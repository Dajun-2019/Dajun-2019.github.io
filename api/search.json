[{"id":"221a7ad001c03569112f684b2dfdc120","title":"Git","content":"Git1.Git整体结构\n\n工作区：电脑里能看到的目录\n暂存区：.git目录下的index文件（.git/index），也叫做索引（index）\n本地版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库\n远程仓库\nGit文件状态\n版本\nHEAD：指向master分支的一个游标，所以出现Head的地方可以用master来替换\n分支\n\n2.常用操作\n查看/修改提交用户名、邮箱\n#查看\n$ git config --list\n$ git config user.name\n$ git config user.email\n#不加--global将只更改本仓库的配置\n$ git config --global user.name &quot;dajunnnnnn&quot;\n$ git config --global user.email &quot;1064049895@qq.com&quot;\n操作流程\n\n初始化：git init，在执行完成 git init命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变\n\n克隆：git clone，从现有Git仓库中拷贝项目，例如git clone https://github.com/Dajun-2019/Learning.git\n\n暂存：git add .，对工作区执行此命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库（.git/objects）中的一个新对象中，而该对象的ID被记录在暂存区的文件索引中\n\n提交：git commit -m &quot;注释信息”，暂存区的目录树写到版本库（对象库）中，master分支会做相应的更新，即master指向的目录树就是提交时暂存区的目录树\n\n远端操作\n\n首先载入远程仓库（git clone…）、然后进入此仓库，执行git remote -v，输出的origin为远程地址的别名\n显示某个远程仓库的信息：git remote show [remote]\n其他命令\n添加远程版本库：git remote add origin git@github.com:Dajun-2019/Learning\n删除远程仓库：git remote rm name\n修改仓库名：’git remote rename old-name new_name’\n\n\n\n\n拉取：git fetch origin master:temp（将远程仓库（origin为别名）的master分支的代码下载到本地分支上面）\n\n拉去代码并合并：$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;\n\n上传远程代码并合并：git push -u origin master，在git中，“push -u”的意思是将本地的分支版本上传到远程合并，并且记录push到远程分支的默认值；当添加“-u”参数时，表示下次继续push的这个远端分支的时候推送命令就可以简写成“git push”\n\n查看状态（git status）：查看仓库当前状态，显示有变更的文件。git status -s简介输出\n\n分支操作\n\n创建分支：git branch (branch name)\n\n查看分支：git branch\n\n切换分支：\ngit checkout (branch name)\n\n\n当执行 git checkout .或者 git checkout -- &lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。\n当执行 git checkout HEAD .或者 git checkout HEAD &lt;file&gt;命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。\n\n\n删除分支：git branch -d (branch name)\n\n合并分支：git merge （branch name）（branch name会被合并到主分支）\n\n\n\n\n\n\nPull Request流程\n\n把别人的代码fork到自己的仓库\n\n在自己的仓库上修改后的分支，摁下New pull request按钮\n\n\n这时，会进入一个新页面，有Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库\n\n\n填写说明，帮助别人理解你的提交，然后按下”create pull request”按钮即可\n\ngit am用于将一个patch文件，合并进入当前代码（Github 对每个 PR 会自动生成一个 patch 文件），可以下载该文件，合并进本地代码，就可以在本地查看效果了\n\nGitHub Flow协作流程\n\n克隆 / Fork 仓库：git clone …\n创建分支: git branch …\n修改代码:\n发起 Pull Request: git\nCode Review\nMerge 分支\n删除分支\n\n\n\n\n\n","slug":"Git","date":"2023-04-20T12:35:53.000Z","categories_index":"","tags_index":"tools","author_index":"Dajunnnnnn"},{"id":"a48e6dda0c21e40880cba7e763278b04","title":"Docker","content":"Docker1.概念\n出现背景：在个人开发环境中，需要大量的虚拟机配置不同的项目环境；在公司内部开发环境中，环境配置不可复用，测试环境与开发环境不匹配，依赖升级需要手动操作；\n\nDocker的口号是“Build，Ship，and Run Any App，Anywhere”\nJava的口号是“Write Once,Run Anywhere”\n\n\nDocker基本概念\n\n引擎：创建和管理容器的工具，通过读取镜像来生成容器，并负责从仓库拉取镜像或提交镜像到仓库中；\n镜像：类似于虚拟机镜像，一般由一个基本操作系统环境和多个应用程序打包而成，是创建容器的模板；\n采用分层存储方式，每个镜像可依赖其他镜像进行构建，每一层的镜像可被多个镜像引用，通过共享镜像层，减少镜像仓库占用空间，对于用户而言，看到的是通过UnionFS（联合文件系统）把相关镜像层的目录“联合”到同一个挂载点呈现出来的一个整体\n在拉取镜像的时候，只会拉去缺少的层，在删除镜像的时候，只会删除没有被共享的层\n\n\n容器：可看作一个简易版的Linxu系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子；\n仓库：集中存放镜像文件的场所，分为公共仓库（Docker Hub）和私有仓库，类似于Git\n宿主机：运行引擎的操作系统所在服务器\n\n\nDocker架构（Docker daemon）\n\n\n命令行工具docker实际上是一个client，他会与Docker Engine里的后台服务Docker daemon通信，镜像存储在远端的Registry里，客户端不能直接访问镜像仓库\nDocker client可以通过build、pull、run等命令向Docker daemon发送请求，而Docker daemon则负责从远端拉去镜像、在本地存储镜像、从镜像生成容器、管理容器等功能\n容器化的应用：指应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行。镜像就是静态的应用容器，容器就是动态的应用镜像\n\n\nDocker隔离实现：是一种应用容器引擎，结合LXC和一些其他技术来实现应用级别容器引擎\n\nLinux提供了Namespace和CGroup技术实现环境隔离和资源控制，其中Namespace是Linux提供的一种内核级别环境隔离的方法，能使一个进程和该进程创建的子进程的运行空间都与Linux的超级父进程相隔离（但只是进程的隔离，物理资源还是进程共用的）；CGroup技术是用来控制一个进程组群可使用的资源（CPU、内存、磁盘IO等），来实现物理资源的隔离\nLinux Container：将Namespace和CGroup相结合，就能构造一个用户空间独立且限定资源的对象，这样的对象称为容器，即LInux Container（Linux提供的容器化技术，简称LXC）。LXC仅为一种轻量级的容器化技术，它仅能对部分资源进行限制，无法做到诸如网络限制、磁盘空间占用限制等（0.7版本取出LXC使用libcontainer，1.11开始使用runC 和 containerd）\n其他技术\nChroot：该技术能在container里构造完整的Linux文件系统；虽然不能直接访问宿主机里的文件，但一般容器都通过包括一个底层的操作系统镜像来弥补\nVeth：该技术能够在主机上虚拟出一张网卡与container里的eth0网卡进行桥接，实现容器与主机、容器之间的网络通信；\nUnionFS：联合文件系统，Docker利用该技术“Copy on Write”（写的时候复制一份副本，在副本上修改）的特点实现容器的快速启动和极少的资源占用，Docker常用的是AUFS\nIptables/netfilter：通过这两个技术实现控制container网络访问策略；\nTC：该技术主要用来做流量隔离，限制带宽；\nQuota：该技术用来限制磁盘读写空间的大小；\nSetrlimit：该技术用来限制container中打开的进程数，限制打开的文件个数等\n\n\n\n\nDocker与虚拟化：虚拟化是依靠一层Hypervisor（软件层）来将虚拟机的指令翻译成物理硬件或宿主机操作系统能识别的指令；而Docker容器里的进程是直接与内核交互的，依靠的Linux的LXC和Chroot等技术，无需中转，几乎没有性能损耗\n\n在启动一个容器时， Docker引擎实际上只是增加了一个可写层和构造了一个Linux容器，这两者都几乎不消耗系统资源，因此Docker容器能够做到秒级启动\n\n为了操作系统镜像占用空间过大的情况，针对不同的场景分别构造了不同的操作系统镜像，包括一下几种：BusyBox（测试场景）、Alpine（生产环境常用）、Debian/Ubuntu、Centos/Fedora\n\n持久化存储：由于都是在可写层里的文件副本进行操作，在容器关闭是，通过以下两种方法实现持久化存储的问题\n\n把宿主机文件系统里的目录映射到容器内的目录，如下图所示。如此一来，容器内在该目录里创建的所有文件，都存储到宿主机的对应目录中，在关闭容器后，宿主机的目录依然存在，再次启动容器时还能读取到之前创建的文件，因此实现了容器的文件持久化。当然同时要明白，如果是对镜像自带文件进行了修改，由于镜像是只读的，该修改操作无法在关闭容器时保存下来，除非在修改了文件后构建一个新的镜像\n\n\n把多台宿主机的磁盘目录通过网络联合为共享存储，然后把共享存储中的特定目录映射给特定的容器，如下图所示。这样容器在重启时，还是能读取到关闭前创建的文件。生产环境中常用NFS作为共享存储方案\n\n\n\n\n\n\n容器的内部机制\n\n文件\n\ndocker cp+源路径+目标路径 命令可以在容器和主机之间互相拷贝文件，适合简单的数据交换，其中目标路径需要用容器名/ID来指明是那个容器的路径，示例：docker cp a.txt 062:/tmp\ndocker run -v命令可以让容器和主机共享本地目录，免去了拷贝操作，提升工作效率，示例：docker run -d --rm -v /tmp:/tmp redis，格式为宿主机路径: 容器内路径，把本机的/tmp路径挂载道容器里的/tmp目录，常用于不同环境运行相同文件\n\n\n网络配置\n\n网络分类：\nhost网络模式让容器与主机共享网络栈，效率高但是容易导致端口冲突，命令为docker run -d --rm --net=host nginx:alpine\nbridge网络模式实现了一个虚拟网桥，容器和主机都在一个私有网段内互联互通，默认使用此模式\n\n\ndocker有一个连接系统允许将多个容器连接在一起，共享连接信息，docker连接会创建一个父子关系，其中父容器可以看到子容器的信息\n新建网络：docker network create -d bridge test-net\n连接容器：\n运行一个容器并连接到新建的 test-net 网络: $ docker run -itd --name test1 --network test-net ubuntu /bin/bash\n打开新的终端，再运行一个容器并加入到 test-net 网络:$ docker run -itd --name test2 --network test-net ubuntu /bin/bash\ntest1和test2可以互相ping通，二者建立了互联关系\n\n\n如果有多个容器，推荐使用Docker Compose\n\n\n\n\n网络端口映射：docker run -p命令可以把主机的端口号映射到容器的内部端口号，解决了潜在的端口冲突\n\n-P：是容器内部端口随机映射到主机的端口，命令为docker run -d -p 5000:5000 training/webapp python app.py\n-p：是容器内部端口绑定到指定的主机端口，还可以附加绑定网络地址，命令为docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py\n\n\n\n\n\n2.常用操作\n安装docker服务\n\n安装docker：sudo apt install -y docker.io\n启动docker服务：sudo service docker start\n当前用户加入docker组：sudo usermod -aG docker $&#123;USER&#125;\n因为操作 Docker 必须要有 root 权限，而直接使用 root 用户不够安全\nDocker官方推荐将当前用户加入 Docker 用户组\n执行完成之后，还需要退出系统（命令 exit ），再重新登录一次，这样才能让修改用户组的命令 usermod 生效\n\n\n验证docker是否安装成功：docker version和docker info\n\n\ndocker 使用\n\n镜像操作命令\n拉取仓库：docker pull [OPTIONS] NAME[:TAG|@DIGEST]\n列出本地已有镜像：docker images\n删除不再使用的镜像：docekr rmi\n\n\n容器操作命令\n启动镜像：docker run\n-it：开启一个交互式操作的Shell\n-d：让容器在后台运行\n--name：为容器起一个名字\n--rm：不保存容器，运行完自动清除\n\n\n列出正在运行的镜像：docker ps\n在容器内执行另一个程序：docker exec\n强制停止容器：docker stop\n再次启动已经停止的容器：docker start\n彻底删除容器：docekr rm\n\n\n\n\n镜像制作\n\n通过正在运行的容器生成新镜像：通过commit命令，把正在运行的容器，叠加上可写层的修改内容，生成一个新镜像。这种方法简单，但是无法直观的设置环境变量、监听端口等内容，适合简单使用的场景\n\n\n通过Dockerfile文件生成新镜像：Dockerfile是一个定义了镜像创建步骤的文件，Docker引擎通过build命令读取Dockerfile，按定义的步骤来一步步构造镜像。在研发和实施环境中，通过Dockerfile 创建容器是主流做法。下面是一个Dockerfile的例子\n\n\ndocker build -f Dockerfile.busybox .（-f后价Dockerfile文件名，后面跟一个文件路径（构建上下文））\n新的镜像暂时没有名字（&lt;none&gt;），可以直接使用ID来查看或运行，可以通过-t参数来指定镜像的标签（tag），名字需要符合规范，用:分割名字和标签\n构建上下文：docker客户端只是把构建上下文目录打包上传，这样服务器才能获得本地的这些文件，就是指定了要打包进镜像的一些依赖文件\n为了避免目录中某些不必要文件（例如 readme/.git/.svn 等）拷贝进镜像，可以在构建上下文目录里再建立一个 .dockerignore 文件，语法与 .gitignore 类似，排除那些不需要的文件\n\n\n更新已有镜像并提交：-m提交的描述信息、-a镜像作者、e218edb10161容器ID、runoob/ubuntu:v2镜像名。可以使用dockr images来查看新镜像，命令为docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2\n\n\nDockerfile内部指令\n\nFROM：所有Dockerfile都要从它开始，表示选择构建使用的基础镜像，相当于打地基，如果关注镜像的安全和大小，一般选择Alpine；如果关注运行的稳定性，则可以选择Ubuntu、CentOS、Debian\nCMD：制定docker run启动容器时默认运行的命令\nCOPY：需要把开发测试产生的一一些源码、配置等文件打包进镜像里，拷贝的源文件必须是构建上下文路径，不能随意指定文件，也就是说，必须把这些文件放在一个专门的目录，然后再docker build里指定构建上下文到这个目录才行\nRUN：执行任意的Shell命令，实现任意的镜像构建步骤，所有RUN指令会在每行的末尾使用续行符\\\\，命令之间也会用&amp;&amp;来连接，这样保证在逻辑上是一行（可以把这些Shell集中到一个脚本文件，然后用COPY命令拷贝进去在用RUN来执行）\nARG：用于创建变量，创建的变量只在镜像构建过程中可见，容器运行时不可见\nENV：用于创建变量，创建的变量不仅能够在构建镜像的过程中使用，在容器运行时也能够以环境变量的形式被应用程序使用\nEXPOSE：用来声明容器对外服务的端口号，对现在基于Node.js、Tomcat、Nginx、Go等开发的微服务系统来说非常有用\n\n\n\n\n\n","slug":"Docker","date":"2023-04-20T12:35:42.000Z","categories_index":"","tags_index":"tools","author_index":"Dajunnnnnn"},{"id":"75ca176d6b382373bec123f05862c849","title":"Java并发","content":"Java并发1.线程\n线程\n\n线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING\n\n\n线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N）\n\nJava使用用户线程模型，上层JVM通过协作式调度来管理这些用户线程，可以在一个线程执行过程中暂停切换到另一线程执行，底层JVM将Java线程映射到操作系统的线程，由操作系统调度和管理\n启动main函数时启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个（主）线程。多个线程共享进程的堆（新建的对象）和方法区资源（已加载的类信息、静态变量、常量、JIT代码），但每个线程有自己的程序计数器、虚拟机栈和本地方法栈\n多线程：减少了上下文的开销，提高了系统的并发能力，减弱IO与CPU的速度差；但会造成死锁、内存泄漏、线程不安全等问题\n\n\n线程安全\n\n线程安全：描述的对象可以是函数也可以是类，线程安全意味者不同线程并发执行相同的函数，或者不同线程执行一个类的不同函数，因为线程切换，函数内的指令都可以任意交叉执行，最终任意执行顺序得到的结果都是相同的，符合预期的\n\n临界区：可能会引起线程不安全的局部代码块，有两个特征，一是访问了共享资源、二是包含复合操作（先检查在执行、先读取再修改后写入）\n&#x2F;&#x2F;先检查再执行\npublic class Singleton &#123;\n    private static Singleton instance;\n    private Singleton()&#123;&#125;\n    public static Singleton getInstance()&#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;先读取再修改后写入\npublic class Demo &#123;\n    private int count &#x3D; 0;\n    public void increment()&#123;\n        count++;\n    &#125;\n&#125;\n同步互斥：用于保证线程安全的访问临界区资源的方法\n\n\n\n\n\n线程创建\n\n实现Runnable接口的run()和start()；继承Thread类重写run方法和start方法，==可用Thread类的已有方法==\n&#x2F;&#x2F;class ThreadDemo extends Thread &#123; 内容同下 &#125; \nclass RunnableDemo implements Runnable &#123;\n   private Thread t;\n   private String threadName;\n   \n   RunnableDemo( String name) &#123; threadName &#x3D; name; &#125;\n   \n   public void run() &#123;\n      &#x2F;&#x2F;线程内需要做的操作\n   &#125;\n   \n   public void start () &#123;\n      if (t &#x3D;&#x3D; null) &#123;\n         t &#x3D; new Thread (this, threadName);\n         t.start ();\n      &#125;\n   &#125;\n&#125;\n通过Callable接口和FutureTask类创建线程，==可创建有返回值的线程（在call函数中实现）==\npublic class CallableThreadTest implements Callable&lt;Integer&gt; &#123;\n    public static void main(String[] args)  \n    &#123;  \n        CallableThreadTest ctt &#x3D; new CallableThreadTest();  \n      \t&#x2F;&#x2F;使用FutureTask包装Callable接口的实现类\n        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);\n        for(int i &#x3D; 0;i &lt; 100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  \n            if(i&#x3D;&#x3D;20)  \n            &#123;  \n                new Thread(ft,&quot;有返回值的线程&quot;).start();&#x2F;&#x2F;call相当于run，但是有返回值  \n            &#125;  \n        &#125;  \n        try  \n        &#123;  \n            System.out.println(&quot;子线程的返回值：&quot;+ft.get());&#x2F;&#x2F;得到call函数的返回值   \n        &#125; catch (InterruptedException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125; catch (ExecutionException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n    &#125;\n    @Override  \n    public Integer call() throws Exception  \n    &#123;  \n        int i &#x3D; 0;  \n        for(;i&lt;100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  \n        &#125;  \n        return i;  \n    &#125;  \n&#125;\n==注意事项==\n\n直接使用Thread类的run方法：new一个Thread类，线程进入NEW状态，调用start方法，启动一个线程并使线程进入READY状态，当分配到时间片后就可以开始运行了，start会执行线程的相应准备工作，然后自动执行run方法的内容，这是真正的多线程工作，但是直接执行run方法，会把run方法当作一个main线程下的普通方法来执行，并不会在某个线程中执行它，所以这并不是多线程工作\nsleep与wait的区别：sleep是Thread类的静态本地方法，wait则是Object类的本地方法\nsleep方法没有释放锁，wait释放了锁\nwait是让获得对象锁的进程实现等待，会自动释放当前线程占有的对象锁，每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）\n因为Sleep是让当前线程暂停执行，不涉及到对象类，所以也不需要对象锁\n\n\nsleep常用于暂停执行，wait方法常用于线程间交互/通信\nwait方法被调用后，线程不会自动苏醒，需要notify方法或notifyAll方法，sleep执行完线程会自动苏醒，或者也可以使用wait(long timeout)超时后自动苏醒\n\n\n\n\n\n\n线程池创建\n\n线程池出现的原因：因为线程过多会增加创建、调度线程的开销，所以通过线程池提前创建若干线程，一方面避免了处理任务时频繁的，创建销毁线程的开销，另一方面避免了线程数量膨胀导致的过分调度问题，并且可以集中管理线程资源，提高系统稳定性\n\nThreadPoolExecutor\n\n基础\n\n继承链\n\nExecutor接口：声明了execute方法，使得用户不需要关注如何创建线程， 只需要传入实现了Runnable接口的线程任务类\nExecutorService接口：声明了执行一批异步生成Future的方法；声明了管控线程池的方法（关闭等方法）\nAbstractExecutorService：将执行任务的流程串联起来，保证下层的实现只需关注一个执行任务的方法\nThreadPoolExecutor：实现复杂的运行部分（维护自身的生命周期、管理线程和任务）\n\n\n参数：corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler\n\n运行状态\n\n\n\n\n池内线程创建过程：首先使用工厂函数针对新任务创建线程直到数量达到核心线程池数量，然后将新任务存储在工作队列中，待工作队列满了之后创建一个新线程来处理任务（没任务一段时间后会被销毁），直到总线程数量达到最大线程池数量后，后续的新任务根据拒绝策略来确定对应操作\n\nworker进程实现了Runnable接口继承自AQS，持有一个线程thread（通过TheradFactory来创建），一个初始化任务firstTask\n确定线程状态：线程池通过一张hash表来保存线程的引用，通过增删引用来控制线程的生命周期。因为使用了AQS锁来实现独占锁，根据独占锁的状态反应线程现在的执行状态\nworker线程增加（addWorker方法）：增加一个线程，有两个参数firstTask和core，根据core的值判断现有线程数在哪个区见\nworker线程的回收：线程池中的回收依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程倍JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可\nworker线程执行任务：worker类中的run方法调用了runWorker方法来执行任务，轮询获取任务，再获取锁，直到没有任务\n\n\n任务与线程的匹配：通过生产者消费者模型，缓存任务，供线程池针对任务进行线程的分配\n\n线程池使用AtomicInteger变量维护：运行状态（runState）和线程数量（workerCount）\n&#x2F;&#x2F;高三位保存runState，低29位保存workerCount\nprivate final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));\n\n\n\n\n示例\n\nThreadPoolExecutor\npublic class ThreadPoolExecutorDemo &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个线程池，包含5个线程\n        ThreadPoolExecutor executor &#x3D; (ThreadPoolExecutor) Executors.newFixedThreadPool(5);\n        &#x2F;&#x2F; 提交10个任务给线程池执行\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            Runnable worker &#x3D; new WorkerThread(&quot;Task &quot; + i);\n            executor.execute(worker);\n        &#125;\n        &#x2F;&#x2F; 关闭线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) &#123;\n            &#x2F;&#x2F; 等待线程池中的任务执行完毕\n        &#125;\n        System.out.println(&quot;All tasks have been completed.&quot;);\n    &#125;\n&#125;\n\nclass WorkerThread implements Runnable &#123;\n    private String taskName;\n\n    public WorkerThread(String taskName) &#123;\n        this.taskName &#x3D; taskName;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot; executing &quot; + taskName);\n        try &#123;\n            &#x2F;&#x2F; 模拟执行任务需要的时间\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nExecutor框架的Executors\n&#x2F;&#x2F;1.创建\nExecutorService service &#x3D; Executors.newFixedThreadPool(10);\n&#x2F;&#x2F;2.执行\nservice.execute(new MyThread());\nservice.execute(new MyThread());\nservice.execute(new MyThread());\nservice.execute(new MyThread());\n&#x2F;&#x2F;3.关闭连接\nservice.shutdown();\n\n\n\n\n\n2.互斥2.1synchronized\n粒度：对象锁（this、newObject）、局部代码锁、类锁（Demo.class）\n\n静态synchronized方法和非静态synchronized方法之间的调用不互斥（一个是类的锁一个是实例对象的锁）\n\n尽量不要使用synchronized(String a)，因为JVM中，字符串常量池具有缓存功能\n\n构造方法不能使用 synchronized 关键字修饰，因为构造方法本身就属于线程安全的，不存在同步的构造方法\npublic synchronized void add(int value) &#123;&#125; &#x2F;&#x2F;方法\nsynchronized (this)&#123;&#125; &#x2F;&#x2F;局部代码块\nsynchronized (obj1) &#123;&#125; &#x2F;&#x2F;内部的一个对象 Object obj1 &#x3D; new Object()\nsynchronized (Wallet.class) &#x2F;&#x2F;类锁\n\n\n锁类别：偏向锁（一个）、轻量级锁（不竞争）、重量级锁（竞争）\n\n通过MarkWork字段辨别锁的类别，新创建的对象处于无锁状态，随后自动变为偏向锁状态，线程可以通过CAS操作竞争偏向锁（单进程使用），竞争成功则执行完任务，执行完后锁会继续保持偏向锁状态，竞争失败则请求线程将锁升级为轻量级锁\n\n升级过程先暂停（JVM的STW）持有锁进程，如其在运行synchronized代码，则升级为轻量级锁（线程交叉使用不存在竞争），否则将MarkWork设置为无锁状态（偏向锁升级代价大，不如直接升级为轻量级锁）\n\n在轻量级锁状态，如果通过（自适应）自旋方式循环执行CAS操作请求锁达到一定数量仍未获得时，就申请升级为重量级锁，唤醒等待重量级锁的进程\n\n锁升级：通过CAS操作，持有锁的线程继续执行，请求锁的线程负责升级任务，包括创建Monitor锁，将自己放到Monitor锁的_cxq中，调用OS系统调用来阻塞自己\n\n解锁：先检查锁标志位，如果没有升级，只需要使用CAS操作解锁即可；如果已升级为重量级锁，那么持有轻量级锁的线程去唤醒等待重量级锁的进程\n\nMonitor锁（hotspot）：\nclass ObjectlMonitor &#123;\n    void * volatile _object;&#x2F;&#x2F;该Monitor锁所属的对象\n    void * volatile _owner;&#x2F;&#x2F;获取到该Monitor锁的线程\n    ObjectWaiter * volatile _cxq;&#x2F;&#x2F;没有获取到锁的线程暂时加入_cxq\n    ObjectWaiter * volatile _EntryList;&#x2F;&#x2F;存储等待被唤醒的线程\n    &#x2F;&#x2F;存储调用了wait()的线程，用来实现wait()、notify()线程同步功能\n\t\t&#x2F;&#x2F;wait、notify等方法也依赖于monitor对象\n    ObjectWaiter * volatile _waitSet;\n    &#x2F;&#x2F;...\n&#125;\n\n\n多个对象通过CAS操作（底层为cmpxchg指令）竞争_owner字段，没有获取到锁的线程加入_cxq队列中等待，待锁释放先通知_EntryList队列中的线程通过CAS操作竞争_owner字段，如果_EntryList队列为空，则将_cxq队列中移到_EntryList队列（一个负责存，一个负责取，减少并发冲突）\n内核线程执行上述步骤没得到锁时，会调用Linux的park函数自行阻塞；阻塞线程获取到锁之后，调用unpark函数来取消对应内核线程的阻塞状态\n\n\n\n\n\n\n锁优化\n\n锁消除：虚拟机在执行JIT编译时，有时会根据对代码的分析(逃逸分析)，去掉某些没有必要的锁（局部变量的锁）\n锁粗化：虚拟机在执行JIT编译时，有时会扩大加锁范围，将对多个小范围代码的加锁，合并一个对大范围代码的加锁（如for循环内的锁）\n\n\n\n2.2锁\n锁类别\n\n可重入锁：可以被同一个线程多次加锁的锁，即在锁没有解锁前，再次加锁，通过变量记录重入次数，JUC提供的锁都是可重入锁\n公平锁：线程会按照请求的先后顺序获得锁。synchronized是非公平锁（新请求可插队），ReentrantLock既支持公平锁也支持非公平锁，默认为非公平锁，通过在构造函数中添加true可声明为公平锁。非公平锁的性能比公平锁更好。ReentrantLock通过AQS（抽象队列同步器）来排队等待锁的线程\n可中断锁：对于synchronized来说，一个线程在阻塞等待锁时，是无法响应中断的，即不可被打断。JUC Lock接口提供了lockInterruptibly()函数，支持可响应中断的方式来请求锁（用于线程池，关闭正在执行的线程）\n非阻塞锁：JUC提供了tryLock()函数，支持非阻塞的方式获取锁，如果锁已经被其他线程获取，则不阻塞直接返回\n可超时锁：JUC提供了带参数的tryLock()函数，支持非阻塞获取锁的同时设置超时时间，tryLock()也可被中断，主要用于对响应时间敏感的系统，如Tomcat\n读写锁：为了提到并发度，可多次获得读锁，JUC提供了ReadWrite接口和其实现类ReetrantReadWriteLock。读锁是一种共享锁，可以被多个线程同时获取，写锁是排他锁，同时只能被一个线程获取，读写锁之间也是排他的（写优先）\n乐观读锁：StampedLock是对ReadWriteLock的进一步优化，提供了读锁、写锁和乐观读锁，其中的读锁和写锁与ReadWriteLock中的类似，乐观读锁是对读锁的进一步优化，在读多写少的时候，大部分读操作都不会被写操作干扰，因此连读锁都不需要加，只有验证真正有被写操作干扰的情况下，再加读锁即可\n\n\nAQS\n\n抽象队列同步器，与synchronized底层的ObjectMonitor类相似，都实现了排队线程、阻塞线程和唤醒线程等功能，但只有一个队列，且基于Java语言实现，是锁实现的原理，在ReentrantLock类有体现（Sync、NofairSync、FairSync都继承自AbstractQueuedSynchronizer）\n\nCLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）\n\n方法\n\nAQS定义了8个模板方法，可以分为两组：独占模式（Lock）和共享模式（Semaphore）\n&#x2F;&#x2F;独占模式\npublic final void acquire(int arg) &#123; ...&#125;\npublic final void acquirelnterruptibly(int arg)throws InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)throws InterruptedException &#123; ...&#125;\npublic final boolean release(int arg) &#123; ...&#125;\n&#x2F;&#x2F;共享模式\npublic final void acquireShared(int arg) &#123; ...&#125;\npublic final void acquireSharedInterruptibly(int arg)throws InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)throws InterruptedException &#123; ...&#125;\npublic final boolean releaseShared(int arg) &#123; ...&#125;\nAQS提供了4个抽象方法：没有声明为abstract是为了减少代码量，更灵活编写代码\n&#x2F;&#x2F;独占模式\nprotected boolean tryAcquire(int arg)&#123;throw new UnsupportedOperationException();&#125;\nprotected boolean tryRelease(int arg)&#123;throw new UnsupportedOperationException();&#125;\n&#x2F;&#x2F;共享模式\nprotected int tryAcquireShared(int arg) &#123;throw new UnsupportedOperationException();&#125;\nprotected boolean tryReleaseShared(int arg) &#123;throw new UnsupportedOperationException();&#125;\n\n\n\n\nReetrantLock：定义了两个继承自AQS的子类：NofairSync和FairSync，分别用来实现非公平锁和公平锁，并且因为底层释放锁的逻辑相同，故又抽象出公共父类Sync（未完待续）\n\nReadWriteLock：读锁不可以转成写锁，但在写锁释放前加读锁，在写锁释放后线程持有的锁自动从写锁降级为读锁（未完待续）\n\nStampedLock：在读写锁的基础上提供了乐观读锁。在读多写少的情况下，大部分操作都不会被写操作干扰，只有在真正被干扰的情况下再加读锁重复执行读操作（未完待续）\n\n\n2.3补充（改成JMM？）\n关键字：volatile、synchronized、final\nvolatile：每次都去主内存读取，修改立即写入内存（c语言中的volatile的意思是禁用cpu缓存）\n解决可见性问题：用volatile修饰的变量，在编译成机器指令时，会加入特殊指令，使得CPU对此变量的修改立即写入内存，并通过其它CPU更新缓存数据\n解决有序性问题：volatile通过禁止指令重排序来解决有序性问题，并且是部分指令重排\n内存屏障：JMM定义了4个细粒度的内存屏障，其底层依赖CPU提供的内存屏障指令（StoreStore、StoreLoad、LoadLoad、LoadStore）分别禁止屏障前后的写写、写读、读读、读写操作重排\nJMM内存模型定义部分禁止重排序的方法：volatile写操作后或者volatile读操作前会添加[StoreLoad]来防止volatile写和读的重排序，一般选择添加在写后面，因为读多写少。\n\n\n解决原子性问题\n在32位计算机上，读写64位的long或double类型数据，会执行两次内存读写操作，如果用volatile修饰，那么编译器会在两次读或写之间锁定总线指令，保证变量读写的原子性，但在64位机上就不需要了\n自增语句（count++）因为是对寄存器的值进行操作，但是volatile对变量只能保证立刻写入内存让所有CPU的缓存失败，所以不能影响寄存器内的值，需要synchronized关键字\n\n\n\n\nsynchronized：通过让原本并发执行的代码串行执行，并且每次加锁和释放锁，都会同步CPU缓存和内存中的数据，可以解决可见性、有序性、原子性的问题\nfinal：JMM对final的语义做了增强，禁止编译器将构造函数中对final变量的写操作，重排序到对象引用之后，也就是禁止初始化对象（构造函数中的语句）和将内存空间赋值给引用的重排序，否则在多线程环境下，一个线程可能看到final变量的两个不同的值\n\n\nsynchronized和volatile有什么区别（互补）\nvolatile关键字是线程同步的轻量级实现，所以性能比synchronized好，但是volatile只能用于变量而synchronized可以修饰方法以及代码块\nvolatile关键字能保证数据的可见性，但不能保证数据的原子性，synchronized关键字两者都能保证\nvolatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性\n\n\nsynchronized和ReentrantLock有什么区别\n相同点：两者都是可重入锁，即线程可以再次获取自己的内部锁，不可重入的此时会产生死锁\nReentrantLock属于可中断锁，获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理；synchronized锁属于不可中断锁，一旦线程申请了锁，就只能等到拿到锁之后才能进行其他的逻辑处理\nsynchronized依赖于JVM（用户不能直接看到代码）而ReentrantLock依赖于API（lock、unlock等方法）\nReentrantLock 比 synchronized 增加了一些高级功能，如可中断锁、公平锁、可超时锁、非阻塞锁、选择性通知（锁可以绑定多个条件）\nsynchronized需要和wait、notify结合才能实现等待/通知机制，ReentrantLock类通过Condition接口和newCondition方法实现\nCondition接口可以实现多路通知功能，也就是在一个Lock对象中可以创建多个Condition实例（对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活\n在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”\nsynchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题\n而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程\n\n\n\n\n\n3.同步2.1条件变量\nObject类：执行wait()或notify()前先加锁、使用while循环避免假唤醒，底层依赖ObjectMonitor\npublic class QueueCond&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      this.notify();&#x2F;&#x2F;通知\n    &#125;\n  &#125;\n  \n  public String get()&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          this.wait();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;\n  &#125;\n&#125;\nCondition接口：使用前后需要lock和unlock，使用中要while，底层依赖ConditionObject（AQS的内部类）\npublic class QueueCondJUC&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  private Lock lock &#x3D; new ReentrantLock();\n  private Condition condition &#x3D; lock.newCondition();\n  \n  private void put(String elem)&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      condition.signal();&#x2F;&#x2F;通知\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n  public String get()&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          condition.await();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n&#125;\n\n2.2信号量（Semaphore）\nSemaphore类\n\n信号量与锁的区别是：释放锁的线程必须持有锁，而信号量则不用。即没有调用acquire()函数的线程也可以直接调用release()函数，用来增加可用许可个数。此时，信号量不再是用来限制对临界区的并发访问，而是用来对共享资源的并发访问\n如果信号量中的许可个数为1，那么信号量就退化成了互斥锁；如果互斥量的许可个数大于1，信号量就可以看作是一种共享锁\n\npublic class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;第一组，默认一次获取或释放的许可（permit）个数为1\n  public void acquire() throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly() &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire()&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release()&#123;&#125;\n\n  &#x2F;&#x2F;第二组，默认制定一次获取或释放的许可个数\n  public void acquire(int permits) throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly(int permits) &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire(int permits)&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(int permits, long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release(int permits)&#123;&#125;\n&#125;\n应用：共享资源并发访问控制\npublic class QueueSemaphore&#123;\n  private static final int Q_SIZE &#x3D; 20;\n  &#x2F;&#x2F;表示队列中的空闲位置\n  private Semaphore semaphore &#x3D; new Semaphore(Q_SIZE);\n  private list&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(Q_SIZE);\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    &#x2F;&#x2F;当可用许可个数为0时，线程执行put函数时会阻塞在acquireUniterruptibly()函数中\n    semaphore.acquireUniterruptibly();\n    synchronized(this)&#123;\n      list.add(count, elem);\n      count++;\n    &#125;\n  &#125;\n  public String get()&#123;\n    if(count &#x3D;&#x3D; 0) return null;\n    synchronized(this)&#123;\n      if(count &#x3D;&#x3D; 0) return null;&#x2F;&#x2F;双重检测\n      String ret &#x3D; list.get(--count);\n      semaphore.release();\n      return ret;\n    &#125;\n  &#125;\n&#125;\n原理\n\n调用semaphore.acquire()，线程尝试获取许可证，如果 state &gt;= 0的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 state的值 state=state-1。如果 state&lt;0的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程\n调用semaphore.release();，线程尝试释放许可证，并使用 CAS 操作去修改 state的值 state=state+1。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 state的值 state=state-1，如果 state&gt;=0则获取令牌成功，否则重新进入阻塞队列，挂起线程。\n\npublic class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;实现AQS，模版模式\n  private final Sync sync;\n  abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n    Sync(int permits) &#123;setState(permits);&#125;\n    protected final boolean tryReleaseShared(int releases) &#123;&#125;\n  &#125;\n\n  static final class NonfairSync extends Sync &#123;\n    NonfairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      return nonfairTryAcquireShared(acquires);\n    &#125;\n  &#125;\n  \n  &#x2F;*\n  final int nonfairTryAcquireShared(int acquires) &#123;\n    for (;;) &#123;\n      int available &#x3D; getState();&#x2F;&#x2F;许可个数存放在state变量中\n      int remaining &#x3D; available - acquires;\n      if (remaining &lt; 0 ||\n          compareAndSetState(available, remaining))\n        return remaining;\n    &#125;\n  &#125;\n  *&#x2F;\n\n  static final class fairSync extends Sync &#123;\n    fairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      for (;;) &#123;\n        if (hasQueuedPredecessors()) return -1;&#x2F;&#x2F;比NonfairSync多了这一行\n        int available &#x3D; getState();\n        int remaining &#x3D; available - acquires;\n        if (remaining &lt; 0 ||\n            compareAndSetState(available, remaining))\n          return remaining;\n      &#125;\n    &#125;\n  &#125;\n\n  public Semaphore(int permits) &#123;&#x2F;&#x2F;默认非公平模式\n    sync &#x3D; new NonfairSync(permits);\n  &#125;\n\n  public Semaphore(int permits, boolean fair) &#123;&#x2F;&#x2F;指定工作模式（公平&#x2F;非公平）\n    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);\n  &#125;\n  &#x2F;&#x2F;暂时省略核心方法的实现\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;acquireUninterruptibly()函数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;位于Semaphore.java中\npublic void acquireUninterruptibly() &#123;\n  sync.acquireShared(1);\n&#125;\n&#x2F;&#x2F;位于AbstractQueuedSynchronizer.java中\npublic final void acquireShared(int arg) &#123;\n  if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争获取许可，返回值&lt;0表示失败，需要排队等待许可\n    doAcquireShared(arg);&#x2F;&#x2F;排队等待许可\n&#125;\n&#x2F;&#x2F;其中tryAcquireShared()函数的代码实现位于NonfairSync和FairSync中，实现见上\n&#x2F;&#x2F;两种实现均通过自旋+CAS的方式获取许可，唯一区别是从等待队列中取还是可以插队\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;release()函数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n2.3Latch&amp;Barrier\nCountDownLatch：等其他线程结束，允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕（是一次性的，不能重复使用）\npublic class DemoJoin&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new RunnableForJoin());\n    THread t2 &#x3D; new THread(new RunnableForJoin());\n    t1.start();\n    t2.start();\n    t1.join();&#x2F;&#x2F;join只用来等待线程执行结束，并且必须知道被等待线程是谁\n    t2.join();\n  &#125;\n  public static class RunnableForJoin implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;业务逻辑\n    &#125;\n  &#125;\n&#125;\npublic class DemoLatch&#123;\n  private static final CountDownLatch latch &#x3D; new CountDownLatch(2);\n  public static void main(String[] args) throws InterruptedException&#123;\n    new Thread(new RunnableForLatch()).start();\n    new Thread(new RunnbaleForLatch()).start();\n    latch.await();&#x2F;&#x2F;等待something执行完成而非等待线程结束，并且不需要知道在等谁\n    &#x2F;&#x2F;执行后续逻辑\n  &#125;\n  public static class RunnableForLatch implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;do something\n      latch.countDown();\n      &#x2F;&#x2F;do otheer thing\n    &#125;\n  &#125;\n&#125;\nCyclicBarrier：CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活\npublic class Demo&#123;\n  &#x2F;&#x2F;创建parties为10的CyclicBarrier对象，用于10个线程之间相互等待，尽管10个线程的启动（执行\n  &#x2F;&#x2F;start函数）的时间不同，但每个线程结束都会调用await函数，将paeties减一，然后检查parties\n  &#x2F;&#x2F;如果不为0，则当前线程阻塞等待，如果parties为0，则当前线程唤醒所有调用了await函数的线程。\n  private static final CyclicBarrier barrier &#x3D; new CyclicBarrier(10);\n  public static void main(String[] args)&#123;\n    for(int i&#x3D;0; i&lt;10; ++i)&#123;\n      new Thread(new Runnbale()&#123;\n        @Override\n        public void run()&#123;\n          try&#123;\n            barrier.await();\n          &#125;catch(InterruptedException e)&#123;&#x2F;&#x2F;当前线程被中断\n            e.printStackTrace();\n          &#125;catch(BrokenBarrierException e)&#123;&#x2F;&#x2F;其他线程调用await()期间被中断\n            e.printStachTrace();\n          &#125;\n          &#x2F;&#x2F;执行业务逻辑\n        &#125;\n      &#125;).start();\n    &#125;\n    &#x2F;&#x2F;主线程需要等待以上10个线程执行结束，方法有以下3种：\n    &#x2F;&#x2F;1.sleep() 2.join() 3.CountDownLatch()\n  &#125;\n&#125;\n\n4.JUC1.并发阻塞（xxxBlockingQueue）\n\n\n\n\n\n\n\n\n线程安全和支持读写阻塞，阻塞并发队列一般用于实现生产者-消费者模型\n\nxxxBlockingQueue：ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue的实现原理类似，都是基于ReentrantLock锁来实现线程安全，基于Condition条件变量来实现阻塞等待\nArrayBlockingQueue：有界队列实现类，底层采用数组来实现，一旦创建容量不能改变\n使用方法和普通队列类似，只不过增加了读写可阻塞，支持公平和非公平两种工作模式，默认为非公平\n支持读写阻塞的put和take函数（ReentrantLock+Condition）\n非阻塞的offer和poll函数，只通过ReentrantLock锁来保证线程安全，没有通过条件变量来实现阻塞读写\n\n\nLinkedBlockingQueue：基于链表实现的有界阻塞并发队列，默认大小为Integer.MAX_VALUE，可以指定队列大小\nLinkedBlockingDeque：与LinkedBlockingQueue的区别在于，它是一个双端队列，支持两端读写操作\nPriorityBlockingQueue：是一个无界阻塞并发优先级队列，底层基于支持扩容的堆来实现，写操作永远不需要阻塞，只有读操作会阻塞，不可插入null值且插入对象必须可比较大小（comparable）\n\n\nDelayQueue\n延迟阻塞并发队列，底层基于PriorityQueue来实现，因为PriorityQueue支持动态扩容，所以DelayQueue为无界队列，写永远都不会阻塞，只有读会阻塞\nDelayQueue中存储的每个元素都必须实现Delayed接口，提供延迟被读取时间delayTime，PriorityQueue按照delayTime的大小将元素组织成最小顶堆，也就是说，堆顶的元素是delayTime最小的元素，应该最先被读取到\ntake函数，包含两个逻辑，针对leader线程的逻辑和针对非leader线程的逻辑。当多个线程先后调用take函数，第一个线程就是leader线程，剩下的就是非leader线程。第一个线程执行读取操作完成之后，第二个线程便称为leader线程。\n非leader线程直接调用await函数阻塞，等待leader线程执行完成之后调用signal来唤醒\nleader线程读取的是队首的元素，如果队首的元素delayTime大于0，那么leader线程会调用awaitNanos阻塞delayTime时间，当delayTime时间过去之后，leader线程自动唤醒，为了避免假唤醒（插队情况见下），leader线程会检查队首元素的delayTime是否真正变为小于等于0，如果是，则队首元素出队，调用signal唤醒第二个线程，第二个线程就成了leader线程\n插队情况：如果一个线程执行take函数时，如果检查发现队列不为空，并且队首元素的delayTime小于等于0，于是，不管是不是有其他线程在调用await或awaitNanos阻塞等待，这个线程都会直接读取队首元素并返回\n\n\n\n\n较少使用\nSynchronousQueue：用于两个线程之间传递数据，每个put操作必须阻塞等待take操作，队列中不存储任何元素\nLinkedTransferQueue：基于链表实现的无界阻塞并发队列，是LinkedBlockingQueue和SynchronousQueue的综合体，提供了transfer函数，跟SynchronousQueue的put函数的功能相同，调用transfer的线程会一直阻塞，直到数据被其他线程消费才会返回\n\n\n\n2.分段加锁（ConcurrentHashMap）\n原理\n底层数据结构：ConcurrentHashMap底层采用数组+链表/红黑树（1.7使用分段数组+链表）\n实现线程安全的方式\nJDK1.7的ConcurrentHashMap：对整个桶数组进行分割分段，每一把锁只锁其中的一部分数据，多线程访问不同段的数据就不会产生锁竞争\nJDK1.8的ConcurrentHashMap：直接用Node数组+链表/红黑树来实现，并发控制使用synchronized和CAS来操作\nTreeNode是存储红黑树节点，被TreeBin包装，TreeBin通过root属性维护红黑树的根节点，因为红黑树在旋转的时候，根节点可能会被它原来的子节点替换掉，在这个时间点如果有其他线程要写这颗红黑树就会产生线程不安全问题，所以在ConcurrentHashMap中TreeBin通过waiter属性维护当前使用这颗红黑树的线程，来防止其他线程的进入\n\n\nConcurrentHashMap比HashTable效率高的原因：ConcurrentHashMap中，table数组被分段加锁，如果table数组的大小为n，那么就对应存在n把锁，每一个链表独享一把锁，不同链表之间的操作可以多线程并行执行，互不影响，以此来提高并发性能。而HashTable使用synchronized（同一把锁）来保证线程安全，效率低，当一个线程使用put时，另一个线程既不能使用put，也不能使用get\n\n\nConcurrentHashMap类（未完待续）\n\n3.写时复制（CopyOnWriteArrayList、CopyOnWriteArraySet）\n主要应用于并发容器中，为了避免读操作和写操作（增、删、改）同时发生而产生的线程安全问题，写时复制将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作，而对读操作继续在原始容器上进行，这样读写之间不会存在数据访问冲突，当写操作执行完成后，新创建的容器替代原始容器\n这样读操作完全不需要加锁，写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待\n\n\n弱一致性：CopyOnWriteArrayList源码显示，写操作的结果并非对读操作立即可见，这就导致了短暂的数据不一致，称为弱一致性，在某些业务场景下，会引发bug\n解决办法：CopyOnWriteArrayList提供了用于遍历容器的迭代器\n\n\n连续存储：JUC提供了CopyOnWriteArrayList、CopyOnWriteArraySet，却没有提供CopyOnWriteLinkedList、CopyOnWriteHashMap等其他类型的写时复制容器的原因：因为执行写操作需要复制整个数据，对于链表和哈希表来说，因为数据在内存中不是连续存储的，所以耗时非常大，写操作的性能无法满足工业级通用类对性能的要求。CopyOnWriteArrayList、CopyOnWriteArraySet底层都是基于数组来实现的，而且使用了JVM底层提供的native方法，通过C++代码中的指针实现了内存块的快速拷贝\n\n5.无锁编程\nCAS：CAS指的是先检查后更新这类复合操作，全称为Compare And Set或Compare And Swap。在CAS操作失败后，可以选择自旋直到CAS成功 或 执行失败处理相关的业务逻辑\n原子类：原子类的每个操作都可以看成是原子操作，在多线程环境下，执行原子类的操作不会出现线程安全问题\nLongAdder：（未完待续）\nThreadLocal：使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全。其作用域范围介于类的成员变量和函数内局部变量之间，既是线程私有的，又可以在函数之间共享，不但避免了线程安全问题，还能避免参数传递带来的代码耦合问题\nUnsafe类：（未完待续）\nFuture类：（未完待续）\n\n","slug":"Java并发","date":"2023-04-13T23:56:43.000Z","categories_index":"","tags_index":"language","author_index":"Dajunnnnnn"},{"id":"b4296f0600f693552b5b6c6b665f6025","title":"Java特性","content":"Java1.关键字\ntrue, false, 和 null 虽然不是关键字，但它们是不能用作标识符的文字和保留字\nstrictfp（精确浮点数，跨平台产生相同结果）、native（原生方法）\n\n\n\n\n\nclass\nreturn\nbyte\ntry\nif\n\n\n\nimport\npublic\nboolean\ncache\nelse\n\n\nextends\nprotected\nshort\nfinally\nfor\n\n\nimplements\nprivate\nint\nthrow\nwhile\n\n\nenum\n==final==\nchar\nthrows\ndo\n\n\ninterface\n==static==\nlong\nresource\nswitch\n\n\npackage\nabstract\nfloat\n==volatile==\ncase\n\n\nnew\nnative\ndouble\n==synchronized==\ndefault\n\n\nsuper\nconst\nvoid\n==transient==\nbreak\n\n\nthis\ngoto\ninstanceof\nstrictfp\ncontinue\n\n\n2.概念辨析\n值传递与引用传递\n\n引用类型（数组、接口、类）的数据存储在堆上，栈上存储的是堆的地址，直接更改对象对所有引用都可见，但不能像C++那样让引用指向新的对象\n引用数据判等：==判断两个引用是否指向同一对象，equals方法+重写的hashcode方法判断属性是否相等\n\n\n深拷贝、浅拷贝、引用拷贝\n\n深拷贝与浅拷贝：深拷贝会复制整个对象，包括对象包含的内部对象；浅拷贝会在堆上创建一个新对象，但是对象内部引用类型变量只会复制引用地址，不会直接复制内部数据\n\n引用拷贝：两个不同引用指向同一对象\n\n示例\npublic class Address implements Cloneable&#123;\n    private String name;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Address clone() &#123;\n        try &#123;\n            return (Address) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n\npublic class Person implements Cloneable &#123;\n    private Address address;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Person clone() &#123;\n        try &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;浅拷贝\n            Person person &#x3D; (Person) super.clone();\n            return person;\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;浅拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; true\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());\n\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;深拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@Override\npublic Person clone() &#123;\n    try &#123;\n        Person person &#x3D; (Person) super.clone();\n\t\t\t\t&#x2F;&#x2F;深拷贝\n        person.setAddress(person.getAddress().clone());\n        return person;\n    &#125; catch (CloneNotSupportedException e) &#123;\n        throw new AssertionError();\n    &#125;\n&#125;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; false\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());\n\n\n重载和重写的区别\n\n重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理（如构造函数）；重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法（如Override）\n如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的\n\n\n接口和抽象类\n\n共同点：都不能被实例化、都可以包含抽象方法，都可以有默认实现方法（default声明，子类可不实d现）\n不同点：\n接口主要是对API声明（参数类型、返回值类型、函数名），抽象类主要是为了代码复用\n一个类可以实现多个接口，但只能继承自一个抽象类\n接口中的成员变量只能是public static final类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可被重新赋值\n\n\n\n\nfinal和static\n\n只有成员变量能被static、public、protected、private修饰，局部变量不行，但是两者都能被final修饰\n\n\n引用类型转换：仅限于有继承关系的类之间，分为向上转换和向下转换两种\n\n向上转换，自动类型转换，总是可以的\n向下转换需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已\n\n\n\n3.语法糖\nswitch支持String与枚举：int比数、char比ascii码、字符串用hashCode()和equals()，其它如short、byte、int都需要转换为整数\n\n泛型和类型擦除：编译时会使用泛型做类型检查，但是当代码编译为字节码之后，泛型中的类型参数和通配符都替换为上界限（==类型擦除==）\n\n泛型遇到重载：因为都会转成父类型，所以List&lt;String&gt;和List&lt;Integer&gt;这种重载会编译失败\n\n当泛型遇到catch：泛型的类型参数不能用在catch语句中，因为异常处理是由JVM在运行时刻来进行的，类型信息被擦除了，所以JVM是无法区分两个异常类型MyException&lt;String&gt;和MyException&lt;Integer&gt;的\n\n创建对象时：不能使用new T()来创建类型参数对象，在代码编译成字节之后类型信息已经擦除，所以，在运行时，JVM无法确定具体类型，也就无法知道T是否存在无参构造函数\n\n当泛型内包含静态变量：由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的\npublic class StaticTest&#123;\n    public static void main(String[] args)&#123;\n        GT&lt;Integer&gt; gti &#x3D; new GT&lt;Integer&gt;();\n        gti.var&#x3D;1;\n        GT&lt;String&gt; gts &#x3D; new GT&lt;String&gt;();\n        gts.var&#x3D;2;\n        System.out.println(gti.var); &#x2F;&#x2F;输出为2\n    &#125;\n&#125;\nclass GT&lt;T&gt;&#123;\n    public static int var&#x3D;0;\n    public void nothing(T x)&#123;&#125;\n&#125;\n因为需要继承自Object，所以基本类型不可以传入类型参数，只有引用类型可以。但是有语法糖可以让List&lt;int&gt;中的int替换为Integer，但是开发上依旧需要为每个基本类型分别定义多个不同的函数接口\n\n\n\n自动装箱与拆箱：原始类型byte, short, char, int, long, float, double, boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean\n\n基本类型和包装类型的区别：包装类型不赋值时是null，可用于范型，占用空间大\n\n基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中（JIT优化，逃逸分析，分配到栈上）\n基本数据类型存放在栈中是一个常见的误区！基本数据类型的成员变量如果没有被 static修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中\n类静态成员变量存放在方法区中！（方法区又叫静态区，跟堆一样，被所有线程共享，方法区包含所有的class和static变量）\n\n\n常量池\n\nInteger等包装类使用了常量池技术，IntegerCache类（享元模式）中会缓存值为-128到127之间的Integer对象，当通过自动装箱，也就是调用valueOf()来创建Integer对象时，如果要创建的Integer对象的值在-128到127之间，会从IntegerCache中直接返回，否则才会真正调用new方法创建，详见Integer类的valueOf()（JVM也提供了方法，可以自定义缓存的最大值）\n\nByte、Short、Integer、Long这四种包装类默认创建了数值[-128,128]的相应类型的缓存数据（存放在一个Cache数组中，由static代码块直接初始化），Character创建了数值在[0，127]范围的缓存数据，Boolean直接返回True或False（return (b ? TRUE : FALSE);）\n\n所有整型包装类对象之间值的比较，全部使用 equals 方法比较\nInteger i1 &#x3D; 40; &#x2F;&#x2F;触发自动装箱，使用缓存中的对象\nInteger i2 &#x3D; new Integer(40); &#x2F;&#x2F;新创建的对象\nSystem.out.println(i1&#x3D;&#x3D;i2); &#x2F;&#x2F;返回false\n\n\n示例代码：项目首选基本类型，业务相关可选包装类用null表示空而不是0\n&#x2F;&#x2F;自动装箱，语法糖，底层实现为：Integer iobj &#x3D; Integer。valueOf(12);\nInteger iobj &#x3D; 12;\n&#x2F;&#x2F;自动拆箱，语法糖，底层实现为：int i &#x3D; iobj.intValue();\nint i &#x3D; iobj;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;触发自动装箱和拆箱的几种情况&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;将基本类型数据赋值给包装类变量（包括参数传递）时，触发自动装箱\nint i1 &#x3D; 5\nInteger iobj1 &#x3D; 5;&#x2F;&#x2F;1\niobj &#x3D; i1;&#x2F;&#x2F;1\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(i1);&#x2F;&#x2F;1\n&#x2F;&#x2F;将包装类对象赋值给基本类型变量（包括参数传递）时，触发自动拆箱\nInteger iobj2&#x3D; new Integer(6);\nint i2 &#x3D; iobj2;&#x2F;&#x2F;2\n&#x2F;&#x2F;当包装类对象参与算术运算、关系运算（&lt;,&gt;）时，触发自动拆箱操作\nInteger iobj3 &#x3D; iobj1 + iobj2;\nboolean bl &#x3D; (iobj1 &lt; iobj2);\nbl &#x3D; (iobj1 &lt; 2);\n&#x2F;&#x2F;当包装类对象参与关系运算（&#x3D;&#x3D;），且另一方是基本类型数据时，触发自动拆箱操作。\nInteger iobj4 &#x3D; new Integer(123);\nbl &#x3D; (iob4 &#x3D;&#x3D; 123);\n\n\n方法变长参数：String… args用一个数组实现，用foreach遍历，编译后会被转变成数组\n\n枚举：当我们使用enum来定义一个枚举类型的时候，编译器会自动创建一个final类型的类继承Enum类，所以枚举类型不能被继承（public enum t&#123;&#125; =&gt; public final class T extends Enum&#123;&#125;）\n\n内部类：\n\n会独立于外部类，生成一个新的class文件，名字为外部类名$内部类名.class或外部类名$[序号].class，静态匿名内部类可访问静态成员变量+静态函数；普通匿名内部类不可访问外部函数中非final修饰的局部变量\n外部函数通过类似参数传递的方式，将局部变量通过值传递的方式传入到匿名内部类，这是外部函数局部变量的副本，所以如果能访问非final修饰的局部变量的话，内部类对其的更改不起作用，违反直觉，类似于形参的改变不影响实参\n\npublic interface I&#123;&#125;\npublic class A&#123;\n    private class B&#123;&#125; &#x2F;&#x2F;类似于ArrayList的内部类Itr\n    private class C implements I&#123;&#125;&#x2F;&#x2F;实现外部接口的内部类\n    public class D&#123;&#125;&#x2F;&#x2F;public修饰的内部类\n\t\tpublic static class E&#123;&#125;&#x2F;&#x2F;静态内部类\n    \n    public B getB()&#123; return new B(); &#125;\n    public I getC()&#123; return new C(); &#125;\n    public D getD()&#123; return new D(); &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.B b &#x3D; a.getB();&#x2F;&#x2F;编译报错，满足封装原则\n        I c &#x3D; a.getC();&#x2F;&#x2F;可访问\n        A.D d1 &#x3D; a.getD();\n        A.D d2 &#x3D; a.new D();\n\t\t\t\tA.E e &#x3D; new A.E();&#x2F;&#x2F;静态内部类的对象可以独立于外部类单独创建\n    &#125;\n&#125;\n条件编译：if的条件是final且为false时，对应代码块不被编译，主要出于对代码优化的考虑\n\n断言：其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行\n\n数值字面量：不管是整数还是浮点数，都允许在数字之间插入任意多个下划线，为了方便阅读\n\n增强for循环：for-each用了普通的for循环和Iterator迭代器的hasNext()方法，在遍历过程中不能增删内部元素，会抛出异常（可以使用Iterator.remove()方法在删除当前迭代对象的同时维护索引的一致性）\n\ntry-with-resource：在try()中写资源申请，就不用在finally中判断是否为null在关闭了，编译期帮助我们关闭了（资源类需要实现Java.lang.AutoClosale接口）\n\nlambda表达式：只有一个函数的接口叫做函数式接口，可以用Lambda表达式简化\n\nLambda表达式\n(类型 a,类型 b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\n(a,b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\na-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a为输入参数\n&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;没有入参\n方法引用：当Lambda中的逻辑已经有现成的方法实现时，可以直接使用方法引用。方法引用要求所引用的方法的参数列表的返回值，跟函数接口中未实现方法的参数列表和返回值完全一致，格式如下\n&#x2F;&#x2F;对象::实例方法\n&#x2F;&#x2F;类::静态方法\n&#x2F;&#x2F;类::实例方法\npublic class FPDemo &#123;\n    public static void main(String] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n\t\t\t\t\t\t&#x2F;&#x2F;直接引用String的方法\n            .filter(((Predicate&lt;String&gt;) String::isEmpty).negate())\n            &#x2F;&#x2F; .filter(s-&gt;s.isEmpty())\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            .map(String::length)\n            &#x2F;&#x2F;.map(s-&gt;s.length())\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;\n\n\n\n4.特殊语法\n反射：在运行的过程中动态告知JVM去创建对象、创建方法、获取类信息（构造函数、方法、成员变量、注解），重要应用见Spring框架的依赖注入\n\nClass类：是一个存储类的信息的特殊的类，提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等\n\nConstructor类：用来存储构造函数的信息，如通过newInstance()方法来进行有参/无参构造\nMethod类：存储方法的信息，如通过invoke()方法可以执行类中的对应方法\nField类：用来存储成员变量的信息\n\n\n获取反射的三种方法\n\n通过对象获取反射\nObject obj &#x3D; new Object(); &#x2F;&#x2F; 创建一个对象\nClass&lt;?&gt; clazz &#x3D; obj.getClass(); &#x2F;&#x2F; 获取 Class 对象\n通过类名获取反射\nClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.example.MyClass&quot;); &#x2F;&#x2F; 获取 Class 对象\n通过类字面常量获取反射\nClass&lt;?&gt; clazz &#x3D; MyClass.class; &#x2F;&#x2F; 获取 Class 对象\n\n\n反射攻击：在Constructor、Method、Field类，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限public void setAccessible(boolean flag)，利用这个方法，可以将私有的构造函数、方法、成员变量设置为可以访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量（打破单例类只能实例化一个对象的限制的情况）\n\n\n\n注解：注解相当于给元素打了一个tag，任何编译器或者应用程序通过反射可以访问的代码元素，都可以用注解去标识\n\n自定义注解：通过反射来读取注解，重要应用为Spring用注解代替XML配置文件\n&#x2F;&#x2F;Java内建注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override &#123;\n&#125;\n\n&#x2F;&#x2F;自定义注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimit &#123;\n\tpublic enum TimeUnit &#123; SECOND,MINUTE, HOUR, DAY,MONTH&#125;\n    string apiName();\n\tint limitCount();\n\tTimeUnit timeUnit() default TimeUnit.SECOND;\n&#125;\n元注解\n\n@Target：用来描述注解的使用范围（如类、接口、方法、成员变量等）\n@Retention：用来描述注解的可见范围、或叫生命周期（如源码可见、字节码可见、运行时可见）\n@Documented：表示注解信息会输出到Javadoc文档中\n@interface：class、interface、enum、@interface这四者是平级关系，@interface用来定义注解，在注解中，还可以定义一些变量，特殊的是注解使用方法来定义变量，对于只有一个变量的注解，可以将其定义为value，这样，在使用时，可以不指定变量的名称\n\n\n实践应用\n\n替代注释：Guava提供@VisibleForTesting注解在方法上进行标记，这个注解只起到注释的作用，并没有实际的作用\n作为标记：Java中有一种特殊的接口，叫做标记接口（Marker Interface）。标记接口中不包含任何方法，跟注解类似，起到标记作用，比如RandomAccess、Cloneable、Serializable，可以根据标记接口判断对象是否可以执行某些操作\n替代XML文件\n@Configuration注解修饰的类中的@Bean创建首字母小写的对象\n@Component注解创建同名对象，使用@Autowired注入对象\n\n\n\n\n\n\n动态代理（==未完待续==）\n\n静态代理：通过实现接口或继承的方式，通过注入原始类并添加新功能的方式实现。实现简单，但会导致项目中的类成倍增加，所有相关的类都需要增加代理类，重复代码多\n动态代理\n一般静态指的编译阶段，动态指的运行阶段。在代理模式上，静态代理指的是在编译阶段时生成代理类的字节码，动态代理指的是运行时生成代理类的字节码，且字节码只存在与内存中，并不会生成对应的class文件\n之所以可以实现动态代理，是因为JVM设计得非常灵活，只要是符合类的格式的字节码，都可以在运行时被JVM解析并加载，不管这个字节码是来自预先编译好的(class文件)，还是在内存中临时生成的(典型应用:动态代理)，又或者从网络加载而来的(典型应用: Applet)。这部分内容涉及到JVM的类加载机制，见JVM\n实现方法一：利用JDK提供的类来实现（InvocationHandler接口+Proxy类）\n实现方法二：使用第三方的字节码类库来实现，比如CGLIB、BECL、ASM、Javassit等直接编辑字节码\n\n\n\n\n\n\n\n5.工具类5.1String\nString不可变的原因\nfinal修饰的数组，数组内容是可变的private final char value[];\n但是String没有暴露更改该数组的公共方法\n因为String类是final修饰的，所以子类无法继承，避免了子类破坏String的不可变性\n\n\n常量池技术\nString类型跟Integer等包装类类似，使用常量池技术，并且==只有使用字符串常量赋值时，才触发==，如果字符串常量在常量池中已经创建过，则直接使用已经创建的对象。用new创建的对象不在常量池中\n除了使用字符串常量赋值外，还可以使用intern()方法，将分配在堆上的String对象，原模原样在常量池中复制一份。当无法用字符串常量赋值，但又有大量重复字符串时，就可以使用intern()方法复制到常量池中，代码中使用常量池中的String对象，原String对象就被JVM回收掉\n\n\n其它\nsubstring()\nsubstring(int beginIndex, int endIndex)方法截取并返回下标在[beginIndex, endIndex)范围内的子串\n在JDK7及其以上版本中，substring()方法会生成新的String对象来存储子串，但如果传入参数正好等于字符串的长度，那么会返回字符串本身，不会创建新对象\n在JDK6及以前的版本，通过substring()方法获取到的子串会共享char数组，并有count和offset属性标志子串的长度和起点\n\n\n运算符重载：C++能直接重载运算符，但Java并不支持（重载运算符是函数式编程、并且语法太复杂），但是String类却实现了加法操作String sc = sa + sb;，主要是因为String比较常用，所以延续了基本类型及其包装类的设计，这样使用起来就方便和统一\nStringBuilder与StringBuffer\n因为String不可变，用+拼接效率低，每次都需要创建新的String对象，所以Java设计了StringBuilder\nStringBuilder支持修改和动态扩容，可以用append()函数拼接，可以把StringBuilder看作是char类型的ArrayList（ArrayList）\n在平时开发中，经常用+号连接多个字符串，实际上底层就采用StringBuilder来实现\nStringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。\n相同情况下使用 StringBuilder相比使用 StringBuffer仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n\n\n\n\n5.2JCF框架\nArrayList动态扩容：在增加元素的时候要检测是否需要扩容，首先确定最小扩容量（最小是10），然后判断是否需要扩容（最小扩容量大于当前数组长度），执行grow函数进行扩容，扩容为原来的1.5倍，如果不够的话就直接使用最小扩容量来作为长度，避免多次扩容，若是1.5倍长度大于数组最大长度，则需要看最小扩容量是否大于最大容量，如果是则为MAX_VALUE否则为MAX_VALUE-8\npublic boolean add(E e) &#123;\n    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!\n    elementData[size++] &#x3D; e;\n    return true;\n&#125;\n\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;确定是否需要扩容，主要用在添加大量元素之前，减少增量分配的次数，通过提前扩容，可以提升性能&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic void ensureCapacity(int minCapacity) &#123;\n    int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n        &#x2F;&#x2F; any size if not default element table\n        ? 0\n        &#x2F;&#x2F; larger than default for default empty table. It&#39;s already\n        &#x2F;&#x2F; supposed to be at default size.\n        : DEFAULT_CAPACITY;\n\t\t&#x2F;&#x2F;如果期待最小容量大于已有的最大容量\n    if (minCapacity &gt; minExpand) &#123;\n        ensureExplicitCapacity(minCapacity);\n    &#125;\n&#125;\n&#x2F;&#x2F;得到最小扩容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) &#123;\n    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    &#125;\n    return minCapacity;\n&#125;\n&#x2F;&#x2F;得到最小扩容量，通过最小扩容量扩容\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n&#x2F;&#x2F;判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) &#123;\n    modCount++;\n\n    &#x2F;&#x2F; overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n\t\t\t\t&#x2F;&#x2F;调用grow方法进行扩容，调用此方法代表已经开始扩容了\n        grow(minCapacity);\n&#125;\nprivate void grow(int minCapacity) &#123;\n    &#x2F;&#x2F;oldCapacity为旧容量，newCapacity为新容量\n    int oldCapacity &#x3D; elementData.length;\n    &#x2F;&#x2F;将oldCapacity 右移一位，其效果相当于oldCapacity &#x2F;2，\n    &#x2F;&#x2F;我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);\n    &#x2F;&#x2F;然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity &#x3D; minCapacity;\n    &#x2F;&#x2F;再检查新容量是否超出了ArrayList所定义的最大容量，\n    &#x2F;&#x2F;若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n    &#x2F;&#x2F;如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为MAX_ARRAY_SIZE。\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity &#x3D; hugeCapacity(minCapacity);\n    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:\n    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n&#125;\n&#x2F;&#x2F;比较minCapacity和MAX_ARRAY_SIZE\nprivate static int hugeCapacity(int minCapacity) &#123;\n    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n&#125;\nHashMap\n\nSet容器包括HashSet、LinkedHashSet、TreeSet，从代码实现上来说，这三个类底层分别是依赖HashMap、LinkedHashMap、TreeMap。例如：往HashSet中存储对象obj，底层将obj作为key，一个空的Object对象作为value，一并存储到HashMap中\n\n底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）\n&#x2F;&#x2F; 包含另一个“Map”的构造函数\n public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);&#x2F;&#x2F;下面会分析到这个方法\n &#125;\nfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;\n    int s &#x3D; m.size();\n    if (s &gt; 0) &#123;\n        &#x2F;&#x2F; 判断table是否已经初始化\n        if (table &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-size\n            &#x2F;&#x2F; 未初始化，s为m的实际元素个数\n            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;\n            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            &#x2F;&#x2F; 计算得到的t大于阈值，则初始化阈值\n            if (t &gt; threshold)\n                threshold &#x3D; tableSizeFor(t);\n        &#125;\n        &#x2F;&#x2F; 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s &gt; threshold)\n            resize();\n        &#x2F;&#x2F; 将m中的所有元素添加至HashMap中\n        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;\n            K key &#x3D; e.getKey();\n            V value &#x3D; e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        &#125;\n    &#125;\n&#125;\n哈希函数\nstatic final int hash(Object key) &#123;\n    int h;\n\t\t&#x2F;&#x2F;key为null的值存储在下标为0的位置，但一个HashMap只能存储一个值为null的key\n\t\t&#x2F;&#x2F;hashCode底层为JNI，定义在Object类中，根据对象在内存中的地址来计算哈希值，子类中可以重写\n\t\t&#x2F;&#x2F;h^(h&gt;&gt;&gt;16)：数组长度一般不超过2^16，所以通过将h的高16位和低16位异或，来增加参与运算的信息\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n&#x2F;&#x2F;确定插入数组时的位置，使用位操作与数组长度n进行取模计算（前提是n为2的幂次方），防止索引越界\nint index &#x3D; hash(key)&amp;(n-1); &#x2F;&#x2F; n-1为 11111，与其进行&amp;运算，相当于对n取余数\n\npublic V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;&#x2F;&#x2F; hash表不为空，待查找链表有值\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node，先查hash(key)，再查key.equals()\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;检测是否哈希冲突\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            if (first instanceof TreeNode) &#x2F;&#x2F;已经树化，进行树上的查找\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);&#x2F;&#x2F;未树化，进行链表上的遍历查找\n        &#125;\n    &#125;\n    return null;\n&#125;\n装载因子：table大小（n）和装载因子（loadFactor）可以用默认的也可以通过构造函数传入，一般为0.75：\n\n权衡时间效率和空间效率之后的结果\n大概是[0.5,1]之间，因为小于0.5会有一半空间从来未用，当大于1时，哈希冲突的概率会大大增加，即使有链表和树化，也会影响性能\n因为table数组的大小n都是2的倍数，而且触发扩容的阈值threshold = n * loadfactor，所以，在[0.5,1]之间，只有0.75能使得得到的阈值一直是整数\n\npublic HashMap(int initialCapacity, float loadFactor) &#123;\n\t\t&#x2F;&#x2F;...initialCapacity和loadFactor的可行性检验代码...\n    this.loadFactor &#x3D; loadFactor;\n\t\t&#x2F;&#x2F;直接赋值的原因：此时table数组只声明未创建，其值为null，在第一次调用put()函数后，\n\t\t&#x2F;&#x2F;HashMap会先用threshold作为数组大小创建table数组，再将其重新赋值为真正的扩容阈值\n\t\t&#x2F;&#x2F;this.table &#x3D; new T[this.threshold];\n\t\t&#x2F;&#x2F;this.threshold *&#x3D; this.factor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);\n&#125;\n&#x2F;&#x2F;initialCapacity需要是2的幂次方，如果不是，需要寻找比initialCapacity大的第一个2的幂次方数\nstatic final int tableSizeFor(int cap) &#123; &#x2F;&#x2F; 1100  12 应该返回 10000\n    int n &#x3D; cap - 1; &#x2F;&#x2F; 1011\n    n |&#x3D; n &gt;&gt;&gt; 1; &#x2F;&#x2F; 0101 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 2; &#x2F;&#x2F; 0011 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 4; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 8; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 16; &#x2F;&#x2F; 0000 - 1111\n    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#x2F;&#x2F; 10000 16\n&#125;\n动态扩容：put后，若元素个数超过threshold=n*loadFactor时触发（n为table大小，loadFactor为装载因子）\n\nHashMap的默认初始化大小为16，之后每次扩充容量为原来的2倍，如果指定了大小，也会选择2的幂次来作为初始值\n因为Hashmap的容量大小是2的幂次方，所以可以通过&amp;运算来优化%运算。例如：（16 % 5 ）等价于 （16 &amp; （5 - 1））\n为了能把数据分配均匀，Hash值的范围是-2147483648 到 2147483647，很难碰撞，但是需要对数组取模，操作如上\n\n\n因为容量变大，位置会发生变化，将每个节点的hash值与新的容量取模，取模操作仍可以用位运算来替代，但JDK8中优化为：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）\n扫描table数组中的每一条链表，根据节点的下标是否更改，将链表中的节点分配到lo链表和hi链表，lo链表中存储的是下标值未变的节点，hi链表存储的是下标值有所改变的节点。处理完一条链表后，将lo链表和hi链表分别存储到新的table数组中的对应位置\n\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;使用resize创建新table\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)&#x2F;&#x2F;数组中链表头不存在，初始化\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123;&#x2F;&#x2F;数组中插入位置有链表头，遍历\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;先检查第一个节点\n            e &#x3D; p;&#x2F;&#x2F;找到\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;遍历链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;没找到，新建节点\n                    p.next &#x3D; newNode(hash, key, value, null);\n\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F;树化？红黑树转换，并不会直接转换成红黑树\n                    break;\n                &#125;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#x2F;&#x2F;找到\n                    break;\n                p &#x3D; e;&#x2F;&#x2F;继续遍历\n            &#125;\n        &#125;\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;&#x2F;&#x2F;更新值\n            afterNodeAccess(e);&#x2F;&#x2F;见LinkedHashMap\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);&#x2F;&#x2F;见LinkedHashMap\n    return null;\n&#125;\n\nfinal Node&lt;K,V&gt;[] resize() &#123;\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    int newCap, newThr &#x3D; 0;\n    if (oldCap &gt; 0) &#123;\n        &#x2F;&#x2F; 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 没超过最大值，就扩充为原来的2倍\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold\n        newCap &#x3D; oldThr;\n    else &#123;\n        &#x2F;&#x2F; signifies using defaults\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    &#x2F;&#x2F; 计算新的resize上限\n    if (newThr &#x3D;&#x3D; 0) &#123;\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)\n        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab;\n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 把每个bucket都移动到新的buckets中\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                oldTab[j] &#x3D; null;\n                if (e.next &#x3D;&#x3D; null)\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123;\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        &#x2F;&#x2F; 原索引\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        &#x2F;&#x2F; 原索引+oldCap\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    &#x2F;&#x2F; 原索引放到bucket里\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    &#x2F;&#x2F; 原索引+oldCap放到bucket里\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;\n链表树化：降低单个链表长度（jdk1.8新增的特性，1.7仅有链表）\n\n当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的大小大于等于64时，将会把链表转化为红黑树，这个过程就叫treeify（树化）\n\n如果table数组长度小于64，即便链表中的节点个数大于等于8，也不会触发treeify，而是触发扩容操作，将长链表拆分为短链表\n\n当红黑树中节点个数比较少时，HashMap会再将其转换回链表，因为维护红黑树的成本比较高，对于少许节点，使用链表存储更高效，红黑树转换为链表的过程，叫做untreeify，促发untreeify的场景有以下两个：\n\n删除键值对：如果红黑树满足以下结构，则会触发untreeify，这个结构的红黑树的节点个数应该处于[2,6]之间，尽管treeify的阈值是8，但untreeify的阈值是[2,6]之间的某个数，之所以不相等是为了避免频繁的插入删除操作，导致节点个数在7，8之间频繁波动\n&#x2F;&#x2F;removeTreeNode函数中\nif (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||\n    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;\n    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small\n    return;\n&#125;\n扩容：每一条链表都会分割为lo和hi两条，同理红黑树也会分割为lt和ht两个红黑树，lt中存储的是下标位置不变的节点，ht中存储的是下标位置变化的节点。不过，在构建lt和ht之前，会先统计属于lt和ht的节点个数lc和hc，如果lc小于等于6（UNTREEIFY_THRESHOLD静态常量），在新的table数组中，HashMap会使用链表来存储下标不变的节点，同理，如果hc小于等于6，在新的table数组中，HashMap会使用链表来存储下标改变的节点。\n\n\n\n\n\n\n\nCollections\n\nsort()：用来对List进行排序，默认为从小到大，支持传入Comparator接口的匿名类改为降序，底层依赖Arrays\n基本类型数组排序算法：JDK8及以后使用DualPivotQuickSort()，JDK7及其以前使用快排，使用不稳定排序\nDualPivotQuickSort根据长度和元素类型，使用双轴快速排序算法、插入排序、计数排序、归并排序等算法来组合进行排序操作\n\n\n对象数组排序算法：JDK8及其以后使用TimSort()，JDK7及其以前使用归并排序，使用的是稳定的排序方式\nTimSort用非递归版本归并排序，归并到阈值后开始进行二分插入排序算法，即在插入时选择用二分查找来确定插入位置\n\n\n\n\nbinarySearch()：用来对已排序的List容器进行二分查找，因为涉及元素比较，所以需要传入实现Comparable接口的对象或者主动传入Comparator接口的匿名类对象\nindexedBinarySearch：查找mid使用的是链表的get函数，需要从头遍历链表来得到对应值\niteratorBinarySearch：查找mid使用的是新定义的get函数，从上一次迭代器的位置（mid）开始向前或向后查找，需要遍历的范围变小了，执行效率就变高了\n\n\nsynchronizedXXX()：JCF中的容器都是非线程安全的，当要使用线程安全的容器时，首选使用JUC并发容器，但当没有合适的JUC并发容器可以使用时，可以使用Collectinos类中的synchronizedXXX()函数来创建线程安全的容器\n\n\n- \n\n\n","slug":"Java特性","date":"2023-04-13T11:25:47.000Z","categories_index":"","tags_index":"language","author_index":"Dajunnnnnn"},{"id":"a7db680819d5984afbc70473b0c79529","title":"SaToken","content":"Sa-Token\n\n\n\n\n\n\n\n\n一款开源的、轻量级的Java权限认证框架，主要解决：登陆认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权等问题\n1.登陆认证\n登陆流程\n\n用户提交name+password参数，调用登录接口\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;示例&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@RequestMapping(&quot;doLogin&quot;)\npublic CommonResult doLogin(String name, String pwd)&#123;\n\t&#x2F;&#x2F;将用户传过来的name和pwd与数据库中的进行比对\n\tif(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd))&#123;\n\t\t&#x2F;&#x2F;根据账号id，进行登陆\n\t\t&#x2F;&#x2F;id为要登陆的账号，类型建议使用long、int、String类型\n\t\tStpUtil.login(10001);\n\t\treturn CommonResult.success(&quot;登陆成功&quot;)；\n\t&#125;\n\treturn CommonResult.failed(&quot;登录失败&quot;)；\n&#125;\n登陆成功，通过Cookie上下文返回给前端这个用户的token，该用户后续请求都带上这个token，服务器可以根据token判断此会话是否登陆成功\n\n如果校验未通过，则抛出异常，告知其需要先进行登陆\n\n\n\n示例\n&#x2F;**\n * 登录测试 \n *&#x2F;\n@RestController\n@RequestMapping(&quot;&#x2F;acc&#x2F;&quot;)\npublic class LoginController &#123;\n\n    &#x2F;&#x2F; 测试登录  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;doLogin?name&#x3D;zhang&amp;pwd&#x3D;123456&gt;\n    @RequestMapping(&quot;doLogin&quot;)\n    public SaResult doLogin(String name, String pwd) &#123;\n        &#x2F;&#x2F; 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 \n        if(&quot;zhang&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123;\n            StpUtil.login(10001);\n            return SaResult.ok(&quot;登录成功&quot;);\n        &#125;\n        return SaResult.error(&quot;登录失败&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 查询登录状态  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;isLogin&gt;\n    @RequestMapping(&quot;isLogin&quot;)\n    public SaResult isLogin() &#123;\n        return SaResult.ok(&quot;是否登录：&quot; + StpUtil.isLogin());\n    &#125;\n    \n    &#x2F;&#x2F; 查询 Token 信息  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;tokenInfo&gt;\n    @RequestMapping(&quot;tokenInfo&quot;)\n    public SaResult tokenInfo() &#123;\n        return SaResult.data(StpUtil.getTokenInfo());\n    &#125;\n    \n    &#x2F;&#x2F; 测试注销  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;logout&gt;\n    @RequestMapping(&quot;logout&quot;)\n    public SaResult logout() &#123;\n        StpUtil.logout();\n        return SaResult.ok();\n    &#125;\n    \n&#125;\n\n2.权限认证\n@RestControllerAdvice注解\n\n与切面有关的注解，作用范围为项目中使用了@RequestMapping的类\n\n与@ExceptionHandler的组合使用：两个注解组合使用是一个全局异常处理方法，发生了对应异常后，进入@ExceptionHandler修饰的方法，在这里处理全局异常（打印到日志里）\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;拦截全局异常&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@RestControllerAdvice\npublic class GlobalExceptionHandler &#123;\n    &#x2F;&#x2F; 全局异常拦截 \n    @ExceptionHandler\n    public SaResult handlerException(Exception e) &#123;\n        e.printStackTrace(); \n        return SaResult.error(e.getMessage());\n    &#125;\n&#125;\n底层原理：https://juejin.cn/post/7025484367539470344\n\nExceptionHandlerExceptionResolver实现了InitializingBean接口的afterPropertiesSet()方法，方法内调用initExceptionHandlerAdviceCache()扫描所有带@ControllerAdvice注解的类放入到adviceBeans链表里，然后将所有adviceBeans转换为ExceptionHandlerMethodResolver，转换过程中扫描每个ControllerAdvice中的带@ExceptionHandler注解的方法，再取出带@ExceptionHandler所处理的Exception类型，以类型为key，方法为value插入到mappedMethods这个map中进行缓存，最后将adviceBean和resolver插入到exceptionHandlerAdviceCache中进行缓存\n\n\n\n\nAPI\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;权限认证&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; 获取：当前账号所拥有的权限集合\nStpUtil.getPermissionList();\n\n&#x2F;&#x2F; 判断：当前账号是否含有指定权限, 返回 true 或 false\nStpUtil.hasPermission(&quot;user.add&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限, 如果验证未通过，则抛出异常: NotPermissionException \nStpUtil.checkPermission(&quot;user.add&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限 [指定多个，必须全部验证通过]\nStpUtil.checkPermissionAnd(&quot;user.add&quot;, &quot;user.delete&quot;, &quot;user.get&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限 [指定多个，只要其一验证通过即可]\nStpUtil.checkPermissionOr(&quot;user.add&quot;, &quot;user.delete&quot;, &quot;user.get&quot;);\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;角色校验&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; 获取：当前账号所拥有的角色集合\nStpUtil.getRoleList();\n\n&#x2F;&#x2F; 判断：当前账号是否拥有指定角色, 返回 true 或 false\nStpUtil.hasRole(&quot;super-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识, 如果验证未通过，则抛出异常: NotRoleException\nStpUtil.checkRole(&quot;super-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识 [指定多个，必须全部验证通过]\nStpUtil.checkRoleAnd(&quot;super-admin&quot;, &quot;shop-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识 [指定多个，只要其一验证通过即可] \nStpUtil.checkRoleOr(&quot;super-admin&quot;, &quot;shop-admin&quot;);\n注解鉴权\n\n注解示例\n\n@SaCheckLogin: 登录校验 —— 只有登录之后才能进入该方法。\n@SaCheckRole(&quot;admin&quot;): 角色校验 —— 必须具有指定角色标识才能进入该方法。\n@SaCheckPermission(&quot;user:add&quot;): 权限校验 —— 必须具有指定权限才能进入该方法。\n@SaCheckSafe: 二级认证校验 —— 必须二级认证之后才能进入该方法。\n@SaCheckBasic: HttpBasic校验 —— 只有通过 Basic 认证后才能进入该方法。\n@SaIgnore：忽略校验 —— 表示被修饰的方法或类无需进行注解鉴权和路由拦截器鉴权。\n@SaCheckDisable(&quot;comment&quot;)：账号服务封禁校验 —— 校验当前账号指定服务是否被封禁。\n\n\n注册拦截器：开启Sa-Token的全局蓝机器到项目中\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册 Sa-Token 拦截器，打开注解式鉴权功能 \n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册 Sa-Token 拦截器，打开注解式鉴权功能 \n        registry.addInterceptor(new SaInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;);    \n    &#125;\n&#125;\n使用注解鉴权\n&#x2F;&#x2F; 登录校验：只有登录之后才能进入该方法 \n@SaCheckLogin                        \n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n\n&#x2F;&#x2F; 角色校验：必须具有指定角色才能进入该方法 \n@SaCheckRole(&quot;super-admin&quot;)        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 权限校验：必须具有指定权限才能进入该方法 \n@SaCheckPermission(&quot;user-add&quot;)        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 二级认证校验：必须二级认证之后才能进入该方法 \n@SaCheckSafe()        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; Http Basic 校验：只有通过 Basic 认证后才能进入该方法 \n@SaCheckBasic(account &#x3D; &quot;sa:123456&quot;)\n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 校验当前账号是否被封禁 comment 服务，如果已被封禁会抛出异常，无法进入方法 \n@SaCheckDisable(&quot;comment&quot;)                \n@RequestMapping(&quot;send&quot;)\npublic String send() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n&#x2F;&#x2F; 此接口加上了 @SaIgnore 可以游客访问 ，表示一个接口忽略认证\n@SaIgnore\n@RequestMapping(&quot;getList&quot;)\npublic SaResult getList() &#123;\n    &#x2F;&#x2F; ... \n    return SaResult.ok(); \n&#125;\n\n\n\n3.路由拦截鉴权\n注册Sa-Token路由拦截器\n&#x2F;&#x2F;注册了一个基于StpUtil.checkLogin()的登陆校验拦截器，除了&#x2F;user&#x2F;doLogin接口都需要登陆才能访问\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册 Sa-Token 拦截器，校验规则为 StpUtil.checkLogin() 登录校验。\n        registry.addInterceptor(new SaInterceptor(handle -&gt; StpUtil.checkLogin()))\n                .addPathPatterns(&quot;&#x2F;**&quot;)\n                .excludePathPatterns(&quot;&#x2F;user&#x2F;doLogin&quot;); \n    &#125;\n&#125;\n完整的配置方式示例\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册 Sa-Token 的拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册路由拦截器，自定义认证规则 \n        registry.addInterceptor(new SaInterceptor(handler -&gt; &#123;\n            \n            &#x2F;&#x2F; 登录校验 -- 拦截所有路由，并排除&#x2F;user&#x2F;doLogin 用于开放登录 \n            SaRouter.match(&quot;&#x2F;**&quot;, &quot;&#x2F;user&#x2F;doLogin&quot;, r -&gt; StpUtil.checkLogin());\n\n            &#x2F;&#x2F; 角色校验 -- 拦截以 admin 开头的路由，必须具备 admin 角色或者 super-admin 角色才可以通过认证 \n            SaRouter.match(&quot;&#x2F;admin&#x2F;**&quot;, r -&gt; StpUtil.checkRoleOr(&quot;admin&quot;, &quot;super-admin&quot;));\n\n            &#x2F;&#x2F; 权限校验 -- 不同模块校验不同权限 \n            SaRouter.match(&quot;&#x2F;user&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;user&quot;));\n            SaRouter.match(&quot;&#x2F;admin&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;admin&quot;));\n            SaRouter.match(&quot;&#x2F;goods&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;goods&quot;));\n            SaRouter.match(&quot;&#x2F;orders&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;orders&quot;));\n            SaRouter.match(&quot;&#x2F;notice&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;notice&quot;));\n            SaRouter.match(&quot;&#x2F;comment&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;comment&quot;));\n            \n            &#x2F;&#x2F; 甚至你可以随意的写一个打印语句\n            SaRouter.match(&quot;&#x2F;**&quot;, r -&gt; System.out.println(&quot;----啦啦啦----&quot;));\n\n            &#x2F;&#x2F; 连缀写法\n            SaRouter.match(&quot;&#x2F;**&quot;).check(r -&gt; System.out.println(&quot;----啦啦啦----&quot;));\n            \n        &#125;)).addPathPatterns(&quot;&#x2F;**&quot;);\n    &#125;\n&#125;\n\n4.Session会话\nSession是会话中专业的数据缓存组件，通过Session可以缓存一些高频读写的数据，提高程序性能。在Sa-Token中，Session分为三种\n\nUser-Session: 指的是框架为每个 账号id 分配的 Session\nToken-Session: 指的是框架为每个 token 分配的 Session\nCustom-Session: 指的是以一个 特定的值 作为SessionId，来分配的 Session\n\n\n在Session上存取值\n&#x2F;&#x2F; 写值 \nsession.set(&quot;name&quot;, &quot;zhang&quot;); \n\n&#x2F;&#x2F; 写值 (只有在此key原本无值的时候才会写入)\nsession.setDefaultValue(&quot;name&quot;, &quot;zhang&quot;);\n\n&#x2F;&#x2F; 取值\nsession.get(&quot;name&quot;);\n\n&#x2F;&#x2F; 取值 (指定默认值)\nsession.get(&quot;name&quot;, &quot;&lt;defaultValue&gt;&quot;); \n\n&#x2F;&#x2F; 取值 (若无值则执行参数方法, 之后将结果保存到此键名下,并返回此结果   若有值则直接返回, 无需执行参数方法)\nsession.get(&quot;name&quot;, () -&gt; &#123;\n            return ...;\n        &#125;);\n\n&#x2F;&#x2F; ---------- 数据类型转换： ----------\nsession.getInt(&quot;age&quot;);         &#x2F;&#x2F; 取值 (转int类型)\nsession.getLong(&quot;age&quot;);        &#x2F;&#x2F; 取值 (转long类型)\nsession.getString(&quot;name&quot;);     &#x2F;&#x2F; 取值 (转String类型)\nsession.getDouble(&quot;result&quot;);   &#x2F;&#x2F; 取值 (转double类型)\nsession.getFloat(&quot;result&quot;);    &#x2F;&#x2F; 取值 (转float类型)\nsession.getModel(&quot;key&quot;, Student.class);     &#x2F;&#x2F; 取值 (指定转换类型)\nsession.getModel(&quot;key&quot;, Student.class, &lt;defaultValue&gt;);  &#x2F;&#x2F; 取值 (指定转换类型, 并指定值为Null时返回的默认值)\n\n&#x2F;&#x2F; 是否含有某个key (返回true或false)\nsession.has(&quot;key&quot;); \n\n&#x2F;&#x2F; 删值 \nsession.delete(&#39;name&#39;);          \n\n&#x2F;&#x2F; 清空所有值 \nsession.clear();                 \n\n&#x2F;&#x2F; 获取此 Session 的所有key (返回Set&lt;String&gt;)\nsession.keys();\n\n&#x2F;&#x2F; 返回此 Session 的id \nsession.getId();                          \n\n&#x2F;&#x2F; 返回此 Session 的创建时间 (时间戳) \nsession.getCreateTime();                  \n\n&#x2F;&#x2F; 返回此 Session 会话上的底层数据对象（如果更新map里的值，请调用session.update()方法避免产生脏数据）\nsession.getDataMap();                     \n\n&#x2F;&#x2F; 将这个 Session 从持久库更新一下\nsession.update();                         \n\n&#x2F;&#x2F; 注销此 Session 会话 (从持久库删除此Session)\nsession.logout();\n\n5.框架配置############## Sa-Token 配置 (文档: &lt;https:&#x2F;&#x2F;sa-token.cc&gt;) ##############\nsa-token: \n    # token名称 (同时也是cookie名称)\n    token-name: satoken\n    # token有效期，单位s 默认30天, -1代表永不过期 \n    timeout: 2592000\n    # token临时有效期 (指定时间内无操作就视为token过期) 单位: 秒\n    activity-timeout: -1\n    # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录) \n    is-concurrent: true\n    # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token) \n    is-share: true\n    # token风格\n    token-style: uuid\n    # 是否输出操作日志 \n    is-log: false\n\n6.Sa-Token集成Redis\nMaven\n&lt;!-- Sa-Token 整合 Redis （使用 jdk 默认序列化方式） --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;cn.dev33&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;sa-token-dao-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.34.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- 提供Redis连接池 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n配置\nspring: \n    # redis配置 \n    redis:\n        # Redis数据库索引（默认为0）\n        database: 1\n        # Redis服务器地址\n        host: 127.0.0.1\n        # Redis服务器连接端口\n        port: 6379\n        # Redis服务器连接密码（默认为空）\n        # password: \n        # 连接超时时间\n        timeout: 10s\n        lettuce:\n            pool:\n                # 连接池最大连接数\n                max-active: 200\n                # 连接池最大阻塞等待时间（使用负值表示没有限制）\n                max-wait: -1ms\n                # 连接池中的最大空闲连接\n                max-idle: 10\n                # 连接池中的最小空闲连接\n                min-idle: 0\n\n7.前后端分离\n常规Web端可以使用Cookie进行鉴权（后端控制写入、请求自动提交），但是在app、小程序等前后端分离的场景，一般没有Cookie这一功能，可以通过如下方式\n\n不能后端控制写入了，就前端自己写入。（难点在后端如何将 Token 传递到前端）\n&#x2F;&#x2F; 登录接口\n@RequestMapping(&quot;doLogin&quot;)\npublic SaResult doLogin() &#123;\n    &#x2F;&#x2F; 第1步，先登录上 \n    StpUtil.login(10001);\n    &#x2F;&#x2F; 第2步，获取 Token 相关参数(tokenName和tokenValue)\n    SaTokenInfo tokenInfo &#x3D; StpUtil.getTokenInfo();\n    &#x2F;&#x2F; 第3步，返回给前端，并保存在前端\n    return SaResult.data(tokenInfo);\n&#125;\n每次请求不能自动提交了，那就手动提交。（难点在前端如何将 Token 传递到后端，同时后端将其读取出来）\n&#x2F;&#x2F; 1、首先在登录时，将tokenName和tokenValue一起存储在本地，例如：\nuni.setStorageSync(&#39;tokenName&#39;, tokenName); \nuni.setStorageSync(&#39;tokenValue&#39;, tokenValue); \n\n&#x2F;&#x2F; 2、在发起ajax的地方，获取这两个值, 并组织到head里 \nvar tokenName &#x3D; uni.getStorageSync(&#39;tokenName&#39;);    &#x2F;&#x2F; 从本地缓存读取tokenName值\nvar tokenValue &#x3D; uni.getStorageSync(&#39;tokenValue&#39;);    &#x2F;&#x2F; 从本地缓存读取tokenValue值\nvar header &#x3D; &#123;\n    &quot;content-type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;\n&#125;;\nif (tokenName !&#x3D; undefined &amp;&amp; tokenName !&#x3D; &#39;&#39;) &#123;\n    header[tokenName] &#x3D; tokenValue;\n&#125;\n\n&#x2F;&#x2F; 3、后续在发起请求时将 header 对象塞到请求头部 \nuni.request(&#123;\n    url: &#39;&lt;https:&#x2F;&#x2F;www.example.com&#x2F;request&gt;&#39;, &#x2F;&#x2F; 仅为示例，并非真实接口地址。\n    header: header,\n    success: (res) &#x3D;&gt; &#123;\n        console.log(res.data);    \n    &#125;\n&#125;);\n\n\n\n8.密码加密\n封装的加密算法\n\n摘要加密（md5、sha1、sha256）\n&#x2F;&#x2F; md5加密 \nSaSecureUtil.md5(&quot;123456&quot;);\n\n&#x2F;&#x2F; sha1加密 \nSaSecureUtil.sha1(&quot;123456&quot;);\n\n&#x2F;&#x2F; sha256加密 \nSaSecureUtil.sha256(&quot;123456&quot;);\n对称加密（AES）\n&#x2F;&#x2F; 定义秘钥和明文\nString key &#x3D; &quot;123456&quot;;\nString text &#x3D; &quot;Sa-Token 一个轻量级java权限认证框架&quot;;\n\n&#x2F;&#x2F; 加密 \nString ciphertext &#x3D; SaSecureUtil.aesEncrypt(key, text);\nSystem.out.println(&quot;AES加密后：&quot; + ciphertext);\n\n&#x2F;&#x2F; 解密 \nString text2 &#x3D; SaSecureUtil.aesDecrypt(key, ciphertext);\nSystem.out.println(&quot;AES解密后：&quot; + text2);\n非对称加密（RSA）\n&#x2F;&#x2F; 定义私钥和公钥 \nString privateKey &#x3D; &quot;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAO+wmt01pwm9lHMdq7A8gkEigk0XKMfjv+4IjAFhWCSiTeP7dtlnceFJbkWxvbc7Qo3fCOpwmfcskwUc3VSgyiJkNJDs9ivPbvlt8IU2bZ+PBDxYxSCJFrgouVOpAr8ar&#x2F;b6gNuYTi1vt3FkGtSjACFb002&#x2F;68RKUTye8&#x2F;tdcVilAgMBAAECgYA1COmrSqTUJeuD8Su9ChZ0HROhxR8T45PjMmbwIz7ilDsR1+E7R4VOKPZKW4Kz2VvnklMhtJqMs4MwXWunvxAaUFzQTTg2Fu&#x2F;WU8Y9ha14OaWZABfChMZlpkmpJW9arKmI22ZuxCEsFGxghTiJQ3tK8npj5IZq5vk+6mFHQ6aJAQJBAPghz91Dpuj+0bOUfOUmzi22obWCBncAD&#x2F;0CqCLnJlpfOoa9bOcXSusGuSPuKy5KiGyblHMgKI6bq7gcM2DWrGUCQQD3SkOcmia2s&#x2F;6i7DUEzMKaB0bkkX4Ela&#x2F;xrfV+A3GzTPv9bIBamu0VIHznuiZbeNeyw7sVo4&#x2F;GTItq&#x2F;zn2QJdBAkEA8xHsVoyXTVeShaDIWJKTFyT5dJ1TR++&#x2F;udKIcuiNIap34tZdgGPI+EM1yoTduBM7YWlnGwA9urW0mj7F9e9WIQJAFjxqSfmeg40512KP&#x2F;ed&#x2F;lCQVXtYqU7U2BfBTg8pBfhLtEcOg4wTNTroGITwe2NjL5HovJ2n2sqkNXEio6Ji0QQJAFLW1Kt80qypMqot+mHhS+0KfdOpaKeMWMSR4Ij5VfE63WzETEeWAMQESxzhavN1WOTb3&#x2F;p6icgcVbgPQBaWhGg&#x3D;&#x3D;&quot;;\nString publicKey &#x3D; &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDvsJrdNacJvZRzHauwPIJBIoJNFyjH47&#x2F;uCIwBYVgkok3j+3bZZ3HhSW5Fsb23O0KN3wjqcJn3LJMFHN1UoMoiZDSQ7PYrz275bfCFNm2fjwQ8WMUgiRa4KLlTqQK&#x2F;Gq&#x2F;2+oDbmE4tb7dxZBrUowAhW9NNv+vESlE8nvP7XXFYpQIDAQAB&quot;;\n&#x2F;&#x2F; 生成一对公钥和私钥，其中Map对象 (private&#x3D;私钥, public&#x3D;公钥)\nSystem.out.println(SaSecureUtil.rsaGenerateKeyPair());\n\n&#x2F;&#x2F; 文本\nString text &#x3D; &quot;Sa-Token 一个轻量级java权限认证框架&quot;;\n\n&#x2F;&#x2F; 使用公钥加密\nString ciphertext &#x3D; SaSecureUtil.rsaEncryptByPublic(publicKey, text);\nSystem.out.println(&quot;公钥加密后：&quot; + ciphertext);\n\n&#x2F;&#x2F; 使用私钥解密\nString text2 &#x3D; SaSecureUtil.rsaDecryptByPrivate(privateKey, ciphertext);\nSystem.out.println(&quot;私钥解密后：&quot; + text2);\n\n\n\n9.多账号体系认证\n比如一个电商系统同时有user表和admin表，两套账号都适用StpUtil类的API进行登陆鉴权，势必会发生逻辑冲突\n\nstpLogic：StpUtil只是对成员变量stpLogic的各个API包装一下进行转发，这样的实现有以下好处\n\nStpLogic 类的所有函数都可以被重写，按需扩展\n在构造方法时随意传入一个不同的 loginType，就可以再造一套账号登录体系\n\n\n示例\n\n对于原生StpUtil类，只做admin账号权限认证，而对于user账号，则新建一个权限认证类（StpUserUtil.java），将StpUtil代码全部复制到StpUserUtil中，更改一下他的loginType，其它使用方式相同\npublic class StpUserUtil &#123;\n    \n    &#x2F;**\n     * 账号体系标识 \n     *&#x2F;\n    public static final String TYPE &#x3D; &quot;user&quot;;    &#x2F;&#x2F; 将 LoginType 从&#96;login&#96;改为&#96;user&#96; \n\n    &#x2F;&#x2F; 其它代码 ... \n\n&#125;\n相关注解的使用：默认只支持StpUtil类\n&#x2F;&#x2F; 通过type属性指定此注解校验的是我们自定义的&#96;StpUserUtil&#96;，而不是原生&#96;StpUtil&#96;\n@SaCheckLogin(type &#x3D; StpUserUtil.TYPE)\n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n使用自定义注解简化前一种方式\n\n重写Sa-Token默认的注解处理器\n@Configuration\npublic class SaTokenConfigure &#123;\n    @Autowired\n    public void rewriteSaStrategy() &#123;\n        &#x2F;&#x2F; 重写Sa-Token的注解处理器，增加注解合并功能 \n        SaStrategy.me.getAnnotation &#x3D; (element, annotationClass) -&gt; &#123;\n            return AnnotatedElementUtils.getMergedAnnotation(element, annotationClass); \n        &#125;;\n    &#125;\n&#125;\n自定义一个注解\n&#x2F;**\n * 登录认证(User版)：只有登录之后才能进入该方法 \n * &lt;p&gt; 可标注在函数、类上（效果等同于标注在此类的所有方法上） \n *&#x2F;\n@SaCheckLogin(type &#x3D; &quot;user&quot;)\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)\npublic @interface SaUserCheckLogin &#123;\n    \n&#125;\n使用示例\n&#x2F;&#x2F; 使用 @SaUserCheckLogin 的效果等同于使用：@SaCheckLogin(type &#x3D; &quot;user&quot;)\n@SaUserCheckLogin\n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n\n\n\n\n同端多登陆\n\n一个设备同时可以登陆两套账户，可能会发生token覆盖的问题，新登陆的token会覆盖掉旧的token\n\n解决办法：更改StpUserUtil（前文配置的新类）的TokenName\npublic class StpUserUtil &#123;\n    \n    &#x2F;&#x2F; 使用匿名子类 重写&#96;stpLogic对象&#96;的一些方法 \n    public static StpLogic stpLogic &#x3D; new StpLogic(&quot;user&quot;) &#123;\n        &#x2F;&#x2F; 重写 StpLogic 类下的 &#96;splicingKeyTokenName&#96; 函数，返回一个与 &#96;StpUtil&#96; 不同的token名称, 防止冲突 \n        @Override\n        public String splicingKeyTokenName() &#123;\n            return super.splicingKeyTokenName() + &quot;-user&quot;;\n        &#125;\n        &#x2F;&#x2F; 同理你可以按需重写一些其它方法 ... \n    &#125;; \n    &#x2F;&#x2F; ... \n&#125;\n再次调用 StpUserUtil.login(10001)进行登录授权时，token的名称将不再是 satoken，而是我们重写后的 satoken-user\n\n\n\n不同体系不同SaTokenConfig配置：自定义的 StpUserUtil 需要使用不同 SaTokenConfig 对象\npublic class StpUserUtil &#123;\n    \n    &#x2F;&#x2F; 使用匿名子类 重写&#96;stpLogic对象&#96;的一些方法 \n    public static StpLogic stpLogic &#x3D; new StpLogic(&quot;user&quot;) &#123;\n        \n        &#x2F;&#x2F; 首先自定义一个 Config 对象 \n        SaTokenConfig config &#x3D; new SaTokenConfig()\n            .setTokenName(&quot;satoken&quot;)\n            .setTimeout(2592000)\n            &#x2F;&#x2F; ... 其它set\n            ;\n        \n        &#x2F;&#x2F; 然后重写 stpLogic 配置获取方法 \n        @Override\n        public SaTokenConfig getConfig() &#123;\n            return config;\n        &#125;\n    &#125;;\n    \n    &#x2F;&#x2F; ... \n    \n&#125;\n多账号体系下，在拦截器中给一个接口登录鉴权的方法如下\n&#x2F;&#x2F; 注册 Sa-Token 拦截器\n@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n    registry.addInterceptor(new SaInterceptor(handle -&gt; &#123;\n        \n        &#x2F;&#x2F; 如果这个接口，要求客户端登录了后台 Admin 账号才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; StpUtil.checkLogin());\n\n        &#x2F;&#x2F; 如果这个接口，要求客户端登录了前台 User 账号才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; StpUserUtil.checkLogin());\n        \n        &#x2F;&#x2F; 如果这个接口，要求客户端同时登录 Admin 和 User 账号，才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; &#123;\n            StpUtil.checkLogin();\n            StpUserUtil.checkLogin();\n        &#125;);\n\n        &#x2F;&#x2F; 如果这个接口，要求客户端登录 Admin 和 User 账号任意一个，就能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; &#123;\n            if(StpUtil.isLogin() &#x3D;&#x3D; false &amp;&amp; StpUserUtil.isLogin() &#x3D;&#x3D; false) &#123;\n                throw new SaTokenException(&quot;请登录后再访问接口&quot;);\n            &#125;\n        &#125;);\n        \n    &#125;)).addPathPatterns(&quot;&#x2F;**&quot;);\n&#125;\n\n","slug":"SaToken","date":"2023-04-13T10:50:40.000Z","categories_index":"","tags_index":"middleware","author_index":"Dajunnnnnn"},{"id":"9a0ea7adf62049ce83652b0a7c894a59","title":"Java数据结构","content":"Java数据结构1.数据结构1.1常用方法\n\n\n接口\nAPI\n\n\n\nCollection\nsize、isEmpty、contains、toArray、add、remove、clear\n\n\nList\nget(index)、set(index)、add(index,element)、remove(index)、indexOf()、lastIndexOf()、subList(from, to)、sort\n\n\nQueue\noffer(element)、poll()、peek()\n\n\nDuque\nofferFirst(E e)、offerLast(E e)、pollFirst()、pollLast()、peekFirst()、peekLast()、push(E e)、pop()\n\n\nSet\nsize、isEmpty、contains、toArray、add、remove\n\n\nSortedSet\nSortedSet subSet(E fromElement, E toElement)、headSet(E toElement)、tailSet(E fromElement)、first、last\n\n\nMap\nsize、isEmpty、containsKey、containsValue、get、put、remove、keySet、values、entrySet\n\n\nMap补\ngetOrDefault(Object key, V defaultValue)、putIfAbsent(K key, V value)、replace(K key, V oldValue, V newValue)\n\n\n1.2工具类\n\n\n类名\nAPI\n\n\n\nString\ncharAt、toCharArray、split、substring（新String）、indexOf、lastIndexOf、replace、length\n\n\nString补\ntrim、toLowerCase、toUpperCase、split(String regex)、format（格式化输出，同c）\n\n\nStringBuilder\nappend、toString、charAt、length、delete、replace、insert、reverse、indexOf、lastIndexOf\n\n\nCollections\nsort、binarySearch、reverse、swap、fill、copy、replaceAll、emptyXXX\n\n\nArrays\nsort、binarySearch、equals、fill、asList、copyOf、copyOfRange\n\n\nMath\nmin、max、abs、sqrt(double)、pow(double, double)、ceil（上整）、floor（下整）、round（四舍五入）\n\n\nMath补\nInteger.MAX_VALUE、Integer.MIN_VALUE、\n\n\nScanner\nnextInt、nextLong、nextLine（nextInt不会洗掉换行符，需要nextLine吸掉）\n\n\nSystem.out\nprintln、print、format(“x = %d, y = %f\\n”, x, y)\n\n\n1.3补充知识\nArrayList\n\n实现特殊接口\n\nRandomAccess：Arrays的静态方法binarySearch会根据接口调用不同的实现方法\nCloneable：使用clone方法，返回一个浅拷贝\n\n\n底层为可动态扩容的数组（支持存储null数据）\n\n首先==确定最小扩容量==，默认最小为10，如果传入的所需容量比10大，则按传入的所需容量来扩容\n\n然后==判断是否需要扩容==，如果前一阶段判定的需要容量比内部数组的长度大，则进行扩容\n\n使用位移操作，将容量扩展为内部数组长度的1.5倍，如果比需要容量小，则直接使用需要容量，防止多次扩容，然后使用System.arraycopy来复制数据\npublic static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);\n\n\n使用modCount：来记录容量更改的次数，每次调用ensureCapacityInternal就将modCount加1，容量不够使才改容量。用来确定迭代的过程中，是否有其他线程更改过数据，如果有人修改过，则抛出ConcurrentModificationException异常\n\n\n\nLinkedList\n\n可以根据引用的接口不同，使用不同方法，支持List、Queue、Deque，根据结构的不同可以调用不同的方法\n底层为双向链表，并且有头尾指针，支持存储null数据\n\n\nArrayDeque\n\n基于数组实现，性能比LinkedList好，也可用来实现栈\n\n\nPriorityQueue\n\n底层依赖堆来实现（使用可变长数组），默认情况下为小顶堆，最先出队列的为当前队列中的最小值，支持Comparator接口\nQueue&lt;Integer&gt; minH &#x3D; new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;小顶堆，默认大小为11\nQueue&lt;Integer&gt; maxH &#x3D; new PriorityQueue&lt;&gt;((i1, i2) -&gt; i2 - i1); &#x2F;&#x2F;大顶堆，默认大小为11\n不支持存储NULL和non-comparable对象，通过堆元素的上浮和下沉，实现了在O(logn)的时间复杂度内插入和删除堆顶元素\n\n堆的构建过程，需要比较节点中数据的大小，所以，添加到优先级队列中的元素，需要能够比较大小，方法有两种：基于Comparable接口和基于Comparator接口，都有时则优先使用comparator，详见siftUp\nprivate void siftUp(int k, E x) &#123;\n    if (comparator !&#x3D; null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n&#125;\n\n\nSet（HashSet、LinkedHashSet、TreeSet）\n\n底层实现分别为：HashMap、LinkedHashMap、TreeMap，存储对象的时候，使用对象作为key，一个空的Object对象作为value，插入到底层的Map中，不管\n如何检查重复：无论Set中是否已经存在了某元素，都会直接在底层进行插入，通过add方法的返回值来确定插入前是否有相同的元素\n应用场景：HashSet用于==不需要保证元素插入和取出顺序==的场景；LinkedHashSet用于==保证元素的插入和取出顺序满足FIFO==的场景（LinedHashMap底层使用双向有序链表+哈希表）；TreeSet用于支持对元素==自定义排序规则==的场景\n\n\nHashMap（==数组+链表/红黑树==）\n\n底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）\n底层数组长度为2的倍数：hash函数可以使用与n-1取交替代与n取余、装载因子使用0.75使得阈值（n*0.75）一直为整数、初始化的时候选择比传入参数大的最小2的幂次方数\n动态扩容：默认初始化大小为16，每次超过阈值的时候就扩容为原来的2倍；扫描数组的每一条链表，根据节点下标决定是否要更改，插入到lo链表（不需改）和hi链表（需要改），处理完一条链表，将新链表插入到对应位置\n新位置确定方式：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）\n链表树化：当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的长度大于等于64时，将会把链表转化为红黑树；如果table长度不满足则触发扩容操作；如果红黑树节点数在[2，6]之间，则退化为链表\n\n\n\n\nArrays的sort\n\nCollections的sort函数底层依赖的Arrays类的sort函数，如List接口中的sort的默认实现\n基本类型：使用==DualPivotQuickSort==，jdk7之前使用快排\n对快排进行改进，选取两个pivot，通过数组的长度决定什么时候选用双轴快排、插入排序、归并排序、记数排序\n\n\n对象数组：使用==TimSort==，jdk7之前使用归并\n使用非递归版本归并排序算法，在归并排序的过程中，大的排序区间不断分解为小的待排序区间，如果带排序区间的长度小于MIN_MERGE（32），就不再继续分解，转而执行二分插入排序算法\n二分插入排序：将数组分为已排序区间和未排序区间，通过二分查找，查找插入位置，当找到后，通过调用System.arraycopy()函数，将插入点之后的数据整体快速后移一位，腾出位置给要插入的数据\n\n\n\n\nString（final数组）\n\nString不可变的原因：内部是final修饰的数组（引用不可改但是数据可改）、没有提供更改数组的方法、String类也是final的子类无法继承，避免了子类破坏String的不变性\n常量池技术：使用字符串常量赋值时触发，直接复用常量池已存在的对象，也可以使用intern方法复制堆上对象到常量池并回收堆上的对象\n运算符重载：因为String比较常用，所以延续了基本类型和包装类的设计，实现了加法操作String sc = sa + sb;，底层使用了StringBuilder来实现（StringBuffer加了锁，是线程安全的）\n\n\n\n2.算法2.1复杂度分析\n分析方法\n加法原则：总复杂度等于量级最大的那段代码的复杂度\n乘法原则：嵌套代码的复杂度等于嵌套内外的代码复杂度乘积\n其他方法：某一条语句执行的总次数；数据被访问的次数；使用递归树来分析\n\n\n空间复杂度\n不关注存储数据所需要的空间，而是关注算法所需要的额外存储消耗（循环、递归调用栈、辅助存储）\n由于现有题型大多以耗时为指标，所以尽可能使用==以空间换时间==的思想\n\n\n时间复杂度\n不看低阶和常数系数、加法取大、乘法取积\n分类：最好、最坏、平均\n\n\n\n2.2技巧\n双指针\n\n前缀和数组：原始数组不会被修改的情况下，频繁查询某个区间的累加和\n\n前缀和数组中两个元素的差，及这段区间的累加和\n示例：原数组{3,5,2,-1,4,1}；前缀和数组{0,3,8,10,8,12,13}\n\n\n差分数组：频繁对原数组的某个区间的元素进行增减\n\n原理：对i→n的所有元素都加3，对j+1→n的所有元素都减3\n示例：原数组{8,2,6,3,1}；差分数组{8,-6,4,-3,-2}\n\n\n并查集（Union-Find）\nclass UF &#123;\n    &#x2F;&#x2F; 连通分量个数\n    private int count;\n    &#x2F;&#x2F; 存储每个节点的父节点\n    private int[] parent;\n\n    &#x2F;&#x2F; n 为图中节点的个数\n    public UF(int n) &#123;\n        this.count &#x3D; n;\n        parent &#x3D; new int[n];\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            parent[i] &#x3D; i;\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 将节点 p 和节点 q 连通\n    public void union(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        \n        if (rootP &#x3D;&#x3D; rootQ)\n            return;\n        \n        parent[rootQ] &#x3D; rootP;\n        &#x2F;&#x2F; 两个连通分量合并成一个连通分量\n        count--;\n    &#125;\n\n    &#x2F;&#x2F; 判断节点 p 和节点 q 是否连通\n    public boolean connected(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        return rootP &#x3D;&#x3D; rootQ;\n    &#125;\n\n    public int find(int x) &#123;\n        if (parent[x] !&#x3D; x) &#123;\n            parent[x] &#x3D; find(parent[x]);\n        &#125;\n        return parent[x];\n    &#125;\n\n    &#x2F;&#x2F; 返回图中的连通分量个数\n    public int count() &#123;\n        return count;\n    &#125;\n&#125;\n快速幂：为了在O(logn)的时间内计算a^n的技巧\n\n理论依据：a^(b+c) = a^b * a^c，与二分查找思想结合可以得出a^(2b) =a^b * a^b =  (a^b) ^2\n\n代码实现\n\n递归\nlong binpow(long a,long b)&#123;\n  if(b &#x3D;&#x3D; 0)&#123;\n    return 1;\n  &#125;\n  long res &#x3D; binpow(a, b&#x2F;2);\n  if(b % 2 &#x3D;&#x3D; 1)&#123;\n    return res * res * a; &#x2F;&#x2F;奇数次幂\n  &#125;else&#123;\n    return res * res; &#x2F;&#x2F;偶数次幂\n  &#125;\n&#125;\n非递归\nlong binpow(long a, long b)&#123;\n  long res &#x3D; 1;\n  while(b &gt; 0)&#123;\n    if((b &amp; 1) &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;当前位为1，则需要乘二进制幂，否则跳过此次\n      res &#x3D; res * a;\n    &#125;\n    a &#x3D; a*a;\n    b &gt;&gt;&#x3D; 1;\n  &#125;\n  return res;\n&#125;\n\n\n应用\n\n计算 (x^n) mod m：取模运算不会干涉乘法，所以计算过程中直接取模就行\n\n另：根据费马小定理，如果m是一个质数，可以计算x^(n mod (m-1) )来加速算法过程\n\nlong binpow(long a, long b, long m)&#123;\n  a %&#x3D; m;\n  long res &#x3D; 1;\n  while(b &gt; 0)&#123;\n    if((b &amp; 1) &#x3D;&#x3D; 1)&#123;\n      res &#x3D; res * a % m;\n    &#125;\n    a &#x3D; a * a % m;\n    b &gt;&gt;&#x3D; 1;\n  &#125;\n  return res;\n&#125;\n\n\n\n\n\n\n2.3算法思想\n排序\n\n基础排序算法\n\nO（n^2）\n\n冒泡排序：一对对比较，一对对交换\n\n插入排序：分为已排和未排区间，取未排插入到已排。例：希尔排序\n\n选择排序：分为已排和未排区间，从未排选一个最小的插入到已排的\n\n希尔排序\n\n\n\nO（nlogn）\n\n归并排序：“分治思想”，分而治之，然后再合并\n\n快速排序：选一个pivot，大的放左，小的放右\n\n堆排序：先将数组原地建成一个堆，从下往上堆化，取堆顶元素，将下标n的元素放到堆顶，堆化\n\n二叉排序树排序\n\n\n\nO（n）\n\n计数排序：例：10G数据，100个桶\n\n基数排序：高考成绩排序，760个桶\n\n桶排序：10万个手机号码排序，从个位开始一位位进行桶或基数排序\n\n\n\n\n\n常见题型\n\n特殊排序：不是单纯的增减顺序，而是有一些特殊要求\nTop K：找到前K个大的，第K个大的……\n链表上的排序：数据结构由数组转换为链表，并进行排序\n排序预处理：排序只是问题的一部分预处理，可以运用库函数\n区间问题：（252题、56题） 先排序，再处理\n\n\n\n\n二分查找：大部分都是变形二分查找或二分答案，代码不长，但容易写对。难点在于：确定搜索区间，循环条件，区间更新，返回值\n\n查找区间永远是闭区间[low,high]\n\n循环条件永远是：low &lt;= high\n\n对于low == high的情况，必要的时候特殊处理，在while内部补充退出条件\n\n返回值永远是mid，而不是low，high\n\nlow、high的更新永远是low = mid + 1和high = mid - 1\n\n对于非确定性查找，使用前后探测法，来确定搜索区间（不用while，而只更新low或high）\n\n先处理命中情况，再处理在左右半部分查找的情况\n\n非确定查找：第一个、最后一个、第一个大于等于、最后一个小于等于、循环数组寻找最小值、寻找峰值\n\n\n\nbfs\n&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离\nint BFS(Node start, Node target) &#123;\n    Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构\n    Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路\n    \n    q.offer(start); &#x2F;&#x2F; 将起点加入队列\n    visited.add(start);\n    int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数\n\n    while (q not empty) &#123;\n        int sz &#x3D; q.size();\n        &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F;\n        for (int i &#x3D; 0; i &lt; sz; i++) &#123;\n            Node cur &#x3D; q.poll();\n            &#x2F;* 划重点：这里判断是否到达终点 *&#x2F;\n            if (cur is target)\n                return step;\n            &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F;\n            for (Node x : cur.adj()) &#123;\n                if (x not in visited) &#123;\n                    q.offer(x);\n                    visited.add(x);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;* 划重点：更新步数在这里 *&#x2F;\n        step++;\n    &#125;\n&#125;\ndfs\n\n递归\n\n代码技巧：千万不要试图想清楚整个递和归的执行过程，实际上是进入了一个思维误区\n\n怎么发现这个问题可以用递归来做：\n\n规模更小的问题，跟规模大点的问题，解决思路相同，但规模不同\n\n利用子问题的解可以组合得到原问题的解\n\n存在最小子问题，可以直接返回结果，即存在递归终止条件\n\n\n\n递归的正确编写姿势：\n\n我们可以假设子问题B,C已经解决，在此基础上思考如何解决原问题A，基于此，找递推公式+终止条件，然后翻译成代码\n\n\n\n\n时间复杂度和空间复杂度分析：\n\n时间复杂度：递推公式或者递归树\n空间复杂度：跟递归的函数调用栈最大深度成正比，即递归树的高度\n\n\n解题技巧：寻找重复结构，是否能将问题结构转化成结构相同，规模更小的子问题，然后写递推公式，包括递归终止条件，然后翻译成代码\n\n原问题解决思路和子问题解决思路是否一样\n\n子问题的解能否构造出原问题的解（递推公式）\n\n找到最小子问题（终止条件）\n\n\n\n\n\n回溯：回溯是递归的副产品，只要有递归就会有回溯，本质就是穷举+剪枝\nresult &#x3D; []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n    \n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\ndfs\npublic List&lt;Integer&gt; dfs(int s,int t)&#123;\n        List&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();\n        path.add(s);\n        visited[s] &#x3D; true;\n        dfs_backtrack(s,t,path);\n        return resultPath;\n    &#125;\n\n    public void dfs_backtrack(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                path.add(q);\n                visited[q] &#x3D; true;\n                dfs_backtrack(q,t,path);\n                path.remove(path.size()-1);\n            &#125;\n        &#125;\n    &#125;\n\n\ndp\n\n解题步骤\n\n可用回溯解决：使用穷举结果才能得到结果的问题（最值、可行、计数等）\n构建多阶段决策模型：看是否能将问题求解的过程分为多个阶段\n查看是否存在重复子问题：是否有多个路径到达同一状态\n定义状态：也就是如何记录每一阶段的不重复状态\n定义状态转移方程：也就是找到如何通过上一阶段的状态推导下一阶段的状态\n画状态转移表：辅助理解，验证正确性，确定状态转移的初始值\n\n\n代码结构\n# 自顶向下递归的动态规划\ndef dp(状态1, 状态2, ...):\n    for 选择 in 所有可能的选择:\n        # 此时的状态已经因为做了选择而改变\n        result &#x3D; 求最值(result, dp(状态1, 状态2, ...))\n    return result\n\n# 自底向上迭代的动态规划\n# 初始化 base case\ndp[0][0][...] &#x3D; base case\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)\n0-1背包的最值、可行、计数\n\n最值1：有n个物品，选择其中一些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装物品总重量的最大值是多少\n\n最值2：有n个物品，选择其中一些物品装入背包，正好装满背包所需物品最小个数（如果装不满，返回-1）\n\n可行：有n个物品，选择其中一些物品装入背包，能不能正好装满背包\n\n计数：有n个物品，选择其中一些物品装入背包，装满背包有多少种不同的装法\n\n\n\n完全背包（同一个物品可装n次）的最值、可行、计数\n\n背包可装物品总重量的最大值是多少\n是否能装满整个背包\n正好装满背包至少需要多少物品\n装满背包有多少种装法\n\n\n空间优化\n\n\n\n\n3.经典代码1.二叉树\n构建\n\n根据数组构建节点结构\npublic class Solution &#123;\n    static class TreeNode &#123;\n        int val;\n        TreeNode left;\n        TreeNode right;\n        public TreeNode(int x) &#123;\n            this.val &#x3D; x;\n            this.left &#x3D; null;\n            this.right &#x3D; null;\n        &#125;\n    &#125;\n    \n    &#x2F;**\n     * 根据数组构建二叉树\n     * @param arr 树的数组表示\n     * @return 构建成功后树的根节点\n     *&#x2F;\n    public TreeNode constructBinaryTree(final int[] arr) &#123;\n        &#x2F;&#x2F; 构建和原数组相同的树节点列表\n        List&lt;TreeNode&gt; treeNodeList &#x3D; arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;\n        TreeNode root &#x3D; null;\n        &#x2F;&#x2F; 把输入数值数组，先转化为二叉树节点列表\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; null;\n            if (arr[i] !&#x3D; -1) &#123; &#x2F;&#x2F; 用 -1 表示null\n                node &#x3D; new TreeNode(arr[i]);\n            &#125;\n            treeNodeList.add(node);\n            if (i &#x3D;&#x3D; 0) &#123;\n                root &#x3D; node;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 遍历一遍，根据规则左右孩子赋值就可以了\n        &#x2F;&#x2F; 注意这里 结束规则是 i * 2 + 1 &lt; arr.length，避免空指针\n        &#x2F;&#x2F; 为什么结束规则不能是i * 2 + 2 &lt; arr.length呢?\n        &#x2F;&#x2F; 如果i * 2 + 2 &lt; arr.length 是结束条件\n        &#x2F;&#x2F; 那么i * 2 + 1这个符合条件的节点就被忽略掉了\n        &#x2F;&#x2F; 例如[2,7,9,-1,1,9,6,-1,-1,10] 这样的一个二叉树,最后的10就会被忽略掉\n        for (int i &#x3D; 0; i * 2 + 1 &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; treeNodeList.get(i);\n            if (node !&#x3D; null) &#123;\n                &#x2F;&#x2F; 线性存储转连式存储关键逻辑\n                node.left &#x3D; treeNodeList.get(2 * i + 1);\n                &#x2F;&#x2F;  再次判断下 不忽略任何一个节点\n                if(i * 2 + 2 &lt; arr.length)\n                node.right &#x3D; treeNodeList.get(2 * i + 2);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n&#125;\n直接构建邻接表\n\nArrayList&lt;Integer&gt;[] adjs &#x3D; new ArrayList[n];\nfor(int i &#x3D; 0; adjs.size(); i++)&#123;\n  adjs[i] &#x3D; new ArrayList&lt;&gt;();\n&#125;\nfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n  adjs[father].add(son);\n&#125;\n图的构建\n&#x2F;&#x2F; 邻接表\n&#x2F;&#x2F; graph[x] 存储 x 的所有邻居节点\nList&lt;Integer&gt;[] graph;\n\n&#x2F;&#x2F; 邻接矩阵\n&#x2F;&#x2F; matrix[x][y] 记录 x 是否有一条指向 y 的边\nboolean[][] matrix;\n\n\n递归遍历\n&#x2F;&#x2F; 前序遍历·递归·LC144_二叉树的前序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n&#x2F;&#x2F; 中序遍历·递归·LC94_二叉树的中序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        inorder(root, res);\n        return res;\n    &#125;\n\n    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        inorder(root.left, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n        inorder(root.right, list);\n    &#125;\n&#125;\n&#x2F;&#x2F; 后序遍历·递归·LC145_二叉树的后序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        postorder(root, res);\n        return res;\n    &#125;\n\n    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        postorder(root.left, list);\n        postorder(root.right, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n    &#125;\n&#125;\n非递归遍历\n&#x2F;&#x2F; 前序遍历顺序：中-左-右，入栈顺序：中-右-左\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 中序遍历顺序: 左-中-右 入栈顺序： 左-右\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        TreeNode cur &#x3D; root;\n        while (cur !&#x3D; null || !stack.isEmpty())&#123;\n           if (cur !&#x3D; null)&#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;else&#123;\n               cur &#x3D; stack.pop();\n               result.add(cur.val);\n               cur &#x3D; cur.right;\n           &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;\n层序遍历\n&#x2F;&#x2F; 102.二叉树的层序遍历\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; resList &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        &#x2F;&#x2F;checkFun01(root,0);\n        checkFun02(root);\n\n        return resList;\n    &#125;\n\n    &#x2F;&#x2F;DFS--递归方式\n    public void checkFun01(TreeNode node, Integer deep) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        deep++;\n\n        if (resList.size() &lt; deep) &#123;\n            &#x2F;&#x2F;当层级增加时，list的Item也增加，利用list的索引值进行层级界定\n            List&lt;Integer&gt; item &#x3D; new ArrayList&lt;Integer&gt;();\n            resList.add(item);\n        &#125;\n        resList.get(deep - 1).add(node.val);\n\n        checkFun01(node.left, deep);\n        checkFun01(node.right, deep);\n    &#125;\n\n    &#x2F;&#x2F;BFS--迭代方式--借助队列\n    public void checkFun02(TreeNode node) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        Queue&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;TreeNode&gt;();\n        que.offer(node);\n\n        while (!que.isEmpty()) &#123;\n            List&lt;Integer&gt; itemList &#x3D; new ArrayList&lt;Integer&gt;();\n            int len &#x3D; que.size();\n\n            while (len &gt; 0) &#123;\n                TreeNode tmpNode &#x3D; que.poll();\n                itemList.add(tmpNode.val);\n\n                if (tmpNode.left !&#x3D; null) que.offer(tmpNode.left);\n                if (tmpNode.right !&#x3D; null) que.offer(tmpNode.right);\n                len--;\n            &#125;\n\n            resList.add(itemList);\n        &#125;\n\n    &#125;\n&#125;\n翻转二叉树\n&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;\n二叉树的所有路径\n&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;\n前序和后序构造二叉树\nclass Solution &#123;\n    Map&lt;Integer, Integer&gt; map;  &#x2F;&#x2F; 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (inBegin &gt;&#x3D; inEnd || postBegin &gt;&#x3D; postEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(postorder[postEnd - 1]);  &#x2F;&#x2F; 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定后序数列的个数\n        root.left &#x3D; findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right &#x3D; findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    &#125;\n&#125;\n前序和中序构造二叉树\nclass Solution &#123;\n    Map&lt;Integer, Integer&gt; map;\n    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数\n        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,\n                            inorder, inBegin, rootIndex);\n        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,\n                            inorder, rootIndex + 1, inEnd);\n\n        return root;\n    &#125;\n&#125;\n\n2.动态规划\n背包问题：0-1、完全、多重、二维费用、分组、有依赖的\n路径问题\n打家劫舍和股票买卖\n一般动态规划问题，上一个阶段做了什么决策，不影响下一个阶段的决策。但是打家劫舍&amp;股票买卖这类问题，上一个阶段的决策会影响下一个阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值\n\n\n爬楼梯\n匹配问题\n\n3.其它","slug":"算法基础","date":"2023-04-01T04:25:03.000Z","categories_index":"","tags_index":"algorithm","author_index":"Dajunnnnnn"}]