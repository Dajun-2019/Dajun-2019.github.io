[{"id":"a7db680819d5984afbc70473b0c79529","title":"SaToken","content":"Sa-Token\n\n\n\n\n\n\n\n\n一款开源的、轻量级的Java权限认证框架，主要解决：登陆认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权等问题\n1.登陆认证\n登陆流程\n\n用户提交name+password参数，调用登录接口\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;示例&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@RequestMapping(&quot;doLogin&quot;)\npublic CommonResult doLogin(String name, String pwd)&#123;\n\t&#x2F;&#x2F;将用户传过来的name和pwd与数据库中的进行比对\n\tif(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd))&#123;\n\t\t&#x2F;&#x2F;根据账号id，进行登陆\n\t\t&#x2F;&#x2F;id为要登陆的账号，类型建议使用long、int、String类型\n\t\tStpUtil.login(10001);\n\t\treturn CommonResult.success(&quot;登陆成功&quot;)；\n\t&#125;\n\treturn CommonResult.failed(&quot;登录失败&quot;)；\n&#125;\n登陆成功，通过Cookie上下文返回给前端这个用户的token，该用户后续请求都带上这个token，服务器可以根据token判断此会话是否登陆成功\n\n如果校验未通过，则抛出异常，告知其需要先进行登陆\n\n\n\n示例\n&#x2F;**\n * 登录测试 \n *&#x2F;\n@RestController\n@RequestMapping(&quot;&#x2F;acc&#x2F;&quot;)\npublic class LoginController &#123;\n\n    &#x2F;&#x2F; 测试登录  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;doLogin?name&#x3D;zhang&amp;pwd&#x3D;123456&gt;\n    @RequestMapping(&quot;doLogin&quot;)\n    public SaResult doLogin(String name, String pwd) &#123;\n        &#x2F;&#x2F; 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 \n        if(&quot;zhang&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123;\n            StpUtil.login(10001);\n            return SaResult.ok(&quot;登录成功&quot;);\n        &#125;\n        return SaResult.error(&quot;登录失败&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 查询登录状态  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;isLogin&gt;\n    @RequestMapping(&quot;isLogin&quot;)\n    public SaResult isLogin() &#123;\n        return SaResult.ok(&quot;是否登录：&quot; + StpUtil.isLogin());\n    &#125;\n    \n    &#x2F;&#x2F; 查询 Token 信息  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;tokenInfo&gt;\n    @RequestMapping(&quot;tokenInfo&quot;)\n    public SaResult tokenInfo() &#123;\n        return SaResult.data(StpUtil.getTokenInfo());\n    &#125;\n    \n    &#x2F;&#x2F; 测试注销  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;logout&gt;\n    @RequestMapping(&quot;logout&quot;)\n    public SaResult logout() &#123;\n        StpUtil.logout();\n        return SaResult.ok();\n    &#125;\n    \n&#125;\n\n2.权限认证\n@RestControllerAdvice注解\n\n与切面有关的注解，作用范围为项目中使用了@RequestMapping的类\n\n与@ExceptionHandler的组合使用：两个注解组合使用是一个全局异常处理方法，发生了对应异常后，进入@ExceptionHandler修饰的方法，在这里处理全局异常（打印到日志里）\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;拦截全局异常&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@RestControllerAdvice\npublic class GlobalExceptionHandler &#123;\n    &#x2F;&#x2F; 全局异常拦截 \n    @ExceptionHandler\n    public SaResult handlerException(Exception e) &#123;\n        e.printStackTrace(); \n        return SaResult.error(e.getMessage());\n    &#125;\n&#125;\n底层原理：https://juejin.cn/post/7025484367539470344\n\nExceptionHandlerExceptionResolver实现了InitializingBean接口的afterPropertiesSet()方法，方法内调用initExceptionHandlerAdviceCache()扫描所有带@ControllerAdvice注解的类放入到adviceBeans链表里，然后将所有adviceBeans转换为ExceptionHandlerMethodResolver，转换过程中扫描每个ControllerAdvice中的带@ExceptionHandler注解的方法，再取出带@ExceptionHandler所处理的Exception类型，以类型为key，方法为value插入到mappedMethods这个map中进行缓存，最后将adviceBean和resolver插入到exceptionHandlerAdviceCache中进行缓存\n\n\n\n\nAPI\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;权限认证&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; 获取：当前账号所拥有的权限集合\nStpUtil.getPermissionList();\n\n&#x2F;&#x2F; 判断：当前账号是否含有指定权限, 返回 true 或 false\nStpUtil.hasPermission(&quot;user.add&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限, 如果验证未通过，则抛出异常: NotPermissionException \nStpUtil.checkPermission(&quot;user.add&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限 [指定多个，必须全部验证通过]\nStpUtil.checkPermissionAnd(&quot;user.add&quot;, &quot;user.delete&quot;, &quot;user.get&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限 [指定多个，只要其一验证通过即可]\nStpUtil.checkPermissionOr(&quot;user.add&quot;, &quot;user.delete&quot;, &quot;user.get&quot;);\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;角色校验&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; 获取：当前账号所拥有的角色集合\nStpUtil.getRoleList();\n\n&#x2F;&#x2F; 判断：当前账号是否拥有指定角色, 返回 true 或 false\nStpUtil.hasRole(&quot;super-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识, 如果验证未通过，则抛出异常: NotRoleException\nStpUtil.checkRole(&quot;super-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识 [指定多个，必须全部验证通过]\nStpUtil.checkRoleAnd(&quot;super-admin&quot;, &quot;shop-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识 [指定多个，只要其一验证通过即可] \nStpUtil.checkRoleOr(&quot;super-admin&quot;, &quot;shop-admin&quot;);\n注解鉴权\n\n注解示例\n\n@SaCheckLogin: 登录校验 —— 只有登录之后才能进入该方法。\n@SaCheckRole(&quot;admin&quot;): 角色校验 —— 必须具有指定角色标识才能进入该方法。\n@SaCheckPermission(&quot;user:add&quot;): 权限校验 —— 必须具有指定权限才能进入该方法。\n@SaCheckSafe: 二级认证校验 —— 必须二级认证之后才能进入该方法。\n@SaCheckBasic: HttpBasic校验 —— 只有通过 Basic 认证后才能进入该方法。\n@SaIgnore：忽略校验 —— 表示被修饰的方法或类无需进行注解鉴权和路由拦截器鉴权。\n@SaCheckDisable(&quot;comment&quot;)：账号服务封禁校验 —— 校验当前账号指定服务是否被封禁。\n\n\n注册拦截器：开启Sa-Token的全局蓝机器到项目中\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册 Sa-Token 拦截器，打开注解式鉴权功能 \n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册 Sa-Token 拦截器，打开注解式鉴权功能 \n        registry.addInterceptor(new SaInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;);    \n    &#125;\n&#125;\n使用注解鉴权\n&#x2F;&#x2F; 登录校验：只有登录之后才能进入该方法 \n@SaCheckLogin                        \n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n\n&#x2F;&#x2F; 角色校验：必须具有指定角色才能进入该方法 \n@SaCheckRole(&quot;super-admin&quot;)        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 权限校验：必须具有指定权限才能进入该方法 \n@SaCheckPermission(&quot;user-add&quot;)        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 二级认证校验：必须二级认证之后才能进入该方法 \n@SaCheckSafe()        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; Http Basic 校验：只有通过 Basic 认证后才能进入该方法 \n@SaCheckBasic(account &#x3D; &quot;sa:123456&quot;)\n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 校验当前账号是否被封禁 comment 服务，如果已被封禁会抛出异常，无法进入方法 \n@SaCheckDisable(&quot;comment&quot;)                \n@RequestMapping(&quot;send&quot;)\npublic String send() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n&#x2F;&#x2F; 此接口加上了 @SaIgnore 可以游客访问 ，表示一个接口忽略认证\n@SaIgnore\n@RequestMapping(&quot;getList&quot;)\npublic SaResult getList() &#123;\n    &#x2F;&#x2F; ... \n    return SaResult.ok(); \n&#125;\n\n\n\n3.路由拦截鉴权\n注册Sa-Token路由拦截器\n&#x2F;&#x2F;注册了一个基于StpUtil.checkLogin()的登陆校验拦截器，除了&#x2F;user&#x2F;doLogin接口都需要登陆才能访问\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册 Sa-Token 拦截器，校验规则为 StpUtil.checkLogin() 登录校验。\n        registry.addInterceptor(new SaInterceptor(handle -&gt; StpUtil.checkLogin()))\n                .addPathPatterns(&quot;&#x2F;**&quot;)\n                .excludePathPatterns(&quot;&#x2F;user&#x2F;doLogin&quot;); \n    &#125;\n&#125;\n完整的配置方式示例\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册 Sa-Token 的拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册路由拦截器，自定义认证规则 \n        registry.addInterceptor(new SaInterceptor(handler -&gt; &#123;\n            \n            &#x2F;&#x2F; 登录校验 -- 拦截所有路由，并排除&#x2F;user&#x2F;doLogin 用于开放登录 \n            SaRouter.match(&quot;&#x2F;**&quot;, &quot;&#x2F;user&#x2F;doLogin&quot;, r -&gt; StpUtil.checkLogin());\n\n            &#x2F;&#x2F; 角色校验 -- 拦截以 admin 开头的路由，必须具备 admin 角色或者 super-admin 角色才可以通过认证 \n            SaRouter.match(&quot;&#x2F;admin&#x2F;**&quot;, r -&gt; StpUtil.checkRoleOr(&quot;admin&quot;, &quot;super-admin&quot;));\n\n            &#x2F;&#x2F; 权限校验 -- 不同模块校验不同权限 \n            SaRouter.match(&quot;&#x2F;user&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;user&quot;));\n            SaRouter.match(&quot;&#x2F;admin&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;admin&quot;));\n            SaRouter.match(&quot;&#x2F;goods&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;goods&quot;));\n            SaRouter.match(&quot;&#x2F;orders&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;orders&quot;));\n            SaRouter.match(&quot;&#x2F;notice&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;notice&quot;));\n            SaRouter.match(&quot;&#x2F;comment&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;comment&quot;));\n            \n            &#x2F;&#x2F; 甚至你可以随意的写一个打印语句\n            SaRouter.match(&quot;&#x2F;**&quot;, r -&gt; System.out.println(&quot;----啦啦啦----&quot;));\n\n            &#x2F;&#x2F; 连缀写法\n            SaRouter.match(&quot;&#x2F;**&quot;).check(r -&gt; System.out.println(&quot;----啦啦啦----&quot;));\n            \n        &#125;)).addPathPatterns(&quot;&#x2F;**&quot;);\n    &#125;\n&#125;\n\n4.Session会话\nSession是会话中专业的数据缓存组件，通过Session可以缓存一些高频读写的数据，提高程序性能。在Sa-Token中，Session分为三种\n\nUser-Session: 指的是框架为每个 账号id 分配的 Session\nToken-Session: 指的是框架为每个 token 分配的 Session\nCustom-Session: 指的是以一个 特定的值 作为SessionId，来分配的 Session\n\n\n在Session上存取值\n&#x2F;&#x2F; 写值 \nsession.set(&quot;name&quot;, &quot;zhang&quot;); \n\n&#x2F;&#x2F; 写值 (只有在此key原本无值的时候才会写入)\nsession.setDefaultValue(&quot;name&quot;, &quot;zhang&quot;);\n\n&#x2F;&#x2F; 取值\nsession.get(&quot;name&quot;);\n\n&#x2F;&#x2F; 取值 (指定默认值)\nsession.get(&quot;name&quot;, &quot;&lt;defaultValue&gt;&quot;); \n\n&#x2F;&#x2F; 取值 (若无值则执行参数方法, 之后将结果保存到此键名下,并返回此结果   若有值则直接返回, 无需执行参数方法)\nsession.get(&quot;name&quot;, () -&gt; &#123;\n            return ...;\n        &#125;);\n\n&#x2F;&#x2F; ---------- 数据类型转换： ----------\nsession.getInt(&quot;age&quot;);         &#x2F;&#x2F; 取值 (转int类型)\nsession.getLong(&quot;age&quot;);        &#x2F;&#x2F; 取值 (转long类型)\nsession.getString(&quot;name&quot;);     &#x2F;&#x2F; 取值 (转String类型)\nsession.getDouble(&quot;result&quot;);   &#x2F;&#x2F; 取值 (转double类型)\nsession.getFloat(&quot;result&quot;);    &#x2F;&#x2F; 取值 (转float类型)\nsession.getModel(&quot;key&quot;, Student.class);     &#x2F;&#x2F; 取值 (指定转换类型)\nsession.getModel(&quot;key&quot;, Student.class, &lt;defaultValue&gt;);  &#x2F;&#x2F; 取值 (指定转换类型, 并指定值为Null时返回的默认值)\n\n&#x2F;&#x2F; 是否含有某个key (返回true或false)\nsession.has(&quot;key&quot;); \n\n&#x2F;&#x2F; 删值 \nsession.delete(&#39;name&#39;);          \n\n&#x2F;&#x2F; 清空所有值 \nsession.clear();                 \n\n&#x2F;&#x2F; 获取此 Session 的所有key (返回Set&lt;String&gt;)\nsession.keys();\n\n&#x2F;&#x2F; 返回此 Session 的id \nsession.getId();                          \n\n&#x2F;&#x2F; 返回此 Session 的创建时间 (时间戳) \nsession.getCreateTime();                  \n\n&#x2F;&#x2F; 返回此 Session 会话上的底层数据对象（如果更新map里的值，请调用session.update()方法避免产生脏数据）\nsession.getDataMap();                     \n\n&#x2F;&#x2F; 将这个 Session 从持久库更新一下\nsession.update();                         \n\n&#x2F;&#x2F; 注销此 Session 会话 (从持久库删除此Session)\nsession.logout();\n\n5.框架配置############## Sa-Token 配置 (文档: &lt;https:&#x2F;&#x2F;sa-token.cc&gt;) ##############\nsa-token: \n    # token名称 (同时也是cookie名称)\n    token-name: satoken\n    # token有效期，单位s 默认30天, -1代表永不过期 \n    timeout: 2592000\n    # token临时有效期 (指定时间内无操作就视为token过期) 单位: 秒\n    activity-timeout: -1\n    # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录) \n    is-concurrent: true\n    # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token) \n    is-share: true\n    # token风格\n    token-style: uuid\n    # 是否输出操作日志 \n    is-log: false\n\n6.Sa-Token集成Redis\nMaven\n&lt;!-- Sa-Token 整合 Redis （使用 jdk 默认序列化方式） --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;cn.dev33&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;sa-token-dao-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.34.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- 提供Redis连接池 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n配置\nspring: \n    # redis配置 \n    redis:\n        # Redis数据库索引（默认为0）\n        database: 1\n        # Redis服务器地址\n        host: 127.0.0.1\n        # Redis服务器连接端口\n        port: 6379\n        # Redis服务器连接密码（默认为空）\n        # password: \n        # 连接超时时间\n        timeout: 10s\n        lettuce:\n            pool:\n                # 连接池最大连接数\n                max-active: 200\n                # 连接池最大阻塞等待时间（使用负值表示没有限制）\n                max-wait: -1ms\n                # 连接池中的最大空闲连接\n                max-idle: 10\n                # 连接池中的最小空闲连接\n                min-idle: 0\n\n7.前后端分离\n常规Web端可以使用Cookie进行鉴权（后端控制写入、请求自动提交），但是在app、小程序等前后端分离的场景，一般没有Cookie这一功能，可以通过如下方式\n\n不能后端控制写入了，就前端自己写入。（难点在后端如何将 Token 传递到前端）\n&#x2F;&#x2F; 登录接口\n@RequestMapping(&quot;doLogin&quot;)\npublic SaResult doLogin() &#123;\n    &#x2F;&#x2F; 第1步，先登录上 \n    StpUtil.login(10001);\n    &#x2F;&#x2F; 第2步，获取 Token 相关参数(tokenName和tokenValue)\n    SaTokenInfo tokenInfo &#x3D; StpUtil.getTokenInfo();\n    &#x2F;&#x2F; 第3步，返回给前端，并保存在前端\n    return SaResult.data(tokenInfo);\n&#125;\n每次请求不能自动提交了，那就手动提交。（难点在前端如何将 Token 传递到后端，同时后端将其读取出来）\n&#x2F;&#x2F; 1、首先在登录时，将tokenName和tokenValue一起存储在本地，例如：\nuni.setStorageSync(&#39;tokenName&#39;, tokenName); \nuni.setStorageSync(&#39;tokenValue&#39;, tokenValue); \n\n&#x2F;&#x2F; 2、在发起ajax的地方，获取这两个值, 并组织到head里 \nvar tokenName &#x3D; uni.getStorageSync(&#39;tokenName&#39;);    &#x2F;&#x2F; 从本地缓存读取tokenName值\nvar tokenValue &#x3D; uni.getStorageSync(&#39;tokenValue&#39;);    &#x2F;&#x2F; 从本地缓存读取tokenValue值\nvar header &#x3D; &#123;\n    &quot;content-type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;\n&#125;;\nif (tokenName !&#x3D; undefined &amp;&amp; tokenName !&#x3D; &#39;&#39;) &#123;\n    header[tokenName] &#x3D; tokenValue;\n&#125;\n\n&#x2F;&#x2F; 3、后续在发起请求时将 header 对象塞到请求头部 \nuni.request(&#123;\n    url: &#39;&lt;https:&#x2F;&#x2F;www.example.com&#x2F;request&gt;&#39;, &#x2F;&#x2F; 仅为示例，并非真实接口地址。\n    header: header,\n    success: (res) &#x3D;&gt; &#123;\n        console.log(res.data);    \n    &#125;\n&#125;);\n\n\n\n8.密码加密\n封装的加密算法\n\n摘要加密（md5、sha1、sha256）\n&#x2F;&#x2F; md5加密 \nSaSecureUtil.md5(&quot;123456&quot;);\n\n&#x2F;&#x2F; sha1加密 \nSaSecureUtil.sha1(&quot;123456&quot;);\n\n&#x2F;&#x2F; sha256加密 \nSaSecureUtil.sha256(&quot;123456&quot;);\n对称加密（AES）\n&#x2F;&#x2F; 定义秘钥和明文\nString key &#x3D; &quot;123456&quot;;\nString text &#x3D; &quot;Sa-Token 一个轻量级java权限认证框架&quot;;\n\n&#x2F;&#x2F; 加密 \nString ciphertext &#x3D; SaSecureUtil.aesEncrypt(key, text);\nSystem.out.println(&quot;AES加密后：&quot; + ciphertext);\n\n&#x2F;&#x2F; 解密 \nString text2 &#x3D; SaSecureUtil.aesDecrypt(key, ciphertext);\nSystem.out.println(&quot;AES解密后：&quot; + text2);\n非对称加密（RSA）\n&#x2F;&#x2F; 定义私钥和公钥 \nString privateKey &#x3D; &quot;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAO+wmt01pwm9lHMdq7A8gkEigk0XKMfjv+4IjAFhWCSiTeP7dtlnceFJbkWxvbc7Qo3fCOpwmfcskwUc3VSgyiJkNJDs9ivPbvlt8IU2bZ+PBDxYxSCJFrgouVOpAr8ar&#x2F;b6gNuYTi1vt3FkGtSjACFb002&#x2F;68RKUTye8&#x2F;tdcVilAgMBAAECgYA1COmrSqTUJeuD8Su9ChZ0HROhxR8T45PjMmbwIz7ilDsR1+E7R4VOKPZKW4Kz2VvnklMhtJqMs4MwXWunvxAaUFzQTTg2Fu&#x2F;WU8Y9ha14OaWZABfChMZlpkmpJW9arKmI22ZuxCEsFGxghTiJQ3tK8npj5IZq5vk+6mFHQ6aJAQJBAPghz91Dpuj+0bOUfOUmzi22obWCBncAD&#x2F;0CqCLnJlpfOoa9bOcXSusGuSPuKy5KiGyblHMgKI6bq7gcM2DWrGUCQQD3SkOcmia2s&#x2F;6i7DUEzMKaB0bkkX4Ela&#x2F;xrfV+A3GzTPv9bIBamu0VIHznuiZbeNeyw7sVo4&#x2F;GTItq&#x2F;zn2QJdBAkEA8xHsVoyXTVeShaDIWJKTFyT5dJ1TR++&#x2F;udKIcuiNIap34tZdgGPI+EM1yoTduBM7YWlnGwA9urW0mj7F9e9WIQJAFjxqSfmeg40512KP&#x2F;ed&#x2F;lCQVXtYqU7U2BfBTg8pBfhLtEcOg4wTNTroGITwe2NjL5HovJ2n2sqkNXEio6Ji0QQJAFLW1Kt80qypMqot+mHhS+0KfdOpaKeMWMSR4Ij5VfE63WzETEeWAMQESxzhavN1WOTb3&#x2F;p6icgcVbgPQBaWhGg&#x3D;&#x3D;&quot;;\nString publicKey &#x3D; &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDvsJrdNacJvZRzHauwPIJBIoJNFyjH47&#x2F;uCIwBYVgkok3j+3bZZ3HhSW5Fsb23O0KN3wjqcJn3LJMFHN1UoMoiZDSQ7PYrz275bfCFNm2fjwQ8WMUgiRa4KLlTqQK&#x2F;Gq&#x2F;2+oDbmE4tb7dxZBrUowAhW9NNv+vESlE8nvP7XXFYpQIDAQAB&quot;;\n&#x2F;&#x2F; 生成一对公钥和私钥，其中Map对象 (private&#x3D;私钥, public&#x3D;公钥)\nSystem.out.println(SaSecureUtil.rsaGenerateKeyPair());\n\n&#x2F;&#x2F; 文本\nString text &#x3D; &quot;Sa-Token 一个轻量级java权限认证框架&quot;;\n\n&#x2F;&#x2F; 使用公钥加密\nString ciphertext &#x3D; SaSecureUtil.rsaEncryptByPublic(publicKey, text);\nSystem.out.println(&quot;公钥加密后：&quot; + ciphertext);\n\n&#x2F;&#x2F; 使用私钥解密\nString text2 &#x3D; SaSecureUtil.rsaDecryptByPrivate(privateKey, ciphertext);\nSystem.out.println(&quot;私钥解密后：&quot; + text2);\n\n\n\n9.多账号体系认证\n比如一个电商系统同时有user表和admin表，两套账号都适用StpUtil类的API进行登陆鉴权，势必会发生逻辑冲突\n\nstpLogic：StpUtil只是对成员变量stpLogic的各个API包装一下进行转发，这样的实现有以下好处\n\nStpLogic 类的所有函数都可以被重写，按需扩展\n在构造方法时随意传入一个不同的 loginType，就可以再造一套账号登录体系\n\n\n示例\n\n对于原生StpUtil类，只做admin账号权限认证，而对于user账号，则新建一个权限认证类（StpUserUtil.java），将StpUtil代码全部复制到StpUserUtil中，更改一下他的loginType，其它使用方式相同\npublic class StpUserUtil &#123;\n    \n    &#x2F;**\n     * 账号体系标识 \n     *&#x2F;\n    public static final String TYPE &#x3D; &quot;user&quot;;    &#x2F;&#x2F; 将 LoginType 从&#96;login&#96;改为&#96;user&#96; \n\n    &#x2F;&#x2F; 其它代码 ... \n\n&#125;\n相关注解的使用：默认只支持StpUtil类\n&#x2F;&#x2F; 通过type属性指定此注解校验的是我们自定义的&#96;StpUserUtil&#96;，而不是原生&#96;StpUtil&#96;\n@SaCheckLogin(type &#x3D; StpUserUtil.TYPE)\n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n使用自定义注解简化前一种方式\n\n重写Sa-Token默认的注解处理器\n@Configuration\npublic class SaTokenConfigure &#123;\n    @Autowired\n    public void rewriteSaStrategy() &#123;\n        &#x2F;&#x2F; 重写Sa-Token的注解处理器，增加注解合并功能 \n        SaStrategy.me.getAnnotation &#x3D; (element, annotationClass) -&gt; &#123;\n            return AnnotatedElementUtils.getMergedAnnotation(element, annotationClass); \n        &#125;;\n    &#125;\n&#125;\n自定义一个注解\n&#x2F;**\n * 登录认证(User版)：只有登录之后才能进入该方法 \n * &lt;p&gt; 可标注在函数、类上（效果等同于标注在此类的所有方法上） \n *&#x2F;\n@SaCheckLogin(type &#x3D; &quot;user&quot;)\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)\npublic @interface SaUserCheckLogin &#123;\n    \n&#125;\n使用示例\n&#x2F;&#x2F; 使用 @SaUserCheckLogin 的效果等同于使用：@SaCheckLogin(type &#x3D; &quot;user&quot;)\n@SaUserCheckLogin\n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n\n\n\n\n同端多登陆\n\n一个设备同时可以登陆两套账户，可能会发生token覆盖的问题，新登陆的token会覆盖掉旧的token\n\n解决办法：更改StpUserUtil（前文配置的新类）的TokenName\npublic class StpUserUtil &#123;\n    \n    &#x2F;&#x2F; 使用匿名子类 重写&#96;stpLogic对象&#96;的一些方法 \n    public static StpLogic stpLogic &#x3D; new StpLogic(&quot;user&quot;) &#123;\n        &#x2F;&#x2F; 重写 StpLogic 类下的 &#96;splicingKeyTokenName&#96; 函数，返回一个与 &#96;StpUtil&#96; 不同的token名称, 防止冲突 \n        @Override\n        public String splicingKeyTokenName() &#123;\n            return super.splicingKeyTokenName() + &quot;-user&quot;;\n        &#125;\n        &#x2F;&#x2F; 同理你可以按需重写一些其它方法 ... \n    &#125;; \n    &#x2F;&#x2F; ... \n&#125;\n再次调用 StpUserUtil.login(10001)进行登录授权时，token的名称将不再是 satoken，而是我们重写后的 satoken-user\n\n\n\n不同体系不同SaTokenConfig配置：自定义的 StpUserUtil 需要使用不同 SaTokenConfig 对象\npublic class StpUserUtil &#123;\n    \n    &#x2F;&#x2F; 使用匿名子类 重写&#96;stpLogic对象&#96;的一些方法 \n    public static StpLogic stpLogic &#x3D; new StpLogic(&quot;user&quot;) &#123;\n        \n        &#x2F;&#x2F; 首先自定义一个 Config 对象 \n        SaTokenConfig config &#x3D; new SaTokenConfig()\n            .setTokenName(&quot;satoken&quot;)\n            .setTimeout(2592000)\n            &#x2F;&#x2F; ... 其它set\n            ;\n        \n        &#x2F;&#x2F; 然后重写 stpLogic 配置获取方法 \n        @Override\n        public SaTokenConfig getConfig() &#123;\n            return config;\n        &#125;\n    &#125;;\n    \n    &#x2F;&#x2F; ... \n    \n&#125;\n多账号体系下，在拦截器中给一个接口登录鉴权的方法如下\n&#x2F;&#x2F; 注册 Sa-Token 拦截器\n@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n    registry.addInterceptor(new SaInterceptor(handle -&gt; &#123;\n        \n        &#x2F;&#x2F; 如果这个接口，要求客户端登录了后台 Admin 账号才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; StpUtil.checkLogin());\n\n        &#x2F;&#x2F; 如果这个接口，要求客户端登录了前台 User 账号才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; StpUserUtil.checkLogin());\n        \n        &#x2F;&#x2F; 如果这个接口，要求客户端同时登录 Admin 和 User 账号，才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; &#123;\n            StpUtil.checkLogin();\n            StpUserUtil.checkLogin();\n        &#125;);\n\n        &#x2F;&#x2F; 如果这个接口，要求客户端登录 Admin 和 User 账号任意一个，就能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; &#123;\n            if(StpUtil.isLogin() &#x3D;&#x3D; false &amp;&amp; StpUserUtil.isLogin() &#x3D;&#x3D; false) &#123;\n                throw new SaTokenException(&quot;请登录后再访问接口&quot;);\n            &#125;\n        &#125;);\n        \n    &#125;)).addPathPatterns(&quot;&#x2F;**&quot;);\n&#125;\n\n","slug":"SaToken","date":"2023-04-13T10:50:40.000Z","categories_index":"","tags_index":"","author_index":"Dajunnnnnn"},{"id":"ef3b137ddfca595334a5f18eaa3f5f69","title":"算法基础","content":"算法基础1.数据结构1.1常用方法\n\n\n接口\nAPI\n\n\n\nCollection\nsize、isEmpty、contains、toArray、add、remove、clear\n\n\nList\nget(index)、set(index)、add(index,element)、remove(index)、indexOf()、lastIndexOf()、subList(from, to)、sort\n\n\nQueue\noffer(element)、poll()、peek()\n\n\nDuque\nofferFirst(E e)、offerLast(E e)、pollFirst()、pollLast()、peekFirst()、peekLast()、push(E e)、pop()\n\n\nSet\nsize、isEmpty、contains、toArray、add、remove\n\n\nSortedSet\nSortedSet subSet(E fromElement, E toElement)、headSet(E toElement)、tailSet(E fromElement)、first、last\n\n\nMap\nsize、isEmpty、containsKey、containsValue、get、put、remove、keySet、values、entrySet\n\n\nMap补\ngetOrDefault(Object key, V defaultValue)、putIfAbsent(K key, V value)、replace(K key, V oldValue, V newValue)\n\n\n1.2工具类\n\n\n类名\nAPI\n\n\n\nString\ncharAt、toCharArray、split、substring（新String）、indexOf、lastIndexOf、replace、length\n\n\nString补\ntrim、toLowerCase、toUpperCase、split(String regex)、format（格式化输出，同c）\n\n\nStringBuilder\nappend、toString、charAt、length、delete、replace、insert、reverse、indexOf、lastIndexOf\n\n\nCollections\nsort、binarySearch、reverse、swap、fill、copy、replaceAll、emptyXXX\n\n\nArrays\nsort、binarySearch、equals、fill、asList、copyOf、copyOfRange\n\n\nMath\nmin、max、abs、sqrt(double)、pow(double, double)、ceil（上整）、floor（下整）、round（四舍五入）\n\n\nMath补\nInteger.MAX_VALUE、Integer.MIN_VALUE、\n\n\nScanner\nnextInt、nextLong、nextLine（nextInt不会洗掉换行符，需要nextLine吸掉）\n\n\nSystem.out\nprintln、print、format(“x = %d, y = %f\\n”, x, y)\n\n\n1.3补充知识\nArrayList\n\n实现特殊接口\n\nRandomAccess：Arrays的静态方法binarySearch会根据接口调用不同的实现方法\nCloneable：使用clone方法，返回一个浅拷贝\n\n\n底层为可动态扩容的数组（支持存储null数据）\n\n首先==确定最小扩容量==，默认最小为10，如果传入的所需容量比10大，则按传入的所需容量来扩容\n\n然后==判断是否需要扩容==，如果前一阶段判定的需要容量比内部数组的长度大，则进行扩容\n\n使用位移操作，将容量扩展为内部数组长度的1.5倍，如果比需要容量小，则直接使用需要容量，防止多次扩容，然后使用System.arraycopy来复制数据\npublic static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);\n\n\n使用modCount：来记录容量更改的次数，每次调用ensureCapacityInternal就将modCount加1，容量不够使才改容量。用来确定迭代的过程中，是否有其他线程更改过数据，如果有人修改过，则抛出ConcurrentModificationException异常\n\n\n\nLinkedList\n\n可以根据引用的接口不同，使用不同方法，支持List、Queue、Deque，根据结构的不同可以调用不同的方法\n底层为双向链表，并且有头尾指针，支持存储null数据\n\n\nArrayDeque\n\n基于数组实现，性能比LinkedList好，也可用来实现栈\n\n\nPriorityQueue\n\n底层依赖堆来实现（使用可变长数组），默认情况下为小顶堆，最先出队列的为当前队列中的最小值，支持Comparator接口\nQueue&lt;Integer&gt; minH &#x3D; new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;小顶堆，默认大小为11\nQueue&lt;Integer&gt; maxH &#x3D; new PriorityQueue&lt;&gt;((i1, i2) -&gt; i2 - i1); &#x2F;&#x2F;大顶堆，默认大小为11\n不支持存储NULL和non-comparable对象，通过堆元素的上浮和下沉，实现了在O(logn)的时间复杂度内插入和删除堆顶元素\n\n堆的构建过程，需要比较节点中数据的大小，所以，添加到优先级队列中的元素，需要能够比较大小，方法有两种：基于Comparable接口和基于Comparator接口，都有时则优先使用comparator，详见siftUp\nprivate void siftUp(int k, E x) &#123;\n    if (comparator !&#x3D; null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n&#125;\n\n\nSet（HashSet、LinkedHashSet、TreeSet）\n\n底层实现分别为：HashMap、LinkedHashMap、TreeMap，存储对象的时候，使用对象作为key，一个空的Object对象作为value，插入到底层的Map中，不管\n如何检查重复：无论Set中是否已经存在了某元素，都会直接在底层进行插入，通过add方法的返回值来确定插入前是否有相同的元素\n应用场景：HashSet用于==不需要保证元素插入和取出顺序==的场景；LinkedHashSet用于==保证元素的插入和取出顺序满足FIFO==的场景（LinedHashMap底层使用双向有序链表+哈希表）；TreeSet用于支持对元素==自定义排序规则==的场景\n\n\nHashMap（==数组+链表/红黑树==）\n\n底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）\n底层数组长度为2的倍数：hash函数可以使用与n-1取交替代与n取余、装载因子使用0.75使得阈值（n*0.75）一直为整数、初始化的时候选择比传入参数大的最小2的幂次方数\n动态扩容：默认初始化大小为16，每次超过阈值的时候就扩容为原来的2倍；扫描数组的每一条链表，根据节点下标决定是否要更改，插入到lo链表（不需改）和hi链表（需要改），处理完一条链表，将新链表插入到对应位置\n新位置确定方式：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）\n链表树化：当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的长度大于等于64时，将会把链表转化为红黑树；如果table长度不满足则触发扩容操作；如果红黑树节点数在[2，6]之间，则退化为链表\n\n\n\n\nArrays的sort\n\nCollections的sort函数底层依赖的Arrays类的sort函数，如List接口中的sort的默认实现\n基本类型：使用==DualPivotQuickSort==，jdk7之前使用快排\n对快排进行改进，选取两个pivot，通过数组的长度决定什么时候选用双轴快排、插入排序、归并排序、记数排序\n\n\n对象数组：使用==TimSort==，jdk7之前使用归并\n使用非递归版本归并排序算法，在归并排序的过程中，大的排序区间不断分解为小的待排序区间，如果带排序区间的长度小于MIN_MERGE（32），就不再继续分解，转而执行二分插入排序算法\n二分插入排序：将数组分为已排序区间和未排序区间，通过二分查找，查找插入位置，当找到后，通过调用System.arraycopy()函数，将插入点之后的数据整体快速后移一位，腾出位置给要插入的数据\n\n\n\n\nString（final数组）\n\nString不可变的原因：内部是final修饰的数组（引用不可改但是数据可改）、没有提供更改数组的方法、String类也是final的子类无法继承，避免了子类破坏String的不变性\n常量池技术：使用字符串常量赋值时触发，直接复用常量池已存在的对象，也可以使用intern方法复制堆上对象到常量池并回收堆上的对象\n运算符重载：因为String比较常用，所以延续了基本类型和包装类的设计，实现了加法操作String sc = sa + sb;，底层使用了StringBuilder来实现（StringBuffer加了锁，是线程安全的）\n\n\n\n2.算法2.1复杂度分析\n分析方法\n加法原则：总复杂度等于量级最大的那段代码的复杂度\n乘法原则：嵌套代码的复杂度等于嵌套内外的代码复杂度乘积\n其他方法：某一条语句执行的总次数；数据被访问的次数；使用递归树来分析\n\n\n空间复杂度\n不关注存储数据所需要的空间，而是关注算法所需要的额外存储消耗（循环、递归调用栈、辅助存储）\n由于现有题型大多以耗时为指标，所以尽可能使用==以空间换时间==的思想\n\n\n时间复杂度\n不看低阶和常数系数、加法取大、乘法取积\n分类：最好、最坏、平均\n\n\n\n2.2技巧\n双指针\n\n前缀和数组：原始数组不会被修改的情况下，频繁查询某个区间的累加和\n\n前缀和数组中两个元素的差，及这段区间的累加和\n示例：原数组{3,5,2,-1,4,1}；前缀和数组{0,3,8,10,8,12,13}\n\n\n差分数组：频繁对原数组的某个区间的元素进行增减\n\n原理：对i→n的所有元素都加3，对j+1→n的所有元素都减3\n示例：原数组{8,2,6,3,1}；差分数组{8,-6,4,-3,-2}\n\n\n并查集（Union-Find）\nclass UF &#123;\n    &#x2F;&#x2F; 连通分量个数\n    private int count;\n    &#x2F;&#x2F; 存储每个节点的父节点\n    private int[] parent;\n\n    &#x2F;&#x2F; n 为图中节点的个数\n    public UF(int n) &#123;\n        this.count &#x3D; n;\n        parent &#x3D; new int[n];\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            parent[i] &#x3D; i;\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 将节点 p 和节点 q 连通\n    public void union(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        \n        if (rootP &#x3D;&#x3D; rootQ)\n            return;\n        \n        parent[rootQ] &#x3D; rootP;\n        &#x2F;&#x2F; 两个连通分量合并成一个连通分量\n        count--;\n    &#125;\n\n    &#x2F;&#x2F; 判断节点 p 和节点 q 是否连通\n    public boolean connected(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        return rootP &#x3D;&#x3D; rootQ;\n    &#125;\n\n    public int find(int x) &#123;\n        if (parent[x] !&#x3D; x) &#123;\n            parent[x] &#x3D; find(parent[x]);\n        &#125;\n        return parent[x];\n    &#125;\n\n    &#x2F;&#x2F; 返回图中的连通分量个数\n    public int count() &#123;\n        return count;\n    &#125;\n&#125;\nTree\n\n根据数组构建节点结构\npublic class Solution &#123;\n    static class TreeNode &#123;\n        int val;\n        TreeNode left;\n        TreeNode right;\n        public TreeNode(int x) &#123;\n            this.val &#x3D; x;\n            this.left &#x3D; null;\n            this.right &#x3D; null;\n        &#125;\n    &#125;\n    \n    &#x2F;**\n     * 根据数组构建二叉树\n     * @param arr 树的数组表示\n     * @return 构建成功后树的根节点\n     *&#x2F;\n    public TreeNode constructBinaryTree(final int[] arr) &#123;\n        &#x2F;&#x2F; 构建和原数组相同的树节点列表\n        List&lt;TreeNode&gt; treeNodeList &#x3D; arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;\n        TreeNode root &#x3D; null;\n        &#x2F;&#x2F; 把输入数值数组，先转化为二叉树节点列表\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; null;\n            if (arr[i] !&#x3D; -1) &#123; &#x2F;&#x2F; 用 -1 表示null\n                node &#x3D; new TreeNode(arr[i]);\n            &#125;\n            treeNodeList.add(node);\n            if (i &#x3D;&#x3D; 0) &#123;\n                root &#x3D; node;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 遍历一遍，根据规则左右孩子赋值就可以了\n        &#x2F;&#x2F; 注意这里 结束规则是 i * 2 + 1 &lt; arr.length，避免空指针\n        &#x2F;&#x2F; 为什么结束规则不能是i * 2 + 2 &lt; arr.length呢?\n        &#x2F;&#x2F; 如果i * 2 + 2 &lt; arr.length 是结束条件\n        &#x2F;&#x2F; 那么i * 2 + 1这个符合条件的节点就被忽略掉了\n        &#x2F;&#x2F; 例如[2,7,9,-1,1,9,6,-1,-1,10] 这样的一个二叉树,最后的10就会被忽略掉\n        for (int i &#x3D; 0; i * 2 + 1 &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; treeNodeList.get(i);\n            if (node !&#x3D; null) &#123;\n                &#x2F;&#x2F; 线性存储转连式存储关键逻辑\n                node.left &#x3D; treeNodeList.get(2 * i + 1);\n                &#x2F;&#x2F;  再次判断下 不忽略任何一个节点\n                if(i * 2 + 2 &lt; arr.length)\n                node.right &#x3D; treeNodeList.get(2 * i + 2);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n&#125;\n直接构建邻接表\nList&lt;Integer&gt;[] adjs &#x3D; new ArrayList[n];\nfor(int i &#x3D; 0; adjs.size(); i++)&#123;\n  adjs[i] &#x3D; new ArrayList&lt;&gt;();\n&#125;\nfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n  adjs[father].add(son);\n&#125;\n\n\nGraph\n&#x2F;&#x2F; 邻接表\n&#x2F;&#x2F; graph[x] 存储 x 的所有邻居节点\nList&lt;Integer&gt;[] graph;\n\n&#x2F;&#x2F; 邻接矩阵\n&#x2F;&#x2F; matrix[x][y] 记录 x 是否有一条指向 y 的边\nboolean[][] matrix;\n\n2.3算法思想\n排序\n\n基础排序算法\n\nO（n^2）\n\n冒泡排序：一对对比较，一对对交换\n\n插入排序：分为已排和未排区间，取未排插入到已排。例：希尔排序\n\n选择排序：分为已排和未排区间，从未排选一个最小的插入到已排的\n\n希尔排序\n\n\n\nO（nlogn）\n\n归并排序：“分治思想”，分而治之，然后再合并\n\n快速排序：选一个pivot，大的放左，小的放右\n\n堆排序：先将数组原地建成一个堆，从下往上堆化，取堆顶元素，将下标n的元素放到堆顶，堆化\n\n二叉排序树排序\n\n\n\nO（n）\n\n计数排序：例：10G数据，100个桶\n\n基数排序：高考成绩排序，760个桶\n\n桶排序：10万个手机号码排序，从个位开始一位位进行桶或基数排序\n\n\n\n\n\n常见题型\n\n特殊排序：不是单纯的增减顺序，而是有一些特殊要求\nTop K：找到前K个大的，第K个大的……\n链表上的排序：数据结构由数组转换为链表，并进行排序\n排序预处理：排序只是问题的一部分预处理，可以运用库函数\n区间问题：（252题、56题） 先排序，再处理\n\n\n\n\n二分查找：大部分都是变形二分查找或二分答案，代码不长，但容易写对。难点在于：确定搜索区间，循环条件，区间更新，返回值\n\n查找区间永远是闭区间[low,high]\n\n循环条件永远是：low &lt;= high\n\n对于low == high的情况，必要的时候特殊处理，在while内部补充退出条件\n\n返回值永远是mid，而不是low，high\n\nlow、high的更新永远是low = mid + 1和high = mid - 1\n\n对于非确定性查找，使用前后探测法，来确定搜索区间（不用while，而只更新low或high）\n\n先处理命中情况，再处理在左右半部分查找的情况\n\n非确定查找：第一个、最后一个、第一个大于等于、最后一个小于等于、循环数组寻找最小值、寻找峰值\n\n\n\nbfs\n&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离\nint BFS(Node start, Node target) &#123;\n    Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构\n    Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路\n    \n    q.offer(start); &#x2F;&#x2F; 将起点加入队列\n    visited.add(start);\n    int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数\n\n    while (q not empty) &#123;\n        int sz &#x3D; q.size();\n        &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F;\n        for (int i &#x3D; 0; i &lt; sz; i++) &#123;\n            Node cur &#x3D; q.poll();\n            &#x2F;* 划重点：这里判断是否到达终点 *&#x2F;\n            if (cur is target)\n                return step;\n            &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F;\n            for (Node x : cur.adj()) &#123;\n                if (x not in visited) &#123;\n                    q.offer(x);\n                    visited.add(x);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;* 划重点：更新步数在这里 *&#x2F;\n        step++;\n    &#125;\n&#125;\ndfs\n\n递归\n\n代码技巧：千万不要试图想清楚整个递和归的执行过程，实际上是进入了一个思维误区\n\n怎么发现这个问题可以用递归来做：\n\n规模更小的问题，跟规模大点的问题，解决思路相同，但规模不同\n\n利用子问题的解可以组合得到原问题的解\n\n存在最小子问题，可以直接返回结果，即存在递归终止条件\n\n\n\n递归的正确编写姿势：\n\n我们可以假设子问题B,C已经解决，在此基础上思考如何解决原问题A，基于此，找递推公式+终止条件，然后翻译成代码\n\n\n\n\n时间复杂度和空间复杂度分析：\n\n时间复杂度：递推公式或者递归树\n空间复杂度：跟递归的函数调用栈最大深度成正比，即递归树的高度\n\n\n解题技巧：寻找重复结构，是否能将问题结构转化成结构相同，规模更小的子问题，然后写递推公式，包括递归终止条件，然后翻译成代码\n\n原问题解决思路和子问题解决思路是否一样\n\n子问题的解能否构造出原问题的解（递推公式）\n\n找到最小子问题（终止条件）\n\n\n\n\n\n回溯：回溯是递归的副产品，只要有递归就会有回溯，本质就是穷举+剪枝\nresult &#x3D; []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n    \n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\ndfs\npublic List&lt;Integer&gt; dfs(int s,int t)&#123;\n        List&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();\n        path.add(s);\n        visited[s] &#x3D; true;\n        dfs_backtrack(s,t,path);\n        return resultPath;\n    &#125;\n\n    public void dfs_backtrack(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                path.add(q);\n                visited[q] &#x3D; true;\n                dfs_backtrack(q,t,path);\n                path.remove(path.size()-1);\n            &#125;\n        &#125;\n    &#125;\n\n\ndp\n\n解题步骤\n\n可用回溯解决：使用穷举结果才能得到结果的问题（最值、可行、计数等）\n构建多阶段决策模型：看是否能将问题求解的过程分为多个阶段\n查看是否存在重复子问题：是否有多个路径到达同一状态\n定义状态：也就是如何记录每一阶段的不重复状态\n定义状态转移方程：也就是找到如何通过上一阶段的状态推导下一阶段的状态\n画状态转移表：辅助理解，验证正确性，确定状态转移的初始值\n\n\n代码结构\n# 自顶向下递归的动态规划\ndef dp(状态1, 状态2, ...):\n    for 选择 in 所有可能的选择:\n        # 此时的状态已经因为做了选择而改变\n        result &#x3D; 求最值(result, dp(状态1, 状态2, ...))\n    return result\n\n# 自底向上迭代的动态规划\n# 初始化 base case\ndp[0][0][...] &#x3D; base case\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)\n0-1背包的最值、可行、计数\n\n最值1：有n个物品，选择其中一些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装物品总重量的最大值是多少\n\n最值2：有n个物品，选择其中一些物品装入背包，正好装满背包所需物品最小个数（如果装不满，返回-1）\n\n可行：有n个物品，选择其中一些物品装入背包，能不能正好装满背包\n\n计数：有n个物品，选择其中一些物品装入背包，装满背包有多少种不同的装法\n\n\n\n完全背包（同一个物品可装n次）的最值、可行、计数\n\n背包可装物品总重量的最大值是多少\n是否能装满整个背包\n正好装满背包至少需要多少物品\n装满背包有多少种装法\n\n\n空间优化\n\n\n\n\n3.补充1.二叉树相关代码\n构建\npublic class TreeNode &#123;\n    int val;\n  \tTreeNode left;\n  \tTreeNode right;\n  \tTreeNode() &#123;&#125;\n  \tTreeNode(int val) &#123; this.val &#x3D; val; &#125;\n  \tTreeNode(int val, TreeNode left, TreeNode right) &#123;\n    \t\tthis.val &#x3D; val;\n    \t\tthis.left &#x3D; left;\n    \t\tthis.right &#x3D; right;\n  \t&#125;\n&#125;\n\n递归遍历\n&#x2F;&#x2F; 前序遍历·递归·LC144_二叉树的前序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n&#x2F;&#x2F; 中序遍历·递归·LC94_二叉树的中序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        inorder(root, res);\n        return res;\n    &#125;\n\n    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        inorder(root.left, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n        inorder(root.right, list);\n    &#125;\n&#125;\n&#x2F;&#x2F; 后序遍历·递归·LC145_二叉树的后序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        postorder(root, res);\n        return res;\n    &#125;\n\n    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        postorder(root.left, list);\n        postorder(root.right, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n    &#125;\n&#125;\n非递归遍历\n&#x2F;&#x2F; 前序遍历顺序：中-左-右，入栈顺序：中-右-左\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 中序遍历顺序: 左-中-右 入栈顺序： 左-右\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        TreeNode cur &#x3D; root;\n        while (cur !&#x3D; null || !stack.isEmpty())&#123;\n           if (cur !&#x3D; null)&#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;else&#123;\n               cur &#x3D; stack.pop();\n               result.add(cur.val);\n               cur &#x3D; cur.right;\n           &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;\n层序遍历\n&#x2F;&#x2F; 102.二叉树的层序遍历\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; resList &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        &#x2F;&#x2F;checkFun01(root,0);\n        checkFun02(root);\n\n        return resList;\n    &#125;\n\n    &#x2F;&#x2F;DFS--递归方式\n    public void checkFun01(TreeNode node, Integer deep) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        deep++;\n\n        if (resList.size() &lt; deep) &#123;\n            &#x2F;&#x2F;当层级增加时，list的Item也增加，利用list的索引值进行层级界定\n            List&lt;Integer&gt; item &#x3D; new ArrayList&lt;Integer&gt;();\n            resList.add(item);\n        &#125;\n        resList.get(deep - 1).add(node.val);\n\n        checkFun01(node.left, deep);\n        checkFun01(node.right, deep);\n    &#125;\n\n    &#x2F;&#x2F;BFS--迭代方式--借助队列\n    public void checkFun02(TreeNode node) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        Queue&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;TreeNode&gt;();\n        que.offer(node);\n\n        while (!que.isEmpty()) &#123;\n            List&lt;Integer&gt; itemList &#x3D; new ArrayList&lt;Integer&gt;();\n            int len &#x3D; que.size();\n\n            while (len &gt; 0) &#123;\n                TreeNode tmpNode &#x3D; que.poll();\n                itemList.add(tmpNode.val);\n\n                if (tmpNode.left !&#x3D; null) que.offer(tmpNode.left);\n                if (tmpNode.right !&#x3D; null) que.offer(tmpNode.right);\n                len--;\n            &#125;\n\n            resList.add(itemList);\n        &#125;\n\n    &#125;\n&#125;\n翻转二叉树\n&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;\n二叉树的所有路径\n&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;\n前序和后序构造二叉树\nclass Solution &#123;\n    Map&lt;Integer, Integer&gt; map;  &#x2F;&#x2F; 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (inBegin &gt;&#x3D; inEnd || postBegin &gt;&#x3D; postEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(postorder[postEnd - 1]);  &#x2F;&#x2F; 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定后序数列的个数\n        root.left &#x3D; findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right &#x3D; findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    &#125;\n&#125;\n前序和中序构造二叉树\nclass Solution &#123;\n    Map&lt;Integer, Integer&gt; map;\n    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数\n        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,\n                            inorder, inBegin, rootIndex);\n        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,\n                            inorder, rootIndex + 1, inEnd);\n\n        return root;\n    &#125;\n&#125;\n\n2.dp经典问题\n背包问题：0-1、完全、多重、二维费用、分组、有依赖的\n路径问题\n打家劫舍和股票买卖\n一般动态规划问题，上一个阶段做了什么决策，不影响下一个阶段的决策。但是打家劫舍&amp;股票买卖这类问题，上一个阶段的决策会影响下一个阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值\n\n\n爬楼梯\n匹配问题\n\n3.给定边怎么构造二叉树","slug":"算法基础","date":"2023-04-01T04:25:03.000Z","categories_index":"","tags_index":"","author_index":"Dajunnnnnn"}]