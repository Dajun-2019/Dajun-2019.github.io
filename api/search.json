[{"id":"144619318c56e5335eaaf8b275761000","title":"Note-GWY","content":"错题汇总1.言语理解和表达\n\n\n红P11真3\n红P12真1\n红P15真1\n红P16真1\n红P21真1\n红P25真题\n\n\n\n红P29真1\n红P34真6\n红P63真1\n红P68真\n红P71真\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2.判断推理\n\n\n红P141真1\n红P142真2\n红P149真3\n红P153真1\n红P154真\n红P162真2\n\n\n\n红P165真\n红P169真1\n红P169真2\n红P173真\n红P175真\n红P178真2\n\n\n红P178真3\n红P180真2\n红P183真5\n红P185真\n红P188真1\n红P194真1\n\n\n红P194真3\n红P196真1\n红P197真2\n红P197真3\n红P198真1\n红P198真2\n\n\n红P203真2\n红P204真1\n红P204真2\n红P204真3\n红P213真4\n红P215真6\n\n\n红P220真3\n红P224真2\n红P225真1\n红P225真2\n红P226真1\n红P228真1\n\n\n红P228真3\n红P229真2\n红P232真4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n3.资料分析\n\n\n红P248真3\n红P250真3\n红P258真2\n红P258真3\n红P260真\n红P265真1\n\n\n\n红P277真\n红P280真1\n红P281真2\n红P282真\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.数量关系\n\n\n红P81真2\n红P84真1\n红P86真4\n红P86真6\n红P93真5\n红P99真3\n\n\n\nP102真3\n红P108真6\n红P110真8\n红P113真3\n红P115真2\n红P116真4\n\n\n红P119真3\n红P120真4\n红P120真5\n红P127真9\n红P129真2\n红P134真4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n5.常识判断\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n言语理解和表达（40/32’’）\n解题步骤\n看问题：明确提问重点，勾画关键信息，如：具体段落信息、针对的话题或对象、否定式问法\n读材料：带着问题阅读材料，并勾画出与题目相关的关键信息\n做题目：将选型代入原文，与材料进行比对，判断正误\n\n\n阅读方法\n勾画法：这是一种边阅读边勾画标记的阅读方法，在阅读的过程中勾画出与解题相关的重点内容，帮助快速解题\n跳读法：这是一种跳跃式的阅读方法，指在明确阅读目的的情况下，在阅读的过程中有意识地跳过一些非重点信息，提高阅读效率。比如，重点读与阅读目标有关的词盒句子，省略与此无关的其他内容\n精读法：这是一种精细深入的阅读方法。对文中的重点段（如首尾段、过渡段等）、重点句仔细揣摩，理解其深层次的含义，以便更好地解题\n\n\n题型汇总：选词填空、细节判断、主旨观点、标题添加、推断下文、词语理解、语句排序、语句填充\n\n1.选词填空1.分析对应关系\n解释说明关系：上下文互相补充、说明或限定，提示词有以下6类\n含有指代义的词语：这、那、此、这些、这样\n表同义替换的词语：也就是说、或者说、即、无异于\n表归纳概括的词语：可见\n表因果、假设、条件的词语：因此、如果…就/那么…、只有…才…\n表举例论证的词语：也是如此、即是例证、譬如\n表解释说明的符号：冒号、破折号\n\n\n相反相对关系：指上下文之间的意义相反或相对，提示词有以下4类\n转折词：虽然…但是…、却、反而、然而、而、其实\n对照词：不是…而是…、多一些…少一些…、会…不会…\n否定词：不、不能、并非\n变化词：转化为、回归、从…到…、变得\n\n\n并举关系：指上下文之间并行并列，具有语义一致、语气一致、构词一致的特点\n递进关系：指上下文中，下文的意思比上文的意思更近一层，一般由轻到重，由浅到深。提示词有：甚至、更、还、以至、乃至、并且、进而、不仅/不光/不但…而且…、尚且…何况…\n\n2.辨析词语差异\n词语的搭配：有些词语虽语义相近，但可搭配的对象却不相同\n如启用只适用于物、起用只适用于人\n社会的使用习惯：仁者见仁与智者见智、众口铄金与积毁销骨、众说纷纭与莫衷一是\n\n\n词义的侧重点：指词语在语义上的侧重点\n如制订侧重订，即草拟过程；制定侧重定，即决定\n\n\n词义的轻重：指词语在表达的程度上有轻重之别\n如避免的程度很轻；但杜绝的程度较重\n\n\n词语的感情色彩：词语的感情色彩包括褒义、贬义、中性三种\n如成果为褒义词、后果为贬义词、结果为中性词\n\n\n词语的语体色彩：又叫文体色彩，包括书面语色彩、口头语色彩两类\n如惦记是口头语、牵挂是书面语\n\n\n词语的语法语用：语义重复的词语不能连用（大约与左右不能同时用）、词性误用、乱接宾语（截止后不能接时间，若要接时间，必须与到连用）\n\n2.片段阅读1.细节判断\n无中生有：选项的内容在文段中没有提及，或者是依据文段中的某一信息，凭空捏造出的相似或相关的信息\n概念变化：选项中的概念与原文中提到的概念，看似相似但实际上不是同一概念，或者由于修饰语的改变或缺失导师概念的内涵和外延发生了扩大和缩小\n颠倒黑白：指选项内容与原文内容相反，违背文意\n绝对表述：指在原文内容的基础上加了“最”、“都”等限定词，导致选项内容与原文相比绝对化了\n强加比较：指选项将文段中的某些对象强行比较，而文段没有比较之意\n混淆逻辑：指选项故意混淆事物之间的因果关系，主要有两种形式：\n强加因果：指两个事物之间不存在因果关系，但强行认为两者之间存在因果关系\n因果倒置：指两个事物之间存在因果关系，但是“因”与“果”出现了颠倒\n\n\n\n2.主旨观点\nf概括归纳型：材料类型有两种\n列举不同事物：总结出几个事例的共同点，正确答案必须适用于每个事例，迷惑项一般只适用于一个或多个部分事例\n剖析同一事物：一般为剖析同一事物的不同方面、不同特性、不同时期，需要提炼各层次的要点，并加和得出结论\n\n\n判断意图型：材料多是议论文，作者明确提出了观点，解题关键是梳理行文思路、把握关键词语来抓材料论述重点\n梳理行文思路\n总分式结构：通常分为总分、分总、总分总，首尾句是文段的主旨句，多关注首尾句\n转折式结构：指文段前后发生转折，转折之后的内容是文段的论述重点，准确理解转折之后的内容\n\n\n把握关键词语\n高频词：可通过高频词把握作者的论述主题\n强调词：作者在表达自己的观点时，为了引起读者的注意常使用一些语气比较重的词语，其所在的句子通常为文段重点，阅读文段时关注这些强调词来把握作者的倾向\n\n\n\n\n\n3.其他题型\n标题添加：在归纳主旨后，选择简洁凝练、吸人眼球的标题\n紧扣主旨：梳理行文结构，归纳主旨，是解答标题添加题的基础\n简洁凝练：要求标题用较少的字数概括出文段的精华\n吸人眼球：标题要尽量生动形象，有趣味性\n\n\n推断下文：关注尾句是关键，注意排除选项中的三种信息\n关注尾句：尾句经常起到既总结上文，又提示下文的作用，可以分为以下三类\n尾句提出一个概念，这个概念前文没有提及，后文可能围绕这个概念展开（多个选项包含此概念时，大概率选“是什么”的选项）\n尾句指出一种现象，这个现象或事实可能比较特殊、新奇，也可能与前文讲述的内容形成对比（多个选项与现象有关时，优先考虑“介绍具体表现”的选项）\n尾句得出一个结论，这个结论可能是作者对某事的评价、看法，也可能是作者的一个倡导，呼吁大家做什么（未阐述理由时，后文可能阐述；已对结论进行分析，后文可能围绕“怎么做”）\n\n\n排除三种信息：根据行文逻辑，排除不太可能出现在后文的信息，缩小备选范围，有以下三种可排出的信息\n本文信息：指已在文段中体现的信息，如果出现在后文，可能会显得累赘\n前文信息：从逻辑顺序上应出现在文段的前文而非后文的信息\n无关信息：指与本文主旨相去甚远与文段基本没有关心的信息\n\n\n\n\n词语理解：主要考查考生是否正确理解阅读材料中指定的词语、语句的含义能力的一种题型，一般从词语和句子的本义入手，同时结合上下文语境甚至文段主旨综合考虑\n遵循就近原则：大多数词语理解题都可以通过对指定词语前后内容的分析得出答案\n分析文段层次：有些词语需要结合全文理解，这时需要分析文段层次，抓住主干（主谓宾）和逻辑关系\n\n\n\n3.语句表达\n\n\n\n\n\n\n\n\n给出几个句子进行排序，或者给出不完整的文段，选出合适的句子填入\n1.语句排序\n判断首尾句：首尾句特征鲜明，可从选项给出的首尾句入手，排除干扰项\n抓标志词：语句中的标志词，如关联词、指代词、顺序词、重复词等可提示语句的逻辑顺序\n抓行文脉络：行文脉络是寻找上下文行文逻辑的依据\n\n2.语句填充\n话题统一：指组成段落或复句的句子之间，彼此紧密联系，都围绕一个话题集中地表现一个事实、场景或观点，包含以下两种形式\n保持主语一致：指的是填入句子的主语应与文段各句的主语保持一致\n保持话题一致：指的是句群之间涉及的领域、对象、观点一致\n\n\n前后照应：指语段中的信息要前后吻合，彼此呼应，在表意上形成一个严密的整体。根据空缺位置的不同，所填句子在文段中所起的作用也不同，有以下三种分类：\n空缺处位于段首：引出话题，总领全文\n空缺处位于段中：承上启下\n空缺处位于段尾：总结上文\n\n\n\n判断推理(40/26’’)1.逻辑判断1.直言命题重基础\n直言命题也称性质命题，是判定对象是否具有某种性质的单句，有以下六种（“有些”等与“有”，表示至少有一个）\n\n\n\n种类\n示例\n\n\n\n所有A是B\n所有小学生是少先队员\n\n\n所有A不是B\n所有小学生不是少先队员\n\n\n有些A是B\n有些小学生是少先队员\n\n\n有些A不是B\n有些小学生不是少先队员\n\n\n某个A是B\n小学生小丁是少先队员\n\n\n某个A不是B\n小学生小丁不是少先队员\n\n\n\n直言命题的对当关系，即直言命题之间的真假制约关系，包括矛盾关系、推出关系、上反对关系和下反对关系\n\n矛盾关系：两个命题永远满足一真一假的关系，一个直言命题前面加“并非”，等值于这个命题的矛盾命题，示例如下：\n“所有A是B”的矛盾命题 = 并非“所有A是B” = 有些A不是B\n“有些A是B”的矛盾命题 = 并非“所有A是B” = 所有A不是B\n“某个A是B”的矛盾命题 = 并非“某个A是B” = 某个A不是B\n\n\n下反对关系：指两个命题必有一真，可以同真，不能同假，最常见的是“有些A是B”和“有些A不是B”\n上反对关系：指两个命题必有一假，可以同假，不能同真，最常见的是“所有A是B”和“所有A不是B”\n推出关系：既可同真，又可同假，示例：\n所有A是B -&gt; 有些A是B\n所有A不是B -&gt; 有些A不是B\n\n\n\n\n\n\n\n2.复言命题重推理\n复言命题是由两个或多个单句作为肢命题，通过联结词联结而成的命题，主要有以下几种：\n\n\n\n命题\n示例\n\n\n\n联言命题\n小桦喜欢打篮球且喜欢踢足球\n\n\n相容选言命题\n小桦喜欢打篮球或踢足球\n\n\n不相容选言命题\n小桦要么喜欢打篮球，要么喜欢踢足球\n\n\n假言命题\n如果小桦喜欢打篮球，那么他也喜欢踢足球\n\n\n\n联言命题\n\n表示多个肢命题同时存在（为真）的复言命题，可表示为“p且q”，如：网购便宜且方便\n联言命题的矛盾命题：当至少一个联言肢为假时，联言命题为假。即“p且q”的矛盾命题是“非p或非q”\n\n\n相容选言命题：至少有一种情况存在的命题\n\n至少有一种情况存在，可以多种情况同时存在，可表示为“p或q”，如：他懂英语或懂汉语\n相容选言命题的矛盾命题：当两个选言肢都为假时，相容选言命题为假。即“p或q”的矛盾命题是“非p且非q”\n\n\n不相容选言命题\n\n表示有且只有一种情况出现，可以表示为“要么p，要么q”，如：要么顽强抵抗，要么屈膝投降\n不相容选言命题的矛盾命题：当两个肢语言同时为真，或同时为假时，不相容选言命题为假。即“要么p。要么q”的矛盾命题是“要么p且q，要么非p且非q”\n\n\n假言命题\n\n假言命题是带有假设条件的命题，可以表示为“p=&gt;q”，\n\n假言命题可断定事物之间的条件关系，主要有以下两种\n\n充分条件关系：有p一定有q，无p未必无q，表示为“p=&gt;q”。有以下几类：\n\n\n\n类别\n示例\n\n\n\n如果p，那么q\n如果天下雨，那么地会湿\n\n\n若p，则q\n若天下雨，则地会湿\n\n\n只要p，就q\n只要天下雨，地就会湿\n\n\n一旦p，就q\n一旦天下雨，地就会湿\n\n\n\n必要条件关系：无p一定无q，有p未必有q，表示为“p&lt;=q”，或非p=&gt;非q。有以下几类：\n\n\n\n类别\n示例\n\n\n\n只有p，才q\n只有本国公民，才能考本国公务员\n\n\n除非p，否则不q\n除非本国公民，否则不能考本国公务员\n\n\n除非p，才q\n除非本国公民，才能考本国公务员\n\n\n\n\n\n推理规则：肯前可以肯后，否前不能否后，肯后不能肯前，肯后可以否前。“p=&gt;q”可以推出“非p&lt;=非q”\n\n矛盾命题：“p=&gt;q”的矛盾命题是“p且非q”\n\n\n\n\n3.朴素逻辑重方法\n代入排除法：直接将选项代入题干条件中，结合题干条件进行推理，排除不符合题干条件的选项\n假设法：假设某个条件的真假情况，进一步推到的方法，当推到的结论与其他条件冲突时，假设不成立\n图表法：通过表格或图形将元素之间的关系表示出来，包括列表法和画图法\n列表法：题干元素为两类的对应关系时，将题干两类元素分别列为标题行和标题列，将题干信息填入表格中，再根据已知条件进行推理\n画图法：元素涉及位置关系时，在直线、环线或者坐标轴上标出题干信息中存在的相对位置\n\n\n找突破口：快速找到解题的切入点，常见突破口如下\n确定性条件：题干某个条件包含的对应情况相对明确，则其具有确定性，包含的对应情况越少，其确定性越强\n关联性条件：题干条件往往包含相同的元素，是通过相同的元素关联在一起的，通过具有关联性的条件，往往可以做进一步推导\n\n\n综合应用：使用上述多种方法，\n\n4.论证分析\n有些题干以论证形式出现，学习论证相关知识有助于准确分析题干。论证在结构上通常有论点、论据和论证方式（用论据论证论点的过程）三部分构成\n论据提示词：因为、由于、假如、理由是、调查、统计、实验、研究\n论点提示词：因此、据此、说明、认为、推测、建议\n\n\n\n5.削弱型、加强型\n基本概念\n削弱型题目的题干中给出一个完整的论证或表述某种观点，要求从备选项中寻找能/最能反驳或削弱题干的选项，或排除能反驳或削弱题干的选项，题干通常包含削弱、质疑、反驳等字样\n加强型题目的题干中给出一个完整的论证或表述某种观点，要求从备选项中寻找能/最能支持或加强题干的选项，或排除能支持或加强题干的选项，题干通常包含加强、支持等字样\n\n\n常见的论证模型\n求异论证\n论证过程：根据某一事件的发生（不发生）与另一事件的发生（不发生）相关，推出两个事件之间存在一定的因果联系\n削弱方式：切断因果、因果倒置、另有他因\n增强方式：解释因果、无因无果、排除他因\n\n\n原因分析\n原因分析是一种比较简单的论证模型，其特点是题干直接给出一个现象，结论推测该现象发生的原因\n削弱方式：因不致果、另有他因\n增强方式：建立因果关系、排除他因\n\n\n提出方法\n提出方法类题目的题干是为了达到某种目的或解决某一问题而提出一个方法\n削弱方式：达不到目的、方法不可行\n增强方式：能达到目的、方法可行\n\n\n枚举归纳\n依据某种属性在部分同类对象中不断重复，没有遇到反例，而推出该类所有对象都具有某种属性的推理，其结论是可能的\n削弱方式：样本特殊、存在反例\n增强方式：样本有代表性\n\n\n类比论证\n将已知事物与跟它有某些相同特点的事物进行比较，根据两个（或两类）对象有某些属性上相同或相似，推出它们在另一些属性上也相同或相似的推理，是一种由特殊到特殊的推理方法，其特点是“同中求同”\n削弱方式：本质不同\n增强方式：本质相同\n\n\n\n\n其他题型\n前提型    \n题干中论据与论点之间一般会存在明显的跳跃，由题干论据不足以推出论点，需要增加一个隐含假设才能使论证成立。解题关键是寻找其中的隐含假设\n解题思路\n搭桥法：通过搭桥将论据和论点的讨论对象联系起来，即可得到所需的隐含假设\n反向代入法：当题干直接要求寻找前提时，可能会有多个选项满足题干，此时可使用反向代入法，通过将选项的反面代入题干，即假设该选项不成立时，看题干论证是否成立，如果题干论证不成立了，则该选项就是题干的隐含假设\n\n\n\n\n结论型\n结论型题目的题干给出一段论述或推理，要求选出能够根据题干所给信息进行归纳或推出的选项，类似于言语理解与表达中的片段阅读题\n正确选项\n与题干信息相符，一定能够由题干推出\n语气较弱，如含有可能、有些的选项\n\n\n错误选项\n无中生有，即与题干无关或超出题干范围\n过度推断，即由题干信息无法客观推出或者说法过于绝对化\n偷换概念，即选项中的概念与题干概念不一致，看似有关，其实无关\n违背规则，如充分条件假言命题通过否定前件得到否定的后件\n与题干信息相矛盾\n\n\n\n\n解释型\n解释型的题干一般给出某一个事实或论证的描述，要求从选项中找出最能够合理地解释题干所述的一项，题干中的描述大多是一个结论、现象、矛盾或差异\n解释型题目的正确选型有以下特点：能够解释题干现象或矛盾；与题干现象或矛盾相关；能够包容题干所诉的矛盾双方，且与人们的常识相符。多个选项均能解释题干时，选最直接、解释力度最强的一项\n\n\n评价型\n评价型题目要求考生对题干论证的结构、方式、有效性等做出评价\n解题思路：\n题干为一段论述材料：分析题干和选项的论证（或推理）方式\n题干为直言或复言命题的推理：直接分析题干和选项的句子结构\n\n\n\n\n\n\n\n2.图形推理、类比推理\n\n\n\n\n\n\n\n\n顺推型、类比型、九宫格型\n1.题型概要\n顺推型：包含一组图形和一个空缺项，找规律选图形\n归纳题干图形的共同特征，然后在选项中选择唯一符合这一特征的图形\n寻找题干图形连续变化的规律，确定空缺图形的特征，然后在选项中寻找对应图形\n将奇数项的图形看作一组，偶数项的图形看作另一组，分别寻找规律\n\n\n类比型：题干图形分为两组，根据第一组规律填充题二组缺失图\n先分析第一组图形，寻找其中规律，再将这种规律运用于第二组图形\n将两组图形中相同位置的图形对应来看，寻找它们的共同特征，进而发现规律\n\n\n九宫格型：给出3*3方格中的八个图形，找规律选图形\n从每行考虑，寻找每行三个图形之间的规律\n从每列考虑，寻找每列三个图形之间的规律\n考虑九个图形的共同特征或连续变化规律\n将九个图形看作一个整体，考虑对称性规律\n\n\n分类分组型：给出六个图形，根据特征分成两组\n以两个图形之间的共同特征作为突破口，猜想并验证分类标准\n分析某个与众不同的图形的特征，然后寻找具备这种特征的其他图形\n从选项出发，观察选项中分在同一类的三个图形是否具有共同特征\n\n\n条件型：给出条件和图形，根据题干条件进行推理\n空间折叠，即根据题干给出的一个平面展开图，选择其折叠后的立体图形，或者根据题干给出的一个立体图形，选择其展开后的平面图形\n立体拼接与切割，即将题干给出的多个立体图形组合成一个完整的立体图形，或者将题干给出的立体图形切割成多个部分\n立体截面，即题干给定一个立体图形吗，将其从任一面剖开，判断其剖开后的截面形状\n三视图，即题干给定一个立体图形，从不同角度观看，判断该立体图形的视图\n\n\n\n2.图形推理（平面、空间）\n位置性\n\n题干图形相似程度较高：考虑图形的移动、旋转与翻转，主要关注移动方向（顺时针、逆时针、上下、左右）和距离\n题干图形都由几个小图形组成：考虑每个图形内部小图形的相对位置\n结构位置：上下结构、左右结构、内外结构\n排列位置：相对、相邻、相接、相交、相离\n平行、垂直：平面中的平行与垂直、立体中的平行与垂直\n相离、相交、相切：圆与圆相离/相交/相切，直线与圆相离/相交/相切\n小图形在特殊位置：例如黑色方块在多边形的顶点处，或在边上等\n\n\n图形整体上具有一致性，但是元素排列随意：考虑图形的遍历，即都经历一遍，都出现一次，主要出现在九宫格型和类比型中\n\n\n叠加性\n\n直接叠加：将两个已知的图形叠放在一起，形成一个新图形，新图形保留已知两个图形的所有线条或小图形\n去同存异、去异存同：将两个图形叠加后去掉相同（不同）的部分，保留不同（相同）的部分，得到第三个图形\n自定义叠加：根据一组图形的变化，确定叠加规则，然后将其运用到所求的一组图形中，主要出现在阴影类的图形推理中\n\n\n对称性\n\n轴对称：主要考察是否是轴对称图形，对称轴的数量、对称轴的方向\n中心对称：主要有两个图形关于某个点呈中心对称、某个图形自身是中心对称图形\n轴对称与中心对称：常见在分类分组型、类比型、九宫格型题目中，有以下两种核心考点\n一组为轴对称图形，另一组为中心对称图形\n一组为轴对称图形（或中心对称图形），另一组既是轴对称图形又是中心对称图形\n\n\n\n\n数量性：指图形中所蕴含的数量特征\n\n封闭区域数：图形的封闭区域数构成规律、图形的封闭区域形状相似、图形的封闭性与开放性（较少考察）\n部分数：图形由一部分或多部分构成，图形中含有相同的部分，图形的部分数据构成规律\n种类数：两组图形含有相同的小图形，两组图形的种类数相同，图形中的种类数构成规律\n线条数：图形中的直线数、曲线数以及线条总数\n笔画数：图形的笔画数（由图形的奇点个数决定）\n奇点为0：从其中任何一点开始，都可一笔将这个图形画出\n奇点为2：从其中任何一个奇点开始，以另一个奇点结束，可一笔将这个图形画出\n其它：可有多笔画出，笔画数=奇点数/2\n\n\n交点数\n十字交叉点：两条线在交叉的位置向四个方向延伸\n直线与曲线的交点：图形中直线部分与曲线部分相交的位置就是两者的交点\n接触点：将一个图形分成两部分，这两个部分相互接触所形成的点叫做接触点（圆内切正方形的切点）\n\n\n角：角的数量（直角的数量、锐角的数量）\n其他元素：即图形中某些特定小图形的数量（三角形、正方形、圆的数量）、小图形的数量换算\n\n\n同一性\n\n封闭区域连接方式\n以点相接：封闭区域互相不包含，两个封闭区域间存在一个交点\n以线相接：封闭区域间存在重合的线条，线条可以完全重合，也可以部分重合\n以线连接：两个封闭区域间不接触，通过一段线条连接\n\n\n图形的填充与重合\n图形的填充：图形中都含有某一种或几种填充方式，图形中含有同种填充方式的封闭区域的数量存在规律\n图形的重合；两个图形之间有交叉，形成一部分重合的区域，题目往往对这一重合区域的形状进行考查，其形状多为三角形、四边形，也可能与圆图形相似\n其他：\n\n\n\n\n空间图形推理\n\n空间折叠    \n\n区分相对面与相邻面\n小图形特征判定法：通过一些面的小图形形状、指向不同，或线条的交点位置、相接边等不一样，来判断\n两面定位法：假定其中两个面（或一个面）的方位正确，判断第三个面的方位正确与否，从而确定答案\n\n\n立体拼接与切割：立体拼接是将几个立体小图形拼接组合成一个完整的立体图形；立体切割是将一个立体图形切割成两个或多个立体小图形\n\n立体截面\n\n\n三视图\n\n\n\n\n3.类比推理\n逻辑关系\n集合关系：全同关系（两个含义完全相同的词语）、包含关系（一个事物是另一个事物的一种或一部分）、交叉关系（两个事物间有重叠的部分，但不完全重合）、全异关系（两个事物完全不同）\n矛盾关系和反对关系的区别：矛盾关系为A和B同属于C，且C只包含A、B两类；反对关系为A和B同属于C，但除了A、B，C还包括D、E等\n种属关系和组成关系：种属关系是指种概念与属概念之间的关系，可表示为A是B的一种；组成关系是指部分与整体之间的关系，可表示为A是B的一部分\n\n\n条件关系：主要包含充分条件关系（水涨与船高）和必要条件关系（水与生存）\n因果关系：即A导致B，但是注意有些事件之间的逻辑联系是必然的，而有些则只是可能的\n\n\n言语关系\n语义关系：近义关系、反义关系、象征关系（鸽子与和平、蓝色与忧郁）\n绝对反义词与相对反义词的区别：绝对反义词指两个词之间是非此即彼的关系，不存在中间项；相对反义词指两个词没有矛盾对立关系，还存在其他中间项\n词语之间的细微差别：语义程度的轻重、词语的适用对象、词语的感情色彩、词语的词性\n\n\n语法关系：主谓结构（名词+动词/形容词）、动宾结构（动词+名词）、并列结构（词性相同的词语）、偏正结构（一个词语修饰另一个词语）\n\n\n常识关系\n经验常识：由日常生活中的经验发展而来，与日常生活中的人或事物有关，主要涉及职业、特征、功能、原材料、位置、活动场所、目的、事件的先后顺序，有以下几方面易错点\n制成品与原材料的关系：纸张的原材料可以是木材，但通过纸张无法看出原材料\n主体或客体是否变动：考虑事件发出的主体以及承受的客体是否产生变化，并对主动、被动的关系进行区分\n必然属性和或然属性：必然属性指事物的固有属性（火焰与热），或然属性指事物可能具有的属性（饮料与冷）\n\n\n理论常识：涉及语文、数学、物理、化学、地理等方面的知识，依靠积累来解决\n\n\n\n3.定义判断1.定义特征分析\n\n2.定义特征归纳\n通过描述具体的实例或过程等给出定义，需要对其特征进行归纳总结，提取出对解题有帮助的信息。\n\n资料分析(20/20”)1.统计概念1.基期与现期\n基期：比较时作为参考标准的时期叫做基期，描述基期的具体数值叫做基期值\n现期：与基期相比较的时期叫做现期，描述现期的具体数值叫做现期值\n根据参照周期的不同，分为同比和环比\n同比：以最大的时间概念为标准向过去循环一个周期进行比较，一般指与上年同一时期相比的情况\n环比：以最小的时间概念为标准向过去循环一个周期进行比较，一般指与上一个相邻的统计周期相比的情况\n\n\n\n2.百分数、百分点、利润率\n百分数：表示一个数是另一个数的百分之几，增长率、比重等比例关系多用百分数表示，表示形式为x%\n百分点：以百分数的形式表示的相对指标（如增长率，比重等）的变动幅度，表示形式为x个百分点\n利润率：剩余价值与全部预付资本的比率，反映企业一定时期利润水平的相对指标，核心公式为：利润率 = 利润总额 / 总收入*100%\n\n3.顺差与逆差\n进出口总额：实际进出我国国境的货物总金额，包括进口额和出口额两部分\n\n进口额：一定时期内从国外进口的商品的总值，也称为进口贸易总额或进口总额\n出口额：一定时期内从国内进口的商品的总值，也称为出口贸易总额或出口总额\n\n\n顺差：进口额小于出口额时，进出口贸易表现为顺差，二者之差也称为净出口额\n\n逆差：当进口额大于出口额时，进出口贸易表现为逆差\n\n\n\n2.考察体系1.增长\n增长量：现期值较基期值变化的数值\n\n增长率：现期值较基期值变化的幅度，等同于增幅、增速、增长速度\n\n\n\n\n2.比重\n现期比重\n\n\n基期比重\n\n\n比重增长量\n\n\n\n3.倍数与翻倍\n现期倍数及翻倍\n\n增长/多几倍 = 是几倍 - 1；若求同一指标不同时期相比多几倍，即求增长率\n\n\n\n基期倍数\n\n\n增长量倍数\n\n\n\n4.平均数\n现期平均数：总量与份数的比值，例如某指标总量为A，分数为B，平均数m = A / B\n\n基期平均数\n\n\n平均增长率\n\n\n\n5.其他\n部分增长率与整体增长率关系：主要利用加权平均的思想，通常不需要直接求解，结合选项利用部分增长率与整体增长率之间的关系即可判断答案。整体增长率介于多个部分增长率之间，且偏向于权重（基期部分）较大的一方\n\n\n隔年增长\n\n\n年均增长\n\n\n贡献率与拉动……增长\n\n贡献率：反映经济增长中各因素所起作用的大小程度，包括两类考察方式\n一般情况下，表示部分增长量占整体增长量的比重\n特殊情况下，也可表示部分值占整体增长的程度指标，与增长无关（表格中的贡献率不包含此情况）\n\n\n拉动……增长：某部分的增长量拉动整体增长的程度指标，指整体中某部分的增长量与整体基期值的比值，表述为部分拉动整体增长了x个百分点\n\n\n\n\n\n3.实战技巧1.快速计算方法\n基础解题思维\n\n加减速算：根据选项通过计算首位/前几位数字，来快速确定答案。计算时要注意加减号、位数对应、进位借位等问题\n\n除法速算：列式中数据取前两位有效数字计算时，基本就可以确定正确答案，若不能，则通过增加数字来增加精度\n\n乘法速算：\n\n\n\n\n特征数字法：利用一些常用的数字特性，将百分数（小数）、整数和分数三者进行相互转化\n\n\n尾数法：取每个数据的末尾数字进行计算，通过确定尾数来判断正确答案\n\n除乘转化法：将某种列式中的除法转化为乘法，具体内容如下\n\n\n反算法：将除法转化为乘法，检验大于小于关系是否成立，若正面数多则可计算反面数\n\n\n2.大小比较技巧\n同位比较\n\n\n\n差分比较\n\n\n百分数比较\n\n\n\n数量关系(15/12”)1.数字运算解题方法1.方程法\n设未知数\n利用比例、倍数关系设未知数：当两个未知量之间存在比例、倍数等关系时，通常可设其中一个量为未知数，根据上述关系表示出另一个量\n取中间量设未知数：当题干含有多个未知量时，这些未知量之间往往具有等量关系，或与某一中间量存在等量关系，此时可设中间量为未知数，由此表示出其他的未知量，减少未知数的个数\n\n\n根据等量关系列方程\n当使用方程法解题时，关键是要从题干条件中找到在数量上相等的一种关系，即等量关系，通过这种等量关系，我们可以列出方程，进而求解未知数\n\n\n解方程\n一元一次方程：去分母、去括号、移项、合并同类项、系数化为1\n\n多元一次方程组：多元一次方程组一般通过代入消元法或加减消元法求解\n\n在不需要求出方程组中所有未知数的解时，可以使用换元法，即把某一部分（如3x+2y）视为一个整体进行运算\n\n不定方程：不定方程即方程中未知数的个数等于等式个数，通常无法使用常规方程求解，需要运用整除特性、奇偶性、尾数、特值等结合选项判断正确答案\n\n奇数个奇数的和是奇数，偶数个奇数的和是偶数\n几个数的乘积如果是奇数，那么这几个数一定都是奇数；几个数的乘积如果是偶数，那么这几个数中至少有一个偶数\n两个数的和与这两个数的差奇偶性相同\n\n\n当遇到“在不同分配情况中，有剩余，或有不足”的问题时，既可以列方程求解，也可直接套用盈亏问题的公式：\n\n\n\n问题类型\n解决方法\n\n\n\n一盈一尽型\n盈数 / 两次分配个数的差 = 对象数\n\n\n一亏一尽型\n亏数 / 两次分配个数的差 = 对象数\n\n\n一盈一亏型\n（盈数 + 亏数） / 两次分配个数的差 = 对象数\n\n\n两次皆盈型\n（大盈数 - 小盈数） / 两次分配个数的差 = 对象数\n\n\n两次皆亏型\n（大亏数 - 小亏数） / 两次分配个数的差 = 对象数\n\n\n\n\n\n\n2.整除法\n针对数学运算题目中涉及的量一定是整数的一类题目，这些量多以个数的形式呈现，有些题可以利用整除特性快速排除错误选项，有些题中整除法是解题的重要突破口\n\n整除的判定\n\n\n\n\n\n3.特值法\n当题目中的某个未知量无论取值多少都不影响所求时，设此未知量为特殊值来简化计算\n方法\n设特殊值为1：在涉及乘法的计算中，为了避免出现过大的数字，可将某些未知量设为1\n设特殊值为100：当题干给出百分数时，把百分数分母代表的量设为100，往往能够消去百分数直接做整除运算\n设特殊数为公倍数：在题干含有多个比例关系的情况下，可设未知的总量为已知分量的公倍数，将数值整数化，方面计算\n设特殊值为最简比：当题目中出现比例关系时，可将比例的份数设为特殊值，从而简化计算\n\n\n\n4.比例法\n比例法是利用比例的相关性质实现减少计算量的一种方法，在题目中，除直接给出比例外，题干中的分数、百分数，一般也可表达两个量之间的比例关系\n比例法的核心是不设未知数而设份数，利用份数代替实际量进行计算，再找到份数和实际量之间的对应关系\n\n5.十字交叉法\n十字交叉法的本质是方程法的简便形式，通过交叉的线断，将方程转换为图形，直观呈现各部分之间的关系，用以解决事物之间的混合比例问题\n\n在使用十字交叉法时，（c-b）/（a-c）表示的是a、b分母对应量的比值，如在浓度问题中，a、b为浓度，浓度 = 溶质/溶液，那么（c-b）/（a-c）就是两种溶液的量之比；在行程问题中，a、b为速度，速度 = 路程/时间，那么（c-b）/（a-c）就是以两个速度行驶的时间比\n\n\n\n\n2.数学运算常考题型1.等差数列\n基本公式\n\n\n求和公式\n\n\n\n2.和差倍比\n通过关键词找等量关系：当题目中出现了如“等于、相等、是、比、多、少”等关键词时，我们可以抓住有关键词的这句话来建立等量关系\n通过基本公式找等量关系：依据基本公式建立等量关系也是考试重点，在考试中经常会利用“总量=平均量*数量”这一公式建立等量关系\n\n3.工程问题\n主要考查工作总量、工作效率、工作时间这三个量之间的关系，核心公式为：工作总量 = 工作效率 *  工作时间（工作效率是指单位时间内完成的工作量）\n交替完工\n根据已知条件将工作量或者工作效率表示为特值\n找出合作周期并计算每个周期完成的工作量\n计算该项工作需要的完整周期数以及剩余工作量\n根据循环顺序，确定剩余工作量的完成方式及完成时间\n\n\n\n4.行程问题\n行程问题从基本题型到复杂题型，种类很多，核心公式为：路程(s)=速度(v) * 时间(t)\n\n具体技巧\n\n做匀变速运动的物体，某段时间内的平均速度还可以用（初速度 + 末速度）/ 2来计算\n\n多次相遇：当甲、乙从A、B两地相向而行时，第一次相遇，两人所走路程和为AB全程s；第二次相遇时，两人所走的路程和为3倍的s\n\n由此可总结多次相遇问题中的路程和公式：Sn = (2n-1)s，相应的，第n次相遇时所用时间满足Tn=(2n-1)t，在第n次相遇时，每个人所走的路程也同样等于其第一次相遇时所走路程的（2n-1）倍\n\n\n环线相遇及追及\n\n\n\n\n\n5.利润问题\n6.排列组合问题\n基本公式\n\n计数原理\n\n\n排列和组合\n\n\n\n\n技巧\n\n优限法：先排除特殊元素或者特殊位置，再排其它元素或位置\n捆绑法：先将必须相邻的元素作为一个整体，与其他元素全排列，然后考虑捆绑元素之间的相对顺序\n插空法：先排其它元素，再将不相邻的元素插入这些元素所形成的空中\n\n\n\n7.概率问题\n古典概率：研究有限个等可能事件发生的概率\n\n\n独立事件概率：事件A是否发生对事件B发生的概率没有影响，这样的两个事件叫做相互独立事件，两个或多个独立事件同时发生的概率等于两个或多个独立事件分别发生的概率之积\n\n独立重复试验概率：\n\n\n\n8.几何问题\n相似图形中，所有边对应成比例，线段比为相似比，面积比为相似比的平方，体积比为相似比的立方\n9.和定最值问题\n和定最值主要解决已知若干个整数的和以及其他相关条件，要求其中某个数的最大值或最小值的问题，解题原则如下：\n要求某个数的最小值，应使其他数尽可能大\n要求某个数的最大值，应使其他数尽可能小\n\n\n技巧\n和定最值问题，方程解出的数不是整数：\n问最大，应向下取整\n问最小，应向上取整\n\n\n\n\n\n10.函数图像\n11.容斥问题\n常识判断(20/10’’)申论作答流程1.审题1.作答任务\n作答对象：找题目中的名词\n题目类型：归纳概括题、综合分析题、提出对策题、贯彻执行题、申发论述题\n\n2.限定条件\n作答范围：题目规定了作答时提去要点的材料范围\n作答身份：以某种身份的立场和角度来作答\n内容要求：根据题型的不同进行针对性的作答\n格式要求：在贯彻执行题中，题目会对标题、称谓、落款等格式作出要求；或其他一些要求，如只写标题和正文\n作答字数：不超过xx字、不少于xx字、xx字左右，字数的计算从第一个空格开始直到最后一个标点符号结束\n\n2.找点1.直接概括\n定位关键词\n\n问题词：主要指负面的社会现象、不良的时间状态等，问题词常用来提示问题或描述问题本身，示例：公众对快递人员的辛苦和安全风险缺乏了解，对他们不够尊重、理解与认可，有些地方，甚至存在客户辱骂、敲诈快递从业人员的问题。\n\n原因词：原因是指造成某种结果或者引发某起事件的条件，在材料中，导致客观事实产生的因素，就是所要寻找的原因要点，原因词主要有原因、因为、由于、本质上、实际上、事实上……\n\n影响词：影响是指以某种方式对人或事物产生的作用等，一般情况下包括积极影响和消极影响，常见影响词有：有利于、有助于、促进、推动、不利于、引发、导致、造成……\n\n对策词：对策是指解决某种问题的建议、意见、思路、方法、措施等，解决问题是申论的最终落脚点，对策由此成为申论的常考要素之一，常考对策词有对策、建议、提议、需要、必须、应该、要求、可以、提出、措施、着手、出台法规、加强宣传……\n\n关联词：\n\n\n\n\n\n关键句\n\n段首句：总领该段核心思想和内容的句子，一般以陈述句为主\n段尾句：总结该段落的核心思想和内容\n中心句：位于段落中间，表达该段落核心思想和内容的句子\n数据材料（事例）+中心句+数据材料（事例）\n是否存在表重点强调的词，如转折词，重点词（本质、核心、关键）等\n作用是否承上启下\n\n\n\n\n缩写要点信息\n\n保留主干、略去修饰：首先提取主谓宾，然后在逐一删去前后的修饰性语言，具体方法有\n去掉“地”字前面的形容词，如“顺利地开展工作”。\n﻿去掉“的”字前面的形容词，如“汇聚海量的用户群”。\n﻿去掉“得”字后面的补充说明词语，如“同学们开心得手舞足蹈”。\n﻿去掉时间、地点等状语，如“这几天，张主任走访了企业”。\n﻿去掉数量词语，保留中心词语，如“选派各类人才3109名到对口帮扶地区服务锻炼”。\n\n\n原词呈现、调整词序：考试阅卷遵循采点给分的原则，这个“点”的判断标准就是是否有材料中关键句子的原词。缩写句子时需要在不改变原意的前提下，适当调整词序，构成简短的单句要点\n\n\n\n2.综合概括\n本质归纳：透过现象看本质，从个别事物中概括出一般性的概念、做法或结论，如种苹果的老张-果农-农民、养山羊-养殖业-农业、红绿灯-交通基础设施……\n\n行政执法类\n\n\n个人品质类\n\n\n产业发展类\n\n\n基础设施类\n\n\n生活水平类\n\n\n\n\n反向推导：申论题目有时要求提出对策，但材料中既没有可以直接缩写的关键词，也没有可供归纳的现成信息，这时往往需要由问题或原因来反向推导出对策要点\n\n\n\n3.加工1.合并加工\n同义合并：将含义相同或相近的要点进行合并，是合并要点时最基础的方法，也是最常用的方法。如“实现职能整合”和“资源得到有效整合”可以合并为“实现职能，资源整合”\n同范围合并：指将所属范围相同的要点进行合并，常见的范围划分有：“经济、政治、文化、社会、生态”“思想、制度、监督”〝硬件、软件”“主观、客观”“内因、外因”等。当题目中出现“有条理”“层次分明”等要求时，在完成同义合并后，通常还需要二次归纳，将要点按照所属范围进行分类整理，以形成最终答案\n同主体合并：同主体合并，指将主体相同的要点进行合并。常见的主体有政府、企业、社会、个人等。同主体合并法与同范围合并法类似，都是在完成同义合并后，对要点进行二次归纳;区别在于归纳原则不同，同主体合并法需按照要点的呈现主体进行分类整理\n\n2.逻辑加工\n整体答案的逻辑加工：当题目的限定条件中出现“逻辑清晰”“层次分明”等表述，或是要点之间存在某种联系时，为符合题目要求，还需对答案整体进行逻辑加工，常见的逻辑结构有“总-分-总”和“总-分”两种\n\n归纳概括题、提出对策题按照“总-分”逻辑加工\n综合分析题、申发论述题按照“总-分-总”逻辑加工，表述形式一般为“提出观点-多角度分析-作出结论或提出对策”和“开头-主体-结尾”\n贯彻执行题，根据不同的文种，按照“总-分-总”或“总-分”的逻辑加工\n\n\n部分答案的逻辑加工：除了对答案整体进行逻辑加工外，具体内容部分可能还需要按照并列、递进、转折进行加工。在罗列每一条答案的过程中，为了凸显层次分明，可以提取每条复杂答案要点的核心内容作为主旨句（即核心关键词）进行前置，示例如下：\n\n\n\n3.格式加工\n标题：标题一般由发文机关、事由和文种（不可胜）三部分组成\n\n标题一：国务院办公厅关于 2022 年部分节假日安排的通知(发文机关＋事由＋文种）\n标题二：关于做好 2022 年元且春节期间有关工作的通知(事由＋文种）\n标题三：北京市人民政府令(发文机关＋文种）\n标题四：倡议书（只写文种）\n\n\n称谓\n\n称谓即主送机关/受文对象，应该在写完标题后，另起一行居左顶格书写，称谓太长需要回行时仍顶格，并在最后一个机关名称或受文对象后加冒号\n\n\n落款\n\n正文结束后,应另起一行在右下方署明单位或个人名称，称为发文机关,并在发文机关下一行编排成文日期。需要注意的是,法定公文和非法定公文落款的编排格式有所不同\n\n法定公文,发文机关和成文日期的编排分为两种情况：①对于加盖印章的公文,成文日期一般右空四字编排，发文机关署名在成文日期之上,以成文日期为谁居中编排(如下图左)。②对于不加盖印章的公文，在正文(或附件说明)下空一行右空二字编排发文机关署名，在发文机关署名下一行编排成文日期，首字比发文机关署名首字右移二字;如成文日期长于发文机关署名，应当使成文日期右空二字编排,并相应增加发文机关署名右空字数(如下图右)\n\n\n非法定公文,如发文机关署名长于成文日期,需要右空二字编排发文机关署名,并在下一行以发文机关署名为准居中编排成文日期;如成文日期长于发文机关署名,应当使成文日期右空二字编排，以成文日期为准居中编排发文机关署名（如下图）\n\n\n\n\n\n4.语言加工​        语言加工主要是针对部分贯彻执行题以及申发论述题来说的。一般来说,申论语言做到严肃、规范即可。但在部分题型中,申论语言也会受到作答身份和受文对象的限制。如果是面向政府机关工作人员,语言要规范、严谨;如果是面向社会大众,除了规范之外，还需要贴近群众，或平实质朴、通俗易懂，或生动活泼、有感染力。\n5.字数加工\n缩减字数\n删繁就简：将加工后的要点删繁就简，能继续合并归类的就继续合并归类，不能合并时就尽可能地将不必要或是烦冗的表诉删掉，比如在确保要点谁确和全面的前提下，刷去重复和修饰性的词句。使答案更为精准、简洁。注意调整字数不能更改专业词汇\n近义替换：删减后仍不符合题目字数要求的，可考虑采用近义替换的方式，如“不强”替换为“弱”，“有待提高”替换为“低”等。在进行近义替换时，不能改变原文意思，更不得与原意相悖\n\n\n扩充字数\n丰富细节表述：在进行部分题日的作答时，考生会发现材料中所给答案要点总括性较强，不足以清晰表述要点或满足字数要求,此类情况常见于提出对策等题日。此时，可依据自身生活经验，对要点进行细节性扩充。如要点为“提供资金保麻”，可扩充内容为“向地方政府申销财政补购，同时引入社会资本”。\n丰富主题阐释：此方达主要应用于贯彻执行题和申发论述题。有些要求写作文书的试题字数较多，如2022年国考申论行政执法类试卷第五题要求写 800-1000 字的公开信。对于这种情况，可以通过引用名人名言、政策理论等，来对主题作出阐释。\n\n\n\n归纳概括（300字/15’’）1.题型介绍\n归纳概括明确要素\n题干给定的概括对象可能是问题、原因、做法、功能等，寻找相关要点时应全面、准确、不可有遗漏\n要求概括的对象往往包含多个要点，建议分表表述，如果字数允许，最好从没条要点中提取关键词，写出简短的总括句（即主旨句），再加以描述，增强作答的条理性\n\n\n归纳概括模糊要素\n这类题型可能涉及多个工作的排序，也可能涉及两个主体的对比，或者需要通读整段、整则材料，提取其中所有的问题、原因、对策或影响等才能得到答案\n题干给定的概括对象要么需体现材料的核心内容，要么是动态的、变化的过程，在寻找要点时应该全面考虑，不可有所偏废\n因概括要素的多样性及不确定性，作答时要全面把握材料内容，概括变化或过程时要注意时间提示词，如“过去”、“现在”、“xx年”等\n\n\n核心要求\n全面\n对象齐全：有的概括题会涉及多个对象，考生作答时不能遗漏任何一个对象\n要点齐全：一般情况下，一个对象在材料中会通过多个方面得到体现，考生作答时不能遗漏任何一个方面\n\n\n准确\n准确理解题意：审题时不要随意放大或缩小概括对象\n准确概括要点：即在提取要点信息时要尊重材料原意，不擅自更改材料中的已有表述，也不要对材料内容进行过度推导\n\n\n有条理/条理清晰：用序次语，按照“总-分”逻辑进行加工，即“总括句+具体内容”的形式\n\n\n\n2.技巧强化1.归纳概括明确要素\n做法\n\n做法，是指处理事情的方法。概括做法，即根据给定资料，我到题目所述对象处理某一事项的方法、措施等。此类题目有时会直接考查”概括××的举措”，有时则会灵活设问，如“在××方面做了哪些努力”“对××的探索进行梳理概括”等\n要想准确概括资料中的做法要素，重点关注语句中的动词，从而得到要点\n\n\n问题\n\n问题，是指需要研究讨论并加以解决的矛盾、疑难。概括问题类试题比较容易判断，题千通常有“问题”“困难”“难题”“短板”“问题的表现”等，简单直接地给出作答任务，我们围绕作答对象从材料中提取问题类要点即可\n\n通常以消极词语提示问题所在\n\n\n\n\n原因\n\n原因，是指造成某种结果或引起另一件事情发生的条件。概括原因，即根据题千要求，去材料中寻找引起题千所述事件的因素。这类试题题干通常会出现“原因”二字，但也有一些题目要求“分析为什么×x”“概括×X的理由”，“分析为什么”“概括理由”就是要求我们概括导致某一结果的原因\n\n包含原因的材料，常有以下几类提示词\n\n\n\n\n影响\n\n影响是指人或事物产生的积极或消极影响的作用，在作答时，首先应明确影响性质，确定是积极的还是消极的；其次，全面把握材料相关内容，对材料涉及的主体、领域等内容有通盘的了解和掌握\n\n常见提示影响的词如下表：\n\n\n\n\n特点\n\n特点，是指人或事物所具有的独特的地方，需要从材料中寻找某一事物或人物的独特之处，常见事物特点和人物特点如下\n\n\n\n\n\n2.归纳概括模糊要素\n概括变化：变化是指事物在形态上或本质上产生的新状况，变化是一种动态过程，需要通过过去和现在进行对比来体现，主要涉及主观变化和客观变化\n\n提示变化的词语\n\n\n主观变化\n\n\n客观变化\n\n\n\n\n概括流程：流程是指完成一个完整的业务行为的过程，由过程节点及执行方式有序组成，答案有时需按照发展的时间轴，梳理事物不同阶段、时期的发展状态\n\n事物发展阶段：起始-上升-鼎盛-衰微-消亡\n\n\n工作流程：指工作事项的活动流向顺序，工作流程包括实际工作中的工作环节、步骤和程序。工作流程中各项工作的逻辑关系，是一种动态关系，通常包括前期准备工作、中期实施工作、后期收尾工作\n\n\n\n\n\n3.真题精解综合分析（150-500字/10-20”）1.题型介绍\n题型分类\n解释分析：考查对资料中出现的特定词语或句子进行理解和阐释，得出概念的含义或者分析本质。要求解释的词语往往内涵丰富，可以结合材料，先确定给定词句的本质含义，然后进行多角度分析\n评论分析：针对材料中出现的社会现象、观点等进行评论，需要分析的现象或者观点均来自材料，作答此类题目需要回到材料，全面把握评论对象所涉及的权威表述、不同观点、原因、影响、结论等，再进行针对性的评论\n启示分析：需要准确理解材料中的案例，总结出具有普适性的工作方法和可行措施，要求分析的案例不止一个时，要根据题目要求考虑要合并还是分别罗列启示\n\n\n核心要求\n明确观点：在答案的开头就表明观点、或阐述对象的内涵本质、或明确判断观点的正误，观点正确是观点明确的前提\n条理清晰\n逻辑思维：分析问题时遵循一定的规律、规则，即有逻辑思维，在形成答案的过程中要仔细斟酌，保证在落笔之前就已完成对要点的加工整合。根据具体情况，答案可按照总-分、总-分-总、宏观-微观、总体-具体、提出观点-多角度分析-做出结论或提出对策，后者时间顺序等结构进行组织，以体现逻辑性\n语言组织：使用能区分层次的词语\n首先······，其次······，再次······，最后······；\n一是······，二是⋯⋯，三是······；\n一方面⋯⋯，另一方面······；\n主要······，次要······；\n直接······，间接······，根本······\n\n\n\n\n分析透彻：分析事理详尽而深入，也就是说要通过对问题和现象的合理分析，透过现象看到本质，主要把握以下三点\n找准、找全分析对象：需要理解的分析对象可能不止一个，一句话里也可能有前后不同的侧重点，找准、找全分析对象是确保分析合理的前提\n合乎事理、符合逻辑：指分析必须符合客观对象自身存在与发展的规律，符合由低到高、由简单到复杂、由显到隐、由外到内、由主要到次要等事物发展顺序、认识顺序和表达顺序，也要符合唯物辩证法的基本观点(联系的观点、发展的观点、一分为二的观点）、基本规律(对立统一规律、质量互变规律和否定之否定规律）以及关于五对基木范畴(现象和本质、内容和形式、原因和结果、可能性和现实性、偶然性和必然性）的原理。\n结合材料，不可主观臆断：综合分析题的作答在一定程度上可以适当引申，但严格依据给定资料依然是原则。也就是说，在分析过程中对观点的阐发、对事例的界定，不能仅凭自己的主观判断，而应严格依据给定资料进行判断。无论是观点还是具体分析，都要在给定资料中找到依据。\n\n\n\n\n\n2.技巧强化1.解释分析题\n提出观点（解释含义）：作答解释分析题，首先要解释词语或向子的本质含义。本质舍义指词语或向子所概括的思维对象特有的属性，既要从字面意思进行简单推导，也要结合材料准确把握。解释词语或句子本质含义前,可先对词语或句子进行整体理解，把握大致作答方向。对于句子来说,可以将句子拆分，分析句子结构，逐个推敲句子里关键词的含义,从而对答案中应该包含的内容进行评估，方便我们回到材料中去寻找相关要点。具体作答时，如果材料中有完整的、深刻的解释，则可以直接提取作为词语或句子的本质含义。如果材料中并没有这样的介绍，就要回到材料找到词语或句子的出处,结合其前后内容进行理解。另外，还要结合权威观点来理解，如政府人员、专家学者等的观点\n多角度分析：在解释完本质含义后，要回到题目给定词向所在的材料位置，仔细分析其与前后内容之问的联系，了解其背景信息以及出现在该处的目的和意义，从而对其作出更深一层的闸释。这里必领以具体材料内容为依托，从问题、原因、影响、必要性等多个角度去分析\n作出结论或提出决策：多角度分析完成后，要立足材料对给定词句要表达的内容、重要性、多个词语间的关系等进行总结，得出权威结论或提出相应对策。若给定词句本身仅是对概念的阐述，没有倾向性，材料主要介绍原因、必要性、途径等内容,那么这部分可以进行适当引申，如引申出意义,对给定词句的本质含义作简单的总结。如果相关材料中有较为明显的措施类要点，或以反映问题为主，那么这部分可以直接引用材料中正面的经验、启示、做法，或从问题、教训等反推合理的举措，作为指导解决实际问题的对策\n\n2.评论分析题\n提出观点（表明价值判断）：一般来说,答案首句一定要提出观点，即明确指出题目中所给出的观点或现象是正确的，还是错误的,或是需要辩证看待。另需注意，在对几种不同的观点或做法进行评论时，首先要对不同的观点或做法进行概括,然后表明态度\n多角度分析：运用材料中的有关信息,说明为什么会持这种态度。可以从观点或现象的原因、影响、意义等多个方面人手，充分论证自己的观点\n作出结论或提出决策：多角度分析完成后，可结合题目的具体要求，适当地总结启示或简要提出对策\n\n3.启示分析题\n借鉴经验：什么是经验？简单来说，就是通过实践掌握的能够解决问题的知识、方法和技能。 在给定资料中，经验往往可以从那些正面的事例中得到。对于给定资料沙及的经验，按照能否直接适用于本国、本地这一标淮，一般可以分为直接经验和间接经验。直按经验的借鉴通常可以直接引用给定资料中的原话，或是在语言上稍加整理；间接经验的借鉴稍微复杂一些，需要从事例中综合概括出；经验蕴含的实质内容，再转化为符合自身实际情况、可为我们所用的思想或举措\n总结教训：教训是在实践中证实的错误的方法、知识等，我们能从中总结出指导今后实践的正确知识 、方法和技能。总结教训的目的在于从中找到解决问题的正确方法,从而指导未来的实践,也就是说在总结教训的时候，并不是对问题进行简单描述，而应,总结出;应对问题的方法。因此,有些教训可以直接针对问题反推得出，而有些教训则需要对问题进行分析，然后再,总结出应对和解决问题的方法\n\n3.真题精解提出对策（新题型/市级）1.题型介绍\n题型分类\n单一型对策\n直接提出解决措施，此类题仅需体现对策，无须概括具体问题、分析原因，发现和界定问题只需在草稿纸上完成，不需要书写在答案中\n题干往往给出了具体方向，只要围绕材料分析，就能找到有效措施\n\n\n复合型对策\n一般要求回答两问，即需要考生先概括材料所反映的问题或分析问题产生的原因等，再就此提出解决措施\n作答任务有两个，第一项 任务问法多样，本质都是归纳概括；第二项任务都是提出对策建议，这种情况下，第一问也需要形成答案书写在答题纸上\n\n\n\n\n核心要求\n角色意识：明确提出对策的具体身份，不可错位，也不可越位\n题目未设定身份：站在政府的角度，从法律手段、行政手段、宣传手段等方面提出解决措施\n题目设定身份：部分提出对策题会在题目中要求考生以某种身份作答\n\n\n有针对性：有针对性，即考生所提的对策既要针对问题，又要做到针对材料。针对问题，是指对策能够切实解决问题；针对材料，是指对策应源于材料\n切实可行：对策要具备可以实施的条件，既要切合实际，又要措施具体\n切合实际，是指所提对策要行合当前社会生活实际情况，无论是在政治、经济，还是在伦理、技术等方面，都具备落地条件\n措施具体，是指对策不可存在“假大空”等问题，要讲明可付诸实践的操作步骤。例如，针对资金匮乏等问题，在提出加大资金投人的对策的基础上，还要具体展开阐述细节化的操作步骤，如通过招商引资、引进社会资本等方式，拓宽融资渠道，打造完善的融资平台等\n\n\n\n\n\n2.技巧强化1.单一型对策\n提取要点：\n\n直接对策：有的材料会直接谈到解决问题的对策、意见、思路、办法等。例如，在“某某领导建议”“某某专家认为”〝某某负责人表示”等语句后面往往会有一些对策表述。此外，当“应该”“务必”“可通过”“希望”“需要”等标志性词语出现时，后面也可能跟着相应的对策。对于这些对策，我们可通过直接概括的方法获取\n间接对策：材料有时会反映一些具体的问题，揭示问题产生的内在原因，介绍一些国内外的成功经验或失败教训，此时并不能直接从材料中得到对策要点，这就需要考生根据材料中的各类信息，推出对策要点\n根据问题、原因提出对策：提出对策题的材料中往往会存在许多需要解决的问题，题干有时也会抛出一个明确的问题，在材料中隐含导致问题的原因。在这种情况下，可在分析本质问题、根本原因的基础上，反向推导出对策。如此,对策才能从根本上解决问题\n根据经验、教训得到对策：有些材料中会介绍国内外的成功经验，需要考生从中总结对策。有些材料中会介绍一些国内外不好的做法，即教训，需要考生进行反推。这类材料在近些年的国考中很少出现\n总结经验通常可以引用材料中的原话或是在语言上稍加整理，但要注意所得措施还需转换主体，把总结出的经验转化为本地适用的可行措施\n\n\n\n\n加工要点：在材料中提取的对策要点往往多而杂，要清晰地呈现出来，就需要对对策要点进行加工。在单一对策题中，答案基本上都是措施类要点，因此呈现出来的多是动宾结构的短句，在加工时可参考如下形式\n\n\n主旨句指位于单条对策最前端的概括性句子，其作用为高度概括答案要点，方便阅卷者快速提取答案信息\n具体阐述是对主旨句的扩展，包括主体、手段和目的\n主体，即对策是由谁实施的，一般情况下对策主体是政府部门,若题干中给出明确限定，则以题干为准\n手段，即对策是如何实施的，通过怎样的途径、依循怎样的程序等\n目的，即实施对策要达到的预期效果\n\n\n在加工单条对策时，主体和目的不是必须具备的，但手段必须要有且须切实可行\n\n\n\n2.复合型对策\n提取要点：复合型对策，除提出对策外，还需要概括问题或原因等，且对于问题或原因等的表述必须体现在答案中\n\n加工要点：复合型对策一般都有条理方面的要求，因此在作答时，要在加工单条对策的基础上，进行整体加工，将作答任务分开表述，需要注意的是，根据材料概括出的问题等在对策中必须给予解决，提出的对策也一定要针对材料分析出的问题，基本框架如下：\n\n\n提出对策题的答案来源广泛，从材料中的问题、原因、经验、教训中都可以提炼出对策，我们需要把握其核心本质得出对策，同时还需要依靠自身积累完善对策内容，将其完整地表达出来\n\n常见对策：\n\n\n\n\n\n3.真题精解贯彻执行1.题型介绍\n题型分类\n宣传演讲类：讲话稿、发言稿、报道、新闻稿、宣传稿、倡议书、公开信、讲解稿等，主要为了将观点、主张、倡议、政策、做法等传达给受众，是他们信服并在思想感情上产生共鸣\n大多给出特定场景和身份，场景一般设定的是具体的活动或座谈会、报告会等会议\n写作目的是向受众介绍经验、事迹、活动或回应社会关切等，旨在让其理解和接受，并落实到行动中\n作答思路框架：标题+称谓+开头（背景介绍）+主体（具体内容）+结尾（发出呼吁）+落款\n\n\n总结说明类：调研报告、情况介绍、推荐材料、简报、编者按、导言等，都是偏向于对工作内容、事件过程、事物特征等汇报总结、概括说明的一类文书\n并不特异强调行文场景和作答身份，更多的是就事论事\n写作目的大多是总结、报告成功的经验做法\n作答思路框架：标题+称谓+开头（背景介绍）+主体（具体内容）+结尾（总结）\n\n\n方案建议类：建议书、方案、通知、提案、计划等，多是对工作提出指导性意见或作出计划性安排，即在工作前给出要求或方法\n部分题目并不十分依赖行文场景，但仍会给出作答身份\n写作目的多是对某项工作提出意见、作出安排，提取的要点应以对策为主\n由于此类题目往往涉及对工作的指导，考生缺乏相关经验，其提问方式往往是“草拟提纲”“拟写工作要点”等，在强调纲要性的同时削弱了对格式的要求，降低了整体难度\n作答思路框架：标题+开头（背景介绍）+主体（提出建议）+结尾（总结上文）\n\n\n观点主张类：短评、回帖、回应等，侧重于表达观点、提出主张、解释问题、回应疑问\n部分题目的作答与场景、身份关联不密切，设置场景和身份只是为了引出作答任务\n部分题目并未给出明确的观点，需要仔细阅读材料，形成自己的观点\n作答思路框架：标题+称谓+开头（背景介绍）+主体（话题分析）+结尾（总结提升）+落款\n\n\n\n\n核心要求\n内容要求\n要点内容具体：将材料涉及的现状、问题、影响、解决措施、意义等要点全面提取，并提纲挈领地表述出来，但是不能过于抽象、笼统、细节需要明确\n文书架构清晰：写作的文书要有清晰的脉络和合理的逻辑，通常表现为层次分明、有逻辑性\n层次分明，即文书呈现出;清晰的结构框架。文书要由开头、主体、结尾(有时可省略)几部分清晰展现，呈现出“总一分(一总)”的层次。主体部分要依照题目要求和材料的层次，从几个方面分别书写\n有逻辑性，即行文的逻辑思路要正确、合理，以保证文书的结构前后连贯、严密有序。在作答时，要注意文书各部分之间的逻辑联系，既不能出现前后内容互不相干的情况，也不能出现前后内容相互矛盾的现象。\n\n\n符合客观实际：客观实际包括材料和题目所给出的与作答有关的背景、原因、意义等多方面内容。在作答时一定要立足客观情况，做到一切从材料和题目出发\n\n\n身份要求\n自身的身份定位：一般题目会设定一个虚拟身份，或者在作答背景中隐藏作答身份（通常是政府某部门的工作人员）\n受众的身份定位：在作答前，确定行文是面向机关内部还是面向社会大众，是上呈上级机关或领导审阅还是下发下级机关执行，或是向平行机关发文\n\n\n格式要求：趋势是慢慢淡化对行文格式的考察，但是仍要认真审题，根据题目中的一些消息来判断是否需要按照规范格式行文\n语言要求：用语恰当、简洁、不空喊口号、符合作答身份和受文对象身份即可，一般而言，通告、意见、通知、通报、报告、请示、建议书、简报、计划、总结等的语言风格都要求正式、规范、得体、严谨。而讲话稿、宣传稿、倡议书、报道、导言、短评等的语言风格要求不那么严格，可视受文对象而定\n\n\n\n2.技巧强化1.宣传演讲类\n讲话稿\n标题：把讲话主题作为标题，体现讲话主旨；有讲话人的姓名、职务、事由和文种构成；复式标题，即前两种的组合，如《进一步学习和发扬鲁迅精神——在鲁迅诞生110周年纪念大会上的讲话》\n称谓：只需根据题干正确判断受文对象，然后将其顶格书写即可\n正文\n开头：吸引听众，亮明讲话缘由，用简洁的文字把要讲的内容概述一下，说明讲话的缘由或者所要讲的内容重点，借此引入讲话的主题，主要有以下两部分\n常用开头语：包括欢迎与会人员到来，表明自己的与会身份、感谢会议邀请等内容\n观点类表述：需要点明讲话背景、此次讲话的主题等，让听众一开始就明白此次讲话的观点和主张\n\n\n主体：紧扣主题，有主有次，围绕讲话主题来具体展开，需要从材料中提取与讲话主题相应的要点；弄清楚讲话的重点在哪里，详略得当地组织要点\n结尾：总结发言，提出希望和要求。写法多样，或总结全篇，重申写作主题、或联系现实，发出希望号召、或征询对讲话内容的意义或建议等\n\n\n\n\n宣传稿\n标题：清晰、新颖，能够凸显特色和亮点，确保宣传内容一目了然，能够激发阅读兴趣，如《社区安全靠大家 安全社区惠大家》\n正文：\n开头：亮明事由，引出宣传主题，常以问题、目的、意义、效果类信息作引，亮明宣传事由，顺势提出要宣传的对象，如典型特征、先进做法、光辉事迹、发展前景等，对宣传对象的概述，要简洁、清晰、有吸引力\n主体：全面论述，突出特色亮点\n全面论述，即有什么说什么。书写宣传内容时，务必实事求是，坚持以材料中的事实为主体\n突出特色亮点，抓人眼球。在论述宣传内容时，要善于思考“我们需要宣传什么”和“受众希望了解什么”这两个问题，从中找到需要重点宣传的特色亮点，在稿件中突出显示，增强宣传效果\n\n\n结尾：强调宣传主题，展望号召，结尾部分一般是呼吁号召人们关注、支持宣传对象，有以下两种写法\n对于以说明为主要表达方式，用来宣传功能、方法、事迹、发展过程等的宣传稿，常在结尾进行总结，进一步强调宣传主题\n对于目的是扩大受众面，以使更多人参与的宣传稿，常在结尾呼吁、号召大家积极行动起来，有时会对未来提出展望\n\n\n\n\n\n\n公开信\n标题\n居中写“公开信”三个字\n采用“（发信方）+（涉及问题）+受信方+文种”，如《中共中央关于控制我国人口增长问题致全体共产党员、共青团员的公开信》\n采用复式标题：主体+上述第二点，如《一元伊始，万象更新——致社区居民的一封信》\n\n\n称谓与落款\n称谓：公开信的受信方一般为某个人或某个共同的身份，如“x×同学”“全体共产觉员”“尊敬的各位家长”等。根据不同对象的身份特点还可加上“尊敬的”敬爱的”“广大”等字样\n落款：一般来说，在正文之后另起一行写明发信单位或个人姓名,然后再另起一行写明发信日期即可，日期有时会省略。此外，如果标题已写明发信方，那么就可以不再署名\n\n\n正文\n开头：阐明原因及背景，开头主要用于介绍写作公开信的原因和背景，即为什么要写这封公开信\n主体：分析阐释+措施建议，注意部分主要是通过分析阐释和措施建议，来说明主要事实和观点\n分析阐释是对问题进行深层次的挖掘，即阐明问题是什么，或者阐述重要意义，或者分析问题产生的根源\n措施建议则是对接下来的行动作出说明，或者针对问题提出应采取的对策，或者对公开信的受众提出建议，或者对庆祝活动作出具体安排\n\n\n结尾：形式灵活，言之成理即可，可以深化主体，也可以呼吁号召，还可以表示敬意和祝愿\n\n\n\n\n报道\n标题：体现主题、简洁、有吸引力，务必揭示新闻报道中最重要、最吸引受众的信息\n正文\n开头：揭示核心内容，吸引读者，开头要直接入题，以极其简洁的文字揭示报道的核心内容，提纲挈领，吸引人们继续读下去，有以下两种方法\n概述式。通过归纳概括，在开头点明时间、地点、人物、事件等基本要素，使读者先有一个整体认识\n评论式。一般说来,报道的开头应尽量避免发表评论，但有些报道新事物或典型经验、重大事件的新闻，其意义不易被读者迅速理解，在这种情况下，可以在开头中添加一些简洁的评论，以明确作者观点\n\n\n主体：进一步解释导语，集中叙述\n主体是报道的主干部分，它紧接开头之后，用于集中叙述事件、闸发问题或表明观点，对导语部分作进一步解释。在写主体时，要根据题目给定的或总结出的主题，从给定资料中全面、准确地提炼事件、问题等要点,并进行整合加工，组织成答案\n为了使内容层次更加分明，一些报道会在主体部分拟制多个小标题，分别统领不同部分的内容\n\n\n结尾：总结提升，有时可省略\n\n\n\n\n\n2.总结说明类\n调研报告\n标题：\n﻿公文式标题：主要写法为“发文机关＋（关于）＋事由+文种”，如《中央组织部关于全国大学生村官工作推进情況的调研报告》。有时发文机关可省略\n﻿正副式标题：正标题一般为调研报告的主题思想或主要内容，而一些研究讨论性的调研报告的正标题也可以通过设问的形式来引起读者的兴趣；副标题则为调研的事项、范围及对象。如《争创国家乡村振兴示范区 打造中部地区乡村振兴的样板——回龙圩管理区乡村振兴调研报告》\n\n\n正文\n开头：介绍背景，引出下文。内容一般包括介绍调查目的、时间、方法、范围、对象、基本观点、调查经过、主要收获\n主体：分析研究，总结经验。注意结构包括以下两种\n并列结构，即调研报告主体各部分之问是并列关系。这种结构方式对调查所得的事实 、数据材料进行概括、分类，从几个不同角度说明问题、概括做法。此类结构常使用序号或小标题的方式突出要点，以显示其清晰、明了的内容架构\n顺序结构，即调研报告主体是按照调查的时间先后顺序或按照事物发展顺序进行叙述和议论的。顺序结构常用于对某一事件进行的调研，需要在主体部分说清事件的起因、经过 、结果等\n除此之外，在实际应用中也有一些内容丰富的调研报告会综合运用并列结构和顺序结构，即先交代事件经过，再分析、归纳、总结事物的基本特性\n\n\n结尾：得出结论，提出希望，调研报告的结尾,要简洁明了地得出调研结论或展望未来，有时可省略\n\n\n\n\n汇报材料\n标题\n两项式标题：事由+文种。这是汇报标题常用的写法，如《关于开展主题觉日活动的情况汇报》\n三项式标题：发文机关＋事由＋文种。如《××市交通运输局法治交通建设工作汇报》\n自由式标题：适用于会议发言、交流体会、经验汇报等。这类标题没有特定格式，但主题要突出、有新意\n\n\n正文\n开头：总述背景，介绍情况。汇报材料的开头主要是总述工作情况，通常概括性地交代发文背景、主要做法、取得的成绩和存在的问题等，并以此作为行文的依据或缘由。在总述结束后，通常会使用惯用的过渡性语句如“现将有关情况汇报如下”引起下文\n主体：突出重点，纲举目张。主体是汇报的关键所在，不仅篇幅所占比重大，而且表达的思想内容丰富。这部分的主要内容包括取得的成绩、经验教训、体会感悟以及怎样去做等方面。在写法上要做到纲举日张、观点明确\n结尾：作出总结，可以省略。结尾依内容的需要切合实际、简洁明了即可。有时材料中并无相关要点，可以省略\n\n\n\n\n简报：\n标题\n单行标题，即标题是能够概括简报主要内容或核心主旨的一句话。常用写法为“主体＋做法”或直接用一句话点明全文主旨，如《国资委以“国企开放日”为载体建设企业精神文明》。\n﻿双行标题，即主副标题，一般主标题体现全文主旨，副标题作进一步补充说明，如《探素互联网时代党的重大活动主题宣传新途径——人民网•创先争优网认真做好创先争优活动宣传工作》。\n\n\n正文\n开头：开门见山，切入主题。用简短的文字，准确地概括报道的内容，说明报道的宗旨，引导读者阅读全文\n主体：反映情况，介绍做法。足够典型、富有说服力的材料把开头的内容加以具体化，用材料来说明观点\n结尾：总结全文，可以省略\n\n\n\n\n导言\n标题\n将“导言”作为标题。“导言”引言”“序言”“前言““绪论“等，都可以直接作为标题。如果导言篇幅很短，可以不另起一行，以“导言：”的形式和正文写在一起\n以主题作为标题。将导言的主题或写作目的提炼出来作为标题，一般适用于导言主题鲜明或有宣传展览目的的情况，如(山中风景一×x作品展导言》。\n\n\n正文\n开头：概述背景，主题鲜明。导言的开头，要求概括性地指出作者的创作宗旨、创作目的。开头篇幅不宜过长，且应当观点清晰、明确，内容抓人眼球\n主体：介绍作品，条理清晰。主体的内容依据作品内容而定：如果是艺术作品，则可以从创作素材、创作经历展开；如果是重要著作或论文，则可以提出文中要研究的问题，引导读者阅读和理解全文\n结尾：总结全文，给予评价。导言的结尾,一般会对书籍、展览等作品进行总结、评价，或重申作者的创作目的，表达对作品的期许，有时可省略\n\n\n\n\n编者按\n在行文前写上“编者按：”三个字\n正文\n引语：引出话题背景。引语是对正文的,总体概括或背景铺垫，用来引出话题、引起读者的阅读兴趣。若编者按篇幅非常短小,也有可能会省略引语\n主体：介绍人物事件。主体内容丰富、写作方式多样,可以是对新闻事件的经过、原因、意义的具体介绍，也可以是对正文中出现的人物、事件的列举\n结语：总结编者观点。结语一般为观点总结，体现编者对正文内容的核心看法，有时也会对正文即将出现的内容做出提示\n\n\n\n\n\n3.方案建议类\n建议书\n格式\n标题：通常会拟为“关于××x的建议”，如《关于推广节约用水滴灌技术的建议》;如果不需要突出建议的具体内容,也可以只写“建议书”\n称谓：根据具体建议对象来确定，提出的建议希望得到哪些人的响应，称谓就写哪些人\n落款：在右下角写出提出建议的团体的名称或个人的名字，并附上成文日期。\n需要注意,建议书的格式并非严格固定的，有时需要根据实际情况灵活变通。一是作答字数比较紧张时:落款分为署名和日期,共占两行,对于作答字数仅有几百字的建议书来说,所占比例并不低，因此,如果作答字数并非十分充裕,落款及称谓均可略去。二是题目明确要求不考虑格式时：此时格式己不占分值，留有格式不但占用较多宇数，还可能给阅卷者留下审题不仔细的不良印象,在这种情况下,标题、称谓及落款都可略去\n\n\n正文\n开头：建议书的开头部分,应该根据给定资料，简要介绍拟定的缘由、目的或依据，简要介绍成绩、问题等,随后可用“现提出如下意见/建议”作为过渡句，以引出下文的具体建议事项\n主体：\n主体部分面对的主要是“如何解决”这个问题。建议事项可以根据给定资料中的观点、意见等直接得出，或者根据问题、原因等进行反推。另外，如果可以利用的材料很少，无法推出足够多的建议，那么就要联系社会实际和个人认识来适当发挥，但要注意对策的针对性和可行性\n具体到每条建议，可以采取“主旨句+具体闸述”的形式来表达，如“加强宣传力度(主旨句)。配备专门的宣传人员，开展交通知识学习等活动，提高群众安全意识和守法观念(具体阐述)”。内容较多、篇幅较长的答案，可以用序号或小标题的形式排列，以使结构更清晰明朗\n\n\n\n\n\n\n工作要点\n﻿正文\n目标与任务，即提出工作事项及要达到的期望目标。先写总目标、总任务和完成时限，再分别写各项具体任务。目标要切合实际\n措施与步骤，即开展工作的具体做法，包括采取什么样的工作方法，安排多少人力、物力、财力等,预估在实施过程中遇到的困难，并提出相应的解决措施\n\n\n\n\n\n4.观点主张类\n短评\n标题：短评一股采用环论式标题，需要展现自己的观点主张，不同程度地表明对所要论述的问题、现象、事件等的态度和看法，使读者一日了然。如《隐形冠军 用“芯”成就》\n正文\n开头：亮出观点，态度鲜明。短评重点在“评”，强调观点明确，为此一定要在开头鲜明地表明自己的态度、观点、看法。但观点绝不是孤立出现的，通常会由材料中介绍的问题、现象、事件等自然引出\n主体：为观点服务，议在实处。短评的主旨是分析评论，主体是为开头提出的观点服务的，以议在实处。为此，一定要抓重点、抓关键,通过对材料中与该评论主题相关信息的整合和分析，确定从哪些方面证明自己的观点，或揭示问题，或挖掘原因，或剖析本质，或预测影响，把评论的内容閘达得有理、有力。此外，遇到材料中正反面论述都有的情况，在分析时不能只谈自己支持的，而是要全面分析，并把自己支持的内容作为重点,这样才具有说服力\n结尾：总结陈述，指明发展方向。结尾，针对分析的问题、原因推导出对策或是简单指明发展方向。注意题干要求和材料限制、不能从措施建议部分展开，便应考患直接进行总结提升\n\n\n\n\n\n5.其它\n提纲\n\n重内容轻格式\n\n应用文书类型多样，很多考生的关注点总是在不同文种的不同格式上,而提纲类贯彻执行题则淡化了对格式的考查,重点强调文书内容，要求紧扣题目和材料,准确写出文书主要内容。这体现在两方面：一是部分题目的作答要求中通常对内容作出相应要求，如“要点完整”，提示考生要注重对要点进行准确提炼、完整表达;二是有的题目会指定内容，比如 2020 年国家省级申论试卷第四题要求“撰写调研报告中•问题，与“建议’这两部分内容的提纲”，那么答案就只写问题和建议两部分内容即可\n提纲的格式比较简单,除去正文,格式要素只有标题，且标题拟制比较灵活、自由，一般围绕主题拟制为“关于x×的汇报”“在×x会议上的发言”等，如“关于休闲城市建设情况的汇报”“在省‘数宇城市’建设座谈会上的发言”\n\n\n呈现纲目性\n\n所谓纲目性，指应用文书的内容要点不仅要有条理性，而且有几个部分、几个段落、几层意思,都要列出纲目，提纲挈领地表述出来。提纲与标准文书的作答方法一致，区别在答案的呈现形式上\n\n\n示例\n\n\n\n\n大公文\n\n字数达标：“大公文”写作的字数多、篇幅长，作答重点不仅要放在提取要点、加工要点上，还要重视对字数的扩充,确保字数达到标准。此外,此类题目对考生的文字表达能力要求较高，考生不仅要从材料中提取相关要点，还要根据文书特点遣词造向、优化表述，丰富文书内容\n结构完整：即要求文书不遗漏任何必备的内容要素，能够完整有效地传达文书写作意图。比如讲话稿，正文一般由开头、主体、结尾三部分组成，先閘明讲话的缘由或重点,再根据讲话目的阐明讲话内容，最后作出总结;再如宣传稿，开头通常要概达宣传对象，主体主要闸明宣传事项，包括采取了什么做法、取得了什么成效等,结尾呼呀号召人们关注、支持宣传对象。在作答时，要清楚每类文书的特点和结构，不遗漏任何结构要素。\n格式正确：“大公文”写作题作答字数较生，基本不存在“不考虑格式”《写一份提纲”的情况，若题目无明确要求,就应该严格按照文书格式要求规范书写。在申论考试中，大部分文书的格式都包括标题、称谓和落款三个部分。各个部分的具体写法在前文已详细讲解，这里不再资述。在作答时，考生要依据各类文书特点，正确书写文书格式。\n语言准确：“大公文”对语言准确的要求主要体现在立足材料和表述规范两个方面。\n立足材料：指要根据给定资料和作答要求作答。对于“大公文”来说，答案要源于材料，主题也要源于材料,也就是文书的观点要与材料保持一致。因此，在作答过程中，考生必须仔细地阅读材料，认真地理解、分析、破译材料，然后从材料的蛛丝马迹中寻找答案的要点，不可主观臆断,要切实做到准确提炼事实观点,并准确表述材料内容，如此方能写出符合要求的文书\n表述规范：“大公文”写作需要把握语言的规范性，即在词语运用、句式变换、语气选择等方面符合表达目的，不出现歧义，要避免使用方言俚语、口语、网络用语、不必要的英文单词等,而应使用书面语，机关常用语、惯用语。“大公文”写作一般都会涉及语言风格,由于各类文书的作答身份、受文对象不同，语言风格也有所区别。对于考生而言，能否根据作答身份和受文对象，准确把握作答语言风格也是影响得分的一项重要因素。作答时，考生要做到用语恰当\n\n\n\n\n\n3.真题精解申发论述1.题型介绍\n题型分类\n\n话题作文：结合对一句话或几句话的理解写文章，立意通过阅读通篇材料，深刻理解句子的意思及其与材料的关系来确定。对于这种命题方式，需要深挖题干，全面把握材料信息，才能确定写作主题\n主体/命题作文：通过给定标题/关键词等明确告知写作主题\n\n\n核心要点\n\n\n\n赋分简析\n\n观点新颖\n多种表达方式\n无语病、无错别字\n\n\n\n2.技巧强化\n3.真题精解","slug":"Note-GWY","date":"2023-04-20T08:48:16.000Z","categories_index":"","tags_index":"","author_index":"Dajunnnnnn"},{"id":"ad761ed2b5bb445c745eca7d55cac5dd","title":"Note-C++","content":"C++1.语言特性1.概述1.生命周期和编程范式\n生命周期\n\n编码（Coding）：主要包括定义变量、写逻辑语句、实现各种数据结构、函数、类。需要遵循语言规范、设计文档、代码规范、设计模式。\n预处理（Pre-processing）：这个中间阶段主要依靠预处理器（Pre-processor）预先处理源代码，它的输入是编码阶段的源码文件，输出是经过预编译的源码文件，主要做了文字替换，即通过#include、#define、#if等预处理指令实现\n编译（Compiling）：包括编译（编译器）和链接（链接器）两步，生成可以在计算机上运行的二进制机器码。这里面包括很多复杂的操作，如分词、语法解析、生成目标码、优化等，并且编译器还会检查程序的语法、语义是否正确，发现错误就会产生编译失败（静态检查）。\n运行（Running）：将静态的程序载入内存，由CPU逐条语句执行，形成动态的进程。此阶段常做的是GDB调试、日志追踪、性能分析等，然后收集动态的数据，调整设计思路，在返回编码阶段。重走以上阶段，实现螺旋上升式的开发\n\n\n编程范式（Paradigm）\n\n\n面向过程：核心思想是命令，把任务分解成若干个步骤去执行，最终达成目标。主要来源于C语言，比如变量声明、表达式、分支/循环/跳转语句、函数等\n面向对象：核心思想是抽象和封装，将任务分解成一些高内聚低耦合的对象，对象间通过通信协作来完成任务，强调对象之间的关系和接口。主要包括class、public、private、virtual、this、构造函数、析构函数、友元函数等\n泛型：核心思想是类型，源自STL，也称为参数化类型、类型擦除，通过模版的方式而不是继承的方式来复用代码。基础是template关键字，然后是标准库的各种泛型容器和算法，比如vector、map、sort等\n模版元：核心思想是类型运算，操作的数据是编译时可见的类型，代码只能由编译器执行，而不能被运行时的CPU执行。主要通过库的方式来使用，比如type_traits、enable_if等，慎用\n函数式：核心思想是一切皆可调用，通过一系列连续或者嵌套的函数调用实现对数据的处理，从c++11引入了Lambda表达式\n\n\n内存分配\n\nC语言的动态内存，用malloc()分配，用free()释放\n在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。\nnew 操作符会根据后面的数据类型来推断所需空间的大小。\n和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。\n为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现\n\n\n\n\n关键字概览\n\n\n\n\n\n\n\n\n\nC++标准：C++98、C++03、C++11、C++14、C++17、C++20\n\n流程控制：if、else、switch、case、default、goto、return、for、while、do、continue、break、\n面向对象：class、struct、union、enum、this、typedef、new、delete、\n数值操作\nchar、short、int、long、float、double、void、register（过时）、bool、true、false、wchar_t（宽字符）、char16_t（16位字符型）、char32_t（32位字符型）、sizeof（数据类型在编译期中的实现长度）、alignas（指定类型或对象的对齐要求）、alignof（查询类型的对齐要求）、typeid（获取一个变量或常量的真实数据类型）、nullptr（空指针）、auto（自动类型推导）、decltype（自动类型推导）\nunsigned、signed、const（只读变量）、volatile、mutable（修饰为可读可写）、static、extern（引用外部符号）、private、protected、public、constexpr（表示函数结果或对象是编译时决定的常量）、thread_local（变量具有线程周期）\nvirtual（用于定义虚拟函数）、friend（声明友元函数）、inline（优化为内联函数）、explicit（防止类构造函数的隐式自动转换）、\n\n\n其他\n异常处理：throw、try、catch、noexcept（指定函数（模版）是否有异常抛出）\n命名空间：namespace（定义一个～）、using（引用一个）\n多态：operator（运算符重载）、template（定义或声明模版）、typename（用于将一个特殊的符号解释成一个类型）\nasm：在代码中嵌入汇编代码\ndynamic_cast（运行时类型检查，转换…）、static_cast（编译时的静态断言）、const_cast（同来修改const或volatile）、reinterpret_cast\n\n\n\n\n特殊语法\n\n命名空间：namespace\n&#x2F;&#x2F;name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由&#123; &#125;包围。\nnamespace name&#123;\n    &#x2F;&#x2F;variables;\n    &#x2F;&#x2F;functions;\n    &#x2F;&#x2F;classes;\n&#125;\n&#x2F;&#x2F;使用1\nname::variable;\n&#x2F;&#x2F;使用2\nusing name::variable;\nvariable;\n\n\n\n\n标准命名空间（std）：C++ 开发人员想了一个好办法，保留原来的库和头文件，它们在 C++ 中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间 std 下，就成了新版 C++ 标准库。这样共存在了两份功能相似的库，使用了老式 C++ 的程序可以继续使用原来的库，新开发的程序可以使用新版的 C++ 库。\n\n为了避免头文件重名，新版 C++ 库也对头文件的命名做了调整，去掉了后缀.h。\n而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个c字\n\n\n对于不带.h的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带.h的头文件，没有使用任何命名空间，所有符号都位于全局作用域。\n\n\n\n内联函数（Inline Function）:为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。\n#include &lt;iostream&gt;\nusing namespace std;\n\n&#x2F;&#x2F;内联函数，交换两个数的值\ninline void swap(int *a, int *b)&#123;\n    int temp;\n    temp &#x3D; *a;\n    *a &#x3D; *b;\n    *b &#x3D; temp;\n&#125;\n\nint main()&#123;\n    int m, n;\n    cin&gt;&gt;m&gt;&gt;n;\n    cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl;\n    swap(&amp;m, &amp;n);\n    cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl;\n\n    return 0;\n&#125;\n\n\n\n\n注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。\n对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。\n\n\nC++默认参数：当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值\n#include&lt;iostream&gt;\nusing namespace std;\n\n&#x2F;&#x2F;带默认参数的函数\nvoid func(int n, float b&#x3D;1.2, char c&#x3D;&#39;@&#39;)&#123;\n    cout&lt;&lt;n&lt;&lt;&quot;, &quot;&lt;&lt;b&lt;&lt;&quot;, &quot;&lt;&lt;c&lt;&lt;endl;\n&#125;\n\nint main()&#123;\n    &#x2F;&#x2F;为所有参数传值\n    func(10, 3.5, &#39;#&#39;);\n    &#x2F;&#x2F;为n、b传值，相当于调用func(20, 9.8, &#39;@&#39;)\n    func(20, 9.8);\n    &#x2F;&#x2F;只为n传值，相当于调用func(30, 1.2, &#39;@&#39;)\n    func(30);\n\n    return 0;\n&#125;\n\n\nC++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值\n\n\n\n\n\n2.编码阶段\n代码格式：多用空格分隔开变量与操作符，多用空行分隔开代码块\n标识符命名：遵循一些共识（用于循环的 i/j/k、用于计数的 count、表示指针的 p/ptr、表示缓冲区的 buf/buffer、表示变化量的 delta、表示总和的 sum），命名风格主要有以下三种，应取各家所长\n匈牙利命名：给成员变量加“m_”前缀（member），给全局变量加“g_”前缀（global），比如 m_count、g_total\nCamelCase：在Java中非常流行，单词首字母大写，比如MyJobClass、tryToLock\nsnake_case：全是小写，单词之间用下划线连接，比如unordered_set、shrink_to_fit\n\n\n注释：一般包括作者、目的、用途、工作原理、注意事项、可能的返回值等信息，最后用英文\n\n3.预处理阶段\n格式示例\n#                              &#x2F;&#x2F; 预处理空行\n#if __linux__                  &#x2F;&#x2F; 预处理检查宏是否存在\n#   define HAS_LINUX    1      &#x2F;&#x2F; 宏定义，有缩进\n#endif                         &#x2F;&#x2F; 预处理条件语句结束\n#                              &#x2F;&#x2F; 预处理空行\n包含文件：因为#include可以包含任何东西，所以需要防止代码被重复包含，通过加上Include Guard，即使用“#ifndef/#define/#endif”来保护整个头文件\n#ifndef _XXX_H_INCLUDED_\n#define _XXX_H_INCLUDED_\n\n...    &#x2F;&#x2F; 头文件内容\n\n#endif &#x2F;&#x2F; _XXX_H_INCLUDED_\n技巧：编写一些代码片段，存进“*.inc”文件里，然后有选择地加载，用得好的话，可以实现“源码级别的抽象”\n&#x2F;&#x2F;改造前\nstatic uint32_t  calc_table[] &#x3D; &#123;  &#x2F;&#x2F; 非常大的一个数组，有几十行\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,\n    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    ...                          \n&#125;;\n&#x2F;&#x2F;改造后，把数组内的数单独摘出来，另存为一个“*.inc”文件\nstatic uint32_t  calc_table[] &#x3D; &#123;\n#  include &quot;calc_values.inc&quot;        &#x2F;&#x2F; 非常大的一个数组，细节被隐藏\n&#125;;\n宏定义（#define/#undef）\n\n#define可以定义源码级别的文本替换，无视c++语法限制，替换任何文字、定义常量 / 变量、实现函数功能、为类型起别名（typedef）、减少重复代码……但是为了可读性需要慎用\n\n使用方法：\n\n宏的展开没有效率损失：对于一些调用频繁的小代码片段，用宏封装比用inline关键字效果更好，因为是源码级别无条件内联\n&#x2F;&#x2F;摘自Nginx\n#define ngx_tolower(c)      ((c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39;) ? (c | 0x20) : c)\n#define ngx_toupper(c)      ((c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) ? (c &amp; ~0x20) : c)\n\n#define ngx_memzero(buf, n)       (void) memset(buf, 0, n)\n宏是没有作用域概念的，永远是全局生效：对于一些用来简化代码、起临时作用的宏，最好是用完后尽快用“#undef”取消定义，避免冲突的风险\n#define CUBE(a) (a) * (a) * (a)  &#x2F;&#x2F; 定义一个简单的求立方的宏\n\ncout &lt;&lt; CUBE(10) &lt;&lt; endl;        &#x2F;&#x2F; 使用宏简化代码\ncout &lt;&lt; CUBE(15) &lt;&lt; endl;        &#x2F;&#x2F; 使用宏简化代码\n\n#undef CUBE                      &#x2F;&#x2F; 使用完毕后立即取消定义\n宏定义前先检查：如果之前有定义就先 undef，然后再重新定义\n#ifdef AUTH_PWD                  &#x2F;&#x2F; 检查是否已经有宏定义\n#  undef AUTH_PWD                &#x2F;&#x2F; 取消宏定义\n#endif                           &#x2F;&#x2F; 宏定义检查结束\n#define AUTH_PWD &quot;xxx&quot;           &#x2F;&#x2F; 重新宏定义\n宏定义代码中的常量，消除“魔术数字”“魔术字符串”\n#define MAX_BUF_LEN    65535\n#define VERSION        &quot;1.0.18&quot;\n宏定义命名空间：用宏来代替直接定义命名空间，很容易识别出命名空间的开始和结束\n#define BEGIN_NAMESPACE(x)  namespace x &#123;\n#define END_NAMESPACE(x)    &#125;\n\nBEGIN_NAMESPACE(my_own)\n\n...      &#x2F;&#x2F; functions and classes\n\nEND_NAMESPACE(my_own)\n\n\n\n\n条件编译（#if/#else/#endif）\n\n通过判断宏的数值来产生不同的源码，改变源文件的形态。条件编译有两个要点，一个是条件指令“#if”，另一个是后面的“判断依据”，也就是定义好的各种宏，而这个“判断依据”是条件编译里最关键的部分。\n\n通常编译环境都会有一些预定义宏，比如 CPU 支持的特殊指令集、操作系统 / 编译器 / 程序库的版本、语言特性等，使用它们就可以早于运行阶段，提前在预处理阶段做出各种优化，产生出最适合当前系统的源码。\n\n示例：\n\n__cplusplus：标记了C++的版本号，可以判断是C还是C++\n#ifdef __cplusplus                      &#x2F;&#x2F; 定义了这个宏就是在用C++编译\n    extern &quot;C&quot; &#123;                        &#x2F;&#x2F; 函数按照C的方式去处理\n#endif\n    void a_c_function(int a);\n#ifdef __cplusplus                      &#x2F;&#x2F; 检查是否是C++编译\n    &#125;                                   &#x2F;&#x2F; extern &quot;C&quot; 结束\n#endif\n\n#if __cplusplus &gt;&#x3D; 201402                &#x2F;&#x2F; 检查C++标准的版本号\n    cout &lt;&lt; &quot;c++14 or later&quot; &lt;&lt; endl;    &#x2F;&#x2F; 201402就是C++14\n#elif __cplusplus &gt;&#x3D; 201103              &#x2F;&#x2F; 检查C++标准的版本号\n    cout &lt;&lt; &quot;c++11 or before&quot; &lt;&lt; endl;   &#x2F;&#x2F; 201103是C++11\n#else   &#x2F;&#x2F; __cplusplus &lt; 201103          &#x2F;&#x2F; 199711是C++98\n#   error &quot;c++ is too old&quot;               &#x2F;&#x2F; 太低则预处理报错\n#endif  &#x2F;&#x2F; __cplusplus &gt;&#x3D; 201402         &#x2F;&#x2F; 预处理语句结束\n编译器会提供一些与优化相关的底层系统信息\n#if defined(__cpp_decltype_auto)        &#x2F;&#x2F;检查是否支持decltype(auto)\n    cout &lt;&lt; &quot;decltype(auto) enable&quot; &lt;&lt; endl;\n#else\n    cout &lt;&lt; &quot;decltype(auto) disable&quot; &lt;&lt; endl;\n#endif  &#x2F;&#x2F;__cpp_decltype_auto\n\n#if __GNUC__ &lt;&#x3D; 4\n    cout &lt;&lt; &quot;gcc is too old&quot; &lt;&lt; endl;\n#else   &#x2F;&#x2F; __GNUC__ &gt; 4\n    cout &lt;&lt; &quot;gcc is good enough&quot; &lt;&lt; endl;\n#endif  &#x2F;&#x2F; __GNUC__ &lt;&#x3D; 4\n\n#if defined(__SSE4_2__) &amp;&amp; defined(__x86_64)\n    cout &lt;&lt; &quot;we can do more optimization&quot; &lt;&lt; endl;\n#endif  &#x2F;&#x2F; defined(__SSE4_2__) &amp;&amp; defined(__x86_64)\n使用“#if 1”“#if 0”来显式启用或者禁用大段代码，要比“/* … */”的注释方式更安全，也更清楚\n#if 0          &#x2F;&#x2F; 0即禁用下面的代码，1则是启用\n  ...          &#x2F;&#x2F; 任意的代码\n#endif         &#x2F;&#x2F; 预处理结束\n\n#if 1          &#x2F;&#x2F; 1启用代码，用来强调下面代码的必要性\n  ...          &#x2F;&#x2F; 任意的代码\n#endif         &#x2F;&#x2F; 预处理结束\n\n\n\n\n\n4.编译阶段\n\n\n\n\n\n\n\n\n有很多复杂的知识，与编译原理有关\n\n属性（attribute）\n\n给变量、函数、类等贴上一个编译阶段的标签，方便编译器识别处理。没有新增关键字，而是通过[[…]]的方式，方括号中间就是属性标签，c++11只有两个属性，noreturn和carries_dependency ，c++14新增了deprecated属性，后续还有更多属性\n[[noreturn]]              &#x2F;&#x2F; 属性标签\nint func(bool flag)       &#x2F;&#x2F; 函数绝不会返回任何值\n&#123;\n    throw std::runtime_error(&quot;XXX&quot;);\n&#125;\nGCC的属性都在gnu::里，示例如下：\n\ndeprecated：与 C++14 相同，但可以用在 C++11 里\nunused：用于变量、类型、函数等，表示虽然暂时不用，但最好保留着，因为将来可能会用\nconstructor：函数会在 main() 函数之前执行，效果有点像是全局对象的构造函数\ndestructor：函数会在 main() 函数结束之后执行，有点像是全局对象的析构函数\nalways_inline：要求编译器强制内联函数，作用比 inline 关键字更强\nhot：标记“热点”函数，要求编译器更积极地优化\n\n[[gnu::unused]]      &#x2F;&#x2F; 声明下面的变量暂不使用，不是错误\nint nouse;  \n\n\n静态断言（static_assert）\n\nassert：用来断言一个表达式必定为真，比如数字必须是正数，指针必须非空，函数必须返回true。当程序（也就是 CPU）运行到 assert 语句时，就会计算表达式的值，如果是 false，就会输出错误消息，然后调用 abort() 终止程序的执行。（assert 虽然是一个宏，但在预处理阶段不生效，而是在运行阶段才起作用，所以又叫“动态断言”）\nassert(i &gt; 0 &amp;&amp; &quot;i must be greater than zero&quot;);\nassert(p !&#x3D; nullptr);\nassert(!str.empty());\nstatic_assert：是一个关键字而不是宏，只在编译时生效，运行阶段不可见。类似于assert，在编译阶段检测各种条件的断言，编译期会看是不是true，如果不是，则导致编译失败。（static_assert 运行在编译阶段，只能看到编译时的常数和类型，看不到运行时的变量、指针、内存数据等）\ntemplate&lt;int N&gt;\nstruct fib\n&#123;\n    static_assert(N &gt;&#x3D; 0, &quot;N &gt;&#x3D; 0&quot;);&#x2F;&#x2F;保证模板参数必须大于等于零\n\n    static const int value &#x3D;\n        fib&lt;N - 1&gt;::value + fib&lt;N - 2&gt;::value;\n&#125;;\n\n\n\n5.运行阶段\nC++中一个类会有六大基本函数：构造函数、析构函数、拷贝构造函数、拷贝赋值函数、转移构造函数、转移赋值函数。C++编译期会自动为我们生成这些函数的默认实现，省去我们重复编写的时间。\n\n对于比较重要的构造函数和析构函数，应该用=default的形式，明确告诉编译器，应该实现这个函数，让编译期做好优化\nclass DemoClass final \n&#123;\npublic:\n    DemoClass() &#x3D; default;  &#x2F;&#x2F; 明确告诉编译器，使用默认实现\n   ~DemoClass() &#x3D; default;  &#x2F;&#x2F; 明确告诉编译器，使用默认实现\n&#125;;\n使用=delete明确地禁用某个函数形式，可以用于任何函数（成员函数、自由函数）\nclass DemoClass final \n&#123;\npublic:\n    DemoClass(const DemoClass&amp;) &#x3D; delete;              &#x2F;&#x2F; 禁止拷贝构造\n    DemoClass&amp; operator&#x3D;(const DemoClass&amp;) &#x3D; delete;  &#x2F;&#x2F; 禁止拷贝赋值\n&#125;;\n因为 C++ 有隐式构造和隐式转型的规则，如果类里有单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用“explicit”将这些函数标记为“显式”\nclass DemoClass final \n&#123;\npublic:\n    explicit DemoClass(const string_type&amp; str)  &#x2F;&#x2F; 显式单参构造函数\n    &#123; ... &#125;\n\n    explicit operator bool()                  &#x2F;&#x2F; 显式转型为bool\n    &#123; ... &#125;\n&#125;;\n\n\nC++11新特性\n\n委托构造（delegating constructor）：多个构造函数有相同的部分，原先需要提取出来，放到一个init()函数里，然后构造函数去调用，C++11可以使用委托构造，一个构造函数直接调用另一个构造函数\nclass DemoDelegating final\n&#123;\nprivate:\n    int a;                              &#x2F;&#x2F; 成员变量\npublic:\n    DemoDelegating(int x) : a(x)        &#x2F;&#x2F; 基本的构造函数\n    &#123;&#125;  \n\n    DemoDelegating() :                 &#x2F;&#x2F; 无参数的构造函数\n        DemoDelegating(0)               &#x2F;&#x2F; 给出默认值，委托给第一个构造函数\n    &#123;&#125;  \n\n    DemoDelegating(const string&amp; s) : &#x2F;&#x2F; 字符串参数构造函数\n        DemoDelegating(stoi(s))        &#x2F;&#x2F; 转换成整数，再委托给第一个构造函数\n    &#123;&#125;  \n&#125;;\n成员变量初始化（In-class member initializer）：类有很多成员变量的时候，写构造函数需要写一长串名字来逐个初始化，C++11可以在类里声明变量的同时给它赋值，实现初始化\nclass DemoInit final                  &#x2F;&#x2F; 有很多成员变量的类\n&#123;\nprivate:\n    int                 a &#x3D; 0;        &#x2F;&#x2F; 整数成员，赋值初始化\n    string              s &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; 字符串成员，赋值初始化\n    vector&lt;int&gt;         v&#123;1, 2, 3&#125;;   &#x2F;&#x2F; 容器成员，使用花括号的初始化列表\npublic:\n    DemoInit() &#x3D; default;             &#x2F;&#x2F; 默认构造函数\n   ~DemoInit() &#x3D; default;             &#x2F;&#x2F; 默认析构函数\npublic:\n    DemoInit(int x) : a(x) &#123;&#125;         &#x2F;&#x2F; 可以单独初始化成员，其他用默认值\n&#125;;\n类型别名（Type Alias）：C++11 扩展了关键字 using 的用法，增加了 typedef 的能力，可以定义类型别名。它的格式与 typedef 正好相反，别名在左边，原名在右边，是标准的赋值形式，所以易写易读。\nusing uint_t &#x3D; unsigned int;        &#x2F;&#x2F; using别名\ntypedef unsigned int uint_t；      &#x2F;&#x2F; 等价的typedef\n  \n&#x2F;&#x2F;在写类的时候，标准库里的类型名字都很长，可以通过using来给他们起别名\n\nclass DemoClass final\n&#123;\npublic:\n    using this_type         &#x3D; DemoClass;          &#x2F;&#x2F; 给自己也起个别名\n    using kafka_conf_type   &#x3D; KafkaConfig;        &#x2F;&#x2F; 外部类起别名\n\npublic:\n    using string_type   &#x3D; std::string;            &#x2F;&#x2F; 字符串类型别名\n    using uint32_type   &#x3D; uint32_t;              &#x2F;&#x2F; 整数类型别名\n\n    using set_type      &#x3D; std::set&lt;int&gt;;          &#x2F;&#x2F; 集合类型别名\n    using vector_type   &#x3D; std::vector&lt;std::string&gt;;&#x2F;&#x2F; 容器类型别名\n\nprivate:\n    string_type     m_name  &#x3D; &quot;tom&quot;;              &#x2F;&#x2F; 使用类型别名声明变量\n    uint32_type     m_age   &#x3D; 23;                  &#x2F;&#x2F; 使用类型别名声明变量\n    set_type        m_books;                      &#x2F;&#x2F; 使用类型别名声明变量\n\nprivate:\n    kafka_conf_type m_conf;                       &#x2F;&#x2F; 使用类型别名声明变量\n&#125;;\n\n\n\n\n2.自动类型推导（auto/decitype）\n自动类型推导就是让计算机去运算，得出操作目标的编译阶段的类型。因为C++是一种静态类型，任何变量都要有一个确定的类型，所以在声明变量的时候，必须要明确地给出类型。但其实编译器是知道这些类型的，有了自动类型推导，即auto关键字，编译器就会自动填上正确的类型（有时推断的不是想要的）\nauto  i &#x3D; 0;          &#x2F;&#x2F; 自动推导为int类型\nauto  x &#x3D; 1.0;        &#x2F;&#x2F; 自动推导为double类型\n\nauto  str &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; 自动推导为const char [6]类型\n\nstd::map&lt;int, std::string&gt; m &#x3D; &#123;&#123;1,&quot;a&quot;&#125;, &#123;2,&quot;b&quot;&#125;&#125;;  &#x2F;&#x2F; 自动推导不出来\n\nauto  iter &#x3D; m.begin();  &#x2F;&#x2F; 自动推导为map内部的迭代器类型\n\nauto  f &#x3D; bind1st(std::less&lt;int&gt;(), 2);  &#x2F;&#x2F; 自动推导出类型，具体是啥不知道\n\n\n避免了对类型的硬编码，例如上面的代码中，当把map改为unordered_map的时候，后面的代码不需改变\n\n\nauto\n\nauto的自动推导只在初始化的场合，就是复制初始化或者花括号初始化，且变量右边必须要有一个表达式（在类成员变量初始化的时候，C++不允许使用auto）\n\n推导规则\n\nauto 总是推导出“值类型”，绝不会是“引用”\n\nauto 可以附加上 const、volatile、*、&amp; 这样的类型修饰符，得到新的类型\nauto        x &#x3D; 10L;    &#x2F;&#x2F; auto推导为long，x是long\n\nauto&amp;       x1 &#x3D; x;      &#x2F;&#x2F; auto推导为long，x1是long&amp;\nauto*       x2 &#x3D; &amp;x;    &#x2F;&#x2F; auto推导为long，x2是long*，是值类型而不是引用类型\nconst auto&amp; x3 &#x3D; x;        &#x2F;&#x2F; auto推导为long，x3是const long&amp;\nauto        x4 &#x3D; &amp;x3;    &#x2F;&#x2F; auto推导为const long*，x4是const long*\n\n\n使用场景\n\n在变量声明的时候尽量多用auto\n\nrange-based for中不需要关心容器元素类型，但是为了保证效率，最好使用“const auto&amp;”或者“auto&amp;”\nvector&lt;int&gt; v &#x3D; &#123;2,3,5,7,11&#125;;  &#x2F;&#x2F; vector顺序容器\n\nfor(const auto&amp; i : v) &#123;      &#x2F;&#x2F; 常引用方式访问元素，避免拷贝代价\n  cout &lt;&lt; i &lt;&lt; &quot;,&quot;;          &#x2F;&#x2F; 常引用不会改变元素的值\n&#125;\n\nfor(auto&amp; i : v) &#123;          &#x2F;&#x2F; 引用方式访问元素\n  i++;                      &#x2F;&#x2F; 可以改变元素的值\n  cout &lt;&lt; i &lt;&lt; &quot;,&quot;;\n&#125;\n推导函数返回值\nauto get_a_set()              &#x2F;&#x2F; auto作为函数返回值的占位符\n&#123;\n    std::set&lt;int&gt; s &#x3D; &#123;1,2,3&#125;;\n    return s;\n&#125;\n\n\n\n\ndecltype\n\nauto只能用于初始化，表达式推导一般使用decltype。decltype 的形式很像函数，后面的圆括号里就是可用于计算类型的表达式（和 sizeof 有点类似），其他方面就和 auto 一样了，也能加上 const、*、&amp; 来修饰。\nint x &#x3D; 0;          &#x2F;&#x2F; 整型变量\n\ndecltype(x)     x1;      &#x2F;&#x2F; 推导为int，x1是int\ndecltype(x)&amp;    x2 &#x3D; x;    &#x2F;&#x2F; 推导为int，x2是int&amp;，引用必须赋值\ndecltype(x)*    x3;      &#x2F;&#x2F; 推导为int，x3是int*\ndecltype(&amp;x)    x4;      &#x2F;&#x2F; 推导为int*，x4是int*\ndecltype(&amp;x)*   x5;      &#x2F;&#x2F; 推导为int*，x5是int**\ndecltype(x2)    x6 &#x3D; x2;  &#x2F;&#x2F; 推导为int&amp;，x6是int&amp;，引用必须赋值，推导出了引用类型\ndecltype 不仅能够推导出值类型，还能够推导出引用类型，也就是表达式的“原始类型”\nusing int_ptr &#x3D; decltype(&amp;x);    &#x2F;&#x2F; int *\nusing int_ref &#x3D; decltype(x)&amp;;    &#x2F;&#x2F; int &amp;\nC++14 就又增加了一个“decltype(auto)”的形式，既可以精确推导类型，又能像 auto 一样方便使用\nint x &#x3D; 0;            &#x2F;&#x2F; 整型变量\n\ndecltype(auto)     x1 &#x3D; (x);  &#x2F;&#x2F; 推导为int&amp;，因为(expr)是引用类型\ndecltype(auto)     x2 &#x3D; &amp;x;   &#x2F;&#x2F; 推导为int*\ndecltype(auto)     x3 &#x3D; x1;   &#x2F;&#x2F; 推导为int&amp;\n使用场景\n\n侧重于编译阶段的类型计算，常用在泛型编程里，获取各种类型\n\n定义函数指针\n&#x2F;&#x2F; UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？\nvoid (*signal(int signo, void (*func)(int)))(int)\n\n&#x2F;&#x2F; 使用decltype可以轻松得到函数指针类型\nusing sig_func_ptr_t &#x3D; decltype(&amp;signal) ;\n定义类的成员变量、成员函数上，变通地实现auto的功能\nclass DemoClass final\n&#123;\npublic:\n    using set_type      &#x3D; std::set&lt;int&gt;;  &#x2F;&#x2F; 集合类型别名\nprivate:\n    set_type      m_set;                   &#x2F;&#x2F; 使用别名定义成员变量\n\n    &#x2F;&#x2F; 使用decltype计算表达式的类型，定义别名\n    using iter_type &#x3D; decltype(m_set.begin());\n\n    iter_type     m_pos;                   &#x2F;&#x2F; 类型别名定义成员变量\n&#125;;\n\n\n\n\n\n3.常量（const、volatile、mutable）\nconst\n\n定义程序要用到的数字、字符串常量、代替宏定义，用于表示常量。与宏定义的本质区别是，在运行阶段才会出现，而宏定义在编译阶段就出现了。可以称作是只读变量\nconst int MAX_LEN       &#x3D; 1024;\nconst std::string NAME  &#x3D; &quot;metroid&quot;;\n因为const是只读变量，所以可以通过指针得到地址来更改，但是编译器对于const修饰的常数，会做各种优化，所以需要加volatile关键字，才能更改。volatile作用见下\n&#x2F;&#x2F; 需要加上volatile修饰，运行时才能看到效果\nconst volatile int MAX_LEN  &#x3D; 1024;\n\nauto ptr &#x3D; (int*)(&amp;MAX_LEN);\n*ptr &#x3D; 2048;\ncout &lt;&lt; MAX_LEN &lt;&lt; endl;      &#x2F;&#x2F; 输出2048\n常量引用：const&amp;被称为万能引用，即它可以引用任何类型（不管是值、指针、左引用还是右引用），而且他还会跟变量附加上const特性，这样变量就成了常量，只能读、禁止写。所以可以拿它做入口参数，既能保证效率又能保证安全\n\n常量指针\n\nconst放在声明的最左边，表示指向常量的指针，即指针指向一个只读变量，不允许修改\n\nconst在*的右边，表示指针不能被修改，而指向的变量可以被修改\n\n根据*在const的左右的不同，口诀：左定值右定向const修饰不变量\nstring name &#x3D; &quot;uncharted&quot;;\nconst string* ps1 &#x3D; &amp;name; &#x2F;&#x2F; 指向常量\n*ps1 &#x3D; &quot;spiderman&quot;;        &#x2F;&#x2F; 错误，不允许修改\n\n\nstring* const ps2 &#x3D; &amp;name;  &#x2F;&#x2F; 指向变量，但指针本身不能被修改\n*ps2 &#x3D; &quot;spiderman&quot;;        &#x2F;&#x2F; 正确，允许修改\n\n\n类中\nclass DemoClass final\n&#123;\n  private:\n  const long  MAX_SIZE &#x3D; 256;    &#x2F;&#x2F; const成员变量\n  int         m_value;           &#x2F;&#x2F; 成员变量\n  public:\n  &#x2F;&#x2F; const成员函数，表示这个函数是一个常量，即函数执行过程中不会修改对象（成员变量）的状态\n  int get_value() const        \n  &#123;\n    return m_value;\n  &#125;\n&#125;;\n\n\n对于常量指针和常量引用修饰的对象是只读的，那么对他的任何操作也应该是只读的，所以编译器会检查const相关代码，如果成员函数不是const，就不允许调用\n\n\n\n\n\nvolatile\n\n在C++中表示变量的值可能会以难以察觉的方式被修改，所以要禁止编译器做任何形式的优化，每次使用时都去老老实实地取值。例如上述代码在加了volatile修饰之后，就表示它是不稳定，编译器再生成二进制机器码的时候，就不会做那些有可能有副作用的优化，而是每次都去内存取值\n用const标记变量可以让编译器做更好的优化，而用volatile会禁止编译器做优化，所以应该少用volatile\n\n\nmutable\n\nmutable类似于volatile，但是volatile可以用来修饰任何变量，而mutable却只能修饰类里面的成员变量，表示变量即使是在const对象里也是可以修改的。\n\n主要是为了给const对象打一个补丁，因为封装的特性，const内部的一些对象本身就不被外部所知，此时变与不变不会改变外界看到的对象的常量性，所以给成员变量加上mutable可以使得其解除const的限制，让任何成员含糊都可以操作它\nclass DemoClass final\n&#123;\nprivate:\n    mutable mutex_type  m_mutex;    &#x2F;&#x2F; mutable成员变量\npublic:\n    void save_data() const          &#x2F;&#x2F; const成员函数\n    &#123;\n        &#x2F;&#x2F; do someting with m_mutex\n    &#125;\n&#125;;\n\n\n\n4.智能指针（smart_ptr）\n概念：\n\n在现代C++中，裸指针的使用应该变为智能指针的使用。指针的概念源自C语言，它的存在是C/C++高效的根源，但是也是无数麻烦（访问无效数据、指针越界、内存泄漏）的根源。Java和Go针对此情况有垃圾回收机制，C++只有构造/析构函数和RAII惯用法\n可以应用代理模式，把裸指针包装起来，在构造函数里初始化，在析构函数里释放。这样当对象失效销毁时，C++ 就会自动调用析构函数，完成内存释放、资源回收等清理工作。智能指针就是代替你来干这些“脏活累活”的。它完全实践了 RAII，包装了裸指针，而且因为重载了 * 和 -&gt; 操作符，用起来和原始指针一模一样。\n\n\nunique_ptr\n\n名字叫指针， 但是实际上它并不是指针，而是一个对象。但是不应该对它调用delete，它会自动管理初始化时的指针，在离开作用域时析构释放内存。他没有定义加减运算，所以不能随意移动指针地址。在使用之前需要声明并初始化，未初始化就相当于空指针\nunique_ptr&lt;int&gt; ptr3;                &#x2F;&#x2F; 未初始化智能指针\n*ptr3 &#x3D; 42 ;                         &#x2F;&#x2F; 错误！操作了空指针\n\n&#x2F;&#x2F;可以调用工厂函数 make_unique()，强制创建智能指针的时候必须初始化，需要C++14\nauto ptr3 &#x3D; make_unique&lt;int&gt;(42);               &#x2F;&#x2F; 工厂函数创建智能指针\nassert(ptr3 &amp;&amp; *ptr3 &#x3D;&#x3D; 42);\n\nauto ptr4 &#x3D; make_unique&lt;string&gt;(&quot;god of war&quot;);  &#x2F;&#x2F; 工厂函数创建智能指针\nassert(!ptr4-&gt;empty());\n所有权：正如它的名字，表示指针的所有权是“唯一”的，不允许共享，任何时候只能有一个“人”持有它。unique_ptr 应用了 C++ 的“转移”（move）语义，同时禁止了拷贝赋值，所以，在向另一个 unique_ptr 赋值的时候，要特别留意，必须用 std::move() 函数显式地声明所有权转移。赋值操作之后，指针的所有权就被转走了，原来的 unique_ptr 变成了空指针，新的 unique_ptr 接替了管理权，保证所有权的唯一性\nauto ptr1 &#x3D; make_unique&lt;int&gt;(42);    &#x2F;&#x2F; 工厂函数创建智能指针\nassert(ptr1 &amp;&amp; *ptr1 &#x3D;&#x3D; 42);         &#x2F;&#x2F; 此时智能指针有效\n\nauto ptr2 &#x3D; std::move(ptr1);         &#x2F;&#x2F; 使用move()转移所有权\nassert(!ptr1 &amp;&amp; ptr2);               &#x2F;&#x2F; ptr1变成了空指针\n\n\nshared_ptr\n\nshared_ptr 具有完整的“值语义”（即可以拷贝赋值），所以，它可以在任何场合替代原始指针，而不用再担心资源回收的问题，比如用于容器存储指针、用于函数安全返回动态创建的对象，等等。但是这一切是有代价的，shared_ptr的执行效率不如unique_ptr\n\n销毁操作：对象的析构函数不应该有复杂、严重阻塞的操作，一旦shared_ptr在某个不确定时间点析构释放资源，就会阻塞整个进程或者线程，“整个世界都会静止不动”\n\n循环引用：\nclass Node final\n&#123;\npublic:\n    using this_type     &#x3D; Node;\n    using shared_type   &#x3D; std::shared_ptr&lt;this_type&gt;;\npublic:\n    shared_type     next;      &#x2F;&#x2F; 使用智能指针来指向下一个节点\n&#125;;\n\nauto n1 &#x3D; make_shared&lt;Node&gt;();   &#x2F;&#x2F; 工厂函数创建智能指针\nauto n2 &#x3D; make_shared&lt;Node&gt;();   &#x2F;&#x2F; 工厂函数创建智能指针d\n\nassert(n1.use_count() &#x3D;&#x3D; 1);    &#x2F;&#x2F; 引用计数为1\nassert(n2.use_count() &#x3D;&#x3D; 1);\n\nn1-&gt;next &#x3D; n2;                 &#x2F;&#x2F; 两个节点互指，形成了循环引用\nn2-&gt;next &#x3D; n1;\n\nassert(n1.use_count() &#x3D;&#x3D; 2);    &#x2F;&#x2F; 引用计数为2\nassert(n2.use_count() &#x3D;&#x3D; 2);    &#x2F;&#x2F; 无法减到0，无法销毁，导致内存泄漏\nweak_ptr：它专门为打破循环引用而设计，只观察指针，不会增加引用计数（弱引用），但在需要的时候，可以调用成员函数 lock()，获取 shared_ptr（强引用）\nclass Node final\n&#123;\npublic:\n    using this_type     &#x3D; Node;\n\n    &#x2F;&#x2F; 注意这里，别名改用weak_ptr\n    using shared_type   &#x3D; std::weak_ptr&lt;this_type&gt;;\npublic:\n    shared_type     next;    &#x2F;&#x2F; 因为用了别名，所以代码不需要改动\n&#125;;\n\nauto n1 &#x3D; make_shared&lt;Node&gt;();  &#x2F;&#x2F; 工厂函数创建智能指针\nauto n2 &#x3D; make_shared&lt;Node&gt;();  &#x2F;&#x2F; 工厂函数创建智能指针\n\nn1-&gt;next &#x3D; n2;             &#x2F;&#x2F; 两个节点互指，形成了循环引用\nn2-&gt;next &#x3D; n1;\n\nassert(n1.use_count() &#x3D;&#x3D; 1);    &#x2F;&#x2F; 因为使用了weak_ptr，引用计数为1\nassert(n2.use_count() &#x3D;&#x3D; 1);   &#x2F;&#x2F; 打破循环引用，不会导致内存泄漏\n\nif (!n1-&gt;next.expired()) &#123;     &#x2F;&#x2F; 检查指针是否有效\n    auto ptr &#x3D; n1-&gt;next.lock();  &#x2F;&#x2F; lock()获取shared_ptr\n    assert(ptr &#x3D;&#x3D; n2);\n&#125;\n\n\n\n5.异常（exception）\n异常知识\n\n异常类型：\n\nC++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。\n可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据），但是catch 和真正的函数调用相比，多了一个在运行阶段将实参和形参匹配的过程，匹配成功的话就“调用”当前的 catch，否则就忽略当前的 catch。\ncatch 在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。\n\n\n异常的特点：\n\n异常的处理流程是完全独立的：throw 抛出异常后就可以不用管了，错误处理代码都集中在专门的 catch 块里。这样就彻底分离了业务逻辑与错误逻辑，看起来更清楚。\n异常是绝对不能被忽略的，必须被处理：如果你有意或者无意不写 catch 捕获异常，那么它会一直向上传播出去，直至找到一个能够处理的 catch 块。如果实在没有，那就会导致程序立即停止运行\n异常可以用在错误码无法使用的场合：因为C++比 C 语言多了构造 / 析构函数、操作符重载等新特性，有的函数根本就没有返回值，或者返回值无法表示错误，而全局的 errno 实在是“太不优雅”了，与 C++ 的理念不符，所以也必须使用异常来报告错误。\n\n\nthrow 用作异常规范\n\n异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：throw exceptionData;，exceptionData 是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。exceptionData 可以是 int、float、bool 等基本类型，也可以是指针、数组、字符串、结构体、类等聚合类型\nthrow 关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。请看下面的例子：double func (char param) throw (int);，这条语句声明了一个名为 func 的函数，它的返回值类型为 double，有一个 char 类型的参数，并且只能抛出 int 类型的异常。如果抛出其他类型的异常，try 将无法捕获，只能终止程序。（异常规范的初衷实现起来有点困难，所以大家达成的一致意见是，最好不要使用异常规范。）\n\n\n\n\n异常的用法的使用方式\n\n用法：用 try 把可能发生异常的代码“包”起来，然后编写 catch 块捕获异常并处理，而且支持多个catch块来捕获不同的异常，再分别处理\ntry\n&#123;\n  int n &#x3D; read_data(fd, ...);    &#x2F;&#x2F; 读取数据，可能抛出异常\n  \n  ...                         &#x2F;&#x2F; do some right thing\n&#125;\ncatch(exception &amp;e)   &#x2F;&#x2F;使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。\n&#123;\n    ...                       &#x2F;&#x2F; 集中处理各种错误情况\n&#125;\n&#x2F;&#x2F;C++语言本身或者标准库抛出的异常都是exception的子类，称为标准异常\nclass exception&#123;\npublic:\n    exception () throw();  &#x2F;&#x2F;构造函数\n    exception (const exception&amp;) throw();  &#x2F;&#x2F;拷贝构造函数\n    exception&amp; operator&#x3D; (const exception&amp;) throw();  &#x2F;&#x2F;运算符重载\n    virtual ~exception() throw();  &#x2F;&#x2F;虚析构函数\n    virtual const char* what() const throw();  &#x2F;&#x2F;虚函数\n&#125;\n异常类型体系\n\n\n示例一\nclass my_exception : public std::runtime_error\n&#123;\npublic:\n    using this_type     &#x3D; my_exception;        &#x2F;&#x2F; 给自己起个别名\n    using super_type    &#x3D; std::runtime_error;  &#x2F;&#x2F; 给父类也起个别名\npublic:\n    my_exception(const char* msg):            &#x2F;&#x2F; 构造函数\n        super_type(msg)                      &#x2F;&#x2F; 别名也可以用于构造\n    &#123;&#125;  \n\n    my_exception() &#x3D; default;                &#x2F;&#x2F; 默认构造函数\n   ~my_exception() &#x3D; default;                &#x2F;&#x2F; 默认析构函数\nprivate:\n    int code &#x3D; 0;                            &#x2F;&#x2F; 其他的内部私有数据\n&#125;;\n\n&#x2F;&#x2F;抛出异常的时候，最好不要直接用throw，而是要封装成一个函数，\n&#x2F;&#x2F;类似于不用new、delete关键字，通过引入一个“中间层”来获得更多的可读性、安全性和灵活性。\n[[noreturn]]                      &#x2F;&#x2F; 属性标签\nvoid raise(const char* msg)      &#x2F;&#x2F; 函数封装throw，没有返回值\n&#123;\n    throw my_exception(msg);     &#x2F;&#x2F; 抛出异常，也可以有更多的逻辑\n&#125;\n\n&#x2F;&#x2F;写 catch 块就像是写一个标准函数，所以入口参数应当使用“const &amp;”的形式，避免对象拷贝的代价\ntry\n&#123;\n    raise(&quot;error occured&quot;);     &#x2F;&#x2F; 函数封装throw，抛出异常\n&#125;\ncatch(const exception&amp; e)      &#x2F;&#x2F; const &amp;捕获异常，可以用基类\n&#123;\n    cout &lt;&lt; e.what() &lt;&lt; endl;  &#x2F;&#x2F; what()是exception的虚函数\n&#125;\n示例二\n\nArray 类实现了动态数组，它的主要思路是：在创建对象时预先分配出一定长度的内存（通过 malloc() 分配），内存不够用时就再扩展内存（通过 realloc() 重新分配）。Array 数组只能在尾部一个一个地插入（通过 push() 插入）或删除（通过 pop() 删除）元素。\n我们通过重载过的[ ]运算符来访问数组元素，如果下标过小或过大，就会抛出异常（第53行代码）；在抛出异常的同时，我们还记录了当前数组的长度和要访问的下标。\n在使用 pop() 删除数组元素时，如果当前数组为空，也会抛出错误。\n\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nusing namespace std;\n&#x2F;&#x2F;自定义的异常类型\nclass OutOfRange&#123;\npublic:\n    OutOfRange(): m_flag(1)&#123; &#125;;\n    OutOfRange(int len, int index): m_len(len), m_index(index), m_flag(2)&#123; &#125;\npublic:\n    void what() const;  &#x2F;&#x2F;获取具体的错误信息\nprivate:\n    int m_flag;  &#x2F;&#x2F;不同的flag表示不同的错误\n    int m_len;  &#x2F;&#x2F;当前数组的长度\n    int m_index;  &#x2F;&#x2F;当前使用的数组下标\n&#125;;\nvoid OutOfRange::what() const &#123;\n    if(m_flag &#x3D;&#x3D; 1)&#123;\n        cout&lt;&lt;&quot;Error: empty array, no elements to pop.&quot;&lt;&lt;endl;\n    &#125;else if(m_flag &#x3D;&#x3D; 2)&#123;\n        cout&lt;&lt;&quot;Error: out of range( array length &quot;&lt;&lt;m_len&lt;&lt;&quot;, access index &quot;&lt;&lt;m_index&lt;&lt;&quot; )&quot;&lt;&lt;endl;\n    &#125;else&#123;\n        cout&lt;&lt;&quot;Unknown exception.&quot;&lt;&lt;endl;\n    &#125;\n&#125;\n&#x2F;&#x2F;实现动态数组\nclass Array&#123;\npublic:\n    Array();\n    ~Array()&#123; free(m_p); &#125;;\npublic:\n    int operator[](int i) const;  &#x2F;&#x2F;获取数组元素\n    int push(int ele);  &#x2F;&#x2F;在末尾插入数组元素\n    int pop();  &#x2F;&#x2F;在末尾删除数组元素\n    int length() const&#123; return m_len; &#125;;  &#x2F;&#x2F;获取数组长度\nprivate:\n    int m_len;  &#x2F;&#x2F;数组长度\n    int m_capacity;  &#x2F;&#x2F;当前的内存能容纳多少个元素\n    int *m_p;  &#x2F;&#x2F;内存指针\nprivate:\n    static const int m_stepSize &#x3D; 50;  &#x2F;&#x2F;每次扩容的步长\n&#125;;\nArray::Array()&#123;\n    m_p &#x3D; (int*)malloc( sizeof(int) * m_stepSize );\n    m_capacity &#x3D; m_stepSize;\n    m_len &#x3D; 0;\n&#125;\nint Array::operator[](int index) const &#123;\n    if( index&lt;0 || index&gt;&#x3D;m_len )&#123;  &#x2F;&#x2F;判断是否越界\n        throw OutOfRange(m_len, index);  &#x2F;&#x2F;抛出异常（创建一个匿名对象）\n    &#125;\n    return *(m_p + index);\n&#125;\nint Array::push(int ele)&#123;\n    if(m_len &gt;&#x3D; m_capacity)&#123;  &#x2F;&#x2F;如果容量不足就扩容\n        m_capacity +&#x3D; m_stepSize;\n        m_p &#x3D; (int*)realloc( m_p, sizeof(int) * m_capacity );  &#x2F;&#x2F;扩容\n    &#125;\n    *(m_p + m_len) &#x3D; ele;\n    m_len++;\n    return m_len-1;\n&#125;\nint Array::pop()&#123;\n    if(m_len &#x3D;&#x3D; 0)&#123;\n         throw OutOfRange();  &#x2F;&#x2F;抛出异常（创建一个匿名对象）\n    &#125;\n    m_len--;\n    return *(m_p + m_len);\n&#125;\n&#x2F;&#x2F;打印数组元素\nvoid printArray(Array &amp;arr)&#123;\n    int len &#x3D; arr.length();\n    &#x2F;&#x2F;判断数组是否为空\n    if(len &#x3D;&#x3D; 0)&#123;\n        cout&lt;&lt;&quot;Empty array! No elements to print.&quot;&lt;&lt;endl;\n        return;\n    &#125;\n    for(int i&#x3D;0; i&lt;len; i++)&#123;\n        if(i &#x3D;&#x3D; len-1)&#123;\n            cout&lt;&lt;arr[i]&lt;&lt;endl;\n        &#125;else&#123;\n            cout&lt;&lt;arr[i]&lt;&lt;&quot;, &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    Array nums;\n    &#x2F;&#x2F;向数组中添加十个元素\n    for(int i&#x3D;0; i&lt;10; i++)&#123;\n        nums.push(i);\n    &#125;\n    printArray(nums);\n    &#x2F;&#x2F;尝试访问第20个元素\n    try&#123;\n        cout&lt;&lt;nums[20]&lt;&lt;endl;\n    &#125;catch(OutOfRange &amp;e)&#123;\n        e.what();\n    &#125;\n    &#x2F;&#x2F;尝试弹出20个元素\n    try&#123;\n        for(int i&#x3D;0; i&lt;20; i++)&#123;\n            nums.pop();\n        &#125;\n    &#125;catch(OutOfRange &amp;e)&#123;\n        e.what();\n    &#125;\n    printArray(nums);\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n&#x2F;&#x2F;Error: out of range( array length 10, access index 20 )\n&#x2F;&#x2F;Error: empty array, no elements to pop.\n&#x2F;&#x2F;Empty array! No elements to print.\n\n\n注意事项：\n\n要仔细分析程序中可能发生的各种错误情况，按严重程度划分出等级。\n\n对于正常的返回值，或者不太严重、可以重试 / 恢复的错误，我建议你不使用异常，把它们归到正常的流程里。（比如说字符串未找到（不是错误）、数据格式不对（轻微错误）、数据库正忙（可重试错误））\n剩下的那些中级、高级错误也不是都必须用异常，你还要再做分析，尽量降低引入异常的成本。\n\n\n使用异常的判断准则\n\n不允许被忽略的错误\n极少数情况下才会发生的错误\n严重影响正常流程，很难恢复到正常状态的错误\n无法本地处理，必须“穿透”调用栈，传递到上层才能被处理的错误\n\n\nnoexcept\n\nnoexcept 专门用来修饰函数，告诉编译器：这个函数不会抛出异常。编译器看到 noexcept，就得到了一个“保证”，就可以对函数做优化，不去加那些栈展开的额外代码，消除异常处理的成本\nvoid func_noexcept() noexcept            &#x2F;&#x2F; 声明绝不会抛出异常\n&#123;\n    cout &lt;&lt; &quot;noexcept&quot; &lt;&lt; endl;\n&#125;\nnoexcept 只是做出了一个“不可靠的承诺”，不是“强保证”，编译器无法彻底检查它的行为，标记为 noexcept 的函数也有可能抛出异常\nvoid func_maybe_noexcept() noexcept          &#x2F;&#x2F; 声明绝不会抛出异常\n&#123;\n    throw &quot;Oh My God&quot;;                    &#x2F;&#x2F; 但也可以抛出异常\n&#125;\n\n\n\n\n\n6.函数式编程（lambda）\nC++函数的特殊性\n\n函数的目的是封装执行的细节，简化程序的复杂度，但因为它有入口参数，有返回值，形式上和数学里的函数很像，所以就被称为“函数”\n\n在语法层面上，C/C++里的函数是比较特别的，虽然存在函数类型，但不存在对应类型的变量，需要用指针去简洁操作\nvoid my_square(int x)           &#x2F;&#x2F; 定义一个函数\n&#123;\n    cout &lt;&lt; x*x &lt;&lt; endl;       &#x2F;&#x2F; 函数的具体内容\n&#125;\n\nauto pfunc &#x3D; &amp;my_square;       &#x2F;&#x2F; 只能用指针去操作函数，指针不是函数\n(*pfunc)(3);                    &#x2F;&#x2F; 可以用*访问函数\npfunc(3);                       &#x2F;&#x2F; 也可以直接调用函数指针\n用法上，所有的函数都是全局的，没有生命周期的。而且函数都是平级的，不能在函数中在定义函数\n\n\n\nlambda表达式\n\n示例：lambda表达式是一个变量，可以随时在调用点定义函数，而且可以将多个小的lambda表达式组合成一个复杂的大lambda表达式\nauto func &#x3D; [](int x)          &#x2F;&#x2F; 定义一个lambda表达式\n&#123;   \n    cout &lt;&lt; x*x &lt;&lt; endl;      &#x2F;&#x2F; lambda表达式的具体内容\n&#125;;  \n\nfunc(3);                      &#x2F;&#x2F; 调用lambda表达式\n\n\n注意事项\n\n语法形式\n\n通过lambda引出符号[]，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体\nauto f1 &#x3D; []()&#123;&#125;;      &#x2F;&#x2F; 相当于空函数，什么也不做\n良好的缩进格式\nauto f2 &#x3D; []()                 &#x2F;&#x2F; 定义一个lambda表达式，必须使用auto，或匿名使用\n&#123;\n    cout &lt;&lt; &quot;lambda f2&quot; &lt;&lt; endl;\n\n    auto f3 &#x3D; [](int x)         &#x2F;&#x2F; 嵌套定义lambda表达式\n    &#123;\n        return x*x;\n    &#125;;&#x2F;&#x2F; lambda f3              &#x2F;&#x2F; 使用注释显式说明表达式结束\n\n    cout &lt;&lt; f3(10) &lt;&lt; endl;\n&#125;;  &#x2F;&#x2F; lambda f2               &#x2F;&#x2F; 使用注释显式说明表达式结束\n\n&#x2F;&#x2F;匿名使用\nvector&lt;int&gt; v &#x3D; &#123;3, 1, 8, 5, 0&#125;;     &#x2F;&#x2F; 标准容器\n\ncout &lt;&lt; *find_if(begin(v), end(v),   &#x2F;&#x2F; 标准库里的查找算法\n            [](int x)                &#x2F;&#x2F; 匿名lambda表达式，不需要auto赋值\n            &#123;\n                return x &gt;&#x3D; 5;        &#x2F;&#x2F; 用做算法的谓词判断条件 \n            &#125;                        &#x2F;&#x2F; lambda表达式结束\n        )\n     &lt;&lt; endl;                        &#x2F;&#x2F; 语句执行完，lambda表达式就不存在了\n\n\n变量捕获规则：外部变量可以理解为lambda表达式定义前所有出现的变量\n\n“[=]”表示按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改\n\n“[&amp;]”是按引用捕获所有外部变量，内部以引用的方式使用，可以修改\n\n可以在“[]”里明确写出外部变量名，指定按值或者按引用捕获\nint x &#x3D; 33;               &#x2F;&#x2F; 一个外部变量\n\nauto f1 &#x3D; [&#x3D;]()           &#x2F;&#x2F; lambda表达式，用“&#x3D;”按值捕获\n&#123;\n    &#x2F;&#x2F;x +&#x3D; 10;            &#x2F;&#x2F; x只读，不允许修改\n&#125;;\n\nauto f2 &#x3D; [&amp;]()         &#x2F;&#x2F; lambda表达式，用“&amp;”按引用捕获\n&#123;\n    x +&#x3D; 10;            &#x2F;&#x2F; x是引用，可以修改\n&#125;;\n\nauto f3 &#x3D; [&#x3D;, &amp;x]()       &#x2F;&#x2F; lambda表达式，用“&amp;”按引用捕获x，其他的按值捕获\n&#123;\n    x +&#x3D; 20;              &#x2F;&#x2F; x是引用，可以修改\n&#125;;\n\n\n泛型：在 C++14 里，lambda 表达式可以实现“泛型化”，相当于简化了的模板函数，主要利用了auto\nauto f &#x3D; [](const auto&amp; x)        &#x2F;&#x2F; 参数使用auto声明，泛型化\n&#123;\n    return x + x;\n&#125;;\n\ncout &lt;&lt; f(3) &lt;&lt; endl;             &#x2F;&#x2F; 参数类型是int\ncout &lt;&lt; f(0.618) &lt;&lt; endl;         &#x2F;&#x2F; 参数类型是double\n\nstring str &#x3D; &quot;matrix&quot;;\ncout &lt;&lt; f(str) &lt;&lt; endl;          &#x2F;&#x2F; 参数类型是string\n\n\n\n2.面向对象1.类和对象\n面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。\n\n类的定义：类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。\nclass Student&#123;\npublic:\n    &#x2F;&#x2F;成员变量\n    char *name;\n    int age;\n    float score;\n\n    &#x2F;&#x2F;成员函数\n    void say()&#123;\n        cout&lt;&lt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl;\n    &#125;\n    &#x2F;&#x2F;注意在类定义的最后有一个分号;，它是类定义的一部分，表示类定义结束了，不能省略\n&#125;;\n\nStudent stu;  &#x2F;&#x2F;创建对象，class 关键字可要可不要\nstu.name &#x3D; &quot;abc&quot;;&#x2F;&#x2F;访问类的成员\n\n&#x2F;&#x2F;使用对象指针\n&#x2F;&#x2F;因为是在栈上分配内存，所以需要使用&amp;获取它的地址\nStudent stu;\nStudent *pStu &#x3D; &amp;stu;\n&#x2F;&#x2F;在堆上创建对象\nStudent *pStu &#x3D; new Student;\n&#x2F;&#x2F;有了对象指针后，可以通过箭头-&gt;来访问对象的成员变量和成员函数\npStu-&gt;name &#x3D; &quot;def&quot;;\n\n成员函数：可以在类体外定义成员函数，但是类体中定义的成员函数会自动成为内联函数。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。\nclass Student&#123;\npublic:\n    char *name;\n    int age;\n    float score;\n    void say();  &#x2F;&#x2F;内联函数声明，可以增加 inline 关键字，但编译器会忽略\n&#125;;\n&#x2F;&#x2F;函数定义，这样，say() 就会变成内联函数。\n&#x2F;&#x2F;虽然 C++ 支持将内联函数定义在类的外部，但建议将函数定义在类的内部，不建议像下面这么写\ninline void Student::say()&#123;\n    cout&lt;&lt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;可以将函数定义放在类体外面，非内联函数\nvoid Student::sayHello()&#123;\n    cout&lt;&lt;&quot;Hello &quot;&lt;&lt;name&lt;&lt;endl;\n&#125;\n访问权限\n\nC++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。==C++ 中的 public、private、protected 只能修饰类的成员，不能修饰类==\n在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。\n在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。\n\n\n成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。\n声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private 部分，也可以先出现 public 部分。如果既不写 private 也不写 public，就默认为 private。\n\n\n构造函数：名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配。（调用没有参数的构造函数也可以省略括号）\n#include &lt;iostream&gt;\nusing namespace std;\nclass Student&#123;\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\npublic:\n    &#x2F;&#x2F;声明构造函数\n    Student(char *name, int age, float score);\n&#125;;\n&#x2F;&#x2F;定义构造函数\nStudent::Student()&#123;\n    m_name &#x3D; NULL;\n    m_age &#x3D; 0;\n    m_score &#x3D; 0.0;\n&#125;\n&#x2F;&#x2F;重载构造函数\nStudent::Student(char *name, int age, float score)&#123;\n    m_name &#x3D; name;\n    m_age &#x3D; age;\n    m_score &#x3D; score;\n&#125;\n&#x2F;&#x2F;采用初始化列表，使得代码更加简洁，使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便\n&#x2F;&#x2F;相当于函数体内部的m_name &#x3D; name; m_age &#x3D; age; m_score &#x3D; score;\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age)&#123;\n    &#x2F;&#x2F; 初始化列表可以用于全部成员变量，也可以只用于部分成员变量\n    m_score &#x3D; score;\n    &#x2F;&#x2F;TODO:\n&#125;\n&#x2F;&#x2F; 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关\n\nC++析构函数：是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。\n#include &lt;iostream&gt;\nusing namespace std;\nclass VLA&#123;\npublic:\n    VLA(int len);  &#x2F;&#x2F;构造函数\n    ~VLA();  &#x2F;&#x2F;析构函数\npublic:\n    void input();  &#x2F;&#x2F;从控制台输入数组元素\n    void show();  &#x2F;&#x2F;显示数组元素\nprivate:\n    int *at(int i);  &#x2F;&#x2F;获取第i个元素的指针\nprivate:\n    const int m_len;  &#x2F;&#x2F;数组长度\n    int *m_arr; &#x2F;&#x2F;数组指针\n    int *m_p;  &#x2F;&#x2F;指向数组第i个元素的指针\n&#125;;\nVLA::VLA(int len): m_len(len)&#123;  &#x2F;&#x2F;使用初始化列表来给 m_len 赋值\n    if(len &gt; 0)&#123; m_arr &#x3D; new int[len];  &#x2F;*分配内存*&#x2F; &#125;\n    else&#123; m_arr &#x3D; NULL; &#125;\n&#125;\nVLA::~VLA()&#123;\n    delete[] m_arr;  &#x2F;&#x2F;释放内存\n&#125;\nint main()&#123;\n    &#x2F;&#x2F;创建一个有n个元素的数组（对象）\n    int n;\n    cout&lt;&lt;&quot;Input array length: &quot;;\n    cin&gt;&gt;n;\n    VLA *parr &#x3D; new VLA(n);\n    &#x2F;&#x2F;删除数组（对象）\n    delete parr;\n    return 0;\n&#125;\nthis指针：是 C++中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。this 实际上是成员函数的一个形参，在调用成员函数时将当前对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。\n\nthis 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。\nthis 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。\n只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用（后续会讲到 static 成员）。\n\nvoid Student::setname(char *name)&#123;\n    this-&gt;name &#x3D; name;\n&#125;\nstatic\n\nstatic 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为静态变量分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了这一静态变量，也会影响到其他对象。static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。\n\nstatic 成员变量必须在类声明的外部初始化，具体形式为：type class::name = value;，被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化。static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。\n\nstatic成员函数只能访问静态成员，静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。\n\n静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。\n\n\n\nconst\n\nconst 成员变量的用法和普通 const 变量的用法相似，只需要在声明时加上 const 关键字。初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表\n&#x2F;&#x2F;初始化 const 成员变量的唯一方法就是使用初始化列表\nclass VLA&#123;\nprivate:\n    const int m_len;\n    int *m_arr;\npublic:\n    VLA(int len);\n&#125;;\n&#x2F;&#x2F;必须使用初始化列表来初始化 m_len\nVLA::VLA(int len): m_len(len)&#123;\n    m_arr &#x3D; new int[len];\n&#125;\nconst成员函数：const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称为 get 函数。常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字，请看下面的例子：\nclass Student&#123;\npublic:\n    Student(char *name, int age, float score);\n    void show();\n    &#x2F;&#x2F;声明常成员函数\n    char *getname() const;\n    int getage() const;\n    float getscore() const;\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\nvoid Student::show()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;m_score&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;定义常成员函数\n&#x2F;&#x2F;需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字,如果只在一个地方加 const 会导致声明和定义处的函数原型冲突\nchar * Student::getname() const&#123;\n    return m_name;\n&#125;\n在C++中，const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。\nconst  class  object(params);\nclass const object(params);\nconst class *p &#x3D; new class(params);\nclass const *p &#x3D; new class(params);\n\n\nfirend\n\n在C++中，借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。\n\n在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。 \n\n一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员\n\n将非成员函数声明为友元函数。\n#include &lt;iostream&gt;\nusing namespace std;\nclass Student&#123;\npublic:\n    Student(char *name, int age, float score);\npublic:\n    friend void show(Student *pstu);  &#x2F;&#x2F;将show()声明为友元函数\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\n&#x2F;&#x2F;非成员函数\nvoid show(Student *pstu)&#123;\n    &#x2F;&#x2F;注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象，如直接访问m_name\n    cout&lt;&lt;pstu-&gt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;pstu-&gt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;pstu-&gt;m_score&lt;&lt;endl;\n&#125;\nint main()&#123;\n    Student stu(&quot;小明&quot;, 15, 90.6);\n    show(&amp;stu);  &#x2F;&#x2F;调用友元函数\n    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);\n    show(pstu);  &#x2F;&#x2F;调用友元函数\n    return 0;\n&#125;\n将其他类的成员函数声明为友元函数\n#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;提前声明Address类\n&#x2F;&#x2F;如果不提前声明，编译器会报错，提示&#39;Address&#39; has not been declared\nclass Address;  \n&#x2F;&#x2F;声明Student类\nclass Student&#123;\npublic:\n    Student(char *name, int age, float score);\npublic:\n    void show(Address *addr);\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\n&#x2F;&#x2F;声明Address类\nclass Address&#123;\nprivate:\n    char *m_province;  &#x2F;&#x2F;省份\n    char *m_city;  &#x2F;&#x2F;城市\n    char *m_district;  &#x2F;&#x2F;区（市区）\npublic:\n    Address(char *province, char *city, char *district);\n    &#x2F;&#x2F;将Student类中的成员函数show()声明为友元函数\n    friend void Student::show(Address *addr);\n&#125;;\n&#x2F;&#x2F;实现Student类\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\nvoid Student::show(Address *addr)&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;\n    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;实现Address类\nAddress::Address(char *province, char *city, char *district)&#123;\n    m_province &#x3D; province;\n    m_city &#x3D; city;\n    m_district &#x3D; district;\n&#125;\nint main()&#123;\n    Student stu(&quot;小明&quot;, 16, 95.5f);\n    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);\n    stu.show(&amp;addr);\n   \n    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);\n    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);\n    pstu -&gt; show(paddr);\n    return 0;\n&#125;\n\n\n友元类：不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。\n#include &lt;iostream&gt;\nusing namespace std;\nclass Address;  &#x2F;&#x2F;提前声明Address类\n&#x2F;&#x2F;声明Student类\nclass Student&#123;\npublic:\n    Student(char *name, int age, float score);\npublic:\n    void show(Address *addr);\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\n&#x2F;&#x2F;声明Address类\nclass Address&#123;\npublic:\n    Address(char *province, char *city, char *district);\npublic:\n    &#x2F;&#x2F;将Student类声明为Address类的友元类\n    friend class Student;\nprivate:\n    char *m_province;  &#x2F;&#x2F;省份\n    char *m_city;  &#x2F;&#x2F;城市\n    char *m_district;  &#x2F;&#x2F;区（市区）\n&#125;;\n&#x2F;&#x2F;实现Student类\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\nvoid Student::show(Address *addr)&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;\n    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;实现Address类\nAddress::Address(char *province, char *city, char *district)&#123;\n    m_province &#x3D; province;\n    m_city &#x3D; city;\n    m_district &#x3D; district;\n&#125;\nint main()&#123;\n    Student stu(&quot;小明&quot;, 16, 95.5f);\n    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);\n    stu.show(&amp;addr);\n   \n    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);\n    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);\n    pstu -&gt; show(paddr);\n    return 0;\n&#125;\n\n\n\n2.引用\n参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。对于像 char、bool、int、float 等基本类型的数据，占用的内存少，对它们进行内存拷贝非常快速。而数组、结构体、对象是一系列数据的集合，占用的内存大，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。在C语言中，一般使用指针，但在C++还可以使用引用。\n\n引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；引用还类似于人的绰号（笔名），使用绰号（笔名）和本名都能表示一个人。引用的定义方式类似于指针，只是用&amp;取代了*，语法格式为：type &amp;name = data;。\n\n引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。\n\n引用使用方式\n#include &lt;iostream&gt;\nusing namespace std;\nint main() &#123;\n    int a &#x3D; 99;\n    int &amp;r &#x3D; a;\n    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; endl;&#x2F;&#x2F;99,99\n    cout &lt;&lt; &amp;a &lt;&lt; &quot;, &quot; &lt;&lt; &amp;r &lt;&lt; endl;&#x2F;&#x2F;0x28ff44, 0x28ff44\n    r &#x3D; 47;\n    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; endl;&#x2F;&#x2F;47.47\n    return 0;\n&#125;\n引用作为函数参数\n#include &lt;iostream&gt;\nusing namespace std;\nvoid swap1(int a, int b);\nvoid swap2(int *p1, int *p2);\nvoid swap3(int &amp;r1, int &amp;r2);\nint main() &#123;\n    int num1, num2;\n    cout &lt;&lt; &quot;Input two integers: &quot;;\n    cin &gt;&gt; num1 &gt;&gt; num2;\n    swap1(num1, num2);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    cout &lt;&lt; &quot;Input two integers: &quot;;\n    cin &gt;&gt; num1 &gt;&gt; num2;\n    swap2(&amp;num1, &amp;num2);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    cout &lt;&lt; &quot;Input two integers: &quot;;\n    cin &gt;&gt; num1 &gt;&gt; num2;\n    swap3(num1, num2);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;直接传递参数内容\nvoid swap1(int a, int b) &#123;\n    int temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n&#x2F;&#x2F;传递指针\nvoid swap2(int *p1, int *p2) &#123;\n    int temp &#x3D; *p1;\n    *p1 &#x3D; *p2;\n    *p2 &#x3D; temp;\n&#125;\n&#x2F;&#x2F;按引用传参\nvoid swap3(int &amp;r1, int &amp;r2) &#123;\n    int temp &#x3D; r1;\n    r1 &#x3D; r2;\n    r2 &#x3D; temp;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;Input two integers: 12 34↙\n&#x2F;&#x2F;12 34\n&#x2F;&#x2F;Input two integers: 88 99↙\n&#x2F;&#x2F;99 88\n&#x2F;&#x2F;Input two integers: 100 200↙\n&#x2F;&#x2F;200 100\n引用作为函数返回值\n\n在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。\n\n#include &lt;iostream&gt;\nusing namespace std;\nint &amp;plus10(int &amp;r) &#123;\n    r +&#x3D; 10;\n    return r;\n&#125;\nint main() &#123;\n    int num1 &#x3D; 10;\n    int num2 &#x3D; plus10(num1);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;20 20\n\n\n3.继承和派生\n继承\n\n术语：被继承的类称为父类或基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。\n\n三种继承方式：继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 protected（受保护的）。此项是可选项，如果不写，默认为 private（成员变量和成员函数默认也是 private）。\n\npublic继承方式\n基类中所有 public 成员在派生类中为 public 属性；\n基类中所有 protected 成员在派生类中为 protected 属性；\n基类中所有 private 成员在派生类中不能使用。\n\n\nprotected继承方式\n基类中的所有 public 成员在派生类中为 protected 属性；\n基类中的所有 protected 成员在派生类中为 protected 属性；\n基类中的所有 private 成员在派生类中不能使用。\n\n\nprivate继承方式\n基类中的所有 public 成员在派生类中均为 private 属性；\n基类中的所有 protected 成员在派生类中均为 private 属性；\n基类中的所有 private 成员在派生类中不能使用。\n\n\n\n\nprivate成员：我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。在派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问。\n\n继承实现代码\n#include&lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类People\nclass People&#123;\npublic:\n    void setname(char *name);\n    void setage(int age);\n    void sethobby(char *hobby);\n    char *gethobby();\nprotected:\n    char *m_name;\n    int m_age;\nprivate:\n    char *m_hobby;\n&#125;;\nvoid People::setname(char *name)&#123; m_name &#x3D; name; &#125;\nvoid People::setage(int age)&#123; m_age &#x3D; age; &#125;\nvoid People::sethobby(char *hobby)&#123; m_hobby &#x3D; hobby; &#125;\nchar *People::gethobby()&#123; return m_hobby; &#125;\n&#x2F;&#x2F;派生类Student\nclass Student: public People&#123;\npublic:\n    void setscore(float score);\nprotected:\n    float m_score;\n&#125;;\nvoid Student::setscore(float score)&#123; m_score &#x3D; score; &#125;\n&#x2F;&#x2F;派生类Pupil\nclass Pupil: public Student&#123;\npublic:\n    void setranking(int ranking);\n    void display();\nprivate:\n    int m_ranking;\n&#125;;\nvoid Pupil::setranking(int ranking)&#123; m_ranking &#x3D; ranking; &#125;\nvoid Pupil::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，考试成绩为&quot;&lt;&lt;m_score&lt;&lt;&quot;分，班级排名第&quot;&lt;&lt;m_ranking&lt;&lt;&quot;，TA喜欢&quot;&lt;&lt;gethobby()&lt;&lt;&quot;。&quot;&lt;&lt;endl;\n&#125;\nint main()&#123;\n    Pupil pup;\n    pup.setname(&quot;小明&quot;);\n    pup.setage(15);\n    pup.setscore(92.5f);\n    pup.setranking(4);\n    pup.sethobby(&quot;乒乓球&quot;);\n    pup.display();\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果\n&#x2F;&#x2F;小明的年龄是15，考试成绩为92.5分，班级排名第4，TA喜欢乒乓球。\n改变访问权限：使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。\n#include&lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类People\nclass People &#123;\npublic:\n    void show();\nprotected:\n    char *m_name;\n    int m_age;\n&#125;;\nvoid People::show() &#123;\n    cout &lt;&lt; m_name &lt;&lt; &quot;的年龄是&quot; &lt;&lt; m_age &lt;&lt; endl;\n&#125;\n&#x2F;&#x2F;派生类Student\nclass Student : public People &#123;\npublic:\n    void learning();\npublic:\n    using People::m_name;  &#x2F;&#x2F;将protected改为public\n    using People::m_age;  &#x2F;&#x2F;将protected改为public\n    float m_score;\nprivate:\n    using People::show;  &#x2F;&#x2F;将public改为private\n&#125;;\nvoid Student::learning() &#123;\n    cout &lt;&lt; &quot;我是&quot; &lt;&lt; m_name &lt;&lt; &quot;，今年&quot; &lt;&lt; m_age &lt;&lt; &quot;岁，这次考了&quot; &lt;&lt; m_score &lt;&lt; &quot;分！&quot; &lt;&lt; endl;\n&#125;\nint main() &#123;\n    Student stu;\n    stu.m_name &#x3D; &quot;小明&quot;;\n    stu.m_age &#x3D; 16;\n    stu.m_score &#x3D; 99.5f;\n    &#x2F;&#x2F;因为 show() 函数是 private 属性的，所以代码第 36 行会报错\n    stu.show();  &#x2F;&#x2F;compile error\n    stu.learning();\n    return 0;\n&#125;\nC++继承时的名字遮蔽问题\n\n如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。\n基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。\n\n\n\n\n基类和派生类的构造函数和析构函数\n\n类的构造函数不能被继承，因为名字不一样，所以继承了也不能成为派生类的构造函数。在派生类中，继承过来的成员变量的初始化工作也要由派生类的构造函数完成，因为会有private属性的成员变量，所以通常在派生类中的构造函数中调用基类的构造函数。而且，会先调用基类构造函数，再调用派生类构造函数\n&#x2F;&#x2F;People(name, age)就是调用基类的构造函数\nStudent::Student(char *name, int age, float score): People(name, age), m_score(score)&#123; &#125;\nvoid Student::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;m_score&lt;&lt;&quot;。&quot;&lt;&lt;endl;\n&#125;\n事实上，通过派生类创建对象时必须要调用基类的构造函数，这是语法规定。换句话说，定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么编译失败。\n\n和构造函数类似，析构函数也不能被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。\n\n\n\n多继承\n#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类\nclass BaseA&#123;\npublic:\n    BaseA(int a, int b);\n    ~BaseA();\npublic:\n    void show();\nprotected:\n    int m_a;\n    int m_b;\n&#125;;\nBaseA::BaseA(int a, int b): m_a(a), m_b(b)&#123;\n    cout&lt;&lt;&quot;BaseA constructor&quot;&lt;&lt;endl;\n&#125;\nBaseA::~BaseA()&#123;\n    cout&lt;&lt;&quot;BaseA destructor&quot;&lt;&lt;endl;\n&#125;\nvoid BaseA::show()&#123;\n    cout&lt;&lt;&quot;m_a &#x3D; &quot;&lt;&lt;m_a&lt;&lt;endl;\n    cout&lt;&lt;&quot;m_b &#x3D; &quot;&lt;&lt;m_b&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;基类\nclass BaseB&#123;\npublic:\n    BaseB(int c, int d);\n    ~BaseB();\n    void show();\nprotected:\n    int m_c;\n    int m_d;\n&#125;;\nBaseB::BaseB(int c, int d): m_c(c), m_d(d)&#123;\n    cout&lt;&lt;&quot;BaseB constructor&quot;&lt;&lt;endl;\n&#125;\nBaseB::~BaseB()&#123;\n    cout&lt;&lt;&quot;BaseB destructor&quot;&lt;&lt;endl;\n&#125;\nvoid BaseB::show()&#123;\n    cout&lt;&lt;&quot;m_c &#x3D; &quot;&lt;&lt;m_c&lt;&lt;endl;\n    cout&lt;&lt;&quot;m_d &#x3D; &quot;&lt;&lt;m_d&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;派生类\nclass Derived: public BaseA, public BaseB&#123;\npublic:\n    Derived(int a, int b, int c, int d, int e);\n    ~Derived();\npublic:\n    void display();\nprivate:\n    int m_e;\n&#125;;\nDerived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e)&#123;\n    cout&lt;&lt;&quot;Derived constructor&quot;&lt;&lt;endl;\n&#125;\nDerived::~Derived()&#123;\n    cout&lt;&lt;&quot;Derived destructor&quot;&lt;&lt;endl;\n&#125;\nvoid Derived::display()&#123;\n    &#x2F;&#x2F;当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，\n    &#x2F;&#x2F;编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上\n    &#x2F;&#x2F;类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。\n    BaseA::show();  &#x2F;&#x2F;调用BaseA类的show()函数\n    BaseB::show();  &#x2F;&#x2F;调用BaseB类的show()函数\n    cout&lt;&lt;&quot;m_e &#x3D; &quot;&lt;&lt;m_e&lt;&lt;endl;\n&#125;\nint main()&#123;\n    Derived obj(1, 2, 3, 4, 5);\n    obj.display();\n    return 0;\n&#125;\n虚继承\n\n为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员，在继承方式前面加上 virtual 关键字就是虚继承\n虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。\n在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。\n\n&#x2F;&#x2F;间接基类A\nclass A&#123;\nprotected:\n    int m_a;\n&#125;;\n&#x2F;&#x2F;直接基类B\nclass B: virtual public A&#123;  &#x2F;&#x2F;虚继承\nprotected:\n    int m_b;\n&#125;;\n&#x2F;&#x2F;直接基类C\nclass C: virtual public A&#123;  &#x2F;&#x2F;虚继承\nprotected:\n    int m_c;\n&#125;;\n&#x2F;&#x2F;派生类D\nclass D: public B, public C&#123;\npublic:\n    void seta(int a)&#123; m_a &#x3D; a; &#125;  &#x2F;&#x2F;正确\n    void setb(int b)&#123; m_b &#x3D; b; &#125;  &#x2F;&#x2F;正确\n    void setc(int c)&#123; m_c &#x3D; c; &#125;  &#x2F;&#x2F;正确\n    void setd(int d)&#123; m_d &#x3D; d; &#125;  &#x2F;&#x2F;正确\nprivate:\n    int m_d;\n&#125;;\nint main()&#123;\n    D d;\n    return 0;\n&#125;\n\n4.多态与虚函数\n向上转型：包括三种情况：通过a=b，将派生类b的派生属性忽略掉，将基类属性的值赋值给a，成员函数不受影响\n\n派生类对象赋值给基类对象\n派生类指针赋值给基类指针：编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。\n派生类引用赋值给基类引用：引用和指针相同，因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装\n\n\n因为通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了虚函数（Virtual Function）。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。virtual void display();\n\n什么时候声明虚函数：首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。\n\n\n有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。\n\n多态实现\n\n必须存在继承关系；\n继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）。\n存在基类的指针，通过该指针调用虚函数。\n\n#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类People\nclass People&#123;\npublic:\n    People(char *name, int age);\n    virtual void display();  &#x2F;&#x2F;声明为虚函数\nprotected:\n    char *m_name;\n    int m_age;\n&#125;;\nPeople::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;\nvoid People::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是个无业游民。&quot;&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;派生类Teacher\nclass Teacher: public People&#123;\npublic:\n    Teacher(char *name, int age, int salary);\n    virtual void display();  &#x2F;&#x2F;声明为虚函数\nprivate:\n    int m_salary;\n&#125;;\nTeacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary)&#123;&#125;\nvoid Teacher::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是一名教师，每月有&quot;&lt;&lt;m_salary&lt;&lt;&quot;元的收入。&quot;&lt;&lt;endl;\n&#125;\nint main()&#123;\n    People *p &#x3D; new People(&quot;王志刚&quot;, 23);\n    p -&gt; display();\n    p &#x3D; new Teacher(&quot;赵宏佳&quot;, 45, 8200);\n    p -&gt; display();\n    return 0;\n&#125;\n纯虚函数和抽象类\n\n在C++中，可以将虚函数声明为纯虚函数，语法格式为：virtual 返回值类型 函数名 (函数参数) = 0;，纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。\n一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。\n只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。\n\n\n包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。\n抽象类实现\n\n#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;线\nclass Line&#123;\npublic:\n    Line(float len);\n    virtual float area() &#x3D; 0;\n    virtual float volume() &#x3D; 0;\nprotected:\n    float m_len;\n&#125;;\nLine::Line(float len): m_len(len)&#123; &#125;\n&#x2F;&#x2F;矩形\nclass Rec: public Line&#123;\npublic:\n    Rec(float len, float width);\n    float area();\nprotected:\n    float m_width;\n&#125;;\nRec::Rec(float len, float width): Line(len), m_width(width)&#123; &#125;\nfloat Rec::area()&#123; return m_len * m_width; &#125;\n&#x2F;&#x2F;长方体\nclass Cuboid: public Rec&#123;\npublic:\n    Cuboid(float len, float width, float height);\n    float area();\n    float volume();\nprotected:\n    float m_height;\n&#125;;\nCuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height)&#123; &#125;\nfloat Cuboid::area()&#123; return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); &#125;\nfloat Cuboid::volume()&#123; return m_len * m_width * m_height; &#125;\n&#x2F;&#x2F;正方体\nclass Cube: public Cuboid&#123;\npublic:\n    Cube(float len);\n    float area();\n    float volume();\n&#125;;\nCube::Cube(float len): Cuboid(len, len, len)&#123; &#125;\nfloat Cube::area()&#123; return 6 * m_len * m_len; &#125;\nfloat Cube::volume()&#123; return m_len * m_len * m_len; &#125;\nint main()&#123;\n    Line *p &#x3D; new Cuboid(10, 20, 30);\n    cout&lt;&lt;&quot;The area of Cuboid is &quot;&lt;&lt;p-&gt;area()&lt;&lt;endl;\n    cout&lt;&lt;&quot;The volume of Cuboid is &quot;&lt;&lt;p-&gt;volume()&lt;&lt;endl;\n  \n    p &#x3D; new Cube(15);\n    cout&lt;&lt;&quot;The area of Cube is &quot;&lt;&lt;p-&gt;area()&lt;&lt;endl;\n    cout&lt;&lt;&quot;The volume of Cube is &quot;&lt;&lt;p-&gt;volume()&lt;&lt;endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;The area of Cuboid is 2200\n&#x2F;&#x2F;The volume of Cuboid is 6000\n&#x2F;&#x2F;The area of Cube is 1350\n&#x2F;&#x2F;The volume of Cube is 3375\ntypeid运算符：获取类型信息，是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。类型信息对于编程语言非常重要，它描述了数据的各种属性：\n\n对于基本类型（int、float 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。\n对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。\n\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\nusing namespace std;\nclass Base&#123; &#125;;\nstruct STU&#123; &#125;;\n&#x2F;&#x2F;typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，\n&#x2F;&#x2F;并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。\n&#x2F;&#x2F;name() 用来返回类型的名称。\n&#x2F;&#x2F;raw_name() 用来返回名字编码（Name Mangling）算法产生的新名称。\n&#x2F;&#x2F;hash_code() 用来返回当前类型对应的 hash 值。\nint main()&#123;\n    &#x2F;&#x2F;获取一个普通变量的类型信息\n    int n &#x3D; 100;\n    const type_info &amp;nInfo &#x3D; typeid(n);\n    cout&lt;&lt;nInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;nInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;nInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个字面量的类型信息\n    const type_info &amp;dInfo &#x3D; typeid(25.65);\n    cout&lt;&lt;dInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;dInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;dInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个对象的类型信息\n    Base obj;\n    const type_info &amp;objInfo &#x3D; typeid(obj);\n    cout&lt;&lt;objInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;objInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;objInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个类的类型信息\n    const type_info &amp;baseInfo &#x3D; typeid(Base);\n    cout&lt;&lt;baseInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;baseInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;baseInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个结构体的类型信息\n    const type_info &amp;stuInfo &#x3D; typeid(struct STU);\n    cout&lt;&lt;stuInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;stuInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;stuInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个普通类型的类型信息\n    const type_info &amp;charInfo &#x3D; typeid(char);\n    cout&lt;&lt;charInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;charInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;charInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个表达式的类型信息\n    const type_info &amp;expInfo &#x3D; typeid(20 * 45 &#x2F; 4.5);\n    cout&lt;&lt;expInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;expInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;expInfo.hash_code()&lt;&lt;endl;\n    return 0;\n&#125;\n&#x2F;**\n运行结果：\nint | .H | 529034928\ndouble | .N | 667332678\nclass Base | .?AVBase@@ | 1035034353\nclass Base | .?AVBase@@ | 1035034353\nstruct STU | .?AUSTU@@ | 734635517\nchar | .D | 4140304029\ndouble | .N | 667332678\n*&#x2F;\n\n\n5.运算符重载\n运算符重载基础及其注意事项\n\n并不是所有的运算符都可以重载。能够重载的运算符包括：+ - * / % ^ &amp; | ~ ! = &lt; &gt; += -= *= /= %= ^= &amp;= |=  &lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ – , -&gt;* -&gt; () []  new new[] delete delete[]\n重载不能改变运算符的优先级和结合性。\n重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。\n运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。\n运算符重载函数既可以作为类的成员函数，也可以作为全局函数。\n箭头运算符-&gt;、下标运算符[ ]、函数调用运算符( )、赋值运算符=只能以成员函数的形式重载。\n\n#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n&#x2F;&#x2F;复数类\nclass Complex&#123;\npublic:  &#x2F;&#x2F;构造函数\n    Complex(double real &#x3D; 0.0, double imag &#x3D; 0.0): m_real(real), m_imag(imag)&#123; &#125;\npublic:  &#x2F;&#x2F;运算符重载\n    &#x2F;&#x2F;以全局函数的形式重载\n    friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);\n    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2);\n    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2);\n    friend Complex operator&#x2F;(const Complex &amp;c1, const Complex &amp;c2);\n    friend bool operator&#x3D;&#x3D;(const Complex &amp;c1, const Complex &amp;c2);\n    friend bool operator!&#x3D;(const Complex &amp;c1, const Complex &amp;c2);\n    friend istream &amp; operator&gt;&gt;(istream &amp; in, complex &amp; A);\n    friend ostream &amp; operator&lt;&lt;(ostream &amp; out, complex &amp; A);\n    &#x2F;&#x2F;以成员函数的形式重载\n    Complex &amp; operator+&#x3D;(const Complex &amp;c);\n    Complex &amp; operator-&#x3D;(const Complex &amp;c);\n    Complex &amp; operator*&#x3D;(const Complex &amp;c);\n    Complex &amp; operator&#x2F;&#x3D;(const Complex &amp;c);\npublic:  &#x2F;&#x2F;成员函数\n    double real() const&#123; return m_real; &#125;\n    double imag() const&#123; return m_imag; &#125;\nprivate:\n    double m_real;  &#x2F;&#x2F;实部\n    double m_imag;  &#x2F;&#x2F;虚部\n&#125;;\n&#x2F;&#x2F;重载+运算符\nComplex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; c1.m_real + c2.m_real;\n    c.m_imag &#x3D; c1.m_imag + c2.m_imag;\n    return c;\n&#125;\n&#x2F;&#x2F;重载-运算符\nComplex operator-(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; c1.m_real - c2.m_real;\n    c.m_imag &#x3D; c1.m_imag - c2.m_imag;\n    return c;\n&#125;\n&#x2F;&#x2F;重载*运算符  (a+bi) * (c+di) &#x3D; (ac-bd) + (bc+ad)i\nComplex operator*(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;\n    c.m_imag &#x3D; c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;\n    return c;\n&#125;\n&#x2F;&#x2F;重载&#x2F;运算符  (a+bi) &#x2F; (c+di) &#x3D; [(ac+bd) &#x2F; (c²+d²)] + [(bc-ad) &#x2F; (c²+d²)]i\nComplex operator&#x2F;(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) &#x2F; (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    c.m_imag &#x3D; (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) &#x2F; (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    return c;\n&#125;\n&#x2F;&#x2F;重载&#x3D;&#x3D;运算符\nbool operator&#x3D;&#x3D;(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    if( c1.m_real &#x3D;&#x3D; c2.m_real &amp;&amp; c1.m_imag &#x3D;&#x3D; c2.m_imag )&#123;\n        return true;\n    &#125;else&#123;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;重载!&#x3D;运算符\nbool operator!&#x3D;(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    if( c1.m_real !&#x3D; c2.m_real || c1.m_imag !&#x3D; c2.m_imag )&#123;\n        return true;\n    &#125;else&#123;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;重载+&#x3D;运算符\nComplex &amp; Complex::operator+&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real +&#x3D; c.m_real;\n    this-&gt;m_imag +&#x3D; c.m_imag;\n    return *this;\n&#125;\n&#x2F;&#x2F;重载-&#x3D;运算符\nComplex &amp; Complex::operator-&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real -&#x3D; c.m_real;\n    this-&gt;m_imag -&#x3D; c.m_imag;\n    return *this;\n&#125;\n&#x2F;&#x2F;重载*&#x3D;运算符\nComplex &amp; Complex::operator*&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real &#x3D; this-&gt;m_real * c.m_real - this-&gt;m_imag * c.m_imag;\n    this-&gt;m_imag &#x3D; this-&gt;m_imag * c.m_real + this-&gt;m_real * c.m_imag;\n    return *this;\n&#125;\n&#x2F;&#x2F;重载&#x2F;&#x3D;运算符\nComplex &amp; Complex::operator&#x2F;&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real &#x3D; (this-&gt;m_real*c.m_real + this-&gt;m_imag*c.m_imag) &#x2F; (pow(c.m_real, 2) + pow(c.m_imag, 2));\n    this-&gt;m_imag &#x3D; (this-&gt;m_imag*c.m_real - this-&gt;m_real*c.m_imag) &#x2F; (pow(c.m_real, 2) + pow(c.m_imag, 2));\n    return *this;\n&#125;\n&#x2F;&#x2F;重载输入运算符\nistream &amp; operator&gt;&gt;(istream &amp; in, complex &amp; A)&#123;\n    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;\n    return in;\n&#125;\n&#x2F;&#x2F;重载输出运算符\nostream &amp; operator&lt;&lt;(ostream &amp; out, complex &amp; A)&#123;\n    out &lt;&lt; A.m_real &lt;&lt;&quot; + &quot;&lt;&lt; A.m_imag &lt;&lt;&quot; i &quot;;;\n    return out;\n&#125;\nint main()&#123;\n    Complex c1(25, 35);\n    Complex c2(10, 20);\n    Complex c3(1, 2);\n    Complex c4(4, 9);\n    Complex c5(34, 6);\n    Complex c6(80, 90);\n   \n    Complex c7 &#x3D; c1 + c2;\n    Complex c8 &#x3D; c1 - c2;\n    Complex c9 &#x3D; c1 * c2;\n    Complex c10 &#x3D; c1 &#x2F; c2;\n    cout&lt;&lt;&quot;c7 &#x3D; &quot;&lt;&lt;c7.real()&lt;&lt;&quot; + &quot;&lt;&lt;c7.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c8 &#x3D; &quot;&lt;&lt;c8.real()&lt;&lt;&quot; + &quot;&lt;&lt;c8.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c9 &#x3D; &quot;&lt;&lt;c9.real()&lt;&lt;&quot; + &quot;&lt;&lt;c9.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c10 &#x3D; &quot;&lt;&lt;c10.real()&lt;&lt;&quot; + &quot;&lt;&lt;c10.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n   \n    c3 +&#x3D; c1;\n    c4 -&#x3D; c2;\n    c5 *&#x3D; c2;\n    c6 &#x2F;&#x3D; c2;\n    cout&lt;&lt;&quot;c3 &#x3D; &quot;&lt;&lt;c3.real()&lt;&lt;&quot; + &quot;&lt;&lt;c3.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c4 &#x3D; &quot;&lt;&lt;c4.real()&lt;&lt;&quot; + &quot;&lt;&lt;c4.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c5 &#x3D; &quot;&lt;&lt;c5.real()&lt;&lt;&quot; + &quot;&lt;&lt;c5.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c6 &#x3D; &quot;&lt;&lt;c6.real()&lt;&lt;&quot; + &quot;&lt;&lt;c6.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n   \n    if(c1 &#x3D;&#x3D; c2)&#123;\n        cout&lt;&lt;&quot;c1 &#x3D;&#x3D; c2&quot;&lt;&lt;endl;\n    &#125;\n    if(c1 !&#x3D; c2)&#123;\n        cout&lt;&lt;&quot;c1 !&#x3D; c2&quot;&lt;&lt;endl;\n    &#125;\n   \n    return 0;\n&#125;\n重载[]\n\n重载++和–\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n&#x2F;&#x2F;秒表类\nclass stopwatch&#123;\npublic:\n    stopwatch(): m_min(0), m_sec(0)&#123; &#125;\npublic:\n    void setzero()&#123; m_min &#x3D; 0; m_sec &#x3D; 0; &#125;\n    stopwatch run();  &#x2F;&#x2F; 运行\n    stopwatch operator++();  &#x2F;&#x2F;++i，前置形式\n    stopwatch operator++(int);  &#x2F;&#x2F;i++，后置形式\n    friend ostream &amp; operator&lt;&lt;( ostream &amp;, const stopwatch &amp;);\nprivate:\n    int m_min;  &#x2F;&#x2F;分钟\n    int m_sec;  &#x2F;&#x2F;秒钟\n&#125;;\nstopwatch stopwatch::run()&#123;\n    ++m_sec;\n    if(m_sec &#x3D;&#x3D; 60)&#123;\n        m_min++;\n        m_sec &#x3D; 0;\n    &#125;\n    return *this;\n&#125;\nstopwatch stopwatch::operator++()&#123;\n    return run();\n&#125;\nstopwatch stopwatch::operator++(int n)&#123;\n    stopwatch s &#x3D; *this;\n    run();\n    return s;\n&#125;\nostream &amp;operator&lt;&lt;( ostream &amp; out, const stopwatch &amp; s)&#123;\n    out&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;s.m_min&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;s.m_sec;\n    return out;\n&#125;\nint main()&#123;\n    stopwatch s1, s2;\n    s1 &#x3D; s2++;\n    cout &lt;&lt; &quot;s1: &quot;&lt;&lt; s1 &lt;&lt;endl;\n    cout &lt;&lt; &quot;s2: &quot;&lt;&lt; s2 &lt;&lt;endl;\n    s1.setzero();\n    s2.setzero();\n    s1 &#x3D; ++s2;\n    cout &lt;&lt; &quot;s1: &quot;&lt;&lt; s1 &lt;&lt;endl;\n    cout &lt;&lt; &quot;s2: &quot;&lt;&lt; s2 &lt;&lt;endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;s1: 00:00\n&#x2F;&#x2F;s2: 00:01\n&#x2F;&#x2F;s1: 00:01\n&#x2F;&#x2F;s2: 00:01\n重载new和delete\n\n以成员函数的形式重载 new 运算符：\nvoid * className::operator new( size_t size )&#123;\n  &#x2F;&#x2F;TODO:\n&#125;\n以全局函数的形式重载 new 运算符：\nvoid * operator new( size_t size )&#123;\n  &#x2F;&#x2F;TODO:\n&#125;\n\n\n重载()\n#include &lt;iostream&gt;\nusing namespace std;\nclass Complex\n&#123;\n    double real, imag;\npublic:\n    Complex(double r &#x3D; 0, double i &#x3D; 0) :real(r), imag(i) &#123;&#125;;\n    operator double() &#123; return real; &#125;  &#x2F;&#x2F;重载强制类型转换运算符 double\n&#125;;\nint main()\n&#123;\n    Complex c(1.2, 3.4);\n    cout &lt;&lt; (double)c &lt;&lt; endl;  &#x2F;&#x2F;输出 1.2\n    double n &#x3D; 2 + c;  &#x2F;&#x2F;等价于 double n &#x3D; 2 + c. operator double()\n    cout &lt;&lt; n;  &#x2F;&#x2F;输出 3.2\n&#125;\n重载=\n\n\n6.面向对象进阶\n拷贝构造函数\n\n深拷贝和浅拷贝\n\n转换构造函数\n\n类型转换函数\n\n四种类型转换运算符\n\n\n\n- \n\n\n\n\n\n3.标准库1.Strings lib\n基础知识\n\nstring不是一个真正的类型，而是模版类basic_string的特化形式，是一个typedef\nusing string &#x3D; std::basic_string&lt;char&gt;;  &#x2F;&#x2F; string其实是一个类型别名\nUnicode：通过一种编码方式统一处理人类语言文字，使用32位（4字节）来容纳所有汉字。但是C++的字符串中的字符是跟随C的定义，是char类型，都是单字节的无法表示Unicode。为了解决这个问题，C++98 定义了 wchar_t； C++11，为了适配 UTF-16、UTF-32，又多了 char16_t、char32_t。\nusing wstring &#x3D; std::basic_string&lt;wchar_t&gt;;\nusing u16string &#x3D; std::basic_string&lt;char16_t&gt;;\nusing u32string &#x3D; std::basic_string&lt;char32_t&gt;;\n\n\nstring\n\nstring是一个功能比较齐全的字符串类，可以提取子串、比较大小、检查长度、搜索字符等。还有size（）、begin（）、end（）、push_back（）等类似容器的操作。虽然有容器的方法，但是应该把每个字符串都看作是一个不可变的实体\n#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nint main()&#123;\n  &#x2F;&#x2F;string str &#x3D; &quot;abc&quot;;\n\t&#x2F;&#x2F;assert(str.length() &#x3D;&#x3D; 3); \n  &#x2F;&#x2F;assert(str &lt; &quot;xyz&quot;);\n  &#x2F;&#x2F;assert(str.substr(0, 1) &#x3D;&#x3D; &quot;a&quot;);\n  &#x2F;&#x2F;assert(str[1] &#x3D;&#x3D; &#39;b&#39;);\n  &#x2F;&#x2F;assert(str.find(&quot;1&quot;) &#x3D;&#x3D; string::npos);\n  &#x2F;&#x2F;assert(str + &quot;d&quot; &#x3D;&#x3D; &quot;abcd&quot;);\n  &#x2F;&#x2F;初始化方法\n  string s1;\n  string s2 &#x3D; &quot;c plus plus&quot;;\n  string s3 &#x3D; s2;\n  string s4 (5, &#39;s&#39;);\n  return 0;\n  &#x2F;&#x2F;转换为C风格的字符串，打开文件时需要\n  &#x2F;&#x2F;c_str()，该函数能够将 string 字符串转换为C风格的字符串\n  &#x2F;&#x2F;并返回该字符串的 const 指针（const char*）\n  string path &#x3D; &quot;D:\\\\demo.txt&quot;;\n  FILE *fp &#x3D; fopen(path.c_str(), &quot;rt&quot;);\n  &#x2F;&#x2F;访问字符串中的字符\n  string s &#x3D; &quot;1234567890&quot;;\n  for(int i&#x3D;0,len&#x3D;s.length(); i&lt;len; i++)&#123;\n    cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;\n  &#125;\n  &#x2F;&#x2F;字符串的拼接\n  string s1 &#x3D; &quot;first &quot;;\n  string s2 &#x3D; &quot;second &quot;;\n  char ch &#x3D; &#39;@&#39;;\n  string s3 &#x3D; s1 + s2;\n  string s4 &#x3D; s1 + ch;\n\n  &#x2F;&#x2F;C++ 提供的 string 类包含了若干实用的成员函数：\n\n  &#x2F;&#x2F;pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。\n  string&amp; insert (size_t pos, const string&amp; str);\n\n  &#x2F;&#x2F;pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。\n  string&amp; erase (size_t pos &#x3D; 0, size_t len &#x3D; npos);\n\n  &#x2F;&#x2F;pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。\n  string substr (size_t pos &#x3D; 0, size_t len &#x3D; npos) const;\n\n  &#x2F;&#x2F;第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。\n  size_t find (const string&amp; str, size_t pos &#x3D; 0) const;\n  size_t find (const char* s, size_t pos &#x3D; 0) const;\n  &#x2F;&#x2F;rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。\n  &#x2F;&#x2F;find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。\n&#125;\n使用技巧\n\n字面量后缀：C++14 为方便使用字符串，新增了一个字面量的后缀“s”，明确地表示它是 string 字符串类型，而不是 C 字符串，这就可以利用 auto 来自动类型推导，而且在其他用到字符串的地方，也可以省去声明临时字符串变量的麻烦，效率也会更高\nusing namespace std::literals::string_literals;  &#x2F;&#x2F;必须打开名字空间\n\nauto str &#x3D; &quot;std string&quot;s;      &#x2F;&#x2F; 后缀s，表示是标准字符串，直接类型推导\n\nassert(&quot;time&quot;s.size() &#x3D;&#x3D; 4);   &#x2F;&#x2F; 标准字符串可以直接调用成员函数\n原始字符串：C++11 为字面量增加了一个“原始字符串”（Raw string literal）的新表示形式，比原来的引号多了一个大写字母 R 和一对圆括号，就像下面这样。主要用于不想转义的情况\nauto str &#x3D; R&quot;(nier:automata)&quot;;    &#x2F;&#x2F; 原始字符串：nier:automata\n\nauto str1 &#x3D; R&quot;(char&quot;&quot;&#39;&#39;)&quot;;    &#x2F;&#x2F; 原样输出：char&quot;&quot;&#39;&#39;\nauto str2 &#x3D; R&quot;(\\r\\n\\t\\&quot;)&quot;;    &#x2F;&#x2F; 原样输出：\\r\\n\\t\\&quot;\nauto str3 &#x3D; R&quot;(\\\\\\$)&quot;;        &#x2F;&#x2F; 原样输出：\\\\\\$\nauto str4 &#x3D; &quot;\\\\\\\\\\\\$&quot;;         &#x2F;&#x2F; 转义后输出：\\\\\\$\n\n&#x2F;&#x2F;在圆括号的两边加上最多16个字符的特别界定符（delimiter），保证不与字符串内容发生冲突\nauto str5 &#x3D; R&quot;&#x3D;&#x3D;(R&quot;(xxx)&quot;)&#x3D;&#x3D;&quot;;&#x2F;&#x2F; 原样输出：R&quot;(xxx)&quot;\n字符串转换函数：在处理字符串的时候，我们还会经常遇到与数字互相转换的事情，以前只能用 C 函数 atoi()、atol()，它们的参数是 C 字符串而不是 string，用起来就比较麻烦，于是，C++11 就增加了几个新的转换函数：\n\nstoi()、stol()、stoll() 等把字符串转换成整数\n\nstof()、stod() 等把字符串转换成浮点数\n\nto_string() 把整数、浮点数转换成字符串。\nassert(stoi(&quot;42&quot;) &#x3D;&#x3D; 42);          &#x2F;&#x2F; 字符串转整数\nassert(stol(&quot;253&quot;) &#x3D;&#x3D; 253L);       &#x2F;&#x2F; 字符串转长整数\nassert(stod(&quot;2.0&quot;) &#x3D;&#x3D; 2.0);       &#x2F;&#x2F; 字符串转浮点数\n\nassert(to_string(1984) &#x3D;&#x3D; &quot;1984&quot;);       &#x2F;&#x2F; 整数转字符串\n\n\n字符串视图类：因为C++拷贝复制的成本太高，所以在 C++17 里有一个string_view，它是一个字符串的视图，成本很低，内部只保存一个指针和长度，无论是拷贝，还是修改，都非常廉价。在C++11中实现简化版本\nclass my_string_view final        &#x2F;&#x2F; 简单的字符串视图类，示范实现\n&#123;\npublic:\n    using this_type &#x3D; my_string_view;     &#x2F;&#x2F; 各种内部类型定义\n    using string_type &#x3D; std::string;\n    using string_ref_type &#x3D; const std::string&amp;;\n\n    using char_ptr_type &#x3D; const char*;\n    using size_type &#x3D; size_t;\nprivate:\n    char_ptr_type ptr &#x3D; nullptr;     &#x2F;&#x2F; 字符串指针\n    size_type len &#x3D; 0;               &#x2F;&#x2F; 字符串长度\npublic:\n    my_string_view() &#x3D; default;\n   ~my_string_view() &#x3D; default;\n\n    my_string_view(string_ref_type str) noexcept\n        : ptr(str.data()), len(str.length())\n    &#123;&#125;\npublic:\n    char_ptr_type data() const     &#x2F;&#x2F; 常函数，返回字符串指针\n    &#123;\n        return ptr;\n    &#125;\n\n    size_type size() const        &#x2F;&#x2F; 常函数，返回字符串长度\n    &#123;\n        return len;\n    &#125;\n&#125;;\n\n\n\n\n正则表达式\n\nstring只解决了文本的表示和存储问题，对它进行大小写转换、判断前缀后缀、模式匹配查找等更复杂的操作，标准算法因为工作对象是容器，所以不起作用，由于大部分算法都无法直接套用在字符串上，所以C++11引入了正则表达式库regex，可以利用它强大能力，来操作文本、字符串\n\n类与算法\n\nC++ 正则表达式主要有两个类\nregex：表示一个正则表达式，是 basic_regex 的特化形式\nsmatch：表示正则表达式的匹配结果，是 match_results 的特化形式\n\n\nC++ 正则匹配有三个算法，注意它们都是“只读”的，不会变动原字符串\nregex_match()：完全匹配一个字符串\nregex_search()：在字符串里查找一个正则匹配\nregex_replace()：正则查找再做替换。\n\n\n\n\n使用：用regex定义好一个表达式，然后再调用匹配算法，就可以立刻得到结果，而且最好要用原始字符串\nauto make_regex &#x3D; [](const auto&amp; txt)    &#x2F;&#x2F; 生产正则表达式\n&#123;\n    return std::regex(txt);\n&#125;;\n\nauto make_match &#x3D; []()                  &#x2F;&#x2F; 生产正则匹配结果\n&#123;\n    return std::smatch();\n&#125;;\n\nauto str &#x3D; &quot;neir:automata&quot;s;          &#x2F;&#x2F; 待匹配的字符串\nauto reg &#x3D; \n    make_regex(R&quot;(^(\\w+)\\:(\\w+)$)&quot;);  &#x2F;&#x2F; 原始字符串定义正则表达式\nauto what &#x3D; make_match();             &#x2F;&#x2F; 准备获取匹配的结果\n\nassert(regex_match(str, what, reg));  &#x2F;&#x2F; 正则匹配\n\nfor(const auto&amp; x : what) &#123;          &#x2F;&#x2F; for遍历匹配的子表达式\n    cout &lt;&lt; x &lt;&lt; &#39;,&#39;;\n&#125;\n\n\nauto str &#x3D; &quot;god of war&quot;s;             &#x2F;&#x2F; 待匹配的字符串\n\nauto reg  &#x3D; \n  make_regex(R&quot;((\\w+)\\s(\\w+))&quot;);    &#x2F;&#x2F; 原始字符串定义正则表达式\nauto what &#x3D; make_match();          &#x2F;&#x2F; 准备获取匹配的结果\n\nauto found &#x3D; regex_search(          &#x2F;&#x2F; 正则查找，和匹配类似\n                str, what, reg);\n\nassert(found);                        &#x2F;&#x2F; 断言找到匹配\nassert(!what.empty());                &#x2F;&#x2F; 断言有匹配结果\nassert(what[1] &#x3D;&#x3D; &quot;god&quot;);              &#x2F;&#x2F; 看第一个子表达式\nassert(what[2] &#x3D;&#x3D; &quot;of&quot;);              &#x2F;&#x2F; 看第二个子表达式\n\nauto new_str &#x3D; regex_replace(      &#x2F;&#x2F; 正则替换，返回新字符串\n    str,                           &#x2F;&#x2F; 原字符串不改动\n    make_regex(R&quot;(\\w+$)&quot;),         &#x2F;&#x2F; 就地生成正则表达式对象\n    &quot;peace&quot;                        &#x2F;&#x2F; 需要指定替换的文字\n);\n\ncout &lt;&lt; new_str &lt;&lt; endl;          &#x2F;&#x2F; 输出god of peace\n\n\n\n   ==Regex==\n\n\n\n\n\n\n\n\n\n功能：校验数据的有效性、查找符合要求的文本、对文本进行切割和替换等操作\n1.元字符\n概念：元字符就是指那些在正则表达式中具有特殊意义的专用字符，是构成正则表达式的基本元件，\n元字符的分类与记忆技巧\n特殊单字符\n.：表示换行以外的任意单个字符\n\\d：任意数字；\\D任意非数字\n\\w：任意字母数字下划线；\\W任意非字母数字下划线\n\\s：任意空白符；\\S任意非空白符\n\n\n空白符\n\\r：回车符\n\\n：换行符（每行文本结束位置默认的换行：Windows 里是 \\r\\n，在 Linux 和 MacOS 中是 \\n）\n\\f：换页符\n\\t：制表符\n\\v：垂直制表符\n\\s：任意空白符（常用）\n\n\n范围\n|：或，如ab|bc代表能匹配上ab，也能匹配上bc，满足其中任意一个就行\n[...]：多选一，括号中任意单个元素\n[a-z]：匹配a到z之间任意单个元素（按ASCII表，包含a，z）\n[^...]：取反，不能是括号中的任意单个元素\n\n\n量词\n*：0到多次\n+：1到多次\n?：0到1次，如colou?r，可以是color也可以是colour\n&#123;m&#125;：出现m次\n&#123;m,&#125;：出现至少m次\n&#123;m,n&#125;：出现m到n次\n\n\n断言\n\n\n\n2.量词与贪婪\n贪婪匹配：表示次数的量词默认是贪婪的，即尽可能最大长度去匹配\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r&#39;a*&#39;, &#39;aaabb&#39;) # 贪婪模式\n[&#39;aaa&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]\n\n\n示例一\n\n示例二\n\n\n\n非贪婪匹配：在量词后面加上?，就变成非贪婪模式，尽可能进行最短匹配\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r&#39;a*?&#39;, &#39;aaabb&#39;) # 非贪婪模式\n[&#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]\n\n\n示例一\n\n示例二\n\n\n\n独占模式：\n\n不管是贪婪模式还是非贪婪模式，都需要回溯才能完成相应的功能。但是独占模式不需要发生回溯，类似于贪婪模式，但是匹配失败时直接结束，不回溯。在某些环境下独占模式性能更好\n# 注意：需要先安装 regex 模块，pip install regex\n#go和python都不支持独占模式，即量词后加上+\n\n&gt;&gt;&gt; import regex\n&gt;&gt;&gt; regex.findall(r&#39;xy&#123;1,3&#125;z&#39;, &#39;xyyz&#39;)  # 贪婪模式\n[&#39;xyyz&#39;]\n&gt;&gt;&gt; regex.findall(r&#39;xy&#123;1,3&#125;+z&#39;, &#39;xyyz&#39;) # 独占模式\n[&#39;xyyz&#39;]\n&gt;&gt;&gt; regex.findall(r&#39;xy&#123;1,2&#125;+yz&#39;, &#39;xyyz&#39;) # 独占模式\n[]\n\n\n\n\n3.分组与引用\n问题：大多数正则实现中，多分支选择都是左边的优先，比如\n\n北京|北京市会把所有北京市匹配成北京市\n北京市|北京可以查找北京和北京市\n北京市?可以匹配北京和北京市，类似匹配15个数组和18个数字可以用\\d&#123;15&#125;(\\d&#123;3&#125;)?\n\n\n分组编号\n\n分组与编号：括号在正则中可以用于分组，被括号括起来的部分“子表达式”会被保存成一个子组，第几个括号就是第几个分组\n\n不保存子组：在括号里面的会保存成子组，如果后续不想复用、不想保存，通过在括号里面使用?:，不保存子组，可以提高正则性能\n\n括号嵌套：在括号嵌套的情况下，求某个括号内容是第几个分组可以通过数左括号的方式，左括号是第几个，就可以确定是第几个分组\n\n命名分组：比默认的数字编号更加容易辨识，命名分组的格式为(?P&lt;分组名&gt;正则)，示例如下（注意不是所有语言都支持）\nurl(r&#39;^profile&#x2F;(?P&lt;username&gt;\\w+)&#x2F;$&#39;, view_func)\n\n\n分组引用：通过\\number的方式来对分组进行引用\n\n\n查找：查找重复出现的部分\n\n替换：对原有内容格式进行改写\n\nPython3实现\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; test_str &#x3D; &quot;2020-05-10 20:23:05&quot;\n&gt;&gt;&gt; regex &#x3D; r&quot;((\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)) ((\\d&#123;2&#125;):(\\d&#123;2&#125;):(\\d&#123;2&#125;))&quot;\n&gt;&gt;&gt; subst &#x3D; r&quot;日期\\1 时间\\5   \\2年\\3月\\4日 \\6时\\7分\\8秒&quot;\n&gt;&gt;&gt; re.sub(regex, subst, test_str) #sub函数用于正则的替换\n&#39;日期2020-05-10 时间20:23:05   2020年05月10日 20时23分05秒&#39;\n\n\n\n4.匹配模式\n\n\n\n\n\n\n\n\n正则中一些改变元字符匹配行为的方式，比如匹配时不区分英文字母大小写，通过把模式修饰符(?模式标识)放在整个正则前面时，就表示整个正则表达式都是不区分大小写的\n\n不区分大小写模式（Case-Insensitive）\n\n正常方法：查找cat，不关心大小写：[Cc][Aa][Tt]\n\n新方法：\n\n(?i)cat：查找一个cat，不关心大小写\n(?i)(cat) \\1：可以匹配两个连续出现的cat，两次cat可以不同\n((?i)cat) \\1：可以匹配两个连续出现的cat，两次cat必须相同\n((?i)cat) cat：匹配第一个cat是不区分大小写的，第二个cat区分大小写且必须是小写\n\n\n示例\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r&quot;cat&quot;, &quot;CAT Cat cat&quot;, re.IGNORECASE)\n[&#39;CAT&#39;, &#39;Cat&#39;, &#39;cat&#39;]\n\n\n点号通配模式（Dot All）\n\n正常.只能匹配出换行符外的任意字符，相匹配上包括换行的任意字符，需要通过(?s)来使用\n示例：(?s).+可以匹配上整个文本的所有字符\n\n\n多行模式（Multiline）\n\n通常情况下，^匹配整个字符串的开头，$匹配整个字符串的结尾，多行匹配就是改变这两个符号的匹配行为\n\n通过使用(?m)来使得^和$能匹配上每行的开头和结尾\n\n\n\n注释模式（comment）\n\n在实际工作中，正则会很复杂，可以在一些关键地方加上注释，使得代码易于理解。通过(?#comment)来使用注释模式\n\n示例一\n\n示例二\n#在 x 模式下，所有的换行和空格都会被忽略，可以通过把空格放入字符组中，或将空格转义来解决\nregex &#x3D; r&#39;&#39;&#39;(?mx)\n^          # 开头\n(\\d&#123;4&#125;)    # 年\n[ ]        # 空格\n(\\d&#123;2&#125;)    # 月\n$          # 结尾\n&#39;&#39;&#39;\n\nre.findall(regex, &#39;2020 06\\n2020 07&#39;)\n# 输出结果 [(&#39;2020&#39;, &#39;06&#39;), (&#39;2020&#39;, &#39;07&#39;)]\n\n\n\n\n\n5.断言\n概念：对匹配到的文本位置有要求，比如查找tom，但其他单词如tomorrow也包含了tom\n\n断言：只用于匹配位置，而不是文本内容本身\n\n单词边界（Word Boundary）\n\n示例：将tom替换为jerry，文本：tom asked me if I would go fishing with him tomorrow.\n\n直接替换会把tomorrow也替换为jerryorrow\n\n使用\\b来表示单词的边界\n\npython代码\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; test_str &#x3D; &quot;tom asked me if I would go fishing with him tomorrow.&quot;\n&gt;&gt;&gt; re.sub(r&#39;\\btom\\b&#39;, &#39;jerry&#39;, test_str)\n&#39;jerry asked me if I would go fishing with him tomorrow.&#39;\n\n\n\n\n行的开始/结束\n\n和单词的边界类似，在正则中还有文本每行的开始和结束，如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用^和$来进行位置界定\n\n应用\n\n日志起始行判断：在收集日志的时候，通常可以指定日志行的开始规则，比如以时间开头，那些不是以时间开头的可能就是打印的堆栈信息\n\n输入数据校验\n&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.search(&#39;\\d&#123;6&#125;&#39;, &quot;1234567&quot;) is not None\nTrue    &lt;-- 能匹配上 (包含6位数字)\n&gt;&gt;&gt; re.search(&#39;^\\d&#123;6&#125;&#39;, &quot;1234567&quot;) is not None\nTrue    &lt;-- 能匹配上 (以6位数字开头)\n&gt;&gt;&gt; re.search(&#39;\\d&#123;6&#125;$&#39;, &quot;1234567&quot;) is not None\nTrue    &lt;-- 能匹配上 (以6位数字结尾)\n&gt;&gt;&gt; re.search(&#39;^\\d&#123;6&#125;$&#39;, &quot;1234567&quot;) is not None\nFalse   &lt;-- 不能匹配上 (只能是6位数字)\n&gt;&gt;&gt; re.search(&#39;^\\d&#123;6&#125;$&#39;, &quot;123456&quot;) is not None\nTrue    &lt;-- 能匹配上 (只能是6位数字)\n\n\n\n\n环视（Look Around）\n\n环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，规则助记：左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思\n\n\n示例\n\n匹配邮编，(?&lt;!\\d)\\d&#123;6&#125;(?!\\d)可以匹配左右都不是数字的6位数\n单词边界用环视表示：\\b\\w+\\b也可以写成 (?&lt;!\\w)\\w+(?!\\w)\n\n\n注意事项：环视中虽然也有括号，但不会保存成子组。保存成子组的一般是匹配到的文本内容，后续用于替换等操作，而环视是表示对文本左右环境的要求，即环视只匹配位置，不匹配文本内容。\n\n\n\n\n\n\n6.应用\n正则中的Unicode\n\n在编程语言中使用正则的时候，一定要使用Unicode编码\n\n要查看语言对字符组的支持程度，比如\\d 表示数字，\\w 表示大小写字母、下划线、数字，\\s 表示空白符号等\n\nUnicode属性：如\\p&#123;Han&#125;+可以查找连续出现的中文\n\n\n\n\n编辑器\n\n光标移动和文本选择：shift+option+左右箭头\n多焦点编辑：选中一个文本，然后通过菜单栏的find all找到所有相同的文本，同时进行相同的操作\n竖向编辑：shift+option\n使用正则：内容提取、内容替换、内容验证、内容切割\n\n\n在编程语言中\n\n校验文本内容\n\npython中，正则的包名是re，验证文本可以使用re.match或re.search的方法，这两个方法的区别在于，re.match 是从开头匹配的，re.search 是从文本中找子串\n\ngo中，正则相关的包是 regexp，示例如下\npackage main\n\nimport (\n   &quot;fmt&quot;\n   &quot;regexp&quot;\n)\n\nfunc main() &#123;\n   re :&#x3D; regexp.MustCompile(&#96;\\A\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;\\z&#96;)\n   &#x2F;&#x2F; 输出 true\n   fmt.Println(re.MatchString(&quot;2020-06-01&quot;))\n&#125;\nJavaScript中，可以直接在浏览器使用Console来使用\n&#x2F;&#x2F; 方法1\n&#x2F;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&#x2F;.test(&quot;2020-06-01&quot;)  &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 方法2\nvar regex &#x3D; &#x2F;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&#x2F;\n&quot;2020-06-01&quot;.search(regex) &#x3D;&#x3D; 0  &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 方法3\nvar regex &#x3D; new RegExp(&#x2F;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&#x2F;)\nregex.test(&quot;2020-01-01&quot;) &#x2F;&#x2F; tru\nJava中，正则相关的类在 java.util.regex 中，其中最常用的是 Pattern 和 Matcher， Pattern 是正则表达式对象，Matcher 是匹配到的结果对象，Pattern 和 字符串对象关联，可以得到一个 Matcher\nfimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Main &#123;\n  public static void main(String[] args) &#123;\n    &#x2F;&#x2F;方法1，可以不加 \\A 和 \\z\n    System.out.println(Pattern.matches(&quot;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;&quot;, &quot;2020-06-01&quot;)); &#x2F;&#x2F; true\n\n    &#x2F;&#x2F;方法2，可以不加 \\A 和 \\z\n    System.out.println(&quot;2020-06-01&quot;.matches(&quot;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;&quot;)); &#x2F;&#x2F; true\n    \n    &#x2F;&#x2F;方法3，必须加上 \\A 和 \\z\n    Pattern pattern &#x3D; Pattern.compile(&quot;\\\\A\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;\\\\z&quot;);\n    System.out.println(pattern.matcher(&quot;2020-06-01&quot;).find()); &#x2F;&#x2F; true\n  &#125;\n&#125;\n\n\n提取文本内容\n\n\n替换文本内容\n\n\n切割文本内容\n\n\n\n\n\n7.优化建议\n测试性能的方法：可以使用 ipython 来测试正则的性能\n提前编译好正则：编程语言中一般都有“编译”方法，可以使用这个方法提前将正则处理好，这样不用在每次使用的时候去反复构造自动机，从而可以提高正则匹配的性能。\n尽量准确表示匹配范围：比如我们要匹配引号里面的内容，除了写成 “.+?”之外，我们可以写成 “[^&quot;]+”。使用[^&quot;]要比使用点号好很多，虽然使用的是贪婪模式，但它不会出现点号将引号匹配上，再吐出的问题\n提取出公共部分：(abcd|abxy)这样的表达式，可以优化成ab(cd|xy)，因为 NFA 以正则为主导，会导致字符串中的某些部分重复匹配多次，影响效率\n出现可能性大的放左边：由于正则是从左到右看的，把出现概率大的放左边，域名中 .com 的使用是比 .net 多的，所以我们可以写成\\.(?:com|net)\\b，而不是\\.(?:net|com)\\b\n只在必要时才使用子组：在正则中，括号可以用于归组，但如果某部分后续不会再用到，就不需要保存成子组。通常的做法是，在写好正则后，把不需要保存子组的括号中加上 ?: 来表示只用于归组。如果保存成子组，正则引擎必须做一些额外工作来保存匹配到的内容，因为后面可能会用到，这会降低正则的匹配性能\n警惕嵌套的子组重复：如果一个组里面包含重复，接着这个组整体也可以重复，比如(.*)*这个正则，匹配的次数会呈指数级增长，所以尽量不要写这样的正则\n避免不同分支重复匹配：在多选分支选择中，要避免不同分支出现相同范围的情况，例如正则是使用 .*ab 去匹配一个比较长的字符串就更糟糕了，因为.*会吃掉整个字符串（不考虑换行，假设文本中没有换行），然后，你会发现正则中还有 ab 没匹配到内容，只能将.*匹配上的字符串吐出一个字符，再尝试，还不行，再吐出一个，不断尝试。\n\n2.Containers lib\n\n容器的通用特性\n\n容器采用的是值语义，容器里存储的是元素的拷贝、副本，而不是引用。所以操作容器的一大块成本就是值的拷贝，一个解决办法是实现转移构造和转移赋值函数，再加入容器的时候使用std::move()来转移，减少元素复制成本\nPoint p;                        &#x2F;&#x2F; 一个拷贝成本很高的对象\n\nv.push_back(p);                &#x2F;&#x2F; 存储对象，拷贝构造，成本很高\nv.push_back(std::move(p));    &#x2F;&#x2F; 定义转移构造后就可以转移存储，降低成本\n也可以使用 C++11 为容器新增加的 emplace 操作函数，它可以“就地”构造元素，免去了构造后再拷贝、转移的成本，不但高效，而且用起来也很方便\nv.emplace_back(...);            &#x2F;&#x2F; 直接在容器里构造元素，不需要拷贝或者转移\n\n\n容器的具体特性\n\n顺序容器（5种）\n\n连续存储的数组：array（静态数组）、vector（动态数组）、deque（双端队列，动态增长）\n\n指针结构的链表：list（双向链表，向前/后遍历）、forward_list（单向链表，只能向前遍历）\n\n\n\n\n有序容器（4种）\n\n主要有set、multiset、map、multimap，multi前缀代表可以容纳重复的key\n\n有序\n\n插入容器的元素按某种规则自动排序\n\n通过制定key的比较函数，来判断顺序，这个函数默认是less，表示小于关系\ntemplate&lt;\n    class T                          &#x2F;&#x2F; 模板参数只有一个元素类型\n&gt; class vector;                      &#x2F;&#x2F; vector\n\ntemplate&lt;\n    class Key,                      &#x2F;&#x2F; 模板参数是key类型，即元素类型\n    class Compare &#x3D; std::less&lt;Key&gt;  &#x2F;&#x2F; 比较函数\n&gt; class set;                        &#x2F;&#x2F; 集合\n\ntemplate&lt;\n    class Key,                      &#x2F;&#x2F; 第一个模板参数是key类型\n    class T,                        &#x2F;&#x2F; 第二个模板参数是元素类型\n    class Compare &#x3D; std::less&lt;Key&gt;  &#x2F;&#x2F; 比较函数\n&gt; class map;                        &#x2F;&#x2F; 关联数组\n类型没有默认的比较函数，就需要重载&lt;，或者自定义模版参数\nbool operator&lt;(const Point&amp; a, const Point&amp; b)\n&#123;\n    return a.x &lt; b.x;            &#x2F;&#x2F; 自定义比较运算\n&#125;\n\nset&lt;Point&gt; s;                    &#x2F;&#x2F; 现在就可以正确地放入有序容器\ns.emplace(7);\ns.emplace(3);\n\n\nset&lt;int&gt; s &#x3D; &#123;7, 3, 9&#125;;           &#x2F;&#x2F; 定义集合并初始化3个元素\n\nfor(auto&amp; x : s) &#123;                &#x2F;&#x2F; 范围循环输出元素\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;              &#x2F;&#x2F; 从小到大排序，3,7,9\n&#125;   \n\nauto comp &#x3D; [](auto a, auto b)  &#x2F;&#x2F; 定义一个lambda，用来比较大小\n&#123;   \n    return a &gt; b;                &#x2F;&#x2F; 定义大于关系\n&#125;;  \n\nset&lt;int, decltype(comp)&gt; gs(comp)  &#x2F;&#x2F; 使用decltype得到lambda的类型\n\nstd::copy(begin(s), end(s),          &#x2F;&#x2F; 拷贝算法，拷贝数据\n          inserter(gs, gs.end()));  &#x2F;&#x2F; 使用插入迭代器\n\nfor(auto&amp; x : gs) &#123;                &#x2F;&#x2F; 范围循环输出元素\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;                &#x2F;&#x2F; 从大到小排序，9,7,3\n&#125;  \n\n\n\n\n无序容器（4种）\n\n主要有unordered_set、unordered_multiset、unordered_map、unordered_multima，与有序容器区别在于内部数据结构不是红黑树而是哈希表\n无序容器虽不要求顺序，但是对key要求严苛。要求 key 具备两个条件，一是可以计算 hash 值，二是能够执行相等比较操作。\n如果只想要单纯的集合、字典，没有排序需求，就应该用无序容器，没有比较排序的成本，它的速度就会非常快\n\n\n\n\n\n3.Algorithm lib\nC++里的算法是工作在容器上的一些泛型函数，会对容器内的元素实施各种操作，比如remove（移除某个特定值）；sort（快速排序）；binary_search（执行二分查找）；make_heap（构造一个堆结构）。但是算法本质上都是for或者while循环，通过循环循环遍历来逐个处理容器里的元素。算法+lambda表达式，就可以初步体验函数式编程的感觉\nauto n &#x3D; std::count_if(      &#x2F;&#x2F; count_if算法计算元素的数量\n    begin(v), end(v),       &#x2F;&#x2F; begin()、end()获取容器的范围\n    [](auto x) &#123;            &#x2F;&#x2F; 定义一个lambda表达式\n        return x &gt; 2;       &#x2F;&#x2F; 判断条件\n    &#125;\n);                          &#x2F;&#x2F; 大函数里面套了三个小函数\n迭代器：\n\n算法只能通过迭代器取间接访问容器以及元素，算法的能力是有迭代器决定的。通过这种间接的方式，可以分离数据和操作，算法可以不关心容器的内部结构，以一致的方式去操作元素。\n\nC++里的迭代器有多种：输入迭代器、输出迭代器、双向迭代器、随机访问迭代器等。容器一般都会提供提供begin、end成员函数，调用它们就可以得到表示两个端点的迭代器\nvector&lt;int&gt; v &#x3D; &#123;1,2,3,4,5&#125;;    &#x2F;&#x2F; vector容器\n\nauto iter1 &#x3D; v.begin();        &#x2F;&#x2F; 成员函数获取迭代器，自动类型推导\nauto iter2 &#x3D; v.end();\n\n&#x2F;&#x2F;建议使用全局函数\nauto iter3 &#x3D; std::begin(v);   &#x2F;&#x2F; 全局函数获取迭代器，自动类型推导\nauto iter4 &#x3D; std::end(v);\n迭代器常用操作\n\ndistance()，计算两个迭代器之间的距离\nadvance()，前进或者后退 N 步\nnext()/prev()，计算迭代器前后的某个位置。\n\n\n\n\n常用算法：\n\n手写循环的替代品：for_each，主要是遍历容器元素和操纵容器元素\nvector&lt;int&gt; v &#x3D; &#123;3,5,1,7,10&#125;;   &#x2F;&#x2F; vector容器\n\nfor(const auto&amp; x : v) &#123;        &#x2F;&#x2F; range for循环\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n&#125;\n\nauto print &#x3D; [](const auto&amp; x)  &#x2F;&#x2F; 定义一个lambda表达式\n&#123;\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n&#125;;\nfor_each(cbegin(v), cend(v), print);&#x2F;&#x2F; for_each算法\n\nfor_each(                      &#x2F;&#x2F; for_each算法，内部定义lambda表达式\n    cbegin(v), cend(v),        &#x2F;&#x2F; 获取常量迭代器\n    [](const auto&amp; x)          &#x2F;&#x2F; 匿名lambda表达式\n    &#123;\n        cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n    &#125;\n);\n排序算法\n\n快排（sort）\nauto print &#x3D; [](const auto&amp; x)  &#x2F;&#x2F; lambda表达式输出元素\n&#123;\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n&#125;;\n\nstd::sort(begin(v), end(v));         &#x2F;&#x2F; 快速排序\nfor_each(cbegin(v), cend(v), print); &#x2F;&#x2F; for_each算法\n要求排序后仍然保持元素的相对顺序，应该用 stable_sort，它是稳定的\n\n选出前几名（TopN），应该用 partial_sort\n\n选出前几名，但不要求再排出名次（BestN），应该用 nth_element\n\n中位数（Median）、百分位数（Percentile），还是用 nth_element\n\n按照某种规则把元素划分成两组，用 partition\n\n第一名和最后一名，用 minmax_element\n&#x2F;&#x2F; top3\nstd::partial_sort(\n    begin(v), next(begin(v), 3), end(v));  &#x2F;&#x2F; 取前3名\n\n&#x2F;&#x2F; best3\nstd::nth_element(\n    begin(v), next(begin(v), 3), end(v));  &#x2F;&#x2F; 最好的3个\n\n&#x2F;&#x2F; Median\nauto mid_iter &#x3D;                            &#x2F;&#x2F; 中位数的位置\n    next(begin(v), v.size()&#x2F;2);\nstd::nth_element( begin(v), mid_iter, end(v));&#x2F;&#x2F; 排序得到中位数\ncout &lt;&lt; &quot;median is &quot; &lt;&lt; *mid_iter &lt;&lt; endl;\n    \n&#x2F;&#x2F; partition\nauto pos &#x3D; std::partition(                &#x2F;&#x2F; 找出所有大于9的数\n    begin(v), end(v),\n    [](const auto&amp; x)                    &#x2F;&#x2F; 定义一个lambda表达式\n    &#123;\n        return x &gt; 9;\n    &#125;\n); \nfor_each(begin(v), pos, print);         &#x2F;&#x2F; 输出分组后的数据  \n\n&#x2F;&#x2F; min&#x2F;max\nauto value &#x3D; std::minmax_element(        &#x2F;&#x2F;找出第一名和倒数第一\n    cbegin(v), cend(v)\n);\n\n\n查找算法\n\nbinary_search，二分查找，缺点是只返回一个bool值\nvector&lt;int&gt; v &#x3D; &#123;3,5,1,7,10,99,42&#125;;  &#x2F;&#x2F; vector容器\nstd::sort(begin(v), end(v));        &#x2F;&#x2F; 快速排序\n\nauto found &#x3D; binary_search(         &#x2F;&#x2F; 二分查找，只能确定元素在不在\n    cbegin(v), cend(v), 7\n); \n在已序容器上执行二分查找，要用到一个名字比较怪的算法：lower_bound，它返回第一个“大于或等于”值的位置\ndecltype(cend(v)) pos;            &#x2F;&#x2F; 声明一个迭代器，使用decltype\n\npos &#x3D; std::lower_bound(          &#x2F;&#x2F; 找到第一个&gt;&#x3D;7的位置\n    cbegin(v), cend(v), 7\n);  \nfound &#x3D; (pos !&#x3D; cend(v)) &amp;&amp; (*pos &#x3D;&#x3D; 7); &#x2F;&#x2F; 可能找不到，所以必须要判断\nassert(found);                          &#x2F;&#x2F; 7在容器里\n\npos &#x3D; std::lower_bound(               &#x2F;&#x2F; 找到第一个&gt;&#x3D;9的位置\n    cbegin(v), cend(v), 9\n);  \nfound &#x3D; (pos !&#x3D; cend(v)) &amp;&amp; (*pos &#x3D;&#x3D; 9); &#x2F;&#x2F; 可能找不到，所以必须要判断\nassert(!found);                          &#x2F;&#x2F; 9不在容器里c\nupper_bound，返回的是第一个“大于”值的元素。\npos &#x3D; std::upper_bound(             &#x2F;&#x2F; 找到第一个&gt;9的位置\n    cbegin(v), cend(v), 9\n);\nfind：与binary_search不同，返回值是迭代器\nmultiset&lt;int&gt; s &#x3D; &#123;3,5,1,7,7,7,10,99,42&#125;;  &#x2F;&#x2F; multiset，允许重复\n\nauto pos &#x3D; s.find(7);                      &#x2F;&#x2F; 二分查找，返回迭代器\nassert(pos !&#x3D; s.end());                   &#x2F;&#x2F; 与end()比较才能知道是否找到\n\nauto lower_pos &#x3D; s.lower_bound(7);       &#x2F;&#x2F; 获取区间的左端点\nauto upper_pos &#x3D; s.upper_bound(7);       &#x2F;&#x2F; 获取区间的右端点\n\nfor_each(                                &#x2F;&#x2F; for_each算法\n    lower_pos, upper_pos, print          &#x2F;&#x2F; 输出7,7,7\n);\n其他算法\nvector&lt;int&gt; v &#x3D; &#123;1,9,11,3,5,7&#125;;  &#x2F;&#x2F; vector容器\n\ndecltype(v.end()) pos;          &#x2F;&#x2F; 声明一个迭代器，使用decltype\n\npos &#x3D; std::find(                 &#x2F;&#x2F; 查找算法，找到第一个出现的位置\n    begin(v), end(v), 3\n);  \nassert(pos !&#x3D; end(v));         &#x2F;&#x2F; 与end()比较才能知道是否找到\n\npos &#x3D; std::find_if(            &#x2F;&#x2F; 查找算法，用lambda判断条件\n    begin(v), end(v),\n    [](auto x) &#123;              &#x2F;&#x2F; 定义一个lambda表达式\n        return x % 2 &#x3D;&#x3D; 0;    &#x2F;&#x2F; 判断是否偶数\n    &#125;\n);  \nassert(pos &#x3D;&#x3D; end(v));        &#x2F;&#x2F; 与end()比较才能知道是否找到\n\narray&lt;int, 2&gt; arr &#x3D; &#123;3,5&#125;;    &#x2F;&#x2F; array容器\npos &#x3D; std::find_first_of(      &#x2F;&#x2F; 查找一个子区间\n    begin(v), end(v),\n    begin(arr), end(arr)\n);  \nassert(pos !&#x3D; end(v));       &#x2F;&#x2F; 与end()比较才能知道是否找到\n\n\n\n\n\n4.Concurrency lib\n线程和多线程，在C++里，线程就是一个能独立运行的函数，比如一个lambda函数。读而不写就不会有数据竞争，所以尽可能让操作都是只读的\nauto f &#x3D; []()                &#x2F;&#x2F; 定义一个lambda表达式\n&#123;\n    cout &lt;&lt; &quot;tid&#x3D;&quot; &lt;&lt;\n        this_thread::get_id() &lt;&lt; endl;\n&#125;;\n\nthread t(f);                &#x2F;&#x2F; 启动一个线程，运行函数f\n多线程开发实践\n\n仅调用一次：用于控制仅初始化一次数据，声明一个once_flag类型的变量，最好是静态的、全局的，作为初始化的标志然后调用专门的call_once函数来传递这个标志，和初始化函数\nstatic std::once_flag flag;        &#x2F;&#x2F; 全局的初始化标志\n\nauto f &#x3D; []()                &#x2F;&#x2F; 在线程里运行的lambda表达式\n&#123;   \n    std::call_once(flag,      &#x2F;&#x2F; 仅一次调用，注意要传flag\n        []()&#123;                &#x2F;&#x2F; 匿名lambda，初始化函数，只会执行一次\n            cout &lt;&lt; &quot;only once&quot; &lt;&lt; endl;\n        &#125;                  &#x2F;&#x2F; 匿名lambda结束\n    );                     &#x2F;&#x2F; 在线程里运行的lambda表达式结束\n&#125;;\n\nthread t1(f);            &#x2F;&#x2F; 启动两个线程，运行函数f\nthread t2(f);\n线程局部存储：读写全局（或局部静态）变量是另一个比较常见的数据竞争场景，但是有时候并不一定是必须共享的，应该是线程局部存储的，通过thread_local实现，它是一个和extern、static同级的变量存储说明\nthread_local int n &#x3D; 0;        &#x2F;&#x2F; 线程局部存储变量，如果是static就会被加两次\n\nauto f &#x3D; [&amp;](int x)           &#x2F;&#x2F; 在线程里运行的lambda表达式，捕获引用\n&#123;   \n    n +&#x3D; x;                   &#x2F;&#x2F; 使用线程局部变量，互不影响\n    cout &lt;&lt; n;                &#x2F;&#x2F; 输出，验证结果\n&#125;;  \n\nthread t1(f, 10);           &#x2F;&#x2F; 启动两个线程，运行函数f\nthread t2(f, 20);\n原子变量：\n\n对于非独占、必须共享的数据，通过互斥量或原子化来解决。目前C++只能让一些最基本的类型原子化，比如atomic_int、atomic_long，他们都是atomic的特化形式，包装了原始的类型，具有相同的结构。原子变量禁用了拷贝构造函数，所以在初始化的时候不能用“=”的赋值形式，只能用圆括号或者花括号。\nusing atomic_bool &#x3D; std::atomic&lt;bool&gt;;    &#x2F;&#x2F; 原子化的bool\nusing atomic_int  &#x3D; std::atomic&lt;int&gt;;      &#x2F;&#x2F; 原子化的int\nusing atomic_long &#x3D; std::atomic&lt;long&gt;;    &#x2F;&#x2F; 原子化的long\n\n\natomic_int  x &#123;0&#125;;          &#x2F;&#x2F; 初始化，不能用&#x3D;\natomic_long y &#123;1000L&#125;;      &#x2F;&#x2F; 初始化，只能用圆括号或者花括号\n\nassert(++x &#x3D;&#x3D; 1);           &#x2F;&#x2F; 自增运算\n\ny +&#x3D; 200;                   &#x2F;&#x2F; 加法运算\nassert(y &lt; 2000);           &#x2F;&#x2F; 比较运算 \n除了模拟整数运算，原子变量还有一些特殊的原子操作，比如 store、load、fetch_add、fetch_sub、exchange、compare_exchange_weak/compare_exchange_strong，最后一组就是著名的 CAS（Compare And Swap）操作。\n\n而另一个同样著名的 TAS（Test And Set）操作，则需要用到一个特殊的原子类型 atomic_flag。它不是简单的 bool 特化（atomic），没有 store、load 的操作，只用来实现 TAS，保证绝对无锁。\n\n\n\n线程对象：\n\nC++ 标准库里有专门的线程类 thread，使用它就可以简单地创建线程，在名字空间 std::this_thread 里，还有 yield()、get_id()、sleep_for()、sleep_until() 等几个方便的管理函数。\nstatic atomic_flag flag &#123;false&#125;;    &#x2F;&#x2F; 原子化的标志量\nstatic atomic_int  n;               &#x2F;&#x2F; 原子化的int\n\nauto f &#x3D; [&amp;]()              &#x2F;&#x2F; 在线程里运行的lambda表达式，捕获引用\n&#123;\n    auto value &#x3D; flag.test_and_set();  &#x2F;&#x2F; TAS检查原子标志量\n\n    if (value) &#123;\n        cout &lt;&lt; &quot;flag has been set.&quot; &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; &quot;set flag by &quot; &lt;&lt;\n            this_thread::get_id() &lt;&lt; endl;  &#x2F;&#x2F; 输出线程id\n    &#125;\n\n    n +&#x3D; 100;                    &#x2F;&#x2F; 原子变量加法运算\n\n    this_thread::sleep_for(      &#x2F;&#x2F; 线程睡眠\n        n.load() * 10ms);        &#x2F;&#x2F; 使用时间字面量\n    cout &lt;&lt; n &lt;&lt; endl;\n&#125;;                        &#x2F;&#x2F; 在线程里运行的lambda表达式结束\n\nthread t1(f);                &#x2F;&#x2F; 启动两个线程，运行函数f\nthread t2(f);\n\nt1.join();                   &#x2F;&#x2F; 等待线程结束    \nt2.join();\nasync：异步运行一个任务，隐含的动作是启动一个线程去执行，但不绝对保证立即启动（也可以在第一个参数传递 std::launch::async，要求立即启动线程）。大多数 thread 能做的事情也可以用 async() 来实现，但不会看到明显的线程（如果你不显式获取 async() 的返回值（即 future 对象），它就会同步阻塞直至任务完成（由于临时对象的析构函数））\nauto task &#x3D; [](auto x)                  &#x2F;&#x2F; 在线程里运行的lambda表达式\n&#123;\n    this_thread::sleep_for( x * 1ms);  &#x2F;&#x2F; 线程睡眠\n    cout &lt;&lt; &quot;sleep for &quot; &lt;&lt; x &lt;&lt; endl;\n    return x;\n&#125;;\n\nauto f &#x3D; std::async(task, 10);         &#x2F;&#x2F; 启动一个异步任务\nf.wait();                              &#x2F;&#x2F; 等待任务完成\n\nassert(f.valid());                    &#x2F;&#x2F; 确实已经完成了任务\ncout &lt;&lt; f.get() &lt;&lt; endl;              &#x2F;&#x2F; 获取任务的执行结果\n\n\nstd::async(task, ...);            &#x2F;&#x2F; 没有显式获取future，被同步阻塞\nauto f &#x3D; std::async(task, ...);   &#x2F;&#x2F; 只有上一个任务完成后才能被执行\n\n\n\n\n\n5.General util lib\noptional（C++17）\n\n原先C++函数只能返回一个值，而且必须是可用的，但是有时候如果执行不成功，就不一定能够返回有意义的值，比如内存空间不足，创建对象失败、模式字符串不存在等等，这个时候函数的返回值就回事无效的。往往使用-1、抛出异常等方法\n\n此时需要一种简单的、轻量级的概念，能够表示任何的无效值，即模版类optional。optional可以近似地看做是只能容纳一个元素的特殊容器，而这样的容器就会有是否持有元素的两种状态，即空和非空，恰好对应无效和有效。optional对象默认是空的，也就是处于无效状态，给它赋值后因为有了元素，就变成了有效状态。\noptional&lt;int&gt; op;             &#x2F;&#x2F; 持有int的optional对象\nassert(!op.has_value());         &#x2F;&#x2F; 默认是无效值\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nop &#x3D; 10;                 &#x2F;&#x2F; 赋值，持有有效值\nif (op.has_value()) &#123;          &#x2F;&#x2F; 判断是否有效\n  cout &lt;&lt; &quot;value is valid&quot; &lt;&lt; endl;\n&#125; \n\n\noptional op &#123;&quot;zelda&quot;&#125;; &#x2F;&#x2F; 持有string的optional对象\nassert(op); &#x2F;&#x2F; 可以像指针一样bool判断\nassert(!op-&gt;empty() &amp;&amp; *op &#x3D;&#x3D; &quot;zelda&quot;); &#x2F;&#x2F; 使用*&#x2F;-&gt;访问内部的值\n\nop.reset(); &#x2F;&#x2F; 清空内部的值\nassert(!op); &#x2F;&#x2F; 此时是无效值\n\n&#x2F;&#x2F;即使不提供初始化参数，它也必定会用“零值”创建出一个有效值的 optional 对象\nauto op1 &#x3D; make_optional&lt;int&gt;();    &#x2F;&#x2F; 使用默认值构造有效值\nauto op2 &#x3D; make_optional&lt;string&gt;();    &#x2F;&#x2F; 使用默认值构造有效值\n\nassert(op1 &amp;&amp; op2);           &#x2F;&#x2F; make_optional总是有效的\nassert(op1 &#x3D;&#x3D; 0);             &#x2F;&#x2F; 值是默认的0\nassert(op2-&gt;empty());          &#x2F;&#x2F; 值是空字符串\n\nauto op3 &#x3D; make_optional&lt;string&gt;(&quot;hi&quot;);      &#x2F;&#x2F; 带参数创建optional\nauto op4 &#x3D; make_optional&lt;vector&lt;int&gt;&gt;(&#123;1,2,3&#125;);  &#x2F;&#x2F; 带参数创建optional\n\nassert(op3-&gt;size() &#x3D;&#x3D; 2);\nassert(op4-&gt;at(0) &#x3D;&#x3D; 1);\n使用示例\nauto safe_sqrt &#x3D; [](double x) &#123;      &#x2F;&#x2F; lambda表达式开平方\n  optional&lt;double&gt; v;         &#x2F;&#x2F; 默认是无效值\n\n  if (x &lt; 0) &#123;            &#x2F;&#x2F; 负数无法求平方根\n    return v;             &#x2F;&#x2F; 返回无效值\n  &#125;\n\n  v  &#x3D; ::sqrt(x);           &#x2F;&#x2F; 正数平方根有效\n  return v;               &#x2F;&#x2F; 返回有效值\n&#125;;\n\nassert(!safe_sqrt(-1));         &#x2F;&#x2F; 负数无法求平方根\nassert(safe_sqrt(9).value() &#x3D;&#x3D; 3);     &#x2F;&#x2F; 正数平方根有效\n\n&#x2F;&#x2F;当它内部持有的是 bool 类型的时候，由于它本身可以转型成 bool，但含义是值的有效性，而并非内部的 bool 真假\noptional&lt;bool&gt; op &#123;false&#125;;         &#x2F;&#x2F; 持有bool的optional对象\n\nif (op) &#123;                &#x2F;&#x2F; 错误用法，实际上判断的是有效性\n    cout &lt;&lt; &quot;misuse&quot; &lt;&lt; endl;\n&#125;\n\nif (op &amp;&amp; op.value()) &#123;          &#x2F;&#x2F; 正确用法，有效后再检查值\n    cout &lt;&lt; &quot; right &quot; &lt;&lt; endl;\n&#125;\n\n\nvariant（C++17）\n\n类似一个智能union，能够聚合任意类型，没有任何限制，使用起来又和union几乎一样方便。如果以容器的视角来看，就像是只容纳一个元素的异质容器，里面存放的具体类型是不确定的，想知道是哪种元素必须调用index函数，它会返回当前元素在模版参数列表里的索引\nvariant&lt;int, float, double&gt; v;       &#x2F;&#x2F; 可以容纳三种不同的整数\n\nv &#x3D; 42;                 &#x2F;&#x2F; 直接赋值为int\nassert(v.index() &#x3D;&#x3D; 0);         &#x2F;&#x2F; 索引号是0\n\nv &#x3D; 3.14f;                 &#x2F;&#x2F; 直接赋值为float\nassert(v.index() &#x3D;&#x3D; 1);         &#x2F;&#x2F; 索引号是1\n\nv &#x3D; 2.718;                 &#x2F;&#x2F; 直接赋值为double\nassert(v.index() &#x3D;&#x3D; 2);         &#x2F;&#x2F; 索引号是2\n因为 variant 需要存储任意类型，内部结构比较复杂，所以 variant 不能像 union 那样用成员变量的形式来访问内部的值，必须要用外部的函数 get() 来获取值。get() 是一个比较特别的模板函数，调用时必须在函数名后加上模板的尖括号，里面的模板参数可以是类型名或者是索引号\nv &#x3D; 42;               &#x2F;&#x2F; 赋值为int\nassert(get&lt;0&gt;(v) &#x3D;&#x3D; 42);       &#x2F;&#x2F; 取第0号的值，即int\n\nv &#x3D; 2.718;               &#x2F;&#x2F; 赋值为double\nauto x &#x3D; get&lt;double&gt;(v);       &#x2F;&#x2F; 取double的值，即第2号\n\nget&lt;int&gt;(v);             &#x2F;&#x2F; 当前是double，所以出错，抛出异常\nget() 访问了不存在的值就会出错，C++ 会以抛出异常的方式来告知调用者。不过抛出异常的方式不太友好，try-catch 处理起来比较麻烦，所以我们还可以用另一个模板函数 get_if()，它以指针的方式返回 variant 内部的值，如果不存在就是 nullptr，这样用起来就比较轻松了：\nauto p &#x3D; get_if&lt;int&gt;(&amp;v);       &#x2F;&#x2F; 取int的值，不存在就是空指针\nassert(p &#x3D;&#x3D; nullptr);\n\n\n\n6.Memory  lib4.开源库1.序列化\n\n\n\n\n\n\n\n\n序列化，就是把内存里“活的对象”转换成静止的字节序列，便于存储和网络传输；而反序列化则是反向操作，从静止的字节序列重新构建出内存里可用的对象\n\nJSON\n\n起源于最流行的脚本语言JavaScript，在Web领域应用广泛\n\nhttps://github.com/nlohmann/json\n\n使用\nusing json_t &#x3D; nlohmann::json;\n\njson_t j;                                   &#x2F;&#x2F; JSON对象\n\nj[&quot;age&quot;] &#x3D; 23;                              &#x2F;&#x2F; &quot;age&quot;:23\nj[&quot;name&quot;] &#x3D; &quot;spiderman&quot;;                    &#x2F;&#x2F; &quot;name&quot;:&quot;spiderman&quot;\nj[&quot;gear&quot;][&quot;suits&quot;] &#x3D; &quot;2099&quot;;                &#x2F;&#x2F; &quot;gear&quot;:&#123;&quot;suits&quot;:&quot;2099&quot;&#125;\nj[&quot;jobs&quot;] &#x3D; &#123;&quot;superhero&quot;&#125;;                  &#x2F;&#x2F; &quot;jobs&quot;:[&quot;superhero&quot;]  \n\nvector&lt;int&gt; v &#x3D; &#123;1,2,3&#125;;                   &#x2F;&#x2F; vector容器\nj[&quot;numbers&quot;] &#x3D; v;                          &#x2F;&#x2F; &quot;numbers&quot;:[1,2,3]\n\nmap&lt;string, int&gt; m &#x3D;                       &#x2F;&#x2F; map容器\n    &#123;&#123;&quot;one&quot;,1&#125;, &#123;&quot;two&quot;, 2&#125;&#125;;               &#x2F;&#x2F; 初始化列表 \nj[&quot;kv&quot;] &#x3D; m;                               &#x2F;&#x2F; &quot;kv&quot;:&#123;&quot;one&quot;:1,&quot;two&quot;:2&#125;\n\n&#x2F;&#x2F;序列化\ncout &lt;&lt; j.dump() &lt;&lt; endl;         &#x2F;&#x2F; 序列化，无缩进\ncout &lt;&lt; j.dump(2) &lt;&lt; endl;        &#x2F;&#x2F; 序列化，有缩进，2个空格\n\n&#x2F;&#x2F;反序列化\nstring str &#x3D; R&quot;(&#123;                \n    &quot;name&quot;: &quot;peter&quot;,\n    &quot;age&quot; : 23,\n    &quot;married&quot; : true\n&#125;)&quot;;\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; JSON文本，原始字符串\n\nauto j &#x3D; json_t::parse(str);    &#x2F;&#x2F; 从字符串反序列化\nassert(j[&quot;age&quot;] &#x3D;&#x3D; 23);        &#x2F;&#x2F; 验证序列化是否正确\nassert(j[&quot;name&quot;] &#x3D;&#x3D; &quot;peter&quot;);\n\n&#x2F;&#x2F;使用异常来处理可能发生的错误\nauto txt &#x3D; &quot;bad:data&quot;s;        &#x2F;&#x2F; 不是正确的JSON数据\n\ntry                             &#x2F;&#x2F; try保护代码\n&#123;\n    auto j &#x3D; json_t::parse(txt);&#x2F;&#x2F; 从字符串反序列化\n&#125;\ncatch(std::exception&amp; e)        &#x2F;&#x2F; 捕获异常\n&#123;\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n&#125;\n\n\nMessagePack\n\n一种轻量级的数据交换格式，比JSON更小巧，处理起来更快，不是纯文本的而是二进制的\n\n\nProtoBuffer\n\n简称PB，由Google出品，PB 也是一种二进制的数据格式，但毕竟是工业级产品，所以没有 JSON 和 MessagePack 那么“轻”，相关的东西比较多，要安装一个预处理器和开发库，编译时还要链接动态库（-lprotobuf）：\napt-get install protobuf-compiler\napt-get install libprotobuf-dev\n\ng++ protobuf.cpp -std&#x3D;c++14 -lprotobuf -o a.out\nPB 的另一个特点是数据有“模式”（schema），必须要先写一个 IDL（Interface Description Language）文件，在里面定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。\nsyntax &#x3D; &quot;proto2&quot;;                    &#x2F;&#x2F; 使用第2版\n\npackage sample;                        &#x2F;&#x2F; 定义名字空间\n\nmessage Vendor                        &#x2F;&#x2F; 定义消息\n&#123;\n    required uint32     id      &#x3D; 1;  &#x2F;&#x2F; required表示必须字段\n    required string     name    &#x3D; 2;  &#x2F;&#x2F; 有int32&#x2F;string等基本类型\n    required bool       valid   &#x3D; 3;  &#x2F;&#x2F; 需要指定字段的序号，序列化时用\n    optional string     tel     &#x3D; 4;  &#x2F;&#x2F; optional字段可以没有\n&#125;\n有了接口定义文件，需要再用 protoc 工具生成对应的 C++ 源码，然后把源码文件加入自己的项目中，就可以使用了：\nprotoc --cpp_out&#x3D;. sample.proto       &#x2F;&#x2F; 生成C++代码\n重要接口\n\n字段名会生成对应的 has/set 函数，检查是否存在和设置值\nIsInitialized() 检查数据是否完整（required 字段必须有值）\nDebugString() 输出数据的可读字符串描述\nByteSize() 返回序列化数据的长度\nSerializeToString() 从对象序列化到字符串\nParseFromString() 从字符串反序列化到对象\nSerializeToArray()/ParseFromArray() 序列化的目标是字节数组\n\n\n示例\nusing vendor_t &#x3D; sample::Vendor;        &#x2F;&#x2F; 类型别名\n\nvendor_t v;                             &#x2F;&#x2F; 声明一个PB对象\nassert(!v.IsInitialized());            &#x2F;&#x2F; required等字段未初始化\n\nv.set_id(1);                            &#x2F;&#x2F; 设置每个字段的值    \nv.set_name(&quot;sony&quot;);\nv.set_valid(true);\n\nassert(v.IsInitialized());             &#x2F;&#x2F; required等字段都设置了，数据完整\nassert(v.has_id() &amp;&amp; v.id() &#x3D;&#x3D; 1); \nassert(v.has_name() &amp;&amp; v.name() &#x3D;&#x3D; &quot;sony&quot;);\nassert(v.has_valid() &amp;&amp; v.valid());\n\ncout &lt;&lt; v.DebugString() &lt;&lt; endl;       &#x2F;&#x2F; 输出调试字符串\n\nstring enc;\nv.SerializeToString(&amp;enc);              &#x2F;&#x2F; 序列化到字符串 \n\nvendor_t v2; \nassert(!v2.IsInitialized());\nv2.ParseFromString(enc);               &#x2F;&#x2F; 反序列化\n\n\n\n2.网络通信\n\n\n\n\n\n\n\n\n原生的Socket API非常底层，要考虑很多细节，比如 TIME_WAIT、CLOSE_WAIT、REUSEADDR 等，如果再加上异步就更复杂了\n\nlibcurl：原子curl项目，高移植、功能丰富的通信库，用户包括Apple、Facebook、Google、Netflix\n\n纯C语言写的，兼容性、可移植性非常好。支持很多协议，但最常用的是HTTP协议\n\nlibcurl 的接口可以粗略地分成两大类：easy 系列和 multi 系列。其中，easy 系列是同步调用，比较简单；multi 系列是异步的多线程调用，比较复杂。通常情况下，我们用 easy 系列就足够了\n\n使用 libcurl 收发 HTTP 数据的基本步骤有 4 个：\n\n使用 curl_easy_init() 创建一个句柄，类型是 CURL*。但我们完全没有必要关心句柄的类型，直接用 auto 推导就行\n\n使用 curl_easy_setopt() 设置请求的各种参数，比如请求方法、URL、header/body 数据、超时、回调函数等（最关键的操作）\n\n使用 curl_easy_perform() 发送数据，返回的数据会由回调函数处理\n\n使用 curl_easy_cleanup() 清理句柄相关的资源，结束会话\n#include &lt;curl&#x2F;curl.h&gt;               &#x2F;&#x2F; 包含头文件\n\nauto curl &#x3D; curl_easy_init();        &#x2F;&#x2F; 创建CURL句柄\nassert(curl);\n\ncurl_easy_setopt(curl, CURLOPT_URL, &quot;http:&#x2F;&#x2F;nginx.org&quot;); &#x2F;&#x2F; 设置请求URI\n\nauto res &#x3D; curl_easy_perform(curl);   &#x2F;&#x2F; 发送数据\nif (res !&#x3D; CURLE_OK) &#123;                &#x2F;&#x2F; 检查是否执行成功\n    cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl;\n&#125;\n\ncurl_easy_cleanup(curl);             &#x2F;&#x2F; 清理句柄相关的资源\n\n\n\n\ncpr：更现代、更通用的通信库\n\ncpr是对libcurl的一个C++11封装\n\n示例\nconst auto url &#x3D; &quot;http:&#x2F;&#x2F;openresty.org&quot;s;  &#x2F;&#x2F; 访问的URL\n\nauto res1 &#x3D; cpr::Head(                    &#x2F;&#x2F; 发送HEAD请求\n            cpr::Url&#123;url&#125;                 &#x2F;&#x2F; 传递URL\n);\n\nauto res2 &#x3D; cpr::Get(                     &#x2F;&#x2F; 发送GET请求\n            cpr::Url&#123;url&#125;,               &#x2F;&#x2F; 传递URL\n            cpr::Parameters&#123;             &#x2F;&#x2F; 传递URL参数\n                &#123;&quot;a&quot;, &quot;1&quot;&#125;, &#123;&quot;b&quot;, &quot;2&quot;&#125;&#125;\n);\n\nauto res3 &#x3D; cpr::Post(                  &#x2F;&#x2F; 发送POST请求\n            cpr::Url&#123;url&#125;,             &#x2F;&#x2F; 传递URL\n            cpr::Header&#123;                &#x2F;&#x2F; 定制请求头字段\n              &#123;&quot;x&quot;, &quot;xxx&quot;&#125;,&#123;&quot;expect&quot;,&quot;&quot;&#125;&#125;,\n            cpr::Body&#123;&quot;post data&quot;&#125;,    &#x2F;&#x2F; 传递body数据\n            cpr::Timeout&#123;200ms&#125;       &#x2F;&#x2F; 超时时间\n);\n\n\nZMQ：高效、快速、多功能的通信库\n\nlibcurl和cpr处理的都是HTTP协议，需要更底层更灵活的网络通信工具。ZeroMQ（Zero Message Queue）不仅是一个单纯的网络通信库，更像是一个高级的异步并发框架\n定义了5种工作模式\n原生模式（RAW），没有消息队列功能，相当于底层 Socket 的简单封装\n结对模式（PAIR），两个端点一对一通信\n请求响应模式（REQ-REP），也是两个端点一对一通信，但请求必须有响应\n发布订阅模式（PUB-SUB），一对多通信，一个端点发布消息，多个端点接收处理\n管道模式（PUSH-PULL），或者叫流水线，可以一对多，也可以多对一\n\n\n\n\n\n3.I/O及文件操作\n输入输出流\n\ncin\n\ncout、cerr、clog\n\ncout支持重定向到文件\ncerr不设缓冲区，否则需要\\n和endl刷新缓冲区\n\n\n无论是使用 cout 输出普通数据，用 cout.put() 输出指定字符，还是用 cout.write() 输出指定字符串，数据都会先放到输出流缓冲区，待缓冲区刷新，数据才会输出到指定位置（屏幕或者文件中）。值得一提的是，当数据暂存于输出流缓冲区中时，我们仍可以对其进行修改。ostream 类中提供有 tellp() 和 seekp() 成员方法，借助它们就可以修改位于输出流缓冲区中的数据。\n#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    double a &#x3D; 1.23;\n    &#x2F;&#x2F;设定后续输出的浮点数的精度为 4\n    cout.precision(4);\n    cout &lt;&lt;&quot;precision: &quot;&lt;&lt; a &lt;&lt; endl;\n    &#x2F;&#x2F;设定后续以科学计数法的方式输出浮点数\n    cout.setf(ios::scientific);\n    cout &lt;&lt;&quot;scientific：&quot;&lt;&lt; a &lt;&lt; endl;\n    return 0;\n&#125;\n\n\n文件操作\n\n文件的打开\n\nvoid open(const char* szFileName, int mode),第一个参数是指向文件名的指针，第二个参数是文件的打开模式标记。\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main() &#123;\n    const char *url &#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;;\n    &#x2F;&#x2F;创建一个 fstream 类对象\n    fstream fs;\n    &#x2F;&#x2F;将 test.txt 文件和 fs 文件流关联\n    fs.open(&quot;test.txt&quot;, ios::out);\n    &#x2F;&#x2F;向test.txt文件中写入 url 字符串\n    fs.write(url, 30);\n    fs.close();\n    return 0;\n&#125;\n文件打开模式标记\n\n\n\n文件的关闭close()\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    const char *url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;;\n    ofstream outFile(&quot;url.txt&quot;, ios::out);\n    &#x2F;&#x2F;向 url.txt 文件中写入字符串\n    outFile.write(url, 30);\n    &#x2F;&#x2F;关闭已打开的文件\n    outFile.close();\n    return 0;\n&#125;\n文件的读写\n\n&gt;&gt;和&lt;&lt;读写文本文件\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    int x,sum&#x3D;0;\n    ifstream srcFile(&quot;in.txt&quot;, ios::in); &#x2F;&#x2F;以文本模式打开in.txt备读\n    if (!srcFile) &#123; &#x2F;&#x2F;打开失败\n        cout &lt;&lt; &quot;error opening source file.&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    ofstream destFile(&quot;out.txt&quot;, ios::out); &#x2F;&#x2F;以文本模式打开out.txt备写\n    if (!destFile) &#123;\n        srcFile.close(); &#x2F;&#x2F;程序结束前不能忘记关闭以前打开过的文件\n        cout &lt;&lt; &quot;error opening destination file.&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    &#x2F;&#x2F;可以像用cin那样用ifstream对象\n    while (srcFile &gt;&gt; x) &#123;\n        sum +&#x3D; x;\n        &#x2F;&#x2F;可以像 cout 那样使用 ofstream 对象\n        destFile &lt;&lt; x &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; &quot;sum：&quot; &lt;&lt; sum &lt;&lt; endl;\n    destFile.close();\n    srcFile.close();\n    return 0;\n&#125;\nread()和write()读写二进制文件\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nclass CStudent\n&#123;\npublic:\n    char szName[20];\n    int age;\n&#125;;\nint main()\n&#123;\n    &#x2F;&#x2F;读\n    CStudent s;\n    ofstream outFile(&quot;students.dat&quot;, ios::out | ios::binary);\n    while (cin &gt;&gt; s.szName &gt;&gt; s.age)\n        outFile.write((char*)&amp;s, sizeof(s));\n    outFile.close();\n    &#x2F;&#x2F;return 0;\n    &#x2F;&#x2F;写\n    CStudent s;       \n    ifstream inFile(&quot;students.dat&quot;,ios::in|ios::binary); &#x2F;&#x2F;二进制读方式打开\n    if(!inFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt;endl;\n        return 0;\n    &#125;\n    while(inFile.read((char *)&amp;s, sizeof(s))) &#123; &#x2F;&#x2F;一直读到文件结束\n        cout &lt;&lt; s.szName &lt;&lt; &quot; &quot; &lt;&lt; s.age &lt;&lt; endl;   \n    &#125;\n    inFile.close();\n    return 0;\n&#125;\nget()和put()读写文件\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    char c;\n    &#x2F;&#x2F;以二进制形式打开文件\n    ofstream outFile(&quot;out.txt&quot;, ios::out | ios::binary);\n    if (!outFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (cin &gt;&gt; c) &#123;\n        &#x2F;&#x2F;将字符 c 写入 out.txt 文件\n        outFile.put(c);\n    &#125;\n    outFile.close();\n    return 0;\n&#125;\n\n\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    char c;\n    &#x2F;&#x2F;以二进制形式打开文件\n    ifstream inFile(&quot;out.txt&quot;, ios::out | ios::binary);\n    if (!inFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while ( (c&#x3D;inFile.get())&amp;&amp;c!&#x3D;EOF )   &#x2F;&#x2F;或者 while(inFile.get(c))，对应第二种语法格式\n    &#123;\n        cout &lt;&lt; c ;\n    &#125;\n    inFile.close();\n    return 0;\n&#125;\ngetline()从文件读取一行字符串\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    char c[40];\n    ifstream inFile(&quot;in.txt&quot;, ios::in | ios::binary);\n    if (!inFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    &#x2F;&#x2F;连续以行为单位，读取 in.txt 文件中的数据\n    while (inFile.getline(c, 40)) &#123;\n        cout &lt;&lt; c &lt;&lt; endl;\n    &#125;\n    inFile.close();\n    return 0;\n&#125;\n\n\n\n\n\n4.性能分析\n系统级工具\n\ntop：无论开发什么样的应用程序， top 命令能够简单直观地看到 CPU、内存等关键的性能指标。如果某个指标有问题，就要深入进程内部查看是哪些操作的原因\n\n\npstack：可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象\n\n\nstrace：pstack 显示的只是进程的一个“静态截面”，信息量还是有点少，而 strace 可以显示出进程的正在运行的系统调用，实时查看进程与系统内核交换了哪些信息\n\n\nperf：可以说是 pstack 和 strace 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出 CPU 使用情况。\n\n\n\n\n源码级工具：Google Performance Tools\n\n在源码里“埋点”，直接写特别的性能分析代码，有目的地对系统的某个模块做精细化分析，拿到更准确、更详细的数据。\n\n\n\n5.其他开源库概览\n\n\n5.实战1.C++primer2.Effective C++1.Effective C++\n视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）\n宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define）\n尽可能使用 const\n确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）\n了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）\n若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）\n为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）\n别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）\n绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）\n令 operator= 返回一个 reference to *this （用于连锁赋值）\n在 operator= 中处理 “自我赋值”\n赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）\n以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））\n在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））\n在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）\n成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete）\n以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）\n让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）\n设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。\n宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）\n必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）\n将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）\n宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）\n若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数\n考虑写一个不抛异常的 swap 函数\n尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）\n尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast&lt;T&gt;(expression)、dynamic_cast&lt;T&gt;(expression)、reinterpret_cast&lt;T&gt;(expression)、static_cast&lt;T&gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）\n避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）\n为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）\n透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）\n将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）\n确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）\n避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）\n区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）\n考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）\n绝不重新定义继承而来的 non-virtual 函数\n绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）\n通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））\n明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）\n明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）\n了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）\n了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）\n学习处理模板化基类内的名称（可在 derived class templates 内通过 this-&gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）\n将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）\n运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）\n需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）\n请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）\n认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）\n了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）\n了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）\n编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）\n写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）\n不要轻忽编译器的警告\n让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）\n让自己熟悉 Boost（准标准库）\n\n2.More Effective c++\n仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）\n最好使用 C++ 转型操作符（static_cast、const_cast、dynamic_cast、reinterpret_cast）\n绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）\n非必要不提供 default constructor（避免对象中的字段被无意义地初始化）\n对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）\n区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）\n千万不要重载 &amp;&amp;，|| 和 , 操作符（&amp;&amp; 与 || 的重载会用 “函数调用语义” 取代 “骤死式语义”；, 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）\n了解各种不同意义的 new 和 delete（new operator、operator new、placement new、operator new[]；delete operator、operator delete、destructor、operator delete[]）\n利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）\n在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）\n禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）\n了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）\n以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）\n明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）\n了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）\n谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）\n考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）\n分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）\n\n3.C++201.C++20实践入门2.C++20高级编程LinuxTheory1.概述\nOS定义：控制软硬件、调度和资源分配、提供接口和环境（命令接口和程序接口、库函数和系统调用）\nOS特征：并发、共享、虚拟、保护（前俩最基本、并发与并行）\n甘特图：纵程序、横时间，画资源\nOS发展：多道批处理、分时、实时\nOS运行环境：用户态与核心态、中断和异常、中断处理过程、访管指令（陷入指令）\n通道和中断的作用：实现I/O与CPU并行\n现代操作系统的两个基本特征是共享性和并发性\n作业由程序、数据、作业说明书组成\n文件按组织形式分类：普通、目录、特殊\n文件包括两部分：文件和文件说明\nCPU输出数据的速度远远高于打印机的打印速度，为了缓解这一矛盾，可采用??缓冲技术??\nOS为用户提供了两种接口：操作级接口（命令接口）：为用户提供各种命令；程序级接口（系统调用）：为用户程序一级提供有关服务\n资源有序分配法破坏了产生死锁的必要条件中的环路等待\n临界资源是一次只能为一个进程使用的资源；临界区是指访问临界资源的那段代码\n在单个CPU系统中，CPU和线程是并行操作的\n访问磁盘时间由三部分组成：寻道时间+延迟时间+传输时间\n在处理机调度中，内外存调度实际上是进程的挂起与激活\n\n2.进程管理七状态模型\n进程=PCB+程序段+数据段（所有系统调用都操作 PCB）\n线程=TCB+堆栈+寄存器\n创建、就绪、运行、阻塞、终止、就绪挂起、阻塞挂起\n运行态到阻塞态：是一种特殊的、由用户态调用操作系统内核过程的形式（主动）\n阻塞态到就绪态：被动行为\n进程调度、进程切换、处理及模式切换P33\n进程作为CPU以外的sys资源分配的基本单位，线程作为处理机调度的基本单位，共享进程资源\n线程实现：用户级线程、内核级线程；多线程模型：多对一、一对一、多对多\n父进程创建子进程与主程序调用子程序（并行/串行）；多线程与多任务（针对进程/针对OS）\n\n==进程通信==\n共享存储：生-消模型、互斥访问共享存储区、“布袋”\n消息传递：以Message为基本单位，使用OS发送、接受原语，直接通信（邮差）、间接通信（邮箱）\n管道通信：半双工通信（单向）、固定大小、数据一次性、读空才写写满才读、pipe文件\n\n软硬件实现临界互斥的方法\n单标志法：turn、违空闲让进\n双标志先检查：flag[2]、违忙则等待\n双标志后检查：flag[2]、违有限等待\n皮特森算法：1+3、违让权等待\n中断屏蔽、TSL（test and set）、swap\n\n进程同步（阻塞+上锁）\n基础知识同步：某个行为要用到某种资源在前面P一下；某个行为能产生某种资源在后面V一下（协调工作次序）互斥：P、V操作夹紧使用互斥资源的行为，尽量保证最少的代码（互斥访问临界资源）P、V：P在信号量有数时才减1，否则阻塞临界资源：一次只允许一个进程访问的可共享的资源（不能修改的代码不属于临界资源）\n前驱关系：前V后P\n生产者-消费者：两对同步or一对同步，当有全局变量时如修改则要PV一下\n读者-写者：可多个进程同时访问，用count计数，第一个P一下，最后一个V一下，在访问count时要互斥访问，属于共享资源。（读写公平多用一组pv同步）\n哲学家进餐：需要同时取多个资源，为防止死锁，取前P全取完V\n吸烟者问题：一个生产者多个消费者，注意怎么唤醒、怎么阻塞\n\nsemaphore mutex &#x3D; 1;\nsemaphore empty &#x3D; n;\nsemaphore full &#x3D; 0;\nproduce ()&#123;\n    while (1)&#123;\n        produce an item in nextp;\n        P(empty);\n        P(mutex);\n        Add nextp to buffet;\n        V(mutex);\n        V(full);\n    &#125;\n&#125;\nconsumer ()&#123;\n    while (1)&#123;\n        P(full);\n        P(mutex);\n        remove an item from buffet;\n        V(mutex);\n        V(empty);\n        consume the item;\n    &#125;\n&#125;\n\nsemaphore plate &#x3D; 1,apple &#x3D; 0,orange &#x3D; 0;\nDad()&#123;\n    while (1)&#123;    \n        P(plate);\n        V(apple);\n    &#125;\n&#125;\nMom()&#123;\n    while (1)&#123;\n         P(plate);\n         V(orange);\n    &#125;\n&#125;\nSon()&#123;\n    while (1)&#123;\n        P(orange);\n        P(plate);\n    &#125;\n&#125;\nDaughter()&#123;\n    while (1)&#123;\n        P(apple);\n        P(plate);\n    &#125;\n&#125;\n\nint count &#x3D; 0;\nsemaphore mutex &#x3D; 1&#x2F;&#x2F;count互斥\nsemaphore rw &#x3D; 1&#x2F;&#x2F;读写互斥\nWriter()&#123;\n    while (1)&#123;\n        &#x2F;&#x2F;P(w);写进程优先 \n        P(rw);\n        Writing;\n        V(rw);\n        &#x2F;&#x2F;V(w);写进程优先\n    &#125;\n&#125;\nReader ()&#123;\n    while (1)&#123;\n        &#x2F;&#x2F;P(w);\n        P(mutex);\n        if(count &#x3D;&#x3D; 0)\n            P(rw);\n        count++;\n        V(mutex);\n        &#x2F;&#x2F;V(w);不加到最后，加到这就足够了\n        Reading;\n        P(mutex);\n        count—-;\n        if(count &#x3D;&#x3D; 0)\n            V(rw);\n        V(mutex);\n    &#125;\n&#125;\n\nsemaphore chopstick[5]&#x3D;&#123;1,1,1,1,1&#125;\nsemaphore mutex &#x3D; 1;\nPi()&#123;\n    do&#123;\n        P(mutex);&#x2F;&#x2F;互斥取筷子,一次取完两根\n        P(chopstick[i]);\n        P(chopstick[(i+1)%5];\n        V(mutex);\n        Eat;\n        V(chopstick[i]);\n        V(chopstick[(i+1)%5];\n        Think;\n    &#125;while(1);\n&#125;\n\nint random;\nsemaphore offer1 &#x3D; 0,offer2 &#x3D; 0,offer3 &#x3D; 0;\nsemaphore finish &#x3D; 0;&#x2F;&#x2F;表示抽烟是否完成，是一种前驱关系，同步关系，完成后才能放新的\nProcess p1()&#123;\n    while (1)&#123;\n        random&#x3D;任意一个整数随机数;\n        random&#x3D;random%3;\n        if(random &#x3D;&#x3D; 0)\n            V(offer1);\n        else if(random &#x3D;&#x3D; 1)\n            V(offer2);\n        else \n            V(offer3);\n        任意两种材料放在桌子上；\n        P(finish);\n    &#125;\n&#125;\nProcess pi()&#123;\n    while (1)&#123;\n        P(offeri);\n        取走；\n        V(finish);\n    &#125;\n&#125;\n\nint waiting &#x3D; 0,chairs &#x3D; n;\nsemaphore customers &#x3D; 0,barbers &#x3D; 0,mutex &#x3D; 1;\nbarber ()&#123;\n    while (1)&#123;\n        P(customers);\n        P(mutex);\n        waiting &#x3D; waiting - 1;\n        V(mutex);\n        V(barbers);\n        Cut_hair();\n&#125;\ncustomer ()&#123;\n    P(mutex);\n    if(waiting &lt; chairs)&#123;\n        waiting &#x3D; waiting + 1;\n        V(customers);\n        V(mutex);\n        P(barbers);\n        Get_haircut();\n    &#125;\n    else\n        V(mutex);\n&#125;\n\n进程调度\n高级调度（作业-&gt;进程）、中级调度（外存&lt;-&gt;内存）、低级调度（三态转化）\n不能调度（处理中断、临界区、屏蔽中断）；剥夺与非剥夺调度（早期批处理）【在进程处于临界区时，只要不破坏临界区资源使用规则就不影响处理机调度】\n评估：CPU利用率（忙碌时间/总时间）、系统吞吐量（完成作业数/总时间）、平均周转时间（提交到完成/n=（等待+执行）/n）、带权周转时间（作业周转时间/实际运行时间，越小越好必然大于1）、等待时间（等处理机状态）、响应时间（提交请求到首次响应）\n先来先服务（FCFS）：选最早\n短作业/进程优先（SJF/SPF）：选最短（平均等待时间、平均周转时间最少）\n优先级调度：选优先级最高（净：sys&gt;users、交互&gt;非交互、I/O&gt;CPU）\n高相应比优先（HRRN）：响应比最高（等待时间+需服务时间）/需服务时间\n时间片轮转（RR）：分时OS、绝对可抢占\n多级反馈队列：1+3+5、“UNIX”、优先级高到低、时间片小到大（上无才执行下）\n\n==死锁（独占资源分配不当）==\n死锁定义：多个进程因竞争资源而造成的一种僵局（互相等待）若无外力作用，这些进程都将无法向前推进\n产生原因：竞争资源、进程推进非法\n预防死锁：破坏互斥（资源共享使用）、破坏不剥夺、破坏请求和保持（预先静态分配）、破坏循环等待（顺序资源分配）（必要条件）\n避免死锁：安全状态（不一定是死锁状态）、银行家算法（必须知道将来的资源请求）、安全性算法\n检测死锁：利用死锁定理化简资源分配图（圆圈代表进程，框代表一类资源，一个圆代表一个该类资源，进程到资源为请求边，资源到进程为分配边）把圈都变成孤点\n解除死锁：资源剥夺、撤销进程、进程回退\n死锁检测：银行家算法\nMax、Allocation、Need\nWork、Need、Allocation、W+A（分配一个写一行，一行一行写）\n\n\n\n3.内存管理基础知识\n程序的编译、链接和装入\n\n\n编译成若干0-n，链接成一个0-m，装入将逻辑地址转换为物理地址（地址重定位）\n静态链接、装入时动态链接、运行时动态链接\n绝对装入、可重定位装入、运行时动态装入（动态重定位、只装入一部分可以提供比内存大的地址空间）\n\n\n内存保护\n\n\n上下限寄存器\n重定位寄存器和界地址寄存器：逻辑&lt;界地址，物理=逻辑+重定位\n\n\n覆盖与交换\n\n\n覆盖：一个程序内，用虚拟内存替代\n交换：中级调度，现在还在用\n\n==内存分派方式==\n连续分配方式\n\n\n单一连续分配：单用户单任务OS、有内无外\n固定分区分配：一个分区一到作业、分区说明表（始址+大小+状态）、有内无外\n动态分区分配：（紧凑）（有外无内）\n首次适应：(First Fit)地址递增，第一个能装进去的（最好、最快）\n最佳适应：(Best Fit)容量递增，有很多外部碎片！！！\n最坏适应：(Worst Fit)容量递减，很快无大连续快\n邻近适应：(Next Fit)又称循环首次适应，从上一次结束开始不从头找\n\n\n非连续分配方式\n\n\n存储密度低于连续分配方式，但少了很多页内碎片\n运行时是否把所有作业都装入内存（基本分页/请求分页）\n地址结构决定了虚拟内存的寻址空间有多大\n\n基本分页存储管理方式（透明）（有内部碎片）\n进程（页）-&gt;内存（页框）-&gt;外存（块）\n页表（页号+物理块号）-&gt;页面-&gt;地址结构（页号+页内偏移量）\n地址变换机构+逻辑地址到物理地址转换过程（页表寄存器=页表始址+页表长度）\n快表（高速缓冲存储器，非内存）：少访问一次内存，有一次访问数据\n两级页表：减少了内存占用空间，只有一个顶级页表\n\n基本分段存储管理方式（不透明）（有外部碎片）\n段内连续，段间不连续，地址空间是二维的（段的始址+段内偏移量）\n段表项：段号+段长+本段在主存的始址\n段表内位置要查一次，找到段的位置，段内偏移量又要查一次，真正的物理地址（段表寄存器=段表始址+段表长度）\n\n段页式管理方式\n段号+页号+页内偏移量\n一个进程一个段表，一个分段一个页表\n段表项=段号+页表长度+页表始址；页表项=页号+块号；段表寄存器=段表长度+段表始址\n首先通过段表查到页表始址-&gt;通过页表查到页帧号-&gt;物理地址（段号查段表、页号查页表、最后加偏移量）\n二维的原因：与页式管理不同，段式管理不能通过给出一个整数便确定对应的物理地址，因为每段的长度是不固定的，无法通过整数除法得出段号，无法通过取余得出段内偏移，所以段号和段内偏移一定要显示给出，因此分段管理的地址空间是二维的。\n\n==页表项的大小有页表数量决定，2²⁰个页表需要20/8上取整，及3B，但一般都取4B（1B有8位）==\n==前面的操作是为了同时将多个进程保存在内存中，后面的操作是为了让一个进程的尽量少的一部分装入内存==\n虚拟内存\n基于局部性原理（时间、空间）：容量小于等于内外存之和，也小于等于计算机地址位数能容纳的最大容量\n实现方式：请求分页、请求分段、请求段页式\n需支持：内存+外存、页表机制、中断机构、地址变换机构\n页表机制：页号、物理块号、状态位P、访问字段A（访问次数）、修改位M、外存地址\n中断机构：指令执行期间处理中断（内中断）、一条指令执行期间可产生多次缺页中断\n地址变换机构：检索快表、（未找到）去内存中找页表、（在内存）根据物理地址访问内存、（没在内存）缺页中断去外存找\n虚拟内存&lt;=内存容量和外存容量之和&amp;&amp;虚拟内存&lt;=计算机地址结构所能容纳的最大容量\n\n页面置换\nOPT：向后找（无法实现）\nFIFO：队列实现（Belady异常【3210 3243 2104】、性能差）\nLRU：（最近最久未用）向前看（性能好、堆栈开销大）\nCLOCK：（NRU：Not Recently Used，最近未用）首次装入内存该帧使用位置为1；当要替换时扫描缓冲区，如果是1则改成0，如果是0则换出并指向下一帧。（当某一帧被替换时，指针被设置成指向缓冲区的下一帧）\n改进CLOCK：（使用位，修改位）扫描第一次：找（0，0）不做修改；扫描第二次：找（0，1）并且将（1，x）-&gt;（0，x），再次从头开始找（0，0）。首选没变化的页面00-&gt;01-&gt;10-&gt;11（换完后将指针后移）\n发生缺页的次数！=页面置换的次数\n\n其它\n驻留集大小：（分配几个物理页框）固定分配局部置换（自给自足）、可变分配全局置换（要就给）、可变分配局部置换（非常想要才给，否则自给自足，多了还往回拿）\n何时、何处调入页面：预调页策略（一次调入若干相邻，首次调时用）、请求调页策略；文件区/对换区：对换区大则都在对换区换，对换区不大只在对换区换修改过的；UNIX：未运行过的在文件区，运行过的在对换区\n抖动：一个进程在换页上用的时间多于执行时间\n工作集：某段时间间隔内，进程要访问的页面集合（不重复），分配的物理块数要大于工作集的大小\n工作集模型：工作集内的页面调入驻留集，工作集外的页面调出驻留集，空闲块多则调入进程，空闲块少则暂停进程\n\n4.文件管理文件\n以磁盘为载体存储在计算机上的信息集合，文件=数据+FCB+访问权限\n系统运行时，资源分配和调度的基本单位：进程；用户输入、输出中，以文件为基本单位\n文件结构：数据项&lt;记录&lt;文件（记录式文件、流式文件）\n文件的唯一标签：标识符（名字有重名）\n\n文件相关操作\n创建（找到空间+创建目录条目）、读、写、截断（删除内容不删除文件）、文件重定位（寻址）、删除（删文件）\n打开与关闭：打开文件表（省略搜索环节）、打开计数器（打开文件的进程数）、在open调用完成后，OS对该文件的任何操作都不再需要文件名，而只需要open调用返回的指针、close后：写回外存、释放内存、删除文件打开条目、释放FCB\n\n文件逻辑结构（用户角度）\n无结构文件（流式文件）\n有结构文件（记录式文件）：顺序文件（串结构、顺序结构）、索引文件（索引表、记录变长记录文件）、索引顺序文件（每组第一条记录为索引项）、直接文件或散列文件\n有结构文件是为了方便查找\n\n文件目录结构\n文件控制块（FCB），一个FCB就是一个文件目录项，FCB必须有序存放，FCB有序集合即为目录\n索引节点：=FCB-精简版目录项，存放在磁盘上，文件被打开时复制到内存中的索引节点\n目录结构：单级目录、两级目录（主文件目录（user1、user2…）+用户文件目录）、多级目录（树形目录、绝对路径、相对路径、分隔符/、当前工作目录.）、无环图目录（增加一些指向同一节点的有向边）\n\n文件共享与保护（目录-&gt;文件）\n硬链接：设置指针指向索引节点的共享方式（链接计数count）原count+1，一个文件的count统一变化\n软连接：基于符号链实现文件共享（与共享文件同名的LINK型文件，只包含共享文件的路径名，类似于快捷方式，指针指向快捷方式）直接复制原count，删文件count不变\n文件保护：口令保护、加密保护、访问控制（访问控制表ACL：用户名+读+写+执行）A        B        C\n\nuser1 r        rw         wuser2 e         -           -\n\n文件系统层次结构\n用户调用接口：根据系统调用，转入相应的模块\n文件目录结构：根据文件路径找到相应FCB或索引节点、目录项\n存取控制验证模块：权限比较，文件保护相关功能\n逻辑文件系统与文件信息缓冲区：把用户读写的逻辑记录转换成逻辑块号\n物理文件系统：将逻辑块号转成物理块号\n其它：辅助分配模块、设备管理模块\n\n目录实现\n线形列表：线性查找，文件名+数据块指针，查找慢\n哈希表：散列查找，根据文件名得到hash值，hash表长固定且hash函数对表长有依赖\n\n文件物理结构（文件实现）文件分配方式（非空闲块）\n连续：目录项（文件名+起始块号+长度）寻道数和寻道时间最小\n链接（串联）：文件分配表（显）（目录项：文件名+起始块号；FAT表：盘块号+下一盘块指针）、盘块内指针（隐）（文件名+起始块指针+结尾块指针）【注】FAT表启动时就会被读入内存，因此查找FAT表的过程是在内存中进行的。\n索引：（支持直接访问）当文件过大时有三种分配方式：链接（一个连一个）、多层（一个连n个）、混合索引（一级索引、二级索引…）\n\n存储空间管理（空闲块）\n空闲表：类似于内存的动态分配，第一个空闲盘块号+空闲盘块数\n空闲链表：空闲盘块链/空闲盘区链\n位示图：0空闲、1已分配（找0，算物理地址，改1，插入数据）\n成组链接：见下\n\n成组链接\n超级块（下一组空闲盘块数+若干空闲块号）复制到超级快，或从超级快拿走\n第一个空闲块指向下一组的类似超级块，其余指向空闲块，倒数第二个分组超级快的第一个空闲块数为-1\n从下往上分配块，从上往下归还块，最后一个块被占用不为空闲，可用块数=总块数-1\n\n磁盘\n地址：柱面号·盘面号·扇区号（或块号）【根据柱面移动磁头找到磁道、根据盘面决定启动哪个磁头，根据扇区号旋转盘面找到数据块】\n磁道为同心圆，存储能力受限于最内道的最大记录密度\n一次磁盘读写操作的时间：寻道时间（移道时间*n+启动磁臂时间）+延迟时间（磁头定位到扇区的时间）+传输时间（从磁盘读出或向磁盘写入的时间）\n磁盘初始化：低级格式化（物理分区，分扇区）、逻辑格式化（创建文件系统）\n引导块：初始化程序（自举程序），在ROM中（只读存储器，只能读不能写）\n数据传输速率：数据传输量（KB）/所用时间（s）【注】表示存储容量、文件大小时K等于1024，表示传输速率时K等于1000，所以得*1024/1000进行转换\n\n磁盘调度算法\nFCFS：根据进程请求访问磁盘的先后顺序，公平\nSSTF：找离当前最接近的（饥饿）\nSCAN（LOOK）：（又称电梯调度算法）两侧都扫描，走到头往回走，到头or不到头\nC-SCAN（C-LOOK）：只能单侧，访问到头快速返回至始端，解决两端不平衡的问题【注】look不走到头，scan走到头；带C只能一个方向扫描，不带C扫描完回头反向扫描\n\n5.输入输出管理（I/O）I/O控制方式（外设与内存间传输方式）（城中D道）\n程序直接控制：对读入的每个字进行循环检查，CPU与I/O串行，CPU利用率极低\n中断驱动方式：读一个字中断一次，I/O操作开始前和完成后需要CPU\nDMA方式（直接存储器存储）：（读一个数据块中断一次）在I/O设备和内存之间开辟直接的数据通路，传连续的数据块到内存，全传完才需CPU干预（命令寄存器、内存地址寄存器、数据寄存器、数据计数器）\n通道方式：弱鸡版的CPU（硬件），第一组数据块中断一次，通过执行CPU发来的通道程序（内存中的任务清单）完成对应I/O任务\n助记：每隔一段时间看看衣服好没；完成一件衣服打电话告知；雇一位秘书，交代好一切，每做100件报告一次；秘书决定衣服放在哪，什么时候报告。（一个DMA秘书只能负责一位裁缝，一个通道秘书可与多个裁缝沟通）\n\nI/O子系统层次结构\n用户层I/O软件：必须通过一组系统调用来获取操作系统服务（各种库函数）\n设备独立性软件：（又称系统调用处理层、设备无关性）为了实现设备独立性引入：逻辑设备&amp;物理设备、设备独立性软件。功能：执行所有设备的公有操作（维护逻辑设备表：将逻辑设备名映射为物理设备名），向用户层提供统一的接口（例如：read、write命令）\n设备驱动程序：一类设备一个驱动程序\n中断处理程序：用于保存中断进程的CPU环境，转入相应中断进程（放在底层的原因：由于中断处理与硬件紧密相关，对用户而言应尽量屏蔽，因此放在OS的底层，其它部分尽可能少的与之联系）\n硬件：I/O设备=机械部件+电子部件（适配器）\n\n设备控制器\n接受和识别CPU或通道发来的命令（控制寄存器）\n实现数据交换（数据寄存器）\n发现和记录设备及自身的状态信息（状态寄存器）\n设备地址识别（为了区分各个寄存器）\n\nI/O子系统概述\nI/O调度：确定一个好的顺序来使进程之间公平的共享设备访问，减少I/O完成所需要的平均等待时间（磁盘调度算法）\n高速缓冲与缓冲区：逻辑上属于磁盘，物理上则是驻留在内存中的盘块。缓冲区非空不能冲入数据，缓冲区充满才能读。\n\n缓冲区技巧：假设一种初始状态，然后计算下一次到达相同状态的所需时间，就是处理一块数据所需时间\n\n单缓冲：工作区满、缓冲区是空的\n双缓冲：工作区空、一个缓冲区满、另一个缓冲区是空的\n循环缓冲：类似于循环队列\n缓冲池：输入缓冲队列、输出缓冲队列、收容输入、提取输入、收容输出、提取输出\n设备分配与回收：设备控制表（一个设备及其属性）、控制器控制表（控制器：解析上层命令，与设备控制表一一对应）、通道控制表（一个通道管多个控制器，为了与内存交换数据）、系统设备表（一个系统一张，标示所有物理设备）\n设备分配策略：静态（一次性）、动态（系统调用向系统提出请求）、安全分配方式（发出I/O请求就进入阻塞态）、不安全分配方式\n\nSPOOLing技术\n用输入输出进程模拟外围控制机，来进行输入输出操作\n输入输出井在磁盘中、输入输出缓冲区在内存中-输入输出先放到磁盘输入输出井中，待I/O设备空闲再输入输出\n\n6.Bash1.理论\n系统启动过程\n\n\n计算机打开电源后，首先是BIOS开机自检，通常由硬盘启动，操作系统接管硬件后，读入/boot目录下的内核文件。运行init进程，是所有进程的祖先进程，init程序会读取配置文件etc/inittab，然后运行守护进程（daemon，开机启动程序）。启动哪些程序主要依赖运行级别（runlevel）的不同，一共有七个运行级别（停机状态默认为0、单用户工作状态为1、正常关闭并重启为6）\n在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本\nrc执行完毕后，返回init，此时基本系统环境已经设置好了，各种守护进程也启动了。init接下来会打开6个终端，以便用户登录系统。相应程序会显示一个文本登陆界面，就是经常能看到的登陆界面，输入用户名和密码后，就通过login程序验证身份\n\n\n系统关机\n$ sync #将数据同步到硬盘中\n$ shutdown #关机指令，可以通过man shutdown查询帮助文档\n$ shutdown -h now #立刻关机\n$ reboot #重启，等同于 shutdown -r now\n$ halt #关闭系统 等同于shutdown -h now 和 poweroff\n系统目录结构\n\n\n/bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。\n\n/boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。\n\n/dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。\n\n/etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。\n\n/home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。\n\n/lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。\n\n/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n\n/media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。\n\n/mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。\n\n/opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。\n\n/proc：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：\necho 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all\n/root：该目录为系统管理员，也称作超级权限者的用户主目录。\n\n/sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。\n\n/selinux：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。\n\n/srv：该目录存放一些服务启动之后需要提取的数据。\n\n/sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。\n\n/tmp：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。\n\n/usr：usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。\n\n/usr/bin：系统用户使用的应用程序。\n\n/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。\n\n/usr/src：内核源代码默认的放置目录。\n\n/var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。\n\n/run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。\n\n\n\n\n2.基础\n\n\n\n\n\n\n\n\n快捷键：Tab：补全命令或文件名;Ctrl+C：中断正在运行的程序;Ctrl+D：结束键盘输入。通过man 命令来查看各个命令的使用文档。网络管理、软件包安装、进程管理、磁盘管理、内存管理\n\n1.text manipulation tools\n文件管理：\n\nls（list files）：列出目录及文件名\n\n-a：列出所有文件，包括以.开头的隐藏文件\n-l：长数据串列出，包含文件的属性与权限等数据\n-t：按照时间顺序显示\n\n\ncd（change directory）：切换目录，添加相对路径或绝对路径\n\ncd ~：返回自己的家目录\ncd ..：返回上一级目录\n\n\npwd（print work directory）：显示当前目录，加上-P可以显示出确实的路径，而非链接（link）路径\n#因为sbin -&gt; usr&#x2F;sbin，是一个链接\nparallels@ubuntu-linux-20-04-desktop:&#x2F;sbin$ pwd\n&#x2F;sbin\nparallels@ubuntu-linux-20-04-desktop:&#x2F;sbin$ pwd -P\n&#x2F;usr&#x2F;sbin\nmkdir（make directory）：创建一个新目录\nmkdir [-mp] 目录名称\n# -m ：配置文件的权限,直接配置，不需要看默认权限 (umask) 的脸色\nmkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4 #自行创建多层目录\n# -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\nmkdir -m 711 test2 #创建权限为 rwx--x--x 的目录\nrmdir（remove dictionary）：删除一个空目录\nrmdir [-p] 目录名称\n#-p ：从该目录起，一次删除多级空目录\ncp（copy file）：复制文件或目录\n\n语法\ncp [-adfilprsu] 来源档(source) 目标档(destination)\ncp [options] source1 source2 source3 .... directory\n参数\n\n-a：相当于 -pdr 的意思，参考下列说明；(常用)\n-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；\n-d：若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；\n-r：递归持续复制，用于目录的复制行为；(常用)\n\n\n-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)\n\n\n示例\n#用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc\ncp ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc \n\n\nrm（remove file）：删除文件或目录\nrm [-fir] 文件或目录\n#f为忽略不存在的文件，不出现警告信息；i为互动模式，删除前询问；r为递归删除，常用在目录的删除\nmv（move file）：移动文件与目录，或修改文件与目录的名称\nmv [-fiu] source destination\n#f为不询问覆盖、i为询问覆盖、u为update，目标文件已经存在时切source比较新，才会升级\nmv [options] source1 source2 source3 .... directory\nmv bashrc mvtest #将bashrc文件移到mvtest目录下\nmv mvtest mvtest2 #将mvtest目录名称改为mvtest2\ntouch(建立新文件)\n\n通配符\n\n*：匹配任何字符串\n?：匹配1个字符串\n[xyz]：匹配xyz任意一个字符\n[a-z]：匹配一个范围\n[!xyz]或[^xyz]：不匹配\n\n\n\n\n文件属性\n\n权限管理\n\n查看文件属性：使用ll或ls -l命令\n\n\nchown：修改所属用户与组（change own）\n\n语法\nchown [-R] 属主名 文件名\nchown [-R] 属主名: 属组名 文件名\n示例\n$ chown bin install.log #将install.log的拥有者改为bin这个账号\n$ chown root:root install.log #将install.log的拥有者与群组改回为root\n\n\nchmod：修改权限常用常用命令（change mode）\n\n文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。\n\n目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。\n\n示例：\n# -R进行递归的持续变更（连同文件夹下的文件），xyz即权限数字的加和，r：4、w：2、x：1\n$ chmod [-R] xyz 文件或目录\n$ chmod 777 .bashrc #将.bashrc这个文件的所有权限都设定启用\n$ chmod a-x test1 #拿掉全部人的可执行权限\n\n\n\n\n用户管理\n\n常用命令\nuseradd：创建用户\nuserdel：删除用户\npasswd：修改用户密码\nusermod：修改用户属性\nchage：修改用户属性\ngroupadd：新建用户组\ngroupdel：删除用户组\n\n\n用户切换\nsu：切换用户\nsudo：以其他用户身份执行命令\n\n\n用户配置文件\n/etc/passwd：用户配置文件\n/etc/shadow：用户密码相关配置文件\n/etc/group：用户组配置文件\n\n\n\n\n\n\n文档编辑：\n\ncat 由第一行开始显示文件内容，可选参数如下\n\n-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；\n-v ：列出一些看不出来的特殊字符\n-E ：将结尾的断行字节 $ 显示出来；\n-T ：将 [tab] 按键以 ^I 显示出来；\n\n\n-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！\n-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；\n\n\ntac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\n\nnl  显示的时候，顺道输出行号！\n\n-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；\n-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；\n-w ：行号栏位的占用的位数。\n\n\nmore 一页一页的显示文件内容，在 more 这个程序的运行过程中，有以下几个按键可以按\n\n空白键 (space)：代表向下翻一页；\nEnter     ：代表向下翻『一行』；\n/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；\n:f      ：立刻显示出档名以及目前显示的行数；\nq       ：代表立刻离开 more ，不再显示该文件内容。\nb 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。\n\n\nless 与 more 类似，但是比 more 更好的是，他可以往前翻页，less运行时可以输入的命令有：\n\n空白键  ：向下翻动一页；\n[pagedown]：向下翻动一页；\n[pageup] ：向上翻动一页；\n/字串   ：向下搜寻『字串』的功能；\n?字串   ：向上搜寻『字串』的功能；\nn     ：重复前一个搜寻 (与 / 或 ? 有关！)\nN     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)\nq     ：离开 less 这个程序；\n\n\nhead 只看头几行\nhead [-n number] 文件 # n后面接数字，代表显示几行的意思\ntail 只看尾巴几行，默认显示最后10行\ntail [-n number] 文件 # n后面接数字，代表显示几行的意思\nwc：统计文件的字节数、单词数、行数\n\n\n\nLinux文本三剑客\n\ngrep：文本搜索工具\nawk：文本和数据进行处理的编程语言，可以让用户自定义函数或正则表达式对文本进行高效管理\nsed：批量编辑文本文件\n\n\n其他\n\n压缩与打包：\n\n最早Linux备份介质是磁带，使用命令tar；可以将打包后的磁带文件进行压缩存储，压缩命令是gzip和bzip2。所以经常出现的扩展名是.tar.gz、.tar.bz2、.tgz\n\n打包：tar\n\nc：打包\nx：解包\nf：指定操作类型为文件\n\ntar cf &#x2F;tmp&#x2F;etc-backup.tar &#x2F;etc #打包etc中的文件\n压缩和解压缩\n\n单独使用gzip、bzip2命令\n\n通过tar命令压缩\ntar czf &#x2F;tmp&#x2F;etc-backup.tar.gz &#x2F;etc #打包并通过gzip压缩etc中的文件\ntar cjf &#x2F;tmp&#x2F;etc-backup.tar.bz2 &#x2F;etc #打包并通过bzip2压缩etc中的文件，压缩比例高\n解压缩\ntar xf &#x2F;tmp&#x2F;etc-backup.tar -C &#x2F;root \ntar zxf &#x2F;tmp&#x2F;etc-backup.tar.gz -C &#x2F;root #.tar.gz可缩写为tgz\ntar jxf &#x2F;tmp&#x2F;etc-backup.tar.bz2 -C &#x2F;root #.tar.bz2可缩写为tbz2\n\n\n\n\nsort：对文件内容进行排序\n\nuniq：去除文件中的重复内容行\n\ncut：按列提取文件内容\n\nfmt：编排文本文件\n\ntr：字符转换指令，用来删除一行中的字符，或者对字符进行替换。\n\nod：以字符或者十六进制的形式显示二进制文件\n\nfind：文件搜索，可以使用文件的属性和权限进行搜索。\n\necho：用于在终端设备上输出指定字符串或变量提取后值的命令，能够给用户一些简单的提醒信息\n\nls链接：\n\n实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。\n\n符号链接：符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。\n当源文件被删除了，链接文件就打不开了。\n\n\n## ln [-sf] source_filename dist_filename\n-s ：默认是实体链接，加 -s 为符号链接\n-f ：如果目标文件存在时，先删除目标文件\n管道命令：管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。在命令之间使用 | 分隔各个管道命令。\n$ ls -al &#x2F;etc | less\n\n\n\n\n2.process monitoring\n进程状态\n\n\n\n状态\n说明\n\n\n\nR\nrunning or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。\n\n\nD\nuninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。\n\n\nS\ninterruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。\n\n\nZ\nzombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。\n\n\nT\nstopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。\n\n\n\n进程查看\n\nps：查看某个时间点的进程信息，示例如下：\n##查看自己的进程\nps -l\n##查看系统所有进程\nps aux\n##查看特定的进程\nps aux | grep threadx\npstree：查看进程树。\n\ntop：实时显示进程信息。\n##两秒钟刷新一次\ntop -d 2\n\n\n进程控制\n\nnice\n\n\n\nlsof：查看文件的进程信息\n\niostat：监视系统输入输出设备和CPU的使用情况\n\nsar：系统运行状态统计\n\nvmstat：显示虚拟内存状态\n\nstrace：跟踪系统调用\n\nsystemtap\n\ndf（disk free）：列出文件系统的整体磁盘使用量\n\n语法\n$ df [-ahikHTm] [目录或文件名]\n选项\n\n-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；\n-k ：以 KBytes 的容量显示各文件系统；\n-m ：以 MBytes 的容量显示各文件系统；\n-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；\n-H ：以 M=1000K 取代 M=1024K 的进位方式；\n-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；\n-i ：不用硬盘容量，而以 inode 的数量来显示\n\n\n示例\nparallels@ubuntu-linux-20-04-desktop:~$ df -h\nFilesystem      Size  Used Avail Use% Mounted on\nudev            1.9G     0  1.9G   0% &#x2F;dev\ntmpfs           392M  1.4M  391M   1% &#x2F;run\n&#x2F;dev&#x2F;sda2        63G  7.3G   52G  13% &#x2F;\n#...省略若干行...\n\n\nkill：杀死进程\n\n\n3.network\nnmap：网络探测和安全审核工具\n\ntcpdump：监听网络流量\n\nping：测试主机间网络联通性\n\nmtr：网络诊断\n\ntraceroute：追踪数据包在网络上传输时的全部路径\n\ndig：查询域名DNS信息\n\niptables：防火墙策略管理工具\n\nnetstat：查看占用端口的进程\n##查看特定端口的进程\nnetstat -anp | grep port\ncurl：文件传输工具\n\nwget：下载网络文件\n\nssh：安全的远程连接服务器\n\n\n3.进阶\n1.Bash scripting\n\n\n\n\n\n\n\n\nshell的一种，通过shell可以请求内核提供服务\n\n变量操作\n\n对一个变量赋值直接使用 =。\n$ x&#x3D;abc\n对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；\n\n输出变量使用 echo 命令。\n$ echo $x\n$ echo $&#123;x&#125;\n变量内容如果有空格，必须使用双引号或者单引号。\n\n双引号内的特殊字符可以保留原本特性，例如 x=”lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8；\n单引号内的特殊字符就是特殊字符本身，例如 x=’lang is $LANG’，则 x 的值为 lang is $LANG。\n\n\n变量的声明：\n$ declare [-aixr] variable\n-a ： 定义为数组类型\n-i ： 定义为整数类型\n-x ： 定义为环境变量\n-r ： 定义为 readonly 类型\n$ array[1]&#x3D;a\n$ array[2]&#x3D;b\n$ echo $&#123;array[1]&#125;\n数据流重定向（使用文件代替标准输入、标准输出和标准错误输出）\n\n有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。\n可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。\n如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。\n\n\n\n\n1\n代码\n运算符\n\n\n\n标准输入 (stdin)\n0\n&lt; 或 &lt;&lt;\n\n\n标准输出 (stdout)\n1\n&gt; 或 &gt;&gt;\n\n\n标准错误输出 (stderr)\n2\n2&gt; 或 2&gt;&gt;\n\n\n\n\n\n\n2.vim\n\n\n\n\n\n\n\n\n从vi发展来的一个文本编辑器，具有代码补全、编译、错误跳转等方便编程的功能\n\nVIM三个模式：\n\n\n\n命令模式（Command mode）：Vim的默认模式，可以用于移动游标查看内容，～代表没有任何东西\n\n编辑模式（Insert mode）：命令模式下按下 “i” 按键之后进入，可以对文本进行编辑，ESC键可返回命令模式\n\n底线命令模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作，命令以回车结束运行\n\n\n\n命令\n作用\n\n\n\n:w\n写入磁盘\n\n\n:w!\n当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关\n\n\n:q\n离开\n\n\n:q!\n强制离开不保存\n\n\n:wq\n写入磁盘后离开\n\n\n\n\n\nvi/vim按键说明\n\n1. \n\n\n\n3.compiling appsPOSIX\n1.网络通信2.进程间通信3.进程管理4.内存管理5.文件管理Linux Internal\n1.Linux操作系统综述1.外包公司的类比\n\n\n\n\n\n\n\n\n操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。将自己的角色切换成这家软件外包公司的老板，设身处地地去理解操作系统是如何协调各种资源，帮客户做成事情的。\n\n公司发展的几个阶段\n初创期：这个老板基于开放的营商环境（x86 体系结构），创办一家外包公司（系统的启动）。因为一开始没有其他员工，老板需要亲自接项目（实模式）。\n发展期：公司慢慢做大，项目越接越多（保护模式、多进程），为了管理各个外包项目，建立了项目管理体系（进程管理）、会议室管理体系（内存管理）、文档资料管理系统（文件系统）、售前售后体系（输入输出设备管理）。\n壮大期：公司越来越牛，开始促进内部项目的合作（进程间通信）和外部公司合作（网络通信）。\n集团化：公司的业务越来越多，会成立多家子公司（虚拟化），或者鼓励内部创业（容器化），这个时候公司就变成了集团。大管家的调度能力不再局限于一家公司，而是集团公司（Linux 集群），从而成功上市（从单机操作系统到数据中心操作系统）。\n\n\n外包公司职能部门与Linux内核系统对应关系：\n操作系统内核体系结构图\n\n2.Linux常用命令3.Linux常见系统调用==站在系统调用的角度，层层深入下去，就能从某个系统调用的场景出发，了解内核中各个模块的实现机制。==\n2.系统初始化1.X86架构\n通用寄存器：AX、BX、CX、DX、SP、BP、SI、DI，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）\nIP寄存器：指令指针寄存器，指向代码段中吓一跳指令的位置\n段寄存器：CS（代码段寄存器）、DS（数据段寄存器）、SS（栈寄存器）、ES\n实模式（Real Pattern）：通过CS、DS找到内存中的代码和数据，起始地址 *16+ 偏移量，段寄存器存放起始地址（16位的），通用寄存器和IP寄存器存放的是偏移量（16位的）\n保护模式（Protected Pattern）：在32位中，段寄存器不在存起始地址，段的起始地址放在内存的某个地方，这个地方是一个表格，表格中一项一项是段描述符（Segment Descriptor），这里面才是真正的段的起始地址，而段寄存器里面保存的是这个表格中的哪一项，成为选择子（Selector）\n\n2.从BIOS到bootloader\nBIOS：\n放在主板上的ROM（只读存储器），全称为基本输入输出系统，电脑刚加电时，第一条指令指向ROM中，BIOS开始初始化工作。\n检查硬件、建议中断向量表和中断服务程序、在显示器上显示一些字符\n\n\nbootloader（通过Grub2工具，全称为Grand Unified Bootloader Version 2）\n可以通过grub2-mkconfig -o /boot/grub2/grub.cfg 来配置系统启动的选项，这里面的选项会在系统启动的时候，成为一个列表，让用户选择从哪个系统启动。\n使用grub2-install /dev/sda可以将启动程序安装到相应的位置\n安装boot.img到启动盘的第一个扇区，通常称为MBR（主引导记录）\nboot.img加载grub2的另一个镜像core.img，core.img 由 diskboot.img、lzma_decompress.img、kernel.img 和一系列的模块组成\n首先加载进来diskboot.img，它负责将core.img的其他部分加载进来，先是解压缩程序lzma_decompress.img，因为kernel.img是压缩过的，再往下是kernel.img（grub的内核）\n\n\n\n\n从实模式切换到保护模式\nlzma_decompress.img调用real_to_prot，切换到保护模式\n启用分段：在内存里建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了\n启动分页：能够管理的内存变大了，就需要将内存分成相等大小的块\n打开地址线：打开第21跟地址线Gate A20\n\n\nkernel.img 对应的代码是 startup.S 以及一堆 c 文件，\n在 startup.S 中会调用 grub_main，这是 grub kernel 的主函数。在这个函数里面，grub_load_config() 开始解析（上面写的那个 grub.conf 文件里的配置信息）。\n如果是正常启动，grub_main 最后会调用 grub_command_execute (“normal”, 0, 0)，最终会调用 grub_normal_execute() 函数。在这个函数里面，grub_show_menu() 会显示出让你选择的那个操作系统的列表。\n选定了某个操作系统后，为了启动它，就要开始调用 grub_menu_execute_entry() ，开始解析并执行选择的那一项，解析完后grub_command_execute (“boot”, 0, 0) 才开始真正地启动内核\n\n\n\n\n\n3.内核初始化\n各个职能部门的创建\n\n项目管理部门：有一行指令set_task_stack_end_magic(&amp;init_task)，这里面有一个参数 init_task，它的定义是 struct task_struct init_task = INIT_TASK(init_task)，它是系统创建的第一个进程，称为0号进程，是进程列表（Process List）的第一个\n办事大厅：对应的函数是trap_init()，里面设置了很多中断门（Interrupt Gate），用于处理各种中断。其中有一个 set_system_intr_gate(IA32_SYSCALL_VECTOR , entry_INT80_32)，这是系统调用的中断门。系统调用也是通过发送中断的方式进行的。\n会议室系统：对应的mm_init()就是用来初始化内存管理模块，项目需要项目管理进行调度，需要执行一定的调度策略。sched_init()就是用于初始化调度模块。\n档案管理：vfs_caches_init() 会用来初始化基于内存的文件系统 rootfs。在这个函数里面，会调用 mnt_init()-&gt;init_rootfs()。这里面有一行代码，register_filesystem(&amp;rootfs_fs_type)。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 struct file_system_type rootfs_fs_type。\n最后，start_kernel() 调用的是rest_init()，用来做其他方面的初始化\n\n\n用户态祖先进程的创建（1号进程）\n\nrest_init 的第一大工作是，用 kernel_thread(kernel_init, NULL, CLONE_FS) 创建第二个进程，这个是 1 号进程。\n\n用户态代码访问核心资源的流程：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行。\n\n从内核态到用户态：\n\nkernel_thread 的参数是一个函数 kernel_init，也就是这个进程会运行这个函数。在 kernel_init 里面，会调用 kernel_init_freeable()，里面有这样的代码：\n&#x2F;&#x2F;ramdisk是根文件系统，运行ramdisk上的&#x2F;init后就是用户态了\nif (!ramdisk_execute_command)\n    ramdisk_execute_command &#x3D; &quot;&#x2F;init&quot;;\nkernel_init里面有这样的代码：\n  if (ramdisk_execute_command) &#123;\n    ret &#x3D; run_init_process(ramdisk_execute_command);\n......\n  &#125;\n......\n  if (!try_to_run_init_process(&quot;&#x2F;sbin&#x2F;init&quot;) ||\n      !try_to_run_init_process(&quot;&#x2F;etc&#x2F;init&quot;) ||\n      !try_to_run_init_process(&quot;&#x2F;bin&#x2F;init&quot;) ||\n      !try_to_run_init_process(&quot;&#x2F;bin&#x2F;sh&quot;))\n    return 0;\n\nrun_init_process 函数里面调用的是 do_execve，是一个系统调用的实现，它会尝试运行 ramdisk 的“/init”，或者普通文件系统上的“/sbin/init”，“/etc/init”，“/bin/init”、“/bin/sh”。不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。\nstatic int run_init_process(const char *init_filename)\n&#123;\n  argv_init[0] &#x3D; init_filename;\n  return do_execve(getname_kernel(init_filename),\n    (const char __user *const __user *)argv_init,\n    (const char __user *const __user *)envp_init);\n&#125;\n综上，1号进程运行的是一个文件，\n\n\n\n从内核态到用户态\n\nrun_init_process会调用：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler，这里面会调用这段内容：\nint search_binary_handler(struct linux_binprm *bprm)\n&#123;\n  ......\n  struct linux_binfmt *fmt;\n  ......\n  retval &#x3D; fmt-&gt;load_binary(bprm);\n  ......\n&#125;\n\n也就是说，我要运行一个程序，需要加载这个二进制文件，这就是我们常说的项目执行计划书。它是ELF格式的（Executable and Linkable Format，可执行与可链接格式），底层先调用 load_elf_binary，最后调用 start_thread\nvoid\nstart_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)\n&#123;\nset_user_gs(regs, 0);\nregs-&gt;fs  &#x3D; 0;\n&#x2F;&#x2F;将寄存器设置为用户的\nregs-&gt;ds  &#x3D; __USER_DS;\nregs-&gt;es  &#x3D; __USER_DS;\nregs-&gt;ss  &#x3D; __USER_DS;\nregs-&gt;cs  &#x3D; __USER_CS;\n&#x2F;&#x2F;下一条指令从用户态开始运行\nregs-&gt;ip  &#x3D; new_ip;\nregs-&gt;sp  &#x3D; new_sp;\nregs-&gt;flags  &#x3D; X86_EFLAGS_IF;\n&#x2F;&#x2F;用于从系统调用中返回\nforce_iret();\n&#125;\nEXPORT_SYMBOL_GPL(start_thread);\n\n\nramdisk的作用\n\n\n\n内核态祖先进程的创建（2号进程）\n\nrest_init 第二大事情就是第三个进程，就是 2 号进程。\nkernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES) 又一次使用 kernel_thread 函数创建进程，这里的函数 kthreadd，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先\n\n\n\n4.系统调用（办事大厅）\nglibc对系统调用的封装\n\n有个文件syscalls.list，里面列着所有glibc的函数对应的系统调用。\n有一个脚本 make-syscall.sh，可以根据syscalls.list配置文件，对于每一个封装好的系统调用，生成一个文件，这个文件里面定义了一些宏\n还有一个文件 syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式。\n对于任何一个系统调用，会调用DO_CALL，这也是个宏，且32位和64位不同\n\n\n64位系统调用过程\n\n将系统调用名称转换为系统调用号，放到寄存器rax，将请求参数存放到寄存器里面，然后执行syscall指令\n&#x2F;* The Linux&#x2F;x86-64 kernel expects the system call parameters in\n   registers according to the following table:\n    syscall number  rax\n    arg 1    rdi\n    arg 2    rsi\n    arg 3    rdx\n    arg 4    r10\n    arg 5    r8\n    arg 6    r9\n......\n*&#x2F;\n#define DO_CALL(syscall_name, args)                \\\n  lea SYS_ify (syscall_name), %rax;                \\\n  syscall\nsyscall指令使用了特殊模块寄存器（Model Specific Registers），在系统初始化的时候，trap_init除了初始化中断模式，还会调用cpu_init-&gt;syscall_init。这里面有这样的代码：wrmsrl(MSR_LSTAR, (unsigned long)entry_SYSCALL_64);，remsr和wrmsr是用来读写特殊模块寄存器的，MSR_LSTAR就是这样一个特殊寄存器，当syscall指令调用时，会从这个寄存器里拿出函数地址来调用，也就是调用entry_SYSCALL_64。\nENTRY(entry_SYSCALL_64)\n        &#x2F;* Construct struct pt_regs on stack *&#x2F;\n        pushq   $__USER_DS                      &#x2F;* pt_regs-&gt;ss *&#x2F;\n        pushq   PER_CPU_VAR(rsp_scratch)        &#x2F;* pt_regs-&gt;sp *&#x2F;\n        pushq   %r11                            &#x2F;* pt_regs-&gt;flags *&#x2F;\n        pushq   $__USER_CS                      &#x2F;* pt_regs-&gt;cs *&#x2F;\n        pushq   %rcx                            &#x2F;* pt_regs-&gt;ip *&#x2F;\n        pushq   %rax                            &#x2F;* pt_regs-&gt;orig_ax *&#x2F;\n        pushq   %rdi                            &#x2F;* pt_regs-&gt;di *&#x2F;\n        pushq   %rsi                            &#x2F;* pt_regs-&gt;si *&#x2F;\n        pushq   %rdx                            &#x2F;* pt_regs-&gt;dx *&#x2F;\n        pushq   %rcx                            &#x2F;* pt_regs-&gt;cx *&#x2F;\n        pushq   $-ENOSYS                        &#x2F;* pt_regs-&gt;ax *&#x2F;\n        pushq   %r8                             &#x2F;* pt_regs-&gt;r8 *&#x2F;\n        pushq   %r9                             &#x2F;* pt_regs-&gt;r9 *&#x2F;\n        pushq   %r10                            &#x2F;* pt_regs-&gt;r10 *&#x2F;\n        pushq   %r11                            &#x2F;* pt_regs-&gt;r11 *&#x2F;\n        sub     $(6*8), %rsp                    &#x2F;* pt_regs-&gt;bp, bx, r12-15 not saved *&#x2F;\n        movq    PER_CPU_VAR(current_task), %r11\n        testl   $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, TASK_TI_flags(%r11)\n        jnz     entry_SYSCALL64_slow_path\n......\nentry_SYSCALL64_slow_path:\n        &#x2F;* IRQs are off. *&#x2F;\n        SAVE_EXTRA_REGS\n        movq    %rsp, %rdi\n        call    do_syscall_64           &#x2F;* returns with IRQs disabled *&#x2F;\nreturn_from_SYSCALL_64:\n  RESTORE_EXTRA_REGS\n  TRACE_IRQS_IRETQ\n  movq  RCX(%rsp), %rcx\n  movq  RIP(%rsp), %r11\n    movq  R11(%rsp), %r11\n......\nsyscall_return_via_sysret:\n  &#x2F;* rcx and r11 are already restored (see code above) *&#x2F;\n  RESTORE_C_REGS_EXCEPT_RCX_R11\n  movq  RSP(%rsp), %rsp\n  USERGS_SYSRET64\n这里先后保存了很多寄存器到pt_regs结构里面，然后调用entry_SYSCALL64_slow_path-&gt;do_syscall_64 \n__visible void do_syscall_64(struct pt_regs *regs)\n&#123;\n        struct thread_info *ti &#x3D; current_thread_info();\n        unsigned long nr &#x3D; regs-&gt;orig_ax;\n......\n        if (likely((nr &amp; __SYSCALL_MASK) &lt; NR_syscalls)) &#123;\n                regs-&gt;ax &#x3D; sys_call_table[nr &amp; __SYSCALL_MASK](\n                        regs-&gt;di, regs-&gt;si, regs-&gt;dx,\n                        regs-&gt;r10, regs-&gt;r8, regs-&gt;r9);\n        &#125;\n        syscall_return_slowpath(regs);\n&#125;\n在 do_syscall_64 里面，从 rax 里面拿出系统调用号，然后根据系统调用号，在系统调用表 sys_call_table 中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。\n\n64 位的系统调用返回的时候，执行的是 USERGS_SYSRET64，返回用户态的指令变成了sysretq\n\n\n\n系统调用表\n\n系统调用的声明一般在include/linux/syscalls.h 文件中\n真正的系统调用的实现在一个.c文件里，.c文件里包含宏定义，把宏展开，和声明的是一样的\n在编译的过程中，需要根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的 unistd_32.h 和 unistd_64.h。生成方式在 arch/x86/entry/syscalls/Makefile 中。这里面会使用两个脚本，其中第一个脚本 arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成 #define __NR_open；第二个脚本 arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成 __SYSCALL(__NR_open, sys_open)。这样，unistd_32.h 和 unistd_64.h 是对应的系统调用号和系统调用实现函数之间的对应关系。\n在文件 arch/x86/entry/syscall_32.c，定义了这样一个表，里面 include 了这个头文件，从而所有的 sys_ 系统调用都在这个表里面了。\n在文件 arch/x86/entry/syscall_64.c，定义了这样一个表，里面 include 了这个头文件，这样所有的 sys_ 系统调用就都在这个表里面了。\n\n\n\n\n\n3.进程管理1.进程\n用系统调用创建进程\n&#x2F;&#x2F;#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;、#include &lt;sys&#x2F;types.h&gt;、#include &lt;unistd.h&gt;\nextern int create_process (char* program, char** arg_list);\nint create_process (char* program, char** arg_list)\n&#123;\n    pid_t child_pid;\n    child_pid &#x3D; fork ();\n    if (child_pid !&#x3D; 0)\n        return child_pid;\n    else &#123;\n        execvp (program, arg_list);\n        abort ();\n    &#125;\n&#125;\nLinux下面的二进制程序的格式：ELF（Executeable and Linkable Format，可执行与可链接格式），根据编译的结果不同有以下几种格式\n\n可重定位文件（Relocatable File），定义为struct elf32_hdr 和 struct elf64_hdr，里面的一个个节（Section）如下：\n\n.text：放编译好的二进制可执行代码\n.rodata：只读数据，例如字符串常量、const 的变量\n.data：已经初始化好的全局变量\n.bss：未初始化全局变量，运行时会置 0\n.symtab：符号表，记录的则是函数和变量\n.strtab：字符串表、字符串常量和变量名\n.rel.text, .rel.data ：与重定位有关\nSection Header Table：保存其它所有节（section）的元数据\n\n\n可执行文件：这个格式和.o 文件大致相似，里面的section同上，只不过这些 section 是多个.o 文件合并过的。定义为 struct elf32_phdr 和 struct elf64_phdr并且被Section Header Table描述。（许多.o文件可通过ar命令归档为.a静态链接文件，使用时找到内部的.o文件并与新.o文件链接成可执行文件）\n\nELF Header\nSegment Header Table\n代码段：.text、.rodata\n数据段：.data、.bss\n不加载到内存：.symtab、.strtab、Section Header Table\n\n\n共享对象文件（Shard Object），即动态链接库（Shard Libraries）\n\n创建：当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，仅包括对动态链接库的引用和名称。\n运行：当运行这个程序的时候，首先寻找动态链接库（默认在/lib 和 /usr/lib 文件夹下寻找），然后加载它。\nELF 文件中还多了两个 section，.plt过程链接表（Procedure Linkage Table，PLT）、.got.plt全局偏移量表（Global Offset Table，GOT）原理如下：\n因为时运行时才去找，编译时不知道代码位置，所以就在 PLT 里面建立一项 PLT[x]。里面有一些代码可以在运行时找真正的create_process 函数。\n代码调用GOT创建的GOT[y]，它是运行时 create_process 函数在内存中真正的地址。\nGOT最初依靠调用链PLT[0]-&gt;GOT[2]-&gt;ld-linux.so，最后加载内存中的函数地址放到GOT[y]中。\n\n\n\n\n\n\n运行程序文件称为进程\n\n内核用下面的数据结构来定义加载二进制文件的方法：\nstruct linux_binfmt &#123;\n    struct list_head lh;\n    struct module *module;\n    int (*load_binary)(struct linux_binprm *);\n    int (*load_shlib)(struct file *);\n    int (*core_dump)(struct coredump_params *cprm);\n    unsigned long min_coredump;     &#x2F;* minimal dump size *&#x2F;\n&#125; __randomize_layout;\n对于ELF文件格式，有对应的实现：\nstatic struct linux_binfmt elf_format &#x3D; &#123;\n    .module         &#x3D; THIS_MODULE,\n    &#x2F;&#x2F;调用链：exec系统调用-&gt;do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler\n    .load_binary    &#x3D; load_elf_binary,\n    .load_shlib     &#x3D; load_elf_library,\n    .core_dump      &#x3D; elf_core_dump,\n    .min_coredump   &#x3D; ELF_EXEC_PAGESIZE,\n&#125;;\n\n\n进程树\n\n通过ps -ef命令查看当前系统启动的进程，会发现有三类进程\n[root@deployer ~]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0  2018 ?        00:00:29 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --system --deserialize 21\nroot         2     0  0  2018 ?        00:00:00 [kthreadd]\nroot         3     2  0  2018 ?        00:00:00 [ksoftirqd&#x2F;0]\nroot         5     2  0  2018 ?        00:00:00 [kworker&#x2F;0:0H]\nroot         9     2  0  2018 ?        00:00:40 [rcu_sched]\n......\nroot       337     2  0  2018 ?        00:00:01 [kworker&#x2F;3:1H]\nroot       380     1  0  2018 ?        00:00:00 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-udevd\nroot       415     1  0  2018 ?        00:00:01 &#x2F;sbin&#x2F;auditd\nroot       498     1  0  2018 ?        00:00:03 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-logind\n......\nroot       852     1  0  2018 ?        00:06:25 &#x2F;usr&#x2F;sbin&#x2F;rsyslogd -n\nroot      2580     1  0  2018 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -D\nroot     29058     2  0 Jan03 ?        00:00:01 [kworker&#x2F;1:2]\nroot     29672     2  0 Jan04 ?        00:00:09 [kworker&#x2F;2:1]\nroot     30467     1  0 Jan06 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;crond -n\nroot     31574     2  0 Jan08 ?        00:00:01 [kworker&#x2F;u128:2]\n......\nroot     32792  2580  0 Jan10 ?        00:00:00 sshd: root@pts&#x2F;0\nroot     32794 32792  0 Jan10 pts&#x2F;0    00:00:00 -bash\nroot     32901 32794  0 00:01 pts&#x2F;0    00:00:00 ps -ef\n\n\n\n\nPID 1 的进程就是 init 进程 systemd，PID 2 的进程是内核线程 kthreadd，这两个在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。\n带中括号的内核态的进程，祖先都是 2 号进程。而用户态的进程，祖先都是 1 号进程。tty 那一列，是问号的，说明不是前台启动的，一般都是后台的服务。\npts 的父进程是 sshd，bash 的父进程是 pts，ps -ef 这个命令的父进程是 bash。\n\n\n\n\n\n2.线程\n线程创建\n\n线程数据\n\n线程栈上的本地数据：每个线程有自己的线程栈，可用pthread_attr_setstacksize修改栈大小\n\n线程共享的全局数据：利用互斥来保证安全\n\n线程私有数据：\n\n创建：key 一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往 key 中填入不同的值，这就相当于提供了一个同名而不同值的全局变量。\nint pthread_key_create(pthread_key_t *key, void (*destructor)(void*))\nvalue值操作\n&#x2F;&#x2F;设置key对应的value\nint pthread_setspecific(pthread_key_t key, const void *value)；\n&#x2F;&#x2F;获取key对应的value\nvoid *pthread_getspecific(pthread_key_t key)    \n\n\n\n\n数据的保护\n\n举例一：转账\n&#x2F;&#x2F;#include &lt;pthread.h&gt;、#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;\n#define NUM_OF_TASKS 5\n\nint money_of_tom &#x3D; 100;\nint money_of_jerry &#x3D; 100;\npthread_mutex_t g_money_lock;\n\nvoid *transfer(void *notused)\n&#123;\n    pthread_t tid &#x3D; pthread_self();\n    printf(&quot;Thread %u is transfering money!\\n&quot;, (unsigned int)tid);\n    pthread_mutex_lock(&amp;g_money_lock);\n    sleep(rand()%10);\n    money_of_tom+&#x3D;10;\n    sleep(rand()%10);\n    money_of_jerry-&#x3D;10;\n    pthread_mutex_unlock(&amp;g_money_lock);\n    printf(&quot;Thread %u finish transfering money!\\n&quot;, (unsigned int)tid);\n    pthread_exit((void *)0);\n&#125;\n\nint main(int argc, char *argv[])\n&#123;\n    pthread_t threads[NUM_OF_TASKS];\n    int rc;\n    int t;\n    pthread_mutex_init(&amp;g_money_lock, NULL);\n\n    for(t&#x3D;0;t&lt;NUM_OF_TASKS;t++)&#123;\n        rc &#x3D; pthread_create(&amp;threads[t], NULL, transfer, NULL);\n        if (rc)&#123;\n            printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc);\n            exit(-1);\n        &#125;\n    &#125;\n\n    for(t&#x3D;0;t&lt;100;t++)&#123;\n        pthread_mutex_lock(&amp;g_money_lock);\n        printf(&quot;money_of_tom + money_of_jerry &#x3D; %d\\n&quot;, money_of_tom + money_of_jerry);\n        pthread_mutex_unlock(&amp;g_money_lock);\n    &#125;\n\n    pthread_mutex_destroy(&amp;g_money_lock);\n    pthread_exit(NULL);\n&#125;\n举例二：三个员工等活干\n&#x2F;&#x2F;#include &lt;pthread.h&gt;、#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;\n#define NUM_OF_TASKS 3\n#define MAX_TASK_QUEUE 11\n\nchar tasklist[MAX_TASK_QUEUE]&#x3D;&quot;ABCDEFGHIJ&quot;;\nint head &#x3D; 0;\nint tail &#x3D; 0;\nint quit &#x3D; 0;\n\npthread_mutex_t g_task_lock;\npthread_cond_t g_task_cv;\n\nvoid *coder(void *notused)\n&#123;\n    pthread_t tid &#x3D; pthread_self();\n\n    while(!quit)&#123;\n\n        pthread_mutex_lock(&amp;g_task_lock);\n        while(tail &#x3D;&#x3D; head)&#123;\n            if(quit)&#123;\n                pthread_mutex_unlock(&amp;g_task_lock);\n                pthread_exit((void *)0);\n            &#125;\n            printf(&quot;No task now! Thread %u is waiting!\\n&quot;, (unsigned int)tid);\n            pthread_cond_wait(&amp;g_task_cv, &amp;g_task_lock);\n            printf(&quot;Have task now! Thread %u is grabing the task !\\n&quot;, (unsigned int)tid);\n        &#125;\n        char task &#x3D; tasklist[head++];\n        pthread_mutex_unlock(&amp;g_task_lock);\n        printf(&quot;Thread %u has a task %c now!\\n&quot;, (unsigned int)tid, task);\n        sleep(5);\n        printf(&quot;Thread %u finish the task %c!\\n&quot;, (unsigned int)tid, task);\n    &#125;\n\n    pthread_exit((void *)0);\n&#125;\n\nint main(int argc, char *argv[])\n&#123;\n    pthread_t threads[NUM_OF_TASKS];\n    int rc;\n    int t;\n\n    pthread_mutex_init(&amp;g_task_lock, NULL);\n    pthread_cond_init(&amp;g_task_cv, NULL);\n\n    for(t&#x3D;0;t&lt;NUM_OF_TASKS;t++)&#123;\n        rc &#x3D; pthread_create(&amp;threads[t], NULL, coder, NULL);\n        if (rc)&#123;\n            printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc);\n            exit(-1);\n        &#125;\n    &#125;\n\n    sleep(5);\n\n    for(t&#x3D;1;t&lt;&#x3D;4;t++)&#123;\n        pthread_mutex_lock(&amp;g_task_lock);\n        tail+&#x3D;t;\n        printf(&quot;I am Boss, I assigned %d tasks, I notify all coders!\\n&quot;, t);\n        pthread_cond_broadcast(&amp;g_task_cv);\n        pthread_mutex_unlock(&amp;g_task_lock);\n        sleep(20);\n    &#125;\n\n    pthread_mutex_lock(&amp;g_task_lock);\n    quit &#x3D; 1;\n    pthread_cond_broadcast(&amp;g_task_cv);\n    pthread_mutex_unlock(&amp;g_task_lock);\n\n    pthread_mutex_destroy(&amp;g_task_lock);\n    pthread_cond_destroy(&amp;g_task_cv);\n    pthread_exit(NULL);\n&#125;\n\n\n\n3.进程数据结构\nTask：Linux里面，无论是进程还是线程，都统一叫任务（Task），由统一的结构task_struct进行管理，并组织成一个链表struct list_head tasks;\n\n任务ID：\n\n用于简化任务展示（ps指令）和向一组任务发指令（kill指令），\npid 是 process id，tgid 是 thread group ID\n任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己。\n如果一个进程创建了其他线程，线程有自己的 pid，tgid 就是进程的主线程的 pid，group_leader 指向的就是进程的主线程。\n\n\n\n\n信号处理：\n&#x2F;&#x2F;里面有 struct sigpending shared_pending（线程组共享的）\nstruct signal_struct    *signal;\n&#x2F;&#x2F;信号正在等待被处理\nstruct sighand_struct    *sighand;\n&#x2F;&#x2F;信号被&#x2F;阻塞暂不处理\nsigset_t      blocked;\nsigset_t      real_blocked;\nsigset_t      saved_sigmask;\n&#x2F;&#x2F;信号等待被处理（本任务的）\nstruct sigpending    pending;\n&#x2F;&#x2F;信号处理默认用用户态的函数栈，下面三个字段用于开辟新的栈专门用于信号处理\nunsigned long      sas_ss_sp;\nsize_t        sas_ss_size;\nunsigned int      sas_ss_flags;\n任务状态：\n\nstate（状态）可以取的值定义在include/linux/sched.h 头文件中，通过bitset的方式设置的，当前是什么状态，哪一位就置1\n&#x2F;* Used in tsk-&gt;state: *&#x2F;\n#define TASK_RUNNING                    0\n#define TASK_INTERRUPTIBLE              1\n#define TASK_UNINTERRUPTIBLE            2\n&#x2F;&#x2F;在进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 或者 SIGTTOU 信号之后进入该状态\n#define __TASK_STOPPED                  4\n&#x2F;&#x2F;TASK_TRACED 表示进程被 debugger 等进程监视，进程执行被调试程序所停止。\n#define __TASK_TRACED                   8\n\n&#x2F;* Used in tsk-&gt;exit_state: *&#x2F;\n#define EXIT_DEAD                       16\n&#x2F;&#x2F;一旦一个进程要结束，先进入的是 EXIT_ZOMBIE 状态，\n&#x2F;&#x2F;但是这个时候它的父进程还没有使用 wait() 等系统调用来获知它的终止信息\n#define EXIT_ZOMBIE                     32\n#define EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)\n\n&#x2F;* Used in tsk-&gt;state again: *&#x2F;\n&#x2F;&#x2F;进程的最终状态\n#define TASK_DEAD                       64\n#define TASK_WAKEKILL                   128\n#define TASK_WAKING                     256\n#define TASK_PARKED                     512\n#define TASK_NOLOAD                     1024\n#define TASK_NEW                        2048\n#define TASK_STATE_MAX                  4096\n状态转移图\n\nTASK_RUNNING： 并不是进程正在运行，而是进程处于准备运行的状态。\n睡眠状态\nTASK_INTERRUPTIBLE：可中断的睡眠状态。虽然在睡眠等待 I/O 完成，但这时一个信号到来，进程还是要被唤醒。\nTASK_UNINTERRUPTIBLE：不可中断的睡眠状态。不可被信号唤醒，只能死等 I/O 操作完成。一旦 I/O 操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。\nTASK_KILLABLE：可以终止的新睡眠状态。进程处于这种状态中，它的运行原理类似 TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。\n\n\nTASK_STOPPED： 在进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 、SIGTTOU 信号后进入该状态。\n\n\nflags字段：\n\nPF_EXITING 表示正在退出。当有这个 flag 的时候，在函数 find_alive_thread 中，找活着的线程，遇到有这个 flag 的，就直接跳过。\nPF_VCPU 表示进程运行在虚拟 CPU 上。在函数 account_system_time 中，统计进程的系统运行时间，如果有这个 flag，就调用 account_guest_time，按照客户机的时间进行统计。\nPF_FORKNOEXEC 表示 fork 完了，还没有 exec。在 _do_fork 函数里面调用 copy_process，这个时候把 flag 设置为 PF_FORKNOEXEC。当 exec 中调用了 load_elf_binary 的时候，又把这个 flag 去掉。\n\n\n\n\n运行统计信息\nu64        utime;&#x2F;&#x2F;用户态消耗的CPU时间\nu64        stime;&#x2F;&#x2F;内核态消耗的CPU时间\nunsigned long      nvcsw;&#x2F;&#x2F;自愿(voluntary)上下文切换计数\nunsigned long      nivcsw;&#x2F;&#x2F;非自愿(involuntary)上下文切换计数\nu64        start_time;&#x2F;&#x2F;进程启动时间，不包含睡眠时间\nu64        real_start_time;&#x2F;&#x2F;进程启动时间，包含睡眠时间\n进程亲缘关系\n\nparent 指向其父进程。当它终止时，必须向它的父进程发送信号。children 表示链表的头部。链表中的所有元素都是它的子进程。sibling 用于把当前进程插入到兄弟链表中。\n\n\n进程权限\n\n用户组：real_cred 就是说明谁能操作我这个进程，而 cred 就是说明我这个进程能够操作谁，cred的定义如下：\nstruct cred &#123;\n    &#x2F;&#x2F;一般谁启动的进程，就是谁的ID，往往不比较这两个\n    kuid_t          uid;            &#x2F;* real UID of the task *&#x2F;\n    kgid_t          gid;            &#x2F;* real GID of the task *&#x2F;\n    \n    kuid_t          suid;           &#x2F;* saved UID of the task *&#x2F;\n    kgid_t          sgid;           &#x2F;* saved GID of the task *&#x2F;\n    &#x2F;&#x2F;当这个进程要操作消息队列、共享内存、信号量等对象的时候，\n    &#x2F;&#x2F;其实就是在比较这个用户和组是否有权限。\n    kuid_t          euid;           &#x2F;* effective UID of the task *&#x2F;\n    kgid_t          egid;           &#x2F;* effective GID of the task *&#x2F;\n\t&#x2F;&#x2F;对文件操作会审核的权限\n    kuid_t          fsuid;          &#x2F;* UID for VFS ops *&#x2F;\n    kgid_t          fsgid;          &#x2F;* GID for VFS ops *&#x2F;\n    &#x2F;&#x2F;......\n    kernel_cap_t    cap_inheritable; &#x2F;* caps our children can inherit *&#x2F;\n    kernel_cap_t    cap_permitted;  &#x2F;* caps we&#39;re permitted *&#x2F;\n    kernel_cap_t    cap_effective;  &#x2F;* caps we can actually use *&#x2F;\n    kernel_cap_t    cap_bset;       &#x2F;* capability bounding set *&#x2F;\n    kernel_cap_t    cap_ambient;    &#x2F;* Ambient capability set *&#x2F;\n    ......\n&#125; __randomize_layout;\n\n\n\n\n一般说来，fsuid、euid，和 uid 是一样的，fsgid、egid，和 gid 也是一样的。因为谁启动的进程，就应该审核启动的用户到底有没有这个权限。\\\n特殊情况chmod u+s program 命令，给文件设置set-user-ID的标识位，这样非文件所有者启动文件时，只有uid为启动者，其余euid和fsuid都仍为文件所有者\n\n\ncapabilities机制：用来平衡root权限过大和用户权限过小的问题，capabilities.h可以找到定义的权限\n#define CAP_CHOWN            0\n#define CAP_KILL             5\n#define CAP_NET_BIND_SERVICE 10\n#define CAP_NET_RAW          13\n#define CAP_SYS_MODULE       16\n#define CAP_SYS_RAWIO        17\n#define CAP_SYS_BOOT         22\n#define CAP_SYS_TIME         25\n#define CAP_AUDIT_READ          37\n#define CAP_LAST_CAP         CAP_AUDIT_READ\n\n\ncap_permitted 表示进程能够使用的权限。但是真正起作用的是 cap_effective。cap_permitted 中可以包含 cap_effective 中没有的权限。一个进程可以在必要的时候，放弃自己的某些权限，这样更加安全。假设自己因为代码漏洞被攻破了，但是如果啥也干不了，就没办法进一步突破。\ncap_bset，也就是 capability bounding set，是系统中所有进程允许保留的权限。如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限。即使以超级用户权限执行的进程，也是一样的。这样有很多好处。例如，系统启动以后，将加载内核模块的权限去掉，那所有进程都不能加载内核模块。这样，即便这台机器被攻破，也做不了太多有害的事情。\ncap_ambient 是比较新加入内核的，就是为了解决 cap_inheritable 鸡肋的状况，也就是，非 root 用户进程使用 exec 执行一个程序的时候，如何保留权限的问题。当执行 exec 的时候，cap_ambient 会被添加到 cap_permitted 中，同时设置到 cap_effective 中。\n\n\n\n\n用户态和内核态\n\n用户态函数栈和内核态函数栈\nstruct thread_info    thread_info;\n&#x2F;&#x2F;内核栈\nvoid  *stack;\n通过task_struct找内核栈\n\n如果有一个 task_struct 的 stack 指针在手，可以通过下面的函数找到这个线程内核栈\nstatic inline void *task_stack_page(const struct task_struct *task)&#123;\n    return task-&gt;stack;\n&#125;\n从 task_struct 如何得到相应的 pt_regs：先从 task_struct 找到内核栈的开始位置。然后这个位置加上 THREAD_SIZE 就到了最后的位置，然后转换为 struct pt_regs，再减一，就相当于减少了一个 pt_regs 的位置，就到了这个结构的首地址。（TOP_OF_KERNEL_STACK_PADDING在32位机上是8，其它是0，因为用户态到内核态权限改变会压栈保存SS、ESP寄存器，共占8个byte）\n#define task_pt_regs(task) \\\n(&#123;                  \\\n  unsigned long __ptr &#x3D; (unsigned long)task_stack_page(task);  \\\n  __ptr +&#x3D; THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;    \\\n  ((struct pt_regs *)__ptr) - 1;          \\\n&#125;)\n\n\n通过内核栈找task_struct\n\n就机制：thread_info结构中的task指向task_struct，用current_thread_info()-&gt;task来获取task_struct\n\n新的机制里面，每个 CPU 运行的 task_struct 不通过 thread_info 获取了，而是直接放在 Per CPU 变量里面了。多核情况下，CPU 是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个 CPU 之间的同步问题。Per CPU 变量就是为每个 CPU 构造一个变量的副本，这样多个 CPU 各自操作自己的副本，互不干涉。比如，当前进程的变量 current_task 就被声明为 Per CPU 变量。\n\n\n\n\n\n\n4.进程调度\n用于进程调度的字段：\n&#x2F;&#x2F;是否在运行队列上\nint        on_rq;\n&#x2F;&#x2F;优先级，实时进程（0~99）、普通进程（100~139）\nint        prio;\nint        static_prio;\nint        normal_prio;\nunsigned int      rt_priority;\n&#x2F;&#x2F;调度器类：包裹调度策略的执行逻辑\nconst struct sched_class  *sched_class;\n&#x2F;&#x2F;调度实体\nstruct sched_entity    se;&#x2F;&#x2F;完全公平调度实体\nstruct sched_rt_entity    rt;&#x2F;&#x2F;实时调度实体\nstruct sched_dl_entity    dl;&#x2F;&#x2F;deadline调度实体\n&#x2F;&#x2F;调度策略（6种）\nunsigned int      policy;\n&#x2F;&#x2F;可以使用哪些CPU\nint        nr_cpus_allowed;\ncpumask_t      cpus_allowed;\nstruct sched_info    sched_info;\n调度策略：\n\n实时调度策略：\n\nSCHED_FIFO： 先来先服务，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，遵循先来先得。\nSCHED_RR ：采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。\nSCHED_DEADLINE：是按照任务的 deadline 进行调度的。当产生一个调度点的时候，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务，并调度它执行。\n\n\n普通调度策略：\n\nSCHED_NORMAL：普通的进程\nSCHED_BATCH：是后台进程，几乎不需要和前端进行交互。这类项目可以默默执行，不要影响需要交互的进程，可以降低它的优先级。\nSCHED_IDLE：特别空闲的时候才跑的进程\n\n\n\n\n调度类有以下几种实现：\n\nstop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；\ndl_sched_class 就对应上面的 deadline 调度策略；\nrt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；\nfair_sched_class 就是普通进程的调度策略；CFS 调度算法（ Completely Fair Scheduling，叫完全公平调度），相当于 N 个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的\nidle_sched_class 就是空闲进程的调度策略。\n\n\n调度队列与调度实体\n\nCFS 调度算法通过红黑树来对 vruntime 进行排序，找出最小的那个。\n\n进程根据自己是实时的，还是普通的类型，通过这个成员变量，将自己挂在某一个数据结构里面，和其他的进程排序，等待被调度。例如：如果这个进程是个普通进程，则通过 sched_entity，将自己挂在这棵红黑树上。\nstruct sched_entity &#123;\n  struct load_weight    load;\n  struct rb_node      run_node;\n  struct list_head    group_node;\n  unsigned int      on_rq;\n  u64        exec_start;\n  u64        sum_exec_runtime;\n  u64        vruntime;\n  u64        prev_sum_exec_runtime;\n  u64        nr_migrations;\n  struct sched_statistics    statistics;\n&#x2F;&#x2F;......\n&#125;;\n红黑树存放的位置：每个 CPU 都有自己的 struct rq 结构，其用于描述在此 CPU 上所运行的所有进程，其包括一个实时进程队列 rt_rq 和一个 CFS 运行队列 cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去 CFS 运行队列找是否有进程需要运行。cfs_rq里存着红黑树的根节点。对于普通进程公平队列 cfs_rq，定义如下：\n&#x2F;* CFS-related fields in a runqueue *&#x2F;\nstruct cfs_rq &#123;\n  struct load_weight load;\n  unsigned int nr_running, h_nr_running;\n  u64 exec_clock;\n  u64 min_vruntime;\n#ifndef CONFIG_64BIT\n  u64 min_vruntime_copy;\n#endif\n  struct rb_root tasks_timeline;\n  struct rb_node *rb_leftmost;\n  struct sched_entity *curr, *next, *last, *skip;\n&#x2F;&#x2F;......\n&#125;;\n\n\n调度类如何工作\n\n调度类，这个结构定义了很多种方法，用于在队列上操作任务\nstruct sched_class &#123;\n    &#x2F;&#x2F;指向下一个调度类\n    const struct sched_class *next;\n\t&#x2F;&#x2F;向就绪队列中添加一个进程，当某个进程进入可运行状态时，调用这个函数\n    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n    &#x2F;&#x2F;将一个进程从就绪队列中删除\n    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*yield_task) (struct rq *rq);\n    bool (*yield_to_task) (struct rq *rq, struct task_struct *p, bool preempt);\n\n    void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);\n\t&#x2F;&#x2F;选择接下来要运行的进程\n    struct task_struct * (*pick_next_task) (struct rq *rq,\n                                            struct task_struct *prev,\n                                            struct rq_flags *rf);\n    &#x2F;&#x2F;用另一个进程代替当前运行的进程\n    void (*put_prev_task) (struct rq *rq, struct task_struct *p);\n\t&#x2F;&#x2F;用于修改调度策略\n    void (*set_curr_task) (struct rq *rq);\n    &#x2F;&#x2F;每次周期性时钟到的时候，这个函数被调用，可能触发调度\n    void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);\n    void (*task_fork) (struct task_struct *p);\n    void (*task_dead) (struct task_struct *p);\n\n    void (*switched_from) (struct rq *this_rq, struct task_struct *task);\n    void (*switched_to) (struct rq *this_rq, struct task_struct *task);\n    void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio);\n    unsigned int (*get_rr_interval) (struct rq *rq,struct task_struct *task);\n    void (*update_curr) (struct rq *rq)\n&#125;\n调度类都放在一个链表上，调度的时候是从优先级最高的调度类到优先级低的调度类，沿着上面的顺序，依次调用每个调度类的方法。对于每种调度类，有自己的具体实现。对于同样的 pick_next_task 选取下一个要运行的任务这个动作，不同的调度类有自己的实现，并且会操作不同的队列。\nstatic struct task_struct *\n    pick_next_task_rt(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n&#123;\n    struct task_struct *p;\n    struct rt_rq *rt_rq &#x3D; &amp;rq-&gt;rt;\n    &#x2F;&#x2F;......\n&#125;\n\nstatic struct task_struct *\n    pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n&#123;\n    struct cfs_rq *cfs_rq &#x3D; &amp;rq-&gt;cfs;\n    struct sched_entity *se;\n    struct task_struct *p;\n    &#x2F;&#x2F;......\n&#125;\n\n\n主动调度：schedule 函数调用，主要逻辑是在 __schedule 函数中实现的\nasmlinkage __visible void __sched schedule(void)&#123;\n    struct task_struct *tsk &#x3D; current;\n\n    sched_submit_work(tsk);\n    do &#123;\n        preempt_disable();\n        __schedule(false);\n        sched_preempt_enable_no_resched();\n    &#125; while (need_resched());\n&#125;\n\n&#x2F;&#x2F;上面这段代码的主要逻辑是在 __schedule 函数中实现的。\nstatic void __sched notrace __schedule(bool preempt)&#123;\n    struct task_struct *prev, *next;\n    unsigned long *switch_count;\n    struct rq_flags rf;\n    struct rq *rq;\n    int cpu;\n\n    &#x2F;&#x2F;首先，在当前的 CPU 上，取出任务队列 rq。\n    cpu &#x3D; smp_processor_id();\n    rq &#x3D; cpu_rq(cpu);\n    &#x2F;&#x2F;prev 指向这个 CPU 的任务队列上面正在运行的那个进程 curr\n    prev &#x3D; rq-&gt;curr;\n    &#x2F;&#x2F;其次，获取下一个任务，next 指向下一个任务，这就是继任\n    next &#x3D; pick_next_task(rq, prev, &amp;rf);\n    clear_tsk_need_resched(prev);\n    clear_preempt_need_resched();\n    &#x2F;&#x2F;最，后当选出的继任者和前任不同，就要进行上下文切换，继任者进程正式进入运行。\n    if (likely(prev !&#x3D; next)) &#123;\n        rq-&gt;nr_switches++;\n        rq-&gt;curr &#x3D; next;\n        ++*switch_count;\n        &#x2F;&#x2F;上下文切换，主要干两件事，一是切换进程空间，也即虚拟内存；二是切换寄存器和 CPU 上下文。\n        rq &#x3D; context_switch(rq, prev, next, &amp;rf);\n\n\n\n\npick_next_task依次调用调度类，因为大部分进程是普通进程，所以调用的是fair_sched_class.pick_next_task，即调用的是pick_next_task_fair\nstatic struct task_struct *\n    pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n&#123;\n    struct cfs_rq *cfs_rq &#x3D; &amp;rq-&gt;cfs;\n    struct sched_entity *se;\n    struct task_struct *p;\n    int new_tasks;\n    &#x2F;&#x2F;取出相应的队列cfc_rq（红黑树），并取出正在运行的任务curr\n    struct sched_entity *curr &#x3D; cfs_rq-&gt;curr;\n    if (curr) &#123;\n        if (curr-&gt;on_rq)\n            &#x2F;&#x2F;处于就绪状态，调用updata_curr更新vruntime\n            update_curr(cfs_rq);\n        else\n            curr &#x3D; NULL;\n    &#125;\n    &#x2F;&#x2F;从红黑树cfc_rq里面取最左边的一个节点\n    se &#x3D; pick_next_entity(cfs_rq, curr);\n    &#x2F;&#x2F;得到下一个调度实体对应的task_struct\n    p &#x3D; task_of(se);\n    &#x2F;&#x2F;如果发现继任和前任不一样，就说明有一个更需要运行的进程，就需要更新红黑树\n    &#x2F;&#x2F;前面继任的vruntime更新过了，put_prev_entity 放回红黑树，会找到相应的位置，\n    &#x2F;&#x2F;然后 set_next_entity 将继任者设为当前任务\n    if (prev !&#x3D; p) &#123;\n        struct sched_entity *pse &#x3D; &amp;prev-&gt;se;\n        put_prev_entity(cfs_rq, pse);\n        set_next_entity(cfs_rq, se);\n    &#125;\n    return p\n&#125;\ncontext_switch上下文切换：切换进程空间（虚拟内存）、切换寄存器和CPU上下文\nstatic __always_inline struct rq *\n    context_switch(struct rq *rq, struct task_struct *prev,\n                   struct task_struct *next, struct rq_flags *rf)\n&#123;\n    &#x2F;&#x2F;内存切换，用户栈也切换了\n    struct mm_struct *mm, *oldmm;\n    mm &#x3D; next-&gt;mm;\n    oldmm &#x3D; prev-&gt;active_mm;\n    switch_mm_irqs_off(oldmm, mm, next);\n    &#x2F;&#x2F;寄存器和栈的切换\n    switch_to(prev, next, prev);\n    &#x2F;&#x2F;编译器指令，用于保证switch_to和finish_task_switch的执行顺序，\n    &#x2F;&#x2F;不会因为编译优化而改变\n    barrier();\n    &#x2F;&#x2F;下面这句会从进程A切换到进程B，指令指针寄存器不变，因为进程的调度都最终会调用\n    &#x2F;&#x2F;到 __schedule 函数\n    return finish_task_switch(prev);\n&#125;\n\n\nswitch_to调用__switch_to_asm（主要用于栈顶指针的切换），有32位和64位两种实现，但最后都返回了__switch_to这个函数，以64位为例：\n__visible __notrace_funcgraph struct task_struct *\n    __switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n&#123;\n    struct thread_struct *prev &#x3D; &amp;prev_p-&gt;thread;\n    struct thread_struct *next &#x3D; &amp;next_p-&gt;thread;\n    int cpu &#x3D; smp_processor_id();\n    &#x2F;&#x2F;通过硬件方式（TSS结构）进行进程切换的模式每一个 CPU 关联一个 TSS，然后将\n    &#x2F;&#x2F;TR（任务寄存器）指向这个 TSS，然后在操作系统的运行过程中，TR 就不切换了\n    &#x2F;&#x2F;永远指向这个 TSS，真正参与进程切换的只有栈顶寄存器等少部分寄存器\n    struct tss_struct *tss &#x3D; &amp;per_cpu(cpu_tss, cpu);\n    load_TLS(next, cpu);\n    this_cpu_write(current_task, next_p);\n    &#x2F;* Reload esp0 and ss1.  This changes current_thread_info(). *&#x2F;\n    load_sp0(tss, next);\n    return prev_p;\n&#125;\n所谓的进程切换，就是将某个进程的 thread_struct 里面的寄存器的值，写入到 CPU 的 TR 指向的 tss_struct，对于 CPU 来讲，这就算是完成了切换。\n\n\n\n\n\n抢占式调度\n\n场景一：一个进程执行时间太长了，是时候切换到另一个进程了\n在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，时钟中断处理函数会调用 scheduler_tick()。这个函数先取出当前 CPU 的运行队列，然后得到这个队列上当前正在运行中的进程的 task_struct，然后调用这个 task_struct 的调度类的 task_tick 函数\ntask_tick函数中有check_preempt_tick函数，用来检查是否是时候被抢占了\n当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。因为一定要等待正在运行的进程调用 __schedule 才行，所以这里只能先标记一下。标记一个进程应该被抢占，都是调用 resched_curr，它会调用 set_tsk_need_resched，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签 TIF_NEED_RESCHED。\n\n\n场景二：当一个进程被唤醒的时候\n当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占。try_to_wake_up()调用 ttwu_queue 将这个唤醒的任务添加到队列当中。ttwu_queue 再调用 ttwu_do_activate 激活这个任务。ttwu_do_activate 调用 ttwu_do_wakeup。这里面调用了 check_preempt_curr检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当前进程，而是将当前进程标记为应该被抢占。\n\n\n抢占的时机（调用 __schedule，见前图）\n用户态的抢占时机\n从系统调用中返回的那个时刻，是一个被抢占的时机\n从中断中返回的那个时刻，也是一个被抢占的时机\n\n\n内核态的抢占时机\n对内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。\n在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机\n\n\n\n\n\n\n\n5.进程创建\nfork系统调用会在 sys_call_table 中找到相应的系统调用 sys_fork，根据 SYSCALL_DEFINE0 这个宏定义，定义了sys_fork，sys_fork 会调用 _do_fork，下面这段代码是_do_fork的定义和实现：\nSYSCALL_DEFINE0(fork)\n&#123;\n    return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);\n&#125;\n\nlong _do_fork(unsigned long clone_flags,unsigned long stack_start,unsigned long stack_size,\n              int __user *parent_tidptr,int __user *child_tidptr,unsigned long tls)&#123;\n    struct task_struct *p;\n    int trace &#x3D; 0;\n    long nr;\n    &#x2F;&#x2F;复制结构\n    p &#x3D; copy_process(clone_flags, stack_start, stack_size,\n                     child_tidptr, NULL, trace, tls, NUMA_NO_NODE);\n\n    if (!IS_ERR(p)) &#123;\n        struct pid *pid;\n        pid &#x3D; get_task_pid(p, PIDTYPE_PID);\n        nr &#x3D; pid_vnr(pid);\n        \n        if (clone_flags &amp; CLONE_PARENT_SETTID)\n            put_user(nr, parent_tidptr);\n\t\t&#x2F;&#x2F;唤醒新进程\n        wake_up_new_task(p);\n        \n        put_pid(pid);\n    &#125; \n&#125;\nfork 的第一件大事：复制结构copy_processstatic __latent_entropy struct task_struct *copy_process(\n    unsigned long clone_flags,\n    unsigned long stack_start,\n    unsigned long stack_size,\n    int __user *child_tidptr,\n    struct pid *pid,\n    int trace,\n    unsigned long tls,\n    int node)\n&#123;\n    int retval;\n    struct task_struct *p;\n    &#x2F;&#x2F;复制task_struct并创建内核栈\n    p &#x3D; dup_task_struct(current, node);\n    &#x2F;&#x2F;处理权限相关\n    retval &#x3D; copy_creds(p, clone_flags);\n    &#x2F;&#x2F;重新设置进程运行的统计量\n    p-&gt;utime &#x3D; p-&gt;stime &#x3D; p-&gt;gtime &#x3D; 0;\n    p-&gt;start_time &#x3D; ktime_get_ns();\n    p-&gt;real_start_time &#x3D; ktime_get_boot_ns();\n    &#x2F;&#x2F;设置调度相关的变量\n    retval &#x3D; sched_fork(clone_flags, p);\n    &#x2F;&#x2F;初始化与文件和文件系统相关的变量\n    retval &#x3D; copy_files(clone_flags, p);\n    retval &#x3D; copy_fs(clone_flags, p);\n    &#x2F;&#x2F;初始化与信号相关的变量\n    init_sigpending(&amp;p-&gt;pending);\n    retval &#x3D; copy_sighand(clone_flags, p);\n    retval &#x3D; copy_signal(clone_flags, p);\n    &#x2F;&#x2F;复制进程内存空间\n    retval &#x3D; copy_mm(clone_flags, p);\n    &#x2F;&#x2F;分配 pid，设置 tid，group_leader，并且建立进程之间的亲缘关系。\n    INIT_LIST_HEAD(&amp;p-&gt;children); \n    INIT_LIST_HEAD(&amp;p-&gt;sibling);\n    &#x2F;&#x2F;...\n&#125;\nfork 的第二件大事：唤醒新进程wake_up_new_task\nvoid wake_up_new_task(struct task_struct *p)\n&#123;\n    struct rq_flags rf;\n    struct rq *rq;\n    &#x2F;&#x2F;将进程的状态设置为 TASK_RUNNING\n    p-&gt;state &#x3D; TASK_RUNNING;\n\t&#x2F;&#x2F;根据调度方法不同，调用不同类（enqueue_task、enqueue_task_fair），唤醒对应进程\n    activate_task(rq, p, ENQUEUE_NOCLOCK);\n    p-&gt;on_rq &#x3D; TASK_ON_RQ_QUEUED;\n    trace_sched_wakeup_new(p);\n    &#x2F;&#x2F;看是否能够抢占当前进程，调用check_preempt_wakeup，这和函数里的wakeup_preempt_entity \n    &#x2F;&#x2F;将父进程和子进程 PK 一次，看是不是要抢占，如果要则调用 resched_curr 标记父进程为 TIF_NEED_RESCHED\n    check_preempt_curr(rq, p, WF_FORK);\n    &#x2F;&#x2F;......\n&#125;\n\n6.线程创建\n用户态创建线程pthread_create.c，调用create_thread\nint __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)&#123;\n\t&#x2F;&#x2F;处理线程的属性参数\n    const struct pthread_attr *iattr &#x3D; (struct pthread_attr *) attr;\n    struct pthread_attr default_attr;\n    if (iattr &#x3D;&#x3D; NULL)&#123;&#x2F;&#x2F;如果没有传入线程属性，就取默认值\n        iattr &#x3D; &amp;default_attr;\n    &#125;\n    &#x2F;&#x2F;维护一个task_struct 结构\n    struct pthread *pd &#x3D; NULL;\n    &#x2F;&#x2F;创建线程栈\n    int err &#x3D; ALLOCATE_STACK (iattr, &amp;pd);\n    &#x2F;&#x2F;确定用户态程序从哪里开始运行\n    &#x2F;&#x2F;start_routine 就是给线程的函数，start_routine，start_routine 的参数 arg，\n    &#x2F;&#x2F;以及调度策略都要赋值给 pthread。\n    pd-&gt;start_routine &#x3D; start_routine;\n    pd-&gt;arg &#x3D; arg;\n    pd-&gt;schedpolicy &#x3D; self-&gt;schedpolicy;\n    pd-&gt;schedparam &#x3D; self-&gt;schedparam;\n    &#x2F;* Pass the descriptor to the caller.  *&#x2F; \n    *newthread &#x3D; (pthread_t) pd;\n    &#x2F;&#x2F; __nptl_nthreads 加一，说明又多了一个线程。\n    atomic_increment (&amp;__nptl_nthreads);\n    &#x2F;&#x2F;真正创建线程\n    retval &#x3D; create_thread (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);\n&#125;\n\nstatic int\n    create_thread (struct pthread *pd, const struct pthread_attr *attr,\n                   bool *stopped_start, STACK_VARIABLES_PARMS, bool *thread_ran)\n&#123;\n    const int clone_flags &#x3D; (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | 0);\n    &#x2F;&#x2F;ARCH_CLONE，其实调用的是 __clone\n    &#x2F;&#x2F;当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向\n    &#x2F;&#x2F;线程将要执行的那个函数。所以这些都需要我们自己做，将线程要执行的函数的参数和指令的\t位置都压到栈里面\n    ARCH_CLONE (&amp;start_thread, STACK_VARIABLES_ARGS, clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)；\n        &#x2F;* It&#39;s started now, so if we fail below, we&#39;ll have to cancel it and let it clean itself up.  *&#x2F;\n        *thread_ran &#x3D; true;\n&#125;\n\n\n接下来我们就要进入内核了。创建线程的话，调用的是系统调用 clone，在 copy_process 函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。内核里面对于 clone 系统调用的定义是这样的：\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n     int __user *, parent_tidptr,\n     int __user *, child_tidptr,\n     unsigned long, tls)\n&#123;\n  return _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);\n&#125;\n用户态执行线程：根据 __clone 的第一个参数，回到用户态也不是直接运行我们指定的那个函数，而是一个通用的 start_thread，这是所有线程在用户态的统一入口。\n#define START_THREAD_DEFN \\\n  static int __attribute__ ((noreturn)) start_thread (void *arg)\n\nSTART_THREAD_DEFN\n&#123;\n    struct pthread *pd &#x3D; START_THREAD_SELF;\n    &#x2F;* Run the code the user provided.  *&#x2F;\n    THREAD_SETMEM (pd, result, pd-&gt;start_routine (pd-&gt;arg));\n    &#x2F;* Call destructors for the thread_local TLS variables.  *&#x2F;\n    &#x2F;* Run the destructor for the thread-local data.  *&#x2F;\n    __nptl_deallocate_tsd ();\n    if (__glibc_unlikely (atomic_decrement_and_test (&amp;__nptl_nthreads)))\n        &#x2F;* This was the last thread.  *&#x2F;\n        exit (0);\n    &#x2F;&#x2F;__free_tcb 用于释放 pthread。\n    __free_tcb (pd);\n    __exit_thread ();\n&#125;\n\n4.内存管理1.内存管理\n\n\n\n\n\n\n\n\n内存已经被分成一块一块的，并且编好了地址，通过地址可以定位到物理内存的位置。但是物理地址对于进程不可见，指令操作的地址是操作系统分配的虚拟地址，操作系统会通过一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来，以供互相转换。\n\n虚拟地址空间容量：如果是 32 位，有 2^32 = 4G 的内存空间，不管内存是不是真的有 4G。如果是 64 位，在 x86_64 下面，只使用了 48 位，48 位地址长度有256TB 的地址空间。\n\n虚拟地址空间划分：内核空间（用来存放内核相关，在低地址）、用户空间（用来存放进程相关，在高地址）\n\n用户空间地址名称，从低位开始0-&gt;X：\nText Segment：存二进制可执行代码\nData Segment：存静态常量\nBSS Segment：存未初始化的静态常量\nHeap（堆段）：往高地址增长，用来动态分配内存的区域\nMemory Mapping Segment：用来把文件映射到内存，例如将动态链接库（so文件）映射到内存中\nStack（栈段）：向低地址增长，主线程的函数调用的函数栈\n\n\n内核空间，从X-&gt;N：\n用户空间不同进程内容不同，但是一旦调用系统调用，进入内核，看到的都是同一个内核空间，所以要访问公共的数据结构需要锁保护\n内核里面也会有内核的代码，同样有 Text Segment、Data Segment 和 BSS Segment，因为内核代码也是 ELF 格式的\n\n\n\n\n如何将虚拟地址映射为物理地址\n\n分段机制：将虚拟空间分成多个段（不同大小）进行保存，虚拟地址由段选择子和段内偏移量组成，段选择子里有段号作为段表的索引，段表中保存着段基地址、段界限、特权等级。物理内存地址=段基地址+段内偏移量\n\nLinux的分段（所有段的起始地址为0）：\n\n段表全称段描述符表（segment descriptors），放在全局描述符表GDT（Global Descriptor Table）里面，会有下面的宏来初始化段描述符表里面的表项，一个段表项由段基地址base、段界限limit，和一些其它标识符组成：\n#define GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \\\n    .a &#x3D; ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \\\n    .b &#x3D; (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \\\n      ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \\\n  &#125; &#125; &#125;\n对于64位和32位，都定义了内核代码段、内核数据段、用户代码段、用户数据段\nDEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) &#x3D; &#123; .gdt &#x3D; &#123;\n#ifdef CONFIG_X86_64\n  [GDT_ENTRY_KERNEL32_CS]    &#x3D; GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),\n  [GDT_ENTRY_KERNEL_CS]    &#x3D; GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),\n  [GDT_ENTRY_KERNEL_DS]    &#x3D; GDT_ENTRY_INIT(0xc093, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER32_CS]  &#x3D; GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_DS]  &#x3D; GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_CS]  &#x3D; GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),\n#else\n  [GDT_ENTRY_KERNEL_CS]    &#x3D; GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),\n  [GDT_ENTRY_KERNEL_DS]    &#x3D; GDT_ENTRY_INIT(0xc092, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_CS]  &#x3D; GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_DS]  &#x3D; GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),\n......\n#endif\n&#125; &#125;;\nEXPORT_PER_CPU_SYMBOL_GPL(gdt_page);\n还会定义四个段选择子，指向上面的段描述符表项。（内核初始化时，启动第一个用户态进程，就将这四个值赋值给段寄存器）：\n#define __KERNEL_CS      (GDT_ENTRY_KERNEL_CS*8)\n#define __KERNEL_DS      (GDT_ENTRY_KERNEL_DS*8)\n#define __USER_DS      (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)\n#define __USER_CS      (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)\n\n\nLinux的分页（Paging）：\n\n把物理内存都分成了大小相同的页（4KB），在硬盘和内存间进行换入、换出操作\n虚拟地址分为两部分，页号和页内偏移，页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。\n由于页表项太多，并且要求是连续的，所以将页表再分页：\n对于32位系统：\n对于64位系统：\n\n\n\n\n\n\n\n2.进程空间管理\n用户态和内核态的划分\n\ntask_struct中有一个 struct mm_struct *mm用来管理内存，在其中有一个task_size成员变量，用来定义用户地址空间和内核地址空间的分界线。\n对于32位系统，用户态虚拟地址空间是3G，内核态是1G\n对于64位系统，虚拟地址只使用了48位，用户态用户态用了低地址的128T，内核态用了高地址的128T，中间的空隙用来进行隔离\n\n\n\n\n用户态布局\n\n在struct mm_struct *mm里面，通过变量定义了如代码、全局变量、堆、栈、内存映射区等区域的统计信息和位置\n&#x2F;&#x2F; 表示虚拟地址空间中用于内存映射的起始地址 一般情况下，这个空间是从高地址到低地址\n&#x2F;&#x2F;增长的。 malloc 申请一大块内存的时候，就是通过 mmap 在这里映射一块区域到物理内存。\n&#x2F;&#x2F;加载动态链接库 so 文件，也是在这个区域里面，映射一块区域到 so 文件\nunsigned long mmap_base; \nunsigned long total_vm;    &#x2F;* Total pages mapped ,物理内存不够时有些页可以换出*&#x2F;\nunsigned long locked_vm;  &#x2F;* 被锁定不能换出*&#x2F;\nunsigned long pinned_vm;  &#x2F;*不能换出，不能移动 *&#x2F;\nunsigned long data_vm;    &#x2F;* 存放数据的页的数目 *&#x2F;\nunsigned long exec_vm;    &#x2F;* 存放可执行文件的页的数目 *&#x2F;\nunsigned long stack_vm;    &#x2F;* 栈所占的页的数目*&#x2F;\n&#x2F;&#x2F;start_code, end_code 表示可执行代码的开始和结束位置\n&#x2F;&#x2F;start_data, end_data 表示已初始化数据的开始位置和结束位置\nunsigned long start_code, end_code, start_data, end_data;\n&#x2F;&#x2F;start_brk 堆的起始位置, brk 堆当前的结束位置（malloc）, start_stack 栈的起始位置\nunsigned long start_brk, brk, start_stack;\n&#x2F;&#x2F;arg_start, arg_end  参数列表的位置,env_start, env_end环境变量的位置位于栈中最高地址\nunsigned long arg_start, arg_end, env_start, env_end;\n\n\n&#x2F;&#x2F;用来描述上面区域的属性，是一个单链表，用于将这些区域串起来，另外还有一个红黑树，\n&#x2F;&#x2F;为了快速查找内存。在进程调度的时候用的也是红黑树（查找和删除都很快），代码见下\nstruct vm_area_struct *mmap; &#x2F;* list of VMAs *&#x2F;\nstruct rb_root mm_rb;\n\nstruct vm_area_struct &#123;\n    &#x2F;*vm_start ，vm_end 制定了该区域在用户空间中的起始和结束地址*&#x2F;\n    unsigned long vm_start;    &#x2F;* Our start address within vm_mm. *&#x2F;\n    unsigned long vm_end;    &#x2F;* The first byte after our end address within vm_mm. *&#x2F;\n    &#x2F;* *vm_next, *vm_prev 将这个区域串在链表上*&#x2F;\n    struct vm_area_struct *vm_next, *vm_prev;\n\t&#x2F;* vm_rb将这个区域放在红黑树上*&#x2F;\n    struct rb_node vm_rb;\n    struct mm_struct *vm_mm;  &#x2F;* The address space we belong to. *&#x2F;\n    struct list_head anon_vma_chain; &#x2F;* Serialized by mmap_sem &amp;* page_table_lock *&#x2F;\n    struct anon_vma *anon_vma;  &#x2F;* 映射到物理内存的虚拟内存区域，也称匿名映射*&#x2F;\n    &#x2F;* 对这个内存区域可以做的操作的定义*&#x2F;\n    const struct vm_operations_struct *vm_ops;\n    struct file * vm_file;    &#x2F;* 映射到文件就需要vm_file指定被映射的文件 *&#x2F;\n    void * vm_private_data;    &#x2F;* was vm_pte (shared mem) *&#x2F;\n&#125; __randomize_layout;\nvm_area_struct如何映射到mm_struct的内存区域，这个事情是在 load_elf_binary 里面实现的。加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。当 exec 运行一个二进制程序的时候，除了解析 ELF 的格式之外，另外一个重要的事情就是建立内存映射。\nstatic int load_elf_binary(struct linux_binprm *bprm)\n&#123;\n    &#x2F;&#x2F;设置内存映射区mmap_base\n    setup_new_exec(bprm);\n    &#x2F;&#x2F;设置栈的vm_area_struct，这里面设置了 mm-&gt;arg_start 是指向栈底的，\n    &#x2F;&#x2F;current-&gt;mm-&gt;start_stack 就是栈底\n    retval &#x3D; setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n                             executable_stack);\n    &#x2F;&#x2F;将 ELF 文件中的代码部分映射到内存中来\n    error &#x3D; elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,\n                    elf_prot, elf_flags, total_size);\n    &#x2F;&#x2F;设置了堆的 vm_area_struct，这里面设置了 ：\n    &#x2F;&#x2F;current-&gt;mm-&gt;start_brk &#x3D; current-&gt;mm-&gt;brk，也即堆里面还是空的\n    retval &#x3D; set_brk(elf_bss, elf_brk, bss_prot);\n    &#x2F;&#x2F;将依赖的 so 映射到内存中的内存映射区域\n    elf_entry &#x3D; load_elf_interp(&amp;loc-&gt;interp_elf_ex,\n                                interpreter,\n                                &amp;interp_map_addr,\n                                load_bias, interp_elf_phdata);\n    &#x2F;&#x2F;......\n    current-&gt;mm-&gt;end_code &#x3D; end_code;\n    current-&gt;mm-&gt;start_code &#x3D; start_code;\n    current-&gt;mm-&gt;start_data &#x3D; start_data;\n    current-&gt;mm-&gt;end_data &#x3D; end_data;\n    current-&gt;mm-&gt;start_stack &#x3D; bprm-&gt;p;\n    &#x2F;&#x2F;......\n&#125;\n修改以上布局的时机：\n\n函数调用：涉及函数栈的改变，主要是改变栈顶指针\n通过malloc申请一个堆内的空间，底层要么执行brk，要么执行mmap\nbrk系统调用的入口是sys_brk，此函数的参数brk是新的堆顶位置，而当前的mm-&gt;brk是原来堆顶的位置。首先按照页对齐地址看是否在一个页里，如果在就直接设置mm-&gt;brk为新的brk，如果不在同一页，则根据堆顶大小判断是释放内存（do_munmap）还是扩大内存（fina_vma，内存不够返回或者调用do_brk分配内存）\n\n\n\n\n\n\n内核态的布局\n\n32位\n直接映射区：空间连续，地址减去3G就是物理内存的位置，即在物理内存的开始的 896M 的空间，会被直接映射到 3G 至 3G+896M 的虚拟地址\n在系统启动的时候，物理内存的前 1M 已经被占用了，从 1M 开始加载内核代码段，然后就是内核的全局变量、BSS 等，也是 ELF 里面涵盖的。这样内核的代码段，全局变量，BSS 也就会被映射到 3G 后的虚拟地址空间里面。具体的物理内存布局可以查看 /proc/iomem\n在内核运行的过程中，如果碰到系统调用创建进程，会创建 task_struct 这样的实例，内核的进程管理代码会将实例创建在 3G 至 3G+896M 的虚拟空间中\n如果电脑内存小于3G，那么内核能使用的虚拟内存地址，只剩下1G减去896M的空间，于是将剩下的虚拟内存地址分成如下几个部分：\nVMALLOC_START 到 VMALLOC_END 之间称为内核动态映射空间，也即内核想像用户态进程一样 malloc 申请内存，在内核里面可以使用 vmalloc。内存过小时，剩下的物理地址就靠这一段的虚拟地址进行映射\nPKMAP_BASE 到 FIXADDR_START 的空间称为持久内核映射。使用 alloc_pages() 函数的时候，在物理内存的高端内存得到 struct page 结构，可以调用 kmap 将其映射到这个区域。\nFIXADDR_START 到 FIXADDR_TOP(0xFFFF F000) 的空间，称为固定映射区域，主要用于满足特殊需求。\n在最后一个区域可以通过 kmap_atomic 实现临时内核映射。\n\n\n\n\n64位\n从 0xffff800000000000 开始就是内核的部分，只不过一开始有 8T 的空档区域。\n从 __PAGE_OFFSET_BASE(0xffff880000000000) 开始的 64T 的虚拟地址空间是直接映射区域，也就是减去 PAGE_OFFSET 就是物理地址。\n从 VMALLOC_START（0xffffc90000000000）开始到 VMALLOC_END（0xffffe90000000000）的 32T 的空间是给 vmalloc 的。\n从 VMEMMAP_START（0xffffea0000000000）开始的 1T 空间用于存放物理页面的描述结构 struct page 的。\n从 __START_KERNEL_map（0xffffffff80000000）开始的 512M 用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 __START_KERNEL_map 就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有 8T 的空当区域，早就过了内核代码在物理内存中加载的位置。\n\n\n\n\n\n3.物理内存管理\n物理内存的组织方式\n\n平坦内存模型（Flat Memory Model）：连续的一页一页组成，每个页大小相同，对于任何一个地址，只要直接除一下每页的大小，就很容易算出在哪一页\nSMP（Symmetric multiprocessing 对称多处理器）：通过总线连接多个CPU和多个内存条组成的一大片内存，但是总线会成为瓶颈\nNUMA（Non-uniform memory acess 非一致内存访问）：每个CPU都有自己的本地内存，CPU访问本地内存不用过总线，每个CPU和内存在一起称为NUMA节点，这个时候就需要非连续内存模型\n\n\nNUMA节点：用typedef struct pglist_data pg_data_t来表示NUMA节点，有以下成员变量：\ntypedef struct pglist_data &#123;\n    &#x2F;&#x2F;每一个节点分成一个个区域 zone，放在数组 node_zones 里面。大小为 MAX_NR_ZONES\n    struct zone node_zones[MAX_NR_ZONES];\n    &#x2F;&#x2F;备用节点和它的内存区域的情况，NUMA自己的内存不够可以去其他节点进行分配\n    struct zonelist node_zonelists[MAX_ZONELISTS];\n    int nr_zones;\n    &#x2F;&#x2F;这个节点的 struct page 数组，用于描述这个节点里面的所有的页\n    struct page *node_mem_map;\n    &#x2F;&#x2F; 是这个节点的起始页号\n    unsigned long node_start_pfn;\n    &#x2F;&#x2F;是真正可用的物理页面的数目\n    unsigned long node_present_pages; &#x2F;* total number of physical pages *&#x2F;\n    &#x2F;&#x2F;个节点中包含不连续的物理内存地址的页面数\n    unsigned long node_spanned_pages; &#x2F;* total size of physical page range, including holes *&#x2F;\n    &#x2F;&#x2F;每一个节点都有自己的 ID\n    int node_id;\n    &#x2F;&#x2F;......\n&#125; pg_data_t;\n\n&#x2F;&#x2F;区域enum的类型\nenum zone_type &#123;\n    #ifdef CONFIG_ZONE_DMA\n    \t&#x2F;&#x2F;DMA，直接内存存取内存，用于DMA机制\n    \tZONE_DMA,\n    #endif\n    #ifdef CONFIG_ZONE_DMA32\n    \t&#x2F;&#x2F;对于64位OS有两块DMA内存\n   \t\tZONE_DMA32,\n    #endif\n    \t&#x2F;&#x2F;直接映射区，从物理内存到虚拟内存的内核区域，通过加上一个常量直接映射\n    \tZONE_NORMAL,\n    #ifdef CONFIG_HIGHMEM\n    \t&#x2F;&#x2F;高端内存区，对于32位系统来说超过896M的地方，64位没有\n    \tZONE_HIGHMEM,\n    #endif\n    \t&#x2F;&#x2F;可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片\n    \tZONE_MOVABLE,\n    \t&#x2F;&#x2F;当前节点的区域数量\n    \t__MAX_NR_ZONES\n&#125;;\n区域：节点分成了区域，用zone表示区域\nstruct zone &#123;\n    \n    struct pglist_data  *zone_pgdat;\n    &#x2F;&#x2F;用于区分冷热页，如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），\n    &#x2F;&#x2F;CPU 读起来速度会快很多，如果没有就是冷页（Cold Page）\n    struct per_cpu_pageset __percpu *pageset;\n\n\t&#x2F;&#x2F;表示属于这个zone的第一个页\n    unsigned long    zone_start_pfn;\n\n    &#x2F;&#x2F;present_pages &#x3D; spanned_pages - absent_pages(pages in holes);真实存在的page数目\n    unsigned long    managed_pages;\n    &#x2F;&#x2F;spanned_pages &#x3D; zone_end_pfn - zone_start_pfn;中间会出现物理空洞\n    unsigned long    spanned_pages;\n    &#x2F;&#x2F;managed_pages &#x3D; present_pages - reserved_pages;本zone被伙伴系统管理的所有page数目\n    unsigned long    present_pages;\n\n    const char    *name;\n    \n    &#x2F;* free areas of different sizes *&#x2F;\n    &#x2F;&#x2F;页分配，伙伴系统，MAX_ORDER为11\n    struct free_area  free_area[MAX_ORDER];\n\n    &#x2F;* zone flags, see below *&#x2F;\n    unsigned long    flags;\n\n    &#x2F;* Primarily protects free_area *&#x2F;\n    spinlock_t    lock;\n    &#x2F;&#x2F;......\n&#125; ____cacheline_internodealigned_in_\n页及页的分配\n\n页：\n\n第一种模式，要用就用一整页。这一整页的内存，或者直接和虚拟地址空间建立映射关系，称为匿名页（Anonymous Page）。或者用于关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为内存映射文件（Memory-mapped File）。\n第二种模式，仅需分配小块内存。例如分配一个 task_struct 结构，只需要分配小块的内存，去存储这个进程描述结构的对象。 slab allocator 技术，用于分配称为 slab 的一小块内存。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 / 被放回池子 / 应该被回收）。\n\nstruct page &#123;\n    unsigned long flags;\n    union &#123;\n        &#x2F;&#x2F;用于内存映射，如果是匿名页最低位为1，如果是映射文件最低为为0\n        struct address_space *mapping;  \n        &#x2F;&#x2F;模式二，已经分配了正在使用的slab的第一个对象\n        void *s_mem;      &#x2F;* slab first object *&#x2F;\n        atomic_t compound_mapcount;  &#x2F;* first tail page *&#x2F;\n    &#125;;\n    union &#123;\n        &#x2F;&#x2F;模式一，映射区的偏移量\n        pgoff_t index;    &#x2F;* Our offset within mapping. *&#x2F;\n        &#x2F;&#x2F;模式二，池子中的空闲对象\n        void *freelist;    &#x2F;* sl[aou]b first free object *&#x2F;\n    &#125;;\n    union &#123;\n        unsigned counters;\n        struct &#123;\n            union &#123;\n                &#x2F;&#x2F;模式一，每个进程都有自己的页表，这里指有多少个页表项指向了这个页\n                atomic_t _mapcount;\n                unsigned int active;    &#x2F;* SLAB *&#x2F;\n                struct &#123;      &#x2F;* SLUB *&#x2F;\n                    unsigned inuse:16;\n                    unsigned objects:15;\n                    unsigned frozen:1;\n                &#125;;\n                int units;      &#x2F;* SLOB *&#x2F;\n            &#125;;\n            atomic_t _refcount;\n        &#125;;\n    &#125;;\n    union &#123;\n        &#x2F;&#x2F;模式一，表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中\n        struct list_head lru;  &#x2F;* Pageout list   *&#x2F;\n        struct dev_pagemap *pgmap; \n        struct &#123;    &#x2F;* slub per cpu partial pages *&#x2F;\n            struct page *next;  &#x2F;* Next partial slab *&#x2F;\n            int pages;  &#x2F;* Nr of partial slabs left *&#x2F;\n            int pobjects;  &#x2F;* Approximate # of objects *&#x2F;\n        &#125;;\n        &#x2F;&#x2F;模式二，需要释放的列表\n        struct rcu_head rcu_head;\n        struct &#123;\n            unsigned long compound_head; &#x2F;* If bit zero is set *&#x2F;\n            unsigned int compound_dtor;\n            unsigned int compound_order;\n        &#125;;\n    &#125;;\n    union &#123;\n        unsigned long private;\n        struct kmem_cache *slab_cache;  &#x2F;* SL[AU]B: Pointer to slab *&#x2F;\n    &#125;;\n   &#x2F;&#x2F; ......\n&#125;\n页的分配\n\n伙伴系统（Buddy System）：分配比较大的内存，例如页级别的。把所有的空闲页分组为 11 个页块链表，每个块链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块。\n\n分配：先找合适的，没有则分裂大的\nstatic inline struct page *\n    alloc_pages(gfp_t gfp_mask, unsigned int order)\n&#123;\n    return alloc_pages_current(gfp_mask, order);\n&#125;\n&#x2F;**\n *   alloc_pages_current - Allocate pages.\n *  gfp表示希望在哪个区域中分配这个内存\n *  @gfp:\n *    %GFP_USER   用于分配一个页映射到用户进程的虚拟地址空间\n *        %GFP_KERNEL 用于内核中分配页，主要分配ZONE_NORMAL\n *        %GFP_HIGHMEM 主要分配高端区域的内存\n *        %GFP_FS     don&#39;t call back into a file system.\n *        %GFP_ATOMIC don&#39;t sleep.\n *  @order: 表示分配2的order次方个页\n *&#x2F;\nstruct page *alloc_pages_current(gfp_t gfp, unsigned order)\n&#123;\n    struct mempolicy *pol &#x3D; &amp;default_policy;\n    struct page *page;\n    &#x2F;&#x2F;核心方法，在一个循环中先看当前节点的zone，如果找不到空闲页，则再看备用节点\n    &#x2F;&#x2F;的zone。每一个zone都有伙伴系统维护的各种大小的队列\n    page &#x3D; __alloc_pages_nodemask(gfp, order,\n                                  policy_node(gfp, pol, numa_node_id()),\n                                  policy_nodemask(gfp, pol));\n    &#x2F;&#x2F;......\n    return page;\n&#125;\n\n\n\n\n小内存的分配（slub分配器）：将从伙伴系统申请的大内存切成小内存，分配给其它系统\n\n在创建进程复制一个task_struct时，调用了kmem_cache_alloc_node函数，在task_struct的缓存区域task_struct_cachep分配了一块内存\n在系统初始化的时候，task_struct对象被分配了名字为task_struct的缓存，缓存区每一块的大小正好等于task_struct的大小，每次创建task_struct的时候，kmem_cache_alloc_node现在缓存里找内存来分配。当一个进程结束，task_struct 也不用直接被销毁，而是放回到缓存中，这就是 kmem_cache_free 的作用。\n在分配缓存块的时候，要分两种路径，fast path 和 slow path，也就是快速通道和普通通道。其中 kmem_cache_cpu 就是快速通道，kmem_cache_node 是普通通道。每次分配的时候，要先从 kmem_cache_cpu 进行分配。如果 kmem_cache_cpu 里面没有空闲的块，那就到 kmem_cache_node 中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。\n\n\n页面换出\n\n分配内存时没有地方了，试图回收一下。申请一个页面的时候，会调用 get_page_from_freelist，接下来的调用链为 get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node，通过这个调用链可以看出，页面换出也是以内存节点为单位的\n\n内存管理系统主动去做的：kswapd，在系统初始化的时候就被创建。这样它会进入一个无限循环，直到系统停止。在这个循环中，如果内存使用没有那么紧张，那就不需要他；如果内存紧张了，就需要去检查一下内存，看看是否需要换出一些内存页\n&#x2F;*\n * The background pageout daemon, started as a kernel thread\n * from the init process.\n *\n * This basically trickles out pages so that we have _some_\n * free memory available even if there is no other activity\n * that frees anything up. This is needed for things like routing\n * etc, where we otherwise might have all activity going on in\n * asynchronous contexts that cannot page things out.\n *\n * If there are applications that are active memory-allocators\n * (most normal use), this basically shouldn&#39;t matter.\n *&#x2F;\nstatic int kswapd(void *p)\n&#123;\n    unsigned int alloc_order, reclaim_order;\n    unsigned int classzone_idx &#x3D; MAX_NR_ZONES - 1;\n    pg_data_t *pgdat &#x3D; (pg_data_t*)p;\n    struct task_struct *tsk &#x3D; current;\n\n\n    for ( ; ; ) &#123;\n        &#x2F;&#x2F;......\n        kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,\n                            classzone_idx);\n        &#x2F;&#x2F;这里的调用链是 balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node，\n        &#x2F;&#x2F;是以内存节点为单位的，最后也是调用 shrink_node\n        reclaim_order &#x3D; balance_pgdat(pgdat, alloc_order, classzone_idx);\n        &#x2F;&#x2F;shrink_node会调用shrink_node_memcg，这里有一个循环处理页面的lru列表\n    &#125;\n&#125;\n\n内存页总共分两类，一类是匿名页，和虚拟地址空间进行关联；一类是内存映射，不但和虚拟地址空间关联，还和文件管理关联。它们每一类都有两个列表，一个是 active，一个是 inactive。顾名思义，active 就是比较活跃的，inactive 就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。\n\n\n\n\n4.用户态内存映射\nmmap原理\n\n用途：申请一大块内存、文件映射到进程的虚拟内存空间\n\n映射到文件：mmap收到一个文件描述符，通过描述符获得struct file，然后依次调用sys_mmap_pgoff-&gt;do_mmap_pgoff-&gt;do_mmap，在这之中有两个主要操作：\n\n调用get_unmapped_area来找到一个没有映射的区域，无论是匿名映射还是映射到文件，最后都会调用mm_struct里面的get_unmapped_area\n&#x2F;&#x2F;匿名映射\nunsigned long\n    get_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n                      unsigned long pgoff, unsigned long flags)\n&#123;\n    unsigned long (*get_area)(struct file *, unsigned long,\n                              unsigned long, unsigned long, unsigned long);\n    get_area &#x3D; current-&gt;mm-&gt;get_unmapped_area;\n    if (file) &#123;\n        if (file-&gt;f_op-&gt;get_unmapped_area)\n            get_area &#x3D; file-&gt;f_op-&gt;get_unmapped_area;\n    &#125; \n&#125;\n&#x2F;&#x2F;映射到文件\nconst struct file_operations ext4_file_operations &#x3D; &#123;\n    .mmap           &#x3D; ext4_file_mmap\n        .get_unmapped_area &#x3D; thp_get_unmapped_area,\n&#125;;\nunsigned long __thp_get_unmapped_area(struct file *filp, unsigned long len,\n                                      loff_t off, unsigned long flags, unsigned long size)\n&#123;\n    unsigned long addr;\n    loff_t off_end &#x3D; off + len;\n    loff_t off_align &#x3D; round_up(off, size);\n    unsigned long len_pad;\n    len_pad &#x3D; len + size;\n    &#x2F;&#x2F;......\n    addr &#x3D; current-&gt;mm-&gt;get_unmapped_area(filp, 0, len_pad,\n                                          off &gt;&gt; PAGE_SHIFT, flags);\n    addr +&#x3D; (off - addr) &amp; (size - 1);\n    return addr;\n&#125;\n调用mmap_region来映射这个虚拟内存区域，\nunsigned long mmap_region(struct file *file, unsigned long addr,\n                          unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n                          struct list_head *uf)\n&#123;\n    struct mm_struct *mm &#x3D; current-&gt;mm;\n    struct vm_area_struct *vma, *prev;\n    struct rb_node **rb_link, *rb_parent;\n\n&#x2F;&#x2F;之前已经找到虚拟内存区域的其哪一个vm_area_struct，这里看是否可以和它合并到一起\n    vma &#x3D; vma_merge(mm, prev, addr, addr + len, vm_flags,\n                    NULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n    if (vma)\n        goto out;\n    \n    &#x2F;&#x2F;不能合并时，调用下面的函数，在Slub里面创建一个新的vm_area_struct对象，\n    &#x2F;&#x2F;设置起始和结束位置，将它加入队列\n    vma &#x3D; kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n    if (!vma) &#123;\n        error &#x3D; -ENOMEM;\n        goto unacct_error;\n    &#125;\n\n    vma-&gt;vm_mm &#x3D; mm;\n    vma-&gt;vm_start &#x3D; addr;\n    vma-&gt;vm_end &#x3D; addr + len;\n    vma-&gt;vm_flags &#x3D; vm_flags;\n    vma-&gt;vm_page_prot &#x3D; vm_get_page_prot(vm_flags);\n    vma-&gt;vm_pgoff &#x3D; pgoff;\n    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);\n\n    if (file) &#123;\n        vma-&gt;vm_file &#x3D; get_file(file);\n        &#x2F;&#x2F;映射到文件\n        error &#x3D; call_mmap(file, vma);\n        addr &#x3D; vma-&gt;vm_start;\n        vm_flags &#x3D; vma-&gt;vm_flags;\n    &#125; \n    &#x2F;&#x2F;将创建的vm_area_struct挂在了mm_struct里面的红黑树上，建立了内存到文件的映射\n    &#x2F;&#x2F;对于文件会有一个struct file，它有个成员指向struct address_space结构，这里面有棵名为i_mmap的红黑树，vm_area_struct就挂在这个树上\n    &#x2F;&#x2F;__vma_link_file建立文件到内存的映射\n    vma_link(mm, vma, prev, rb_link, rb_parent);\n    return addr;\n    &#x2F;&#x2F;.....\n&#125;\n\n\n\n\n用户态缺页异常\n\n\n5.内核态内存映射\n内核页表\nvmalloc&amp;kmap_atomic原理\n内核态缺页异常\n\n5.文件系统\nxfs文件系统：\n\n\n\n\n\n\n\n\n\nXFS是一个日志型的文件系统，能在断电以及操作系统崩溃的情况下保证数据的一致性。XFS将空间分为若干个分配组，每个分配组大小相等（最后一个可能不等）。分配组包含有超级块、inode管理和剩余空间管理等，所以分配组可以认为是一个单独的文件系统。正是分配组这样的设计，使得XFS拥有了并行IO的能力。在单个分区上使用XFS体现不了这种并行IO能力，但是如果文件系统跨越多个物理硬件比如ceph，并行IO将大大提高吞吐量利用率。\n\n超级块（superblock）：xfs_sb_t，包括了分配组和文件系统的全部元数据信息\nxfs_db查看超级块内容，执行xfs_db -r /dev/xxx(xxx为XFS所在的分区)，输入sb再输入p即可，如下图所示（鉴于篇幅未尽列出输出）\nblocksize块大小一般4kb，dblocks一个分配组还有的块数目，agcount整个文件含有的分配组数目，sectsize扇区大小，一般为512B，inodesize inode节点大小，一般为512B，icount整个文件系统目前已经分配的inode数目，ifree整个文件系统空闲的inode数目\n\n\n空闲块信息（AG free block info）：xfs_agf_t，主要描述两个空闲空间B+树和剩余空间信息\nxfs_db输入agf可查看空闲块信息\n空闲块信息包含了两颗空闲空间B+树，分别以block序号和block数目为关键字，满足两种不同的需求。\n\n\ninode信息：xfs_agi_t\ninode B+树信息：主要描述inode B+树的根block、已构造的inode个数以及空闲个数\nInode信息：每一个文件或目录都对应一个inode，用于描述文件的基本信息，除了目录或链接，inode不携带文件数据。\n\n\n内部空闲列表：xfs_agfl_t\n\n==inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。==\n\n\n\n6.输入输出系统7.进程间通信8.网络系统9.虚拟化10.容器化TCP/IP\n1.网络协议综述1.网络协议及网络分层\n协议三要素：语法+语义+顺序，通过网络协议可以是一大片机器相互协作，共同完成一件事\n\n网络协议示例（下单过程）：浏览器输入URL，其通过DNS或HTTPDNS来查找IP地址，应用层通过添加HTTP头封装（HTTP头结构），传输层选择UDP或TCP协议来封装（源和目的端口号），网络层使用IP协议封装（源IP和目的IP），通过链路层的MAC协议和DHCP分配的默认网关IP封装，通过ARP协议决定发到哪个默认网关，网关一般都是路由器，通过路由表知道到某个IP地址应该怎么走，而路由协议常用的有OSPF和BGP，在到达之后，往往最初接待这个请求的是Tomcat，负责统筹处理请求，告诉各自线程处理请求，另外需要通过RPC调用来告诉相关进程，待处理完之后，回复一个HTTPS的包。\n\n网络分层：\n\n原因：复杂的程序都要分层，这是程序设计的要求\n\n程序如何工作的：\n\n\nprocess_layer2：摘掉二层的头，看一看应该根据头里面的内容做什么操作，如果MAC相同则转发到下一层来处理\nprocess_layer3：摘掉三层的头，通过看IP地址是不是自己的，决定到底是发给自己的，还是希望转发出去的\nprocess_tcp：查看四层的头，看是发起、应答、还是正常数据包，来决定是发起或应答一个回复包，还是将数据包交给上层处理（根据端口号）\nprocess_http：处理发送给浏览器的，解析HTML，显示出页面\n\n\n层与层之间的关系\n\n套娃的关系，每一层都补充一部分，在网络上的包都是完整的，可以有下层没有上层，但不可以有上层没有下层，所以在TCP三次握手的时候，TCP每发一次消息，下面的IP层和MAC层也一直在忙碌\n\n所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已\n\n链路层的==ARP==协议完成IP地址和MAC地址的转换，==IP==用于在网络中找到目的主机，==DHCP==用于自动分配IP地址，==NAT==用于将内部IP地址转换为外部IP地址并实现防火墙功能，==ICMP==用于与其他主机或路由器的IP层之间交换差错信息（Ping，Traceroute），==TCP==用于保证可靠性传输，==DNS==用于把域名解析为IP地址，==HTTP==用于传输网页内容\n\n五层模型\n\n应用层(Application Layer)协议：FTP (文件传输)，SMTP (邮件)，HTTP (万维网)，DNS\n\n传输层(Transport Layer)（报文）功能：可靠传输/不可靠传输，差错处理，流量控制，复用分用协议：TCP（报文段）、UDP（用户数据报）\n\n网络层(Network Layer)（分组/数据报）功能：路由选择（最佳路径），流量控制，差错控制，拥塞控制\n协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF\n\n数据链路层(Data Link Layer)（帧）功能：成帧（定义帧的开始和结束），差错控制（帧错+位错），流量控制，访问接入控制（控制对信道的访问，CSMA/CD 表示载波监听多点接入 / 碰撞检测），物理寻址，信道复用技术(1. 频分复用，2. 时分复用，3. 统计时分复用，4.波分复用，5.码分复用)协议：SDLC、HDLC、PPP、STP、Ethernet\n\n物理层(physical Layer)功能：定义接口特性，定义传输模式（单工、半双工、双工），定义传输速率，比特同步，比特编码协议：Rj45、802.3设备：中继器：转发器、集线器（Hub）：多端口中继器，双绞线、同轴电缆、光纤、无线传输介质。\n\n\n\nOSI七层模型\n\n\n\n\n\n\n\n2.设备\n交换机本质上是高性能的网桥，\n\n网桥和交换机用于连接多个物理的链路层网络\n\n网桥使用==生成树协议（STP）或快速生成树协议（RSTP）==来找到网络拓扑结构中的一个生成树\n\n单机模式\n\n网线连接：将两个主机连起来\n\n中继器（Repeater）：解决网线不够长和距离太大数据会开始丢失的问题\n\n集线器（Hub）：解决中继器接口不够的问题，是一种多口中继器\n\n网桥（Bridge）：解决冲突域隔离，不同接口之间的数据不会相互冲突\n\n交换机（Switch）：相比于网桥接口数量更密集、高速转发、VLAN隔离，能够记录MAC表\n\n路由器（Router）：基于IP寻址，采用路由表实现数据转发，用于连接不同类型局域网\n\n无线AP（Access Point）：带有无线功能的交换机/路由器\n\n防火墙（Firewall）：用于对网络进行安全访问限制，一般用在互联网边缘，可看错待由安全功能的路由器\n\n流量控制：因为网络太拥挤，主要有负载均衡器、链路优化、上网行为管理\n\n\n3.Web 页面请求过程1. DHCP 配置主机信息\n假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。\n主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。\n该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。\n该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。\n连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。\n该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。\n主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。\n\n2. ARP 解析 MAC 地址\n主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。\n主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。\n该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。\n该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。\nDHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。\n主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。\n网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。\n\n3. DNS 解析域名\n知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。\n网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。\n因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。\n到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。\n找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。\n\n4. HTTP 请求页面\n有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。\n在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。\nHTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。\n连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。\nHTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。\n浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。\n\n2.底层网络知识详解1.数据链路层1.物理层\n寝室内组网，通过将网线水晶头的1-3、2-6交叉接，可以将两台主机构成一个局域网，即LAN。如果是三台机器，则需要一个集线器（Hub）\n\n2.MAC\nHub是广播模式，发出的包每个电脑都能收到，这样会出现多路访问堵车的问题，所以需要一个交换机（Bridge），将MAC头拿下来，检查目标MAC地址，然后根据策略（通过学习得到转发表）转发数据包\n\nMAC全称为Medium Access Control，即媒体访问控制，即控制在往媒体上发数据的时候，谁先发，谁后发的问题，即多路访问控制，主要有：信道划分、轮流协议、随机接入协议\n\nMAC地址：包括目的MAC地址和源MAC地址，然后是类型，大部分都是IP数据包，然后IP里面包含TCP、UDP、HTTP等，最后是CRC循环冗余检验，通过XOR异或算法来检错\n\n已知MAC地址，数据包在链路上广播，MAC的网卡才能发现这个包是给它的，然后将包收进来，查看IP，然后查看TCP的端口号，发送给对应进程处理，将返回信息在逐层封装\n\n没有MAC地址，需要利用ARP协议，利用已知的IP地址，求MAC地址。通过发送广播包来询问\n\n\n\nMAC帧格式\n\n类型字段用于确定协议类型：\nIPv4为0x0800\nIPv6为0x86DD\n\n\nFCS为帧校验序列：为待检查的消息追加n为0，除以一个n+1位的生成多项式，将余数取反放到FCS中\n链路层MTU为1500字节\n\n\n\n\n2.网络层1.查看IP地址\nifconfig、ip addr\n\nscope：如果是global，则此张网卡是可以对外开放的，可以接受各个地方的包；对于lo来说事host，说明这张网卡仅仅可以供本机相互通信\nlo全称是loopback，又称环回接口，往往会被分配到127.0.0.1这个地址，用于本机通信，经过内核处理后直接返回，不会再任何网络中出现。\nMAC地址：在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为 MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。因为MAC没有定位功能，所以需要IP地址来寻路\n网络设备的状态标识（net_device flags）：例如&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; ，UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。MTU1500 是指最大传输单元 MTU 为 1500，这是以太网的默认值。\n排队规则（qdisc pfifo_fast）：qdisc 全称是 queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。\n\n\nIP地址分类\n\n分类方式一：D类组播地址用于VXLAN协议\n\n\n分类方式二：无类型域间选路（CIDR）：将32位地址分为两部分，前面是网络号，后面是主机号，例如：。伴随着CIDR出现的有广播地址、子网掩码、网络号（子网掩码和IP地址按位算AND）\n\n共有IP和私有IP：共有IP统一分配需要购买\n\n\n\n\nIP数据报格式（==‘’一种八片首饰‘’==）\n\n\n版本 : 有 4（IPv4）和 6（IPv6）两个值；\n\n首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。\n\n区分服务 : 是一个框架和一组标准，用于支持RFC2474,RFC2475,RFC3260上不同类型的服务（即不只是尽力而为的服务，而是更好的服务）\n\n总长度 : 包括首部长度和数据部分长度，以字节为单位。\n\n生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。\n\n协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP（6）、UDP（17） 等。\n\n首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。\n\n标识 : 避免数据报分片的混淆，在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。\n\n片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。\n\n选项字段：很多选项已经被淘汰，只有一部分被留下来放在了IPv6的扩展头部中，\n\n\n\n\n2.IP获取\nDHCP协议：\n\n消息格式\n\n\nDHCP 工作过程如下：\n\n\n客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。\nDHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。\n如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。\nDHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。\n\n==助记==\n\n手动配置IP相当于自己买房装修，DHCP协议相当于租房\n新到一个城市要先找中介（DHCP服务器）租个房（IP）-Discover\n中介（DHCP）会带你看房，可能会有多个中介带你看多个房-Offer\n你看上其中一个房，愿意租下来-Request\n中介说没问题，咱们签合同，租约达成-Ack\n租约达成要广播，防止中介之间跳单\n租约快到之前，记得续租\n\n\n\n\nPXE（预启动执行环境）的工作过程\n\n\nARP\n\n帧格式\n\n\n硬件类型：1，协议类型：0x0800，硬件地址长度：6，协议地址长度：4\n\nop字段：ARP请求（值为1），ARP应答（2），RARP请求（3），RARP应答（4）\n\n在Linux查看ARP缓存：\n$arp -a\n\n\nARP协议原理\n\n每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。\n如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。\n以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。\n当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。\n如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”\n网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP高速缓存（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。\n\n\n\n\n\n\n\n3.拓扑结构\n交换机数量增多，就形成了一个稍微复杂的拓扑结构。拓扑结构最常见的问题就是环路问题，这就需要使用生成树算法STP（Spanning Tree Protocol）\n\n概念：Root Bridge（根交换机，即树根）、Designated Bridges（指定交换机，即树枝非叶子）、Bridge Protocol Data Units（网桥协议数据单元，比喻为相互比较实力的协议）、Priority Vector（优先级向量，比喻为实力）\n工作过程：\n所有节点将自己初始化为Root Bridge，每个网桥都初始化有一个ID，具有优先级，人工分配。\n互相发送BPDU来比实力，有四种不同情形，最终得出一个树\n\n\n\n\n解决广播问题和安全问题\n\n物理隔离：公司的每个部门有单独的交换机，配置单独的子网，部门间的沟通通过路由器\n\n虚拟隔离：通过VLAN，即虚拟局域网，只需要在二层的头上加一个TAG，里面有一个VLAN ID，一共12位，最多可以划分4096个用户。交换机之间通过Trunk口连接\n\n\n\n\n\n4.ICMP协议与ping\nping是基于ICMP协议的，全称为Internet Control Message Protocol，即互联网控制报文协议主要有以下几种类型：\n\n查询报文类型：一种主动请求并且获得主动应答的ICMP协议，在网络抓包时，称为ICMP ECHO REQUEST和CMP ECHO REPLY，比原生ICMP多个标识符和序号字段\n差错报文类型：主要有终点不可达（3）、源抑制（4）、超时（11）、重定向（5）等\n\n\nping的发送和接收过程\n\n\nTraceroute\n\n作用一：故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器\n作用二：故意设置不分片，从而确定路径的 MTU\n\n\n\n5.网关和路由协议\n在一个机构内，会给每个主机分配一个具体的内部IP（如192.168.1.x/10.10.x.x），只有通过网卡或者路由器，再配置好网关（Gateway）和IP，就可以连接上外网，才能访问外网。访问时如果是同一网段，则直接访问，如果是外部网段，则需要发给网关（往往是路由器，三层转发设备，可以查看MAC头和IP头，然后根据内容和路由算法决定如何转发）。\n\n\n路由方式：MAC地址在局域网内才有效，所以MAC地址只要过网关，就必定会改变；不改变IP地址的网关，称为转发网关，改变IP地址的网关，称为NAT（Network Address Translation）网关。MAC地址用在局域网内，IP地址用在全局。\n\n欧洲十国游型：每到一个新的局域网，MAC都要变，但是IP地址不变，IP地址一直是源IP和目的IP，MAC是当前MAC和吓一跳MAC地址\n\n\n玄奘西行型：局域网的IP冲突了，源IP和目的IP相同，在局域网内各管各的，这就需要在网关上将局域网IP转换为公网IP，目的IP也要改成对应的公网IP。IP的更改发生在NAT网关，其配置了局域网IP与公网IP的映射表。\n\n\n\n\n路由协议\n\n配置路由\n\n路由表：决定如何转发流量，通常称为路由表，主要包含以下三项信息，目的网络、出口设备、下一跳网关。可以通过route命令和ip route命令进行查询或者配置。例如，我们设置 ip routew add 10.176.48.0/20 via 10.173.32.1 dev eth0，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。\n\n策略路由配置示例：\n$ ip rule add from 192.168.1.0&#x2F;24 table 10 \n$ ip rule add from 192.168.2.0&#x2F;24 table 20\n#表示从 192.168.1.10&#x2F;24 这个网段来的，使用 table 10 中的路由表，\n#而从 192.168.2.0&#x2F;24 网段来的，使用 table20 的路由表\n$ ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2\n#下一跳有两个地方，分别是 100.100.100.1 和 200.200.200.1，权重分别为 1 比 2。\n\n\n动态路由算法：如何在网络拓扑中找到两个节点的最短路径，主要有Bellman-Ford和Dijkstra算法\n\n距离矢量路由算法（distance vector routing）：基于Bellman-Ford算法，算法思想是每个路由器都保存一个路由表，从哪出和距离，每个路由器都保存全局信息，每过一段时间将已知信息告知邻居。存在两个问题\n好消息（新加入路由器）传的块，坏消息（下线的路由器）传的慢\n每次发送的时候，要发送整个全局路由表\n\n\n链路状态路由算法（link state routing），基于Dijkstra算法，算法思想是当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径\n\n\n动态路由协议\n\n基于链路状态路由算法的OSPF（Open Shortest Path First，开放式最短路径优先）：主要用于数据中心内部，又称内部网关协议（Interior Gateway Protocol IGP）。内部网关协议的重点就是找到最短路径，可以在多个路径中进行负载均衡，常被称为等价路由。常配合接入层的负载均衡LVS\n基于距离矢量路由算法的BGP（Border Gateway Protocol，外网路由协议）：因为每个数据中心都有自己的Policy，所以有些路可以走，有些不可以走。这一个个数据中心称为自治系统AS（Autonomous System），通过边界路由器与外面世界建立联系。BGP有两类：\neBGP：边界路由器之间使用eBGP广播路由\niBGP：使得内部路由器能够找到到达外网目的地的最好的边界路由器\n\n\n\n\n\n\n\n6.NAT与防火墙1.防火墙\n\n\n\n\n\n\n\n\n控制互联网中网络流量的流向\n\n包过滤防火墙：一般配置为丢弃或转发数据包头中符和特定标准的数据包，这些标准称为过滤器\n无状态的防火墙：单独处理每一个数据报的信息\n有状态的防火墙：通过关联已经或者即将到达的数据包来推断流或者数据报的信息，即可以构成一个IP数据报的IP分片\n\n\n代理防火墙：本质上是运行一个或多个应用层网关的主机，该主机拥有多个互联网接口，能够在应用层中继两个连接/关联之间的特定类型的流量，一种常见配置为在”外“接口配置一个全局路由的IP地址，为”内“接口分配一个私有IP地址。\nHTTP防火墙：缓存网页减少网页延迟，增加黑名单来组织用户访问某些网站\n隧道代理服务器：本质上执行相反的功能，以避免用户被内容过滤器封阻\n\n\nSOCKS防火墙：比HTTP代理访问使用更广泛，可用于Web之外的其他服务\n\n\nLinux中==iptables==使用一个称为NetFilter的网络过滤功能来构建\n\n2.NAT\n\n\n\n\n\n\n\n\n为了应对IPv4地址数量枯竭\n\n允许多个范围内中的同一地址可以复用。专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP，内部原理就是重写通过路由器的数据包的识别信息\n\n一共有三个IPv4地址范围作为私有地址范围使用（常作为DHCP地址池）\n\n10.0.0.0/8\n172.16.0.0/12\n192.168.0.0/16\n\n\n在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。\n\nNAT的转换行为和过滤行为有三种\n\n\n\n3.NAT和TCP P214​    TCP连接建立时，将源IP地址改成NAT的外接口地址，并创建内部状态来记住此连接，通过会话计时器和探测数据包来确定是否删除一个内部状态，待处理的棘手问题为：如何处理多个NAT内部的主机上运行的对等应用\n3.传输层1.UDP\nUDP包头\n\n\nIP头里有一个8位协议，来指明是TCP还是UDP。从数据中解析出对应的头，内核就按照端口号来将传输层包中的端口号来传送给正在监听此端口号的应用程序\n\n\n协议原理\n- \n\n使用场景\n\n需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用\n不需要一对一沟通，建立连接，而是可以广播的应用\n需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候\n基于UDP的协议：DHCP、HTTP3、云网络中的VXLAN、操作系统镜像的下载使用的 TFTP\n一些新兴改进\nQUIC是Google提出的一种基于UDP改进的通信协议，在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制。主要用在网页和APP的访问\n直播协议多使用RTMP，丢包时会影响直播效果，所以很多直播应用都基于UDP实现了视频传输协议\n实时游戏领域，在异步IO机制引入之前，常采用自定义UDP来解决对海量客户端连接的策略\n物联网领域终端资源少，维护TCP协议代价太大，而且物联网对实时性要求也很高。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的\n在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的\n\n\n\n\n\n2.TCP\n包头\n\n\n序号：给包编号，用来解决乱序问题\n确认序号：发出去的包应该有确认，来确定是否已经收到相应包\n状态位：\nSYN：发起一个连接\nACK：回复\nRST：重新连接\nFIN：结束连接\n\n\n窗口大小：TCP要做流浪控制，通信双方动态约定一个窗口，保证双方都在高效处理数据\n\n\n\n协议原理\n\n三次握手\n\n原理\n\n状态变化时序图：一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。\n\n\n\n\n相关问题\n\n握手次数：一次的话，请求方不知道响应方是否已经成功接受请求；两次的话，接收方不知道发送方是否成功接受相应；三次的话，刚好双方都知晓；四次以及更多的话，已经没有特殊的意义了，所以再多的数据包都不能保证真的可靠，后续通过数据包和探活包来解决相关问题\nTCP包的序号问题：为了防止连接之间数据包序号的相互影响，所以序号是随时间变化的，通过数据包的序号，双方都可以知道应收的包和应发的包都是哪个\n为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样\n\n\n\n\n四次挥手\n\n原理\n\n状态变化时序图\n\n\n\nFIN_WAIT_2：如果此时右端机器直接关机，那么TCP协议里并没有对这个状态的处理，但是在Linux中可以调整tcp_fin_timeout这个参数，设置一个超时时间\n等待2MSL：MSL是报文最大生存时间，虽然序号是重新生成的，但是为了防止左端提前结束后收到右端之前连接的数据包，所以需要等待2MSL时间。时间截止后，对于右端旧连接发送的数据包，左端将会直接发送RST，这样右端就知道左端已退出\n\n\n\n\n相关问题\n\n\n\n滑动窗口\n\n顺序问题    \n\n为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为累计确认或者累计应答（cumulative acknowledgment）\n\n根据处理的情况可以将发送端的包分为四个部分\n\n\n\n第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的\n第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉\n第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的\n第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。（区分三和四是为了流量控制）\n\n\n根据处理的情况可以将接受端的包分为三个部分\n\n\n\n第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的\n第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量\n第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。\n\n\n\n\n流量控制\n\n在对包的确认中，同时会携带一个窗口的大小。当发送方窗口已经全发送过了，但是接受端还没接收，此时每接受到一个应答，窗口大小就减一，直到为0\n\n\n丢包问题\n\n超时重传：对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。超时时间依靠自适应重传算法（Adaptive Retransmission Algorithm）\n超时间隔加倍：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送\n快速重传机制：当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段\nSACK：这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方\n\n\n\n\n拥塞窗口\n\n包丢失\n\n超时重传\n\n慢启动拥塞避免\n\n\n快重传快恢复\n\n\nBRR拥塞算法\n\n\n\n\n\n其他问题\n\nTCP状态机\n\n\n\n\n\n\n其它\n\n\n3.Socket\n参数设置\n\n指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6\n指定到底是 TCP 还是 UDP，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM\n\n\n基于 TCP 协议的 Socket 程序函数调用过程\n\n函数调用过程\n\n\n数据结构\n\n\n\n\n基于 UDP 协议的 Socket 程序函数调用过程\n\n函数调用过程\n\n\n\n\n\n\n4.应用层1.HTTP/1.1\n\n\n\n\n\n\n\n\na stateless application-level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information system.\n1.协议的通用规则\n协议格式：ABNF（扩充巴克斯范式）操作符号\n\n空白字符：用来分隔定义中的各个元素，method SP request-target SP HTTP-version CRLF\n\n选择 /:表示多个规则都是可供选择的规则，start-line = request-line / status-line\n\n值范围 %c##-## ：OCTAL=“0”/“1”/“2”/“3”/“4”/“5”/“6”/“7”与OCTAL=%x30-37等价\n\n序列组合 ():将规则组合起来，视为单个元素\n\n不定量重复 m*n:\n\n* 元素表示零个或更多元素：*( header-field CRLF )\n1* 元素表示一个或更多元素，2*4 元素表示两个至四个元素\n\n\n可选序列 []：[ message-body ]\n\n核心规则：\n\n\n\nURI\n\nURL：[RFC1738]，Uniform Resource Locator，表示资源的位置，Internet上描述信息资源的字符串\n\nURN：[RFC2141]，Uniform Resource Name，例如磁力链接\n\nURI：[RFC1630]，[RFC3986]，Uniform Resource Identifier，URL是URI的一种实现\n\n组成：schema、user information、host、port、path、query、fragment\n\n\n格式：URI = scheme “:” hier-part [ “?” query ] [ “#” fragment ]\n\nscheme=ALPHA*(ALPHA/DIGIT/“+”/“-“/“.”)\n例如：http, https, ftp,mailto,rtsp,file,telnet\n\n\nquery=*(pchar/“/“/“?”)\nfragment=*(pchar/“/“/“?”)\nhier-part = “//“ authority path-abempty / path-absolute / path-rootless / path-empty\nauthority = [ userinfo “@” ] host [ “:” port ]\nuserinfo = *( unreserved / pct-encoded / sub-delims / “:” )\nunreserved = ALPHA / DIGIT / “-“ / “.” / “_” / “~” \nALPHA: %41-%5A and %61-%7A\nDIGIT: %30-%39\n-:%2D        .:%2E.        _:%5F\n\n\n\n\nhost = IP-literal / IPv4address / reg-name\nport = *DIGIT\n\n\n\n\npath = path-abempty/ path-absolute/ path-noscheme / path-rootless / path-empty \npath-abempty = *( “/” segment )，以/开头的路径或者空路径\npath-absolute = “/” [ segment-nz *( “/” segment ) ]，以/开头的路径，但不能以//开头\npath-noscheme = segment-nz-nc *( “/” segment )，以非:号开头的路径\npath-rootless = segment-nz *( “/” segment )，相对path-noscheme，增加允许以:号开头的路径\npath-empty = 0&lt;pchar&gt;，空路径\n\n\n\n\n\n\n\n\n方法与响应码概览\n\n方法[RFC7231]\nGET：主要的获取信息方法，大量性能优化都针对该方法，幂等方法\nPOST：常用语提交HTML FORM表单，新增资源等\nPUT：更新资源，带条件时是幂等方法\nDELETE：删除资源，幂等方法\n其它：HEAD、CONNECT、OPTIONS、TRACE、PROPFIND、PROPPATCH、MKCOL、COPY、MOVE、LOCK、UNLOCK\n\n\n响应码[RFC6585]、[RFC7231]\n1xx：请求已经收到，需要进一步处理才完成\n200：请求响应成功\n3xx：请求重定向（去新地方找），[RFC2068]规定不能超过五次，防止死循环\n4xx：找不到资源,资源不存在\n5xx：服务器代码错，例如502网关错误\n\n\n\n\n\n2.连接与消息的路由\n连接\n\nHTTP连接的常见流程：解析出主机名、通过DNS查询主机名的IP、浏览器获得端口号（80）、浏览器发起到IP端口80的连接、浏览器向服务器发送一条请求报文、浏览器从服务器读取响应报文、关闭连接\n\n从编程的角度\n\n短连接与长连接\n\nConnection头部（Connection仅对当前连接有效，不是整条链路）\nKeep-Alive：长连接，HTTP/1.1默认支持\nClose：短连接\n不转发Connection列出的头部，该头部仅与当前连接有关\n\n\nProxy-Connection：陈旧的代理服务器不识别该头部，退化为短连接；新版本的代理服务器理解该头部，与客户建立长连接，然后与服务器使用Connection替代Proxy-Connection\n\n\n\n\n连接相关头部\n\n用于连接消息\nHost头部 [RFC7230]section5.4\nABNF：Host = uri-host [ “:” port]\n示例：www.baidu.com、localhost:8080\nHTTP/1.1规范要求，不传递Host头部、超过一个Host头部，无效头部都会返回400错误码\n\n\n\n\n用于代理服务器转发消息\nMax-Forwards头部\nABNF：Max-Forwards = 1*DIGIT\n限制Proxy代理服务器的最大转发次数，仅对TRACE/OPTIONS方法有效\n\n\nVia头部\nABNF：Via = 1#( received-protocol RWS received-by [ RWS comment ] )\nreceived-protocol = [ protocol-name “/“ ] protocol-version\nreceived-by = ( uri-host [ “:” port ] ) / pseudonym\npseudonym = token\n\n\n指明经过的代理服务器名称及版本\n\n\nCache-Contro头部l:no-transform：禁止代理服务器修改响应包体\n\n\n用于请求/响应上下文的头部\n请求的上下文\nUser-Agent\nABNF：User-Agent = product *( RWS ( product / comment ) )\nproduct = token [“/“ product-version]\nRWS=1*(SP/HTAB)\n\n\n示例：\nMozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36\n\n\n\n\nReferer\n浏览器对来自某一页面的请求自动添加的头部，用于统计分析、缓存优化、防盗链等功能\n示例：Referer: https://cn.bing.com/\nRefer不会被添加的场景\n来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI\n当前请求页面采用的是 http 协议，而来源页面采用的是 https 协议\n\n\n\n\nFrom：主要用于网络爬虫，告诉服务器如何通过邮件联系到爬虫的负责人\n\n\n响应的上下文\nServer\nABNF：Server = product *( RWS ( product / comment ) )\nproduct = token [“/“ product-version]\n\n\n服务器上所用软件的信息，用于帮助客户端定位问题或统计数据\n示例： nginx/1.23.1、BWS/1.1\n\n\nAllow\nABNF：Allow = #method\n告诉客户端，服务器上该URI对应的资源允许哪些方法的执行\n示例：Allow: GET, HEAD, PUT\n\n\nAccept-Ranges\n告诉客户端服务器上该资源是否允许range请求\n示例\nAccept-Ranges: bytes\nAccept-Ranges: none\n\n\n\n\n\n\n\n\n\n\n\n3.内容协商与传输\n内容协商\n\n每个URI指向的资源可以是任何事物，可以有多种不同的表述，例如一份文档可以有不同语言的翻译、不同的媒体格式、可以针对不同的浏览器提供不同的压缩编码等\n\n内容协商的两种方式\n\nProactive 主动式内容协商：指由客户端先在请求头部中提出需要的表述形式，而服务器根据这些请求头部提供特定的 representation 表述\n\nReactive 响应式内容协商：指服务器返回 300 Multiple Choices 或者 406 Not Acceptable，由客户端 选择一种表述 URI 使用\n\n\n\n常见的协商要素\n\n媒体资源的 MIME 类型及质量因子q（内容的质量、可接受类型的优先级）\nAccept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,/;q=0.8,application/signed-exchange;v=b3;q=0.9\n\n\n字符编码：由于 UTF-8 格式广为使用， Accept-Charset 已被废弃\n内容编码：主要指压缩算法\nAccept-Encoding: gzip, deflate, br\n\n\n表述语言\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\n\n\n国际化与本地化\ninternationalization(i18n)：指设计软件时，在不同的国家、地区可以不做逻辑实现层面的修改便能够以不同的语言显示\nlocalization(l10n)：指内容协商时，根据请求中的语言及区域信息，选择特定的语言作为资源表述\n\n\n资源表述的元数据头部\n媒体类型、编码：content-type: text/html; charset=utf-8\n内容编码：content-encoding: gzip\n语言：Content-Language: de-DE, en-CA\n\n\n\n\n\n\n包体\n\n概念：实际承载的消息内容\n\n两种传输HTTP包体的方式\n\n定长包体：发送HTTP消息时已能够确定包体的全部长度，接受端处理更简单\n\n使用Content-Length头部明确指明包体长度，单位是10进制，且必须与实际传输的包体长度一致\n\n\n不定长包体：发送HTTP消息时不能够确定包体的全部长度，基于长连接持续推送动态内容\n\n使用 Transfer-Encoding 头部指明使用 Chunk 传输方式，并忽略 Content-Length 头部\n\nABNF：transfer-coding = “chunked” / “compress” / “deflate” / “gzip” / transfer-extension\n\nchunk传输方式（分块传输编码）：Transfer-Encoding:chunked\n\nchunked-body = *chunk  last-chunk  trailer-part  CRLF（0-n个chunk）\n\nchunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF\n\nchunk-size = 1*HEXDIG:注意这里是 16 进制而不是10进制\nchunk-data = 1*OCTET\n\n\nlast-chunk = 1*(“0”) [ chunk-ext ] CRLF\n\ntrailer-part = *( header-field CRLF )\n\n\n\n\n\nTrailer头部的传输（不是所有服务器都支持）\n\nTE 头部:客户端在请求在声明是否接收 Trailer 头部\nTE: trailers\n\n\nTrailer 头部:服务器告知接下来 chunk 包体后会传输哪些 Trailer 头部\nTrailer: Date\n\n\n以下头部不允许出现在 Trailer 的值中:\n用于信息分帧的首部 (例如 Transfer-Encoding 和 Content-Length)\n用于路由用途的首部 (例如 Host)\n请求修饰首部 (例如控制类和条件类的，如 Cache-Control，Max-For wards，或者 TE)\n身份验证首部 (例如 Authorization 或者 Set-Cookie)\nContent-Encoding, Content-Type, Content-Range，以及 Trailer 自身\n\n\n\n\n\n\n\n\n其他\n\nMIME( Multipurpose Internet Mail Extensions )格式\ncontent := “Content-Type” “:” type “/“ subtype *(“;” parameter)\ntype := discrete-type / composite-type\ndiscrete-type := “text” / “image” / “audio” / “video” / “application” / extension-token\ncomposite-type := “message” / “multipart” / extension-token\nextension-token := ietf-token / x-token\n\n\nsubtype := extension-token / iana-token\nparameter := attribute “=” value\n\n\n大小写不敏感，但通常是小写\n例如: Content-type: text/plain; charset=”us-ascii“\n\n\nContent-Disposition头部[RFC6266]\ndisposition-type = “inline” | “attachment” | disp-ext-type\ninline:指定包体是以 inline 内联的方式，作为页面的一部分展示\nattachment:指定浏览器将包体以附件的方式下载\n例如: Content-Disposition: attachment\n例如: Content-Disposition: attachment; filename=“filename.jpg”\n\n\n在 multipart/form-data 类型应答中，可以用于子消息体部分\n如 Content-Disposition: form-data; name=”fieldName”; filename=”filename.jpg”\n\n\n\n\n\n\nRange[RFC7233]\n允许服务器基于客户端的请求只发送响应包体的一部分给到客户端，而客户端 自动将多个片断的包体组合成完整的体积更大的包体\n服务器通过 Accept-Range 头部表示是否支持 Range 请求\n通过Range头部传递请求范围，如:Range: bytes=0-499\n\n\n\n\n\n\nForm表单\n\nFORM表常用控件：Text Input Controls:文本输入控件、Checkboxes Controls:复选框控件、Radio Box Controls :单选按钮控件、Select Box Controls:下拉列表控件、File Select boxes:选取文件控件、Clickable Buttons:可点击的按钮控件、Submit and Reset Button:提交或者重置按钮控件\n\nFORM表单提交请求时的关键属性\n\naction:提交时发起 HTTP 请求的 URI\n\nmethod:提交时发起 HTTP 请求的 http 方法\n\nGET:通过 URI，将表单数据以 URI 参数的方式提交，不安全但高效\nPOST:将表单数据放在请求包体中提交，安全但不高效\n\n\nenctype:在 POST 方法下，对表单内容在请求包体中的编码方式\n\napplication/x-www-form-urlencoded\n\n数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值，字符以 URL 编码方式编码\n\n\nmultipart/form-data\n\nboundary 分隔符\n\n每部分表述皆有HTTP头部描述子包体，例如 Content-Type\n\nlast boundary 结尾\n\n\n\n\n\n\n\nmultipart[RFC1521]、[RFC822]：一个包体中多个资源表述\n\nContent-type 头部指明这是一个多表述包体\n\nContent-type: multipart/form-data;\nboundary=—-WebKitFormBoundar yRRJKeWfHPGrS4LKe\n\n\nBoundary 分隔符的格式\n\nboundary := 0*69&lt;bchars&gt; bcharsnospace\nbchars := bcharsnospace / “ “\nbcharsnospace:=DIGIT/ALPHA/“‘“/“(“/“)”/“+”/“_”/“,”/“-“/“.”/“/“/“:” / “=” / “?”\n\n\n\n\n包体格式：multipart-body = preamble 1*encapsulation close-delimiter epilogue\n\npreamble := discard-text\n\nepilogue := discard-text\n\ndiscard-text := *(*text CRLF)\n\n\n每部分包体格式:encapsulation = delimiter body-part CRLF\n\ndelimiter = “–” boundary CRLF\n\nbody-part = fields *( CRLF *text )\n\nfield = field-name “:” [ field-value ] CRLF\n\ncontent-disposition: form-data; name=”xxxxx“\n\ncontent-type 头部指明该部分包体的类型\n\n\n\n\n\n\n\nclose-delimiter = “–” boundary “–” CRLF\n\n\n\n\n\n\n\n\n4.cookie的设计与问题\nCookie的格式与约束\n\nHTTP State Management Mechanism[RFC6265]，保存在客户端，由浏览器维护、表示应用状态的HTTP头部\n存放在内存或磁盘中\n服务端生成Cookie在响应中通过Set-Cookie头部告知客户端，允许多 个 Set-Cookie 头部传递多个值\n客户端得到Cookie后，后续请求都会自动将Cookie头部携带至请求中\n\n\nABNF\ncookie-header = “Cookie:” OWS cookie-string OWS（可以存放多个名值name/value对）\ncookie-string = cookie-pair *( “;” SP cookie-pair )\ncookie-pair = cookie-name “=” cookie-value\n\n\n\n\nset-cookie-header = “Set-Cookie:” SP set-cookie-string（只有一个名值对，但可以包含多个头部）\nset-cookie-string = cookie-pair *( “;” SP cookie-av )\ncookie-pair = cookie-name “=” cookie-value\ncookie-av:描述 cookie-pair 的可选属性，cookie-av = expires-av / max-age-av / domain-av / path-av / secure-av / httponly-av / extension-av\n\n\n\n\n\n\n浏览器使用Cookie的要求：每条 Cookie 的长度(包括 name、value 以及描述的属性等总长度)至多要达到 4KB ；每个域名下至少支持 50 个 Cookie；至少要支持 3000 个 Cookie\nCookie缺点：需要附加在每个HTTP请求中，无形增加了流量；明文传递有安全性问题；大小有限制对复杂请求来说不够用\n\n\nSession的工作原理\n\n\n同源策略\n\n如果两个 URL 的 protocol、port (en-US)(如果有指定的话) 和 host都相同的话，则这两个 URL 是同源\n\n\n\nURL\n结果\n原因\n\n\n\nhttp://store.company.com/dir2/other.html\n同源\n只有路径不同\n\n\nhttp://store.company.com/dir/inner/another.html\n同源\n只有路径不同\n\n\nhttps://store.company.com/secure.html\n失败\n协议不同\n\n\nhttp://store.company.com:81/dir/etc.html\n失败\n端口不同 (  默认端口是 80)\n\n\nhttp://news.company.com/dir/other.html\n失败\n主机不同\n\n\n\n作用：\n\n没有同源策略下的Cookie，只能保证用户请求来自同一浏览器，不能确保是用户自愿发出的\n站点B的脚本就可以随修改A的DOM结构\n限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互\n\n\n平衡点\n\n可用性:HTML 的创作者决定跨域请求是否对本站点安全\n &lt;script&gt;&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;带有 src 属性可以跨域访问\n 允许跨域写操作:例如表单提交或者重定向请求（CSRF安全性问题）\n\n\n安全性:浏览器需要防止站点 A 的脚本向站点 B 发起危险动作\nCookie、LocalStorage 和 IndexDB 无法读取\nDOM 无法获得(防止跨域脚本篡改 DOM 结构)\nAJAX 请求不能发送\n\n\n\n\n\n\n跨域访问（CORS，Cross-Origin Resource Sharing）\n\n浏览器同源策略下的跨域访问解决方案：如果站点 A 允许站点 B 的脚本访问其资源，必须在 HTTP 响应中显式的告知浏览器，站点 B 是被允许的\n\n访问站点 A 的请求，浏览器应告知该请求来自站点 B\n站点 A 的响应中，应明确哪些跨域请求是被允许的\n\n\n简单请求的跨域访问\n\n简单请求\n\nGET/HEAD/POST 方法之一\n仅能使用 CORS 安全的头部:Accept、Accept-Language、Content-Language、Content-Type\nContent-Type 值只能是: text/plain、multipart/form-data、application/x-www-form-urlencoded 三者其中之一\n\n\n策略\n\n请求中携带 Origin 头部告知来自哪个域\n响应中携带 Access-Control-Allow-Origin 头部表示允许哪些域\n浏览器放行\n\n\n简单请求以外的其他请求：访问资源前，需要先发起 prefilght 预检请求(方法为 OPTIONS)询问何种请求是被允许的\n\n\n\n\n\n\n条件请求\n\n概念\n目的：有客户端携带条件判断信息，而服务器预执行条件验证过程成功后，再返回资源的表述\n应用场景：使缓存的更新更有效率、断点续传时对之前内容的验证、当多个客户端并行修改同一资源时，防止某一客户端的更新被错误丢弃\n\n\n条件请求头部\nIf-Match = “*“ / 1#entity-tag\nIf-None-Match = “*” / 1#entity-tag\nIf-Modified-Since = HTTP-date\nIf-Unmodified-Since = HTTP-date\nIf-Range = entity-tag / HTTP-date\n\n\n验证器 validator：根据客户端请求中携带的相关头部，以及服务器资源的信息，执行两端的资源验证\n强验证器:服务器上的资源表述只要有变动(例如版本更新或者元数据更 新)，那么以旧的验证头部访问一定会导致验证不过\n弱验证器:服务器上资源变动时，允许一定程度上仍然可以验证通过(例如一小段时间内仍然允许缓存有效)\n验证器响应头部\nEtag 响应头部， 给出当前资源表述的标签，ETag = entity-tag\nentity-tag = [ weak ] opaque-tag\nweak = %x57.2F\nopaque-tag = DQUOTE *etagc DQUOTE etagc = %x21 / %x23-7E / obs-text\n\n\n例如：\n强验证器 ETag: “xyzzy”\n弱验证器 ETag: W/“xyzzy”\n\n\n\n\nLast-Modified 响应头部：Last-Modified = HTTP-date\n表示对应资源表述的上次修改时间\n对比 Date 头部: Date = HTTP-date\n表示响应包体生成的时间\nLast-Modified 不能晚于 Date 的值\n\n\n\n\n\n\n\n\n\n\n\n5.缓存的控制\n缓存的原理\n\n为当前请求复用前请求的响应\n\n缓存实现示意图\n\n\n\n缓存新鲜度的四种计算方式\n\n判断缓存是否过期：response_is_fresh = (freshness_lifetime &gt; current_age)\n\nfreshness_lifetime:按优先级，取以下响应头部的值（s-maxage &gt; max-age &gt; Expires &gt; 预估过期时间）\n预估过期时间：[RFC7234]\n\n\ncurrent_age：current_age = corrected_initial_age + resident_time;\nresident_time = now - response_time(接收到响应的时间);\ncorrected_initial_age = max(apparent_age, corrected_age_value);\ncorrected_age_value = age_value + response_delay;\nresponse_delay = response_time - request_time(发起请求的时间);\n\n\napparent_age = max(0, response_time - date_value);\n\n\n\n\n\n\n示例\n\n\n\n\nCache-Control头部\n\n头部格式\n\n\nCache-Control的值\n\nmax-age:告诉服务器，客户端不会接受 Age 超出 max-age 秒的缓存\nmax-stale:告诉服务器，即使缓存不再新鲜，但陈旧秒数没有超出 max-stale 时，客户端仍打算使用。若 max-stale 后没有值，则表示无论过期多久客户端都可使用\nmin-fresh:告诉服务器，Age 至少经过 min-fresh 秒后缓存才可使用\nno-cache:告诉服务器，不能直接使用已有缓存作为响应返回，除非带着缓存条件到上游服务端得到 304 验证返回码才可使用现有缓存\nno-store:告诉各代理服务器不要对该请求的响应缓存(实际有不少不遵守该规定的代理服务 器)\nno-transform:告诉代理服务器不要修改消息包体的内容\nonly-if-cached:告诉服务器仅能返回缓存的响应，否则若没有缓存则返回 504 错误码\nmust-revalidate:告诉客户端一旦缓存过期，必须向服务器验证后才可使用\nproxy-revalidate:与 must-revalidate 类似，但它仅对代理服务器的共享缓存有效\nno-cache:告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证 得到 304 返回码。如果 no-cache 后指定头部，则若客户端的后续请求及响应 中不含有这些头则可直接使用缓存\nmax-age:告诉客户端缓存 Age 超出 max-age 秒后则缓存过期\ns-maxage:与 max-age 相似，但仅针对共享缓存，且优先级高于 max-age 和 Expires\npublic:表示无论私有缓存或者共享缓存，皆可将该响应缓存\nprivate:表示该响应不能被代理服务器作为共享缓存使用。若 private 后指定头部，则在告诉代理服务器不能缓存指定的头部，但可缓存其他部分\nno-store:告诉所有下游节点不能对响应进行缓存\nno-transform:告诉代理服务器不能修改消息包体的内容\n\n\n\n\n什么样的响应才会被缓存\n\n请求方法可以被缓存理解(不只于 GET 方法)\n响应码可以被缓存理解(404、206 也可以被缓存)\n响应与请求的头部没有指明 no-store\n响应中至少应含有以下头部中的 1 个或者多个:\nExpires、max-age、s-maxage、public\n当响应中没有明确指示过期时间的头部时，如果响应码非常明确，也可以缓存\n\n\n如果缓存在代理服务器上\n不含有 private\n不含有 Authorization\n\n\n\n\n多种重定向跳转方式的差异\n\n重定向流程\n\n\n\n\n\n2.WebSocket3.HTTP/2.01.TLS/SSL2.HTTPS\n对称加密：我们在谍战剧里面经常看到这样的场景，就是特工破译的密码会有个密码本，截获无线电台，通过密码本就能将原文破解出来\n\n非对称加密：非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个私钥的私密性，对应私钥的公钥，是可以在互联网上传播的，只要外卖网站把这个公钥给你，你就可以愉快地互通了\n\n数字证书：\n\n你怎么鉴别别人给你的公钥是对的？这个时候就需要权威部门的介入了，而由权威部门颁发的就是证书\n\n证书里面有什么？有公钥，有证书的所有者，还有证书的发布机构和证书的有效期\n\n证书的生成\nopenssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req\n\n\n\n4.流媒体协议\n概念\n\n名词系列\n名词系列一：AVI、MPEG、RMVB、MP4、MOV、FLV、WebM、WMV、ASF、MKV\n名词系列二：H.261、 H.262、H.263、H.264、H.265\n名词系列三：MPEG-1、MPEG-2、MPEG-4、MPEG-7\n\n\n视频：就是一张一张的图片，当播放的足够快，比如每秒60帧（FPS），人眼就看不出来是一张张独立的图片。每一张图片都是由像素组成的，如3456*2234；每个像素由RGB组成，每个8位，共24位（三原色），每秒视频可以计算为：60*3456*2234*24 = 11117813760Bits = 1389726720 Bytes = 1.29GB\n压缩：因为视频的图像相邻像素强相关、相邻帧相似、人们视觉不够敏感、可用霍夫曼编码差异化编码，所以可以用压缩算法对视频进行压缩。编码过程大致包括帧内预测、帧间预测、变换、量化（降低图像质量）、熵编码（变长编码）几方面。视频编码主要有两大流派\n流派一：ITU（International Telecommunications Union）的 VCEG（Video Coding Experts Group），名词系列二，就是这个组织制定的标准\n流派二：ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），名词系列三，就是这个组织制定的标准\n重点：ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC\n\n\n\n\n直播产生的过程\n\n\n编码：将视频序列分成三种帧（I关键帧、P前向预测编码帧、B双向预测内插编码帧），压缩后帧的序列可以通过IBBP的间隔出现（通过时序进行编码）。一个视频拆分成一系列的帧，每一帧拆分成一系列的片，每一片都放在一个NALU（网络提取单元）里面，NALU之间都是通过特殊的起始标识符分隔，在每一个I帧的第一片里面，要插入单独保存的SPS（图像序列的所有信息）和PPS（图像的所有分片信息）的NALU，最终形成一个长长的NALU序列\n\n推流：首先通过RTMP协议将编码得到的二进制的流打包成网络包进行传送，RTMP基于TCP连接并且还要建立RTMP连接用于同步信息（握手时版本号、时间戳；握手后Chunk块大小、窗口大小）。传输数据的时候创建一个流Stream，通过Stream来推流，即将NALU放在Message里面发送（RTMP Packet），并且不是以Message为单位的，而是把Message拆分成Chunk发送，而且是串行发送\n\n流处理、分发：观众可以通过RTMP协议从流媒体服务器上拉取，但因服务器压力过大，所以需要分发网络。分发网络分为中心和边缘两层，边缘层服务器部署在全国各地及横跨各大运营商里，和用户距离很近。中心层是流媒体服务集群，负责内容的转发。\n\n拉流：先读到的是H.264的解码参数，例如SPS和PPS，然后对收到的NALU组成的以一个个帧，进行解码，交给播放器播放，一个绚丽多彩的视频画面就出来了\n\n解码：即通过上述过程的逆过程，将一串串看不懂的二进制，再转变成一帧帧生动的图片，在客户端播放出来\n\n\n\n\n\n5.P2P协议\nFTP的两种工作模式\n\n主动模式（PORT）：客户端随机打开一个大于 1024 的端口 N，向服务器的命令端口 21 发起连接，同时开放 N+1 端口监听，并向服务器发出 “port N+1” 命令，由服务器从自己的数据端口 20，主动连接到客户端指定的数据端口 N+1\n被动模式（PASV）：客户端打开两个任意的本地端口 N（大于 1024）和 N+1。第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 P（大于 1024），返回“227 entering passive mode”消息，里面有 FTP 服务器开放的用来进行数据传输的端口。客户端收到消息取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输\n\n\nP2P（peer-to-peer）：资源开始并不集中地储存在某些设备上，而是分散地存储在多台设备（peer）上，可以缓解单一服务器的带宽压力。例如软件BitTorrent，种子（.torrent）文件。P2P主要分为两类，基于tracker和基于分布式哈希算法。有一种著名的去中心网络协议，Kademlia协议，具体如下\n\n\n\n任何一个BitTorrent启动后，有两个角色。peer，用来上传和下载文件；DHT node，通过这个角色，这个节点加入了一个DHT网络；每个DHT node都应该知道某些文件是保存在哪些节点上，也就是文件索引\n如果一个文件计算出一个哈希值，DHT node的ID是和哈希值相同长度的串，则和这个哈希值一样的或是很接近的那些DHT node，就有责任知道从哪里下载这个文件\nDHT网络特别像一个社交网络，每个node都保存了一些其他node的联系方式，也就是朋友圈，节点之间回相互通信，添加或删除朋友圈，这样ID之间的距离就不是物理位置的距离，而是社交网络中的社交距离\n一个新的DHT node上线，只要联系上DHT网络中的一个节点，就加入这个网络\n新DHT node节点通过计算文件哈希，可以知道某个node应该有这个文件保存在哪里的知识，于是去万能的朋友圈去问，朋友如果不知道，朋友再去自己的朋友圈问，很快就能找到\n\n\n\n\n5.数据中心1.DNS\n\n\n\n\n\n\n\n\n将域名映射为IPv4地址\n\n\nDNS\n\n因为DNS服务器访问量巨大，所以一定要设置成高可用、高并发和分布式的，因而使用了树状结构。并且为了减少每次查找地址簿（根据名称查具体IP地址）的时间，每个运营商都有本地域名服务器做缓存。\n\nDNS解析流程：本地DNS通过DHCP配置，是由客户端的网络服务商（ISP）自动分配，通常在网络服务商的某个机房。本地DNS会缓存一张域名与之对应 IP 地址的大表格，如果找到域名对应IP，则直接返回，否则访问根域名服务器，由根域名服务器和其他几个层级的服务器通过递归回溯的方式，最终由对应权威服务器提供IP\n\n负载均衡\n\n内部负载均衡：某个应用访问另一个应用时，如果配置了另一个应用的IP地址，那么这个访问就是一对一的，可以部署多个应用来保证可用性。实现方法为，将应用配置成为域名，在域名解析的时候可以配置策略，每次返回的IP不同，就可以实现负载均衡了\n\n全局负载均衡：为了保证应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用\n\n示例：通过DNS访问数据中心中对象存储上的静态资源\n\nyourcompany.com的DNS服务器，通过配置CNAME的方式，给请求起一个别名，然后告诉本地DNS服务器，让他请求GSLB解析这个域名，GSLB可以在解析的过程中实现负载均衡\nLayer 2 GSLB有可能返回6个Region的IP地址，客户端可以随机货轮询选择一个Region进行访问\n\n\n\n\n\n\n传统DNS问题\n\n域名缓存问题：\n因为本地有缓存的问题，不是每一个请求都回去访问权威DNS服务器，而是访问过一次就把结果缓存到自己本地，这就使得其他客户端访问此缓存的时候，会出现失效的问题\n有的运营商会把一些静态页面缓存到本地运营商的服务器内，这样用户请求的时候，就不用跨运营商进行访问，既加快速度，有减少运营商之间流量计算的成本。在域名解析的时候，不会将用户导向真正的网站，而是指向这个缓存的服务器。这就会出现访问到老页面的问题\n负载均衡失效：本地的缓存，往往使得全局负载均衡失败，因为上次进行缓存的时候，缓存中的地址不一定是这次访问离客户最近的地方，如果把这个地址返回给客户，那肯定就会绕远路\n\n\n域名转发：本地域名解析服务，不是每次都要去权威 DNS 服务器查找，有了请求之后，直接转发给其他运营商去做解析，这样就会使得返回的地址离用户很远\n出口NAT：很多机房的出口会配置NAT，使得从这个网关出去的包，都换成新的 IP 地址，对于访问没有任何问题，但是一旦一旦做了网络地址的转换，权威的 DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问\n域名更新：本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的 TTL 时间限制，在权威 DNS 服务器解析变更的时候，解析结果在全网生效的周期非常漫长。在跨机房负载均衡和容灾中，一个机房出现问题，如果权威DNS的更新比较慢，就会有用户出现访问异常的问题\n解析延迟：DNS 的查询过程需要递归遍历多个 DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时\n\n\nHTTPDNS\n\n概念：不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。当客户端需要DNS解析的时候，直接通过HTTP协议请求这个服务器集群，得到就近的地址。这就需要绕过默认的DNS，常用在手机应用，需要手机端嵌入支持HttpDNS的客户端 SDK\n\n工作模式\n\n\n\n在客户端的 SDK 里动态请求服务端，获取 HttpDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果\n当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己决定缓存机制\n如果本地没有，就需要请求 HttpDNS 的服务器，在本地 HttpDNS 服务器的 IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网站的 IP 列表\n手机客户端自然知道手机在哪个运营商、哪个地址。由于是直接的 HTTP 通信，HttpDNS 服务器能够准确知道这些信息，因而可以做精准的全局负载均衡\n\n\n缓存设计\n\nHttpDNS将解析速度和更新速度都掌握在自己手里，一方面，解析的过程，不需要本地 DNS 服务递归的调用一大圈，一个 HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可以自己控制\n\n缓存设计模式\n\n客户端：手机客户端\n缓存：DNS缓存\n数据源：HttpDNS服务器\n\n\n解析可以同步进行，也就是直接调用HttpDNS的接口，返回最新的记录，更新缓存；也可以异步进行，添加一个解析任务到后台，由后台任务调用HttpDNS的接口\n\n同步更新对应到应用架构中缓存的Cache-Aside机制\n\n异步更新的优点是可以预加载，合并多个HttpDNS，减少HttpDNS压力；缺点是当前请求拿到过期数据的时候会需要冒风险直接使用或再次请求。对应到应用架构中缓存的 Refresh-Ahead 机制\n\n\n\n\n\n调度设计\n\n\n\n由于客户端嵌入了 SDK，因而就不会因为本地 DNS 的各种缓存、转发、NAT，让权威 DNS 服务器误会客户端所在的位置和运营商，而可以拿到第一手资料\n在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HttpDNS 服务端可以根据这些信息，选择最佳的服务节点访问。如果有多个节点，还会考虑错误率、请求时间、服务器压力、网络状况等，进行综合选择，而非仅仅考虑地理位置。当有一个节点宕机或者性能下降的时候，可以尽快进行切换\n在服务端，应用可以通过调用 HttpDNS 的管理接口，配置不同服务质量的优先级、权重。HttpDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址\n\n\n\n\n\n2.CDN\nCDN分发系统架构：全球各地的用于缓存数据的数据中心称为边缘节点，由于边缘节点无法缓存全局信息，所以需要有区域节点及中心节点，来缓存更多的数据，增加缓存的命中率，如果都未命中，则会源网站访问\n\n客户端访问边缘节点：\n\n没有CDN的时候，通过DNS来查询IP地址。有了CDN后，在权威DNS服务器上，会设置一个CNAME别名，指向另一个域名，返回给本地DNS服务器。\n本地DNS服务器继续解析这个新域名，这次会CDN的权威DNS服务器，在这个服务器上，还是会设置一个CNAME，指向另外一个域名，也即 CDN 网络的全局负载均衡器。\n接下来，本地 DNS 服务器去请求 CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，依据包括IP、运营商、URL中的内容、服务器当前负载，返回该服务器IP地址\n本地 DNS 服务器缓存这个 IP 地址，然后将 IP 返回给客户端，客户端去访问这个边缘节点，下载资源\n\n\nCDN缓存的内容\n\n静态CDN\n静态页面、图片：通过拉取的方式，当发现未命中的时候，再去上一级进行拉取\n流媒体（RTMP）：预先缓存流数据，通过推送的模式，将热点数据主动推送到边缘节点，通过HTTP头部中的referer字段、时间戳防盗链（与CDN厂商约定一个加密字符串）解决防盗链问题\n\n\n动态CDN\n一种为生鲜超市模式，也即边缘计算的模式。既然数据是动态生成的，所以数据的逻辑计算和存储，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现\n另一种是冷链运输模式，也即路径优化的模式。数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。\n\n\n\n\n\n3.数据中心\n核心交换机\n\n设备：网关、机架（Rack）、边界路由器（Broder Router）+BGP协议、接入层/TOR（Top Of Rack）交换机、汇聚层（Aggregation Layer）交换机、\n\nLACP（Link Aggregation Control Protocol）协议：所有服务器和交换机都需要支持，可以将多个网卡合称为一个网卡，多个网线聚合成一个网线，在网线之间可以进行负载均衡，也可以为了高可用做准备\n\n可用区（Available Zone，又称Point Of Delivery）：交换机通过堆叠技术，多个物理交换机形成一个逻辑的交换机。汇聚层将大量的计算节点相互连接在一起，形成一个集群，在这个机群里，服务之间通过二层互通。当节点数目再多的时候，需要将多个可用区连在一起，连接多个可用区的交换机称为核心交换机\n\n环路问题：解决方法一为，不同的可用区在不同的二层网络，需要分配不同的网段，此时二层不在一个广播域里，所以不会出现环路。三层可以有环路，只需要通过路由协议选择最佳的路径就可以\n\n大二层：核心交换机也变为二层设备，通过引入 TRILL（Transparent Interconnection of Lots of Link），即多链接透明互联协议。它的基本思想是，二层环有问题，三层环没有问题，那就把三层的路由能力模拟在二层实现。通过链路状态协议运作，学习拓扑+MAC路由\n\n\n\n边界路由器：在核心交换上面，往往会挂一些安全设备，例如入侵检测、DDoS 防护等等。这是整个数据中心的屏障，防止来自外来的攻击。核心交换机上往往还有负载均衡器。因为流量从上到下传输，故称为南北流量\n\n随着云和大数据的发展，节点之间的交互越来越多，例如大数据计算经常要在不同的节点将数据拷贝来拷贝去，这样需要经过交换机，节点之间的交互越来越多，例如大数据计算经常要在不同的节点将数据拷贝来拷贝去，这样需要经过交换机。东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。\n\n叶子交换机（leaf），直接连接物理服务器。L2/L3 网络的分界点在叶子交换机上，叶子交换机之上是三层网络\n\n脊交换机（spine switch），相当于核心交换机。叶脊之间通过 ECMP 动态选择多条路径。脊交换机现在只是为叶子交换机提供一个弹性的 L3 路由网络。南北流量可以不用直接从脊交换机发出，而是通过与 leaf 交换机并行的交换机，再接到边界路由器出去\n\n\n\n\n4.VPN\nVPN通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术。三种协议：乘客协议、隧道协议和承载协议\n\n\nVPN相当于自驾海南游，如何通过琼州海峡呢？这里用到轮渡，就是隧道协议\n在广州这边开车是有“协议”的，例如靠右行驶、红灯停绿灯行，这就相当于“被封装”的乘客协议。当然在海南那面，开车也是同样的协议\n在海上坐船航行，也有协议，例如要看灯塔、要按航道航行等。这是外层的承载协议\n车如何从广州到海南呢？要遵循开车的协议，将车开上轮渡，所有通过轮渡的车都关在船舱里面，按照既定的规则排列好，这就是隧道协议。\n在大海上，车是关在船舱里面的，就像在隧道里面一样，这时内部的乘客协议，也即驾驶协议没啥用处，只需要船遵从外层的承接协议，到达海南就可以了。\n到达之后，外部承接协议的任务就结束了，打开船舱，将车开出来，就相当于取下承接协议和隧道协议的头。接下来，在海南怎么开车，还是内部的乘客协议起作用\n\n\nIPsec VPN\n\nIPsec VPN 的协议簇\n\n协议\nAH（Authentication Header）协议：只能进行数据摘要 ，不能实现数据加密\nESP（Encapsulating Security Payload）协议：能够进行数据加密和数据摘要\n\n\n算法\n加密算法（Encryption Algorithms）\n摘要算法（Hashing Algorithms）\n\n\n组件\nIKE（Internet Key Exchange）组件：用于VPN的双方要进行对称密钥的交换\nSA（Security Association）组件：VPN的双方要对连接进行维护\n\n\n\n\n建立过程\n\n阶段一：建立IKE自己的SA。这个SA用来维护一个通过身份认证和安全保护的通道，为阶段二提供服务。这个阶段通过DH（Diffie-Hellman）算法计算出一个对称密钥K，即为对称密钥。对称密钥从未在通道上传输过，只传输了生成密钥的材料\n\n阶段二：建立IPsec SA。这个SA里，双方会生成一个随机的对称密钥M（有过期时间），由K加密传给对方，然后使用M进行双方接下来通信的数据，IPsec SA 里面有以下内容：\n\nSPI（Security Parameter Index），用于标识不同的连接\n双方商量好的加密算法、哈希算法和封装模式\n生存周期，超过这个周期，就需要重新生成一个 IPsec SA，重新生成对称密钥\n\n\n\n\n传输数据\n\n通过ESP对IP进行加密（可通过对称密钥解密）并封装，外层再包裹一个IP头。下图左侧为原始IP，右侧为包裹后的IP\n\n\n有了 IPsec VPN 之后，客户端发送的明文的 IP 包，都会被加上 ESP 头和 IP 头，在公网上传输，由于加密，可以保证不被窃取，到了对端后，去掉 ESP 的头，进行解密\n\n\n\n\n\nMPLS-VPN：综合和 IP 转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买\n\n\n5.移动网络\n移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变\n\n请记住 4G 网络的结构，有 eNodeB、MME、SGW、PGW 等，分控制面协议和数据面协议，你可以对照着结构，试着说出手机上网的流程，架构及上网流程如下：\n\n\n手机开机以后，在附近寻找基站 eNodeB，找到后给 eNodeB 发送 Attach Request，说“我来啦，我要上网”\n\neNodeB 将请求发给 MME，说“有个手机要上网”，eNodeB朝前对接无线网络，朝后对接核心网络\n\neNodeB使用SCTP协议，有以下特点：多宿主（网卡）、将一个联合（多个接口）分成多个流、四次握手（方式SYN攻击）、消息分帧（类似UDP）、断开连接是三次挥手（没有半关闭状态）\n\n\n\nMME 去请求手机，一是认证，二是鉴权，还会请求 HSS 看看有没有钱，看看是在哪里上网（控制平面）\n\n当 MME 通过了手机的认证之后，开始分配隧道，先告诉 SGW，说要创建一个会话（Create Session）。在这里面，会给 SGW 分配一个隧道 ID t1，并且请求 SGW 给自己也分配一个隧道 ID\n\nSGW 转头向 PGW 请求建立一个会话，为 PGW 的控制面分配一个隧道 ID t2，也给 PGW 的数据面分配一个隧道 ID t3，并且请求 PGW 给自己的控制面和数据面分配隧道 ID\n\nPGW 回复 SGW 说“创建会话成功”，使用自己的控制面隧道 ID t2，回复里面携带着给 SGW 控制面分配的隧道 ID t4 和控制面的隧道 ID t5，至此 SGW 和 PGW 直接的隧道建设完成。双方请求对方，都要带着对方给自己分配的隧道 ID，从而标志是这个手机的请求\n\n接下来 SGW 回复 MME 说“创建会话成功”，使用自己的隧道 ID t1 访问 MME，回复里面有给 MME 分配隧道 ID t6，也有 SGW 给 eNodeB 分配的隧道 ID t7\n\n当 MME 发现后面的隧道都建设成功之后，就告诉 eNodeB，“后面的隧道已经建设完毕，SGW 给你分配的隧道 ID 是 t7，你可以开始连上来了，但是你也要给 SGW 分配一个隧道 ID”\n\neNodeB 告诉 MME 自己给 SGW 分配一个隧道，ID 为 t8\n\nMME 将 eNodeB 给 SGW 分配的隧道 ID t8 告知 SGW，从而前面的隧道也建设完毕。（数据平面）\n\n数据面的协议都是通过 GTP-U，如图所示\n\n\n\n\n\n即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书\n\n如果你在巴塞罗那，一下飞机，手机开机，周围搜寻到的肯定是巴塞罗那的 eNodeB。通过 MME 去查询国内运营商的 HSS，看你是否合法，是否还有钱。如果允许上网，你的手机和巴塞罗那的 SGW 会建立一个隧道，然后巴塞罗那的 SGW 和国内运营商的 PGW 建立一个隧道，然后通过国内运营商的 PGW 上网\n因此，判断你是否能上网的是国内运营商的 HSS，控制你上网策略的是国内运营商的 PCRF，给手机分配的 IP 地址也是国内运营商的 PGW 负责的，给手机分配的 IP 地址也是国内运营商里统计的。运营商由于是在 PGW 里面统计的，这样你的上网流量全部通过国内运营商即可，只不过巴塞罗那运营商也要和国内运营商进行流量结算\n\n\n\n3.热门技术中的应用1.云计算中的网络1.云中网络\n为了解决物理设备维护费用高、扩展性不足的问题，发明了虚拟机，并基于它产生了云计算技术。在个人PC可以使用虚拟化软件；在数据中心可以使用qemu-kvm技术，来在物理机上通过软件虚拟出若干小机器\n\n虚拟网卡的原理：以qemu-kvm技术为例，通过Linux上的一种TUN/TAP技术来实现\n\n\n\n虚拟机软件通过打开一个称为 TUN/TAP 的 Char Dev（字符设备文件），打开了这个字符设备文件之后，在物理机上就能看到一张虚拟TAP网卡\n网络包会到虚拟网卡，将网络包转换成为文件流，写入字符设备，就像写一个文件一样。内核中 TUN/TAP 字符设备驱动会收到这个写入的文件流，交给 TUN/TAP 的虚拟网卡驱动。这个驱动将文件流再次转成网络包，交给 TCP/IP 协议栈，最终从虚拟 TAP 网卡发出来，成为标准的网络包\n\n\n虚拟网卡连接到云中：主要有共享（多个网卡共享出口）、隔离（网卡之间无影响）、互通（网卡之间能ping通）、灵活（灵活配置）几方面问题\n\n共享与互通问题\n\nhost-only：Linux上通过brctl addbr br0命令创建虚拟的网桥，然后将两个虚拟网卡连接到虚拟网桥上brctl addif br0 tap0，两个虚拟网卡就在相同的子网网段，两个虚拟机可以互相通信\n\n桥接网络：宿主机多了几张网卡，也就是虚拟交换机，其将多个虚拟机连接在一起，而且物理网卡也连接到这个虚拟交换机，也就是两个虚拟机和物理机是同一网段的。在数据中心只不过将上面的br0再连接到物理网卡上\n\nNAT：上面的不适合虚拟机很多的场景，会有广播的问题。可以通过NAT模式\n\n在这种方式下，登录到虚拟机里面查看 IP 地址，会发现虚拟机的网络是虚拟机的，物理机的网络是物理机的，两个不相同。虚拟机要想访问物理机的时候，需要将地址 NAT 成为物理机的地址\n还会在笔记本电脑里内置一个 DHCP 服务器，为笔记本电脑上的虚拟机动态分配 IP 地址。也可以手动为每台虚拟机配置IP地址\n\n\n\n\n隔离问题\n\n单物理机：brctl 创建的网桥也是支持 VLAN 功能的，可以设置两个虚拟机的 tag，这样在虚拟网桥上，两个虚拟机是不互通的\n跨物理机互通并实现VLAN的隔离：通过vconfig命令，基于物理网卡 eth0 创建带 VLAN 的虚拟网卡，所有从这个虚拟网卡出去的包，都带这个 VLAN，跨物理机的互通和隔离就可以通过这个网卡来实现\n一个物理机内部因为网桥不同，不能相互通信；出了网桥因为VLAN不同，包也不会被转发到另一个网桥上；出了物理机，会携带VLAN ID，到达另一物理机，包只会被转发给相同VLAN的网卡和网桥\n\n\n\n\n\n\n\n2.软件定义网络\n软件定义网络（SDN）：一种新型网络创新架构，网络虚拟化的一种实现方式。其核心技术OpenFlow通过将网络设备的控制面与数据面分离开来，从而实现了网络流量的灵活控制，有以下三个特点\n\n\n\n控制与转发分离：转发平面就是一个个虚拟或者物理的网络设备，控制平面就是统一的控制中心\n控制平面与转发平面之间的开放接口：控制器向上提供接口（北向接口），被应用层调用；控制器向下调用接口（南向接口），来控制网络设备\n逻辑上的集中控制：逻辑上集中的控制平面可以控制多个转发面设备，也就是控制整个物理网络，因而可以获得全局的网络状态视图，并根据该全局网络状态视图实现对网络的优化控制\n\n\nOpenFlow &amp; OpenvSwitch\n\n\n\nOpenFlow 是 SDN 控制器和网络设备之间互通的南向接口协议，OpenvSwitch 用于创建软件的虚拟交换机，支持 OpenFlow 协议，全都被统一的SDN管理器管理\n\nSDN 控制器是如何通过 OpenFlow 协议控制网络：OpenSwitch里面有一个FLow Table规则，任何通过这个交换机的包，都会经过这些规则进行处理，从而接受、转发、放弃。这些规则包括从哪个端口进来，网络包头里面有什么等。满足了条件的网络包，就要执行一个动作，对这个网络包进行处理。可以修改包头里的内容，可以跳到任何一个表格，可以转发到某个网口出去，也可以丢弃\n\n\n可以做的处理包括\n\n对于物理层\n匹配规则包括从哪个口进来\n执行动作包括从哪个口出去\n\n\n对于 MAC 层\n匹配规则包括：源 MAC 地址是多少？（dl_src），目标 MAC 是多少？（dl_dst），所属 vlan 是多少？（dl_vlan）\n执行动作包括：修改源 MAC（mod_dl_src），修改目标 MAC（mod_dl_dst），修改 VLAN（mod_vlan_vid），删除 VLAN（strip_vlan），MAC 地址学习（learn）\n\n\n对于网络层\n匹配规则包括：源 IP 地址是多少？(nw_src)，目标 IP 是多少？（nw_dst）。执行动作包括：修改源 IP 地址（mod_nw_src），修改目标 IP 地址（mod_nw_dst）\n对于传输层：匹配规则包括：源端口是多少？（tp_src），目标端口是多少？（tp_dst）。执行动作包括：修改源端口（mod_tp_src），修改目标端口（mod_tp_dst）\n\n\n\n\n创建虚拟机\n$ ovs-vsctl add-br br0\n\n\n\n\n示例\n\n示例一：用 OpenvSwitch 实现 VLAN 的功能\n在 OpenvSwitch 中端口 port 分两种\naccess port：可以配置tag，类似于VLAN ID\ntrunk port：不配置任何tag，配置trunks参数\n\n\n\n\n示例二：用 OpenvSwitch 模拟网卡绑定，连接交换机\n在 OpenvSwitch 里面，有个 bond_mode，可以设置为以下三个值\nactive-backup：一个连接是 active，其他的是 backup，只有当 active 失效的时候，backup 才顶上\nbalance-slb：流量按照源 MAC 和 output VLAN 进行负载均衡\nbalance-tcp：必须在支持 LACP 协议的情况下才可以，可根据 L2、L3、L4 进行负载均衡（L2、L3、L4 指的是网络协议 2、3、4 层）\n\n\n\n\n示例三：在云计算中使用 OpenvSwitch\n首先，由于 OpenvSwitch 本身就是支持 VLAN 的，这样所有的虚拟机都可以放在一个网桥 br0 上，通过不同的用户配置不同的 tag，就能够实现隔离\n另外，还可以创建一个虚拟交换机 br1，将物理网络和虚拟网络进行隔离。物理网络有物理网络的 VLAN 规划，虚拟机在一台物理机上，所有的 VLAN 都可以从 1 开始。由于一台物理机上的虚拟机肯定不会超过 4096 个，所以 VLAN 在一台物理机上如果从 1 开始，肯定够用了\n如果物理机之间的通信和隔离还是通过 VLAN 的话，需要将虚拟机的 VLAN 和物理环境的 VLAN 对应起来，但为了灵活性，不一定一致，这样可以实现分别管理物理机的网络和虚拟机的网络\n\n\n\n\n\n3.云中的网络安全\n对于云上的虚拟机，最好是只开放需要的端口，而将其他的端口一概关闭，这样就可以集中安全措施语这唯一的入口了。常常采用ACL（Access Control List 访问控制列表）来控制IP和端口，配置好后，就只有指定的IP段能够访问指定的开放接口，在云平台上，这些规则的集合称为安全组\n\n内核模块ip_tables\n\n一个网络包进入一台机器的处理流程，拿下MAC和IP后，将进行路由判断，路由判断前的节点叫PREROUTING、发给上面的传输层的节点叫INPUT、转发出去的节点叫FORWARD、上层返回处理结果的节点称为OUTPUT、最后一个节点是POSTROUTING\n\nNetfilter框架：Linux内核中的一个框架，可以在上述5个节点中插入hook函数，对数据包进行干预，例如交回协议栈就是ACCEPT、过滤掉不在传输就是DROP、发送给某个用户态进程处理就是QUEUE\n\n内核ip_tables：\n\nNetfilter框架的一个实现，可以在上述5个节点埋下函数，按功能可以分为四大类：连接跟踪（conntrack）、数据包的过滤（filter）、网络地址转换（nat）和数据包的修改（mangle），其中连接跟踪是基础功能，被其他功能所依赖\n\n用户端程序iptables，用命令行来干预内核的规则。内核的功能对应 iptables 的命令行来讲，就是表和链的概念，iptables的表分为四种（raw、mangel、nat、filter），raw不常用略去，并且分别对应五条链中的若干条\n\n\nfilter 表处理过滤功能，主要包含三个链：INPUT 链：过滤所有目标地址是本机的数据包；FORWARD 链：过滤所有路过本机的数据包；OUTPUT 链：过滤所有由本机产生的数据包\nnat 表主要是处理网络地址转换，可以进行 Snat（改变数据包的源地址）、Dnat（改变数据包的目标地址），包含三个链：PREROUTING 链：可以在数据包到达防火墙时改变目标地址；OUTPUT 链：可以改变本地产生的数据包的目标地址；POSTROUTING 链：在数据包离开防火墙时改变数据包的源地址\nmangle 表主要是修改数据包，包含：PREROUTING 链；INPUT 链；FORWARD 链；OUTPUT 链；POSTROUTING 链。\n\n\niptables 的表和链加入到上面的过程图中，就形成了下面的图和过程\n\n\n数据包进入的时候，先进 mangle 表的 PREROUTING 链。在这里可以根据需要，改变数据包头内容之后，进入 nat 表的 PREROUTING 链，在这里可以根据需要做 Dnat，也就是目标地址转换。\n进入路由判断，要判断是进入本地的还是转发的。\n如果是进入本地的，就进入 INPUT 链，之后按条件过滤限制进入。之后进入本机，再进入 OUTPUT 链，按条件过滤限制出去，离开本地。\n如果是转发就进入 FORWARD 链，根据条件过滤限制转发。之后进入 POSTROUTING 链，这里可以做 Snat，离开网络接口。\n\n\n\n\n\n\n\n\n在云中实现一定的安全策略\n\n可以通过iptables的配置来实现一些安全策略\n$ iptables -t filter -A INPUT -s 0.0.0.0&#x2F;0.0.0.0 -d X.X.X.X -j DROP\n$ iptables -I INPUT -s 0.0.0.0&#x2F;0.0.0.0 -d X.X.X.X -p tcp --dport 22 -j ACCEPT\n$ iptables -A INPUT -s 0.0.0.0&#x2F;0.0.0.0 -d X.X.X.X -p tcp --dport 80 -j ACCEPT\n安全组：云平台上允许一个或多个虚拟机属于某个安全组，而属于不同安全组的虚拟机之间的访问以及外网访问虚拟机，都需要安全组进行过滤，安全组的规则（iptables配置）会自动下发到每个在安全组里的虚拟机上\n\n安全组A允许任意 IP 地址 0.0.0.0/0 访问 8080 端口，但是对于 ssh 的 22 端口，仅仅允许管理员网段 203.0.113.0/24 访问\n安全组 B 里面，仅仅允许来自安全组 A 的机器访问 3306 端口，但是对于 ssh 的 22 端口，同样允许管理员网段 203.0.113.0/24 访问\n\n\n\nNetfilter的链接跟踪功能（conntrack）：所有虚拟机共享一个机房网和公网IP地址，解决返回的数据包怎么转发到对应的私有IP所在的虚拟机。通过在conntrack表里记录TCP连接和私网IP的对应关系\n源地址转换 (Snat)： $ iptables -t nat -A -s 私网 IP -j Snat --to-source 外网 IP\n目的地址转换 (Dnat)：$ iptables -t nat -A -PREROUTING -d 外网 IP -j Dnat --to-destination 私网 IP\n\n\n\n4.云中的网络QoS\nQoS（Quality of Service）：云平台上的一种流量控制技术，对于控制一台机器的网络的QoS，分为两个方向，入方向和出方向，只能通过Shaping控制出方向，进入方向无法控制，只能通过Policy将包丢弃\n\n控制网络的QoS：在 Linux 下，可以通过 TC （流量控制工具）控制网络的 QoS，主要就是通过队列的方式\n\n无类别排队规则\n\n无类别排队规则（Classless Queuing Disciplines）：如ip addr返回的pfifo_fast，是一种不把网络包分类的技术，pfifo_fast 分为三个先入先出的队列，称为三个 Band。根据网络包里面 TOS，看这个包到底应该进入哪个队列。TOS 总共四位，每一位表示的意思不同，总共十六种类型\n\n随机公平队列（Stochastic Fair Queuing）：会建立若干FIFO队列，TCP Session会计算hash值，通过hash值分配到某个队列，队列另一端，通过轮询从各队列取网络包并发送，防止一个Session占据所有流量\n\n\n令牌桶规则（TBF，Token Bucket Filte）：所有的网络包排成队列进行发送，但不是到了队头就能发送，而是需要拿到令牌才能发送。令牌根据设定的速度生成，所以即便队列很长，也是按照一定的速度进行发送的\n\n\n\n\n基于类别的队列规则\n\n分层令牌桶规则（HTB， Hierarchical Token Bucket）：HTB往往是一棵树，特点是同一个 root class 下的子类可以相互借流量\n$ tc qdisc add dev eth0 root handle 1: htb default 12\n$ tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps\n$ tc class add dev eth0 parent 1:1 classid 1:10 htb rate 30kbps ceil 100kbps\n$ tc class add dev eth0 parent 1:1 classid 1:11 htb rate 10kbps ceil 100kbps\n$ tc class add dev eth0 parent 1:1 classid 1:12 htb rate 60kbps ceil 100kbps\n$ tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5\n$ tc qdisc add dev eth0 parent 1:11 handle 30: pfifo limit 5\n$ tc qdisc add dev eth0 parent 1:12 handle 40: sfq perturb 10\n\n\n\n\n\n\n\n\n\n如何控制QoS\n\n对于进入的流量，可以设置策略Ingress policy\novs-vsctl set Interface tap0 ingress_policing_rate&#x3D;100000\novs-vsctl set Interface tap0 ingress_policing_burst&#x3D;10000\n对于发出的流量，可以设置QoS规则Egress shaping，支持 HTB\n\n\n\n\n5.云中网络的隔离GRE、VXLAN2.容器技术中的网络\n\n\n\n\n\n\n\n\n云计算解决了基础资源层的弹性伸缩，但没有解决PaaS层应用随基础资源层弹性伸缩而带来的批量、快速部署问题，于是，容器应运而生\n1.容器网络\n\n\n\n\n\n\n\n\n主要依靠两种技术：看起来隔离的技术namespace、用起来隔离的技术cgroup\n\nnamespace\n类似于面向对象编程语言的命名空间，每个namespace中的应用看到的是不同的IP地址、用户空间、进程号等。网络的namespace有ip netns命令操作，可以创建、删除、查询namespace\n\n\n\ncgroup：虽然整台机器有很多的CPU、内存，但是一个应用只能用其中的一部分\n\n\n2.容器网络之Flannel3.容器网络之Callco3.微服务相关协议1.RPC协议综述\n定义：Bruce Jay Nelson 写了一篇论文Implementing Remote Procedure Calls，定义了RPC的调用标准，后面所有RPC框架都是基于此标准，架构如下\n\n\nNFS为例\n\nNFS（Network File System）就是网络文件系统。要使 NFS 成功运行，要启动两个服务端，一个是 mountd，用来挂载文件路径；一个是 nfsd，用来读写文件。NFS 可以在本地 mount 一个远程的目录到本地的一个目录，从而本地的用户在这个目录里面写入、读出任何文件的时候，其实操作的是远程另一台机器上的文件（XDR是一个标准的数据压缩格式，可以表示基本的数据类型，也可以表示结构体）\n\n\n协议约定问题（约定各种格式）\n\nRPC调用过程中，所有数据类型都要封装成特定的格式\n\n\nRPC调用和结果返回有严格的格式\n\n\n在客户端和服务端实现 RPC 的时候，首先要定义一个双方都认可的程序、版本、方法、参数等\n\n\n\n\n传输问题：\n\n通过ONE RPC的的类库来实现，对于每一个客户端，都会创建一个传输管理层，而每一次RPC调用，都会是一个任务，在传输管理层，可以看到队列机制、拥塞窗口机制\n\n\n状态转换图\n\n\n\n\n服务发现问题：在ONE RPC中，通过portmapper实现，portmapper会启动在一个众所周知的端口上，PRC程序是用户自己写的，会监听在一个随机端口上，但是RPC程序启动的时候会向portmapper注册，客户端要访问RPC服务端这个服务的时候，首先查询portmapper，获取RPC程序的随机端口，然后向这个端口建立连接，开始RPC调用\n\n\n\n\n\n2.基于XML的SOAP协议\n\n\n3.基于JSON的RESTful接口协议4.二进制类RPC协议5.跨语言类RPC协议Kubernetes1.Docker1.概念\ndocker 架构（通过docker run hello-world可以展示详细工作流程）\n\n\n命令行工具docker实际上是一个client，他会与Docker Engine里的后台服务Docker daemon通信，镜像存储在远端的Registry里，客户端不能直接访问镜像仓库\nDocker client可以通过build、pull、run等命令向Docker daemon发送请求，而Docker daemon则负责从远端拉去镜像、在本地存储镜像、从镜像生成容器、管理容器等功能\n容器化的应用：指应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行。镜像就是静态的应用容器，容器就是动态的应用镜像\n\n\n隔离怎么实现的\n\n其实奥秘就在于 Linux 操作系统内核之中，为资源隔离提供了三种技术：namespace、cgroup、chroot，虽然这三种技术的初衷并不是为了实现容器，但它们三个结合在一起就会发生奇妙的“化学反应”\nnamespace 是 2002 年从 Linux 2.4.19 开始出现的，和编程语言里的 namespace 有点类似，它可以创建出独立的文件系统、主机名、进程号、网络等资源空间，相当于给进程盖了一间小板房，这样就实现了系统全局资源和进程局部资源的隔离\ncgroup 是 2008 年从 Linux 2.6.24 开始出现的，它的全称是 Linux Control Group，用来实现对进程的 CPU、内存等资源的优先级和配额限制，相当于给进程的小板房加了一个天花板\nchroot 的历史则要比前面的 namespace、cgroup 要古老得多，早在 1979 年的 UNIX V7 就已经出现了，它可以更改进程的根目录，也就是限制访问文件系统，相当于给进程的小板房铺上了地砖\n\n\n镜像的内部机制\n\n分层（Layer）：容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫“Union FS 联合文件系统”的技术把它们合并在一起，就形成了容器最终看到的文件系统\n\n如果某两层有文件同名，则只能看到上层的文件，下层的就被屏蔽了，可以使用docker inspect nginx:alpine来查看镜像的分层信息（RootFS部分）\n在拉取镜像的时候，只会拉取缺少的层；在删除镜像的时候，只会删除没有未被共享的层\n\n\n\n容器与外部互联互通\n\n文件\n\ndocker cp+源路径+目标路径 命令可以在容器和主机之间互相拷贝文件，适合简单的数据交换，其中目标路径需要用容器名/ID来指明是那个容器的路径，示例：docker cp a.txt 062:/tmp\ndocker run -v 命令可以让容器和主机共享本地目录，免去了拷贝操作，提升工作效率，示例：docker run -d --rm -v /tmp:/tmp redis，格式为宿主机路径: 容器内路径，把本机的/tmp路径挂载道容器里的/tmp目录，常用于不同环境运行相同文件\n\n\n网络\n\n网络分类\n\nhost 网络模式让容器与主机共享网络栈，效率高但容易导致端口冲突，docker run -d --rm --net=host nginx:alpine\nbridge 网络模式实现了一个虚拟网桥，容器和主机都在一个私有网段内互联互通，默认使用此模式\n\n\ndocker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息\n\n新建网络：docker network create -d bridge test-net\n\n-d：指定Docker网络类型，可以是bridge、overlay（用于Swarm）\n\n\n连接容器\n\n运行一个容器并连接到新建的 test-net 网络:\n$ docker run -itd --name test1 --network test-net ubuntu &#x2F;bin&#x2F;bash\n打开新的终端，再运行一个容器并加入到 test-net 网络:\n$ docker run -itd --name test2 --network test-net ubuntu &#x2F;bin&#x2F;bash\ntest1和test2可以互相ping通，二者建立了互联关系，如果有多个容器，推荐使用Docker Compose\n\n\n\n\n\n网络端口映射：docker run -p 命令可以把主机的端口号映射到容器的内部端口号，解决了潜在的端口冲突\n\n-P：是容器内部端口随机映射到主机的端口\n$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py\n33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0\n-p：是容器内部端口绑定到指定的主机端口，还可以附加绑定网络地址\n$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py\n6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a\n\n\n\n\n\n\n\n\n2.常用操作\n安装docker服务\n\n安装docker：sudo apt install -y docker.io\n启动docker服务：sudo service docker start\n当前用户加入docker组：sudo usermod -aG docker $&#123;USER&#125;，\n因为操作 Docker 必须要有 root 权限，而直接使用 root 用户不够安全\nDocker官方推荐将当前用户加入 Docker 用户组\n执行完成之后，还需要退出系统（命令 exit ），再重新登录一次，这样才能让修改用户组的命令 usermod 生效\n\n\n验证docker是否安装成功：docker version和docker info\n\n\ndocker使用\n\n\n\n查看镜像/容器：\n\n查看运行的容器：docker ps\n\nCONTAINER ID: 容器 ID；IMAGE: 使用的镜像；COMMAND**:** 启动容器时运行的命令；CREATED: 容器的创建时间\nSTATUS: 容器状态，主要有7种状态：created（已创建）、restarting（重启中）、running 或 Up（运行中）、removing（迁移中）、paused（暂停）、exited（停止）、dead（死亡）\nPORTS: 容器的端口信息和使用的连接类型（tcp\\udp）；NAMES: 自动分配的容器名称\n\n\n查看运行完毕的容器：docker ps -a\n\n查看已存储镜像的信息：docker images\n\nREPOSITORY：表示镜像的仓库源，通过REPOSITORY:TAG来定义不同的镜像；TAG：镜像的标签，同一仓库可以有多个TAG，代表这个仓库的不同个版本；IMAGE ID：镜像ID；CREATED：镜像创建时间；SIZE：镜像大小\n\n\n可以通过docker logs 容器ID来查看容器内的标准输出\n\n查找镜像：docker search 镜像名\n\nNAME: 镜像仓库源的名称；DESCRIPTION：镜像的描述；OFFICIAL: 是否 docker 官方发布；stars: 类似 Github 里面的 star；AUTOMATED: 自动构建\n\n\n\n\n拉取镜像：docker pull busybox\n\n获取一个打包了的busybox应用的镜像，里面固化了busybox程序和它所需的完整运行环境\n镜像的完整名字由两个部分组成：名字:标签，标签（tag）是为了区分不同版本的应用而做的额外标记，可以是任意字符串，默认标签是latest\n\n\n启动镜像：docer run+参数+镜像名/ID+运行命令（通过docker run --help来查看帮助信息）\n\n启动并执行echo输出字符串：docker run busybox echo hello world，提取镜像里的各种信息，运用namespace、cgroup、chroot技术创造出隔离环境，然后运行busybox的echo命令，输出字符串\n启动镜像，离开当前操作系统，进入新系统：docker run -it arm64v8/ubuntu /bin/bash，-it表示开启一个交互式操作的Shell，可以直接进入容器内部，通过exit命令或者Crtl+D退出\n-t: 在新容器内指定一个伪终端或终端\n-i: 允许对容器内的标准输入 (STDIN) 进行交互\n\n\n后台运行：docker run -d --name red_srv redis，-d表示让容器在后台运行，用于启动服务器程序；--name可以为容器起一个名字，否则会分配一个随机的名字\n可以通过IMAGE ID进行短路操作，仅使用前几位就可定位到对应容器\ndocker run -d --rm redis：--rm参数告诉Docker不保存容器，再运行完毕后就自动清除\n\n\n删除镜像：docker rmi redis\n\ndocker rm ID：只会删除容器，不会删除镜像 \n\n\n停止容器：docker stop CONTAINER ID\n\n只能通过docker ps -a查看已停止运行的容器，通过docker start ID再次启动运行\n\n\n运行的容器中在执行另一程序：docker exec -it red_srv sh，登陆进入Redis容器，方便查看服务的运行状态和日志。效果同docker run，但因为容器已存在，所以不会创建新容器\n\n进入容器：通过docker exec -it 容器ID /bin/bash来进入后台运行的容器，并且推出时不会导致容器终止，docker attach 容器ID会在退出时终止容器\n\n\n导出和导入容器\n\n导出本地某个容器：docker export 容器ID &gt; ubuntu.tar\n从容器快照文件中再导入为镜像：cat docker/ubuntu.tar | docker import - test/ubuntu:v1\n\n\n\n\n创建容器\n\nDockerfile：一个纯文本，里面记录了一些列的构建指令，比如选择基础镜像、拷贝文件、执行脚本等，每个指令都会生成一个Layer，而Docker顺序执行这个文件的所有步骤，最终会创建出一个新的镜像出来\n\nDockerfile内部指令（不区分大小写，一条指令生成一个镜像）\n\nFROM：所有Dockerfile都要从它开始，表示选择构建使用的基础镜像，相当于打地基，如果关注镜像的安全和大小，一般选择Alpine；如果关注运行的稳定性，则可以选择Ubuntu、CentOS、Debian\nCMD：制定docker run启动容器时默认运行的命令\nCOPY：需要把开发测试产生的一一些源码、配置等文件打包进镜像里，拷贝的源文件必须是构建上下文路径，不能随意指定文件，也就是说，必须把这些文件放在一个专门的目录，然后再docker build里指定构建上下文到这个目录才行\nRUN：执行任意的Shell命令，实现任意的镜像构建步骤，所有RUN指令会在每行的末尾使用续行符\\，命令之间也会用&amp;&amp;来连接，这样保证在逻辑上是一行（可以把这些Shell集中到一个脚本文件，然后用COPY命令拷贝进去在用RUN来执行）\nARG：用于创建变量，创建的变量只在镜像构建过程中可见，容器运行时不可见\nENV：用于创建变量，创建的变量不仅能够在构建镜像的过程中使用，在容器运行时也能够以环境变量的形式被应用程序使用\nEXPOSE：用来声明容器对外服务的端口号，对现在基于Node.js、Tomcat、Nginx、Go等开发的微服务系统来说非常有用\n\n\n构建镜像：docker build -f Dockerfile.busybox .，-f指定Dockerfile文件名，后面必须跟一个文件路径，叫做构建上下文（build‘s context），这里只是一个简单的点号，表示当前路径\n\n新的镜像暂时没有名字（&lt;none&gt;），可以直接使用ID来查看或运行，可以通过-t参数来指定镜像的标签（tag），名字需要符合规范，用:分割名字和标签\n\n构建上下文：docker客户端只是把构建上下文目录打包上传，这样服务器才能获得本地的这些文件，就是指定了要打包进镜像的一些依赖文件\n\n为了避免目录中某些不必要文件（例如 readme/.git/.svn 等）拷贝进镜像，可以在构建上下文目录里再建立一个 .dockerignore 文件，语法与 .gitignore 类似，排除那些不需要的文件\n$ cat Dockerfile #每一指令都会在镜像上创建一个新的层，每一指令的前缀都必须是大写\nFROM    centos:6.7 #指定使用哪个镜像源\nMAINTAINER      Fisher &quot;fisher@sudops.com&quot;\n#RUN 指令告诉docker 在镜像内执行命令，安装了什么\nRUN     &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd\nRUN     useradd runoob\nRUN     &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswd\nRUN     &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\\&quot;en_US.UTF-8\\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;local\nEXPOSE  22\nEXPOSE  80\nCMD     &#x2F;usr&#x2F;sbin&#x2F;sshd -D\n\n\n更新已有镜像并提交：-m提交的描述信息、-a镜像作者、e218edb10161容器ID、runoob/ubuntu:v2镜像名。可以使用dockr images来查看新镜像\n$ docker commit -m&#x3D;&quot;has update&quot; -a&#x3D;&quot;runoob&quot; e218edb10161 runoob&#x2F;ubuntu:v2\nsha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8\n\n\n\n\n3.实践1.Docker容器引擎1. Docker出现的背景　　在平常的研发和项目场景中，以下情况普遍存在：\n\n个人开发环境为了做大数据相关项目，需要安装一套CDH集群，常见的做法是在自己电脑里搭建3台与CDH版本对应的虚拟机，把CDH集群装起来后，考虑到以后很有可能还要使用一个干净的CDH集群，为了避免以后重复安装环境，通常会对整套CDH集群做一个备份，这样电脑里就有6个虚拟机镜像了。另外，后面在学习其他技术时，比如学习Ambari大数据集群，那么为了不破坏已有的虚拟机环境，又要重新搭建3台虚拟机，本机磁盘很快被一大堆的虚拟机镜像占满。\n公司内部开发环境公司里往往会以小团队的方式来做项目，一般由运维部门从他们管理的服务器资源中分配出虚拟机供团队内部开发测试使用。比如做一个与机器学习相关的项目：\n小明在运维部门分配的虚拟机上搭建了一套Ambari集群，拿来跑大数据相关业务\n小刚用python3写了一个机器学习算法，放到虚拟机上运行发现虚拟机里是python2，算法不兼容，于是把虚拟机里的python版本升级了，算法跑通了，但Ambari用到python的部分功能可能就报错了\n小李开发了应用，放到虚拟机上启动tomcat，发现虚拟机里的是OpenJDK，导致tomcat起不来，于是又安装了一个JDK，这时候可能Ambari里的Java代码可能就报错了\n小赵想利用服务器资源做性能测试，发现虚拟机严重削减了性能，最终还是要直接找物理机来跑测试，破坏了物理机原来的环境\n做完项目后，这些虚拟机上安装的东西往往变得没用了，下个项目组来还是得新申请虚拟机重新部署软件\n\n\n开发/测试/现场环境研发人员在开发环境里写好了代码做好测试后，提交给测试部门，测试人员在测试环境跑起来发现有BUG，研发人员说在开发环境没这个BUG，和测试人员多次扯皮解决BUG后发布版本，发到现场在生产环境部署后，又发现有BUG，这下轮到工程人员和测试人员扯皮。有时候为了兼容特殊的现场环境，还需要对代码进行定制化修改，拉出分支，这样导致了每次到现场升级都是一场噩梦\n升级或迁移项目在每次发版本要升级到现场时，如果现场起了多个tomcat应用，那么需要对每个tomcat都先停掉，替换war包，然后再起起来，轮流着做，不仅繁琐而且很容易出错，如果遇到升级后出现严重BUG，还要手工做回退。另外，如果项目想上云，那么在云上部署后要重新进行一轮测试，如果后面考虑还云厂商，可能相同的测试还要再进行一次（比如更换了数据存储组件），费时费力。\n\n　　总结以上列举的所有场景，他们存在的一个共同的问题是：没有一种既能够屏蔽操作系统差异，又能够以不降低性能的方式来运行应用的技术，来解决环境依赖的问题。Docker应运而生。\n2. Docker是什么\n　　Docker是一种应用容器引擎。首先说一下何为容器，Linux系统提供了Namespace和CGroup技术实现环境隔离和资源控制，其中Namespace是Linux提供的一种内核级别环境隔离的方法，能使一个进程和该进程创建的子进程的运行空间都与Linux的超级父进程相隔离，注意Namespace只能实现运行空间的隔离，物理资源还是所有进程共用的，为了实现资源隔离，Linux系统提供了CGroup技术来控制一个进程组群可使用的资源（如CPU、内存、磁盘IO等），把这两种技术结合起来，就能构造一个用户空间独立且限定了资源的对象，这样的对象称为容器。Linux Container是Linux系统提供的容器化技术，简称LXC，它结合Namespace和CGroup技术为用户提供了更易用的接口来实现容器化。LXC仅为一种轻量级的容器化技术，它仅能对部分资源进行限制，无法做到诸如网络限制、磁盘空间占用限制等。dotCloud公司结合LXC和以下列出的技术实现了Docker容器引擎，相比于LXC，Docker具备更加全面的资源控制能力，是一种应用级别的容器引擎。\n\nChroot：该技术能在container里构造完整的Linux文件系统；\nVeth：该技术能够在主机上虚拟出一张网卡与container里的eth0网卡进行桥接，实现容器与主机、容器之间的网络通信；\nUnionFS：联合文件系统，Docker利用该技术“Copy on Write”的特点实现容器的快速启动和极少的资源占用，后面会专门介绍该文件系统；\nIptables/netfilter：通过这两个技术实现控制container网络访问策略；\nTC：该技术主要用来做流量隔离，限制带宽；\nQuota：该技术用来限制磁盘读写空间的大小；\nSetrlimit：该技术用来限制container中打开的进程数，限制打开的文件个数等\n\n\n\n\n\n\n\n\n\n\n也正是因为Docker依赖Linux内核的这些技术，至少使用3.8或更高版本的内核才能运行Docker容器，官方建议使用3.10以上的内核版本。\n3. 与传统虚拟化技术的区别\n　　传统的虚拟化技术在虚拟机（VM）和硬件之间加了一个软件层Hypervisor，或者叫做虚拟机管理程序。Hypervisor的运行方式分为两类：\n\n直接运行在物理硬件之上。如基于内核的KVM虚拟机，这种虚拟化需要CPU支持虚拟化技术；\n运行在另一个操作系统。如VMWare和VitrualBox等虚拟机。\n\n　　因为运行在虚拟机上的操作系统是通过Hypervisor来最终分享硬件，所以虚拟机Guest OS发出的指令都需要被Hypervisor捕获，然后翻译为物理硬件或宿主机操作系统能够识别的指令。VMWare和VirtualBox等虚拟机在性能方面远不如裸机，但基于硬件虚拟机的KVM约能发挥裸机80%的性能。这种虚拟化的优点是不同虚拟机之间实现了完全隔离，安全性很高，并且能够在一台物理机上运行多种内核的操作系统（如Linux和Window），但每个虚拟机都很笨重，占用资源多而且启动很慢。\n　　Docker引擎运行在操作系统上，是基于内核的LXC、Chroot等技术实现容器的环境隔离和资源控制，在容器启动后，容器里的进程直接与内核交互，无需经过Docker引擎中转，因此几乎没有性能损耗，能发挥出裸机的全部性能。但由于Docker是基于Linux内核技术实现容器化的，因此使得容器内运行的应用只能运行在Linux内核的操作系统上。目前在Window上安装的docker引擎其实是利用了Window自带的Hyper-V虚拟化工具自动创建了一个Linux系统，容器内的操作实际上是间接使用这个虚拟系统实现的。\n4. Docker基本概念\n　　Docker主要有如下几个概念：\n\n引擎：创建和管理容器的工具，通过读取镜像来生成容器，并负责从仓库拉取镜像或提交镜像到仓库中；\n镜像：类似于虚拟机镜像，一般由一个基本操作系统环境和多个应用程序打包而成，是创建容器的模板；\n容器：可看作一个简易版的Linxu系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子；\n仓库：集中存放镜像文件的场所，分为公共仓库和私有仓库，目前最大的公共仓库是官方提供的Docker Hub，此外国内的阿里云、腾讯云等也提供了公共仓库；\n宿主机：运行引擎的操作系统所在服务器。\n\n5. Docker与虚拟机、Git、JVM的类比　　为了让大家对Docker有更直观的认识，下面分别进行三组类比：\n\n　　上图中Docker的镜像仓库类似于传统虚拟机的镜像仓库或存放镜像的本地文件系统，Docker引擎启动容器来运行Spark集群（容器内包含基础的Linux操作系统环境），类比于虚拟机软件启动多个虚拟机，在虚拟机内分别运行Spark进程，两者区别在于Docker容器内的应用在使用物理资源时，直接与内核打交道，无需经过Docker引擎。\n\n　　Docker的仓库思想与Git是相同的。\n\n　　Docker的口号是“Build，Ship，and Run Any App，Anywhere”，也就是可以基于Docker构建、装载和运行应用程序，一次构建到处运行。Java的口号是“Write Once,Run Anywhere”，即一次编写到处运行。Java是基于JVM适配操作系统的特点来屏蔽系统的差异，Docker则是利用内核版本兼容性的特点来实现一次构建导出运行，只要Linux系统的内核是3.8或更高的版本，就都能把容器跑起来。\n\n\n\n\n\n\n\n\n\n当然，正如Java中如果应用代码使用了JDK10的新特性，基于JDK8就无法运行一样，如果容器内的应用使用了4.18版本的内核特性，那么在CentOS7（内核版本为3.10）启动容器时，虽然容器能够启动，但里面应用的功能是无法正常运行的，除非把宿主机的操作系统内核升级到4.18版本。\n6. Docker镜像文件系统\n　　Docker镜像采用分层存储格式，每个镜像可依赖其他镜像进行构建，每一层的镜像可被多个镜像引用，上图的镜像依赖关系，K8S镜像其实是CentOS+GCC+GO+K8S这四个软件结合的镜像。这种分层结构能充分共享镜像层，能大大减少镜像仓库占用的空间，而对用户而言，他们所看到的容器，其实是Docker利用UnionFS（联合文件系统）把相关镜像层的目录“联合”到同一个挂载点呈现出来的一个整体，这里需要简单介绍一个UnionFS是什么：\n\n\n\n\n\n\n\n\n\nUnionFS可以把多个物理位置独立的目录（也叫分支）内容联合挂载到同一个目录下，UnionFS允许控制这些目录的读写权限，此外对于只读的文件和目录，它具有“Copy on Write（写实复制）”的特点，即如果对一个只读的文件进行修改，在修改前会先把文件复制一份到可写层（可能是磁盘里的一个目录），所有的修改操作其实都是对这个文件副本进行修改，原来的只读文件并不会变化。其中一个使用UnionFS的例子是：Knoppix，一个用于Linux演示、光盘教学和商业产品演示的Linux发行版，它就是把一个CD/DVD和一个存在在可读写设备（例如U盘）联合挂载，这样在演示过程中任何对CD/DVD上文件的改动都会在被应用在U盘上，不改变原来的CD/DVD上的内容。\n　　UnionFS有很多种，其中Docker中常用的是AUFS，这是UnionFS的升级版，除此之外还有DeviceMapper、Overlay2、ZFS和 VFS等。Docker镜像的每一层默认存放在/var/lib/docker/aufs/diff目录中，当用户启动一个容器时，Docker引擎首先在/var/lib/docker/aufs/diff中新建一个可读写层目录，然后使用UnionFS把该可读写层目录和指定镜像的各层目录联合挂载到/var/lib/docker/aufs/mnt里的一个目录中（其中指定镜像的各层目录都以只读方式挂载），通过LXC等技术进行环境隔离和资源控制，使容器里的应用仅依赖mnt目录中对应的挂载目录和文件运行起来。\n　　利用UnionFS写实复制的特点，在启动一个容器时， Docker引擎实际上只是增加了一个可写层和构造了一个Linux容器，这两者都几乎不消耗系统资源，因此Docker容器能够做到秒级启动，一台服务器上能够启动上千个Docker容器，而传统虚拟机在一台服务器上启动几十个就已经非常吃力了，而且虚拟机启动很慢，这是Docker相比于传统虚拟机的两个巨大的优势。\n　　当应用只是直接调用了内核功能来运作的情况下，应用本身就能直接作为最底层的层来构建镜像，但因为容器本身会隔绝环境，因此容器内部是无法访问宿主机里文件的（除非指定了某些目录或文件映射到容器内），这种情况下应用代码就只能使用内核的功能。但是Linux内核仅提供了进程管理、内存管理、文件系统管理等一些基础且底层的管理功能，在实际的场景中，几乎所有软件都是基于操作系统来开发的，因此往往都需要依赖操作系统的软件和运行库等，如果这些应用的下一层直接是内核，那么应用将无法运行。所以实际上应用镜像往往底层都是基于一个操作系统镜像来补足运行依赖的。\n　　Docker中的操作系统镜像，与平常安装系统时用的ISO镜像不同。ISO镜像里包含了操作系统内核及该发行版系统包含的所有目录和软件，而Docker中的操作系统镜像，不包含系统内核，仅包含系统必备的一些目录（如/etc /proc等）和常用的软件和运行库等，可把操作系统镜像看作内核之上的一个应用，一个封装了内核功能，并为用户编写的应用提供运行环境的工具。应用基于这样的镜像构建，就能够利用上相应操作系统的各种软件的功能和运行库，此外，由于应用是基于操作系统镜像来构建的，就算换到另外的服务器，只要操作系统镜像中被应用使用到的功能能适配宿主机的内核，应用就能正常运行，这就是一次构建到处运行的原因。\n　　下图形象的表现出了镜像和容器的关系：\n\n　　上图中Apache应用基于emacs镜像构建，emacs基于Debian系统镜像构建，在启动为容器时，在Apache镜像层之上构造了一个可写层，对容器本身的修改操作都在可写层中进行。Debian是该镜像的基础镜像（Base Image），它提供了内核Kernel的更高级的封装。同时其他的镜像也是基于同一个内核来构建的（以下的BusyBox是一个精简版的操作系统镜像）：\n\n　　这时候就会有一个问题，应用基于操作系统镜像来构建，那如果操作系统镜像本身就很占空间，岂不是镜像的分发不方便，而且镜像仓库占用的空间也会很大。有人已经考虑到这一点，针对不同的场景分别构造了不同的操作系统镜像，下面介绍几种最常用的系统镜像。\n7. Docker基础操作系统\n　　以上系统镜像分别适用于不同的场景：\n\nBusyBox：一个极简版的Linux系统，集成了100多种常用Linux命令，大小不到2MB，被称为“Linux系统的瑞士军刀”，适用于简单测试场景；\nAlpine：一个面向安全的轻型Linux发行版系统，比BusyBox功能更完善，大小不到5MB，是官网推荐的基础镜像，由于其包含了足够的基础功能和体积较小，在生产环境中最常用；\nDebian/Ubuntu： Debian系列操作系统，功能完善，大小约170MB，适合研发环境；\nCentOS/Fedora：都是基于Redhat的Linux发行版，企业级服务器常用操作系统，稳定性高，大小约200MB，适合生产环境使用。\n\n8. Docker持久化存储　　根据前面介绍的容器UnionFS写实复制的特点，可知在容器里增加、删除或修改文件，其实都是对可写层里的文件副本进行了操作。在容器关闭后，该可写层也会被删除，对容器的所有修改都会失效，因此需要解决容器内文件持久化的问题。Docker提供了两种方案来实现：\n\n把宿主机文件系统里的目录映射到容器内的目录，如下图所示。如此一来，容器内在该目录里创建的所有文件，都存储到宿主机的对应目录中，在关闭容器后，宿主机的目录依然存在，再次启动容器时还能读取到之前创建的文件，因此实现了容器的文件持久化。当然同时要明白，如果是对镜像自带文件进行了修改，由于镜像是只读的，该修改操作无法在关闭容器时保存下来，除非在修改了文件后构建一个新的镜像。\n\n\n\n把多台宿主机的磁盘目录通过网络联合为共享存储，然后把共享存储中的特定目录映射给特定的容器，如下图所示。这样容器在重启时，还是能读取到关闭前创建的文件。生产环境中常用NFS作为共享存储方案。\n\n\n9. Docker镜像制作方法　　镜像制作方法有两种：\n\n通过正在运行的容器生成新镜像\n\n\n　　当一个容器在运行时，在里面所有的修改都会体现在容器的可写层，Docker提供了commit命令，可以把正在运行的容器，叠加上可写层的修改内容，生成一个新镜像。如上图所示，在容器里新安装Spark组件的，如果关闭容器，Spark组件会随着可写层的消失而消失，如果在关闭容器之前使用commit命令生成新镜像，那么使用新镜像启动为容器时，容器里就会包含Spark组件。\n　　这种方式比较简单，但无法直观的设置环境变量、监听端口等内容，适合在简单使用的场景运用。\n\n通过Dockerfile文件来生成新镜像\n\n\n　　Dockerfile是一个定义了镜像创建步骤的文件，Docker引擎通过build命令读取Dockerfile，按定义的步骤来一步步构造镜像。在研发和实施环境中，通过Dockerfile 创建容器是主流做法。下面是一个Dockerfile的例子：\nFROM ubuntu&#x2F;14.04                                # 基础镜像\nMAINTAINER guest                                 # 制作者签名\nRUN apt-get install openssh-server -y            # 安装ssh服务\nRUN mkdir &#x2F;var&#x2F;run&#x2F;sshd                          # 创建目录\nRUN useradd -s &#x2F;bin&#x2F;bash -m -d &#x2F;home&#x2F;guest guest # 创建用户\nRUN echo ‘guest:123456’| chpasswd                # 修改用户密码\nENV RUNNABLE_USER_DIR &#x2F;home&#x2F;guest                # 设置环境变量\nEXPOSE 22                                        # 容器内默认开启的端口\nCMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd -D&quot;]                        # 启动容器时自动启动ssh服务\n\n　　Docker引擎可以根据以上Dockerfile定义的步骤，构造出一个带有ssh服务的Ubuntu镜像。\n10. Docker的使用场景　　Docker作为一种轻量级的虚拟化方案，应用场景十分丰富，下面收集了一些常见的场景：\n\n作为轻量级虚拟机使用可以使用Ubuntu等系统镜像创建容器，当作虚拟机来使用，相比于传统虚拟机，启动速度更快，资源占用更少，单机可以启动大量的操作系统容器，方便进行各种测试；\n作为云主机使用结合Kubernetes这样的容器管理系统，可以在大量服务器上动态分配和管理容器，在公司内部，甚至可以取代VMWare这样的虚拟机管理平台，使用Docker容器作为云主机使用；\n应用服务打包在Web应用服务开发场景，可以把Java运行环境、Tomcat服务器打包为一个基础镜像，在修改了代码包后加入到基础镜像来构建一个新的镜像，能很方便的升级服务和控制版本；\n容器云平台CaaSDocker的出现，使得很多云平台供应商开始提供容器云的服务，简称容器即服务CaaS，以下对比一下IaaS、PaaS和SaaS：\nIaaS（基础设施即服务）：提供虚拟机或者其他基础资源作为服务提供给用户。用户可以从供应商那里获得虚拟机或者存储等资源来装载相关的应用，同时这些基础设施的繁琐的管理工作将由IaaS供应商来处理。其主要的用户是企业的系统管理员和运维人员；\nPaaS（平台即服务）：把开发平台作为服务提供给用户。用户可以在一个包括SDK，文档和测试环境等在内的开发平台上非常方便地编写应用，而且不论是在部署，或者在运行的时候，用户都无需为服务器、操作系统、网络和存储等资源的管理操心，这些繁琐的工作都由PaaS供应商负责处理。其主要的用户是企业开发人员。\nSaaS（软件即服务）：将应用作为服务提供给客户。用户只要接上网络，并通过浏览器，就能直接使用在云端上运行的应用，而不需要顾虑类似安装等琐事，并且免去初期高昂的软硬件投入。SaaS主要面对的是普通的用户。\nCaaS（容器即服务）：完成IaaS和PaaS两个层级的功能。相对于传统的IaaS和PaaS服务，CaaS对底层的支持比PaaS更灵活，而对上层应用的操控又比IaaS更容易。同时因为Docker是比VM更细粒度的虚拟化服务，所以能够对计算资源做到更高效的利用。CaaS可以部署在任何物理机，虚拟机或IaaS云之上。\n\n\n持续集成和持续部署互联网行业提倡敏捷开发，持续集成部署CI/CD便是最典型的开发模式。使用Docker容器云平台，就能实现从代码编写完成推送到Git/SVN后，自动触发后端CaaS平台将代码下载、编译并构建成测试Docker镜像，再替换测试环境容器服务，自动在Jenkins或者Hudson中运行单元/集成测试，测试通过后，马上就能自动将新版本镜像更新到线上，完成服务升级。整个过程全自动化，一气呵成，最大程度地简化了运维，而且保证线上、线下环境完全一致，而且线上服务版本与Git/SVN发布分支也实现统一。\n解决微服务架构的实施难题基于Spring Cloud这样的微服务框架，能够实现微服务的管理，但微服务本身还是需要运行在操作系统上。一个采用微服务架构开发的应用中，微服务的个数往往很多，这就导致了一台服务器上往往需要启动多个微服务来提高资源的利用率，而微服务本身可能就只能兼容部分操作系统，这就导致了就算有大量的服务器资源（操作系统可能不一样），但由于微服务本身与操作系统可能相关，就不能做到让微服务在任意服务器上运行，这就带来了资源的浪费和运维的困难。利用Docker容器的环境隔离能力，让微服务运行在容器内，就能够解决以上所说的问题。\n执行临时任务有时候用户只是想执行一次性的任务，但如果用传统虚拟机的方式就要搭建环境，执行完任务后还要释放资源，比较麻烦。使用Docker容器就可以构建临时的运行环境，执行完任务后关闭容器即可，方便快捷。\n多租户环境利用Docker的环境隔离能力，可以为不同的租户提供独占的容器，实现简单而且成本较低。\n\n11. 总结　　Docker的技术并不神秘，只是整合了前人积累的各种成果实现的应用级的容器化技术，它利用各种Linux发行版中使用了版本兼容的内核容器化技术，来实现镜像一次构建到处运行的效果，并且利用了容器内的基础操作系统镜像层，屏蔽了实际运行环境的操作系统差异，使用户在开发应用程序时，只需确保在选定的操作系统和内核版本上能正确运行即可，几乎不需要关心实际的运行环境的系统差异，大大提高效率和兼容性。但随着容器运行得越来越多，容器管理将会称为另一个运维的难题，这时候就需要引入Kubernetes、Mesos或Swarm这些容器管理系统，后面有机会再介绍这些技术。\n2.基础1.初级1.集群搭建\n基本概念\n\n容器编排（Container Orchestration）：在容器之上的管理，主要有服务发现、负载均衡、状态监控、健康检查、扩容缩容、应用迁移、高可用等\n\nKubernetes：\n\n前身是Google内部用C++实现的Borg，支撑整个公司运转的集群应用管理系统，在切换到Omega的时候，将Borg用Go重写并开源，即Kubernetes\n\nKubernetes是一个生产级别的容器编排平台和集群管理系统，不仅能够创建、调度容器，还能够监控、管理服务器，提供了一个可弹性运行分布式系统的框架：\n\n服务发现和负载均衡：使用DNS或IP地址来暴漏容器，并提供负载均衡来分配流量\n\n存储编排：允许自动挂载用户选择的存储系统，如本地存储、公共云提供商等\n\n自动部署和回滚：可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。\n\n自动完成装箱计算：允许指定每个容器所需CPU和内存（RAM）\n\n自我恢复：将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端\n\n密钥与配置管理：可以存储和管理敏感信息\n\n\n\n\n\nMinikube：用于在单机快速搭建Kubernetes环境\n\n\n\n集群搭建：\n\n下载安装Minikube，用来管理k8s集群环境\n\n下载安装kubectl，用来操作实际的k8s功能\n\n启动验证minikube环境：\n\nminikube start --kubernetes-version=v1.23.3\nminikube自带的kubectl有限制，添加别名在.bashrc：alias kubectl=&quot;minikube kubectl --&quot;\n运行Nginx示例：kubectl run ngx --image=nginx:alpine\n查看pod：kubectl get pod\n\n\n\n\n\n2.架构\n\n基础概念\n\n外部有一个kubectl：k8s客户端工具，用来操作Kubernetes，位于集群之外，理论上不属于集群。可以使用kubectl get node来查看k8s的节点状态\n可以通过kubectl get pod -n kube-system来查看控制面组件的状态\n通过minikube ssh登录到节点后，通过docker ps |grep kube-proxy查看kube-proxy、通过ps -ef|grep kubelet来查看kubelet\n\n\n控制平面组件（Control Plane Components）：为集群做出全局决策，可以在集群中的任何节点上运行，但为了简单起见通常在同一个未运行用户容器的计算机上启动所有控制平面组件\n\n\nkube-apiserver：API服务器是整个k8s系统的唯一入口，用于公开K8s的一系列RESTful API，并且加上了验证、授权等功能，负责处理接受请求的工作，是K8s控制平面的前端。K8s API服务器的主要实现是kube-apiserver，可以运行kube-apiserver的多个实例，并在这些实例之间平衡流量\nK8s API可以让用户查询和操纵K8s API中对象的状态，例如Pod、Namespace、ConfigMap和Event。大部分操作都可以通过kubectl命令行接口或类似kubeadm这类命令行工具（背后也是调用API）来执行，也可以使用REST调用来访问这些API\n\n\netcd：是兼顾一致性和高可用性的分布式键值数据库，用来持久化存储系统里的各种资源对象和状态，可以作为保存K8s所有集群数据的后台数据库。其只与apiserver有联系，所以任何其他组件想要读写 etcd 里的数据都必须经过 apiserver\nkube-scheduler：负责监视新创建的、未指定运行节点（node）的Pods，并选择节点来让Pod在上面运行。（调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。）\nkube-controller-manager：负责运行控制器进程，用于维护容器和节点等资源的状态，实现故障检测、服务迁移、应用伸缩等功能。每个控制器都是一个单独的进程，但是为了降低复杂性，都被编译到同一个可执行文件，并在同一个进程中运行。主要有以下控制器：\n节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应\n任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成\n端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）\n服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌\n\n\ncloud-controller-manager：允许将用户集群连接到云提供商的API之上，并将与该云平台交互的组件同用户的集群交互的组件分离开来。下面的控制器都包含堆云平台驱动的依赖：\n节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除\n路由控制器（Route Controller）：用于在底层云基础架构中设置路由\n服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器\n\n\n\n\nNode组件：Node的数量非常多，构成一个资源池，Kubernetes就在这个池里分配资源、调度应用，通过池化资源来简化管理（只有kube-proxy被容器化了）\n\n\nkubelet：\n在集群中每个节点（node）上运行，是Node的代理，负责管理Node相关的绝大部分操作，保证容器（containers）都运行在Pod中\nNode上只有它能够与apiserver通信，实现状态报告、命令下发、起停容器等功能\nkubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器\n\n\nkube-proxy：\n是集群中每个节点（node）上运行的网络代理，实现K8s服务（Service）的一部分\nkube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信\n如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发\n\n\nContainer Runtime：在Kubectl的指挥下创建容器，管理Pod的生命周期，如Docker\n\n\n插件（Addons）\n\nDNS：集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。\nWeb界面：使用户可以管理集群中运行的应用程序以及集群本身，并进行故障排除\n容器资源监控：将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供浏览这些数据的界面\n集群层面日志：负责将容器的日志数据保存到一个集中的日志存储中，提供搜索和浏览接口\n\n\n工作流程\n\n每个 Node 上的 kubelet 会定期向 apiserver 上报节点状态，apiserver 再存到 etcd 里\n每个 Node 上的 kube-proxy 实现了 TCP/UDP 反向代理，让容器对外提供稳定的服务\nscheduler 通过 apiserver 得到当前的节点状态，调度 Pod，然后 apiserver 下发命令给某个 Node 的 kubelet，kubelet 调用 container-runtime 启动容器\ncontroller-manager 也通过 apiserver 得到实时的节点状态，监控可能的异常情况，再使用相应的手段去调节恢复\n\n\n\n3.YAML\n声明式和命令式\n\n命令式：例如Docker命令和Dockerfile、大多数编程语言，特点是交互性强，注重顺序和过程\n声明式：不关心具体的过程，更注重结果，不需要教计算机做什么，而是告诉它一个目标状态，它自己就会想办法去完成任务，更加自动化、智能化程度更高\n区别：以打车为例，一路上给司机指路的就是命令式，只告诉司机目的地的是声明式\n\n\nYAML\n\nhttps://yaml.org/官网有对语言规范的完整介绍，YAML式JSON的超集，支持整数、浮点数、布尔、字符串、数组和对象等数据类型，但是YAML语法更简单，形式更紧凑，例如：\n\n使用空白与缩进表示层次（有点类似 Python），可以不使用花括号和方括号\n\n可以使用 # 书写注释，比起 JSON 是很大的改进\n\n对象（字典）的格式与 JSON 基本相同，但 Key 不需要使用双引号\n# YAML对象(字典)\nKubernetes:\n  master: 1\n  worker: 3\n数组（列表）是使用 - 开头的清单形式（有点类似 MarkDown）\n# YAML数组(列表)\nOS:\n  - linux\n  - macOS\n  - Windows\n表示对象的 : 和表示数组的 - 后面都必须要有空格\n# 复杂的例子，组合数组和对象\nKubernetes:\n  master:\n    - apiserver: running\n    - etcd: running\n  node:\n    - kubelet: running\n    - kube-proxy: down\n    - container-runtime: [docker, containerd, cri-o]\n可以使用 — 在一个文件里分隔多个 YAML 对象\n\n其它：\n\n\n\n\n如何编写YAML：\n\n所有API对象的字段都可以在官方文档中找到https://kubernetes.io/docs/reference/kubernetes-api/\n\n技巧：\n\n命令kubectl api-resources会显示出资源对象相应的 API 版本和类型，比如 Pod 的版本是“v1”，Ingress 的版本是“networking.k8s.io/v1”，照着它写绝对不会错\n\n命令kubectl explain相当于是Kubernetes自带的API文档，会给出对象字段的详细说明，这样就不必去网上查找了。比如想要看Pod里的字段该怎么写，就可以这样：\nkubectl explain pod\nkubectl explain pod.metadata\nkubectl explain pod.spec\nkubectl explain pod.spec.containers\n文档样板：kubectl 的两个特殊参数 –dry-run=client 和 -o yaml，前者是空运行，后者是生成 YAML 格式，结合起来使用就会让 kubectl 不会有实际的创建动作，而只生成 YAML 文件\n\n例如，想要生成一个 Pod 的 YAML 样板示例，可以在 kubectl run 后面加上这两个参数：\nkubectl run ngx --image&#x3D;nginx:alpine --dry-run&#x3D;client -o yaml\n就会生成一个绝对正确的 YAML 文件：\napiVersion: v1\nkind: Pod\nmetadata:\n  creationTimestamp: null\n  labels:\n    run: ngx\n  name: ngx\nspec:\n  containers:\n  - image: nginx:alpine\n    name: ngx\n    resources: &#123;&#125;\n  dnsPolicy: ClusterFirst\n  restartPolicy: Always\nstatus: &#123;&#125;\n然后通过查阅对象的说明文档，添加或删除字段来定制这个YAML\n\n\n\n\n\n\n\n\n\nAPI对象\n\nAPI对象概念：\n\nk8s总结了Google多年的经验，在理论层面抽象出了很多概念，用来描述系统的管理运维工作，这些概念叫做API对象\nAPI对象源自apiserver，因为apiserver是kubernetes系统的唯一入口，外部用户和内部组件都必须和它通信，因为采用了HTTP协议的URL资源理念，API风格也用RESTful的GET/POST/DELETE等，所以，这些概念很自然地就被称为是“API 对象”了\n通过kubectl api-resources来看当前kubernetes版本支持的所有对象，在使用kubectl的时候，可以加上一个参数 –v=9，它会详细的命令执行过程，清楚地看到发出的HTTP请求\n\n\n如何描述API对象\n\nheader：被kubectl用于生成HTTP请求发给apiserver\n\napiVersion：表示操作这种资源的API版本号\n\nkind：表示资源对象的类型，比如Pod、Node、Job、Service\n\nmetadata：表示资源的一些元信息，也就是用来标记对象、方便k8s管理的一些信息\napiVersion: v1\nkind: Pod\nmetadata:\n  name: ngx-pod #给pod起名字\n  labels: #给pod贴一些标签\n    env: demo\n    owner: chrono\n\n\nbody：与对象特定相关，每种对象有不同的规格定义，在YAML表现为sprc字段，表示对对象的期望状态（desired status）\nspec:\n  containers:\n  - image: nginx:alpine\n    name: ngx\n    ports:\n    - containerPort: 80\n\n\n创建/删除对象：\n\nk8s收到这份声明式的数据，再根据HTTP请求里POST/DELETE等方法，就会自动操作这个资源对象\nK8s对象是目标性记录，一旦创建对象，K8s系统将不断工作以确保对象存在\n通过创建对象，就是在告知K8s系统，集群工作负载状态看起来应该是什么样子的，这就是K8s集群所谓的期望状态（Desired State）\n\nkubectl apply -f ngx-pod.yml\nkubectl delete -f ngx-pod.yml\n\n\n\n4.Pod\nPod：\n\n为了解决这样多应用联合运行的问题，同时还要不破坏容器的隔离，就需要在容器外面再建立一个收纳仓，让多个容器既保持相对独立，又能够小范围共享网络、存储等资源，而且永远是“绑在一起”的状态\n\nPod是可以在K8s中创建和管理的最小的可部署的计算单元，Pod是一组（一个或多个）容器，这些容器共享存储、网络、怎样运行这些容器的声明。Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行\n\nPod 被设计成支持形成内聚服务单元的多个协作过程（形式为容器）。 Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。 容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身\n\n以Pod为中心的k8s资源对象关系图，所有k8s资源都直接或间接地附在Pod之上，所有k8s功能都必须通过Pod来实现\n\n\n\n\n如何使用YAML描述Pod\n\n因为 Pod 也是 API 对象，所以它也必然具有 apiVersion（v1）、kind（Pod）、metadata、spec 这四个基本组成部分\n\nmetadata里有name和labels这两个字段\napiVersion: v1\nkind: Pod\nmetadata:\n  name: busy-pod\n  labels:\n    owner: chrono\n    env: demo\n    region: north\n    tier: back\nspec字段需要管理、维护Pod这个k8s基本调度单元，里面有多个字段，以containers为例\n\n算法\n\nspec:\n  containers:\n  - image: busybox:latest\n    name: busy\n    imagePullPolicy: IfNotPresent #拉取策略\n    env: #环境变量\n      - name: os \n        value: &quot;ubuntu&quot;\n      - name: debug\n        value: &quot;on&quot;\n    command:\n      - &#x2F;bin&#x2F;echo\n    args:\n      - &quot;$(os), $(debug)&quot;\n\n\n如何使用kubectl操作Pod\nkubectl apply -f busy-pod.yml #创建pod\nkubectl delete -f busy-pod.yml #删除pod\nkubectl delete pod busy-pod #pod的name被指定为busy-pod\nkubectl logs busy-pod #查看默认后台运行的pod的标准输出信息\nkubectl get pod #可以查看pod列表和运行状态\nkubectl describe pod busy-pod #查看详细状态，用于调试排错\n\n5.Job/CronJob\n概念\n\n面向对象的思想：因为k8s中的pod已经是一个相对完善的对象，专门负责管理容器，根据单一职责原则，就不会再为它扩充功能，而是要保持它的独立性。容器之外的功能就需要定义其它对象，然后根据组合优于继承原则，将pod作为它的一个成员组合进去\nJob和CronJob组合了Pod，实现了对离线业务的处理，并且满足面向对象原则：\n离线业务：离线业务相对于在线业务（Nginx、MySQL、Redis），不服务与外部用户，只对内部用户有意义，比如日志分析、数据建模、视频转码等\n业务特性：离线业务的特点是必定会退出，不会无期限地运行下去，所以它的调度策略也就与“在线业务”存在很大的不同，需要考虑运行超时、状态检查、失败重试、获取计算结果等管理事项\n面向对象原则：离线业务的业务特性和容器管理没有必然的联系，所以如果用pod来实现就会违反单一职责原则，所以把这部分功能分到另一个对象上实现，并让这个对象去控制pod的运行\n\n\nJob和CronJob的使用场景\n“离线业务”也可以分为两种。一种是“临时任务”，跑完就完事了，下次有需求了说一声再重新安排；另一种是“定时任务”，可以按时按点周期运行，不需要过多干预\n对应到 Kubernetes 里，“临时任务”就是 API 对象 Job，“定时任务”就是 API 对象 CronJob，使用这两个对象你就能够在 Kubernetes 里调度管理任意的离线业务了\n\n\n\n\n如何使用YAML描述Job\n\napiVersion是batch/v1，kind是Job，metadata里有name标记名字，可以用labels添加任意的标签\n\nspec中的template字段：在Job对象里应用了组合模式，template字段定义了一个应用模版，里面嵌入了一个pod，这样Job就可以从这个模版来创建出pod\n\n而这个 Pod 因为受 Job 的管理控制，不直接和 apiserver 打交道，也就没必要重复 apiVersion 等“头字段”，只需要定义好关键的 spec，描述清楚容器相关的信息就可以了，可以说是一个“无头”的 Pod 对象\napiVersion: batch&#x2F;v1\nkind: Job\nmetadata:\n  name: echo-job\n\nspec:\n  template:\n    spec:\n      restartPolicy: OnFailure\n      containers:\n      - image: busybox\n        name: echo-job\n        imagePullPolicy: IfNotPresent\n        command: [&quot;&#x2F;bin&#x2F;echo&quot;]\n        args: [&quot;hello&quot;, &quot;world&quot;]\nspec其他重要字段：用来控制模版里的pod对象，与template同级\n\nactiveDeadlineSeconds，设置 Pod 运行的超时时间\nbackoffLimit，设置 Pod 的失败重试次数\ncompletions，Job 完成需要运行多少个 Pod，默认是 1 个\nparallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源。\n\n\n使用YAML生成CronJob对象\n\n样板\napiVersion: batch&#x2F;v1\nkind: CronJob\nmetadata:\n  name: echo-cj\n\nspec:\n  schedule: &#39;*&#x2F;1 * * * *&#39; #用来定义任务周期运行的规则，使用标准的Cron语法\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          restartPolicy: OnFailure\n          containers:\n          - image: busybox\n            name: echo-cj\n            imagePullPolicy: IfNotPresent\n            command: [&quot;&#x2F;bin&#x2F;echo&quot;]\n            args: [&quot;hello&quot;, &quot;world&quot;]\n嵌套层次\n\n\n\n\n\n如何在k8s中操作Job\nkubectl apply -f job.yml #运行简单的离线作业\nkubectl get job #查看job状态\nkubectl get pod #查看pod状态\n\n6.ConfigMap/Secret\n基础概念\n\n配置文件：把运行时需要的一些参数从代码中分离出来，让我们在实际运行的时候能更方便的调整优化\n配置信息分类\n一类是明文配置，也就是不保密，可以任意查询修改，比如服务端口、运行参数、文件路径等等\n另一类则是机密配置，由于涉及敏感信息需要保密，不能随便查看，比如密码、密钥、证书等等\n\n\n这两类配置信息本质上都是字符串，只是由于安全性的原因，在存放和使用方面有些差异，所以 Kubernetes 也就定义了两个 API 对象，ConfigMap 用来保存明文配置，Secret 用来保存秘密配置\n\n\nConfigMap\n\n样板文件：因为是存储配置文件，是静态的字符串而不是容器，就不需要spec字段来说明运行时的规格\n#kubectl create cm info --from-literal&#x3D;k&#x3D;v --dry-run&#x3D;client -o yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: info\n\ndata:\n  count: &#39;10&#39;\n  debug: &#39;on&#39;\n  path: &#39;&#x2F;etc&#x2F;systemd&#39;\n  greeting: |\n    say hello to kubernetes.\n\n\nSecret\n\nk8s里Secret对象又细分出跟多类，比如：\n\n访问私有镜像仓库的认证信息\n身份识别的凭证信息\nHTTPS 通信的证书和私钥\n一般的机密信息（格式由用户自行解释）\n\n\n样板代码：kubectl create secret generic user --from-literal=name=root --dry-run=client -o yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: user\n\ndata: #通过Base64编码进行加密\n  name: cm9vdA&#x3D;&#x3D; # root \n  pwd: MTIzNDU2 # 123456 \n  db: bXlzcWw&#x3D; # mysql\n\n\n如何以环境变量的方式使用 ConfigMap/Secret\n\nPod 与 ConfigMap、Secret 的“松耦合”关系，使用keyRef字段间接应用对象，同一段配置信息就可以在不同的对象之间共享\n\n“valueFrom”字段指定了环境变量值的来源，可以是“configMapKeyRef”或者“secretKeyRef”，然后你要再进一步指定应用的 ConfigMap/Secret 的“name”和它里面的“key”，要当心的是这个“name”字段是 API 对象的名字，而不是 Key-Value 的名字\n\n\n\n如何以 Volume 的方式使用 ConfigMap/Secret\n\nKubernetes 为 Pod 定义了一个“Volume”的概念，可以翻译成是“存储卷”。如果把 Pod 理解成是一个虚拟机，那么 Volume 就相当于是虚拟机里的磁盘\n\n可以为 Pod“挂载（mount）”多个 Volume，里面存放供 Pod 访问的数据，这种方式有点类似 docker run -v，虽然用法复杂了一些，但功能也相应强大一些\n\n在 Pod 里挂载 Volume 很容易，只需要在“spec”里增加一个“volumes”字段，然后再定义卷的名字和引用的 ConfigMap/Secret 就可以了。要注意的是 Volume 属于 Pod，不属于容器，所以它和字段“containers”是同级的，都属于“spec”\n\n这种方式的好处在于：以 Volume 的概念统一抽象了所有的存储，不仅现在支持 ConfigMap/Secret，以后还能够支持临时卷、持久卷、动态卷、快照卷等许多形式的存储，扩展性非常好\n\n环境变量用法简单，更适合存放简短的字符串，而 Volume 更适合存放大数据量的配置文件，在 Pod 里加载成文件后让应用直接读取使用\n\n\n\n\n2.中级1.Kubeadm\n定义：简化集群环境部署Kubernetes，并且让这个集群接近生产级质量\n准备工作\n安装kubeadm\n安装\n部署master\n部署worker\n\n\n\n2.Deployment\n基础\n\n用途：专门用来部署应用程序的，能够让应用永不宕机，多用来发布无状态的应用。与Job/CronJob类似，通过组合的方式管理Pod\n\nDockfile文件\n#export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n#kubectl create deploy ngx-dep --image&#x3D;nginx:alpine $out\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  labels:\n    app: ngx-dep\n  name: ngx-dep\n  \nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: ngx-dep\n      \n  template:\n    metadata:\n      labels:\n        app: ngx-dep\n    spec:\n      containers:\n      - image: nginx:alpine\n        name: nginx\n\n\n关键字段\n\nreplicas：（真正维护多副本的控制器为RepliaSet）\n代表副本数量，也就是指定要在k8s集群中运行多少个Pod实例，初始化时为0，根据YAML文件里的Pod模版，逐个创建出要求数量的Pod\n接下来k8s持续监控Pod的运行状态，万一有 Pod 发生意外消失了，数量不满足“期望状态”，它就会通过 apiserver、scheduler 等核心组件去选择新的节点，创建出新的 Pod，直至数量与“期望状态”一致\n\n\nselector：\n作用是筛选出要被Deployment管理的Pod对象，下属字段“matchLabels”定义了 Pod 对象应该携带的 label，它必须和“template”里 Pod 定义的“labels”完全相同，否则校验不通过\n因为在线业务和离线业务的应用场景差异很大。离线业务中的Pod是一次性的，至于这个业务有关，但是在线业务中Pod会被其他API对象引用来管理，比如负责负载均衡的Service对象\n\n\n\n\n进阶\n\n如何描述Deployment和Pod的组合关系：通过在 API 对象的“metadata”元信息里加各种标签（labels），我们就可以使用类似关系数据库里查询语句的方式，筛选出具有特定标识的那些对象。通过标签这种设计，Kubernetes 就解除了 Deployment 和模板里 Pod 的强绑定，把组合关系变成了“弱引用”\n\n操作\n\n如何使用kubectl操作Deployment\n$ kubectl apply -f deploy.yml #创建对象\n$ kubectl get deploy #查看Deployment的状态\n#READY 表示运行的 Pod 数量，前面的数字是当前数量，后面的数字是期望数量，所以“2&#x2F;2”的意思就是要求有两个 Pod 运行，现在已经启动了两个 Pod\n#UP-TO-DATE 指的是当前已经更新到最新状态的 Pod 数量。因为如果要部署的 Pod 数量很多或者 Pod 启动比较慢，Deployment 完全生效需要一个过程，UP-TO-DATE 就表示现在有多少个 Pod 已经完成了部署，达成了模板里的“期望状态”\n#AVAILABLE 要比 READY、UP-TO-DATE 更进一步，不仅要求已经运行，还必须是健康状态，能够正常对外提供服务，它才是我们最关心的 Deployment 指标\n通过kubectl get pod命令来看看 Pod 的状态，其中被Deploymentguan管理的Pod自动带上了名字，命名规则是Deployment的名字+Pod模版的Hash值\n\n\n\n\n特性：\n\n永不宕机：通过kubedctl delete pod &lt;podName&gt;删除一个Pod之后，该Pod消失后，Deployment会又创建出一个新的Pod\n弹性伸缩：例如kubectl scale --replicas=5 deploy ngx-dep可以把Nginx应用扩容到5个，但这是临时的措施，如果想要长时间保持另一个Pod数量，需要改动YAML文件，重新创建对象\n\n\n\n\n\n3.Daemonset\n基础\n\nWhat：DaemonSet会在k8s集群的每个节点上都运行一个Pod，好像Linux系统里的守护进程（Daemon）\nWhy：\n因为Deployment不关心Pod会在集群的哪些节点上运行，只关心Pod的个数，这对大多数业务都没问题，比如Nginx、MySQL，他们不需要知道集群、节点的细节信息，在那个节点运行都一样\n但是有一些业务不完全独立于系统运行，而是与主机存在绑定关系，必须依附于节点才能产生价值，如下，所以需要DaemonSet来为每个节点守护一个Pod\n网络应用（如 kube-proxy）：必须每个节点运行一个 Pod，否则节点就无法加入Kubernetes网络\n监控应用（如 Prometheus），必须每个节点都有一个 Pod 用来监控节点的状态，实时上报信息\n日志应用（如 Fluentd），必须每个节点上运行一个 Pod，才能够搜集容器运行时产生的日志数据\n安全应用，同样的，每个节点都要有一个 Pod 来执行安全审计、入侵检查、漏洞扫描等工作。\n\n\n\n\n\n\n实践\n\nYAML文件：\n#k8s不提供自动创建DaemonSet YAML样板的功能，当根据官网示例有如下样板文件\n#方法二：用kubectl create先创建出一个Deployment对象，然后把kind改成DaemonSet，再删除 spec.replicas\n\t\t\t\t# export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n\t\t\t\t# change &quot;kind&quot; to DaemonSetkubectl create deploy redis-ds --image&#x3D;redis:5-alpine $out\napiVersion: apps&#x2F;v1\nkind: DaemonSet\nmetadata:\n  name: redis-ds\n  labels:\n    app: redis-ds\n\nspec:\n  selector:\n    matchLabels:\n      name: redis-ds\n\n  template:\n    metadata:\n      labels:\n        name: redis-ds\n    spec:\n      containers:\n      - image: redis:5-alpine\n        name: redis\n        ports:\n        - containerPort: 6379\n没有replicas字段：与Deployment不同，DaemonSet不会在集群里创建多个Pod副本，而是要在每个节点只创建一个Pod实例。也就是说，DaemonSet 仅仅是在 Pod 的部署调度策略上和 Deployment 不同，其他的都是相同的，可以把 DaemonSet 看做是 Deployment 的一个特例\n\n\n使用\n$ kubectl apply -f ds.yml #创建对象\n$ kubectl get ds #查看状态 \n$ kubecrl get pod -o wide #查看pod\n#master被排除了，只在每一个worker节点运行了一个Pod实例\n\n\n进阶\n\n污点（taint）：用于给节点贴标签，为了区分labels字段，改成了taint\n\n容忍度（toleration）：Pod能够容忍污点，不是DaemonSet独有的概念，而是从属于Pod，所以也可用在Job/CronJob、Deployment\n\n污点和容忍度是一个相对的过程，Pod会根据自己对污点和容忍度来选择合适的目标，k8s会在创建集群的时候自动给节点Node加上一些污点，方便Pod的调度和部署，可以用kubectl describe node来查看：\n\nMaster 节点默认有一个 taint，名字是 node-role.kubernetes.io/master，它的效果是 NoSchedule，也就是说这个污点会拒绝 Pod 调度到本节点上运行，而 Worker 节点的 taint 字段则是空的\n这正是 Master 和 Worker 在 Pod 调度策略上的区别所在，通常来说 Pod 都不能容忍任何“污点”，所以加上了 taint 属性的 Master 节点也就会无缘 Pod 了\n\n$ kubectl describe node master\n\nName:     master\nRoles:    control-plane,master\n...\nTaints:   node-role.kubernetes.io&#x2F;master:NoSchedule\n...\n\n$ kubectl describe node worker\n\nName:     worker\nRoles:    &lt;none&gt;\n...\nTaints:   &lt;none&gt;\n...\n如何让 DaemonSet 在 Master 节点上运行：\n\n第一种方法是去掉 Master 节点上的 taint，让 Master 变得和 Worker 一样“纯洁无瑕”，DaemonSet 自然就不需要再区分 Master/Worker\n$ kubectl taint node master node-role.kubernetes.io&#x2F;master:NoSchedule-\n第二种方法：为 Pod 添加字段 tolerations，让它能够容忍某些污点，就可以在任意的节点上运行了\ntolerations:\n- key: node-role.kubernetes.io&#x2F;master\n  effect: NoSchedule\n  operator: Exists\n\n\n\n\n\n4.Service\n基础\n\nWhat：Service是集群内部的负载均衡机制，用来解决服务发现的问题，与Pod一样属于k8s的核心对象\nWhy：\n因为k8s集群里的Pod的生命周期是短暂的，在运行过程中会多次发生Pod的销毁和重建，这种动态稳定是的后台微服务Pod的IP地址总变，这样客户端就无法访问了\n已有的方法是LVS、Nginx等，通过一个前端与后端之间的中间层，来屏蔽后端的变化，为前端提供一个稳定的服务\n但 LVS、Nginx 毕竟不是云原生技术，所以 Kubernetes 就按照这个思路，定义了新的 API 对象：Service。Kubernetes 会给它分配一个静态 IP 地址，然后它再去自动管理、维护后面动态变化的 Pod 集合，当客户端访问 Service，它就根据某种策略，把流量转发给后面的某个 Pod\n\n\n\n\n实践\n\nYAML\n# export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n# kubectl expose deploy ngx-dep --port&#x3D;80 --target-port&#x3D;80 $out\n# 使用 kubectl expose 指令时还需要用参数--port和--target-port分别指定映射端口和容器端口# 而 Service 自己的 IP 地址和后端 Pod 的 IP 地址可以自动生成\napiVersion: v1\nkind: Service\nmetadata:\n  name: ngx-svc\n  \nspec:\n  selector:\n    app: ngx-dep\n    \n  ports:\n  - port: 80 #外部端口\n    targetPort: 80 #内部端口\n    protocol: TCP #使用的协议\nKubernetes 为 Service 对象自动分配了一个 IP 地址“10.96.240.115”，这个地址段是独立于 Pod 地址段的。而且 Service 对象的 IP 地址还有一个特点，它是一个“虚地址”，不存在实体，只能用来转发流量\nkubectl describe svc ngx-svc #查看Service代理了那些后端的Pod\n负载均衡\n\n测试负载均衡\n#进入到集群的内部网段\n$ kubectl exec -it ngx-dep-6796688696-r2j6t -- sh\n#再用curl工具来访问service，如curl 10.96.240.115\n针对删除重建的节点，Service会通过controller-manager实时监控Pod的变化情况，并立即更新它代理的IP地址\n\nservice的ip地址是虚拟的，只用于转发流量，不能ping通\n\n\n\n\n\n进阶\n\nService工作原理：Service 使用了 iptables 技术，每个节点上的 kube-proxy 组件自动维护 iptables 规则，客户不再关心 Pod 的具体地址，只要访问 Service 的固定 IP 地址，Service 就会根据 iptables 规则转发请求给它管理的多个 Pod，是典型的负载均衡架构\n\nservice和它引用的Pod的关系\n\n以域名的方式使用\n\n命名空间（namespace）：用来在集群里实现对API对象的隔离和分组，使用kubectl get ns查看\n\nKubernetes 有一个默认的名字空间，叫“default”，如果不显式指定，API 对象都会在这个“default”名字空间里。而其他的名字空间都有各自的用途，比如“kube-system”就包含了 apiserver、etcd 等核心组件的 Pod\n因为 DNS 是一种层次结构，为了避免太多的域名导致冲突，Kubernetes 就把名字空间作为域名的一部分，减少了重名的可能性，Service 对象的域名完全形式是“对象. 名字空间.svc.cluster.local”，但很多时候也可以省略后面的部分，直接写“对象. 名字空间”甚至“对象名”就足够了，默认会使用对象所在的名字空间（比如这里就是 default）\n\n\n\n\n\n如何让Service对外暴露服务\n\ntype关键字：表示 Service 是哪种类型的负载均衡，默认是ClusterIP，即对集群内部Pod的负载均衡。除了“ClusterIP”，Service 还支持其他三种类型，分别是“ExternalName”“LoadBalancer”“NodePort”，“ExternalName”“LoadBalancer”一般由云服务商提供\n\nNodePort类型\n\n使用：在使用命令 kubectl expose 的时候加上参数 –type=NodePort，或者在 YAML 里添加字段 type:NodePort\nService除了会对后端的 Pod 做负载均衡之外，还会在集群里的每个节点上创建一个独立的端口，用这个端口对外提供服务，这也正是“NodePort”这个名字的由来\n这个端口号属于节点，外部能够直接访问，可以不用登陆集群节点或者进入Pod内部，直接在集群外使用任意一个节点的 IP 地址，就能够访问 Service 和它代理的后端服务了\n\n\n\n\n\n\n\n\n5.Ingress\n基础\n\n在service的基础上提出了Ingress的概念，用于流量的管理，与它关联的还有Ingress Controller、Ingress Class等对象\n\nservice是一个由kube-proxy控制的四层负载均衡，即在TCP/IP协议栈上转发流量；而Ingress是在七层的HTTP/HTTPS协议上来做负载均衡，并且还作为流量的总入口，统管集群的进出口数据，即扇入扇出流量\n\nIngress Controller：与Service和kube-proxy类似，Ingress也只是一些HTTP路有规则的集合，需要Ingress Controller来读取、应用Ingress规则、处理调度流量。常见的Ingress Controller有k8s Ingress Controller、Nginx Ingress Controller、Kong Ingress Controller等\n\nIngressClass：由于项目内不同的Ingress Controller、过多的Ingress规则、多个Ingress没有逻辑分组方式等问题k8s提出了Ingress Class的概念，他在Ingress和Ingress Controller的中间作为流量规则和控制器的协调人\n\n\n\n实践\n\nYAML（Ingress）\n# 创建样板文件\n# export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n# kubectl create ing ngx-ing --rule&#x3D;&quot;ngx.test&#x2F;&#x3D;ngx-svc:80&quot; --class&#x3D;ngx-ink $out\n# --class指定Ingress从属的Ingress Class对象，--rule指定路由规则，也就是说是访问 HTTP 路径就转发到对应的 Service 对象，再由 Service 对象转发给后端的 Pod\n\napiVersion: networking.k8s.io&#x2F;v1\nkind: Ingress\nmetadata:\n  name: ngx-ing\n  \nspec:\n\n  ingressClassName: ngx-ink\n  \n  rules:\n  - host: ngx.test\n    http:\n      paths:\n      - path: &#x2F;\n        pathType: Exact\n        backend:\n          service:\n            name: ngx-svc\n            port:\n              number: 80\nYAML（Ingress Class）\napiVersion: networking.k8s.io&#x2F;v1\nkind: IngressClass\nmetadata:\n  name: ngx-ink\n\nspec:\n  controller: nginx.org&#x2F;ingress-controller\n使用\n$ kubectl apply -f ingress.yml #两个yaml写到一起，创建这两个对象\n$ kubectl get ingressclass #查看对象状态\n$ kubectl get ing #查看对象状态\n$ kubectl describe ing ngx-ing #查看更详细的Ingress信息\n在k8s中使用Ingress Controller\n#以Nginx Ingress Controller为例，下面4个YAML是用来做试验安装Nginx Ingress Controller的\n$ kubectl apply -f common&#x2F;ns-and-sa.yaml\n$ kubectl apply -f rbac&#x2F;rbac.yaml\n$ kubectl apply -f common&#x2F;nginx-config.yaml\n$ kubectl apply -f common&#x2F;default-server-secret.yaml\n\n# 部署Ingress Controller的Deployment\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  name: ngx-kic-dep\n  namespace: nginx-ingress\n\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ngx-kic-dep\n\n  template:\n    metadata:\n      labels:\n        app: ngx-kic-dep\n    ...\n    spec:\n      containers:\n      - image: nginx&#x2F;nginx-ingress:2.2-alpine\n        ...\n        args:\n          - -ingress-class&#x3D;ngx-ink\n\n$ kubectl apply -f kic.yml\n# Ingress Controller位于名字空间“nginx-ingress”，所以查看状态需要用“-n”参数显式指定\n$ kubectl get deploy -n nginx-ingress\n$ kubectl get pod -n nginx-ingress\n# 因为 Ingress Controller 本身也是一个 Pod，想要向外提供服务还是要依赖于 Service 对象。所以你至少还要再为它定义一个 Service，使用 NodePort 或者 LoadBalancer 暴露端口，才能真正把集群的内外流量打通\n$ \n# 下面这条命令就把本地的 8080 端口映射到了 Ingress Controller Pod 的 80 端口\n$ kubectl port-forward -n nginx-ingress ngx-kic-dep-8859b7b86-cplgp 8080:80 &amp;\n\n\n进阶\n\n关系图\n\n\n\n\n\n\n3.高级1.PersistentVolume2.persistentVolume+NFS3.StatefulSet4.滚动更新5.应用保障6.集群管理7.系统监控8.网络通信3.进阶1.容器编排与作业管理2.持久化存储3.容器网络4.作业调度与资源管理5.容器运行时6.容器监控与日志MySQL1.概念1.IndexesMySQL 索引\n\n\n\n\n\n\n\n\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n\nB+Tree 索引：\n\n是大多数 MySQL 存储引擎的默认索引类型，因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\n\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。\n\n主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n\n\n\n辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n\n\n\n哈希索引\n\n哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n\n无法用于排序与分组；\n\n只支持精确查找，无法用于部分查找和范围查找。\n\n\n\nInnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n\n\n\n全文索引\n\nMyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。（InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引）\n\n\n空间数据索引：MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。\n\n\n索引优化\n独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用 actor_id 列的索引：SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;\n\n多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\nSELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id &#x3D; 1 AND film_id &#x3D; 1;\n索引列的顺序：让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\nSELECT COUNT(DISTINCT staff_id)&#x2F;COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)&#x2F;COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049\n前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。\n\n覆盖索引：索引包含所有需要查询的字段的值。具有以下优点：\n\n索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。\n\n一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。\n\n对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。\n\n\n\n\n索引的优点\n大大减少了服务器需要扫描的数据行数。\n帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。\n将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。\n\n索引的使用条件\n对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n对于中到大型的表，索引就非常有效；\n但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n\n2.查询性能优化使用 Explain 进行分析\nExplain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。比较重要的字段有：\n\nselect_type : 查询类型，有简单查询、联合查询、子查询等\n\nkey : 使用的索引\n\nrows : 扫描的行数\n\n\n\n\n优化数据访问\n减少请求的数据量\n\n只返回必要的列：最好不要使用 SELECT * 语句。\n\n只返回必要的行：使用 LIMIT 语句来限制返回的数据。\n\n缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。\n\n\n\n减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。\n\n\n重构查询方式\n切分大查询：一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。\nDELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);\nrows_affected &#x3D; 0\ndo &#123;\n    rows_affected &#x3D; do_query(\n    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)\n&#125; while rows_affected &gt; 0\n分解大连接查询：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：\n\n让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。\n\n分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。\n\n减少锁竞争；\n\n在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。\n\n查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。\n\n\nSELECT * FROM tag\nJOIN tag_post ON tag_post.tag_id&#x3D;tag.id\nJOIN post ON tag_post.post_id&#x3D;post.id\nWHERE tag.tag&#x3D;&#39;mysql&#39;;\nSELECT * FROM tag WHERE tag&#x3D;&#39;mysql&#39;;\nSELECT * FROM tag_post WHERE tag_id&#x3D;1234;\nSELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);\n\n3.存储引擎InnoDB\n是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\n\nMyISAM\n设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。\n提供了大量的特性，包括压缩表、空间数据索引等。\n不支持事务。\n不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。\n可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。\n如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。\n\n比较\n事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。\n并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。\n外键：InnoDB 支持外键。备份：InnoDB 支持在线热备份。\n崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。\n其它特性：MyISAM 支持压缩表和空间数据索引。\n\n4.数据类型整型\nTINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。\nINT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。\n\n浮点数\nFLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。\nFLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。\n\n字符串\n主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。\nVARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。\n在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。\n\n时间和日期\nMySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。\nDATETIME：能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关。默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。\nTIMESTAMP：和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。\n应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。\n\n\n\n5.Sharding水平切分\n\n\n水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。\n\n垂直切分\n\n\n垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。\n在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。\n\nSharding 策略\n哈希取模：hash(key) % N；\n范围：可以是 ID 范围也可以是时间范围；\n映射表：使用单独的一个数据库来存储映射关系。\n\nSharding 存在的问题\n事务问题：使用分布式事务来解决，比如 XA 接口。\n\n连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。\n\nID 唯一性\n\n使用全局唯一 ID（GUID）\n\n为每个分片指定一个 ID 范围\n\n分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)\n\n\n\n\n6.Replication主从复制主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。\n\nbinlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。\nI/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。\nSQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。\n\n\n\n\n\n读写分离\n主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。\n\n读写分离能提高性能的原因在于：\n\n主从服务器负责各自的读和写，极大程度缓解了锁的争用；\n\n从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；\n\n增加冗余，提高可用性。\n\n\n\n读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。\n\n\n\n\n7.Transactions\nACID\n\n\n8.database normalization\n1NF\n2NF\n3NF\nBCNF\n其他\n第四范式、第五范式、第六范式\nDk范式\n\n\n\n2.SQL语法1.基础\n模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。\n主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。\nSQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。\nSQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。\nSQL 支持以下三种注释：\n\n## 注释\nSELECT *\nFROM mytable; -- 注释\n&#x2F;* 注释1\n   注释2 *&#x2F;\n\n\n数据库创建与使用：\n\nCREATE DATABASE test;\nUSE test;\n\n2.创建表CREATE TABLE mytable (\n  # int 类型，不为空，自增\n  id INT NOT NULL AUTO_INCREMENT,\n  # int 类型，不可为空，默认值为 1，不为空\n  col1 INT NOT NULL DEFAULT 1,\n  # 变长字符串类型，最长为 45 个字符，可以为空\n  col2 VARCHAR(45) NULL,\n  # 日期类型，可为空\n  col3 DATE NULL,\n  # 设置主键为 id\n  PRIMARY KEY (&#96;id&#96;));\n\n3.修改表\n添加列\n\nALTER TABLE mytable\nADD col CHAR(20);\n\n\n删除列\n\nALTER TABLE mytable\nDROP COLUMN col;\n\n\n删除表\n\nDROP TABLE mytable;\n\n4.插入\n普通插入\n\nINSERT INTO mytable(col1, col2)\nVALUES(val1, val2);\n\n\n插入检索出来的数据\n\nINSERT INTO mytable1(col1, col2)\nSELECT col1, col2\nFROM mytable2;\n\n\n将一个表的内容插入到一个新表\n\nCREATE TABLE newtable AS\nSELECT * FROM mytable;\n\n5.更新UPDATE mytable\nSET col &#x3D; val\nWHERE id &#x3D; 1;\n\n6.删除DELETE FROM mytable\nWHERE id &#x3D; 1;\n\n\nTRUNCATE TABLE 可以清空表，也就是删除所有行。\n\nTRUNCATE TABLE mytable;\n\n使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。\n7.查询\nDISTINCT：相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。\n\nSELECT DISTINCT col1, col2\nFROM mytable;\n\n\nLIMIT：限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n\n返回前 5 行：\nSELECT *\nFROM mytable\nLIMIT 5;\nSELECT *\nFROM mytable\nLIMIT 0, 5;\n\n返回第 3 ~ 5 行：\nSELECT *\nFROM mytable\nLIMIT 2, 3;\n\n8.排序\nASC ：升序（默认）\nDESC ：降序\n\n可以按多个列进行排序，并且为每个列指定不同的排序方式：\nSELECT *\nFROM mytable\nORDER BY col1 DESC, col2 ASC;\n\n9.过滤不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。\nSELECT *\nFROM mytable\nWHERE col IS NULL;\n\n下表显示了 WHERE 子句可用的操作符\n\n\n\n操作符\n说明\n\n\n\n=\n等于\n\n\n&lt;\n小于\n\n\n&gt;\n大于\n\n\n&lt;&gt; !=\n不等于\n\n\n&lt;= !&gt;\n小于等于\n\n\n&gt;= !&lt;\n大于等于\n\n\nBETWEEN\n在两个值之间\n\n\nIS NULL\n为 NULL 值\n\n\n应该注意到，NULL 与 0、空字符串都不同。\nAND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。\nIN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。\nNOT 操作符用于否定一个条件。\n10.通配符通配符也是用在过滤语句中，但它只能用于文本字段。\n\n% 匹配 &gt;=0 个任意字符；\n_ 匹配 ==1 个任意字符；\n[ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。\n\n使用 Like 来进行通配符匹配。\nSELECT *\nFROM mytable\nWHERE col LIKE &#39;[^AB]%&#39;; -- 不以 A 和 B 开头的任意文本\n\n不要滥用通配符，通配符位于开头处匹配会非常慢。\n11.计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。\n计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。\nSELECT col1 * col2 AS alias\nFROM mytable;\n\nCONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。\nSELECT CONCAT(TRIM(col1), &#39;(&#39;, TRIM(col2), &#39;)&#39;) AS concat_col\nFROM mytable;\n\n12.函数各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。\n汇总\n\n\n函 数\n说 明\n\n\n\nAVG()\n返回某列的平均值\n\n\nCOUNT()\n返回某列的行数\n\n\nMAX()\n返回某列的最大值\n\n\nMIN()\n返回某列的最小值\n\n\nSUM()\n返回某列值之和\n\n\nAVG() 会忽略 NULL 行。\n使用 DISTINCT 可以汇总不同的值。\nSELECT AVG(DISTINCT col1) AS avg_col\nFROM mytable;\n\n文本处理\n\n\n函数\n说明\n\n\n\nLEFT()\n左边的字符\n\n\nRIGHT()\n右边的字符\n\n\nLOWER()\n转换为小写字符\n\n\nUPPER()\n转换为大写字符\n\n\nLTRIM()\n去除左边的空格\n\n\nRTRIM()\n去除右边的空格\n\n\nLENGTH()\n长度\n\n\nSOUNDEX()\n转换为语音值\n\n\n其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。\nSELECT *\nFROM mytable\nWHERE SOUNDEX(col1) &#x3D; SOUNDEX(&#39;apple&#39;)\n\n日期和时间处理\n日期格式：YYYY-MM-DD\n时间格式：HH:MM:SS\n\n\n\n\n函 数\n说 明\n\n\n\nADDDATE()\n增加一个日期（天、周等）\n\n\nADDTIME()\n增加一个时间（时、分等）\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nDATE()\n返回日期时间的日期部分\n\n\nDATEDIFF()\n计算两个日期之差\n\n\nDATE_ADD()\n高度灵活的日期运算函数\n\n\nDATE_FORMAT()\n返回一个格式化的日期或时间串\n\n\nDAY()\n返回一个日期的天数部分\n\n\nDAYOFWEEK()\n对于一个日期，返回对应的星期几\n\n\nHOUR()\n返回一个时间的小时部分\n\n\nMINUTE()\n返回一个时间的分钟部分\n\n\nMONTH()\n返回一个日期的月份部分\n\n\nNOW()\n返回当前日期和时间\n\n\nSECOND()\n返回一个时间的秒部分\n\n\nTIME()\n返回一个日期时间的时间部分\n\n\nYEAR()\n返回一个日期的年份部分\n\n\nmysql&gt; SELECT NOW();\n2018-4-14 20:25:11\n\n数值处理\n\n\n函数\n说明\n\n\n\nSIN()\n正弦\n\n\nCOS()\n余弦\n\n\nTAN()\n正切\n\n\nABS()\n绝对值\n\n\nSQRT()\n平方根\n\n\nMOD()\n余数\n\n\nEXP()\n指数\n\n\nPI()\n圆周率\n\n\nRAND()\n随机数\n\n\n13.分组把具有相同的数据值的行放在同一组中。\n可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。\n指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。\nSELECT col, COUNT(*) AS num\nFROM mytable\nGROUP BY col;\n\nGROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。\nSELECT col, COUNT(*) AS num\nFROM mytable\nGROUP BY col\nORDER BY num;\n\nWHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。\nSELECT col, COUNT(*) AS num\nFROM mytable\nWHERE col &gt; 2\nGROUP BY col\nHAVING num &gt;&#x3D; 2;\n\n分组规定：\n\nGROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；\n除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；\nNULL 的行会单独分为一组；\n大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。\n\n14.子查询子查询中只能返回一个字段的数据。\n可以将子查询的结果作为 WHRER 语句的过滤条件：\nSELECT *\nFROM mytable1\nWHERE col1 IN (SELECT col2\n               FROM mytable2);\n\n下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：\nSELECT cust_name, (SELECT COUNT(*)\n                   FROM Orders\n                   WHERE Orders.cust_id &#x3D; Customers.cust_id)\n                   AS orders_num\nFROM Customers\nORDER BY cust_name;\n\n15.连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。\n连接可以替换子查询，并且比子查询的效率一般会更快。\n可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。\n内连接内连接又称等值连接，使用 INNER JOIN 关键字。\nSELECT A.value, B.value\nFROM tablea AS A INNER JOIN tableb AS B\nON A.key &#x3D; B.key;\n\n可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。\nSELECT A.value, B.value\nFROM tablea AS A, tableb AS B\nWHERE A.key &#x3D; B.key;\n\n自连接自连接可以看成内连接的一种，只是连接的表是自身而已。\n一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。\n子查询版本\nSELECT name\nFROM employee\nWHERE department &#x3D; (\n      SELECT department\n      FROM employee\n      WHERE name &#x3D; &quot;Jim&quot;);\n\n自连接版本\nSELECT e1.name\nFROM employee AS e1 INNER JOIN employee AS e2\nON e1.department &#x3D; e2.department\n      AND e2.name &#x3D; &quot;Jim&quot;;\n\n自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。\n内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。\nSELECT A.value, B.value\nFROM tablea AS A NATURAL JOIN tableb AS B;\n\n外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。\n检索所有顾客的订单信息，包括还没有订单信息的顾客。\nSELECT Customers.cust_id, Customer.cust_name, Orders.order_id\nFROM Customers LEFT OUTER JOIN Orders\nON Customers.cust_id &#x3D; Orders.cust_id;\n\ncustomers 表：\n\n\n\ncust_id\ncust_name\n\n\n\n1\na\n\n\n2\nb\n\n\n3\nc\n\n\norders 表：\n\n\n\norder_id\ncust_id\n\n\n\n1\n1\n\n\n2\n1\n\n\n3\n3\n\n\n4\n3\n\n\n结果：\n\n\n\ncust_id\ncust_name\norder_id\n\n\n\n1\na\n1\n\n\n1\na\n2\n\n\n3\nc\n3\n\n\n3\nc\n4\n\n\n2\nb\nNull\n\n\n16.组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。\n每个查询必须包含相同的列、表达式和聚集函数。\n默认会去除相同行，如果需要保留相同行，使用 UNION ALL。\n只能包含一个 ORDER BY 子句，并且必须位于语句的最后。\nSELECT col\nFROM mytable\nWHERE col &#x3D; 1\nUNION\nSELECT col\nFROM mytable\nWHERE col &#x3D;2;\n\n17.视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。\n对视图的操作和对普通表的操作一样。\n视图具有如下好处：\n\n简化复杂的 SQL 操作，比如复杂的连接；\n只使用实际表的一部分数据；\n通过只给用户访问视图的权限，保证数据的安全性；\n更改数据格式和表示。\n\nCREATE VIEW myview AS\nSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col\nFROM mytable\nWHERE col5 &#x3D; val;\n\n18.存储过程存储过程可以看成是对一系列 SQL 操作的批处理。\n使用存储过程的好处：\n\n代码封装，保证了一定的安全性；\n代码复用；\n由于是预先编译，因此具有很高的性能。\n\n命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。\n包含 in、out 和 inout 三种参数。\n给变量赋值都需要用 select into 语句。\n每次只能给一个变量赋值，不支持集合的操作。\ndelimiter &#x2F;&#x2F;\n\ncreate procedure myprocedure( out ret int )\n    begin\n        declare y int;\n        select sum(col1)\n        from mytable\n        into y;\n        select y*y into ret;\n    end &#x2F;&#x2F;\n\ndelimiter ;\ncall myprocedure(@ret);\nselect @ret;\n\n19.游标在存储过程中使用游标可以对一个结果集进行移动遍历。\n游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。\n使用游标的四个步骤：\n\n声明游标，这个过程没有实际检索出数据；\n打开游标；\n取出数据；\n关闭游标；\n\ndelimiter &#x2F;&#x2F;\ncreate procedure myprocedure(out ret int)\n    begin\n        declare done boolean default 0;\n\n        declare mycursor cursor for\n        select col1 from mytable;\n        # 定义了一个 continue handler，当 sqlstate &#39;02000&#39; 这个条件出现时，会执行 set done &#x3D; 1\n        declare continue handler for sqlstate &#39;02000&#39; set done &#x3D; 1;\n\n        open mycursor;\n\n        repeat\n            fetch mycursor into ret;\n            select ret;\n        until done end repeat;\n\n        close mycursor;\n    end &#x2F;&#x2F;\n delimiter ;\n\n20.触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。\n触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。\nINSERT 触发器包含一个名为 NEW 的虚拟表。\nCREATE TRIGGER mytrigger AFTER INSERT ON mytable\nFOR EACH ROW SELECT NEW.col into @result;\n\nSELECT @result; -- 获取结果\n\nDELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。\nUPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。\nMySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。\n21.事务管理基本术语：\n\n事务（transaction）指一组 SQL 语句；\n回退（rollback）指撤销指定 SQL 语句的过程；\n提交（commit）指将未存储的 SQL 语句结果写入数据库表；\n保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。\n\n不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。\nMySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。\n设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。\n如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。\nSTART TRANSACTION\n&#x2F;&#x2F; ...\nSAVEPOINT delete1\n&#x2F;&#x2F; ...\nROLLBACK TO delete1\n&#x2F;&#x2F; ...\nCOMMIT\n\n22.字符集基本术语：\n\n字符集为字母和符号的集合；\n编码为某个字符集成员的内部表示；\n校对字符指定如何比较，主要用于排序和分组。\n\n除了给表指定字符集和校对外，也可以给列指定：\nCREATE TABLE mytable\n(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )\nDEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;\n\n可以在排序、分组时指定校对：\nSELECT *\nFROM mytable\nORDER BY col COLLATE latin1_general_ci;\n\n23.权限管理MySQL 的账户信息保存在 mysql 这个数据库中。\nUSE mysql;\nSELECT user FROM user;\n\n创建账户\n新创建的账户没有任何权限。\nCREATE USER myuser IDENTIFIED BY &#39;mypassword&#39;;\n\n修改账户名\nRENAME USER myuser TO newuser;\n\n删除账户\nDROP USER myuser;\n\n查看权限\nSHOW GRANTS FOR myuser;\n\n授予权限\n账户用 username@host 的形式定义，username@% 使用的是默认主机名。\nGRANT SELECT, INSERT ON mydatabase.* TO myuser;\n\n删除权限\nGRANT 和 REVOKE 可在几个层次上控制访问权限：\n\n整个服务器，使用 GRANT ALL 和 REVOKE ALL；\n整个数据库，使用 ON database.*；\n特定的表，使用 ON database.table；\n特定的列；\n特定的存储过程。\n\nREVOKE SELECT, INSERT ON mydatabase.* FROM myuser;\n\n更改密码\n必须使用 Password() 函数进行加密。\nSET PASSWROD FOR myuser &#x3D; Password(&#39;new_password&#39;);\n\n3.MySQL实战45讲1.基础架构\nMySQL分为Server层和存储引擎层\n\nServer 层：包括连接器、查询缓存、分析器、优化器、执行器等。所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能（存储过程、触发器、视图）都在这一层实现\n\n存储引擎层：负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5.5 版本开始成为了默认存储引擎\n\n\n\n连接器\n\n负责跟客户端建立连接、获取权限、维持和管理连接。连接命令为mysql -h$ip -P$port -u$user -p\n连接命令中的mysql是客户端工具，用来跟服务端建立连接，在完成TCP握手后（一般客户端和数据库在不同服务器上），连接器开始认证身份。如果密码通过则会读出对应权限（连接时用户权限被管理员修改也不生效）。连接完成后可以使用show processlist来查看，在wait_timeout（8h）后连接自动断开\n长连接与短连接：长连接会造成MySQL占用内存过多，被系统强行杀掉，异常重启的情况。可以定期断开长连接，或执行mysql_reset_connection来重新初始化连接资源（5.7以上版本）\n\n\n查询缓存（8.0后删除）：MySQL拿到一个查询请求后，会先到查询缓存，看之间是不是执行过这条语句，语句和执行结果以key-value对的形式被直接缓存在内存中。一般不建议使用查询缓存：查询缓存的失效非常频繁，因为只要对一个表更新，则表上所有的查询缓存都会被清空。按需使用，可以将query_cache_type设置成DEMAND，默认不使用查询缓存，可以通过select SQL_CACHE * from T where ID=10；的方式显示指定\n\n分析器：\n\n词法分析：识别出输入的SQL语句里的字符串都分别是什么，代表什么\n语法分析：根据词法分析结果，通过语法规则判断SQL语句是否满足MySQL语法（指定出错首位置），并且检查表、列等是否存在\n\n\n优化器：在表里有多个索引的时候，决定使用哪个索引；或者在一个SQL语句有多表关联（join）的时候，决定各个表的连接顺序\n\n执行器：执行的时候，先判断对此表是否有执行权限（如果命中查询缓存，则在返回时进行权限验证，查询也会在优化器之前调用precheck验证权限）。如果有权限，则打开表继续执行，会根据表的引擎定义去使用这个引擎提供的接口，日志中通过rows_examined字段记录语句执行过程中扫描了多少行\n\n\n2.日志系统\n执行流程：连接器连接数据库、清空表上的查询缓存、分析器通过词法和语法解析知道这是一条更新语句，优化器决定要使用哪个索引，然后执行器具体执行\n\nredo log（重做日志，InooDB引擎特有）\n\n每次更新都写进磁盘，IO成本、查询成本都很高，所以引入WAL技术（Write-Ahead Logging），即先写日志、再写磁盘\n\n具体来说当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在系统空闲的时候，将这个操作记录更新到磁盘里面\n\nInnoDB 的 redo log 是固定大小的。比如可以配置为一组 4 个文件，每个文件的大小是 1GB，组织成如下结构，write pos即入当前记录位置，边写边后移，checkpoint记录要擦除的位置，边擦除边后移，擦除前更新数据文件，write pos和checkpoint之间的是还空着的部分，可以用来记录新操作\n\n\n\nCrash-safe：异常重启不丢失记录\n\n\n\nbinlog（归档日志，Server层）\n\nbinlog和redo log对比\nredo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\nredo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。\nredo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n持久化\ninnodb_flush_log_at_trx_commit参数设置成 1 ，表示每次事务的 redo log都直接持久化到磁盘\nsync_binlog参数设置成 1 ，表示每次事务的 binlog 都持久化到磁盘\n\n\n\n\n举例update T set c=c+1 where ID=2;（redo log的两阶段提交）\n执行器先找引擎取ID=2这一行。因ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回\n执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据\n写入redo log：引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务\n写binlog：执行器生成这个操作的 binlog，并把 binlog 写入磁盘，binlog会记录所有的逻辑操作\n提交事务：执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交commit状态\n\n\n如何恢复数据：找到最近的一次全量备份，从备份的时间点开始，将备份的binlog依次取出来，重放到出问题的时刻。当异常重启的时候，就需要redo log来保证不丢失记录\n\n\n\n3.事务1.事务隔离\n隔离性与隔离级别\n\n隔离性（Isolation）：当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了隔离级别的概念\n隔离的越严格，效率就会越低。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）：\n读未提交：一个事务还没提交时，它做的变更就能被别的事务看到\n读提交：一个事务提交之后，它做的变更才会被其他事务看到。将参数 transaction-isolation 的值设置成 READ-COMMITTED\n可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的\n串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行\n\n\n在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。\n在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图\n在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的\n“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念\n“串行化”隔离级别下直接用加锁的方式来避免并行访问。\n\n\n\n\n事务隔离的实现（MyISAM引擎不支持事务，InnoDB支持事务）\n\n在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值\n多版本并发控制（MVCC）：对于某条记录的查询，不同时刻启动的事务会有不同的read-view，即同一条记录在系统中可以存在多个版本\n回滚日志删除时间：当系统里没有比这个回滚日志更早的read-view的时候，所以不建议使用长事务，会导致回滚记录的保存从而占用存储空间\n\n\n事务的启动方式\n\n显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback，commit work and chain 提交事务并自动启动下一个事务\n\nset autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。（建议总是set autocommit=1）\n\n可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。\n\n\nselect * from information_schema.innodb_trx \nwhere TIME_TO_SEC(timediff(now(),trx_started))&gt;60;\n\n2.事务到底是隔离的还是不隔离的\n事务启动\n\nbegin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动\n如果想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令\n没有显示使用begin/commit，但是autocommit=1时，一条语句就是一个事务\n\n\n视图\n\n概念一 view：它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样\n概念二 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view：用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现\n\n\nMVCC中的快照（秒级创建快照）\n\n通过事务的Transaction id来记录同一数据的不同状态，并且将Transaction id赋给状态的row trx_id，来区分不同状态。不同状态不是物理上真实存在的，而是通过undo log和最新状态来综合算出来的。因此在事务启动的时候会记录启动时间，并根据此时间来确定其他事务是否可见，并向上追溯不可见事务直到可见\n\n实现：InnoDB为每个事务构造一个数组，用来保存这个事务启动瞬间，当前正在活跃（启动但未提交）的所有事务ID。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）\n\n一致性视图：将所有的row trx_id分成了三种不同的情况\n\n\n如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；\n如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；\n如果落在黄色部分，那就包括两种情况\na. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；\nb. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见\n\n\n\n\n当前读：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待\n\n\n\n\n4.索引\n\n\n\n\n\n\n\n\n为了提高数据查询的效率，类似于书的目录\n1.索引基础\n常见模型：从数据模型可推测数据库使用场景\n哈希表：key-value存储结构，增加新数据的速度很快，但做区间查询的速度是很慢的，只适用于等值查询\n有序数组：在等值查询和范围查询场景中的性能高，但维护成本高，插入需要移动大量元素\n搜索树：平衡二叉搜索树、N叉搜索树，因为索引还要写到磁盘，所以使用B+树，减少I/O次数\n跳表\nLSM树\n\n\nInnoDB的索引模型\n索引组织表：在InnoDB中，表都是按照主键顺序以索引的形式存放的，这种方式称为～，又因为InnoDB使用了B+树索引模型，所以数据都存储在B+树中，每一个索引在InnoDB里面对应一棵B+树\n根据叶子界定啊的内容，索引类型分为：\n主键索引：主键索引的叶子节点存的是整行数据，InnoDB中也被称为聚簇索引（clustered index）\n非主键索引：非主键索引的叶子节点内容是主键的值，InnoDB中也被称为二级索引（secondary index），需要在主键索引中再多搜索一次，称为回表，所以应该尽量使用主键查询\n\n\n索引维护\n主要指相应B+树的插入和删除\n自增主键：指自增列上定义的主键，建表语句为： NOT NULL PRIMARY KEY AUTO_INCREMENT。每插入一条新记录，会将对应值自增，采用追加操作不涉及到挪动其他记录，也不会触发叶子节点的分裂\n业务逻辑相关主键没法保证顺序插入数据，写数据成本高\n选取字节数小的当作主键，否则索引所占用的空间过大，如不选身份证号而选自增主键\n\n\n使用业务字段直接做主键：只有一个索引，且该索引必须是唯一索引，即典型的KV场景，可以使用业务字段做主键，没有其他索引就不用关注叶子结点大小的问题\n\n\n\n\n==覆盖索引==\n从select * from T where k between 3 and 5改为select ID from T where k between 3 and 5，不需要回到主键索引树（回表），直接就可以给出查询结果，称为覆盖索引\n覆盖索引可以减少树的搜索次数，显著提高查询性能，所以使用覆盖索引是一个常用的性能优化手段\n举例：当需要高频请求根据身份证号查询姓名时，建立（身份证号，姓名）联合索引就可以不需要回表查整行记录，减少语句的执行时间\n\n\n==最左前缀原则==\n单独为不频繁的请求建立索引会很浪费，通过B+树这种结构，可以利用索引的“最左前缀”来定位记录，即查询以张开头的名字用张%\n最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。所以在建立联合索引的时候，就需要考虑索引内的字段顺序，为了索引的复用能力更强，减少需要维护的索引个数\n如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。例如已经有了（a，b）这个联合索引就不需要再单独在a上建立索引，但是需要给b再建立一个索引\n\n\n==索引下推(index condition pushdown)==\nMySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数\n即在（a，b）索引下找a，b同时满足某些条件的结果，如果没有索引下推，则需要找出a满足条件的行，再回表看b是否满足；如果要是有索引优化，则会在所以内部判断并跳过那些b不满足条件的行\n\n\n\n2.选普通索引还是唯一索引\n查询过程：\n对于普通索引和唯一索引来说，都需要从B+树的跟节点开始找，当找到第一个符合的记录后，唯一索引会直接返回，而普通索引会继续遍历直到第一个不复合的记录\n因为InnoDB的数据是按数据页来读写的，所以每次读取都会以页（16KB）为单位，将其整体读入内存，所以两个索引性能差距很小，选哪个都行\n\n\nchange buffer：\nchange buffer：当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性\n持久化：change buffer是可持久化的数据，change buffer在内存中有拷贝，也会被写入到磁盘上\nmerge：将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。访问时会merge、后台定期merge、数据库正常关闭也会执行merge\n\n\nchange buffer的大小可以通过参数innodb_change_buffer_max_size来动态设置 。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%\nchange buffer和redo log：redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗\n\n\n更新过程：\n要更新的目标页在内存中时：性能没有太大差别\n要更新的目标页不在内存中时：唯一索引的更新不能使用change buffer，只有普通索引可以使用，因为唯一索引需要判断操作是否违反唯一性约束，这就需要读数据页到内存\n普通索引的更新因为有change buffer的存在，性能会有提升，所以写多读少的业务change buffer的效果最好，例如账单类、日志类的系统     \n\n\n\n3.为什么有时候选错索引\n问题：数据库已有10万行记录并在a上由索引，在下面操作的情况下，sessionB的查询变慢，查询选错索引\n优化器的逻辑：\n优化器选择索引的目的：找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少\n基数：MySQL在开始执行语句之前会根据统计信息估算记录数，这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多（不同值个数称为基数cardinality），这个索引的区分度就越好\n可以通过show index from tablename; 来看一个索引的基数（估计值），通过analyze table tablename:来重新统计索引信息（==可解决统计错误问题==）\n基数估计方法：InnoDB默认选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。当变更的行数超过1/M的时候，会自动触发重新做一次索引统计，MySQL中有两种存储索引统计的方式，通过设置参数innodb_stats_persistent来选择\n设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10\n设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16\n\n\n\n\n扫描行数：explain + SQL语句中的rows，表示预计扫描行数\n\n\n选错索引的原因：如果选择非主键索引，那么每次从非主键索引上拿到一个值，都要回主键索引上查出整行数据，这个代价优化器也要算进去，但是如果扫描主键索引，则没有额外的代价，解决办法：\n使用force index强行选择一个索引，但是不够灵活，一般用来解决线上紧急问题\n修改语句，引导MySQL使用期望的索引，让优化器觉得某个索引比另外一个代价大\n新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引\n\n\n\n4.怎么给字符串字段加索引\n问题场景：支持邮箱登陆的系统怎么在邮箱字段上建立索引（否则需要进行全表扫描）\n\n前缀索引：\n\nMySQL支持前缀索引，也就是可以定义字符串的一部分作为索，例如：mysql&gt; alter table SUser add index index2(email(6));，只取每个记录的前6个字节创建索引。缺点是会增加额外的记录扫描次数，因为每次从索引找到记录都需要回到主键上来判断，知道这行记录加入结果集\n\n定义好长度，才能做到既节省空间，又不用额外太多的查询成本，可以用下面的语句通过索引上有多少个不同的值来判断要使用多长的前缀\nselect \n  count(distinct left(email,4)）as L4,\n  count(distinct left(email,5)）as L5,\n  count(distinct left(email,6)）as L6,\n  count(distinct left(email,7)）as L7,\nfrom SUser;\n前缀索引对覆盖索引的影响：\n\n如果只需要查询email和主键列，则可以使用覆盖索引，从email索引查到结果就直接返回，\n\n如果列更多则用不上覆盖索引对查询性能的优化，因为要到主键索引查询其他列信息\n\n使用前缀索引就用不上覆盖索引对查询性能的优化了\n\n\n\n\n\n其它方式（例如：身份证号问题）\n\n倒排存储：将身份证号倒过来存储，查询时如下操作mysql&gt; select field_list from t where id_card = reverse(&#39;input_id_card_string&#39;);\n\nhash字段：可以在表上在创建一个整数字段，来保存身份证的效验码，同时在这个字段上创建索引mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc)，每次插入新记录的时候，都同时用crc32()这个函数，查询时为避免效验码相同，需要判断id_card的值是否精确相同\nmysql&gt; select field_list from t where id_card_crc&#x3D;crc32(&#39;input_id_card_string&#39;) and id_card&#x3D;&#39;input_id_card_string&#39;\n异同点：\n\n从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。\n在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。\n从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。\n\n\n\n\n\n5.加锁1.锁基础\n全局锁\n对整个数据库实例加锁，命令是Flush tables with read lock，执行后整个数据库将处于只读状态，其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句\n主要用于全库逻辑备份，即把整库每个表都select出来存成文本，会使得数据库停摆或主从延迟\n备份的常用方法：\n通过在可重复读隔离级别下开启一个事务。官方自带的工具mysqldump使用参数-single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，而由于MVCC的支持，这个过程数据是可以正常更新的\n不使用set global readonly = true的方式：readonly的值在某些系统下可能用来判断是主库还是从库、客户端异常时数据库会一直保持readonly状态，是的数据库长期不可写\nFTWRL方式：\n\n\n\n\n表级锁\n表锁：\n语法为lock tables ... read/write，既可以通过unlock tables主动释放，也可以在客户端断开时自动释放。除了会限制别的线程的读写外，也限定了本线程接下来的操作对象\n举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表\n一般在数据库引擎不支持行锁的时候才会被用到\n\n\n元数据锁（meta data lock）\nMDL不需要显示使用，在访问一个表的时候会被自动加上。作用是保证读写的正确性（表结构不变）\n5.5版本引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表结构变更操作的时候，加MDL写锁\n给表加字段会使得表被写锁锁住，没法继续执行查询，安全的加字段的方法：\nkill掉长事务或者暂停修改操作\n在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后再重试命令\n\n\n\n\n\n\n行级锁\n行锁由引擎层自己实现，但并不是所有的引擎都支持（MyISAM不支持），不支持行锁意味着并发控制只能使用表锁，会影响业务并发度\n两阶段锁协议：在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。可以通过在事务中重排语句顺序来减少加锁时间提高并发度，即将最可能造成锁冲突、最可能影响并发度的锁尽量往后放\n死锁和死锁检测：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。出现死锁有两种策略：\n一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。\n另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on。\n解决热点行更新导致的性能问题：关闭死锁检测、控制并发度\n\n\n\n\n\n6.缓存1.基本使用2.更新策略3.key/value如何设计","slug":"Note-C","date":"2023-04-20T08:46:07.000Z","categories_index":"","tags_index":"","author_index":"Dajunnnnnn"},{"id":"6cc22201d59326eaf451b7fbadccff38","title":"Note-Java","content":"Basic Syntax\n\n\n\n\n\n\n\n\nAndroid、Chromium（OS用C++）、Spring\n/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home\n/Library/Java/JavaVirtualMachines/jdk1.8.0_333.jdk/Contents/Home\n/opt/homebrew/bin:$PATH\n路线图语法1.程序的本质1.编程语言类型\n编译型语言：类似于C++，代码会在编译成机器指令后再被执行，CPU执行机器指令效率高，但因为CPU指令集和OS系统调用的不同，需要根据环境重新编译\n解释型语言：类似于Python，代码在执行过程中，有虚拟机（解释器）逐条编译并执行，因为执行包括编译所以执行耗时长，但因为有虚拟机来帮助适应编译环境，可以执行好\n混合型语言：类似于Java，编译器将.java文件翻译成字节码.class文件，字节码与平台无关但又可快速翻译成机器码，机器码也是解释执行但速度较快。JIT（即时编译）将热点字节码编译成机器码缓存起来，以供反复执行\n\n2.OS、JVM\nOS在程序执行中的作用：用来管理硬件资源和调度程序执行。提供类库（编译好的机器指令）并封装成系统调用供应用程序使用\n\nJVM在程序执行中的作用：C++编译之后的代码可以直接执行，而Python和Java代码的执行，需要依赖虚拟机，即编译命令中的python和java。虚拟机可以看作一个编译成机器指令的程序，用户代码相当于这个程序的一个插件，虚拟机将字节码翻译成CPU指令，放到固定的内存位置，再通过修改CPU寄存器中存储的地址的方式，引导CPU执行这块内存中存储的CPU指令。\n#C++\n$ g++ helloworld.cpp -o helloworld\n$ .&#x2F;helloworld\n#Python\n$ python helloworld.py\n#Java\n$ javac helloworld.java\n$ java helloworld\n\n3.CPU指令、汇编语言、字节码\nCPU指令 = 操作码 + 地址 + 数据，指明要执行的操作、数据来源、操作结果去向\n\n汇编语言：汇编指令与CPU指令一一对应，采用字符而不是二进制数来表示，汇编语言也需要经过汇编成机器码才能被执行，C/C++的编译过程就包括这一步：先编译成汇编代码，在汇编成机器码。主要有两种风格：Intel风格、AT&amp;T风格\n\n字节码：\n\n诞生的目的：克服p解释型语言解释执行速度慢的缺点，字节码跟平台无关是为了让Jaca保留跨平台的优点，因此虚拟机必须跟平台有关。\n\n字节码的格式：\n\n一堆有固定格式的十六进制格式的二进制码，使用javap工具可以将class文件解析成人类阅读的模式（与javac的功能相反）\n\nclass文件里包含了很多类的信息，一条字节码指令有操作码和可选的操作数组成，因为操作码长度为一个字节，所以这种指令格式被叫做字节码。而且可以得知，字节码的操作码类型不超过256个（2^8），以为抽象程度高，所以比汇编指令少很多，但逻辑更加复杂。\n\n\n\n\n\n\n\n4.代码的执行\n依靠CPU中的寄存器+L1、L2、L3三级缓存，存取数据。寄存器的类别有以下几种：\n\n通用寄存器：AX、BX、CX、DX\n\n指针寄存器：BP（一个栈桢的栈底地址）、SP（栈顶地址）、SI（源地址寄存器）、DI（目的地址寄存器）、IP（指令指针寄存器）\n\n段寄存器：CS（代码段地址寄存器，物理地址=段地址*16+偏移地址(IP)）、DS（数据段地址寄存器，与SI结合）、SS（栈寄存器，与SP结合或与BP结合）\n\n指令寄存器：IR（存放当前正在执行的指令用于译码器译码，即一串二进制码）\n\n标志寄存器：FR（也叫程序状态寄存器PSW，这个寄存器的每一个二进制位记录一类状态）\n\n\n\nCPU执行指令的流程：\n\n对于编译型语言，OS会把编译好的机器码，加载到内存中的代码段，将代码中变量等数据放入内存中的数据段，并且设置好各个寄存器的初始值。CPU根据PC寄存器（CS寄存器和IP寄存器的总称）存储的内存地址，从对应的内存单元取出一条CPU指令，放到指令寄存器，然后将IP寄存器的地址递增指向下一个条指令，一条指令执行完成之后，再通过PC寄存器中的地址，取下一条指令继续执行。\n对于解释型或混合型语言，操作系统将虚拟机本身的机器码，加载到内存中的代码段，然后一条一条地被CPU执行。这部分执行的指令对应的功能，就包括把程序员编写的程序解释成机器码这一功能。虚拟机把解释好的机器码放到某段内存中，然后将PC寄存器的地址设置为这段内存的首地址，于是，CPU就被虚拟机引导去执行程序员编写的代码。\n\n\n\n5.基础结构\n变量：\n内存被划分为内存单元，一个内存单元对应一个地址。在机器码中，因为通过内存地址来实现内存中数据的读写的可读性比较差，所以高级语言中用变量作为地址的别名来使用。\n因为变量的作用域（声明周期）的不同，为提高内存利用率被分到不同的区域来存储，主要有栈、堆、常量池\n栈一般存储函数内的数据，如局部变量，参数，用完即丢\n堆一般存储作用域不局限于函数内的数据，如对象，需要显示的释放\n常量池一般存储常量，常量的生命周期跟程序的生命周期一样，在程序结束之后才会被释放\n\n\n\n\n数组：为了减少程序中的变量数量，Java中new出的数组存储在堆上，C语言中既可以申请栈上的内存也可以动态分配堆上的内存\n类型：CPU不知道类型的信息，类型主要是看编译器怎么解读，引入类型的目的是为了方便程序员编写正确的代码，避免错误的复制操作。根据类型是否可以动态变化和类型检查发生的时期可以分为以下两种：\n动态类型：一个变量的类型是可变的，具体看赋值给他的数据是什么类型的，类型检查发生在运行期。例如：PHP\n静态类型：一个变量的类型是唯一确定的，类型检查发生在编译期。例如Java、Go\n\n\n运算：常见的运算类型主要有：算术运算、关系运算、赋值运算、逻辑运算、位运算，绝大部分运算在CPU中都有对应的指令。因为不同类型的电路逻辑不同，所以执行的花费也不同，例如：位运算比乘、除法快。\n跳转：程序由顺序、选择、循环三种基本结构构成，其中选择和循环又统称为跳转。不管是if还是for底层都是通过CPU的跳转指令（jge,jle,je,jmp等）来实现的。goto语句因会导致可读性变差，被废弃\n函数：\n实现代码模块化的一种手段，函数底层实现依赖函数栈，栈中依次保存了，前一个栈帧的栈底地址，参数，局部变量，返回地址（BP指向前一个栈帧的栈底地址，SP保存了栈顶地址）。\nCPU通过callq指令调用函数，callq指令会将当前的rip寄存器中的内容（callq指令的下一条指令的内存地址，即返回地址）存储在栈帧的最顶端，当被调用的函数执行完时，被调用函数的栈帧释放，最后调用retq指令（相当于popq %rip），将返回地址重新赋值给rip，CPU就可以从函数中callq指令的下一条指令继续执行了。\n\n\n\n2.基本类型1.类型转换\n\n\n\n\n\n\n\n\n自动类型转换、强制类型转换、引用类型转换\n\n自动类型转换（隐式转换）：从数据范围小的类型向数据范围大的类型转换，触发自动类型转换    \n\nbyte 自动转换为：short、int、long、float、double；\nshort自动转换为：        、int、long、float、double；\nchar 自动转换为：        、int、long、float、double；（==得到char类型的UTF-16编码==）\nint    自动转换为：                、long、float、double；\nlong 自动转换为：                          、float、double；\nfloat 自动转换为：                                     、double；\n\n==注意：是否能自动转换的参考是数据范围而不是类型长度（所占字节个数）==\n\nshort和char都占2个字节，但不能互相转换：short是-32768-32767，而char是0-65535，转换跨度大\n\nlong占用8个字节，但却能转换为4字节的float：浮点数表示方法特殊，采用科学计数法，long转换为float会损失一些精度，相当于四舍五入，对于本身就无法表示精确值的float来说，这种转换时合理的\nlong l &#x3D; 500000000000000l;\nfloat f &#x3D; l;\nSystem.out.println(f);&#x2F;&#x2F;输出4.99999993E14\n\n\n强制类型转换（显式转换）：从数据范围大的类型向数据范围小的类型转换，需要强制类型转换。强制类型转换有可能会导致数据据的截断（将高位字节丢弃）或精度的丢失，只有保证数据落在另一个类型可表示的范围内时，这种转换才是有意义的。\n\n引用类型的互相转换：仅限于有继承关系的类之间\n\n向上转换（Upcasting）：将对象的类型转换为父类或接口类型，总是被允许的（自动类型转换）\n\n向下转换（Downcasting）：将对象的类型转换子类类型，需要显示指明（强制类型转换）。在向下转换时，因为转换为子类之后，有可能会调用子类存在而父类不存在的属性和方法，所以需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已。\npublic class ParentC&#123;\n  public int a;\n&#125;\npublic class ChildC extends ParentC&#123;\n  public int b;\n&#125;\npublic class OtherC&#123;\n  public int c;\n&#125;\npublic class Demo&#123;\n  public static void main(String[] args)&#123;\n    ChildC child &#x3D; new ChildC();\n    f(child);&#x2F;&#x2F;向上转换，自动类型转换，总是可以的\n  &#125;\n&#125;\npublic static void f(ParentC obj)&#123;\n  &#x2F;&#x2F;需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已\n  OtherC oc &#x3D; (OtherC)obj;&#x2F;&#x2F;报错\n  ChildC cc &#x3D; (ChildC)obj;&#x2F;&#x2F;OK\n  System.out.println(cc.b);\n&#125;\n\n\n\n2.float\n\n\n\n\n\n\n\n\n浮点数表示法、BigDecimal\n\n科学计数法：\n\n十进制科学计数法：\nfloat f1 &#x3D; 100000000.0f;\nSystem.out.println(&quot;&quot; + f1);&#x2F;&#x2F;输出1.0E8\nfloat f2 &#x3D; 1.3E23f;\nSystem.out.println(&quot;&quot;+f2);&#x2F;&#x2F;输出1.3E23\n二进制科学计数法：\n\n\n\n实数的存储方式：定点数与浮点数，浮点数相关概念如下：\n\n计算机中的浮点数一般分为4字节精度浮点数和8字节浮点数，对应到Java语言中就是float类型和double类型\n\n浮点数的二进制格式为：(-1)^s*M*2^E（M的整数位必须是1），例如：-12.375-&gt;-1100.011-&gt;(-1)^1*1.100011*2^3。存储格式如下：\n\n存储时M的整数位不用存储\n\nE的范围是[-126，127]，且为无符号类型，将E统一加127后，再存到指数域\n\n指数域为0（0000 0000，本应为-127），用来辅助表示浮点数0，即当指数域为0时，从有效数字中读取的二进制位不需要再前面加1\n指数域为255（1111 1111，本应为128），用来辅助表示无穷大或NaN，其中s为0时表示正无穷、s为1时表示负无穷，有效数字域的二进制位不全为0时，表示这是一个无意义数NaN（Not a number）\n\n&#x2F;&#x2F;Java中Float类中定义3个静态常量来表示正无穷大和NaN\npublic static final float POSITIVE_INFINITY &#x3D; 1.0f&#x2F;0.0f;\npublic static final float NEGATIVE_INFINITY &#x3D; -1.0f&#x2F;0.0f;\npublic static final float NaN &#x3D; 0.0f&#x2F;0.0f;\n\n\n\n\n\n\n表示范围（4字节精度浮点数来举例）：M的最大值是24个1，指数的最大值是127，因此最大值是1.11…1111*2^127，最小值是-1.11…1111*2^127，即3.4E38和-3.4E38\n\n精度：当某个实数表示成二进制科学计数法，其有效字位数超过24位时，就会做精度舍弃（非四舍五入），不仅仅小数会有，整数也有精度问题\nfloat f &#x3D; 0.1f;\nSystem.out.printf(&quot;%.11f\\n&quot;,f);&#x2F;&#x2F;0.10000000149\n&#x2F;&#x2F;0.1的二进制表示为：0.001100110011...\nBigDecimal（浮点数的替代品）\n\n对精度不敏感的系统，用浮点数表示就足够了，对精度比较敏感的金融系统，一般采用BigDecimal来表示实数。传递进BigDecimal中的是字符串，而不是float类型数据\nBigDecimal bg &#x3D; new BigDecimal(&quot;0.1&quot;);\nSystem.out.pringln(bg.toString());&#x2F;&#x2F;输出0.1\nBigDecimal bg &#x3D; new BigDecimal(0.1f);\nSystem.out.println(bg.toString());&#x2F;&#x2F;输出0.0100000.....因为传入前就不准确\nBIgDecimal提供了相应的方法进行精确的加减乘除操作，对于无法整除的除法操作，我们需要指明舍入（Rounding）方法\n\n浮点数的关系操作（判等、大于、小于等）是比较复杂的，需要引入误差，而BigDecimal有现成的方法可以用。\nif(Math.abs(f1-f2) &lt; 0.0001)&#123;...&#125;\n&#x2F;&#x2F;ret &#x3D; -1,0,1分别表示小于，等于，大于\nif ret &#x3D; bg1.compareTo(bg2)\n\n\n浮点数的精度取舍方法\n\n四舍五入法：出了0.5入都可以抵消，所以累计误差比较大\n四舍六入五成双（银行家算法）：舍去位的数值小于5时，直接舍去；舍去位的数值大于5时，进位；当舍去位的数值等于5时，根据5前一位数的奇偶来判断，偶数则进位，奇数则舍去\nMySQL会四舍五入，Orcale会直接截断\n\n\n\n3.char\n\n\n\n\n\n\n\n\n字符集、字符编码、ASCII、UTF-8、UTF-16\n\n字符、字符集和字符编码\n\n字符（Character）可以理解为书面表达中所可能用到的符号，包括文字、数字、标点、图形符号、控制符号（回车、换行）\n字符集（Character Set）是一组字符的集合，不同语言有不用的字符集，例如GB2312是中文字符集，其中每个字符的编号只是为了方便索引\n字符编码（Character Encoding）是指计算机存储字符编号的格式，一个字符集会对应一种或多种字符编码，比如Unicode字符集对应UTF-8、UTF-16、UTF-32三种不同的字符编码\n\n\n常见字符集和字符编码\n\nASCII字符集和字符编码：0-31和127为不可显示字符（控制字符），32-126为可显示字符，48为0、65为A、97为a\n\n字符串存储可显示字符，通过以下方式存储非可显示字符\nchar c1 &#x3D; &#39;a&#39;;\nchar c2 &#x3D; &#39;\\141&#39;;&#x2F;&#x2F;a的ASCII为97，八进制141\nchar c3 &#x3D; &#39;\\015&#39;;&#x2F;&#x2F;回车\nSystem.out.println(&quot;abc\\015def&quot;);&#x2F;&#x2F;一行打印abc，另一行打印def\nchar c4 &#x3D; &#39;\\n&#39;;&#x2F;&#x2F;回车的转义字符为\\n\nSystem.out.println(&quot;abc\\ndef&quot;);&#x2F;&#x2F;一行打印abc，另一行打印def\nchar c5 &#x3D; 97;&#x2F;&#x2F;a的ASCII码值为97，它存储在计算机中的二进制串，跟数值97的二进制串xaing&#39;tong\nSystem.out.println(c5);&#x2F;&#x2F;打印a\nchar类型数据之间的比较和加减操作，对应的是将字符编码转变为无符号数进行相应操作\n\n\n\nGB*支持中文的字符集和字符编码：GB2312：6000多汉字、GBK、GB18030\n\nUnicode字符集和UTF*系列字符编码\n\n总共有100多万个字符，为了让常用字符的编号尽可能小，Unicode字符集将编号分为两部分：\n\n编号从U+0U+FFFF，并且排除U+800U+DFFF，分配给使用频率最高的字符\n编号从U+10000~U+10FFFF，大约有100多万个编号，分配给剩下的所有字符\n\n\nUTF-32：定长编码，使用4个字节来存储Unicode编号，解码时每次读取四个字节解码为一个字符\n\nUTF-16：变长编码，U+0U+FFFF（不包含U+D800U+DFFF）内的编号使用2字节编码，U+10000~U+10FFFF之间的编号采用4字节编码。如何确定取出的2个字节对应的数值是2字节编码还是4字节编码的一部分：\n\nU+0~U+FFFF之间的Unicode编号，直接存储在2个字节中\nU+10000~U+10FFFF之间的Unicode编号，采用如下特殊编码方式\n\n\nUTF-8：\n\n编码方式：不同字节编码的首字节的前缀不同，但尾随字节的前缀均为10\n\n\n\n编码\n范围\n第1个字节\n第2个字节\n第3个字节\n第4个字节\n\n\n\n1字节编码\n0000~007F\n0xxxxxxx\n\n\n\n\n\n2字节编码\n0080~07FF\n110xxxxx\n10xxxxxx\n\n\n\n\n3字节编码\n0800~FFFF\n1110xxxx\n10xxxxxx\n10xxxxxx\n\n\n\n4字节编码\n10000~10FFFF\n11110xxx\n10xxxxxx\n10xxxxxx\n10xxxxxx\n\n\n\n上图的xxxxx如何替换为具体的Unicode编号\n\n\n\n\n\n\n\n\nJava中char的字符编码\n\nC语言出现的早，C++继承C语言的特性，所以C/C++中的char类型占用一个字节长度，只能存储ASCII字符，满足英文系统，通过char数组来存储非ASCII字符，比如中文。\n\n因为Java出现较晚，Unicode已经流行，为了让char类型表示更多的字符，Java设计了两个字节长的char类型，存储部分Unicode字符（U+0~U+FFFF之间的），Unicode字符会通过UTF-16编码之后存储到char类型变量中\n\n跟ASCII码类似，我们也有3种方法将Unicode字符赋值给char类型变量：\n\n对于可显示字符，我们可以直接使用字符\n对于所有字符（可显示/不可显示），我们都可以将字符对应的UTF-16编码表示为\\uxxxx的形式赋值给变量，其中xxxx为16进制\n对于所有字符，我们都可以将字符对应的Unicode编号赋值给变量\n\nchar a &#x3D; &#39;我&#39;;&#x2F;&#x2F;字符本身\nchar b &#x3D; &#39;\\u6211&#39;;&#x2F;&#x2F;UTF-16编码\nchar c &#x3D; 0x6211;&#x2F;&#x2F;Unicode编号\n&#x2F;&#x2F;打印a、b、c都会打印出“我”字\n\n&#x2F;&#x2F;U+10000~U+10FFFF范围内的Unicode字符，Java使用char数组来存储\n&#x2F;&#x2F;某个字符的Unicode编号为U+1F701，UTF-16编码为：D830 DF01\nchar[] chs &#x3D; new char[2];\nchs[0] &#x3D; &quot;\\uD83D&quot;;\nchs[1] &#x3D; &quot;\\uDF01&quot;;\n\nString s &#x3D; &quot;\\uD830\\UDFF01&quot;;\n\nchar[] chs2 &#x3D; Character.tochars(0x1F701);\n\n\n\n4.包装类\n\n\n\n\n\n\n\n\n自动装箱、自动拆箱、常量池\n\n自动装箱和拆箱：\n\n装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（Number是整型和浮点型包装类的父类）\n&#x2F;&#x2F;基本类型转换为包装类\nint i &#x3D; 5;\nInteger iobj1 &#x3D; new Integer(i);&#x2F;&#x2F;少用，无法利用IntegerCache缓存，见常量池\nInteger iobj2 &#x3D; Integer.valueOf(i);\n&#x2F;&#x2F;包装类转换为基本类型\ni &#x3D; iobj1.intValue();\n\n&#x2F;&#x2F;自动装箱，语法糖，底层实现为：Integer iobj &#x3D; Integer。valueOf(12);\nInteger iobj &#x3D; 12;\n&#x2F;&#x2F;自动拆箱，语法糖，底层实现为：int i &#x3D; iobj.intValue();\nint i &#x3D; iobj;\n原始类型byte, short, char, int, long, float, double, boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean\n\n触发自动装箱和拆箱的几种情况：\n&#x2F;&#x2F;将基本类型数据赋值给包装类变量（包括参数传递）时，触发自动装箱\nint i1 &#x3D; 5\nInteger iobj1 &#x3D; 5;&#x2F;&#x2F;1\niobj &#x3D; i1;&#x2F;&#x2F;1\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(i1);&#x2F;&#x2F;1\n&#x2F;&#x2F;将包装类对象赋值给基本类型变量（包括参数传递）时，触发自动拆箱\nInteger iobj2&#x3D; new Integer(6);\nint i2 &#x3D; iobj2;&#x2F;&#x2F;2\n&#x2F;&#x2F;当包装类对象参与算术运算、关系运算（&lt;,&gt;）时，触发自动拆箱操作\nInteger iobj3 &#x3D; iobj1 + iobj2;\nboolean bl &#x3D; (iobj1 &lt; iobj2);\nbl &#x3D; (iobj1 &lt; 2);\n&#x2F;&#x2F;当包装类对象参与关系运算（&#x3D;&#x3D;），且另一方是基本类型数据时，触发自动拆箱操作。\nInteger iobj4 &#x3D; new Integer(123);\nbl &#x3D; (iob4 &#x3D;&#x3D; 123);\n\n\n常量池技术\n\nInteger等包装类使用了常量池技术，IntegerCache类（享元模式）中会缓存值为-128到127之间的Integer对象，当我们通过自动装箱，也就是调用valueOf()来创建Integer对象时，如果要创建的Integer对象的值再-128到127之间，会从IntegerCache中直接返回，否则才会真正调用new方法创建，详见Integer类的valueOf()\nInteger a &#x3D; 12;\nInteger b &#x3D; 12;\nInteger c &#x3D; new Integer(12);&#x2F;&#x2F;新Integer对象，不用常量池，不推荐使用\nSystem.out.println(&quot;a&#x3D;&#x3D;12&quot;+(a&#x3D;&#x3D;12));&#x2F;&#x2F;输出true\nSystem.out.println(&quot;a&#x3D;&#x3D;b&quot;+(a&#x3D;&#x3D;b));&#x2F;&#x2F;输出true，常量池返回相同Integer对象\nSystem.out.println(&quot;a&#x3D;&#x3D;c&quot;+(a&#x3D;&#x3D;c));&#x2F;&#x2F;输出false\n实际上，JVM也提供了方法，让我们可以自定义缓存的最大值。如下所示，如果通过分析应用程序的JVM内存占用情况，发现-128到255之间的数据占用的内存比较多，就可以用如下方式，将缓存的最大值127调整到255，不过，JDK并没有提供设置最小值的方法\n&#x2F;&#x2F;方法一：\n-Djava.lang.Integer.IntegerCache.high&#x3D;255\n&#x2F;&#x2F;方法二：\n-XX:AutoBoxCacheMax&#x3D;255\n基本类型VS包装类\n\n读写效率方面，基本类型高效：包装类是引用类型，对象的引用和对象本身是分开存储的；基本类型数据变量对应内存块，直接存储数据本身\n存取效率方面，基本类型占用少：在64位JVM上开启引用压缩的情况下，一个Integer对象占用16个字节，而一个int类型数据只占用4字节的内存空间\n==在项目开发中==：首选基本类型，毕竟基本类型在性能方面更好。但在映射数据库的Entity、映射接口请求的DTO，在数据库或请求中的字段值为null时，我们需要将其映射为Entity或DTO中的null值。还有，我们在初始化变量时，需要将其设置为没有业务意义的值，如果某个变量的默认值0是有业务意义的值，这个时候，我们需要找一个其他值（例如-1）来初始化变量。这种情况下，就是和使用包装类，因为包装类变量的默认值是null，是没有业务意义的。\n\n\n\n\n\n5.位运算\n补码：原码就是用一位表示符号（1为负），其余为数值，但是其减法运算过于复杂，所以发明了补码。其中整数的补码跟原码相同，而负数的补码为原码取反（符号位不变，数值位按位取反）再+1（-0被用作-128）。对于加减法一律按加法处理，并且截断高位溢出。（补码的补码就是原码）\n&#x2F;&#x2F;溢出示例\nint a &#x3D; 2147483647;&#x2F;&#x2F;0x7fffffff\nint b &#x3D; 1;\nint c &#x3D; a + b;&#x2F;&#x2F;c为-2147483648，因为截断高位\n\n&#x2F;&#x2F;如何避免计算的过程中溢出\npublic int sum(int a,int b)&#123;\n    &#x2F;&#x2F;Integer.MIN_VALUE &#x3D; -2147483648\n\tboolean downOverflow &#x3D; a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; a&lt;Integer.MIN_VALUE-b;\n    &#x2F;&#x2F;Integer.MAX_VALUE &#x3D; 2147483647\n\tboolean upOverflow &#x3D; a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; a&gt;Integer.MAX_VALUE-b;\n    if(downOverflow || upOverflow)&#123;\n        throw new RuntimeException(&quot;Overflow&quot;);\n    &#125;\n    return a+b;\n&#125;\n自动类型转换：当byte类型的数据赋值给short类型变量时，会触发自动类型转换，其中如果byte类型的数据是正数，则高字节用0补全；如果byte类型的数据是负数，那么高字节用1补全\n\n位运算：\n\n常见的位运算有：与（&amp;）、或（|）、异或（^）==同0异1==、取反（!）、移位\n\n移位分为算数移位和逻辑移位，两种运算操作的对象也是数据的补码。\n\n逻辑位移不区分符号位，整体往左或往右移动，并且在后面或前面补全0。\n\n算数左移跟逻辑左移操作相同，算数右移，正数整体右移之后前面补0，负数整体右移之后前面补1。\n==超出范围的二进制位会被舍弃==\n\n\n\n算术左移相当于乘以2，可以代替乘法提高运算速度，但左移之后如果超过了可以表示的数据范围是，就有可能导致数据从负数变为正数，或从正数变为负数。\n\n算术右移相当于除以2，对于正数，不停算术右移，最终值为0。不过，对于负数来说，不停算术右移，永远都不会为0，最终停留在-1不变。\n\nJava中：算术右移&gt;&gt;，算术左移&lt;&lt;，逻辑右移&gt;&gt;&gt;\n\n\n\n\n6.String1.String的实现原理​    String类的定义：\nPublic final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence&#123;\n    private final char value[];\n    private int hash;\n&#125;\n\n\n接口：\n\nSerializable接口用来表示该类的对象可以序列化和反序列化（见IO）\nComparable接口只有一个compareTo()方法，用来比较两个对象的大小，实现此接口可以自行定义比较方式（见容器）\nCharSequence接口定义了一组操作字符串的方法，比如length()、charAt()、toString()等，StringBuilder、StringBuffer都实现了这个接口\n\n\n属性：\n\nvalue数组用来存储字符串，从Java9开始，将其改成了byte类型（见String压缩技术）\nhash属性用来缓存hashcode，防止重复计算（见容器）\n\n\n构造方法：（见String常量池技术）\nString s1 &#x3D; &quot;abc&quot;;&#x2F;&#x2F;字面常量赋值\nString s2 &#x3D; new String(&quot;abc&quot;);\nString s3 &#x3D; new String(new char[]&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;);\nString s4 &#x3D; new String(s3);\n运算符：C++能直接重载运算符，但Java并不支持（重载运算符是函数式编程、并且语法太复杂），但是String类却实现了加法操作String sc = sa + sb;，主要是因为String比较常用，所以延续了基本类型及其包装类的设计，这样使用起来就方便和统一\n\nlength()：\n\n返回值：char类型value数组的长度，不管是英文还是中文，均占用一个char的存储空间，例如“a我b你c”的函数返回结果为5\n时间复杂度：O(1)，String类的length()方法直接调用了value数组的length属性，length是JVM在内存中为数组维护的信息，所以时间复杂度为O(1)。（其中length属性记录的是数组的大小而不是其中元素的个数，这里可以用因为String不可变，数组大小和字符串元素个数相同）\n\n\nvalueOf()\n\nJava重载了一组valueOf()方法，可以将基本数据类型数据转换为String类型\npublic static String valueOf(boolean b) &#123;\n        return b ? &quot;true&quot; : &quot;false&quot;;\n    &#125;\n\npublic static String valueOf(char c) &#123;\n    char data[] &#x3D; &#123;c&#125;;\n    return new String(data, true);\n&#125;\n\npublic static String valueOf(int i) &#123;\n    return Integer.toString(i);\n&#125;\n\npublic static String valueOf(long l) &#123;\n    return Long.toString(l);\n&#125;\n\npublic static String valueOf(float f) &#123;\n    return Float.toString(f);\n&#125;\n\npublic static String valueOf(double d) &#123;\n    return Double.toString(d);\n&#125;\nString重载+运算符，不止可以实现两个String对象相加，而且String对象还可以跟其他任意类型的对象相加，最后结果为String对象于其他对象的toString()函数的返回值相加\n\n\n\ncompareTo()\n\n字符比较大小，是将字符对应的UTF-16解读为16位的无符号数，在进行比较\n字符串比较，从下标0开始，两个字符串中的相同下标位置的字符一一比较，串a小于串b，返回负数\n\npublic int compareTo(String anotherString) &#123;\n    int len1 &#x3D; value.length;\n    int len2 &#x3D; anotherString.value.length;\n    int lim &#x3D; Math.min(len1, len2);\n    char v1[] &#x3D; value;\n    char v2[] &#x3D; anotherString.value;\n\n    int k &#x3D; 0;\n    while (k &lt; lim) &#123;\n        char c1 &#x3D; v1[k];\n        char c2 &#x3D; v2[k];\n        if (c1 !&#x3D; c2) &#123;\n            return c1 - c2;\n        &#125;\n        k++;\n    &#125;\n    return len1 - len2;\n&#125;\nsubstring()\n\nsubstring(int beginIndex, int endIndex)方法截取并返回下标在[beginIndex, endIndex)范围内的子串\n在JDK7及其以上版本中，substring()方法会生成新的String对象来存储子串，但如果传入参数正好等于字符串的长度，那么会返回字符串本身，不会创建新对象\n在JDK6及以前的版本，通过substring()方法获取到的子串会共享char数组，并有count和offset属性标志子串的长度和起点\n\n\n\n2.String的压缩技术\nJDK8及之前的版本中，String类底层依赖char类型的数组来存储字符串，char类型存储的是UTF-16编码，一个字符2个字节，存储英文等ASCII码会比较浪费空间，因此JDK9中，Java对String类进行了优化，将char类型数组改为了byte类型\n新增了coder属性，有两个值，一个是LATIN1，所有Unicode编号小于等于127的每个字符用一个字节存储；另一个是UTF-16，和之前一样，一个字符用两个字节存储\n是否使用压缩存储方式，可以通过JVM参数设置\n\n3.String的常量池技术\nString类型跟Integer等包装类类似，使用常量池技术，并且只有使用字符串常量赋值时，才触发，如果字符串常量在常量池中已经创建过，则直接使用已经创建的对象。用new创建的对象不在常量池中\n\n出了使用字符串常量赋值外，还可以使用intern()方法，将分配在堆上的String对象，原模原样在常量池中复制一份。\nString s1 &#x3D; &quot;abc&quot;;\nString s2 &#x3D; new String(&quot;abc&quot;);\nString s2 &#x3D; s2.intern();\n\nSystem.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;false\nSystem.out.println(s1&#x3D;&#x3D;s3);&#x2F;&#x2F;true\nSystem.out.println(s2&#x3D;&#x3D;s3);&#x2F;&#x2F;false\n当无法用字符串常量赋值，但又有大量重复字符串时，就可以使用intern()方法复制到常量池中，代码中使用常量池中的String对象，原String对象就被JVM回收掉\n\n\n4.String的不可变性\nString类是不可变类，不可变的意思是：其对象在创建完成之后，所有的属性都不可以再被修改，包括引用类型变量所引用的对象的属性\n原因：\n因为String类使用了常量池技术，有可能很多变量会引用同一个String对象。一个引用修改，别的引用也将获得新数据，不符合大部分业务开发需求\n字符串和整型数经常用来作为HashMap的键（key），如果之后数据改变了，此对象在HashMap的存储位置也需要改变，增加了编码的复杂度\n基本类型和包装类都是不可变的，String延续了他们的设计思路\n\n\n\n5.StringBuilder\n因为String不可变，用+拼接效率低，每次都需要创建新的String对象，所以Java设计了StringBuilder\nStringBuilder支持修改和动态扩容，可以用append()函数拼接，可以把StringBuilder看作是char类型的ArrayList（ArrayList&lt;Character&gt;）\n在平时开发中，经常用+号连接多个字符串，实际上底层就采用StringBuilder来实现\n\n3.引用类型1.Java类型：基本类型 VS 引用类型\n基本类型：整型（byte、short、int、long）、浮点型（float、double）、字符型（char）、布尔型（boolean）\n\n引用类型：\n\n类、接口:\npublic class Group&#123;\n    public int grandNo;\n    public int classNo;\n    public Group(int grandNo, int classNo)&#123;\n        this.grandNo &#x3D; grandNo;\n        this.classNo &#x3D; classNo;\n    &#125;\n&#125;\n\npublic class Studnet&#123;\n    public int id;\n    public int age;\n    public Group group;\n    public Student(int id,int age)&#123;\n        this.id &#x3D; id;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        Student s &#x3D; new Student(1,3);\n        s.group &#x3D; new Group(2,3);\n    &#125;\n&#125;\n\n\n\n\n\n\n数组：\nStudent[][] arr &#x3D; new Student[3][];\n\narr[0] &#x3D; new Student[2];\narr[0][0] &#x3D; new Studnet(2,2);\n\narr[2] &#x3D; new Student[3];\narr[2][1] &#x3D; new Student(4,4);\narr[2][2] &#x3D; new Student(5,5);\n\n\n\n\n\n\n\n\n2.参数传递：值传递 VS 引用传递\n基本参数类型：因为基本类型是存在栈上的，所以在函数调用时，调用函数和被调用函数不能取对方栈里的值，作为参数传递的值被重新赋值\n引用参数类型：因为引用类型是通过new创建的，是存储在堆上的，所以传递给被调用参数的是对象，直接更改对象对所有引用都可见，被调用函数只能改对象的属性，不能改变引用变量本身的值（也就是无法使得调用函数内的引用指向新的对象）\n\n3.数据判等：等号 VS equals()方法\n基本类型数据判等：直接使用==，即可判定两个变量的值是否相等，也就是判定两个变量对应的内存单元中存储的数据是否相等\n\n引用数据类型判等：\n\n==判等：比较变量对应的内存单元中存储的值是否相等，对于引用来说，就是判定两个引用是否指向同一个对象\n\nequals判等：如果没有重写Object类的equals方法，那么就跟使用等号判等一样，但重写之后的equals()判定的不再是对象的内存地址是否相等，而是对象的关键属性值是否相等。一般来说，重写equals()方法的同时，也要重写hashcode()方法。\npublic class Student&#123;\n    public int id;\n    public int age;\n    public Student(int id,int age)&#123;\n        this.id &#x3D; id;\n        this.age &#x3D; age;\n    &#125;\n    @Override\n    public boolean equals(Object obj)&#123;\n        if(obj instanceof Student)&#123;\n            Student stu &#x3D; (Student)obj;\n            return this.id &#x3D;&#x3D; stu.id;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\n\n\n4.访问安全：引用 VS 指针\nJava摒弃C/C++中的指针语法，引入了引用语法，尽管指针和引用存储的都是被指或被引用的内存块的地址，但引用却比指针在使用上安全很多。\n为了方便编写底层的代码，C/C++赋予指针灵活的操作内存的能力，C/C++允许指针越界访问，允许指针做加减运算，允许指针嵌套（指针的指针），甚至允许指针将一块内存重新读为任意类型。因此对程序员编写代码的能力要求很高，稍有不慎就会引入bug，引发安全问题。\nJava语言设计的初衷就是简单易用， 所以权衡安全性和灵活性，Java摒弃了灵活的指针，设计了更加安全的引用，也可以叫做安全指针。引用时有限制的指针，没有了那么多酷炫的操作，Java中的引用只能引用对象或数组，并且不能进行加减运算，而且，强制类型转化也只能发生在有继承关系的类之间。\n\n4.关键字1.关键字概览\n访问修饰符：public(跨包)、protected(包内)、private(类内)\n\n面向对象相关：import、package、new、class、enum、interface、abstract、implements、extends\n\n修饰方法、类、属性和变量：static(静态变量)、final(常量)、super(调用父类方法)、this(调用当前类方法)、native(c代码)、synchronized(加锁)、==transient==、volatile（不可变）、strictfp(strict float point精确浮点)\n\n数据类型：void、null、true、false\n\n整数类型：byte（字节型，8位）、short（短整型，16位）、int（整型，32位，默认）、long（长整型，64位，数后跟L标志位），==负数比正数多一个==\n浮点类型：float（单精度，4字节，数后跟f标志位）、double（双精度，8字节，默认），==float表示的数据范围比int大，见后==\n字符类型：char（2字节，16位，’\\u0000’ ~ ‘\\uFFFF’），==C/C++用1字节==\n布尔类型：boolean（1字节，true/false），==用8位是为了字节对齐和操作简单==\n\n\n控制语句：if、else、switch、case、default、for、while、do、break、continue、return、instanceof（二元操作符、测试左边对象是否是右边对象的实例）\n\n错误处理：try、catch、throw、throws、finally、assert\n\n\n2.语法糖\nswitch支持String与枚举：int比数、char比ascii码、字符串用hashCode()和equals()、\n泛型和类型擦除\n自动装箱与拆箱：\n方法变长参数：String… args用一个数组实现\n枚举：当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。\n内部类：又称为嵌套类，可以把内部类理解为外部类的一个普通成员。\n条件编译：if的条件是final且为false时，对应代码块不被编译\n断言：其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行\n数值字面量：不管是整数还是浮点数，都允许在数字之间插入任意多个下划线，为了方便阅读\n增强for循环：for-each用了普通的for循环和Iterator迭代器的hasNext()方法\ntry-with-resource：在try()中写资源申请，就不用在finally中判断是否为null在关闭了\nlambda表达式：只有一个函数的接口叫做函数式接口，可以用Lambda表达式简化\n\n3.final\nfinal修饰类：final类不可被继承\n\nfinal修饰方法：final方法在子类中不可被重写，子类可以将父类的非final方法声明为final方法，早期会优化为内联函数，现在看情况\n\nfinal修饰变量（常量）：final变量只被赋值一次，之后就不能再修改。final修饰的变量有三类：\n\n类的成员变量：有两种赋值方式，在成员变量声明时，或在构造函数中\n函数的局部变量：有两种赋值方式，在局部变量声明时，或在使用前赋值一次\n函数的参数：final修饰的变量既可以是基本类型变量，也可以是引用类型变量，对于引用型变量，final关键字只限制引用本身不可变，但引用变量所引用的对象的属性或者数组的s元素是可变的\n\n\nfinal的应用场景：不可变类，以下展示了如何设计一个不可变类\n\n将类设置为final类，这样类就无法被继承，避免通过如下方式创建可变对象\npublic class MyString extends String&#123;\n    &#x2F;&#x2F;重写toCharArray()方法，让它直接返回value数组，这样就能更改value数组了\n    @Override\n    public char[] toCharArray()&#123;\n        return value;\n    &#125;\n&#125;\nString s &#x3D; new MyString(&quot;abc&quot;);\nchar[] chars &#x3D; s.toCharArray();\nchars[0] &#x3D; &#39;x&#39;;\nSystem.out.println(s);&#x2F;&#x2F;打印xab\n将类中所有的属性设置为final，在创建对象时设置，之后不再允许修改。当然，如果能保证类中没有方法会改变这个属性的值，也可以不用将其设置为final，例如String类中的hash属性\n\n通过方法返回属性，如果是引用类型的（数组或对象，如String类中的value数组），需要返回属性的副本而非本身。否则外部代码可以通过引用，修改返回对象中的属性或数组中元素。\npublic char[] toCharArray()&#123;\n    char result[] &#x3D; new char[value.length];&#x2F;&#x2F;副本\n    System.arraycopy(value,0,result,0,value.length);\n    return result;&#x2F;&#x2F;返回副本\n&#125;\n\n\n\n4.static\nstatic变量\n\nstatic只能修饰类的成员变量（静态变量），静态变量隶属于类，为类的所有对象所共享存储，静态变量跟类的代码一起存储在方法区\n\n对于静态变量，既可以通过类来访问，也可以通过对象来访问\npublic class Obj&#123;\n    public static int objCount &#x3D; 0;\n    public Obj()&#123;\n        objCount++;\n    &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        Obj o1 &#x3D; new Obj();\n        Obj o2 &#x3D; new Obj();\n        System.out.println(Obj.objCount);&#x2F;&#x2F;打印2\n        System.out.println(o1.objCount);&#x2F;&#x2F;打印2\n    &#125;\n&#125;\nstatic和final一起修饰的变量叫做静态常量，对于一些跟具体对象无关，又不会改变的常量数据，一般使用静态常量来存储。静态常量命名比较特殊，所有字母都大写\n\n\n\nstatic方法\n\n静态方法属于类而非对象，所以可以在不创建对象的情况下，调用静态方法。所以很多工具类中的方法都设计为静态方法，比如Math类，Collections类中的方法\n==注意==：静态方法只能访问静态成员变量，以及调用类中的其它静态方法，静态方法不能访问类中的非静态成员变量，也不能调用类中的非静态方法。反过来，类中的非静态方法可以访问类中的静态变量和静态方法。因为对象可以使用类的数据，但类不能使用具体某个对象的数据\n\n\nstatic代码块：对于某些静态成员变量，如果初始化无法通过一个简单的赋值语句来完成，可以将静态成员变量的初始化逻辑放入static修饰的代码块中，静态代码块是在类加载时执行的\npublic class ParserFactory&#123;\n    private static Map&lt;String,Parser&gt; parsers &#x3D; new HashMap&lt;&gt;();\n    static&#123;\n        parsers.put(&quot;json&quot;,new JSONParser());\n        parsers.put(&quot;xml&quot;,new XMLParser());\n        parsers.put(&quot;yaml&quot;,new YAMLParser());\n    &#125;\n    &#x2F;&#x2F;省略其他方法和属性\n&#125;\nstatic嵌套类\n\n\n\n\n\n\n\n\n\nstatic只能修饰嵌套类，也叫做内部类，内部类在编译成字节码之后，会独立于外部类，生成一个新的class文件，命名方式为：外部类名$内部类名.class，对于匿名内部类，因为内部类没有名字，所以命名方式为：外部类名$[序号].class。其中序号表示此内部类是外部类的第几个匿名内部类\n\n普通内部类\n\n例如ArrayList类中定义了一个内部类Itr,负责遍历ArrayList容器中的元素，Itr类独自属于ArrayList类，其他类不会用到它，这样代码的可读性和可维护性好，更加满足封装原则\n\nprivate内部类对除外部类之外的代码不可见，如果想在除了外部类之外的代码中使用内部类，要不将内部类设置为public，要么让内部类实现一个外部的接口，外部代码使用接口来访问内部类的代码\npublic interface I&#123;&#125;\npublic class A&#123;\n    private class B&#123;&#125;\n    private class C implements I&#123;&#125;&#x2F;&#x2F;实现外部接口的内部类\n    public class D&#123;&#125;&#x2F;&#x2F;public修饰的内部类\n    \n    public B getB()&#123;\n        return new B();\n    &#125;\n    public I getC()&#123;\n        return new C();\n    &#125;\n    public D getD()&#123;\n        return new D();\n    &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.B b &#x3D; a.getB();&#x2F;&#x2F;编译报错\n        I c &#x3D; a.getC();\n        A.D d1 &#x3D; a.getD();\n        A.D d2 &#x3D; a.new D();\n    &#125;\n&#125;\n\n\n静态内部类\n\n静态内部类和普通内部类主要区别有三个：\n\n在访问权限上，内部类跟外部类中的方法具有相同的访问权限。也就是说，静态内部类跟静态方法一样，只能访问外部类的静态变量和静态方法，而普通内部类可以访问外部类的所有变量和所有方法\n\n静态内部类可以包含静态变量和静态方法，而普通内部类不行，不过在JDK16中，普通内部类也可以包含静态变量和静态方法了\n\n如果要创建普通内部类的对象，需要先创建外部类的对象，而静态内部类的对象可以独立于外部类单独创建\npublic class A&#123;\n    public class D&#123;&#125;\n    public static class E&#123;&#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.D d &#x3D; a.new D();\n        A.E e &#x3D; new A.E();\n    &#125;\n&#125;\n\n\n\n\n匿名类\n\n在线程开发中，我们会经常用到匿名内部类，如下：\nThread t &#x3D; new Thread(new Runnable()&#123;\n    @Override\n    public void run()&#123;\n        System.out.println(&quot;hello&quot;)\n    &#125;\n&#125;);\nt.start();\n匿名内部类跟定义它的外部函数，具有相同的访问权限，如果外部函数是静态函数，那么匿名内部类只能访问外部类的静态成员变量和静态函数；如果外部函数是普通函数，那么访问内部类可以访问外部类的任何成员变量和成员函数，包括private修饰的成员变量和成员函数。除此之外，匿名内部类还可以访问外部函数的final局部变量\npublic class Demo&#123;\n  private static int a &#x3D; 1;\n  private int b &#x3D; 2;\n  private static void f()&#123;&#125;\n  private void g()&#123;&#125;\n  public static void main(String[] args)&#123;\n    final int c &#x3D; 3;\n    int d &#x3D; 4;\n\n    Thread t &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        a+&#x3D;1;s\n        b+&#x3D; 3;&#x2F;&#x2F;编译报错，非静态成员变量\n        int y &#x3D; c+1;\n        int x &#x3D; d+2;&#x2F;&#x2F;编译报错，非final局部变量\n        f();\n        g();&#x2F;&#x2F;编译报错，非静态成员函数\n      &#125;\n    &#125;);\n    t.start();\n    d &#x3D; 3\n  &#125;\n&#125;\n为什么非final局部变量不能被匿名函数访问：因为外部函数通过类似参数传递的方式，将局部变量传递给匿名内部类来使用，前面讲过，java的参数传递的是值传递。匿名内部类对参数（相当于局部变量的副本）进行修改，不会改变局部变量本身的值。在程序员看来，明明在匿名类中修改了局部变量的值，却没有生效，不符合直觉认知，所以在设计上，只允许匿名内部类访问final修饰的局部变量。\npublic interface ICallable&#123;\n    void add();\n&#125;\npublic class Demo&#123;\n    public void test()&#123;\n        int a &#x3D; 1;\n        ICallable callback &#x3D; new ICallable()&#123;\n            @Override\n            public void add()&#123;\n                a++;\n                System.out.println(a);&#x2F;&#x2F;打印2\n            &#125;\n        &#125;\n        System.out.println(a);&#x2F;&#x2F;被修改了，但却仍然打印1\n    &#125;\n&#125;\n\n\n\n\n例题：\n \n\n\n5.类和对象\n\n\n\n\n\n\n\n\n Java对象在内存中的存储结构包含三部分：对象头（Header）、实例数据（Instance）、对其填充（Padding）。可以使用JOL工具来查看对象的内存结构\n1.对象头​        对象头又包含：标记字、类指针、数组长度（有数组时）\n\n标记字（Mark Word）：在32位JVM中占4字节长度，其存储对象在运行过程中的一些信息，例如：GC分代年龄（age）、锁标志位（lock）、是否偏向锁（biased_lock）、线程ID（thread）、时间戳（epoch）、哈希值（hashcode）等。其中大部分信息都用于多线程和JVM垃圾回收\n类指针（C++指针）：对象所属的类的信息存储在方法区，为了知道某个对象的类信息，对象头中存储了类指针，指向方法区中的类信息，即对应类信息在方法区中的内存地址\n数组长度：在JVM实现数组时，JVM将数组作为一种特殊的对象来看待，其内存存储结构跟普通对象几乎一样，唯一的区别是数组的对象头中多了数组长度这样一个字段，无论是32位还是64位，此字段都占4字节长度。由此可知Java中可以申请的数组的最大长度位2^32-1\n\n2.实例数据\n实例对象存储的是对象里的非静态成员变量，可以是基本类型，也可以是引用类型，而非对象，所以静态变量并非存储在对象中，在64位JVM中，各个类型的字节长度为：\n\n\n\n类型\n字节大小\n\n\n\ndouble\n8\n\n\nlong\n8\n\n\nfloat\n4\n\n\nint\n4\n\n\nshort\n2\n\n\nchar\n2\n\n\nbyte\n1\n\n\nboolean\n1\n\n\n引用\n8\n\n\n\n在内存，每个属性存储的内存地址，必须是自身字节长度的倍数，比如：long型、int型、char型属性的内存地址必须分别是8、4、2的倍数，如果不是，需要补齐。这样的存储要求叫做“字节对齐”，补齐的方式叫做“字节填充”。\n\n对象中的属性并非按照定义的顺序存储，而是依据如下规则：\n\n先存储父类的属性，在存储子类的属性\n类中的属性默认按照如下先后顺序来存储：double/long、float/int、short/char、byte/boolean、object referece，此顺序受JVM参数-XX:FieldsAllocationStyle影响，不过高版本被废弃默认是这个顺序\n任何属性的存储地址是按照类型的字节长度，进行字节对齐和填充，比如：long类型的属性的存储地址按8字节对齐，不足的补齐，对象整体按照8字节对齐和填充\n父类的属性和子类的属性之间4字节对齐，不足4字节的补齐4字节\n在应用规则4之后，父类的属性和子类的属性之间仍有间隙（子类有8字节属性，所以父类属性和子类属性之间要填充4字节，才能8字节对齐），我们将子类属性按照float/int、short/char、byte/boolean、object referece的顺序，依次拿来填充间隙，直到间隙填充满或无法继续填充为止。同理，如果在对象头和类的属性之间有间隙，我们同样应用此规则进行填充，此规则受JVM参数-XX:CompactFields的影响，默认为true。\n\n\n\n3.对齐填充\n进行字节对齐和对齐填充的原因：CPU按照字（Word）为单位从内存中读取数据，对于64位的CPU，字的大小位8字节，也就是说，内存以8字节为单位，切分为很多快，CPU每次读取一块内存\n为了避免CPU缓存的伪共享，程序员会手动进行64字节或128字节对齐，见多线程\n\n4.压缩类指针和引用\n类指针压缩：-XX:+UseCompressedClassPointers参数打开后，类指针为4字节大小\n引用压缩：-XX:+UseCompressedOops参数打开后，引用为4字节大小\n如何把8字节的地址压缩为4字节，以引用类型为例：\n4字节可以寻址的内存大小为2^32个字节，即4GB；如果设置的堆大小超过4GB，有些对象的地址就无法在引用类型属性中存储了\n对齐填充中对象是按照8字节对其的，也就是说，对象的首地址是8的倍数，表示成二进制之后，后三位都是0，所以32位二进制可以存储长度为35个二进制的地址，即32GB\n以此类推，通过增加对象对齐的字节数，可以扩大表示范围，可以使用-XX:ObjectAlignmentInBytes参数配置对象的对其长度，参数取值范围为[8，256]，最大可以设置的堆大小为4GB*此参数值\n\n\n为什么要压缩引用和指针：\n在编程中，我么会频繁地使用引用类型，在64位JVM中，将其压缩至4字节，可以大大节省存储空间\nJava之所以在有Integer等包装类的情况下，仍然引入int等基本类型，其中一个重要原因就是节省内存，例如：一个int数据占据4字节内存，一个Integer对象，对象头8字节+类指针4字节=12字节，然后加上仅有的int类型属性，总共占据16字节，所以使用基本类型比包装类型节省大量内存空间。\n\n\n\n6.容器\n1.JCF\nJava的JCF（Java Collections Framework）类似于C++的STL（Standard Template Library）\n\n概览图：\n\n\n将JCF中的容器分为5类：\n\nList（列表）：ArrayList、LinkedList、Vector（废弃）\nStack（栈）：Stack（废弃）\nQueue（队列）：ArrayDeque、LinkedList、PriorityQueue\nSet（集合）：HashSet、LinkedHashSet、TreeSet\nMap（映射）：HashMap、LinkedHashMap、TreeMap、HashTable（废弃）\n\n\n继承与实现关系\n\n实现相同的接口是为了方便在开发中替换不同的实现类\n继承同样的抽象类是为了避免重复编写代码，通过抽象类来存放这些公共的代码\n\n\n\n2.List\nArrayList：底层依赖可扩容的数组，即可以动态扩容，\n\nLinkedList：底层依赖的数据结构为双向链表，并且有头尾指针\n\nVector：Vector是线程安全的ArrayList，模仿的是C++STL中的Vector，为了更符合程序员的开发习惯，JCF将线程安全容器和非线程安全容器分开来设计。在非多线程环境下，使用没加锁的ArrayList替代Vector，性能更高。对于多线程环境，我们可以使用Collections工具类提供的synchronizedList方法，或者使用JUC（java.util.concurrent）提供的CopyOnWriteArrayList。（详见多线程）\n\nStack：Stack同Vector一样，也是JDK1.0d的产物，继承自Vector，不推荐使用，取而代之，我们可以使用Deque双端队列来模拟栈\n\n\n4.Queue\nDeque\n\nArrayDeque是基于数组实现的队列\nLinkedList是基于链表实现的队列，LinkedList在实现中实现了Deque接口\n\n\nPriorityQueue\n\n底层依赖堆来实现，默认情况下为小顶堆，最先出队列的为当前队列中的最小值，可以通过Comparator接口的匿名类对象来改变优先级队列的实现方式。\n\n堆的构建过程，需要比较节点中数据的大小，所以，添加到优先级队列中的元素，需要能够比较大小，方法有两种：基于Comparable接口和基于Comparator接口，都有时则优先使用comparator，详见siftUp\n&#x2F;&#x2F;不管是使用Comparable的o1.compareTo(o2)方法，还是使用Comparator的compare(o1，o2)方法\n&#x2F;&#x2F;o1小于o2时都返回负数，o1等于o2时都返回0，o1大于o2时都返回正数\npublic interface Comparable&lt;T&gt;&#123;\n    public int compareTo(T o);\n&#125;\npublic interface Comparator&lt;T&gt;&#123;\n    int compare(T o1,T o2);\n&#125;\n&#x2F;&#x2F;实现comparable接口，表示类是可比较的，写死在类中\npublic class Person1 implements Comparable&lt;Person1&gt;&#123;\n    private int age;\n    private String name;\n\n    public Person1(String name, int age)&#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n    @Override\n    public int compareTo(Person1 o)&#123;\n        return this.age-o.age;\n    &#125;\n&#125;\nPriorityQueue&lt;Person1&gt; p &#x3D; new PriorityQueue&lt;&gt;();\n&#x2F;&#x2F;使用comparator灵活定义优先级，是一种比较器工具，后续可更改\npublic final class Person2&#123;\n    private int age;\n    private String name;\n\n    public Person2(String name, int age)&#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n&#x2F;&#x2F;匿名类对象\nPriorityQueue&lt;Person2&gt; p &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;Person2&gt;()&#123;\n    @Override\n    public int compare(Person2 o1, Person2 o2)\n    &#123;\n        if(o1 &#x3D;&#x3D; null || o2 &#x3D;&#x3D; null)\n            return 0;\n        return o1.getAge()-o2.getAge();\n    &#125;\n&#125;);\n\n\n\n5.Set\nSet容器跟List容器都可以用来存储一组数据，不同的地方在于：List容器中有下标的概念，不同下标对应的位置可以存储相同的数据，而Set容器没有下标的概念，不允许存储相同的数据\n\nSet容器包括HashSet、LinkedHashSet、TreeSet，从代码实现上来说，这三个类底层分别是依赖HashMap、LinkedHashMap、TreeMap。例如：往HashSet中存储对象obj，底层将obj作为key，一个空的Object对象作为value，一并存储到HashMap中，如下：\npublic class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;\n    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable\n&#123;\n    &#x2F;&#x2F;数据存储在这个Map中\n    private transient NavigableMap&lt;E,Object&gt; m;\n    &#x2F;&#x2F;存储在Map中的默认value值\n    private static final Object PRESENT &#x3D; new Object();\n    \n    public TreeSet() &#123;\n        this(new TreeMap&lt;E,Object&gt;());\n    &#125;\n    \n    public boolean contains(Object o) &#123;\n        return m.containsKey(o);\n    &#125;\n\n    public boolean add(E e) &#123;\n        return m.put(e, PRESENT)&#x3D;&#x3D;null;\n    &#125;\n&#125;\n\n6.Map\nMap容器包括HashMap、LinkedHashMap和TreeMap，跟Set容器类似，Map容器也不存储重复的键，其中HashMap和LinkedHashMap的底层原理见后两节\nTreeMap\nTreeMap是基于红黑树来实现的，TreeMap基于键值对的键来构建红黑树，值作为卫星数据，附属在红黑树的中\n在使用TreeMap时，要么键值对中的键实现 Comparable接口，要么在构建TreeMap时传入Comparator接口的匿名类对象\nTreeMap直接实现的接口时SortedMap，而非Map，这是因为TreeMap底层依赖红黑树来实现，其中中序遍历的结构是有序的，因此，相对于基于哈希表实现的HashMap，TreeMap可以提供更多丰富的功能，比如查看最大键、最小键值、大于某个值的键值、有序输出所有的键值等等，这些操作都定义在SortedMap接口中\n\n\n\n6-1.HashMap1.基本原理\nHashMap容器实现了接口Map，是一个映射，通过key快速获取value，key与value具有一一映射关系，HashMap中的key不能重复，但value可以重复，存储重复的key，后面存储的value会覆盖前面的value\n\nHashMap容器是基于哈希表实现的，对key计算哈希值，并将key和value包裹为一个对象，存储在哈希表中\nstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n    final int hash;\n    final K key;\n    V value;\n    Node&lt;K,V&gt; next;\n\n    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n        this.hash &#x3D; hash;\n        this.key &#x3D; key;\n        this.value &#x3D; value;\n        this.next &#x3D; next;\n    &#125;\n    &#x2F;&#x2F;省略getter、setter等方法\n&#125;\n&#x2F;&#x2F;哈希表\ntransient Node&lt;K,V&gt;[] table;\nHashMap通过链表法来解决哈希冲突，table数组用来存放链表，Node类便是链表中节点的定义，其中的hash值由key通过哈希函数计算得到，起到缓冲作用，在查询元素时，用此值做预判，详见哈希函数，冲突情况见下图\n\n\n\n2.哈希函数\nHashMap中的哈希函数\nstatic final int hash(Object key) &#123;\n    int h;\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n&#x2F;&#x2F;因为得到的哈希范围往往会超过table数组长度n，因此，需要跟n取模，n默认为16\n&#x2F;&#x2F;因为取模操作比较耗时，所以用位运算实现取模运算，如下所示\nint index &#x3D; hash(key)&amp;(n-1); &#x2F;&#x2F; 插入数组时选择的位置\n\n\nkey的hashCode()函数：hashCode()函数定义在Object类中，根据对象在内存中的地址来计算哈希值，也可以在Object的子类中重写hashCode()函数，\n&#x2F;&#x2F;Integer的hashCode()函数\npublic int hashCode() &#123;\n    return Integer.hashCode(value);\n&#125;\n&#x2F;&#x2F;String类的hashCode()函数\npublic int hashCode() &#123;\n    int h &#x3D; hash;\n    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;\n        char val[] &#x3D; value;\n\n        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;\n            h &#x3D; 31 * h + val[i];\n        &#125;\n        hash &#x3D; h;\n    &#125;\n    return h;\n&#125;\nh^(h&gt;&gt;&gt;16)：在hash()函数中，不直接返回h的原因是因为，一般来说，table数组的大小n不会很大，一般会小于2^16（65536），而hashCode()函数的返回值h为int类型，长度为4个字节，在计算key对用的数组下标时，h跟n取模后，h的高16位消息将会丢失，相当于只使用了h的后16位信息，理论上来讲，参与运算的信息越多，得到的数组下标越随机，所以将hashCode()函数的返回值h与其高16位异或，这样所有的信息都没有浪费\n\n取模h&amp;(n-1)：之所以可以用这种方法来实现取模运算，有一个前提是：HashMap中table数组的大小n为2的幂次方，例如2^4，将其减一之后的二进制串为11111，跟h求与，相当于取模操作\n\nkey可为null值：从hash()函数中，可以发现，值为null的key的哈希值为0，对应数组下标为0，所以，值为null的key也可以存储在HashMap中，不过，一个HashMap容器只能存储一个值为null的key\n\n\n\nhash属性：hash属性存储的是key的哈希值，这个值作用是预判、提高查询速度，避免重复计算\n\n当调用get(xkey)函数查询xkey的xvalue时，HashMap容器先通过hash(xkey)函数计算得到xkey的哈希值，假设为xhash，xhash跟table数组大小n取模，得到数组下标xindex，也就说明x应该出现在table[xindex]对应的链表中\n遍历table[xindex]所对应的链表，查找xkey对应的节点，当遍历到每个node节点之后，首先会拿出node.hash，与x的哈希值xhash比较，如果不相等，则继续比较下一节点\n如果相等，因为存在hash冲突，所以还需要再调用equls()方法，比较node.key和xkey是否真的想等\n因为hash的比较为整数比较(==)，key的比较为对象的比较(equals())，所以前者效率更高，可以提高查询速度\n\npublic V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);\n        &#125;\n    &#125;\n    return null;\n&#125;\n\n3.装载因子\nJCF提供的容器都支持动态扩容，HashMap的扩容主要由table数组的大小(n，默认16)和装载因子(loadFactor，默认0.75)决定，当HashMap容器中的元素个数超过n*loadFactor时，就会触发扩容，其中n*loadFactor再HashMap类中定义为属性threshold。n和loadFactor可以用默认的也可以通过构造函数传入\npublic HashMap(int initialCapacity, float loadFactor) &#123;\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity &#x3D; MAXIMUM_CAPACITY;\n    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n    this.loadFactor &#x3D; loadFactor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);\n&#125;\n前面提到，为了方便是用位运算来实现取模运算，table数组的大小必须是2的幂次方，如果自定义的不是，则需要tableSizeFor()函数，它会寻找比initialCapacity大的第一个2的幂次方数\nstatic final int tableSizeFor(int cap) &#123;\n    int n &#x3D; cap - 1;\n    n |&#x3D; n &gt;&gt;&gt; 1;\n    n |&#x3D; n &gt;&gt;&gt; 2;\n    n |&#x3D; n &gt;&gt;&gt; 4;\n    n |&#x3D; n &gt;&gt;&gt; 8;\n    n |&#x3D; n &gt;&gt;&gt; 16;\n    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n&#125;\n将tableSizeFor(initialCapacity)直接赋值给threshold的原因：在创建HashMap对象时，table数组只声明未创建，其值为null，只有当第一次调用put()函数时，table数组才会被创建，但是，HashMap并没有定义表示table数组大小的属性，于是，tableSizeFor(initialCapacity)的值暂存在threshold属性中，当真正要创建table数组时，HashMap会先用threshold作为数组大小创建table数组，再将其重新赋值为真正的扩容阈值\nthis.table &#x3D; new T[this.threshold];\nthis.threshold *&#x3D; this.factor;\n一般不改变装载因子，但若更关注时间效率，则可以适当减小装载因子，哈希冲突的概率会更小，链表长度更短；若更关注空间效率，则可以适当增大装载因子，table数组中的空闲空间就更少，不过，这也会导致冲突概率更大，链表长度更长，增删改查以及扩容都会变慢\n\n装载因子是0.75的原因：\n\n权衡时间效率和空间效率之后的结果\n大概是[0.5,1]之间，因为小于0.5会有一半空间从来未用，当大于1时，哈希冲突的概率会大大增加，即使有链表和树化，也会影响性能\n因为table数组的大小n都是2的倍数，而且触发扩容的阈值threshold = n * loadfactor，所以，在[0.5,1]之间，只有0.75能使得得到的阈值一直是整数\n\n&#x2F;**\n* &lt;p&gt;As a general rule, the default load factor (.75) offers a good\n* tradeoff between time and space costs.  Higher values decrease the\n* space overhead but increase the lookup cost (reflected in most of\n* the operations of the &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; class, including\n* &lt;tt&gt;get&lt;&#x2F;tt&gt; and &lt;tt&gt;put&lt;&#x2F;tt&gt;).  The expected number of entries in\n* the map and its load factor should be taken into account when\n* setting its initial capacity, so as to minimize the number of\n* rehash operations.  If the initial capacity is greater than the\n* maximum number of entries divided by the load factor, no rehash\n* operations will ever occur.\n*&#x2F;\n\n4.动态扩容\n当我们调用put()函数往HashMap容器中添加键值对时，在添加完成后，会判断容器中键值对的个数时候超过threshold，如果超过则触发动态扩容，申请一个新的table[]数组，大小为原table数组的2倍，并将原table数组中的节点，一个一个的搬移到新的table[]数组中。\n\n扩容会逐一处理table数组中的每条链表，当由红黑树时，跟链表的处理方式类似\n\n因为容量变大，位置会发生变化，将每个节点的hash值与新的容量取模，取模操作仍可以用位运算来替代，但JDK8中优化为：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）。\n\n\n扫描table数组中的每一条链表，根据节点的下标是否更改，将链表中的节点分配到lo链表和hi链表，lo链表中存储的是下标值未变的节点，hi链表存储的是下标值有所改变的节点。处理完一条链表后，将lo链表和hi链表分别存储到新的table数组中的对应位置。\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;使用resize创建新table\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#x2F;&#x2F;数组中链表头不存在，初始化\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123; &#x2F;&#x2F;数组中插入位置有链表头，遍历\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;先检查第一个节点\n            e &#x3D; p; &#x2F;&#x2F;找到\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;没找到，新建节点\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F;树化？\n                    break;\n                &#125;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#x2F;&#x2F;找到\n                    break;\n                p &#x3D; e;&#x2F;&#x2F;继续遍历\n            &#125;\n        &#125;\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;&#x2F;&#x2F;更新值\n            afterNodeAccess(e);&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions？？？\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions？？？\n    return null;\n&#125;\n\n\n\n5.链表树化\n尽管我们可以通过装载因子，限制HashMap容器中不会装载太多的键值对，但只能限制平均链表长度，对于单个链表的长度，我们无法限制，当链表长度过长时，HashMap上的增删改查都会变慢，针对这种情况，JDK8做了优化，当某个链表中的节点个数大于等于8（此值定义在HashMap类的TREEIFY_THRESHOLD静态常量中），并且table数组的大小大于等于64时，将会把链表转化为红黑树，这个过程就叫treeify（树化）。\n\n但是如果table数组长度小于64，即便链表中的节点个数大于等于8，也不会触发treeify，而是触发扩容操作，试图通过扩容长链表拆分为短链表，因为小数据量的情况下，扩容要比treeify更简单，更省时间。\n\n当红黑树中节点个数比较少时，HashMap会再将其转换回链表，因为维护红黑树的成本比较高，对于少许节点，使用链表存储更高效，红黑树转换为链表的过程，叫做untreeify，促发untreeify的场景有两个，一个是删除键值对时，另一个是扩容时。\n\n在删除键值对时，如果红黑树满足以下结构，则会触发untreeify，这个结构的红黑树的节点个数应该处于[2,6]之间，尽管treeify的阈值是8，但untreeify的阈值是[2,6]之间的某个数，之所以不相等是为了避免频繁的插入删除操作，导致节点个数在7，8之间频繁波动\n&#x2F;&#x2F;removeTreeNode函数中\nif (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||\n    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;\n    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small\n    return;\n&#125;\n在扩容时，每一条链表都会分割为lo和hi两条，同理红黑树也会分割为lt和ht两个红黑树，lt中存储的是下标位置不变的节点，ht中存储的是下标位置变化的节点。不过，我们在构建lt和ht之前，会先统计属于lt和ht的节点个数lc和hc，如果lc小于等于6（此值定义在HashMap类的UNTREEIFY_THRESHOLD静态常量中），在新的table数组中，HashMap会使用链表来存储下标不变的节点，同理，如果hc小于等于6，在新的table数组中，HashMap会使用链表来存储下标改变的节点。\n\n\n\n链表树化阈值为什么是8：\n\n装在因子限定的是链表的平均长度，用来保证HashMap的整体性能，链表树化限定的是链表长度的最大值，用来保证HashMap的最差情况下的性能。\n\n通过泊松分布：入为事件发生的平均次数，k为想要得到发生概率的次数。链表的平均长度为0.5，带入到公式中，并将k赋值为0、1、2…8，得到对应发生的概率值，8的概率为千万分之六，发生的概率已经足够低了，所以选择8作为链表树化的阈值。\n\n\n\n\n\n6-2.LinkedHashMap\n\n\n\n\n\n\n\n\nHashMap的增强版，既能实现快速的增删改查操作，又能实现容器内的有序遍历\n1.整体结构\n哈希表+双向有序链表\npublic class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;\n    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n        Entry&lt;K,V&gt; before, after;\n        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n            super(hash, key, value, next);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;双向链表的头指针和尾指针\n    transient LinkedHashMap.Entry&lt;K,V&gt; head;\n    transient LinkedHashMap.Entry&lt;K,V&gt; tail;\n    &#x2F;**\n     * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;&#x2F;tt&gt;\n     * for access-order（访问顺序）, &lt;tt&gt;false&lt;&#x2F;tt&gt; for insertion-order（插入顺\n     * 序）.\n     *&#x2F;\n    final boolean accessOrder;\n    &#x2F;&#x2F;键和值不再包裹为Node节点，而是包裹为Entry节点\n    &#x2F;&#x2F;next用来将节点串联在table数组的链表中，before和after用来串联双向链表\n    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n        Entry&lt;K,V&gt; before, after;\n        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n            super(hash, key, value, next);\n        &#125;\n    &#125;\n&#125;\n示例：\n\n\n\n2.entrySet()\n在Map接口中，定义了三个方法来返回内部数据：\npublic Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;\n    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;\n    return (es &#x3D; entrySet) &#x3D;&#x3D; null ? \n        (entrySet &#x3D; new LinkedEntrySet()) : es;\n&#125;\npublic Set&lt;K&gt; keySet() &#123;\n    Set&lt;K&gt; ks &#x3D; keySet;\n    if (ks &#x3D;&#x3D; null) &#123;\n        ks &#x3D; new LinkedKeySet();\n        keySet &#x3D; ks;\n    &#125;\n    return ks;\n&#125;\npublic Collection&lt;V&gt; values() &#123;\n    Collection&lt;V&gt; vs &#x3D; values;\n    if (vs &#x3D;&#x3D; null) &#123;\n        vs &#x3D; new LinkedValues();\n        values &#x3D; vs;\n    &#125;\n    return vs;\n&#125;\n遍历方式\nMap&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();\n\n&#x2F;&#x2F;把HashMap改为LinkedHashMap后，输出结果的顺序跟键值对插入的先后顺序一致\n&#x2F;&#x2F;Map&lt;Integer,String&gt; map &#x3D; new LinkedHashMap&lt;&gt;();\n\n&#x2F;&#x2F;for-each循环\nSet&lt;Entry&lt;Integer,String&gt;&gt; entrySet  &#x3D; map.entrySet();\nfor(Entry&lt;Integer,String&gt; entry : entrySet)&#123;\n    System.out.println(entry);\n&#125;\n&#x2F;&#x2F;迭代器遍历\nIterator&lt;Map.Entry&lt;Integer,String&gt;&gt;itr &#x3D; entrySet.iterator();\nwhile(itr.hasNext())&#123;\n    System.out.println(itr.next().toString());\n&#125;\n&#x2F;&#x2F;forEach()函数，函数式编程，Lambda表达式\nentrySet.forEach(e-&gt;System.out.println(e.toString()));\n\nEntrySet内部类\nfinal class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final int size() &#123; return size; &#125;\n    public final void clear() &#123; HashMap.this.clear(); &#125;\n    &#x2F;&#x2F;for-each遍历和迭代器遍历\n    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;\n        return new EntryIterator();\n    &#125;\n    &#x2F;&#x2F;foreach()遍历\n    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;\n        Node&lt;K,V&gt;[] tab;\n        if (action &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        if (size &gt; 0 &amp;&amp; (tab &#x3D; table) !&#x3D; null) &#123;\n            int mc &#x3D; modCount;\n            for (int i &#x3D; 0; i &lt; tab.length; ++i) &#123;\n                for (Node&lt;K,V&gt; e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; e.next)\n                    action.accept(e);\n            &#125;\n            if (modCount !&#x3D; mc)\n                throw new ConcurrentModificationException();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;迭代器\nfinal class EntryIterator extends HashIterator\n    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;\n&#125;\nabstract class HashIterator &#123;\n    &#x2F;&#x2F;省略属性和其他方法\n    public final boolean hasNext() &#123;\n        return next !&#x3D; null;\n    &#125;\n\n    final Node&lt;K,V&gt; nextNode() &#123;\n        Node&lt;K,V&gt;[] t;\n        Node&lt;K,V&gt; e &#x3D; next;\n        if (modCount !&#x3D; expectedModCount)\n            throw new ConcurrentModificationException();\n        if (e &#x3D;&#x3D; null)\n            throw new NoSuchElementException();\n        if ((next &#x3D; (current &#x3D; e).next) &#x3D;&#x3D; null &amp;&amp; (t &#x3D; table) !&#x3D; null) &#123;\n            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next &#x3D; t[index++]) &#x3D;&#x3D; null);\n        &#125;\n        return e;\n    &#125;\n&#125;\nLinkedHashMap有序遍历：迭代器和forEach()函数遍历的对象不再是table数组，而是双向链表\nfinal class LinkedEntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final int size()                 &#123; return size; &#125;\n    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;\n    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;\n        return new LinkedEntryIterator();\n    &#125;\n    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;\n        if (action &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        int mc &#x3D; modCount;\n        for (LinkedHashMap.Entry&lt;K,V&gt; e &#x3D; head; e !&#x3D; null; e &#x3D; e.after)\n            action.accept(e);\n        if (modCount !&#x3D; mc)\n            throw new ConcurrentModificationException();\n    &#125;\n&#125;\nfinal class LinkedEntryIterator extends LinkedHashIterator\n    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;\n&#125;\nabstract class LinkedHashIterator &#123;\n    &#x2F;&#x2F;省略其他属性和方法\n    public final boolean hasNext() &#123;\n        return next !&#x3D; null;\n    &#125;\n\n    final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;\n        LinkedHashMap.Entry&lt;K,V&gt; e &#x3D; next;\n        if (modCount !&#x3D; expectedModCount)\n            throw new ConcurrentModificationException();\n        if (e &#x3D;&#x3D; null)\n            throw new NoSuchElementException();\n        current &#x3D; e;\n        next &#x3D; e.after;\n        return e;\n    &#125;\n&#125;\n\n3.插入、删除、修改、查找\n插入键值对：新增的键值对会被包裹成Entry节点，通过next指针串在table数组的对应链表中，同时，通过before、after指针串在双向有序链表的尾部。双向链表的有序性是动态维护的，不管哪种排序方式，将新键值对插入到双向链表的尾部，双向链表仍然有序。扩容时不影响双向链表，直接复用HashMap中的逻辑。\n&#x2F;&#x2F;将Entry节点串在table数组对应的链表中的逻辑见HashMap，可以直接复用\n&#x2F;&#x2F;将Entry节点串在双向有序链表尾部的代码如下：\nprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;\n    LinkedHashMap.Entry&lt;K,V&gt; last &#x3D; tail;\n    tail &#x3D; p;\n    if (last &#x3D;&#x3D; null)\n        head &#x3D; p;\n    else &#123;\n        p.before &#x3D; last;\n        last.after &#x3D; p;\n    &#125;\n&#125;\n删除键值对：删除键值对时，对应的Entry节点会从table数组对应的链表和双向链表中删除，删除操作并不会破坏双向链表的有序性\nvoid afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink\n    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;\n        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;\n    p.before &#x3D; p.after &#x3D; null;\n    if (b &#x3D;&#x3D; null)\n        head &#x3D; a;\n    else\n        b.after &#x3D; a;\n    if (a &#x3D;&#x3D; null)\n        tail &#x3D; b;\n    else\n        a.before &#x3D; b;\n&#125;\n修改键对应值：修改键对应的值，结构不需要调整，对于双向有序链表，如果是按照插入顺序来排序，就不需要对其结构进行调整；如果是按照访问顺序来排序，需要将被修改的节点移动到双向链表的尾部。\nvoid afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last\n    LinkedHashMap.Entry&lt;K,V&gt; last;\n    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;\n        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;\n            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;\n        p.after &#x3D; null;\n        if (b &#x3D;&#x3D; null)\n            head &#x3D; a;\n        else\n            b.after &#x3D; a;\n        if (a !&#x3D; null)\n            a.before &#x3D; b;\n        else\n            last &#x3D; b;\n        if (last &#x3D;&#x3D; null)\n            head &#x3D; p;\n        else &#123;\n            p.before &#x3D; last;\n            last.after &#x3D; p;\n        &#125;\n        tail &#x3D; p;\n        ++modCount;\n    &#125;\n&#125;\n查找键值对：对于按照访问数序排序的双向链表，操作同上述afterNodeAccess()函数。\n\n\n4.应用：LRU缓存public class LRUCache&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; &#123;\n    private int cacheMaxSize;&#x2F;&#x2F;缓存大小限制\n    public LRUCache(int size) &#123;\n        &#x2F;&#x2F;因为动态扩容会影响效率，如果可以预估出数据量，并当作initialCapacity\n        &#x2F;&#x2F;传入构造函数就不会触发动态扩容了。\n        super((int) (size&#x2F;0.75f + 1),0.75f,true);\n        this.cacheMaxSize &#x3D; size;\n    &#125;\n    @Override\n    protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;\n        &#x2F;&#x2F;this.size()返回LinkedHashMap中元素的个数\n        &#x2F;&#x2F;缓存满了的时候返回true，LinkedHashMap的afterNodeInsertion\n        &#x2F;&#x2F;会删除访问时间最早的节点\n        return cacheMaxSize &gt; this.size();\n    &#125;\n&#125;\npublic class LRUCache&lt;K,V&gt; &#123;\n    private int cacheMaxSize;\n    private LinkedHashMap&lt;K,V&gt; lmap;\n    public LRUCache(int size)&#123;\n        this.lmap &#x3D; new LinkedHashMap&lt;K,V&gt;&#123;\n            @Override\n            protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)&#123;\n                &#x2F;&#x2F;this.size()返回LinkedHashMap中元素的个数\n                return cacheMaxSize &gt; this.size();\n            &#125;\n        &#125;;\n        this.cacheMaxSize &#x3D; size;\n    &#125;\n    public V get(K key)&#123;\n        return lmap.get(key);\n    &#125;\n    public void put(K key,V value)&#123;\n        lmap.put(key,value);\n    &#125;\n    public void remove(K key)&#123;\n        lmap.remove(key);\n    &#125;\n&#125;\n\n7.Collections\n\n\n\n\n\n\n\n\nJCF提供的一个工具类，包含大量操作容器的静态函数，其中下文的XXX可以替换为List、Collection、Set、Map等\n1.sort()\nCollections类中的sort()函数用来对List进行排序，默认方式为从小到大排序（也可通过传入Comparator接口的匿名类对象改变排序方式）\n&#x2F;&#x2F;函数定义\npublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;\n    list.sort(null);\n&#125;\n@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)\npublic static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123;\n    list.sort(c);\n&#125;\n&#x2F;&#x2F;使用方法\nList&lt;Integer&gt; list &#x3D; new LinkedList&lt;&gt;();\nlist.add(2);\nlist.add(3);\nlist.add(6);\n&#x2F;&#x2F;默认\nCollections.sort(list);\n&#x2F;&#x2F;自定义\nCollections.sort(list, new Comparator&lt;Integer&gt;() &#123;\n    @Override\n    public int compare(Integer o1, Integer o2) &#123;\n        return o2-o1;\n    &#125;\n&#125;);\n&#x2F;&#x2F;直接调用list的sort()\n&#x2F;&#x2F;Comparator接口的匿名类对象为null\n&#x2F;&#x2F;使用Integer实现的Comparable接口进行元素大小比较\nlist.sort(null);\n不管是ArrayList容器还是LinkedList容器，使用sort()函数进行排序时，底层都会先将其转换为数组，对数组进行排序之后，再将排好序的数据存入容器\n&#x2F;&#x2F;Collections类中\npublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;\n    list.sort(null);\n&#125;\n&#x2F;&#x2F;List接口中\ndefault void sort(Comparator&lt;? super E&gt; c) &#123;\n    Object[] a &#x3D; this.toArray();\n    &#x2F;&#x2F;Arrays是数组的工具类，Collections是容器的工具类\n    Arrays.sort(a, (Comparator) c);\n    ListIterator&lt;E&gt; i &#x3D; this.listIterator();\n    for (Object e : a) &#123;\n        i.next();\n        i.set((E) e);\n    &#125;\n&#125;\nCollections底层的sort()函数，底层依赖的Arrays类的sort()函数的是实现算法：\n\n基本类型数组排序算法：JDK8及以后使用DualPivotQuickSort()，JDK7及其以前使用快排\npublic static void sort(int[] a) &#123;\n    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);\n&#125;\n对象数组排序算法：JDK8及其以后使用TimSort()，JDK7及其以前使用归并排序\npublic static void sort(Object[] a) &#123;\n    if (LegacyMergeSort.userRequested)\n        legacyMergeSort(a);\n    else\n        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);\n&#125;\npublic static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;\n    if (c &#x3D;&#x3D; null) &#123;\n        sort(a);\n    &#125; else &#123;\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a, c);\n        else\n            TimSort.sort(a, 0, a.length, c, null, 0, 0);\n    &#125;\n&#125;\n一个对象用来构建数据结构的属性叫做键，对象中的其他属性叫做卫星数据，针对对象数组的排序，Arrays类使用稳定的TimSort来实现，对于基本类型数据的排序，使用对稳定性没有要求的DualPivotQuickSort来实现\n\n\n\nDualPivotQuickSort实现原理\n\n代码实现中用到了双轴快速排序算法、插入排序、计数排序、归并排序等算法\n\n对快排改进，选取两个pivot：LP&amp;RP，采用5数取2法\n\n对int、long、float、double这4种类型的数组：当数组长度小于QUICKSORT_THRESHOLD（286）时，执行双轴快速排序算法；在双轴快速排序算法中，在递归处理过程中，当待排序区间长度小于INSERTION_SORT_THRESHOLD（47）时，改为使用插入排序算法。如果待排序数组长度大于QUICKSORT_THRESHOLD（286）时，则通过从头到尾扫描统计数组中连续增和连续减区间的个数，如果区间个数超过MAX_RUN_COUNT（67）时，则说明待排序数组的数据杂乱无章一些，于是就选改进后的双轴快速排序，否则就选择执行非递归版的归并排序\n\n对char、short类型的数组，如果数组元素大于COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR（3200）时，将执行计数排序，否则同int等类型的数组相同的排序过程\n\n对于byte类型的数组COUNTING_SORT_THRESHOLD_FOR_BYTE（29）时，将执行计数排序，否则执行插入排序\n\n\n\nTimSort实现原理\n\n使用非递归版本归并排序算法，在归并排序的过程中，大的排序区间不断分解为小的待排序区间，如果带排序区间的长度小于MIN_MERGE（32），就不再继续分解，转而执行二分插入排序算法\n二分插入排序算法将数组分为两部分：已排序区间和未排序区间，初始化已排序区间为空，为排序区间为整个数组。每次从未排序区间中取出一个数，插入到已排序区间中，并保持已排序区间继续有序。二分插入排序是通过二分查找，查找插入位置，当找到后，通过调用System.arraycopy()函数，将插入点之后的数据整体快速后移一位，腾出位置给要插入的数据。\n\n\n\n2.binarySearch()\nbinarySearch()用来对已排序的List容器进行二分查找，定义如下，因为也涉及元素比较，所以需要传入实现Comparable接口的对象或者主动传入Comparator接口的匿名类对象\npublic static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;\n    &#x2F;&#x2F;RandomAccess接口代表支持随机访问\n    &#x2F;&#x2F;BINARYSEARCH_THRESHOLD(5000)，每次找mid都需要遍历\n    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n&#125;\npublic static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123;\n    if (c&#x3D;&#x3D;null)\n        return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key);\n\n    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key, c);\n    else\n        return Collections.iteratorBinarySearch(list, key, c);\n&#125;\n&#x2F;&#x2F;使用\nCollections.sort(list);\nint idx &#x3D; Collections.binarySearch(list,targetNum);\n两种二分查找：\nprivate static &lt;T&gt; int indexedBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c) &#123;\n    int low &#x3D; 0;\n    int high &#x3D; l.size()-1;\n\n    while (low &lt;&#x3D; high) &#123;\n        int mid &#x3D; (low + high) &gt;&gt;&gt; 1;\n        T midVal &#x3D; l.get(mid);\n        int cmp &#x3D; c.compare(midVal, key);\n        &#x2F;&#x2F;Comparable&lt;? super T&gt; midVal &#x3D; list.get(mid);\n        &#x2F;&#x2F;int cmp &#x3D; midVal.compareTo(key);\n\n        if (cmp &lt; 0)\n            low &#x3D; mid + 1;\n        else if (cmp &gt; 0)\n            high &#x3D; mid - 1;\n        else\n            return mid; &#x2F;&#x2F; key found\n    &#125;\n    return -(low + 1);  &#x2F;&#x2F; key not found\n&#125;\nprivate static &lt;T&gt; int iteratorBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c) &#123;\n    int low &#x3D; 0;\n    int high &#x3D; l.size()-1;\n    ListIterator&lt;? extends T&gt; i &#x3D; l.listIterator();\n\n    while (low &lt;&#x3D; high) &#123;\n        int mid &#x3D; (low + high) &gt;&gt;&gt; 1;\n        T midVal &#x3D; get(i, mid);\n        int cmp &#x3D; c.compare(midVal, key);\n\n        if (cmp &lt; 0)\n            low &#x3D; mid + 1;\n        else if (cmp &gt; 0)\n            high &#x3D; mid - 1;\n        else\n            return mid; &#x2F;&#x2F; key found\n    &#125;\n    return -(low + 1);  &#x2F;&#x2F; key not found\n&#125;\n&#x2F;&#x2F;get每次都从上一个mid的位置向前或向后找，查找的范围变小了，执行效率变高了\nprivate static &lt;T&gt; T get(ListIterator&lt;? extends T&gt; i, int index) &#123;\n    T obj &#x3D; null;\n    int pos &#x3D; i.nextIndex();\n    if (pos &lt;&#x3D; index) &#123;\n        do &#123;\n            obj &#x3D; i.next();\n        &#125; while (pos++ &lt; index);\n    &#125; else &#123;\n        do &#123;\n            obj &#x3D; i.previous();\n        &#125; while (--pos &gt; index);\n    &#125;\n    return obj;\n&#125;\n\n3.emptyXXX()\nemptyXXX()用来返回一个空的容器，其中的XXX可以替换为List、Set、Map，定义如下，一般用来替换返回null值，因为返回null值有可能导致外部代码在调用函数时发生NullPointerException异常\npublic static final &lt;T&gt; List&lt;T&gt; emptyList() &#123;\n    return (List&lt;T&gt;) EMPTY_LIST;\n&#125;\npublic static final &lt;T&gt; Set&lt;T&gt; emptySet() &#123;\n    return (Set&lt;T&gt;) EMPTY_SET;\n&#125;\npublic static final &lt;K,V&gt; Map&lt;K,V&gt; emptyMap() &#123;\n    return (Map&lt;K,V&gt;) EMPTY_MAP;\n&#125;\n一个要注意的用法：Collections.emptyList()函数返回的虽然是一个新类（EmptyList）的对象，但他是Collections的静态成员变量，当使用这个新类的add函数时，会抛出UnsupportedOperationException异常（见AbstractList）。为了避免这个问题，一般在外部代码重新定义一个容器，将调用函数返回的结果通过addAll()添加到容器中\npublic static final List EMPTY_LIST &#x3D; new EmptyList&lt;&gt;();\nprivate static class EmptyList&lt;E&gt;\n    extends AbstractList&lt;E&gt;\n    implements RandomAccess, Serializable &#123;\n    private static final long serialVersionUID &#x3D; 8842843931221139166L;\n\n    public Iterator&lt;E&gt; iterator() &#123;\n        return emptyIterator();\n    &#125;\n    public ListIterator&lt;E&gt; listIterator() &#123;\n        return emptyListIterator();\n    &#125;\n\n    public int size() &#123;return 0;&#125;\n    public boolean isEmpty() &#123;return true;&#125;\n\n    public boolean contains(Object obj) &#123;return false;&#125;\n    public boolean containsAll(Collection&lt;?&gt; c) &#123; return c.isEmpty(); &#125;\n\n    public Object[] toArray() &#123; return new Object[0]; &#125;\n\n    public &lt;T&gt; T[] toArray(T[] a) &#123;\n        if (a.length &gt; 0)\n            a[0] &#x3D; null;\n        return a;\n    &#125;\n\n    public E get(int index) &#123;\n        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);\n    &#125;\n\n    public boolean equals(Object o) &#123;\n        return (o instanceof List) &amp;&amp; ((List&lt;?&gt;)o).isEmpty();\n    &#125;\n\n    public int hashCode() &#123; return 1; &#125;\n\n   &#x2F;&#x2F;...省略部分代码\n&#125;\nList&lt;Integer&gt; list &#x3D; Collections.emptyList();\nList&lt;Integer&gt; list2 &#x3D; Collections.emptyList();&#x2F;&#x2F;list2 &#x3D;&#x3D; list true\n&#x2F;&#x2F;错误使用方式,抛出异常\nlist.add(&quot;abc&quot;);\n&#x2F;&#x2F;正确使用方式\nList&lt;Integer&gt; list3 &#x3D; new ArrayList&lt;&gt;();\nlist3.addAll(list);\nlist3.add(&quot;abc&quot;);&#x2F;&#x2F;插入成功\n\n4.synchronizedXXX()\nJCF中的容器都是非线程安全的，当要使用线程安全的容器时，首选使用JUC并发容器，但当没有合适的JUC并发容器可以使用时，可以使用Collectinos类中的synchronizedXXX()函数来创建线程安全的容器。定义如下：\npublic static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) &#123;\n    return new SynchronizedCollection&lt;&gt;(c);\n&#125;\npublic static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;\n    return (list instanceof RandomAccess ?\n            new SynchronizedRandomAccessList&lt;&gt;(list) :\n            new SynchronizedList&lt;&gt;(list));\n&#125;\npublic static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) &#123;\n    return new SynchronizedSet&lt;&gt;(s);\n&#125;\npublic static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;\n    return new SynchronizedMap&lt;&gt;(m);\n&#125;\n&#x2F;&#x2F;创建线程安全的容器：\nList list &#x3D; Collections.synchronizedList(new LinekdList&lt;&gt;());\n&#x2F;&#x2F;底层原理，通过对每个方法加锁，来避免并发访问\nstatic class SynchronizedList&lt;E&gt;\n    extends SynchronizedCollection&lt;E&gt;\n    implements List&lt;E&gt; &#123;\n    private static final long serialVersionUID &#x3D; -7754090372962971524L;\n\n    final List&lt;E&gt; list;\n\n    SynchronizedList(List&lt;E&gt; list) &#123;\n        super(list);\n        this.list &#x3D; list;\n    &#125;\n    SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;\n        super(list, mutex);\n        this.list &#x3D; list;\n    &#125;\n\n    public boolean equals(Object o) &#123;\n        if (this &#x3D;&#x3D; o)\n            return true;\n        synchronized (mutex) &#123;return list.equals(o);&#125;\n    &#125;\n    public int hashCode() &#123;\n        synchronized (mutex) &#123;return list.hashCode();&#125;\n    &#125;\n\n    public E get(int index) &#123;\n        synchronized (mutex) &#123;return list.get(index);&#125;\n    &#125;\n    public E set(int index, E element) &#123;\n        synchronized (mutex) &#123;return list.set(index, element);&#125;\n    &#125;\n    public void add(int index, E element) &#123;\n        synchronized (mutex) &#123;list.add(index, element);&#125;\n    &#125;\n    public E remove(int index) &#123;\n        synchronized (mutex) &#123;return list.remove(index);&#125;\n    &#125;\n\t&#x2F;&#x2F;...\n&#125;\n\n5.unmodifiable()\nunmodifiableXXX()用来返回不可变容器，这里的不可变指的是容器内的数据只能访问，不可增删。\npublic static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123;\n    return new UnmodifiableCollection&lt;&gt;(c);\n&#125;\npublic static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) &#123;\n    return (list instanceof RandomAccess ?\n            new UnmodifiableRandomAccessList&lt;&gt;(list) :\n            new UnmodifiableList&lt;&gt;(list));\n&#125;\npublic static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) &#123;\n    return new UnmodifiableSet&lt;&gt;(s);\n&#125;\npublic static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n    return new UnmodifiableMap&lt;&gt;(m);\n&#125;\n&#x2F;&#x2F;使用\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nList&lt;Integer&gt; result &#x3D; Collections.unmodifiableList(list);\n&#x2F;&#x2F;抛出UnsupportedOperationException异常\nresult.add(Integer.valueof(1));\n实现原理：定义新的UnmodifiableXXX类，重写add()、remove()等增删操作，让其抛出UnsupportedOperationException异常\nstatic class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;\n    implements List&lt;E&gt; &#123;\n    private static final long  &#x3D; -283967356065247728L;\n\n    final List&lt;? extends E&gt; list;\n\n    UnmodifiableList(List&lt;? extends E&gt; list) &#123;\n        super(list);\n        this.list &#x3D; list;\n    &#125;\n\n    public boolean equals(Object o) &#123;return o &#x3D;&#x3D; this || list.equals(o);&#125;\n    public int hashCode()           &#123;return list.hashCode();&#125;\n\n    public E get(int index) &#123;return list.get(index);&#125;\n    public E set(int index, E element) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public void add(int index, E element) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public E remove(int index) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public int indexOf(Object o)            &#123;return list.indexOf(o);&#125;\n    public int lastIndexOf(Object o)        &#123;return list.lastIndexOf(o);&#125;\n    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n\n    @Override\n    public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    @Override\n    public void sort(Comparator&lt;? super E&gt; c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n\n    public ListIterator&lt;E&gt; listIterator()   &#123;return listIterator(0);&#125;\n\n    public ListIterator&lt;E&gt; listIterator(final int index) &#123;\n        return new ListIterator&lt;E&gt;() &#123;\n            private final ListIterator&lt;? extends E&gt; i\n                &#x3D; list.listIterator(index);\n\n            public boolean hasNext()     &#123;return i.hasNext();&#125;\n            public E next()              &#123;return i.next();&#125;\n            public boolean hasPrevious() &#123;return i.hasPrevious();&#125;\n            public E previous()          &#123;return i.previous();&#125;\n            public int nextIndex()       &#123;return i.nextIndex();&#125;\n            public int previousIndex()   &#123;return i.previousIndex();&#125;\n\n            public void remove() &#123;\n                throw new UnsupportedOperationException();\n            &#125;\n            public void set(E e) &#123;\n                throw new UnsupportedOperationException();\n            &#125;\n            public void add(E e) &#123;\n                throw new UnsupportedOperationException();\n            &#125;\n\n            @Override\n            public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n                i.forEachRemaining(action);\n            &#125;\n        &#125;;\n    &#125;\n\n    public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;\n        return new UnmodifiableList&lt;&gt;(list.subList(fromIndex, toIndex));\n    &#125;\n    private Object readResolve() &#123;\n        return (list instanceof RandomAccess\n                ? new UnmodifiableRandomAccessList&lt;&gt;(list)\n                : this);\n    &#125;\n&#125;\n\n8.Iterator\n\n\n\n\n\n\n\n\n遍历容器的常用方法\n1.容器的遍历方法\n\n\n\n\n\n\n\n\n主要考虑List、Set、Map，不考虑操作受限的Stack和Queue，因为容器的底层可能比较复杂，所以将遍历逻辑包裹成迭代器，来降低开发成本。\n\nfor循环：只能用于List容器，因为需要根据下标获取元素，而Set、Map并没有下标的概念，所以不支持这种遍历方式，LinkedList虽然能用但性能差（O(n^2)）\nfor(int i &#x3D; 0;i &lt; list.size();++i)&#123;\n    System.out.println(list.get(i));\n&#125;\nfor-each循环：和迭代器遍历等价，是一种语法糖，底层用迭代器实现\nfor(String s ； list)&#123;\n    System.out.println(s);\n&#125;\n迭代器：只支持实现了Iterable接口的类，所以List和Set支持迭代器遍历，Map不支持，只能通过entrySet()获取EntrySet对象，然后通过EntrySet提供的迭代器来遍历\nIterator&lt;String&gt; itr &#x3D; list.iterator();\nwhile(itr.hasNext())&#123;\n    System.out.println(itr.next());\n&#125;\nforEach()函数：JDK8开始支持的函数式编程，List、Set、Map都支持，具体见函数式编程\nlist.forEach(s-&gt;System.out.println(s));\n\n2.实现原理\n迭代器是迭代器设计模式的经典实现，迭代器设计模式的代码结构如下：\n\n\nIterable接口\npublic interface Iterable&lt;T&gt; &#123;\n    Iterator&lt;T&gt; iterator();\n    \n    default void forEach(Consumer&lt;? super T&gt; action) &#123;\n        Objects.requireNonNull(action);\n        for (T t : this) &#123;\n            action.accept(t);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;用于配合实现forEach()函数式编程\n    default Spliterator&lt;T&gt; spliterator() &#123;\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    &#125;\n&#125;\nArrayList中iterator()函数的代码实现：容器实现Iterable接口，迭代器实现Iterator接口，容器中定义迭代器类，并通过iterator()函数返回迭代器类对象\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;\n    protected transient int modCount &#x3D; 0;\n    \n    public Iterator&lt;E&gt; iterator() &#123;\n        return new Itr();\n    &#125;\n\n    private class Itr implements Iterator&lt;E&gt; &#123;\n        int cursor;       &#x2F;&#x2F; index of next element to return\n        int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such\n        int expectedModCount &#x3D; modCount;\n\n        Itr() &#123;&#125;\n\n        public boolean hasNext() &#123;\n            return cursor !&#x3D; size;\n        &#125;\n\n        @SuppressWarnings(&quot;unchecked&quot;)\n        public E next() &#123;\n            checkForComodification();\n            int i &#x3D; cursor;\n            if (i &gt;&#x3D; size)\n                throw new NoSuchElementException();\n            Object[] elementData &#x3D; ArrayList.this.elementData;\n            if (i &gt;&#x3D; elementData.length)\n                throw new ConcurrentModificationException();\n            cursor &#x3D; i + 1;\n            return (E) elementData[lastRet &#x3D; i];\n        &#125;\n\n        public void remove() &#123;\n            if (lastRet &lt; 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try &#123;\n                ArrayList.this.remove(lastRet);\n                cursor &#x3D; lastRet;\n                lastRet &#x3D; -1;\n                expectedModCount &#x3D; modCount;\n            &#125; catch (IndexOutOfBoundsException ex) &#123;\n                throw new ConcurrentModificationException();\n            &#125;\n        &#125;\n\n        @Override\n        @SuppressWarnings(&quot;unchecked&quot;)\n        public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;\n            Objects.requireNonNull(consumer);\n            final int size &#x3D; ArrayList.this.size;\n            int i &#x3D; cursor;\n            if (i &gt;&#x3D; size) &#123;\n                return;\n            &#125;\n            final Object[] elementData &#x3D; ArrayList.this.elementData;\n            if (i &gt;&#x3D; elementData.length) &#123;\n                throw new ConcurrentModificationException();\n            &#125;\n            while (i !&#x3D; size &amp;&amp; modCount &#x3D;&#x3D; expectedModCount) &#123;\n                consumer.accept((E) elementData[i++]);\n            &#125;\n            &#x2F;&#x2F; update once at end of iteration to reduce heap write traffic\n            cursor &#x3D; i;\n            lastRet &#x3D; i - 1;\n            checkForComodification();\n        &#125;\n\n        final void checkForComodification() &#123;\n            if (modCount !&#x3D; expectedModCount)\n                throw new ConcurrentModificationException();\n        &#125;\n    &#125;\n&#125;\n增强版的迭代器：ListIterator\npublic interface Iterator&lt;E&gt; &#123;\n    boolean hasNext();\n    E next();\n    default void remove() &#123;\n        throw new UnsupportedOperationException(&quot;remove&quot;);\n    &#125;\n    default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    &#125;\n&#125;\npublic interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;\n    boolean hasNext();\n    E next();\n    boolean hasPrevious();\n    E previous();\n    int nextIndex();\n    int previousIndex();\n    void remove();\n    void set(E e);\n    void add(E e);\n&#125;\n&#x2F;&#x2F;使用\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.addAll(Arrays.asList(0,1,2,3,4));\n&#x2F;&#x2F;从下标为2的位置开始遍历\nListIterator&lt;Integer&gt; litr &#x3D; list.listIterator(2);\nwhile(litr.hasNext())&#123;\n    System.out.println(litr.next());&#x2F;&#x2F;输出2 3 4\n&#125;\nwhile(litr.hasNext())&#123;\n    System.out.println(litr.previous());&#x2F;&#x2F;输出4 3 2 1 0\n&#125;\n\n3.问题及解决思路\n在创建迭代器之后，增删容器中的元素，再使用迭代器遍历容器，会导致未决行为（结果不确定），所以才引入了expectedModCount和modCount这两个成员变量\n当没有expectedModCount和modCount这两个成员变量的时候，在遍历的时候增删元素会遇到未决问题\n解决方法：在增删元素之后，让遍历报错，凡是实现了Iterable接口的容器，都有modCount成员变量，用来记录容器修改的次数，容器每调用一次增加或删除元素的函数，就会给modCount加1，当通过调用容器上的iterator()函数来创建迭代器的时候，把modCount的值传递给expectedModCount成员变量，之后每次调用迭代器上的next()函数，我们都会调用checkForComodification()函数，检查modCount是否改变过。如果expectedModCount和modCount的值不同， 则说明被修改过，迭代器就不能用了，抛出运行时异常ConcurrentModificationException，结束程序，让程序员尽快修复这个bug\n\n4.安全删除元素\nIterator接口中出了最基本的hasNext()、next()方法之外，还定义了一个remove()方法，使用它可以在遍历的同时，安全的删除容器中的元素。但是它只能删除cursor指向的前一个元素，而且调用一个next()函数之后，只能跟着一个remove()操作\n\n7.异常1.异常使用\n作用：相比较C语言返回错误码的方式，可以携带更多的错误信息（message、stack trace等），并且可以将业务代码和异常处理代码分离，这样代码的可读性会更好。\n\n异常关键词：\n\nthrow：用来抛出异常\nthrows：用来在方法定义中声明方法可能抛出的异常\ntry：用来标记需要监控异常的代码\ncatch：用来捕获代码抛出的异常并进行处理\nfinally：用来兜底，只要try标记的代码被执行，不管有没有抛出异常，finally中的代码都会被执行，一般用来做清理工作，比如关闭打开的文件\n\npublic byte[] readData(String filePath) throws DataReadException&#123;\n    IntputStream in &#x3D; null;\n    try&#123;\n        in &#x3D; new FileInputStream(filePath);\n        byte[] data &#x3D; new byte[in.available()];\n        in.read(data);\n        return data;\n    &#x2F;&#x2F;先捕获子类异常，再捕获父类异常\n    &#125;catch(FileNotFoundException e)&#123;\n        &#x2F;&#x2F;DataReadException是自定义异常\n        throw new DataReadException(&quot;File not found&quot; + filePath,e);\n    &#125;catch(IOException e)&#123;\n        throw new DataReadException(&quot;Failed to read&quot; + filePath,e);\n    &#125;finally&#123;\n        if(in !&#x3D; null)&#123;\n            try&#123;\n                in.close();\n            &#125;catch(IOException e)&#123;\n                &#x2F;&#x2F;使用日志框架记录日志\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;新特性\npublic void readData(String filePath)throws DataReadException&#123;\n    try(InputStram in &#x3D; new FileInputStream(filePath))&#123;\n        Thread.sleep(10);\n    &#125;catch(FileNotFoundException | InterruptedException e)&#123;\n        &#x2F;&#x2F;...\n    &#125;catch(IoException e)&#123;\n        throw new DataReadExceptioin(&quot;Failed to read&quot; + filePath,e);\n    &#125;\n&#125;\n&#x2F;&#x2F;对于实现了Java.lang.AutoClosale接口的资源类，可以使用try-with-resources语句来\n&#x2F;&#x2F;创建资源类对象，try代码执行完成之后，对应的资源会自动被关闭\n\n2.异常体系\n\nThrowable是所有异常的父类，Error和Exception是Throwable的子类，RuntimeExeption是Exception的子类，因此所有异常可以分为三类：\n继承自Error的异常，是一种比较特殊的异常，用来表示程序无法处理的严重错误，这些错误有可能导致线程或JVM终止\n继承自Exception的异常，也叫做受检异常（Checked Exception）或编译时异常（Compile Exception），在编写代码的时候，我们需要主动取捕获或者在函数定义中声明此类异常，否则编译就会报错\n继承自RuntimeException的异常，也叫做非受检异常（Unchecked Exception）或者运行时异常（Runtime Exception），在编写代码的时候，我们可以不主动取捕获和在函数定义中声明此类异常，不处理也可以通过编译\n\n\n\n3.自定义异常\n一般使用Java已经提供的内建异常，在不满足业务需求的情况下，就需要自定义异常，如下：\npublic class UserNotExistingException extends Exception&#123;\n    public UserNotExistingException()&#123;\n        super();\n    &#125;\n    public UserNotExistingException(String msg,Throwable cause)&#123;\n        super(msg,cause)；\n    &#125;\n    public UserNotExistingException(String msg)&#123;\n        super(msg);\n    &#125;\n    public UserNotExistingException(Throwable cause)&#123;\n        super(cause);\n    &#125;\n&#125;\n自定义异常跟大多数内建异常一样，要么继承自Exception，要么继承自RuntimeException。对于代码bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以更倾向于使用非受检异常。对于可恢复异常、业务异常、预期可能发生的异常（比如现金额大于余额的异常），更倾向于使用受检异常。但是现在一般都依赖框架来编程，受检和非受检异常大部分情况下都会被框架兜底捕获并处理，并不会直接导致程序的终止，所以从这个角度来看，继承自哪个异常均可。\n\n受检异常的缺点：\n\n受检异常需要显示地在函数定义中声明，如果过多，则会影响代码可读性\n编译器强制程序必须显示地捕获所有的受检异常，代码实现会比较繁琐\n受检异常的使用违反开闭原则，如果给某个函数新增一个受检异常，这个函数所在的函数调用链上的所有位于其上的数，都需要做相应的代码修改，知道某个函数捕获处理不再抛出为止，相反，新增非受检异常可以不改动调用链上的代码，可以灵活地选择在某个函数中集中处理，比如再Spring中的AOP切面集中处理异常\n\n\n非受检异常的缺点：非受检异常使用起来更加灵活，怎么处理异常的主动权交给了程序员，在使用函数时，需要查看函数的逻辑，才能知道函数具体抛出哪些异常，一些本应该捕获处理的异常就有可能被程序员遗漏。\n\n\n4.异常处理\n一共有三种处理方法，选择的原则是：函数只抛出跟函数所涉及业务相关的异常，在函数内部，如果某代码的异常行为，并不会导致调用此函数的上层代码出现异常行为，也就是说，上层代码并不关心被调用函数内部的这个异常，我们就可以在函数内部将这个异常捕获并打印日志记录。相反，如果函数内部的异常行为会导致调用此函数时，知道如何处理异常，那么直接将其抛出即可。如果此异常跟函数的业务无关，上层代码无法理解这个异常的含义，不知道如何处理，那么需要将其包裹成新的跟函数业务相关的异常重新抛出。\n\n捕获后记录日志\n\npublic void f() throws LowLevelException&#123;...&#125;\npublic void g()&#123;\n    try&#123;\n        f();\n    &#125;catch(LowLevelException e)&#123;\n        log.warn(&quot;...&quot;,e);&#x2F;&#x2F;使用日志框架记录日志\n    &#125;\n&#125;\n\n\n\n\n原封不动再抛出\n\npublic void f() throws LowLevelException&#123;...&#125;\n&#x2F;&#x2F;如果LowLevelException是非受检异常，则不需要再函数g()定义中声明\npublic void g() throws LowLevelException&#123;\n    f();\n&#125;\n\n\n\n\n包装成新异常抛出\n\npublic void f() throws LowLevelException&#123;...&#125;\npublic void g()&#123;\n    try&#123;\n        f();\n    &#125;catch(LowLevelExceptioin e)&#123;\n        throw new HighLevelException(&quot;...&quot;,e);\n    &#125;\n&#125;\n改版：\n\n\n&#x2F;&#x2F;文件打开失败的FileNotFoundException因为跟readData()函数业务相关，可以直接将其抛出\npublic byte[] readData(String filePath) throws \n    \t\t\t\tDataReadException,FileNotFoundException&#123;\n    IntputStream in &#x3D; null;\n    try&#123;\n        Thread.sleep(10);\n        in &#x3D; new FileInputStream(filePath);\n        byte[] data &#x3D; new byte[in.available()];\n        in.read(data);\n        return data;\n    &#125;catch(InterruptedException e)&#123;\n        &#x2F;&#x2F;DataReadException是自定义异常\n        throw new DataReadException(&quot;Interuupted when reading&quot; + filePath,e);\n    &#125;catch(IOException e)&#123;\n        &#x2F;&#x2F;因为IOException异常比较底层，如果原封不动抛出，上层不知道如何处理\n        &#x2F;&#x2F;所以，将其包裹成DataReadException异常再抛出\n        throw new DataReadException(&quot;Failed to read&quot; + filePath,e);\n    &#125;finally&#123;\n        if(in !&#x3D; null)&#123;\n            try&#123;\n                in.close();\n            &#125;catch(IOException e)&#123;\n                &#x2F;&#x2F;使用日志框架记录日志\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n5.异常调用链\n异常调用链可以完整的描述异常发生的整个过程，但需要特别注意的是，捕获异常并包裹成新的异常抛出时，我们一定要将先前的异常通过cause参数传递进新的异常，否则，异常调用链会断开。\n&#x2F;&#x2F;错误\ntry&#123;\n    ...\n&#125;catch(CausedByException e)&#123;\n    throw new NewException(&quot;msg&quot;);&#x2F;&#x2F;e丢失\n&#125;\n&#x2F;&#x2F;正确\ntry&#123;\n    ...\n&#125;catch(CausedByException e)&#123;\n    throw new NewException(&quot;msg&quot;,e);\n&#125;\n在平时开发中，我们还需要注意，对于异常的处理，要么记录，要么抛出，但两者不能同时执行，对于异常调用链，只需要在最后一个异常生命周期结束时，打印异常调用链即可，没必要如下，重复打印异常调用链\n&#x2F;&#x2F;错误\ntry&#123;\n    ...\n&#125;catch(CauseByException)&#123;\n    logger.error(&quot;...&quot;,e);\n    throw new NewException(&quot;msg&quot;,e);\n&#125;\n\n6.异常实现原理\n异常代码块执行顺序：不管try监听的代码块有没有异常抛出，finally代码块总是被执行，并且在finally代码执行完成之后，try代码块和catch代码块中的return语句才会被执行\n\n异常的运行机制主要有3部分：\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        double res &#x3D; div(2, 1);\n        System.out.println(res);\n        res &#x3D; div(2, 0);\n        System.out.println(res);\n    &#125;\n\n    public static double div(int a, int b) &#123;\n        try &#123;\n            double res &#x3D; a &#x2F; b;\n            System.out.println(&quot;in the block&quot;);\n            return res;\n        &#125;catch (ArithmeticException e)&#123;\n            System.out.println(&quot;in the ATE catch block&quot;);\n            return -1.0;\n        &#125;finally &#123;\n            System.out.println(&quot;in finally blocks&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n异常表：对应于上图最后一部分的Exception table，其中from、to、target都表示字节码的行号，当行号在[from，to）之间的代码抛出type类型的异常时，JVM会跳转至target行字节码继续执行\n异常兜底：第50行代码开始，主要是捕获try代码块和catch代码块中未被捕获的异常，然后再执行完finally代码块之后，在原封不动的将异常抛出。\nfinally内联：JVM在生成字节码时，会将finally代码块内联（插入）到try代码块和catch代码块中的return语句之前，这样就可以实现不管程序是否抛出异常，finally代码块总是会被执行，并且再函数返回之前执行。如果finally由return语句，会提前返回\n\n\n\n\n7.异常性能分析\n\n\n\n\n\n\n\n\n如果未发生异常，则性能不受影响；当有异常抛出时，一般会执行三个操作：使用new创建异常、使用throw抛出异常、打印异常调用链\n\n使用new创建异常\n\n在堆上创建异常对象，初始化成员变量\n\n调用异常父类Throwable中的fillInStackTrace()函数生成栈追踪信息\n\n栈追踪信息：当创建异常时函数调用栈中的所有函数的信息，栈追踪信息记录了异常产生的整个函数调用链路，方便开发者定位此异常是如何产生的\n\nfillInStackTrace()函数所做的工作就是遍历函数调用栈，将每个函数的信息存入异常的stackTrace成员变量中，stackTrace成员变量的定义为：\nprivate StackTraceElement[] stackTrace;\npublic final class StackTraceElement implements java.io.Serializable &#123;\n    &#x2F;&#x2F; Normally initialized by VM (public constructor added in 1.5)\n    private String declaringClass;&#x2F;&#x2F;函数所属类名\n    private String methodName;&#x2F;&#x2F;函数名\n    private String fileName;&#x2F;&#x2F;函数所属类文件名\n    private int    lineNumber;&#x2F;&#x2F;异常抛出时，函数执行到了哪一行\n    &#x2F;&#x2F;...\n&#125;\n通过getStackTrace()函数，将异常的stackTrace栈追踪信息打印出来\nRuntimeException e &#x3D; new RuntimeException(&quot;oops&quot;);\nStackTraceElement[] stackTrace &#x3D; e.getStackTrace();\nfor(StackTraceElement element : stackTrace)&#123;\n    System.out.println(element);\n&#125;\n当总的函数调用层次过深时，fillInStackTrace()的耗时就相当可观了，这就是异常导致程序变慢的其中一个原因，所以在递归中不要轻易抛出异常\n\n\n\n\n\n使用throw抛出异常（）\n\nthrow new RuntimeException(&quot;oops&quot;)这样一个异常抛出代码包括两个操作：创建异常和抛出异常等价于下面的两行代码：\nRuntimeException e &#x3D; new RuntimeException(&quot;oops!&quot;);\nthrow e;\n当函数执行throw语句抛出异常时，JVM底层会执行栈展开（stack unwinding），依次将函数调用栈中的函数栈帧弹出，直到找到哪个函数可以捕获这个异常为止，然后JVM从这个函数继续再执行。\n\n相对于普通的函数返回（调用return语句）导致的栈帧弹出，调用throw导致的栈展开除了包含栈帧弹出之外，还增加了一个过程：在函数的异常表中查找是否有可匹配的处理规则。如果异常抛出之后，经过很多函数调用，最终才被捕获，那么查询这些函数的异常表的耗时就会比较多，这就是异常导致程序变慢的另一个原因。但是相比于创建异常来说，栈展开的耗时更小一些。因此，对于异常，应该遵守能捕获尽早捕获的开发原则，例如SpringAOP在程序的最外层捕获所有的异常，这样的做法增加了栈展开的耗时。\n\n\n\n打印异常调用链\n\n将异常封装成新的异常再抛出：\ntry&#123;\n    &#x2F;&#x2F;...\n&#125;catch(IOException e)&#123;\n    throw new RuntimeException(&quot;oops&quot;,e);\n&#125;\n\npublic class Throwable&#123;\n    private String detailMessage;\n    private Throwable cause &#x3D; this;&#x2F;&#x2F;异常调用\n    private StackTraceElement[] stackTrace &#x3D; UNASSIGNED_STACK;\n    \n    public Throwable(String message, Throwable cause) &#123;\n        fillInStackTrace();&#x2F;&#x2F;生成stackTrace\n        detailMessage &#x3D; message;\n        this.cause &#x3D; cause;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n一般在开发中使用日志框架来记录异常，异常调用链信息会输出到日志文件中，方便开发者事后查看，一般不推荐使用e.pringStackTrace()来打印异常日志，因为会打印到标准出错输出System.err中，即命令行中，这不方便保存以便反复查看。\ntry&#123;\n    &#x2F;&#x2F;...\n&#125;catch(IOException e)&#123;\n    log.error(&quot;...&quot;,e);\n    &#x2F;&#x2F;e.printStackTrace() 不推荐\n&#125;\n每个异常的stackTrace栈追踪消息都是一直到main函数的，不可以只记录生命周期内的函数，因为stackTrace栈追踪信息是在异常创建时生成的，在打印异常时，异常的声明周期未必就一定结束，所以无法只填充生命周期内所经历的函数。\n\n因为大多情况下都需要调用日志框架来打印异常调用链，把所有异常的栈追踪信息都打印出来，显然是比较耗时的\n\n\n\n\n8.异常最佳实践\n对于业务异常，没必要记录stackTrace栈追踪信息，只需要将一些有用的信息，记录在异常的detailMessage成员变量中即可，比如对于UserNotExistingException这个业务异常，只需要记录不存在的用户的ID即可。\n\n怎么创建不包含栈追踪信息的异常：Throwable有一个特殊的构造函数，可以用来禁止在创建异常的同时调用fillStackTrace()函数，只需要自定义异常时，调用父类Throwable的这个构造函数并且将writableStackTrace赋值为false即可。\nprotected Throwable(String message, Throwable cause,\n                    boolean enableSuppression,\n                    boolean writableStackTrace) &#123;\n    if (writableStackTrace) &#123;\n        fillInStackTrace();\n    &#125; else &#123;\n        stackTrace &#x3D; null;\n    &#125;\n    detailMessage &#x3D; message;\n    this.cause &#x3D; cause;\n    if (!enableSuppression)\n        suppressedExceptions &#x3D; null;\n&#125;\n&#x2F;&#x2F;使用，可以解决高并发下程序中大量业务异常导致的程序变慢的问题\npublic class UserNotExistingException extends Throwable&#123;\n    public UserNotExistingException() &#123;\n        super(null,null,true,false);\n    &#125;\n\n    public UserNotExistingException(String message) &#123;\n        super(message,null,true,false);    &#125;\n\n    public UserNotExistingException(String message, Throwable cause) &#123;\n        super(message,cause,true,false);\n    &#125;\n\n    public UserNotExistingException(Throwable cause) &#123;\n        super(null,cause,true,false);\n    &#125;\n&#125;\n\n8.IO1.io类库1.io类库整体结构\njava的I/O库包括io类库和nio类库，如下是java的io类库的总览\n\n\n使用规律：\n\n明确要操作的数据是数据源还是数据目的（要读还是要写）+要操作的数据是字节还是字符：\n输入（读）：InputStream （字节）、Reader（字符）\n输出（写）：OutputStream（字节）、Writer（字符）\n\n\n明确数据存在的具体设备：\n硬盘：文件File开头\n内存：数组(CharArrayxxx)、字符串(Stringxxx)、字节（ByteArrayxxx）\n键盘/屏幕：System.in、System.out、System.err\n网络：Socket\n管道：Pipedxxx\n\n\n明确是否需要额外的功能\n需要转换（字符流通向字符的桥梁）：InputStreamReader、OutputStreamWriter\n需要高效（缓冲流，用来包装别的类）：Bufferedxxx\n多个源（序列流）：SequenceInputStream\n保证数据的输出形式（打印流）：PrintStream、PrintWriter\n操作基本数据，保证字节原样性：DataOutputStream、DataInputStream\n\n\n\n\n\n2.输入流和输出流\n按照数据流向可以分为：\n\n输入流：InputStream、Reader\n将File、Network、标准输入System.in、管道中的数据输入到内存中。\n\n\n输出流：OutputStream、Writer\n将内存中的数据输出到File、Network、标准输出System.out和System.err、管道中\n\n\n\n\n使用方法\n&#x2F;&#x2F;输入流\ntry (InputStream inputStream &#x3D; new FileInputStream\n     (&quot;C:\\code\\AlgorithmLearning\\src\\main\\java\\ioLearning\\1.txt&quot;)) &#123;\n    byte[] data &#x3D; new byte[1024];\n    while (inputStream.read(data) !&#x3D; -1)&#123;\n        &#x2F;&#x2F;处理data数组\n    &#125;\n&#125; catch (FileNotFoundException e) &#123;\n    e.printStackTrace();\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n&#x2F;&#x2F;输出流\nOutputStream outputStream &#x3D; new FileOutputStream\n    (&quot;C:\\code\\AlgorithmLearning\\src\\main\\java\\ioLearning\\2.txt&quot;);\nbyte[] data &#x3D; new byte[1024];\noutputStream.write(data);\n\n3.字节流和字符流\n按照数据流的读写单位分为：\n字节流：InputStream、OutputStream\n一个字节一个字节的从输入流读取数据或者将数据写入输出流\n\n\n字符流：Reader、Writer\n一个字符一个字符的从输入流中读取数据或者将数据写入输出流\n\n\n\n\n字符流比字节流多了一个字符编码转换的环节\nJava中的char类型数据使用UTF-16编码，而文件的编码方式有可能是UTF-8、GBK等，所以，当从文件中读取数据到Java内存中的char数组时，我们需要将其从文件的编码方式转换为UTF-16编码方式，写入同理。\n\n\n\n4.原始库和装饰类库\njava.io类库的设计用到了设计模式中的装饰器模式，从这个角度，我们可以将java.io类库中的类分为原始类和装饰器类。\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n  void f();\n&#125;\npublic class A implements IA &#123;\n  public void f() &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class ADecorator implements IA &#123;\n  private IA a;\n  public ADecorator(IA a) &#123;\n    this.a &#x3D; a;\n  &#125;\n  \n  public void f() &#123;\n    &#x2F;&#x2F; 功能增强代码\n    a.f();\n    &#x2F;&#x2F; 功能增强代码\n  &#125;\n&#125;\n装饰器类是对原始类的增强，不能独立使用，使用方式如下\nInputStream in &#x3D; new FileInputStream(&quot;...&quot;);\nInoutStream bin &#x3D; new BufferedInputStream(in);\nbyte[] data &#x3D; new byte[1024];\nwhile(bin.read(data) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;处理data数组\n&#125;\n\n5.原始类分类介绍\n文件：跟文件读写相关的类有：FileInputStream、FileOutputStream、FileReader、FileWriter\n\n网络：\n\njava.io类库并没有提供专门的类用于网络I/O的读写，而是直接复用InputStream类、OutputStream类进行网络I/O的读写。除此之外，还需要java.net类库的配合，java.net类库用来管理网络连接，比如创建连接、关闭连接、监听连接等。java.io类库中只负责读写已经建立的网络连接，如下：\nSocket socket &#x3D; new Socket(&quot;127.29.2.4&quot;,8090);\nOutputStream out &#x3D; socket.getOutputStream();\nout.write(&quot;hi&quot;.getBytes());\n\nInputStream in &#x3D; socket.getInputStream();\nbyte[] data &#x3D; new byte[1024];\nwhile(in.read(data) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;do something\n&#125;\nInputStream、OutputStream是所有字节流类的父类，它既可以读写文件，也可以读写网路，还可以读写其它I/O，这充分体现了“抽象”的设计思想，尽管深入硬件层面，各个I/O设备的读写方式各不相同，但是，上层应用开发并不关心底层实现细节，大部分I/O设备的访问都可以抽象为打开、读、写、关闭等几个操作，因此，Java将所有的I/O设备都抽象为Stream（流），并未不同的I/O设备的读写设计了一套统一的接口，从而对于不同I/O设备的读写，我们可以用同样的代码实现，代码更加统一、简洁。\n\n\n\n内存\n\n跟内存读写相关的类有：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter、StringReader、StringWriter\n\n在大部分情况下，我们都不需要这种内存读写类，直接对byte数组，char数组进行读写即可，没必要将它们封装成流来操作，使用情景如下：\n\n实现兼容：例如，当调用第三方类库中的某个函数来处理byte数组中的数据时，但这个函数的入参是InputStream类型的，那么就需要将待处理byte数组封装成ByteArrayInputStream对象，在传递给这个函数\nbyte[] source &#x3D; &quot;测试数据&quot;.getBytes();\nInputStream in &#x3D; new ByteArrayInputStream(source);\n&#x2F;&#x2F;用in代替source继续处理\n在编写单元测试时，这些内存读写类也非常有用，可以替代文件或网路，将测试数据内置于内存，准备起来更加容易，即可以直接在内存中构建测试数据\n&#x2F;&#x2F;待测试函数\npublic int readFromFIle(InputStream inputStream)&#123;...&#125;\n\n&#x2F;&#x2F;测试代码\npublic void test_readFromFile()&#123;\n    byte[] testData &#x3D; new byte[512];\n    &#x2F;&#x2F;构建测试数据，填入testData数组\n    InputStream in &#x3D; new ByteInputStream(testData);\n    int res &#x3D; readFromFile(in);\n    &#x2F;&#x2F;assert 判断返回值是否符合预期\n&#125;\n\n\n\n\n管道\n\n跟读写管道相关的类有：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter，不同于Unix中的管道（进程间通信），这里的管道是Java提供的为同一个进程内的两个线程之间通信的工具，一个线程通过PipedOutputStream写入的数据，另一个线程就可以通过PipedInputStream读取数据\n\n示例代码如下：\nPipedOutputStream out &#x3D; new PipedOutputStream();\ntry &#123;\n    PipedInputStream in &#x3D; new PipedInputStream(out);\n    new Thread(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            try &#123;\n                out.write(&quot;Hi Dajunnnnnn&quot;.getBytes());\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;).start();\n    new Thread(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            byte[] buffer &#x3D; new byte[512];\n            try &#123;\n                in.read(buffer);\n                System.out.println(new String(buffer));\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;).start();\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n\n\n标准输入输出：\n\n操作系统中，一般会有三个标准I/O系统：标准输入、标准输出、标准错误输出。\nSystem.in是一个定义在System类中的静态InputStream对象\nSystem.out和System.err都是定义在System类中的PrintStream对象。PrintStream为装饰器类，需要嵌套OutputStream来使用，支持按照格式输出数据（System.err显示的字符串为红色，以表示出错）\n\n\n\n\n\n6.装饰器类分类介绍\n支持读写缓存功能的装饰器类\n\n主要有BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter\n对比InputStream，BufferedInputStream会在内存中维护一个8192字节大小的缓存，如果缓存中没有足够的数据，那么read()函数会从I/O设备中读取8192个字节存储到缓存中，然后read()函数再从缓存中返回需要的数据量。如果缓存中有足够多的数据，read()函数直接从缓存中读取数据，而不会触发真正I/O操作，可以减少I/O操作的次数，但是如果每次请求的数据量大于等于8192字节，那么BufferedInputStream就不起作用了。\n同理OutputStream用于缓存写入I/O设备中的数据，当积攒到一定量（默认为8192字节），再一次性将其写入I/O设备，减少I/O操作的次数，提高程序的性能。\n\n\n支持基本类型数据读写的装饰器类\n\nDataInputStream支持将输入流中读取的数据解析为基本类型（byte、char、short、int、float、double等），DataOutputStream类支持将基本类型数据转化为字节数组写入输出流。\n\n示例代码：\nDataOutputStream out &#x3D; new DataOutputStream(new FileOutputStream(&quot;...&quot;));\nout.writeInt(12);\nout.writeChar(&quot;a&quot;);\nout.writeFloat(12,12f);\nout.close();\n\nDataIntputStream in &#x3D; new DataInputStream(new FileInputStream(&quot;...&quot;));\nSystem.out.println(in.readInt());\nSystem.out.println(in.readChar());\nSystem.out.println(in.readFloat());\nin.close();\nreadChar()、writeChar()也可以按字符为单位读取、写入数据，但是，DataInputStream一次只能处理一个字符，而字符流可以处理char数组，并且字符流提供的函数更多，功能更丰富\n\n\n\n支持对象读写的装饰器类：\n\nObjectInputStream支持将从输入流中读取到的数据反序列化为对象，ObjectOutputStream支持将对象序列化之后写入到输出流\n\n示例代码：\nObjectOutputStream out &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;.&quot;));\nout.writeObject(new Person(12,&quot;Dajunnnnnn&quot;));\n\nObjectInputStream in &#x3D; new ObjectInputStream(new FileInputStream(&quot;.&quot;));\nPerson p &#x3D; (Person) in.readObject();\n\n\n支持格式化打印数据的装饰器类:\n\nPrintStream和PrintWrite可以将数据按照一定的格式，转化为字符串，写入到输出流。前面讲到System.out、System.err就是PrintStream类型的\nPrintStream printStream &#x3D; new PrintStream(new FileOutputStream(&quot;..&quot;));\nprintStream.print(124);&#x2F;&#x2F;int-&gt;Integer-&gt;toString(),写入字符串“124”\nprintStream.print(&quot;hello %d&quot;,43);&#x2F;&#x2F;写入字符串“hello 43”\n\n\n除了以上装饰器类之外，还有一组原始类，其功能非常类似装饰器类，那就是InputStreamReader、OutputStreamWriter。InputStreamReader可以充当InputStream的装饰器类，OutputStreamWriter可以充当OutputStream的装饰器类。它们可以将字节流转化为字符流。示例代码如下所示。从这一点上，我们也可以看出，java.io类库的设计有很多不合理的地方，更晚开发的java.nio类库在设计上明显要合理很多。\nOutputStream outStream &#x3D; new FileOutputStream(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;a.txt&quot;);\nOutputStreamWriter writer &#x3D; new OutputStreamWriter(outStream, &quot;gbk&quot;);\nwriter.write(&quot;王a争&quot;); &#x2F;&#x2F;按照gbk编码将字符串写入文件\n\n2.nio类库1.java.nio类库\nJDK1.4引入，也称：New I/O、Non-blocking I/O、Network I/O。一般情况使用java.io，在网络编程中大多使用java.nio\n\njava.io中所有的I/O都抽象为Stream，java.nio中引入Channel代替Stream，并且引入新的概念：Buffer，用来存储待写入或读取的数据\nFileChannel channel &#x3D; FileChannel.open(Paths.get(&quot;...&quot;));\nByteBuffer buffer &#x3D; ByteBuffer.allocate(512);\nwhile(channel.read(buffer) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;处理buffer中的数据data\n&#125;\n核心概念\n\nBuffer：\n\n本质上就是一块内存，就相当于java.io申请的byte数组，常见的Buffer有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer、MappedByteBuffer，不同之处在于解析数据的方式不同\njava.io有字节流解析和字符流解析，java.nio将这些部分抽取出来，独立到Buffer类中，不同的Channel跟不同的Buffer组合在一起，可以实现不同的IO读写需求。\n\n\n同步Channel：\n\n常用的Channel有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel用于文件读写，其余三个用于网络编程，其中DatagramChannel用于读写UDP数据，SocketChannel和ServerSocketChannel用于读写TCP数据，ServerSocketChannel用于服务器编程，可以使用accept()函数监听客户端SocketChannel的连接请求。\njava.nio中的Channel即可以读也可以写，每个Channel类通过实现不同的接口组合，来支持不同的功能组合\nChannel有两种运行方式：阻塞和非阻塞方式，其中除FileChannel只支持阻塞模式外，其余三个都同时支持两种方式，默认为阻塞方式，可以调用configureBlocking(false)函数将其设置为非阻塞模式，非阻塞Channel一般会配合Selector，用于实现多路复用I/O模型。\n阻塞模式与非阻塞模式：线程在调用read()或write()函数对I/O进行读写时，如果I/O不可读或者不可写（待会解释这两个的意思），那么，在阻塞模式下，read()或write()函数会等待，直到读取到数据或者写入完成时才会返回，在非阻塞模式下，read()或write()函数会直接返回，并报告读取或写入未成功。\n\n\n\n\nSelector：\n\n在网络编程中，使用非阻塞模式，线程需要通过while循环，不停轮询调用read()、write()、accept()函数，查看是否有数据可读，是否可写，是否有客户端连接到来\nSeverSocketChannel serverChannel &#x3D; ServerSocketChannel.open();\nserverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,1192));\nserverChannel.configureBlocking(false);\nByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n\nSocketChannel clinetChannel &#x3D; null;\nwhile(clinetChannel &#x3D;&#x3D; null)&#123;\n    clientChannel &#x3D; serverChannel.accept();\n&#125;\n\nwhile(clientChannel.read(buffer) &#x3D;&#x3D; -1);\n\nbuffer.flip();&#x2F;&#x2F;将buffer从用于读变成用于写\nwhile(buffer.hasRemaining())&#123;\n    clientChannel.write(buffer);&#x2F;&#x2F;echo,读了啥就写啥\n&#125;\n多路复用I/O用来解决while轮询的问题，为了实现多路复用，Unix提供了epoll库、Windows提供了iocp库、BSD提供了kequeue库，Java作为一种跨平台语言，对不同操作系统的实现进行了封装，提供了统一的Selector，可以将需要监听的Channel，调用registor()函数，注册到Selector中，Selector底层会通过轮询的方式，查看哪些Channel可读、可写、可连接等，并将其返回处理。\n\n\n\n异步Channel：\n\n尽管使用Selector可以避免开发者手写轮询代码，但是Selector底层仍然依赖轮询来实现，在JDK7中，java.nio类库做了升级，引入了支持异步模式的Channel，主要包括：AdynchronousFileChannel、AsynchronousSocketChannel、AsynchronousServerSocketChannel\n在异步模式下，Channel不再注册到Selector，而是注册到操作系统内核中，由内核来通知某个Channel可读、可写或可连接，java.nio收到通知之后，为了不阻塞主线程，会使用线程池去执行事先注册的回调函数。\n\n\n\n\n\n2.Java IO模型（网络）\n阻塞I/O模型（BIO）\n\n利用阻塞模式搭配多线程来实现服务器，因为服务器需要连接大量客户端，因为read()函数是阻塞函数，所以，为了实现接受客户端发来的数据，服务器需要创建大量线程，每个线程负责等待读取一个客户端的数据。因为java.io支持阻塞模式，java.nio既支持阻塞模式也支持非阻塞模式，所以都可以实现阻塞I/O模型。\n\n示例代码：如果有n个客户端连接服务器，那么服务器需要创建n+1个线程，其中n个线程用于调用read()函数，除此之外，因为accept()函数也是阻塞函数，所以也独占一个线程。当连接的客户端非常多时，服务器需要创建大量线程，而每个线程会分配一个线程栈，需要占用一定的内存空间。当线程比较多时，内存资源的消耗就会比较大。大量线程来回切换，什么都不做但又要白白占用内存和线程资源，非常浪费。\npublic class BioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket serverSocket &#x3D; new ServerSocket();\n        serverSocket.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        while (true) &#123;\n            &#x2F;&#x2F; accept()为阻塞函数，直到有连接到来才返回\n            Socket clientSocket &#x3D; serverSocket.accept();\n            &#x2F;&#x2F; 为了每个客户端单独创建一个线程处理\n            new Thread(new ClientHandler(clientSocket)).start();\n        &#125;\n    &#125;\n\n    private static class ClientHandler implements Runnable &#123;\n        private Socket socket;\n        public ClientHandler(Socket socket) &#123;\n            this.socket &#x3D; socket;\n        &#125;\n\n        @Override\n        public void run() &#123;\n            byte[] data &#x3D; new byte[1024];\n            while (true) &#123; &#x2F;&#x2F;持续接收客户端发来的数据\n                try &#123;\n                    &#x2F;&#x2F; read()为阻塞函数，直到读取到数据再返回\n                    socket.getInputStream().read(data);\n                    &#x2F;&#x2F; write()为阻塞函数，全部写完成才会返回\n                    socket.getOutputStream().write(data); &#x2F;&#x2F;echo\n                &#125; catch (IOException e) &#123;\n                    &#x2F;&#x2F; log and exit\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n非阻塞I/O模型（NIO）\n\n非阻塞模型利用非阻塞模式和Selector多路复用器来开发服务器，也叫做多路复用I/O模型\n\n示例代码\npublic class NioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F; Selector\n        Selector selector &#x3D; Selector.open();\n\n        &#x2F;&#x2F; create serverChannel and register to selector\n        ServerSocketChannel serverChannel &#x3D; ServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        serverChannel.configureBlocking(false);\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n        while (true) &#123;\n            int channelCount &#x3D; selector.select();\n            if (channelCount &gt; 0) &#123;\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n                Iterator&lt;SelectionKey&gt; iterator &#x3D; keys.iterator();\n                while (iterator.hasNext()) &#123;\n                    SelectionKey key &#x3D; iterator.next();\n                    if (key.isAcceptable()) &#123;\n                        &#x2F;&#x2F; create clientChannel and register to selector\n                        SocketChannel clientChannel &#x3D; \n                            serverChannel.accept();\n                        clientChannel.configureBlocking(false);\n                        clientChannel.register\n                            (selector, SelectionKey.OP_READ);\n                    &#125; else if (key.isReadable()) &#123;\n                        SocketChannel clientChannel &#x3D; \n                            (SocketChannel) key.channel();\n                        clientChannel.read(buffer);\n                        buffer.flip(); &#x2F;&#x2F;从&quot;用于读&quot;变为&quot;用于写&quot;\n                        if (buffer.hasRemaining())&#123;&#x2F;&#x2F;也可以注册到selector中\n                            clientChannel.write(buffer); &#x2F;&#x2F;echo\n                        &#125;\n                        buffer.clear(); &#x2F;&#x2F;重复利用\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n在NioEchoServer类中，如果有n可客户端连接服务器，那么就会创建n+1个Channel，其中一个serverChannel用于接受客户端的连接，另外n个clientChannel用于与客户端进行通信。这n+1个Channel均注册到Selector中。Selector会间隔一定时间轮训这n+1个Channel，查找可连接、可读、可写的Channel，然后再进行连接、读取、写入操作。\n\n大部分情况下，我们都不需要监听Channel是否可写，毕竟网络写入跟文件写入类似，大部分情况下都不需要等待。只有当写入出现问题时，比如write()函数返回0，表示网络拥塞，此时才需要如下代码所示，将Channel注册到Selector中，等待可写。\nclientChannel.register(selector, SelectionKey.OP_WRITE);\n只有实现了SelectableChannel接口的Channel才可以注册到Selector中被监听，比如DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel无法被Selector监听\n\n多路复用I/O模型：只需要一个线程即可，解决了阻塞I/O模型线程开销大的问题。但是如果某些clientChannel耗时比较久，那么其它clientChannel便需要阻塞，使得服务器响应的延迟变高，但可以用过线程池中取线程来处理，而不是所有的clientChannel都在一个线程中处理。跟非阻塞I/O的区别在于不管有没有数据可读，阻塞I/O模型中的每个clientSocket都会一直占用线程。而这里的多线程只会处理经过Selector筛选之后有可读数据的clientChannel，并且处理完之后就释放回线程池，线程的利用率更高。\n\n\n\n异步I/O模型（AIO）\n\n通过异步Channel调用accept()、read()、write()函数。当有连接建立、数据读取完成、数据写入完成时，底层会通过线程池执行对应的回调函数。这种服务器的实现方式叫做异步I/O模型。\n\n示例代码\npublic class AioEchoServer &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        AsynchronousServerSocketChannel serverChannel &#x3D; AsynchronousServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        &#x2F;&#x2F; 异步accept()\n        serverChannel.accept(null, new AcceptCompletionHandler(serverChannel));\n        Thread.sleep(Integer.MAX_VALUE);\n    &#125;\n\n    private static class AcceptCompletionHandler\n        implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;\n        private AsynchronousServerSocketChannel serverChannel;\n        public AcceptCompletionHandler(AsynchronousServerSocketChannel serverChannel) &#123;\n            this.serverChannel &#x3D; serverChannel; \n        &#125;\n\n        @Override\n        public void completed(AsynchronousSocketChannel clientChannel, Object attachment) &#123;\n            &#x2F;&#x2F; in order to accept other client&#39;s connections\n            serverChannel.accept(attachment, this);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n            &#x2F;&#x2F; 异步read()\n            clientChannel.read(buffer, buffer, new ReadCompletionHandler(clientChannel)); \n        &#125;\n\n        @Override\n        public void failed(Throwable exc, Object attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n\n    private static class ReadCompletionHandler \n        implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private AsynchronousSocketChannel clientChannel;\n        public ReadCompletionHandler(AsynchronousSocketChannel clientChannel) &#123;\n            this.clientChannel &#x3D; clientChannel;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer buffer) &#123;\n            buffer.flip();\n            &#x2F;&#x2F; 异步write()。回调函数为null，写入完成就不用回调了\n            clientChannel.write(buffer, null, null); &#x2F;&#x2F; echo\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n&#125;\n实际上，在平时的开发中，我们一般不会直接使用底层的ava.nio类库，而是使用Netty等框架来进行网络编程，这些框架封装了网络编程的复杂性，使用起来更加简单，开发效率更高。除了以上三种常见的I/O模型之外，实际上，还有更多更加复杂的I/O模型，比如Netty框架提供的Reactor模型。\n\n在《Unix网络编程》一书中，介绍了Unix操作系统的5种I/O模型：阻塞I/O模型、非阻塞I/O模型、多路复用I/O模型、信号驱动I/O模型、异步I/O模型。实际上，不同的操作系统会提供不同的I/O模型。Java是一种跨平台语言，为了屏蔽各个操作系统I/O模型的差异，设计了3种新的I/O模型：BIO（阻塞I/O）、NIO（非阻塞I/O）、AIO（异步I/O），并且提供了I/O类库来支持这3种I/O模型的代码实现。而Java的I/O类库底层需要依赖操作系统的I/O接口（专业名称为系统调用）来实现，因此，从本质上来讲，Java I/O模型只是对操作系统I/O模型的重新封装。\n\n\n\n\n3.对比java.io与java.nio\n按照喜好或者团队的编程习惯来选择\n对于网络编程，首选java.nio，对于文件读写，java.io和java.nio都可以\n\n3.文件（高速I/O）1.用户态和内核态\n系统调用：操作系统内核包含各种操作硬件资源的系统调用，应用程序必须通过操作系统提供的系统调用才能访问硬件资源\n库函数：系统调用比较底层，所以Linux又提供了库函数，比如Glibc库、Posix库，对系统调用进行封装，提供更加简单易用的函数，供应用程序开发使用，比如：Glibc中的malloc()函数封装了sbrk()系统调用，fread()、fwrite()封装了read()、write()系统调用，在开发应用程序的时候，既可以使用库函数，也可以直接使用系统调用\nShell：Linux还提供了Shell这一程序，即命令行，Shell能在不进行编程的情况下，通过命令行中运行Shell命令或脚本，达到访问硬件的目的，比如cp拷贝文件、rm删除文件\n用户态&amp;内核态：为避免应用程序在运行时，访问到内核所用的内存空间，操作系统将虚拟内存分为内核空间和用户空间两部分，CPU因此有内核态和用户态两种，在内核态CPU拥有最高权限，可以执行所有的机器指令并且可以访问硬件，而且内核态能访问所有虚拟内存空间，在用户态则不能。\n上下文切换：当应用调用操作系统的系统调用时，会涉及内核态与用户态的上下文切换，主要耗时的操作有：\n寄存器保存与恢复耗时：因为内核空间不使用应用程序的函数调用栈，会分配新的函数调用栈，所以在上下文切换时需要更新更多栈相关的寄存器，比如SS栈基址寄存器。除此之外，应用程序和内核程序的代码存储位置也不同，CS代码段基址寄存器也需要更新。并且更新前会保存下来原始值，以便切换回用户态之后恢复执行\n缓存失效带来的性能损耗：CPU有L1、L2、L3三级Cache，用于缓存将要执行的代码以及所需的内存数据，上下文切换会导致CPU缓存失效\n\n\n\n2.I/O读写的底层实现原理\nLinux操作系统下，Java的I/O类库调用open()、read()、write()系统调用来实现，通过open()返回Linux下I/O设备的文件描述符，来和I/O设备建立连接\n操作系统为每个文件描述符都分配一个内核读缓存区和一个内核写缓存区，内核读写缓存区只有在第一次调用read()或write()系统调用时，才会真正被分配内存空间。默认读缓冲区的大小为8192字节，写缓冲区的大小为16384字节。当然，也可以根据业务需求，通过系统调用，来重新设置\n在读写完成后需要调用close()系统调用\nLinux下读写文件的C语言代码实现如下，数据会先被放到内核读写缓存区，读缓冲区不够时才会从磁盘读取文件，写缓冲区满时才会写入到磁盘中（如果想立刻存入磁盘则需要调用sync()系统调用），这样做的原因是应用程序缓存区是应用程序维护的，内核代码无法控制其大小和生命周期，出于稳妥起见才申请了内核缓冲区，而且可以减少与I/O设备的交互次数\n\n&#x2F;&#x2F;Linux下读写文件的C语言代码实现\n#include &lt;stdio.h&gt;\n#include stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys&#x2F;types.h&gt;\n#include &lt;sys&#x2F;stat.h&gt;\n#include &lt;fcntl.h&gt;\nint main (int argc, char *argv)&#123;\n    int rfd;\n    int wfd;\n    int nbytes;\n    char rfile[]&#x3D; &quot;&#x2F;users&#x2F;root&#x2F;in.txt&quot;;\n    char wfile[]&#x3D; &quot;&#x2F;users&#x2F;rootout.txt&quot;;\n    char buffer[256];&#x2F;&#x2F;应用程序缓冲区\n    rfd &#x3D; open(rfile, O_RDONLY,0666);\n    wfd &#x3D; open(wfile, o_CREAT | O_WRONLY, 0666);\n    if(rfd &lt; 0 || wfd &lt; 0)&#123;\n        printf(&quot;open file failed!\\n&quot;);\n        return -1;\n    &#125;\n    while((nbytes &#x3D; read(rfd, buf, 255)) &gt; 0)&#123;\n        write(wfd, buffer, nbytes);\n    &#125;\n    close(rfd);\n    close(wfd);\n    return 0;\n&#125;\n\n\n\n3.CPU减负神器之DMA技术\nDMA(Direct Memory Access）技术：通过在主板上安装一个叫做DMAC (DMA Controller，DMA控制器)的协处理器(或叫芯片)，协助CPU来完成I/O设备的数据读写工作。随着计算机的发展，安装在计算机上的I/O设备越来越多，仅在主板上安装一个通用的DMAC已经远远不够了，因此，现在很多IO设备都自带DMAC，比如硬盘、网卡、显示器都有各自的DMAC。\n工作原理：DMAC替代CPU从设备中读取数据或向设备写入数据，通过中断通知CPU，CPU利用率提高了\n\n4.mmap\nmmap（memory-mapped file，内存映射文件）是提高文件读写性能的有效技术，mmap一般用于文件，像网络这种数据未知的I/O设备，不适合使用mmap。\n&#x2F;&#x2F;java.nio.FileChannel类中\npublic MappedByteBuffer map(MapMode mode , long position, long size);\n前置知识：操作系统记录物理内存跟虚拟内存之间的映射关系，这样每个进程只需要操作虚拟内存地址即可。并且因为并不是将整个程序加载到物理内存再执行，所以如果待执行的代码没有在物理内存中，就会向操作系统发出一个缺页中断，操作系统会将带执行的代码从磁盘加载到物理内存，并会将不再执行的代码置换出物理内存\n\n底层原理：通过将文件或文件中的某段映射到用户空间中的某段虚拟内存地址上，如果没加载到物理内存，则触发缺页中断；如果有脏页，操作系统自动写回磁盘或者调用msync()立即写回\nint main(void)&#123;\n    char file &#x3D; &quot;&#x2F;users&#x2F;root&#x2F;in.txt&quot;;\n    int fd &#x3D; open(file, O_RDWR,0666);\n    if(fd &lt;0)&#123;\n        printf(&quot;open file failedl\\n&quot;);\n        return -1;\n    &#125;\n    &#x2F;&#x2F;映射文件开头(offset&#x3D;0)的512字节(length&#x3D;512)到ptr\n    size_t length &#x3D; 512;\n    int offset &#x3D; 0;\n    char *ptr &#x3D; mmap(null, length, PROT_READn| PROT_WRITE, MAP_SHARED, fd , offset);\n    if (ptr &#x3D;&#x3D; MAP_FAILED)&#123;\n        printf(&quot;mmap failed.&quot;);\n        return -1;\n    &#125;\n    &#x2F;&#x2F;创建好内存映射文件之后，fd就没用了，可以释放了\n    close(fd);\n    \n    &#x2F;&#x2F;操作ptr就等同于读写文件\n    for (int i &#x3D; 0; i &lt; length; i++)&#123;\n        ptr[i] &#x3D; &#39;a&#39; +(length%26);\n    &#125;\n\n    for (int i &#x3D; 0; i &lt;N, i++)&#123;\n        printf(&quot;%c&quot;,ptr[i]);\n    &#125;\n    &#x2F;&#x2F;删除内存映射文件，释放占用的虚拟内存空间\n    munmap(ptr, length);\n    return 0;\n&#125;\nmmap相当于直接将数据在磁盘和用户空间之间互相拷贝，相对于使用read()、write()系统调用读写文件，数据拷贝次数由2次减少为1次，并且减少了内核态和用户态上下文切换的耗时，之后读写文件就像读写内存一样\n\n对于少量文件读写，使用read()、write()更合适，对于大文件的读写，一般使用mmap，并且需要一些测试来验证性能。进程间通信当两个应用程序都采用MAP_SHARED模式创建匿名的内存映射文件时，这两个应用程序会共享物理内存，一个应用程序可以读取另一个程序写入物理内存的数据，以此来实现互相通信\nchar* ptr &#x3D; mmap(NULL,length,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANONYMOUS,-1,0);&#x2F;&#x2F;fd &#x3D; -1 \n\n5.零拷贝\nmmap主要用于文件的读写这一应用场景，而零拷贝（Zero-copy）技术主要用于两个I/O设备之间互相传输数据，特别是将文件中的数据发送到网络或者将从网络接受的数据存储到文件这一场景中\n&#x2F;&#x2F;java.nio.FileChannel\npublic abstract long transferTo(long position,long count WritableByteChannel target);\npublic abstract long transferFrom(ReadableByteChannel src, long position,long count);\n零拷贝不需要将数据拷贝到应用程序缓冲区，而是直接从内核读缓冲区拷贝到内核写缓冲区，应用程序只需要进行一次系统调用（执行sendfile()），接可以将文件发送到网络。\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys&#x2F;sendfile.h&gt;\n#include &lt;sys&#x2F;stat.h&gt;\n#include sys&#x2F;types.h&gt;\nint main (int argc, char*argv[)&#123;\n    int read_fd;\n    int write_fd;\n    struct stat stat_buf;\n    off_t offset &#x3D; o;\n    read_fd &#x3D; open (argv[1],O_RDONLY);\n    fstat (read_fd, &amp;stat_buf) ;\n    write_fd &#x3D; open (argv[2],O_WRONLY \\ O_CREAT, stat_buf.st_mode);\n    sendfile (write_fd, read_fd, &amp;offset, stat_buf.st_size);\n    close(read_fd);\n    close (write_fd);\n    return 0;\n&#125;\nSG-DMAC（Scatter-Gatter DMA Controller）使得零拷贝再少1次数据拷贝\n\n\n9.特殊语法1.泛型1.为什么使用泛型\n泛型语法：可以编写出更通用的代码，而且可以提前在编译时做类型检查，保证类型的安全性\npublic class Stack&lt;E&gt; &#123;\n    private Object[]arr;&#x2F;&#x2F;这里不是T[arr;原因稍后解释\n    private int top;\n    private int size;\n    \n    public Stack(int size) &#123;\n        this.arr &#x3D; new Object[size];\n        this.size &#x3D; size,\n        this.top &#x3D; o;\n    &#125;\n    public void push(E elem) &#123;\n        if (top &#x3D;&#x3D; size) return;\n        arr[top++] &#x3D; elem;\n    &#125;\n    public E pop() &#123;\n        if (top &#x3D;&#x3D; 0) return null;\n        return (E) arr[--top];\n    &#125;\n&#125;\n\n2.泛型的基本用法\n使用方式\n\n尖括号内表示类型参数：E（容器中的元素的类型参数）、T（非容器元素的数据类型参数）、K,V（键值对中键和值的类型参数）、N（数字类型参数）\n使用extends上界限定符，例如&lt;T extends Person&gt;，必须传入Person或者其子类\n没有implements，例如&lt;T extends Closable&gt;，表示限定传入类型参数的具体类型必须实现了Closable接口\n\n&#x2F;&#x2F;泛型接口\npublic interface List&lt;E&gt; &#123;\n    void add(E element);\n    E get(int index);\n    &#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;泛型类\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    private Object[]arr;&#x2F;&#x2F;这里不是T[]arr;原因稍后解释\n    public void add(E element) &#123; ...&#125;\n    public E get(int index) &#123; ...&#125;\n\t&#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F;泛型方法\npublic class Collections &#123;\n    public static &lt;T&gt; int binarySearch(List&lt;T&gt; list, T key);\n    &#x2F;&#x2F;...\n&#125;\n\n\n3.泛型中的通配符（?）\n通配符跟类型参数的应用场景并不相同，类型参数一般用于定义泛型类、泛型接口和泛型方法，而通配符跟Integer、Person、String这些具体类型无异，用来具体化泛型类或泛型接口，可以看做一种特殊的具体类型。当我们在具体化某个泛型类或泛型接口，但又无法指明明确的具体类型时，我们就可以使用通配符这种特殊的具体类型\npublic class Collections&#123;\n    &#x2F;&#x2F; 不需要有类型参数声明\n    public static void reverse(List&lt;?&gt; list)&#123;...&#125;\n    &#x2F;&#x2F; 泛型方法\n    &#x2F;&#x2F; public static &lt;T&gt; void reverse(List&lt;T&gt; list)&#123;...&#125;\n&#125;\n&lt;? extends Person&gt;或&lt;T extends Person&gt;，extends上界限定符可用于类型参数或者通配符，表示传入通配符是Person或者Person的子类\n\n&lt;? super Person&gt;，super下界限定符只用于通配符，表示传入通配符是Person或者Person的父类\n\n&lt;? extends T&gt;或&lt;? super T&gt;，通配符可以extends或super类型参数，但类型参数不可以etends或super类型参数\n\n\n4.泛型中的类型擦除\n底层原理：泛型只不过是一个语法糖，在编译时，编译器会使用泛型做类型检查，但是，当代码编译为字节码之后，泛型中的类型参数和通配符统统替换成上界，比如&lt;T&gt;替换为Object，&lt;T extends String&gt;替换为String，这种实现方式叫做类型擦除\n因为Java泛型的类型擦除，不能使用new T()来创建类型参数对象，在代码编译成字节之后类型信息已经擦除，所以，在运行时，JVM无法确定具体类型，也就无法知道T是否存在无参构造函数，所以也就无法使用new来创建T对象了，这也是为什么前面实现Stack泛型类中使用Object来定义arr数组的原因。\n因为需要继承自Object，所以基本类型不可以传入类型参数，只有引用类型可以。但是有语法糖可以让List&lt;int&gt;中的int替换为Integer，但是开发上依旧需要为每个基本类型分别定义多个不同的函数接口\n\n2.反射1.反射的作用\n创建对象：\n一般使用new语句来创建对象，但是如果想要在代码的运行过程中，根据配置、输入、执行结果等，动态创建一些额外的对象，这个时候就需要用到反射动态地告知JVM去创建某个类的对象\n不管是new还是反射，对象的创建都是在运行时进行的，不过申请创建对象的时机却是不同的。通过new来创建对象，其创建对象的需求是在代码编写时确定的（静态申请对象创建）；而通过反射来创建对象，其创建对象的需求是在运行时确定的（动态申请对象创建）\n\n\n执行方法：除动态申请对象创建之外，程序还可以动态申请执行方法。一般程序会执行哪些方法都是在代码编写的时候确定的；但是在运行时，额外申请新的要执行的方法就需要靠反射来实现（动态代理就是依赖反射动态执行方法来实现的）\n区别：不管是反射创建对象还是执行方法，跟普通的对象创建和方法执行，本质上没有太大区别，只不过是告知JVM的时机和方式不同而已\n获取类信息：除了创建对象、执行方法之外，反射还能够获取对象的类信息，包括类中的构造函数、方法、成员变量。（注解就是依赖反射的这个作用）\n\n2.反射的用法\nClass类\n\n与class关键字无关，是一个存储类的信息的特殊的类，提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等\n\n获取类信息主要方法如下\n&#x2F;&#x2F;获取类信息\npublic static Class&lt;?&gt; forName(String className);\n\n&#x2F;&#x2F;获取类名\npublic String getName();\npublic String getSimpleName();\n&#x2F;&#x2F;获取父类信息\npublic native Class&lt;? super T&gt; getSuperclass();\n&#x2F;&#x2F;获取package信息\npublic Package getPackage();\n\n&#x2F;&#x2F;获取接口信息\npublic Class&lt;?&gt;[]getlnterfaces();\n\n&#x2F;&#x2F;获取成员的变量，包含私有成员变量，不包含父类成员变量\npublic Field[] getDeclaredFields();\npublic Field getDeclaredField(String name);\n&#x2F;&#x2F;获取成员变量，只包含公有成员变量，包含父类成员变量\npublic Field[] getFields();\npublic Field getField(String name);\n&#x2F;&#x2F;获取类的方法，包括私有方法，不包含父类方法\npublic Method[] getDeclaredMethods();\npublic Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);\n&#x2F;&#x2F;获取类的方法，只包含公有方法，包含父类方法\npublic Method getMethods();\npublic Method getMethod(String name,Class&lt;?&gt;...parameterTypes);\n\n&#x2F;&#x2F;获取构造函数，只包含公共构造函数\npublic Constructor&lt;?&gt;[]getConstructors();\npublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);\n&#x2F;&#x2F;获取构造函数，包含私有构造函数\npublic Constructor[] getDeclaredConstructors();\npublic Constructor getDeclaredConstructor(Class... parameterTypes);\n\n&#x2F;&#x2F;获取类上的注解\npublic Annotation[] getAnnotations();\n\n\n使用方法：\npackage com.ys.reflex;\npublic class Person &#123;\n    &#x2F;&#x2F;私有属性\n    private String name &#x3D; &quot;Tom&quot;;\n    &#x2F;&#x2F;公有属性\n    public int age &#x3D; 18;\n    &#x2F;&#x2F;构造方法\n    public Person() &#123;\n    &#125;\n    &#x2F;&#x2F;私有方法\n    private void say()&#123;\n        System.out.println(&quot;private say()...&quot;);\n    &#125;\n    &#x2F;&#x2F;公有方法\n    public void work()&#123;\n        System.out.println(&quot;public work()...&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;1、通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object\n&#x2F;&#x2F;  类型的对象，而我不知道你具体是什么类，用这种方法\nPerson p1 &#x3D; new Person();\nClass c1 &#x3D; p1.getClass();\n\n&#x2F;&#x2F;2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高\n&#x2F;&#x2F;  这说明任何一个类都有一个隐含的静态成员变量 class\nClass c2 &#x3D; Person.class;\n\n&#x2F;&#x2F;3、通过 Class 对象的 forName() 静态方法来获取，用的最多，\n&#x2F;&#x2F;   但可能抛出 ClassNotFoundException 异常\nClass c3 &#x3D; Class.forName(&quot;com.ys.reflex.Person&quot;);\n\n&#x2F;&#x2F;获得类完整的名字\nString className &#x3D; c2.getName();\nSystem.out.println(className);&#x2F;&#x2F;输出com.ys.reflex.Person\n\n&#x2F;&#x2F;获得类的public类型的属性。\nField[] fields &#x3D; c2.getFields();\nfor(Field field : fields)&#123;\n    System.out.println(field.getName());&#x2F;&#x2F;age\n&#125;\n\n&#x2F;&#x2F;获得类的所有属性。包括私有的\nField [] allFields &#x3D; c2.getDeclaredFields();\nfor(Field field : allFields)&#123;\n    System.out.println(field.getName());&#x2F;&#x2F;name    age\n&#125;\n\n&#x2F;&#x2F;获得类的public类型的方法。这里包括 Object 类的一些方法\nMethod [] methods &#x3D; c2.getMethods();\nfor(Method method : methods)&#123;\n    System.out.println(method.getName());&#x2F;&#x2F;work waid equls toString hashCode等\n&#125;\n\n&#x2F;&#x2F;获得类的所有方法。\nMethod [] allMethods &#x3D; c2.getDeclaredMethods();\nfor(Method method : allMethods)&#123;\n    System.out.println(method.getName());&#x2F;&#x2F;work say\n&#125;\n\n&#x2F;&#x2F;获得指定的属性\nField f1 &#x3D; c2.getField(&quot;age&quot;);\nSystem.out.println(f1);\n&#x2F;&#x2F;获得指定的私有属性\nField f2 &#x3D; c2.getDeclaredField(&quot;name&quot;);\n&#x2F;&#x2F;启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消 java 语言的访问检查；反之不取消\nf2.setAccessible(true);\nSystem.out.println(f2);\n\n&#x2F;&#x2F;创建这个类的一个对象\nObject p2 &#x3D;  c2.newInstance();\n&#x2F;&#x2F;将 p2 对象的  f2 属性赋值为 Bob，f2 属性即为 私有属性 name\nf2.set(p2,&quot;Bob&quot;);\n&#x2F;&#x2F;使用反射机制可以打破封装性，导致了java对象的属性不安全。\nSystem.out.println(f2.get(p2)); &#x2F;&#x2F;Bob\n\n&#x2F;&#x2F;获取构造方法\nConstructor [] constructors &#x3D; c2.getConstructors();\nfor(Constructor constructor : constructors)&#123;\n    System.out.println(constructor.toString());&#x2F;&#x2F;public com.ys.reflex.Person()\n&#125;\n\n\n创建对象方法\n&#x2F;&#x2F;创建对象\npublic T newInstance();\n\n&#x2F;&#x2F;方法一：使用forName()+类名全称\n&#x2F;&#x2F;通过 Class 对象的 forName() 静态方法来获取，用的最多，\n&#x2F;&#x2F;但可能抛出 ClassNotFoundException 异常\nClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.wz.demo.Student&quot;);\n&#x2F;&#x2F;方法二：通过class属性，只用这一种方法可以不用通配符“？”，直接具体化Class类\n&#x2F;&#x2F;直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高\n&#x2F;&#x2F; 这说明任何一个类都有一个隐含的静态成员变量 class\nClass&lt;?&gt; clazz &#x3D; Student.class;\nClass&lt;Student&gt; clazz &#x3D; Student.class;\n&#x2F;&#x2F;方法三：通过getClass()方法\n&#x2F;&#x2F;通过对象调用 getClass() 方法来获取,通常应用在：\n&#x2F;&#x2F;比如你传过来一个 Object类型的对象，而我不知道你具体是什么类，用这种方法\nClass&lt;?&gt; clazz &#x3D; student.getClass();\n\n\nConstructor类\n\nConstructor用来存储构造函数的信息\n&#x2F;&#x2F;构造函数所包含的信息\n&#x2F;&#x2F;在Constructor中，以下信息都有相应的方法来获取\npublic final class Constructor&lt;T&gt; extends Executable &#123;\n    private Class&lt;T&gt;            clazz;\n    private int                 slot;\n    private Class&lt;?&gt;[]          parameterTypes;\n    private Class&lt;?&gt;[]          exceptionTypes;\n    private int                 modifiers;\n    &#x2F;&#x2F; Generics and annotations support\n    private transient String    signature;\n    &#x2F;&#x2F; generic info repository; lazily initialized\n    private transient ConstructorRepository genericInfo;\n    private byte[]              annotations;\n    private byte[]              parameterAnnotations;\n&#125;\n\n举例：newInstance()方法，通过newInstance()方法，可以调用构造函数来创建对象。Class类中的newInstance()方法只能无参构造；Constructor类对象可以使用newInstance()方法进行有参构造。\npublic T newInstance(Object ... initargs);\n\n\nMethod类\n\nMethod存储的是方法的信息\npublic final class Method extends Executable &#123;\n    private Class&lt;?&gt;            clazz;\n    private int                 slot;\n    &#x2F;&#x2F; This is guaranteed to be interned by the VM in the 1.4\n    &#x2F;&#x2F; reflection implementation\n    private String              name;\n    private Class&lt;?&gt;            returnType;\n    private Class&lt;?&gt;[]          parameterTypes;\n    private Class&lt;?&gt;[]          exceptionTypes;\n    private int                 modifiers;\n    &#x2F;&#x2F; Generics and annotations support\n    private transient String              signature;\n    &#x2F;&#x2F; generic info repository; lazily initialized\n    private transient MethodRepository genericInfo;\n    private byte[]              annotations;\n    private byte[]              parameterAnnotations;\n    private byte[]              annotationDefault;\n    private volatile MethodAccessor methodAccessor;\n&#125;\nMethod类也提供了大量方法来获取以上信息，例如invoke()方法，调用此方法可以执行对应方法\npublic Object invoke(Object obj, Object... args);\n\n\nField类\n\nField用来存储成员变量的信息\npublic final  class Field extends AccessibleObject implements Member &#123;\n    private Class&lt;?&gt;            clazz;\n    private int                 slot;\n    &#x2F;&#x2F; This is guaranteed to be interned by the VM in the 1.4\n    &#x2F;&#x2F; reflection implementation\n    private String              name;\n    private Class&lt;?&gt;            type;\n    private int                 modifiers;\n    &#x2F;&#x2F; Generics and annotations support\n    private transient String    signature;\n    &#x2F;&#x2F; generic info repository; lazily initialized\n    private transient FieldRepository genericInfo;\n    private byte[]              annotations;\n    &#x2F;&#x2F; Cached field accessor created without override\n    private FieldAccessor fieldAccessor;\n    &#x2F;&#x2F; Cached field accessor created with override\n    private FieldAccessor overrideFieldAccessor;\n&#125;\n\n\n\n3.反射攻击\n在Constructor、Method、Field类，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限public void setAccessible(boolean flag)，利用这个方法，可以将私有的构造函数、方法、成员变量设置为可以访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量。如下：\npublic class Demo &#123;\n    public static class Person &#123;\n        private int age;\n        private Person()&#123;&#125;;\n        private void print() &#123;\n            system.out.printIn(this.age);\n        &#125;\n    &#125;\n    public static void main(String[]args) throws Exception &#123;\n        Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.wz.demo.Demo$Person&quot;);\n\n        Constructor&lt;?&gt; constructor &#x3D; clazz.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        Person pobj &#x3D; (Person) constructor.newInstance();\n\n        Field field &#x3D; clazz.getDeclaredField(&quot;age&quot;);\n        field.setAccessible(true);\n        field.set(pobj,10);\n\n        Method method &#x3D; clazz.getDeclaredMethod(&quot;print&quot;);\n        method.setAccessible(true);\n        method.invoke(pobj);\n    &#125;\n&#125;\n反射攻击：打破单例类只能实例化一个对象的限制的情况\n\n\n4.反射的作用\nSpring可以作为一种IOC容器（DI容器、依赖注入容器），就是一个大的工厂类，负责在程序启动时，根据配置，事先创建好对象，当应用程序需要使用某个对象时，直接从容器中获取即可。\n\n在普通的工厂模式中，工厂类要创建哪个对象是事先确定好的，并且写死在工厂类代码中的。但是Spring通过读取事先定义好的配置文件，将每个要创建的对象信息，解析为一定的内存结构：BeanDefinition，然后根据BeanDefinition中的信息，通过反射创建对象\npublic class BeansFactory &#123;\n    private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();\n    private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n        &#125;\n\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;\n                createBean(beanDefinition);\n            &#125;\n        &#125;\n    &#125;\n\n    public Object getBean(String beanId) &#123;\n        BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);\n        if (beanDefinition &#x3D;&#x3D; null) &#123;\n            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n        &#125;\n        return createBean(beanDefinition);\n    &#125;\n\n    @VisibleForTesting\n    protected Object createBean(BeanDefinition beanDefinition) &#123;\n        if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n\n        Object bean &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;得到类信息\n            Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());\n            &#x2F;&#x2F;得到构造参数列表\n            List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();\n            if (args.isEmpty()) &#123;\n                bean &#x3D; beanClass.newInstance();\n            &#125; else &#123;\n                Class[] argClasses &#x3D; new Class[args.size()];\n                Object[] argObjects &#x3D; new Object[args.size()];\n                for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;\n                    BeanDefinition.ConstructorArg arg &#x3D; args.get(i);\n                    if (!arg.getIsRef()) &#123;\n                        argClasses[i] &#x3D; arg.getType();\n                        argObjects[i] &#x3D; arg.getArg();\n                    &#125; else &#123;\n                        BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());\n                        if (refBeanDefinition &#x3D;&#x3D; null) &#123;\n                            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());\n                        &#125;\n                        argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());\n                        argObjects[i] &#x3D; createBean(refBeanDefinition);\n                    &#125;\n                &#125;\n                &#x2F;&#x2F;有参构造\n                bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);\n            &#125;\n        &#125; catch (ClassNotFoundException | IllegalAccessException\n                 | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;\n            throw new BeanCreationFailureException(&quot;&quot;, e);\n        &#125;\n\n        if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;\n            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n        &#x2F;&#x2F;返回新对象bean\n        return bean;\n    &#125;\n&#125;\n\n5.反射的原理\n反射创建对象比new慢一些，大概10倍的，但是不会是应用程序的性能瓶颈\n反射动态执行方法比普通方法调用慢几百倍，但是也不需要担忧：\n使用反射执行方法，并不会让方法内部逻辑的执行速度变慢，只是增加一些额外耗时而已，这部分额外耗时是固定的，跟方法内部逻辑的复杂程度无关\n方法的额外耗时并不长，对于大部分方法来说，特别是一些I/O操作的方法（比如访问数据库），方法本身内部逻辑执行的耗时远远大于使用反射而额外增加的耗时\n\n\n额外耗时产生的原因：\n安全性检查：普通函数的参数类型匹配、和确保方法存在都是在编译时完成的，不占用运行时间，但是，对于反射，因为其在运行时才能确定创建什么对象，执行什么方法，所以，安全性检查无法在编译时执行，只能在运行时真正创建，执行方法时再完成，这就会增加额外的运行时间\n类、方法查找：当我们使用反射创建对象或执行方法时，需要通过类名、方法名去查找对应的类或方法，因为字符串匹配比较慢，所以代码经过编译之后得到的字节码中，每个类和方法都会分配一个对应的编号，保存在常量池中，代码中所有出现类或方法的地方，都会被替换为编号，可以提高查找速度。\n\n\n\n3.注解1.定义注解\n自定义注解的方式\n&#x2F;&#x2F;Java内建注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override &#123;\n&#125;\n\n&#x2F;&#x2F;自定义注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimit &#123;\n\tpublic enum TimeUnit &#123; SECOND,MINUTE, HOUR, DAY,MONTH&#125;\n    string apiName();\n\tint limitCount();\n\tTimeUnit timeUnit() default TimeUnit.SECOND;\n&#125;\n元注解\n\n@Target：用来描述注解的使用范围，他有以下值，一个注解可以有多个使用范围，如果没有Target则可以用于任何范围。\n\nElementType.TYPE：类、接口、枚举\nElementType.METHOD：用于方法\nElementType.CONSTRUCTOR：用于构造器\nElementType.FIELD：用于成员变量\nElementType.LOCAL_VARIABLE：用于局部变量\nElementType.PARAMETER：用于参数\nElementType.PACKAGE：用于包\n\n\n@Retention：用来描述注解的可见范围（或叫生命周期），有以下值，\n\nRetentionPolicy SOURCE：仅在源码中可见，当编译器将源码编译成字节码后，注解信息将被丢弃，但是，编译器可以读取到可见范围为SOURCE的注解。比如，在编译时，如果函数上标有@Override，就会去检查对应的函数有没有在父类中定义，如果没有，就提示编译错误\nRetentionPolicy.CLASS：表示注解在源码、字节码均可见，但在运行时是不可见的，无法在程序运行时，利用反射获取到代码（类、方法等）的这类注解信息\nRetentionPolicy.RUNTIME：表示注解在源码、字节码、运行时均可见，生命周期最长，可以在程序运行时，利用反射获取代码的这类注解信息\n\n\n@Documented：表示注解信息会输出到Javadoc文档中，当我们根据源码生成Javadoc文档时，类或方法上的用@Documented标记的注解也会跟随输出到Javadoc文档中\n\n@interface：class、interface、enum、@interface这四者是平级关系，@interface用来定义注解，在注解中，还可以定义一些变量，特殊的是注解使用方法来定义变量，对于只有一个变量的注解，可以将其定义为value，这样，在使用时，可以不指定变量的名称\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy. SOURCE)\npublic @interface Author &#123;\n\tstring value();\n&#125;\n\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Description &#123;\n\tstring author();\n\tstring date();\n&#125;\n@Author(&quot;wangzheng&quot;)\npublic class Demo &#123;\n\t@Description(author&#x3D;&quot;wangzheng&quot;, date&#x3D;&quot;2020-11-22&quot;)\n    public void f() &#123;\n\t&#x2F;&#x2F;...\n\t&#125;\n&#125;\n\n\n\n2.标记注解\n注解相当于给元素打了一个tag，任何编译器或者应用程序通过反射可以访问的代码元素，都可以用注解去标识\n\n不管是内建注解，还是自定义注解，使用方法都一样，注解用于类、方法等代码元素之上，起到标记作用。比如@Override，用来标记某个函数是对父类的重写；再比如，前面定义的@RateLimit注解，用于标记需要限流的接口，使用方式如下，在使用注解时，可以为注解中定义的变量赋值\npublic class UserController&#123;\n    @RateLimit(apiName&#x3D;&quot;&#x2F;user&#x2F;register&quot;,\n               limitCount&#x3D;1000,tiimeUnit&#x3D;RateLimit.TimeUnit.Second)\n    public UseerVo register(String telephone,String passward)&#123;\n        \n    &#125;\n&#125;\n\n3.读取注解\n大部分情况下，只定义和标记注解还不够，还需要有读取注解并做相应处理的代码逻辑，才能发挥注解的真正作用。这就类似于推荐算法中，只定义标签和给数据打标签是没用的，还需要设计根据标签分类数据的算法，这样才能发挥标签的作用。对于Java内建注解，编译器和JVM都可以对其进行读取和处理，比如@Override注解，编译器会处理\n对于自定义注解，我们需要自己开发相应的读取和处理逻辑，读取代码（类或方法等）中的注解信息就需要用到反射语法，因为反射作用于代码运行时，所以自定义注解的@Rentention可见范围一般应该设置为RUNTIME。\n\n4.注解应用\n替代注释：单元测试一般只能测试public和protected方法，如果想要测试private方法，那么就需要将这个方法的访问权限从private变为protected。为了表明此方法设置为protected只是为了测试，以免开发人员误解和误用，可以使用Google Guava提供的@VisibleForTesting注解在方法上进行标记，这个注解只起到注释的作用，并没有实际的作用，并不能限制除了单元测试代码之外的其他代码访问这个方法。尽管这里我们也可以使用注释代替注解，但是注解相对于注释，更加规范、统一、可读性更好。\n\n替代Marker Interface：\n\nJava中有一种特殊的接口，叫做标记接口（Marker Interface）。标记接口中不包含任何方法，跟注解类似，起到标记作用，比如RandomAccess、Cloneable、Serializable，可以根据标记接口判断对象是否可以执行某些操作\npublic interface RandomAccess&#123;&#125;&#x2F;&#x2F;支持随机访问\npublic interface Cloneable&#123;&#125;&#x2F;&#x2F;支持克隆\npublic interface Serializable&#123;&#125;&#x2F;&#x2F;支持序列化\n\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n    implements List&lt;E&gt;,RandomAccess,Cloneable,java.io.Serializable&#123;\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F;位于java.util.Collections类中\npublic static &lt;T&gt; int binarySearch\n    (List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; C)&#123;\n    if (C&#x3D;&#x3D;null)\n\t\treturn binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt; ) list, key);\n    \n    &#x2F;&#x2F;如果实现了RandomAccess标记接口的List容器，\n    &#x2F;&#x2F;binarySearch()函数调用indexedBinarySearch()函数来实现二分查找\n\tif (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n\t\treturn Collections.indexedBinarySearch(list, key, c);\n\telse\n\t\treturn Collections.iteratorBinarySearch(list, key, c),\n&#125;\n注解也可以起到标记的作用，因此可以使用注解来替代标记接口\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RandomAccess &#123;\n    \n&#125;\n\n@RandomAccess\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n    implements List&lt;E&gt;, Cloneable, java.io.Serializable &#123;\n    &#x2F;&#x2F;.....省略代码...\n&#125;\n\npublic static &lt;T&gt; int binarySearch\n    (List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)&#123;\n    if (c&#x3D;&#x3D;null)\n\t\treturn binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt; ) list, key);\n    \n    &#x2F;&#x2F;读取注解\n\tClass&lt;?&gt; clazz &#x3D; list.getClass();\n\tif(clazz.isAnnotationPresent(RandomAccess.class )\n       || list.size()&lt;BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key, c);\n\telse\n\t\treturn Collections.iteratorBinarySearch(list, key,c);\n&#125;\n\n\n替代XML配置文件\n\nSpring IOC容器需要读取应用程序的配置文件，解析出需要创建的对象，然后使用反射来创建对象\npublic class Demo &#123;\n    public static void main(String[]args)&#123;\n        ApplicationContext applicationContext &#x3D; new ClassPathXmIApplicationContext(&quot;beans.xml&quot;);\n        RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter.test();\n    &#125;\n    \n&#x2F;&#x2F;配置文件beans.xml\n&lt;beans&gt;\n\t&lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n        &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot; scope&#x3D;&quot;&quot;singleton&quot; lazy-init&#x3D;&quot;true&quot;&gt;\n\t\t\t&lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n            &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n     &lt;&#x2F;bean&gt;\n&lt;&#x2F;bean&gt;\n\n\n\nSpring还支持基于注解的配置方式\n@configuration\npublic class AppConfig &#123;\n    @Bean\n    public RateLimiter rateLimiter() &#123;\n        return new RateLimiter(redisCounter());\n    &#125;\n    @Bean(&quot;redisCnt&quot;)\n    public RedisCounter redisCounter()&#123;\n        return new RedisCounter(&quot;127.0.0.1&quot;,1234);\n    &#125;\n&#125;\npublic class Demo &#123;\n    public static void main(String[]args)&#123;\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n        RateLimiter rateLimiter &#x3D;(RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter test();\n    &#125;\n&#125;\n\n程序在启动时，Spring lOC容器利用反射获取到AppConfig上的注解，发现包含@Configuration注解，便确定这个类为配置类，然后，利用反射获取标记有@Bean注解的方法，利用反射执行方法并将创建的对象放置于BeansFactory中。BeansFactory维护了一个Map结构，Map中的键为对象名称，值为对象本身，之后我们便可以使用getBean(“rateLimiter”)这种方式从BeansFactory中获取对象了。对于@Bean标注的方法，默认使用类名首字母小写作为对象名称(比如rateLimiter)，当然，也可以通过注解中的value变量来指定对象名称(比如rediCnt)。\n\n从上述示例，我们发现，跟XML配置文件的配置方式类似，基于Java注解的配置方式，也是集中式的配置方式，所有要创建对象都集中在AppConfig类中。AppConfig类就等同于XML配置文件，只不过形式不同而已。有些Java程序员偏爱于Java代码做配置，有些Java程序员偏爱于XML文件做配置，两者没有绝对的优势。不过，基于Java注解，不仅可以实现集中式配置，还可以将配置分散在各个类中。\n\n如下所示，如果我们需要Spring lOC容器帮忙创建和管理某个类的对象，那么我们只需要在这个类上标记上@Component注解(当然也可以是@Controller、@Service、@Repository等Spring可以识别的其他注解)。Spring IOC容器会为标记了   @Component注解的类创建一个同名对象。当然，我们也可以在@Component注解中指定创建的对象名称。除此之外，如果创建某个类的对象需要依赖其他对象，那么，我们可以使用@Autowired自动依赖注入注解，标记依赖的成员变量，这样Spring lOC容器会从BeanFactory中获取依赖的对象，自动赋值给成员变量。\n@component\npublic class RateLimiter &#123;\n    @Autowired\n    private RedisCounter redisCounter;\n    public void test() &#123;\n        system.out.printIn(&quot;Hello World!&quot;);\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n因为被标记为@Component的类可散落在项目代码中的各个地方，为了让Spring lOC容器能查找到这些类，我们需要告知SpringIOC去哪些package下扫描查找。告知的方法如下所示，编写AppConfig类，并且通过注解@ComponentScan指定扫描路径。\n@configuration\n@componentScan(&quot;com.xzg&quot;)\npublic class AppConfig &#123;\n\n&#125;\npublic class Demo &#123;\n    public static void main(String[]args)&#123;\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n        RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter test();\n    &#125;\n&#125;\n\n程序在启动时，Spring lOC容器会通过反射读取AppConfig类上的注解，发现包含@Configuration，确认是配置文件，然后再通过反射读取@ComponentScan注解中的value值，获得扫描范围com.xzg。接下来，Spring lOC容器便在com.xzg包下，扫描标记有@Component注解的类（RateLimiter），然后利用反射创建类的对象，并存储到BeansFactory中。在创建的过程中，如果某个类中的成员变量标记有@Autowired注解，那么Spring lOC容器会从BeansFactory中，查找已经创建好的对象，自动赋值给这个成员变量。\n\n对于以上非集中式的配置方式，添加、删除类不需要修改集中的配置文件，并且，注解还能在代码中起到注释的作用，比如，在阅读代码时，如果我们发现某个方法标记了@Transactional注解，那么，我们可以得知这个方法支持事务。当然，集中式配置也有优点，那就是配置信息跟代码解耦合，方便代码复用，除此之外，使用集中式配置，配置集中于一处，项目中有哪些配置─目了然，比如，如果我们使用配置文件配置事务，那么通过查看配置文件，我们就可以得知项目中所有支持事务的方法。集中式配置方式(基于XML配置文件、基于Java注解)和非集中式配置方式(基于Java注解)各有利弊，没有哪个具有绝对优势，你可以根据团队的习惯自行选择。\n\n\n4.动态代理\n\n\n\n\n\n\n\n\n代理模式可以在不改变原始类的代码的情况下，通过引入代理类来给原始类附加功能。代理模式分为静态代理和动态代理\n1.静态代理（见设计模式）\n通过实现接口或继承的方式，通过注入原始类并添加新功能的方式实现\n实现简单，但会导致项目中的类成倍增加，所有相关的类都需要增加代理类，重复代码多\n\n2.动态代理\n一般静态指的编译阶段，动态指的运行阶段。在代理模式上，静态代理指的是在编译阶段时生成代理类的字节码，动态代理指的是运行时生成代理类的字节码，且字节码只存在与内存中，并不会生成对应的class文件\n之所以可以实现动态代理，是因为JVM设计得非常灵活，只要是符合类的格式的字节码，都可以在运行时被JVM解析并加载，不管这个字节码是来自预先编译好的(class文件)，还是在内存中临时生成的(典型应用:动态代理)，又或者从网络加载而来的(典型应用: Applet)。这部分内容涉及到JVM的类加载机制，见JVM。\n实现方法一：利用JDK提供的类来实现\n实现方法二：使用第三方的字节码类库来实现，比如CGLIB、BECL、ASM、Javassit等直接编辑字节码\n\n\n\n3.基于JDK实现动态代理\n基本语法\n\n为UserController类实现动态代理，当为其它Controller类中的方法也添加时间统计代码时，可以复用CtrlProxyHandler类，并通过Proxy类的newProxyInstance()静态方法生成对应的代理类对象。\npublic class CtrlProxyHandler implements InvocationHandler &#123;\n    private Object origBean;\n\n    public CtrlProxyHandler(Object origBean) &#123;\n        this.origBean &#x3D; origBean;\n    &#125;\n    @override\n    public Object invoke(Object proxy， Method method, Object[] args) throws Throwable &#123;\n        long startTime &#x3D; system.currentTimeMillis();\n        \n        Object res &#x3D; method.invoke(origBean, args);\n        \n        long costTime &#x3D; System.currentTimeMillis() - startTime;\n        System.out.printIn(origBean.getClass().getSimpleName()+&quot;#&quot;+ method.getName() + &quot; cost time: &quot; + costTime);\n        return res;\n    &#125;\n&#125;\n\npublic class JDKProxyDemo &#123;\n    public static void main(String] args) &#123;\n        luserController userController &#x3D; new UserController();\n        CtrIProxyHandler handler &#x3D; new CtrIProxyHandler(userController);\n        &#x2F;&#x2F;用Proxy的静态方法生成代理类\n        lUserController userControllerProxy &#x3D; (IUserController)Proxy.newProxyInstance\n            (handler.getClass().getClassLoader(), UserController.class.getInterfaces(), handler);\n        userControllerProxy.login(&quot;139********&quot;，&quot;*********&quot;);\n    &#125;\n&#125;\n\n基于JDK来实现动态代理主要用到了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类。\n\nInvocationHandler接口只包含一个invoke()函数\npublic interface InvocationHandler &#123;\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n&#125;\nProxy类生成代理类和实例化对象的方法如下\n&#x2F;&#x2F;Foo为接口\n\nInvocationHandler handler &#x3D; new MyInvocationHandler(...); &#x2F;&#x2F; InvocationHandler\n&#x2F;&#x2F;生成代理类\nClass&lt;?&gt; proxyClass &#x3D; Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);\n&#x2F;&#x2F;实例化对象\nFoo f&#x3D;(Foo) proxyClass.getConstructor(\n    InvocationHandler.class).newInstance(handler);\n\n&#x2F;&#x2F;大部分情况下，我们只需要用到代理类的实例化对象，\n&#x2F;&#x2F;所以，上述代码中的后两行代码可以简化为如下一行代码。\nFoo f &#x3D;(Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class&lt;?&gt;[] &#123; Foo.class &#125;, handler);\n\n\n\n\n实现原理\n\nnewProxyInstance函数的定义：public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)\n\nClassLoader loaderloader表示类加载器，用于加载动态代理类到JVM\nClass&lt;?&gt;[] interfaces用于生成动态代理类，接口中的方法就是动态代理类包含的方法\nInvocationHandler h用于创建（实例化）动态代理类对象\n\npublic static Object newProxyInstance(\n    ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h)&#123;\n    \n    &#x2F;&#x2F;1)生成动态代理类\n    &#x2F;&#x2F;2)加载动态代理类\n    Class&lt;?&gt; cl&#x3D; getProxyClass0(loader, intfs);\n\n    &#x2F;&#x2F;3)实例化动态代理类对象\n    final Class&lt;?&gt;[] constructorParams &#x3D; &#123; InvocationHandler.class &#125;;\n    final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);\n    return cons.newlnstance(new Object]&#123;h);\n&#125;\n生成动态代理类的过程：newProxyInstance()函数调用ProxyGenerator类(JDK提供的生成字节码的类)，按照类的字节码格式，生成动态代理类的字节码，并存储到内存（proxyClassFile）中\n&#x2F;&#x2F;生成动态代理类的名称\nfinal String proxyClassNamePrefix &#x3D; &quot;$Proxy&quot;;\nlong num &#x3D; nextUniqueNumber.getAndIncrement();\nString proxyName &#x3D; proxyPkg + proxyClassNamePrefix + num;\n\n&#x2F;&#x2F;ProxyGenerator类似字节码类库，可以生成动态代理类的字节码\nbyte[] proxyClassFile &#x3D; ProxyGenerator.generateProxyClass(\n    proxyName, interfaces, accessFlags);\ntry &#123;\n    &#x2F;&#x2F;通过JVM的类加载器来加载动态代理类\n    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n&#125; \ncatch(ClassFormatError e) &#123; &#x2F;&#x2F;如果生成的动态代理类的字节码格式有误，则报错\n    throw new lllegalArgumentException(e.toString());\n&#125;\n\n\n\n动态代理类具有哪些方法：只跟接口有关，跟原始类没有任何关系，这也是基于JDK实现的动态代理要求原始类必须有接口定义才行。\n\n\n类名：动态代理类的类名是自动生成的，由两部分组成，$Proxy+自增编号，如果项目中使用Proxy类生成了两个动态代理类，名称将分别为$Proxy0，$Proxy1\n\n反编译动态代理类：\n\n动态代理类字节码的保存方式：byte[] bytecodes = ProxyGenerator.generateProxyClass(&quot;CtrIProxy&quot;, new Class[] &#123; IUserController.class &#125;);\n\n利用反编译工具生成CtrlProxy.class字节码文件\npublic final class CtrlProxy extends Proxy implements IUserController&#123;\n    private static Method m4;&#x2F;&#x2F;register()\n    \n    public final UserVo register(String var1,String var2) throws &#123;\n        try &#123;\n            &#x2F;&#x2F;super.h的值，在实例化动态代理类对象时，赋值为自定义的InvoationHandler实现类对象（比如CtrlProxyHandler类对象）\n            return (UserVo)super.h.invoke(this, m4, new Object[]&#123;var1, var2&#125;);\n        &#125; catch (RuntimeException | Error var4) &#123;\n            throw var4;\n        &#125;catch (Throwable var5)&#123;\n            throw new UndeclaredThrowableException(var5);\n        &#125;\n    &#125;\n    \n    static &#123;\n        try&#123;\n            m4 &#x3D; Class.forName(&quot;demo.proxy.IUserController&quot;).getMethod(&quot;register&quot;,\n                Class.forName(&quot;java.lang.String&quot;),Class.forName(&quot;java.lang.String&quot;));\n        &#125;catch (NoSuchMethodException var2)&#123;\n            throw new NoSuchMethodError(var2.getMessage());\n        &#125; catch (ClassNotFoundException var3)&#123;\n            throw new NoClassDefFoundError(var3.getMessageO));\n        &#125;\n    &#125;\n&#125;\n\n\n当调用login()方法时，login()方法会调用CtrlProxyHandler上的invoke()方法。invoke()方法执行一些附加逻辑，然后再拿传递过来的方法和参数，利用反射在原始类对象上执行\n\n\n\n性能分析：动态代理耗时的地方有，运行时动态生成代理类的字节码、利用反射执行方法\n\n\n4.基于CGLIB实现动态代理\nMaven导入cglib的依赖\n\n基于CGLIB实现动态代理，也要用到一个核心接口MethodInterceptor和一个核心类Enhancer，他们的用法跟JDK中的InvocationHandler接口和Proxy类相似\npublic class ProxyFactory implements MethodInterceptor &#123;\n    private Object origBean;\n\n    public ProxyFactory(Object origBean)&#123;\n        this.origBean &#x3D; origBean;\n    &#125;\n    \n    @Override\n    public Object intercept(Object obj, Method method, \n                            Object[] args,MethodProxy methodProxy)throws Throwable &#123;\n        long startTime &#x3D; System.currentTimeMillis();\n        Object res &#x3D; method.invoke(origBean, args);\n        long costTime &#x3D; System.currentTimeMillis() - startTime;\n        System.out.printIn(origBean.getClass().getSimpleName()+\n                           &quot;#&quot;+ method.getName() + &quot; cost time: &quot; + costTime);\n        return res;\n    &#125;\n&#125;\npublic class CGLIBProxyDemo &#123;\n    public static void main(Stringargs)&#123;\n        Enhancer enhancer &#x3D; new Enhancer();\n        enhancer.setSuperclass(UserController.class);\n        enhancer.setCallback(new ProxyFactory(new UserController()));\n        UserController userControllerProxy &#x3D; (UserController) enhancer.create();\n        userControllerProxy.login(&quot;&quot;.&quot;&quot;);\n    &#125;\n&#125;\n基于CGLIB的动态代理实现方式，并不依赖接口，通过继承原始类来生成动态代理类，因此，是一种基于继承的动态代理实习方式\n\n\n5.函数式编程1.函数式编程\n编程范式对比：\n\n面向对象编程的特点：以类、对象作为组织代码的单元以及它的四大特性\n面向过程编程的特点：以函数作为组织代码的单元，数据与方法相分离\n函数式编程的特点：用一系列数学函数或表达式组合来表示，式程序面向数学的更底层的抽象，将计算过程描述为表达式\n\n\n应用场景：科学计算、数据处理、统计分析等，在这些领域，程序往往比较容易用数学表达式来表示，比非函数式编程实现同样的功能需要更少的代码\n\n函数编程的实现：\n\n函数是无状态的，只有局部变量不共享全局变量/成员变量，函数的执行结果只与入参有关，同样的入参，不管怎么执行，得到的结果都一样\n\nJava函数式编程举例\npublic class FPDemo &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n            &#x2F;&#x2F;先过滤非空字符串\n            .filter(((Predicate&lt;string&gt; ) string::isEmpty).negate())\n            &#x2F;&#x2F;查找以&quot;wz-&quot;为前缀的字符串\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            &#x2F;&#x2F;统计每个字符串的长度\n            .map(String::length)\n            &#x2F;&#x2F;打印输出\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;\n\n\n\n2.函数接口\n\n\n\n\n\n\n\n\n把函数包裹成接口，来实现把函数当作参数一样使用（Java不像C可以使用函数指针把函数直接当参数来使用）\n\n因为Java没有函数指针，所以通过函数接口，将函数包裹在接口中，当作变量来使用，例如Runnable、Comparator等都是函数接口\n@Functionallnterface\npublic interface Runnable &#123;\n    &#x2F;&#x2F;只有一个未实现方法\n    public abstract void run();\n&#125;\n\n@Functionallnterface\npublic interface Comparator&lt;T&gt; &#123;\n    &#x2F;&#x2F;未实现方法\n    int compare(T o1,T o2);\n    &#x2F;&#x2F;虽然未实现，但继承了Object的equals方法的默认实现\n    boolean equals(Object obj);\n    &#x2F;&#x2F;有默认实现的方法\n    default Comparator&lt;T&gt; reversed() &#123;\n        return Collections.reverseOrder(this);\n    &#125;\n    \n    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other)&#123;\n        Objects.requireNonNull(other);\n        return (Comparator&lt;T&gt; &amp; Serializable)(c1, c2) -&gt;&#123;\n            int res &#x3D; compare(c1,c2);                                                         \n            return (res !&#x3D; 0) ? res : other.compare(c1, c2);\n        &#125;\n    &#125;\n&#125;\n当函数接口只包含一个未实现的方法，Java提供了专门的注解@Functionallnterface来标识某个接口是函数接口，这个注解的作用就是检查接口中是否只有一个未实现的方法。只包含一个未实现方法但未使用注解的也会被认为是函数接口。可以自行定义加上注解@Functionallnterface的函数接口\n\nJava预定义的其它函数接口，比如Predicate&lt;T&gt;，Function&lt;T,R&gt;、Consumer&lt;T&gt;、Supplier&lt;T&gt;等，详见java.util.function包\n：@Functionallnterface\npublic interface Predicate&lt;T&gt; &#123;\n    boolean test(T t); &#x2F;&#x2F;只有这一个未实现的方法\n    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;\n        objects.requireNonNull(other);\n        return (t) -&gt; test(t) &amp;&amp; other.test(t);\n    &#125;\n    default Predicate&lt;T&gt; negate() &#123;\n        return (t) -&gt; ltest(t);\n    &#125;\n    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)&#123;\n        Objects.requireNonNull(other);\n        return (t) -&gt; test(t) || other.test(t);\n    &#125;\n    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;\n        return (null &#x3D;&#x3D; targetRef)\n            ? Objects:..isNull\n                : object -&gt; targetRef.equals(object);\n    &#125;\n&#125;\n使用：作用上类似于模板模式、实现上类似于回调。将某个流程中可变的逻辑抽离出来，设计成函数接口，以此来支持灵活定制可变逻辑\npublic class Demo &#123;\n    public static void main(String[]args) &#123;\n        List&lt;String&gt; files &#x3D; Arrays.asList(&quot;wang.txt&quot;, &quot;zheng.java&quot;, &quot;xiao.txt&quot; , &quot;ge.java&quot;);\n        List&lt;String&gt; javaFiles &#x3D; filterFiles(files, new Filter&lt;String&gt;()&#123;\n            @override\n            public boolean accept(String name) &#123;\n                return name.endsWith(&quot;.java&quot;);\n            &#125;\n        &#125;);\n    &#125;\n    &#x2F;&#x2F; filter过滤策略为可变逻辑\n    public static List&lt;String&gt; filterFiles(List&lt;Strings files, Filter&lt;String&gt; filter) &#123;\n        List&lt;String&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (String file : files) &#123;\n            if (filter.accept(file))&#123;\n                res.add(file);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n3.Lambda表达式\n\n\n\n\n\n\n\n\n简化函数接口的匿名实现类的代码编写\n\nLambda表达式\n(类型 a,类型 b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\n(a,b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\na-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a为输入参数\n&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;没有入参\n\n实现，简化Filter\npublic static void main(String] args) &#123;\n    List&lt;String&gt; files &#x3D; Arrays.asList(&quot;wang.txt&quot;, &quot;zheng.java&quot;, &quot;xiao.txt&quot;, &quot;ge.java&quot;);\n    &#x2F;&#x2F;使用匿名实现类\n    List&lt;String&gt; javaFiles &#x3D; filterFiles(files, new Filter&lt;String&gt;()&#123;\n        @override\n        public boolean accept(String name) &#123;\n            return name.endsWith(&quot;.java&quot;);\n        &#125;\n    &#125;);\n    &#x2F;&#x2F;使用Lambda表达式\n    List&lt;String&gt; javaFiles2 &#x3D; filterFiles(files, (String name)-&gt;&#123;\n        return name.endsWith(&quot;. java&quot;);\n    &#125;);\n    &#x2F;&#x2F;有入参，只有一条返回语句\n\tList&lt;String&gt; javaFiles &#x3D; filterFiles(files,name-&gt;name.endWith(&quot;.java&quot;));\n&#125;\n\n4.方法引用\n\n\n\n\n\n\n\n\n进一步简化Lambda表达式\n\n当Lambda中的逻辑已经有现成的方法实现时，可以直接使用方法引用。方法引用要求所引用的方法的参数列表的返回值，跟函数接口中未实现方法的参数列表和返回值完全一致，格式如下\n对象::实例方法\n类::静态方法\n类::实例方法\n实现\npublic class FPDemo &#123;\n    public static void main(String] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n            .filter(((Predicate&lt;String&gt;) String::isEmpty).negate())\n            &#x2F;&#x2F; .filter(s-&gt;s.isEmpty())\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            .map(String::length)\n            &#x2F;&#x2F;.map(s-&gt;s.length())\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;\n\n5.Sream流\n\n\n\n\n\n\n\n\n支持通过”.”级联多个函数操作的代码编写方式\n\n函数式编程其本质应该是Stream流，每个函数都返回一个通用的类（Stream对象），在Stream上的操作有两种：\n\n中间操作：返回的仍然式Stream对象，可以继续级联其它操作\n终止操作：确定的值结果或者没有返回值，无法继续往下级联处理\n\n\nStream类中的filter()、map()、forEach()等方法的参数为Java预定义的函数接口，因此函数接口的匿名实现类可以通过Lambda表达式来简化\npublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);\n    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);\n    void forEach(Consumer&lt;? super T&gt; action);\n&#125;\nJava预定义的函数接口中，有一些具有默认实现的方法，比如Predicate&lt;T&gt;函数接口中的add()、or()、negate()等方法，一般用来组合操作\nList&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot; , &quot;c.java&quot;);\nPredicate&lt;String&gt; p1 &#x3D; s-&gt;s.startsWith(&quot;wz-&quot;);\nPredicate&lt;String&gt; p2&#x3D; s-&gt;s.endsWith(&quot;. java&quot;);\nList&lt;String&gt; res &#x3D; strList.stream()\n    &#x2F;&#x2F;既包含wz-前缀，又.java后缀\n    .filter(p1.and(p2))\n    .collect(Collectors.toList());\n\n多线程1.线程概述1.线程由来\n单进程：对程序运行过程中所涉及的数据（比如创建的对象、变量）、代码、资源（比如打开的文件）、执行信息（执行到哪行代码）的封装聚合，起到方便管理的作用。\n多进程：\n原理：计算机的需求从CPU密集型的计算任务转变为对实时性要求更高的个人操作，计算机内部采用并发（concurrency）的方式来实现用户眼里的并行（paralelism）需求，类似于视频的帧切换\n上下文切换：在进程切换的过程中，OS需要记录下进程暂停时的环境信息，重启执行时，需要恢复这个进程执行的环境信息，这个环境信息就叫做上下文（Context），两个进程之间切换执行，就会导致上下文切换（Context Switching）\n操作系统用进程表（Process Table）来记录所有进程的执行信息，每一个表项叫做进程控制块，简称PCB（Process Control Block），一个PCB记录一个进程的执行信息，主要包括：进程ID、进程状态、程序计数器（PC计数器 Programm Counter，记录接下来要执行的代码所在的内存地址）、寄存器值（程序执行的中间结果）、调度信息（如进程的优先级）、文件列表（已打开的文件信息）、其他信息（如统计信息，进程运行了多长时间）\n\n\n多线程：对多进程的一种优化\n设计方面：相当于对进程进行了拆分，进程只负责线程共享资源的管理，线程负责代码的执行，线程负责部分数据（函数调用栈、程序计数器、寄存器值）；进程是资源分配的最小单元，线程是CPU调度的最小单元，OS按线程来分配CPU执行时间；线程切换也会导致上下文的切换。\n性能方面：随着多核计算机的发展，多线程可以让一个程序并行运行在多个CPU上，提高程序运行效率，使得CPU密集型和IO密集型逻辑可以并行执行，不仅程序间可以并行执行，程序内也可以并行执行。\n易用性方面：引入多线程后，每个线程负责执行一个逻辑，OS负责多个逻辑之间的调度执行，如果没有多线程，就需要程序员维护\n\n\n\n2.线程概述\n调度策略概览：先来先服务、最短作业优先、高优先级优先、多优先级队列、轮转调度等\n线程状态\nNEW：新创建的线程、在没有调用start()函数前，线程处于NEW状态\nREADY：线程一切就绪，等待操作系统调度\nRUNNING：线程正在执行\nWAITING：线程在等待I/O读写完成，等待获得锁、等待时钟定时到期（调用sleep()函数）等\nTERMINATED：线程终止状态，线程终止后，未必就立即销毁，有些OS为了节省线程创建的时机（因为要分配内存和初始化一些变量），会复用处于TERMINATED状态的线程\n\n\n\n3.线程模型\n\nd\n由操作系统负责内核调度，调用程序运行在内核空间，CPU处于内核态。操作系统暴漏内核的系统调用给应用程序使用，比如Linux中的pthread、C++中的std::thread。\n内核线程也叫做1：1模型，表示一个应用程序的用户线程（比如Java Thread创建的线程对象）对应一个内核线程\n缺点是：系统调用会导致用户态和内核态的上下文切换，比较耗时\n\n\n用户线程：\n概念：线程的调度由虚拟机完成，因为虚拟机本质上就是一个应用程序，运行在用户空间，所以，用户线程也叫做用户空间线程或用户态线程。协程就是用户线程\n调度：调度程序会通过调度算法来调度用户线程，调度算法大部分都是依靠轮询的策略。调度是在用户空间完成的，完全不需要OS内核的参与，避免可上下文切换。\n虚拟机：保存用户线程的上下文，并且为每个用户线程维护独立的函数调用栈\n用户线程也叫做M：1模型，也就是M个用户线程对应1个内核线程。虚拟机本质上也是程序，在运行时，OS会为其创建进程，并且是单内核线程\n缺点：只能共享一个内核线程，没法利用多核优势；无法使用阻塞模式的系统调用，一个用户线程阻塞其它也都无法工作\n\n\n混合线程：\n一个进程中的M个用户线程对应N个内核线程，M一般大于N，M个线程并不会绑定在一个内核线程上，不用的用户线程可以分散到不同的CPU上，可以利用计算机的多核优势\nM：N模型也可以称为是协程，Go语言中的协程就是基于M：N模型来实现的，也叫做Go协程\n\n\n\n4.实现原理\nGreen Thread：就是M：1线程模型，名字是因为开发团队名字叫Green Team，JDK1.3便已经废弃。\nNative Thread：内核线程模型，也就是1：1线程模型，Java线程库是对OS内核线程系统调用的二次封装，而且为了实现统一的编程接口，定义了自己的线程状态和优先级\n线程状态有：NEW、RUNNABLE、WAITING、TIMED_WAITING、BLOCKED、TERMINATED\n线程优先级有10个，从1到10\n\n\n\n5.代码实现1.创建一个线程\n通过实现 Runnable 接口\n\nclass RunnableDemo implements Runnable &#123;\n   private Thread t;\n   private String threadName;\n   \n   RunnableDemo( String name) &#123;\n      threadName &#x3D; name;\n      System.out.println(&quot;Creating &quot; +  threadName );\n   &#125;\n   \n   public void run() &#123;\n      System.out.println(&quot;Running &quot; +  threadName );\n      try &#123;\n         for(int i &#x3D; 4; i &gt; 0; i--) &#123;\n            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);\n            &#x2F;&#x2F; 让线程睡眠一会\n            Thread.sleep(50);\n         &#125;\n      &#125;catch (InterruptedException e) &#123;\n         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);\n      &#125;\n      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);\n   &#125;\n   \n   public void start () &#123;\n      System.out.println(&quot;Starting &quot; +  threadName );\n      if (t &#x3D;&#x3D; null) &#123;\n         t &#x3D; new Thread (this, threadName);\n         t.start ();\n      &#125;\n   &#125;\n&#125;\n \npublic class TestThread &#123;\n \n   public static void main(String args[]) &#123;\n      RunnableDemo R1 &#x3D; new RunnableDemo( &quot;Thread-1&quot;);\n      R1.start();\n      \n      RunnableDemo R2 &#x3D; new RunnableDemo( &quot;Thread-2&quot;);\n      R2.start();\n   &#125;   \n&#125;\n\n\n通过继承 Thread 类本身\n\nclass ThreadDemo extends Thread &#123;\n   private Thread t;\n   private String threadName;\n   \n   ThreadDemo( String name) &#123;\n      threadName &#x3D; name;\n      System.out.println(&quot;Creating &quot; +  threadName );\n   &#125;\n   \n   public void run() &#123;\n      System.out.println(&quot;Running &quot; +  threadName );\n      try &#123;\n         for(int i &#x3D; 4; i &gt; 0; i--) &#123;\n            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);\n            &#x2F;&#x2F; 让线程睡眠一会\n            Thread.sleep(50);\n         &#125;\n      &#125;catch (InterruptedException e) &#123;\n         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);\n      &#125;\n      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);\n   &#125;\n   \n   public void start () &#123;\n      System.out.println(&quot;Starting &quot; +  threadName );\n      if (t &#x3D;&#x3D; null) &#123;\n         t &#x3D; new Thread (this, threadName);\n         t.start ();\n      &#125;\n   &#125;\n&#125;\n \npublic class TestThread &#123;\n \n   public static void main(String args[]) &#123;\n      ThreadDemo T1 &#x3D; new ThreadDemo( &quot;Thread-1&quot;);\n      T1.start();\n      \n      ThreadDemo T2 &#x3D; new ThreadDemo( &quot;Thread-2&quot;);\n      T2.start();\n   &#125;   \n&#125;\n\n\n通过 Callable 和 Future 创建线程\n\npublic class CallableThreadTest implements Callable&lt;Integer&gt; &#123;\n    public static void main(String[] args)  \n    &#123;  \n        CallableThreadTest ctt &#x3D; new CallableThreadTest();  \n        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);  \n        for(int i &#x3D; 0;i &lt; 100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  \n            if(i&#x3D;&#x3D;20)  \n            &#123;  \n                new Thread(ft,&quot;有返回值的线程&quot;).start();  \n            &#125;  \n        &#125;  \n        try  \n        &#123;  \n            System.out.println(&quot;子线程的返回值：&quot;+ft.get());  \n        &#125; catch (InterruptedException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125; catch (ExecutionException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n    &#125;\n    @Override  \n    public Integer call() throws Exception  \n    &#123;  \n        int i &#x3D; 0;  \n        for(;i&lt;100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  \n        &#125;  \n        return i;  \n    &#125;  \n&#125;\n\n2.线程状态\n新建\n\npublic class TestJoin implements Runnable&#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestJoin testJoin &#x3D; new TestJoin();\n        Thread thread &#x3D; new Thread(testJoin);\n        thread.start();\n        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n            if (i &#x3D;&#x3D; 200)&#123;\n                thread.join();\n            &#125;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+i);\n        &#125;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;线程vip来了&quot;+i);\n        &#125;\n    &#125;\n&#125;\n\n\n阻塞\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n&#x2F;&#x2F;模拟网络延时\n&#x2F;&#x2F;模拟倒计时\npublic class TestSleep &#123;\n    public void printSlowly() throws InterruptedException &#123;\n\n        char[] chars &#x3D; new char[1024];\n        chars &#x3D; &quot;写Java的说门口开了一家Spring串店，挺火。写php的说去以前高中门口的烤面筋小摊吃，怀旧。写python的说在家里炒点牛肉片跟去外面吃烧烤一样，还快\\n&quot;.toCharArray();\n        for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n            System.out.print(chars[i]);\n            Thread.sleep(20);\n        &#125;\n    &#125;\n    public void tenDown() throws InterruptedException &#123;\n        int num &#x3D; 10;\n        Date startTime &#x3D; new Date(System.currentTimeMillis());&#x2F;&#x2F;获取当前时间\n        while(true)&#123;\n            Thread.sleep(1000);\n            System.out.println(num--);\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\n            startTime &#x3D; new Date(System.currentTimeMillis());\n            if (num&lt;&#x3D;0) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestSleep testSleep &#x3D; new TestSleep();\n        testSleep.printSlowly();\n        testSleep.tenDown();\n\n    &#125;\n&#125;\npublic class TestJoin implements Runnable&#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestJoin testJoin &#x3D; new TestJoin();\n        Thread thread &#x3D; new Thread(testJoin);\n        thread.start();\n        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n            if (i &#x3D;&#x3D; 200)&#123;\n                thread.join();\n            &#125;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+i);\n        &#125;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;线程vip来了&quot;+i);\n        &#125;\n    &#125;\n&#125;\n\n\n查看状态\n\npublic class TestState &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread thread &#x3D; new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n                try &#123;\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        &#125;);\n        &#x2F;&#x2F;观察状态\n        Thread.State state &#x3D; thread.getState();\n        System.out.println(state);\n\n        &#x2F;&#x2F;观察启动后\n        thread.start();\n        state &#x3D; thread.getState();\n        System.out.println(state);\n\n        &#x2F;&#x2F;只要线程不终止，就一直输出状态\n        while(state !&#x3D; Thread.State.TERMINATED)&#123;\n            Thread.sleep(100);\n            state &#x3D; thread.getState();&#x2F;&#x2F;更新线程状态\n            System.out.println(state);\n        &#125;\n        thread.setPriority(Thread.MAX_PRIORITY);\n    &#125;\n&#125;\n\n\n线程终止\n\n&#x2F;&#x2F;测试stop\n&#x2F;&#x2F;1.建议线程正常终止--&gt;利用次数，不建议死循环\n&#x2F;&#x2F;2.建议使用标志位---&gt;设置一个标志位\n&#x2F;&#x2F;3.不要使用stop或者destroy等过时的或者JDK不建议使用的方法\npublic class TestStop implements Runnable&#123;\n\n    &#x2F;&#x2F;1.设置一个标注为\n    private Boolean flag&#x3D; true;\n    @Override\n    public void run() &#123;\n        int i &#x3D; 0;\n        while(flag)&#123;\n            System.out.println(&quot;run...Thread&quot;+i++);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;设置一个公开方法用来停止线程，转换标志位\n    public void stop()&#123;\n        this.flag &#x3D; false;\n    &#125;\n    public static void main(String[] args) &#123;\n        TestStop testStop &#x3D; new TestStop();\n        new Thread(testStop).start();\n        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n            System.out.println(&quot;main&quot;+i);\n            if (i &#x3D;&#x3D; 900)&#123;\n                &#x2F;&#x2F;调用stop方法切换标志位，该线程停止了\n                testStop.stop();\n                System.out.println(&quot;该线程停止了&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n3.线程池import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;1.创建服务，创建线程池\n        ExecutorService service &#x3D; Executors.newFixedThreadPool(10);\n        &#x2F;&#x2F;2.执行\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        &#x2F;&#x2F;3.关闭连接\n        service.shutdown();\n    &#125;\n&#125;\nclass MyThread implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n\n        System.out.println(Thread.currentThread().getName());\n\n    &#125;\n&#125;\n\n6.线程安全\n线程安全：描述的对象可以是函数也可以是类，线程安全意味者不同线程并发执行相同的函数，或者不同线程执行一个类的不同函数，因为线程切换，函数内的指令都可以任意交叉执行，最终任意执行顺序得到的结果都是相同的，符合预期的。\n\n临界区和竞态\n\n临界区：可能会引起线程不安全的局部代码块，一般包括以下两个特征\n\n访问共享资源：类中的成员变量、参数传递进来的共享对象（注意指令重排序问题）\n\n包含复合操作：先检查再执行、先读取再修改后写入\n&#x2F;&#x2F;先检查再执行\npublic class Singleton &#123;\n    private static Singleton instance;\n    private Singleton()&#123;&#125;\n    public static Singleton getInstance()&#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;先读取再修改后写入\npublic class Demo &#123;\n    private int count &#x3D; 0;\n    public void increment()&#123;\n        count++;\n    &#125;\n&#125;\n\n\n竞态：两个线程处于竞态执行临界区，就有可能执行出错，就有可能线程不安全\n\n\n\n互斥和同步\n\n互斥：对临界区加锁，让临界区变为原子操作，目的就是让多个线程互斥访问临界区\n同步：多个线程之间如何协同执行，比如一个线程等待另一个线程执行完成后再执行\n\n\n\n2.JMM\n\n\n\n\n\n\n\n\nJava内存模型（规范为JSR-133）用来解决多线程的三大问题：可见性问题、有序性问题、原子性问题。模型中Java定义了一些关键字（volatile、synchronized），或者增强了某些关键字（final），以此来限制内存中多线程共享数据的读写方式，最终达到解决可见性、有序性、原子性问题。\n1.CPU缓存导致可见性问题\n\n\n\n\n\n\n\n\n内存的访问速度对于CPU来说太慢了，依靠局部性原理通过缓存来提高数据读写速度。在单线程或单CPU多线程下并没有影响，但是在多CPU多线程下会导致CPU缓存之间存在数据的一致性问题，或叫可见性问题\n\n\n大部分CPU都支持缓存一致性协议，可以在硬件层面解决各个CPU缓存数据的一致性问题，比如MESI，它具有四种状态：\nM（Modified）：表示当前缓存行中的数据已被修改，但并未同步到内存\nE（Exclusive）：表示当前缓存行中有这个数据，其他CPU缓存中没有这个数据\nS（Shared）：表示当前缓存中有这个数据，其它CPU缓存中也有这个数据\nI（Invalid）：表示当前缓存行中的数据已经失效，说明其他CPU对数据进行了修改，下次CPU读取数据要从内存中读取，并同步更新缓存\n\n\nStore Buffer\n从MESI状态来看，当多个CPU缓存中都有同一数据时，一个CPU对缓存数据进行修改，需要广播invalidate消息，其他CPU收到invalidate消息之后，将对应的缓存行设置为l，然后再发送invalid ack消息给这个CPU。此时，这个CPU才可以将数据更新写入缓存和内存。\n因为保证缓存数据一致性，写操作需要大量耗时，所以在CPU和CPU缓存之间，增加了类似消息中间件的存储结构，叫做Store Buffer，用来异步执行写操作\nCPU将写操作的所有信息存储到Store Buffer之后，就立刻返回执行其他指令了，由Store Buffer来完成剩下的工作，包括发送invalidate消息，接收invalidate ack，写入缓存和内存。引入Store Buffer之后，在读取数据时，CPU会先从Store Buffer中读取，如果读取不到再从缓存中读取。这样就可以保证CPU总是能读取到自己写入的最新值。\n\n\nInvalidate Queue\nStore Buffer发送给其他CPU的invalidate消息之后，需要等待其他CPU设置缓存失效并返回invalidate ack消息，才能执行更新缓存和内存的操作。而其他CPU有可能忙于其他事情，导致来不及设置缓存失效和回复invalidate ack消息，这样写操作便会堆积在Store Buffer中很长时间。\nStore Buffer的存储空间很小，当有大量写操作堆积在Store Buffer中等待执行，导致Store Buffer无法存储更多数据时，CPU往Store Buffer中存储新的写操作，便会阻塞等待，此时，Store Buffer便失去了作用。\n为了解决这个问题，计算机科学家又引入了一个新的存储结构: Invalidate Queue，专门用来存储invlidate消息和回复invalidateack消息，并异步执行设置缓存行失效操作。这样就进一步节省了Store Buffer处理写操作的时间，能够让Store Buffer尽快清空。\n\n\nJIT编译时，会进行一定的编译优化，所以有时判断真假的语句会直接将变量转换为true或false，解决这种情况的方法时：禁止JIT编译来运行代码，或者将变量声明为volatile后JIT就不会优化\n\n2.指令重排导致有序性问题\n通过指令重排序可以提高指令的运行效率，但是会出现问题使得执行结果不确定，如下所示，因为t2线程执行的两行代码没有任何联系，会发生指令重排，在多核情况下t1和t2同时运行，t2代码的执行顺序会影响到t1的输出\npublic class Demo &#123;\n    private static boolean ready &#x3D; false;\n    private static int value &#x3D; 1;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                while (!ready) &#123;\n                &#125;\n                System.out.println(value);\n            &#125;\n        &#125;);\n        Thread t2 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                value &#x3D; 2;\n                ready &#x3D; true;\n            &#125;\n        &#125;);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n    &#125;\n&#125;\n在代码的编译执行过程中，会发生3种不同类型的重排序：\n\n编译优化导致的重排序（见JVM）\nCPU指令并行执行导致的重排序（如上代码）：为了提高指令的执行效率，现在的处理器大都采用指令级并行技术（Instruction-Level Parallelism，简称IPL），来并行的执行多条指令。CPU从内存中逐一读取并解码指令，然后放入执行队列，每次从执行队列中选择没有依赖关系的几条指令来并行执行。在多线程情况下就会出现指令顺序的重排序\n硬件内存模型导致的重排序\n\n\n\n3.线程竞争导致原子性问题\n多个线程同时读写一个数据，会导致结果不确定，因为是非原子操作。\n\n4.volatile\n解决可见性问题：用volatile修饰的变量，在编译成机器指令时，会加入特殊指令，使得CPU对此变量的修改立即写入内存，并通过其它CPU更新缓存数据\n\n解决有序性问题：volatile通过禁止指令重排序来解决有序性问题，并且是部分指令重排\n\n完全禁止指令重排：volatile修饰的变量的读写指令不可以跟其前面或后面的读写指令重排\n\n部分禁止指令重排：也可以保证多线程运行的有序性，规则有：\n\n对volatile修饰的变量执行写操作，JMM只禁止位于其起前面的读写操作不与其进行重排序，但后面的可以\n对volatile修饰的变量执行读操作，JMM只禁止位于其起后面的读写操作不与其进行重排序，但前面的可以\n\n\n内存屏障（Memory Barrier）：为了实现部分指令重排，JMM定义了4个细粒度的内存屏障，也叫做内存栅栏（Memory Fence），其底层依赖CPU提供的内存屏障指令。分别是StoreStore、StoreLoad、LoadLoad、LoadStore，指令含义为：StoreStore内存屏障禁止屏障前面的写操作，跟屏障后面的写操作重排序。StoreLoad内存屏障禁止屏障前的写操作，跟屏障后的读操作重排序。LoadStore内存屏障禁止屏障前的读操作，跟屏障后的写操作重排序。LoadLoad内存屏障禁止屏障前的读操作，跟屏障后的读操作重排序。\n\n\nJMM内存模型定义部分禁止重排序的方法：volatile写操作后或者volatile读操作前会添加[StoreLoad]来防止volatile写和读的重排序，一般选择添加在写后面，因为读多写少。\n\n\n\n对于X86 CPU来说只需要在volatile写操作后添加一条额外的指令，所以volatile的性能比synchronized更好\n内存屏障也可以用来禁止编译优化（JIT编译）导致的指令重排序\n\n\n\n\n解决原子性问题：\n\n在32位计算机上，读写64位的long或double类型数据，会执行两次内存读写操作，如果用volatile修饰，那么编译器会在两次读或写之间锁定总线指令，保证变量读写的原子性，但在64位机上就不需要了\n自增语句（count++）因为是对寄存器的值进行操作，但是volatile对变量只能保证立刻写入内存让所有CPU的缓存失败，所以不能影响寄存器内的值，需要synchronized关键字\n\n\n\n5.synchronized&amp;final\nsynchronized：通过让原本并发执行的代码串行执行，并且每次加锁和释放锁，都会同步CPU缓存和内存中的数据，可以解决可见性、有序性、原子性的问题\nfinal\nfinal用来限制变量是否可变\nJMM对final的语义做了增强，禁止编译器将构造函数中对final变量的写操作，重排序到对象引用之后，也就是禁止初始化对象（构造函数中的语句）和将内存空间赋值给引用的重排序，否则在多线程环境下，一个线程可能看到final变量的两个不同的值\n\n\n\n6.happens-before规则\n\n\n\n\n\n\n\n\n用于检查自己编写的代码在多线程下的执行顺序是否符合预期\n\n单线程规则:在单线程中，前面的操作先于后面的操作执行。但是编译器可以偷偷的重排序\n锁规则:一个线程释放锁先于另一个线程获取锁。\nvolatile规则:在时间序上，如果对一个volatile变量的写操作，先于后面的对这个变量的读操作执行，那么，volatile读操作必定能读到volatile写操作的结果。也就是说，如果x为volatile变量，在t1时刻执行了x=1，在t2时刻执行了y=x， t1小于t2，那么y肯定等于1。不管编译器或者CPU会如何优化指令的执行顺序，都能保证这个结果。\n线程启动规则:如果线程A在执行过程中，启动了线程B，那么，线程A对共享变量的修改对线程B可见。\n线程终结规则:如果线程A在执行的过程中，通过Thread.join()等待钱程B终止，那么，线程B对共享变量的修改，在线程B终止之后，对线程A可见。\n线程中断规则:线程A对线程B调用interrupt()方法，先行发生于线程B的代码检测到中断事件的发生。\n对象终结规则:一个对象的初始化完成，先行发生于调用它的finalize()方法。\n传递规则:如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。\n\n3.互斥锁\n\n\n\n\n\n\n\n\n临界区互斥的手段，提供了各种不同粒度和作用的锁，最大限度的减小加锁范围，提高代码并发执行程度。基本功能：多个线程进程获取锁，没有得到的排队阻塞等待并且不分配时间片，锁释放后会通知排队等待的锁，得到锁后取消阻塞，并且给相应的内核线程分配时间片\n1.Synchronized\n对象锁\n\n方法：在方法的声明上加synchronized关键字\n&#x2F;&#x2F;两个方法加了相同的锁，函数本身不可并发执行，函数间也不可并发执行\npublic class Counter &#123;\n    private int count &#x3D; 0;\n    public synchronized void add(int value) &#123;\n        count +&#x3D; value;\n    &#125;\n    public synchronized void substract(int value)&#123;\n        count -&#x3D; value;\n    &#125;\n&#125;\n局部代码块：为了提高代码执行的并发度，减小加锁范围\npublic class Counter &#123;\n    private int count &#x3D; 0;\n    public void add(int value)&#123;\n        synchronized (this) &#123;\n            count +&#x3D; value;\n        &#125;\n    &#125;\n    public void substract(int value) &#123;\n        synchronized (this) &#123;\n            count -&#x3D; value;&#125;\n    &#125;\n&#125;\n\nsynchronized底层使用的锁叫做Monitor锁，无法直接创建和使用，Monitor锁是寄生存在的，每个对象都会拥有一个。如果想要一个新的Monitor锁只需要使用一个新的对象，并在synchronized关键字后附带声明要使用哪个对象的Monitor锁。不加声明隐式的使用this\npublic class Counter &#123;\n    private int increasedsum &#x3D; 0;\n    private int decreasedsum &#x3D; 0;\n    private Object obj1 &#x3D; new Object();\n    private Object obj2 &#x3D; new Object();\n    \n    public void add(int value)&#123;\n        synchronized (obj1) &#123;\n            increasedSum +&#x3D; value;\n        &#125;\n    &#125;\n    public void substract(int value) &#123;\n        synchronized (obj2)&#123;\n            decreasedsum -&#x3D; value;\n        &#125;\n    &#125;\n&#125;\n\n\n类锁\n\n对象锁只能保证一个对象上的函数不能并发执行，但是为了做到不仅一个对象的某个函数不能并发执行，同一个类的所有对象的这个函数都不能并发执行，所以使用类锁代替对象锁，即synchronized后跟随某个类的Class对象即可\npublic class Wallet &#123;\n    private int balance;\n    public void transferTo(Wallet targetwallet, int amount) &#123;\n        synchronized (Wallet.class) &#123;\n            if (this.balance &gt;&#x3D; amount) &#123;\n                this.balance -&#x3D; amount;\n                targetWallet.balance +&#x3D; amount;&#125;\n        &#125;\n    &#125;\n&#125;\n对于对象锁，synchronized底层使用的是对象上的Monitor锁；对于类锁synchronized使用的也是某个对象上的Monitor锁，只不过这个对象是类的Class类对象，class类对象是所有类的抽象，每个类再JVM中都有一个Class类对象来表示这个类\n\n除了显示声明类锁，对静态方法加synchronized也会隐式地使用当前类的类锁\n\n\n\n字节码：只是简单的翻译了synchronized\n\n作用于方法：在flags中添加了ACC_SYNCHRONIZED标记，其它部分不变\n作用域局部代码块：字节码通过monitorenter和monitorexit来标记synchronized的作用范围\n有可能由多个monitorexit对应着抛出异常后仍能解锁\nsynchronized可以选择任意对象的Monitor锁，通过monitorenter前面的几行字解码来表示用了哪个对象的Monitor锁\n\n\n\n\n锁类别：为了提高加解锁的效率，在不同场景下使用不同的锁来实现\n\n重量级锁，即Monitor锁，synchronized锁被多个线程交叉使用，存在竞争使用的情况\n\n不同JVM有不同的实现版本，在Hotspot JVM实现中，Monitor锁对应的实现类为ObjectMonitor\nclass ObjectlMonitor &#123;\n    void * volatile _object;&#x2F;&#x2F;该Monitor锁所属的对象\n    void * volatile _owner;&#x2F;&#x2F;获取到该Monitor锁的线程\n    ObjectWaiter * volatile_cxq;&#x2F;&#x2F;没有获取到锁的线程暂时加入_cxq\n    ObjectWaiter * volatile _EntryList;&#x2F;&#x2F;存储等待被唤醒的线程\n    &#x2F;&#x2F;存储调用了wait()的线程，用来实现wait()、notify()线程同步功能\n    ObjectWaiter * volatile _waitSet;\n    &#x2F;&#x2F;...\n&#125;\n通过对象查找到对应的Monitor锁：对象头中的Mark Word字段便可以用来记录对象所对应的Monitor锁\n\n\n\nMark Word字段\n\n\n\nObjectMonitor中互斥锁基本功能的实现：\n\n多个线程竞争获取锁：\n\n通过CAS操作来设置_owner字段，谁设置成功，谁获取这个Moitor锁\n参与竞争的线程会先检查_owner是否是null，如果是再将自己的Thread对象地址赋值给_owner\n底层JVM依靠CPU提供的cmpxchg指令来实现CAS操作，CPU通过总线锁来保证cmpxchg指令的原子性来保证CAS操作的线程的线程安全性，相当于在硬件层面上给CAS操作加了锁\n\n\n没有获取到锁的线程队等待获取锁：在_cxq中等待锁，_cxq是一个单向链表，链表节点定义为class Objectwaiter : public StackObj，里面包含线程的信息和结构信息\n\n锁释放之后会通知排队等待的锁去竞争锁：\n\n当持有锁的线程释放锁之后，会从_EntryList取出一个线程，通过CAS来竞争获取Monitor锁（防止有新来的）。\n如果_EntryList中没有线程，就将_cxq中的线程全部移到_EntryList中，因为可以减少多线程环境下链表存取操作的冲突。_cxq只负责将存操作（往链表中添加节点)，_EntryList负责取操作(从链表中删除节点)。\n\n\n没有获取锁的线程会阻塞，并且对应的内核线程不再被分配时间片：应用程序将代码提交给Java线程（Runnable接口中的run()中的代码），当内核线程执行到synchronized关键字，会执行上述的1-3个步骤，如果没得到锁则嗲用park()函数将自己阻塞，Linux下实现如下：\npthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;\nvoid park() &#123;\n    pthread_mutex_lock(&amp;mutex);\n    pthread_cond_wait(&amp;cond,&amp;mutex);&#x2F;&#x2F;阻塞等待其他线程发送信号\n    pthread_mutex_unlock(&amp;mutex);\n&#125;\n阻塞线程获取到锁之后取消阻塞，并且对应的内核线程将被分配时间片：通过调用unpark()函数来取消对应内核线程的阻塞状态，来让它去执行竞争锁的代码。Linux下实现如下：\nvoid unpark()&#123;\n    pthread_mutex_lock(&amp;mutex);\n    pthread _cond_signal(&amp;cond);\n    pthread_mutex_unlock(&amp;mutex);\n&#125;\n\n\n\n\n偏向锁：一个synchronized锁只被一个线程使用\n\n新创建的对象，Mark Word处于无锁状态（可跳过），并随即很快变为偏向锁状态，并且threadID为0。如果某个线程在某个对象上使用synchronized关键字，发现其处于偏向锁状态且threadID为0，那么就通过CPU提供的CAS原子操作来竞争这个偏向锁（看Mark Word是否等于5，若等于在设置threadID为自己的线程ID）\n获得到锁的情况：执行业务代码（synchronized包裹的代码），执行完不会解锁偏向锁，即不会更改theadID为0，为了提高同一线程再次加锁的效率（减少CAS操作的次数）\n没获得到锁的情况：\n问题：一个线程获取锁，另一个线程来请求；或者更特殊情况，两个线程竞争偏向锁，只有一个得到。\n解决：请求偏向锁的线程将锁升级为轻量级锁，升级过程中虚拟机暂停持有偏向锁的线程，查看是否在运行synchronized内的代码。如果已不再使用，虚拟机就像Mark Word设置为无锁状态；如果还在使用，虚拟机就将偏向锁升级为轻量级锁\n暂停的原因：检查是否运行synchronized的代码是复合操作，非线程安全\n如何暂停：因为挂机线程的系统调用在不同平台上不一样，而且有时会导致IO出问题，所以虚拟机选择复用垃圾收集器中的STW（Stop The World）功能\n未在使用时可不可以跳过无锁状态继续保持偏向锁（只把ThreadID设置为0），将偏向锁移交给另一线程使用：STW会暂停所有线程，偏向锁升级代价大，如果将偏向锁交给另一线程就可能带来更多的STW操作，不如直接使用重量级锁\n\n\n\n\n\n\n轻量级锁：一个synchronized锁被多个线程交叉使用，不存在竞争使用的情况\n\nMark Word处于无锁状态：线程会先在自己栈中创建一个Lock Record结构（用于解锁时快速恢复为无d锁状态），并将Mark Word拷贝到此结构中的Displaced Mark Word中。然后线程通过CAS操作去竞争轻量级锁，先检查Mark Word的低三位是否为001（无锁状态），如果是的话再将Mark Word中的Lock Record指针设置为指向自己的Lock Record\nMark Word处于轻量级锁状态：暂缓升级为重量级锁，通过自旋的方式循环执行CAS操作，如果执行了很多次之后，仍然没有等到另一个线程释放轻量级锁，那么就将其升级为重量级锁\n自适应自旋：针对所有在用的轻量级锁，如果上次自旋之后成功等到了另一个线程释放轻量级锁，那么下次自旋的次数就增加，如果上次自旋没有等到等到另一个线程释放轻量级锁，那么下次自旋的次数就减少。\n锁升级：通过CAS操作，持有锁的线程继续执行，请求锁的线程负责升级任务，包括创建Monitor锁，将自己放到Monitor锁的_cxq中，调用OS系统调用来阻塞自己\n解锁：先检查锁标志位，如果标记为00，说明没有升级，只需要使用CAS操作解锁即可（先检查是否为00，再将Displaced Mark Word）赋值给Mark Word；如果锁标识为10，即已升级为重量级锁，那么持有轻量级锁的线程去唤醒等待重量级锁的进程\n\n\n\n\n\n\n其他优化\n\n锁消除：虚拟机在执行JIT编译时，会根据对代码的分析(逃逸分析)，去掉某些没有必要的锁。如下示例代码所示。为了保证多线程操作的安全性，StringBuffer中的append()函数在设计实现时加了锁。但是，在下面的代码中，strBuffer是局部变量，不会被多线程共享，更不会在多线程环境下调用它的append()函数。因此append()函数的锁可以被优化消除。\npublic class Demo &#123;\n    public String concat(String s1, string s2)&#123;\n        stringBuffer strBuffer &#x3D; new StringBuffer();\n        strBuffer.append(s1);\n        strBuffer.append(s2);\n        return strBuffer.tostring0);\n    &#125;\n&#125;\n锁粗化：缩小加锁范围能够提高程序的并发程度，提高多线程环境下的程序的执行效率。但是，在有些情况下，虚拟机在执行JIT编译时，会扩大加锁范围，将对多个小范围代码的加锁，合并一个对大范围代码的加锁，这样的做法叫做锁粗化。如下所示代码所示，执行10000次append()函数，会加锁解锁10000次。通过锁粗化，编译器将append()函数的锁去掉，移到for循环外面，这样就只需要加锁解锁1次即可。\npublic class Demo&#123;\n    private StringBuffer strBuffer;\n    public void reproduce(String s)&#123;\n        for (int i &#x3D; 0, i &lt;10000;++i)&#123;\n            strBuffer.append(s);\n        &#125;\n    &#125;\n&#125;\n\n\n\n2.Lock1.Lock\n概述\n\n\nLock接口，因为平常用到的都是可重入锁，所以只有一个实现类ReentrantLock\npublic interface Lock &#123;\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLocK();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlocK();\n    Condition newCondition();\n&#125;\nReadWriteLock接口，同上也只有一个实现类ReetrantReadWriteLock\npublic interface ReadWriteLock &#123;\n    Lock readLock();\n    Lock writeLock();\n&#125;\n\nStampedLock是对ReadWriteLock锁的优化，在ReadWriteLock锁的基础上引入了读乐观锁\n\n\n\n可重入锁：可以被同一个线程多次加锁的锁，即在锁没有解锁前，再次加锁，通过变量记录重入次数。JUC提供的锁都是可重入锁。如下，getEvenSeq中调用了increment，如果不是可重入锁的话，increment等待getEvenSeq释放锁，就会出现死锁情况。\npublic class Demo &#123;\n    Lock lock &#x3D; new ReentrantLock();\n    private int seq &#x3D; 0;\n    public int getEvenSeq() &#123;\n        lock.locK();\n        try &#123;\n            if (seq%2 &#x3D;&#x3D; 1)&#123;\n                increment();\n            &#125;\n            return seq;\n        &#125;finally &#123;\n            &#x2F;&#x2F;放在finally里是为了避免代码抛出异常导致锁无法释放，从而产生死锁问题\n            lock.unlock();\n        &#125;\n    &#125;\n    public void increment()&#123;\n        lock.lock();\n        seq++;\n        lock.unlock();\n    &#125;\n&#125;\n\n公平锁：对于公平锁，线程会按照请求的先后顺序获得锁。synchronized锁是非公平锁（新请求可插队），ReentrantLock既支持公平锁也支持非公平锁，默认为非公平锁，通过在构造函数中添加true可声明为公平锁。非公平锁的性能比公平锁更好。ReentrantLock通过AQS（抽象队列同步器）来排队等待锁的线程\n\n可中断锁：\n\n对于synchronized来说，一个线程在阻塞等待锁时，是无法响应中断的，即不可被打断。JUC Lock接口提供了lockInterruptibly()函数，支持可响应中断的方式来请求锁。\n可中断锁一般用于线程池中，方便关闭正在执行的线程，如Nginx中调用stop命令关闭服务器时通过中断的方式中止等待锁的线程，示例代码如下\n\npublic class Demo &#123;\n    private static Lock lock &#x3D; new ReentrantLock();\n    public static void main(String[] args)&#123;\n        Thread t1 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    lock.lockInterruptibly();&#x2F;&#x2F;以可中断的方式请求锁\n                &#125;catch (InterruptedException e) &#123;\n                    system.out.printIln(&quot;I am interrupted&quot;);\n                    return;\n                &#125;\n                try &#123;\n                    system.out.printIn(&quot;l got lock&quot;);\n                &#125; finally &#123;\n                    lock.unlocK();\n                &#125;\n            &#125;\n        &#125;);\n        lock.Iock();&#x2F;&#x2F;主线程先获得锁并一直持有\n        t1.start();&#x2F;&#x2F;t1线程启动，调用lockInterruptibly请求锁，因锁被主线程持有，所以阻塞等待\n        t1.interrupt();&#x2F;&#x2F;主线程向t1线程发起中断，t1线程退出阻塞，响应中断，打印&quot;I am ... &quot;\n        lock.unlocK();\n    &#125;\n&#125;\n非阻塞锁：JUC提供了tryLock()函数，支持非阻塞的方式获取锁，如果锁已经被其他线程获取，则不阻塞直接返回\npublic class Demo &#123;\n    private Lock lock &#x3D; new ReetrantLock();\n    public void useTryLock()&#123;\n        if (lock.tryLock())&#123;\n            try &#123;\n                &#x2F;&#x2F; ...执行业务代码...\n            &#125;finally &#123;\n                lock.unlock();&#125;\n        &#125;else &#123;\n            &#x2F;&#x2F; ...没有获取锁，执行其他业务代码..\n        &#125;\n    &#125;\n&#125;\n可超时锁：\n\nJUC提供了带参数的tryLock()函数，支持非阻塞获取锁的同时设置超时时间，即获取锁失败时，阻塞等待一会，直到超过了设定的时间，直接返回。tryLock()也可被中断。\n应用场景：对响应时间敏感的系统，比如面向用户的系统。比如Tomcat等服务器采用线程池的方式并发执行用户请求，如果某个特殊请求不能并发执行需要加锁，并且请求执行时间较长，当多个线程同时执行这个请求时，就会存在有线程长时间无法获得锁而请求无法执行的情况，从而导致用户请求超时和线程数量变少请求超时的问题\n底层实现\n\npublic class Demo &#123;\n    private Lock lock &#x3D; new ReentrantLock();\n    public void useTryLockWithTimeout()&#123;\n        boolean locked &#x3D; false;\n        try &#123;\n            locked &#x3D; lock.tryLock(100,TimeUnit.MILLISECONDS);\n        &#125; catch (InterruptedException e) &#123;\n            system.out.printIn(&quot;I am interrupted&quot;);\n        &#125;\n        if (locked) &#123;\n            try &#123;\n                &#x2F;&#x2F;...执行业务代码...\n            &#125; finally &#123;\n                lock.unlocK();\n            &#125;\n        &#125;else &#123;\n            &#x2F;&#x2F; ...没有获取锁，执行其他业务代码...\n        &#125;\n    &#125;\n&#125;\n读写锁：\n\n为了提到并发度，可多次获得读锁，JUC提供了ReadWrite接口和其实现类ReetrantReadWriteLock。读锁是一种共享锁，可以被多个线程同时获取，写锁时排他锁，同时只能被一个线程获取，读写锁之间也是排他的，有以下几种情况\n如果有线程已经获取读锁，那么，请求写锁的线程将会排队等待。\n如果有线程已经获取读锁，并且没有线程在排队等待写锁，那么，请求读锁的线程会直接获取读锁。\n如果有线程已经获取到读锁，并且有线程在排队等待写锁，那么，请求读锁或者写锁的线程都将排队等待。这样可以避免等待写锁的线程迟迟获取不到写锁。\n如果有线程已经获取到写锁，那么请求读锁或写锁的线程都将排队等待。\n\n\n原理\n\npublic class Demo &#123;\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    private ReadWriteLock rwLock &#x3D; new ReentrantReadvriteLock();\n    private Lock rLock &#x3D; rwLock.readLock();\n    private Lock wLock &#x3D; rwLock.writeLocK();\n    public void add(int idx, String elem)&#123;\n        wLock.lock();\n        try &#123;\n            list.add(idx, elem);\n        &#125; finally &#123;\n            wLock.unlocK();\n        &#125;\n    &#125;\n    public String get(int idx)&#123;\n        rLock.locK();\n        try &#123;\n            return list.get( idx);\n        &#125; finally &#123;\n            rLock. unlock();\n        &#125;\n    &#125;\n&#125;\n乐观读锁：StampedLock是对ReadWriteLock的进一步优化，提供了读锁、写锁和乐观读锁，其中的读锁和写锁与ReadWriteLock中的类似，乐观读锁是对读锁的进一步优化，在读多写少的时候，大部分读操作都不会被写操作干扰，因此连读锁都不需要加，只有验证真正有被写操作干扰的情况下，再加读锁即可\npublic class Demo &#123;\n    private stampedLock slock &#x3D; new stampedLock();\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    public void add(int idx, String elem)&#123;\n        long stamp &#x3D; slock.writeLock();&#x2F;&#x2F;申请写锁\n        try &#123;\n            list.add(idx, elem);\n        &#125;finally &#123;\n            slock.unlockWrite(stamp);\n        &#125;\n    &#125;\n    public String get(int idx)&#123;\n        &#x2F;&#x2F;申请乐观读锁，返回时间戳，再执行完读操作之后，验证stamp是否被更改\n        long stamp &#x3D; slock.tryOptimisticRead(); \n        String res &#x3D; list.get(idx);\n        if (slock.validate(stamp))&#123;&#x2F;&#x2F;没写操作干扰\n            return res;\n        &#125;\n        &#x2F;&#x2F;有写操作干扰，重新使用读锁\n        stamp &#x3D; slock.readLock();&#x2F;&#x2F;申请读锁\n        try &#123;\n            return list.get(idx);&#x2F;&#x2F;之前得到的结果需要作废\n        &#125;finally &#123;\n            slock.unlockRead(stamp);\n        &#125;\n    &#125;\n&#125;\n\n2.AQS\n简介：全称为AbstractQueueSynchronizer，即抽象队列同步器，与synchronized底层的ObjectMonitor类相似，都实现了排队线程、阻塞线程和唤醒线程等功能，但只有一个队列。但是AQS是在JDK中基于Java语言实现，因为JUC只是JDK中的一个工具包\n\n数据结构\npublic abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable &#123;\n\n    private transient volatile Node head;\n    private transient volatile Node tail;\n    private volatile int state;\n&#125;\npublic abstract class AbstractOwnableSynchronizer\n    implements java.io.Serializable &#123;\n    private transient Thread exclusiveOwnerThread;\n&#125;\n\n\nstate：用于在多个线程竞争锁时，谁设置成功了，谁获得锁。0为无人获得锁，1为有人获得锁，大于1的数表示重入的次数。多个线程竞争锁时，通过如下CAS操作来更新state的值。先检查是否为0，如果是的话，就设置为1，谁设置成功了，谁就获得了这个锁。\nprotected final boolean compareAndSetState(int expect, int update) &#123;\n    &#x2F;&#x2F;底层仍然依靠硬件提供的原子CAS指令来实现\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n&#125;\nexclusiveOwnerThread：存储持有锁的线程，配合state成员变量，实现锁的重入机制\n\nhead和tail：实现了一个双向链表的队列，Node节点定义如下\nstatic final class Node &#123;\n\n    static final Node SHARED &#x3D; new Node();\n    static final Node EXCLUSIVE &#x3D; null;\n\n    static final int CANCELLED &#x3D;  1;\n    static final int SIGNAL    &#x3D; -1;\n    static final int CONDITION &#x3D; -2;\n    static final int PROPAGATE &#x3D; -3;\n\n    volatile int waitStatus;\n    volatile Node prev;\n    volatile Node next;\n    volatile Thread thread;\n    Node nextWaiter;\n\n    final boolean isShared() &#123;\n        return nextWaiter &#x3D;&#x3D; SHARED;\n    &#125;\n    final Node predecessor() throws NullPointerException &#123;\n        Node p &#x3D; prev;\n        if (p &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        else\n            return p;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n\n基本原理：使用了模板方法模式\n\nAQS定义了8个模板方法，可以分为两组：独占模式和共享模式。Lock为排他锁，底层只会用到AQS的独占模式，ReadWriteLock中的读锁为共享锁，写锁为排他锁，其底层会用到两种模式，Semaphore、CountdownLatch这些工具只会用到共享模式\n&#x2F;&#x2F;独占模式\npublic final void acquire(int arg) &#123; ...&#125;\npublic final void acquirelnterruptibly(int arg)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean release(int arg) &#123; ...&#125;\n&#x2F;&#x2F;共享模式\npublic final void acquireShared(int arg) &#123; ...&#125;\npublic final void acquireSharedInterruptibly(int arg)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean releaseShared(int arg) &#123; ...&#125;\nAQS提供了4个抽象方法：没有声明为abstract是为了减少代码量，更灵活编写代码\n&#x2F;&#x2F;独占模式\nprotected boolean tryAcquire(int arg)&#123;\n\t\t\t\t\t\tthrow new UnsupportedOperationException();&#125;\nprotected boolean tryRelease(int arg)&#123;\n\t\t\t\t\t\tthrow new UnsupportedOperationException();&#125;\n&#x2F;&#x2F;共享模式\nprotected int tryAcquireShared(int arg) &#123;\n\t\t\t\t\t\tthrow new UnsupportedOperationException();&#125;\nprotected boolean tryReleaseShared(int arg) &#123;\n    \t\t\t\t\tthrow new UnsupportedOperationException();&#125;\n示例：ReetrantLock，其部分代码如下，定义了两个继承自AQS的子类：NofairSync和FairSync，分别用来实现非公平锁和公平锁，并且因为底层释放锁的逻辑相同，故又抽象出公共父类Sync\npublic class ReentrantLock implements Lock, java.io.Serializable &#123;\n    private final sync sync;\n    \n    abstract static class Sync extends AbstractQueuedSynchronizer &#123; ...&#125;\n    static final class NonfairSync extends Sync &#123; ...&#125;\n\tstatic final class FairSync extends Sync &#123; ...&#125;\n    \n\tpublic ReentrantLock()&#123;\n\t\tsync &#x3D; new NonfairSync();\n    &#125;\n\tpublic ReentrantLock(boolean fair) &#123;\n\t\tsync &#x3D; fair ? new FairSync() : new NonfairSync();\n    &#125;\n        \n\tpublic void lock()&#123;sync.acquire(1);&#125;\n\tpublic void unlock() &#123;sync.release(1);&#125;\n\t&#x2F;&#x2F;...省略其他方法...\n    &#125;\n&#125;\n\n\nacquire()模板方法\npublic final void acquire(int arg) &#123;\n    &#x2F;&#x2F;1.调用tryAcquire去竞争获取锁，如果成功，则直接返回\n    &#x2F;&#x2F;2.调用addWaiter，将线程包裹为Node节点放入等待队列的尾部\n    &#x2F;&#x2F;3.调用acquireQueued阻塞当前线程，\n    if ( !tryAcquire(arg) &amp;&amp; acquireQueued( addWaiter(Node.EXCLUSIVE), arg ) )\n        &#x2F;&#x2F;用来处理中断，如果在等待锁的过程中，被其它线程中断，\n        &#x2F;&#x2F;则在获取锁之后，将现成的中断标记设置为true\n        selfInterrupt();\n&#125;\n\nstatic final class NonfairSync extends Sync &#123;\n    &#x2F;&#x2F;尝试获取锁，成功返回true，失败返回false。AQS用于实现锁时，acquires&#x3D;1\n    protected final boolean tryAcquire(int acquires)&#123;\n        final Thread current &#x3D; Thread.currentThread();\n        int c &#x3D; getState(); &#x2F;&#x2F;获取state值\n        if (c &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;锁没有被其他线程占用\n            if (compareAndSetstate(0,acquires)) &#123; &#x2F;&#x2F;CAS设置state值为1\n                setExclusiveOwnerThread(current);&#x2F;&#x2F;设置exclusiveownerThread\n                return true;&#x2F;&#x2F;获取锁成功\n            &#125;\n        &#125;else if (current &#x3D;&#x3D; getExclusiveOwnerThread())&#123;&#x2F;&#x2F;锁已被自己占用，可重入\n            int nextc &#x3D; c + acquires; &#x2F;&#x2F; state+1\n            if (nextc &lt; 0)&#x2F;&#x2F;重入次数太多，超过了int最大值，溢出为负数，此情况罕见\n                throw new Error(&quot;Maximum lock count exceeded&quot;);\n            setState(nextc); &#x2F;&#x2F; state&#x3D;state+1,state记录重入的次数，解锁的时候用\n            return true;&#x2F;&#x2F;获取锁成功\n        &#125;\n        return false;&#x2F;&#x2F;获取锁失败\n    &#125;\n&#125;\nstatic final class FairSync extends Sync &#123;\n    protected final boolean tryAcquire(int acquires) &#123;\n        final Thread current &#x3D; Thread.currentThread();int c &#x3D; getState();\n        if (c &#x3D;&#x3D; 0)&#123;\n            if (!hasQueuedPredecessors() &amp;&amp;&#x2F;&#x2F;等待队列中没有线程时才获取锁\n                compareAndSetstate(0, acquires))&#123;\n                setExclusiveownerThread(current);\n                return true;\n            &#125;\n        &#125;else if (current &#x3D;&#x3D; getExclusiveOwnerThread())&#123;\n            int nextc &#x3D; C + acquires;\n            if (nextc &lt; 0)\n                throw new Error(&quot;Maximum lock count exceeded&quot;);setState(nextc);\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;通过自旋和CAS操作解决往链表尾部添加节点和特殊处理链表为空所存在的线程安全问题\nprivate Node addWaiter(Node mode)&#123;\n    Node node &#x3D; new Node(Thread.currentThread(), mode);\n    &#x2F;&#x2F;自旋执行CAS操作，直到成功为止\n    for (;;) &#123;\n        Node t &#x3D; tail;\n        if (t &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;链表为空，添加虚拟头节点\n            &#x2F;&#x2F;CAS操作解决添加虚拟头节点的线程安全问题\n            if (compareAndSetHead(null, new Node()))\n                tail &#x3D; head;\n        &#125;else &#123;&#x2F;&#x2F;链表不为空\n            node.prev &#x3D; t;\n            &#x2F;&#x2F;CAS操作解决了同时往链表尾部添加节点时的线程安全问题\n            if (compareAndSetTail(t, node)) &#123;\n                t.next &#x3D; node;\n                return t;\n            &#125;\n        &#125;\n    &#125;\n    return node;\n&#125;\n&#x2F;&#x2F;主要有两部分逻辑，使用tryAcquire函数来竞争锁和使用park()函数来阻塞线程\n&#x2F;&#x2F;采用for循环来交替执行这两个逻辑，为了在吸纳成被唤醒后，并不是直接获取锁，\n&#x2F;&#x2F;而是重新竞争锁，如果竞争失败，则需要再次被阻塞\nfinal boolean acquireQueued(final Node node, int arg) &#123;\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;)&#123;\n            &#x2F;&#x2F;使用tryAcquire()函数来竞争锁\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return interrupted;\n            &#125;\n            &#x2F;&#x2F;调用park()函数来阻塞线程，等待其他线程调用unpark()函数唤醒\n            if (parkAndCheckInterrupt()) interrupted &#x3D; true;\n        &#125;\n    &#125;finally &#123;\n        if (failed) cancelAcquire(node);\n    &#125;\n&#125;\nprivate final boolean parkAndChecklnterrupt() &#123;\n    LockSupport.park(this);&#x2F;&#x2F;底层也是调用JVM提供的native park()函数来实现\n    return Thread.interrupted();\n&#125;\nrelease()模板方法\npublic final boolean release(int arg) &#123;\n    &#x2F;&#x2F;tryRelease释放锁\n    if (tryRelease(arg)) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)\n            unparkSuccessor(h);&#x2F;&#x2F;内部调用unpark()函数，唤醒链表首节点对应的线程\n        return true;\n    &#125;\n    return false;\n&#125;\n&#x2F;&#x2F;公平锁和非公平锁的实现相同\nstatic final class Sync extends AbstractQueuedSynchronizer &#123;\n    &#x2F;&#x2F;释放锁，成功返回true，失败返回false。AQS用于实现锁时，releases&#x3D;1\n    protected final boolean tryRelease(int releases)&#123;\n        int c &#x3D; getState() - releases; &#x2F;&#x2F;state-1\n        &#x2F;&#x2F;不持有锁的线程去释放锁，抛出异常\n        if (Thread.currentThread() !&#x3D; getExclusiveownerThread())\n            throw new lllegalMonitorStateException();\n        boolean free &#x3D; false;\n        if (c &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;stat-1之后为0，解锁\n            free &#x3D; true;\n            setExclusiveownerThread(null);\n        &#125;\n        setState(c); &#x2F;&#x2F;state-1之后不为0，说明锁被重入多次，还不能解锁。\n        return free;\n    &#125;\n&#125;\n\n\n\n\n中断机制：独占模式下的另两个acquirelnterruptibly和tryAcquireNanos分别用于实现ReetrantLock中的locklnterruptibly()函数和带超时时间的tryLock()函数。\npublic void lockInterruptibly() throws InterruptedException &#123;\n    sync.acquirelnterruptibly(1);\n&#125;\n&#x2F;&#x2F;如果线程中断则抛出异常，否则。调用tryAcquire()竞争获取锁，\n&#x2F;&#x2F;获得失败后调用doAcquireInterruptibly\npublic final void acquirelnterruptibly(int arg) throws InterruptedException &#123;\n    if (Thread.interrupted()) throw new InterruptedException();\n    if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n&#125;\n&#x2F;&#x2F;与acquireQueued()函数的代码非常相似，唯一区别是对中断的响应处理不同\nprivate void doAcquireInterruptibly(int arg) throws InterruptedException &#123;\n    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n    boolean failed &#x3D; true;\n    try &#123;\n        for(;;)&#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return;\n            &#125;\n            if (parkAndChecklnterrupt())\n                throw new lnterruptedException(); &#x2F;&#x2F;区别:抛出异常! 阻止等待锁\n        &#125;\n    &#125;finally &#123;\n        if (failed) \n            cancelAcquire(node);&#125;\n&#125;\n\n超时机制\npublic boolean tryLock(long timeout,TimeUnit unit)\n    throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1 , unit.toNanos(timeout));\n&#125;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n    throws InterruptedException &#123;\n    &#x2F;&#x2F;如果线程被中断则抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    &#x2F;&#x2F;调用tryAcquire竞争获取锁，成功则返回，失败则调用doAcquireNanos\n    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);\n&#125;\n&#x2F;&#x2F;在acquirelnterruptibly函数基础上，添加了对超时的处理机制\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n    throws InterruptedException &#123;\n    if (nanosTimeout &lt;&#x3D; 0L) return false;\n    final long deadline &#x3D; System.nanoTime() + nanosTimeout;\n    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n    boolean failed &#x3D; true;\n    try &#123;\n        for (;;)&#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg))&#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return true;\n            &#125;\n            nanosTimeout &#x3D; deadline - System.nanoTime();\n            if (nanosTimeout &lt;&#x3D; 0L) return false;\n            if(nanosTimeout &gt; spinForTimeoutThreshold)&#x2F;&#x2F;不着急阻塞，先自旋—下\n                LockSupport.parkNanos(this, nanosTimeout);&#x2F;&#x2F;超时阻塞\n            if (Thread.interrupted()) throw new InterruptedException();\n        &#125;\n    &#125;finally &#123;\n        if (failed) cancelAcquire(node);\n    &#125;\n&#125;\n&#x2F;&#x2F;为了支持超时阻塞，在阻塞线程时，doAcquireNanos调用parkNanos函数\n&#x2F;&#x2F;synchronized中park函数实现如下，parkNanos只将其中的pthread_cond_wait换成了\n&#x2F;&#x2F;pthread_cond_timewait，便可实现超时等待。\npthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;\nvoid park() &#123;\n    pthread_mutex_lock(&amp;mutex);\n    pthread_cond_wait(&amp;cond,&amp;mutex);&#x2F;&#x2F;阻塞等待其他线程发送信号\n    pthread_mutex_unlock(&amp;mutex);\n&#125;\n\n3.ReadWriteLock\n读写锁基本用法\n\nReadWriteLock只有一个可重入的实现类ReentrantReadWriteLock\npublic interface ReadwriteLock &#123;\n    Lock readLock();\n    Lock writeLock();\n&#125;\n基本使用\npublic class Demo &#123;\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    private ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\n    private Lock rLock &#x3D; rwLock.readLock();&#x2F;&#x2F;读锁\n    private Lock wLock &#x3D; rwLock.writeLock();&#x2F;&#x2F;写锁\n    public void add(String elem) &#123;\n        wLock.lock(); &#x2F;&#x2F;加写锁\n        try &#123;\n            list.add(idx, elem);\n        &#125; finally &#123;\n            wLock.unlock(); &#x2F;&#x2F;释放写锁\n        &#125;\n    &#125;\n    public String get(int idx) &#123;\n        rLock.Iock();&#x2F;&#x2F;加读锁\n        try &#123;\n            return list.get(idx);\n        &#125; finally &#123;\n            rLock.unlock();&#x2F;&#x2F;释放读锁\n        &#125;\n    &#125;\n&#125;\nReentrantReadWriteLock既支持公平锁有支持非公平锁，默认为非公平锁\nReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock(true); &#x2F;&#x2F;公平锁\nReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock(false);&#x2F;&#x2F;非公平锁\nReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();&#x2F;&#x2F;默认为非公平锁\n锁升级：读写锁不支持锁升级，即一个线程获取读锁之后，在读锁释放前，不可以再获取写锁\n\n锁降级：\n\n读写锁支持锁降级，一个线程在获取写锁之后，在写锁释放前，可以再获取读锁，当写锁释放之后，线程持有的锁从写锁降级为读锁\n\n既有写操作又有读操作的临界区，如果先加写锁，锁释放后再加读锁，会出现线程安全的问题，所以选择在写锁释放前先加读锁，即锁降级的方式\n\n\n\n\n\n\n读写锁的实现原理\n\n代码\npublic class ReentrantReadWriteLock\n    implements ReadWriteLock, java.io.Serializable &#123;\n    &#x2F;&#x2F;内部类提供实现，使用NonfairSync和FairSync来编程实现读锁（ReadLock）和\n    &#x2F;&#x2F;写锁（WriteLock），均实现了Lock接口、相同的AQS、Lock接口中的所有加解锁函数\n    private final ReentrantReadWriteLock.ReadLock readerLock;\n    private final ReentrantReadWriteLock.WriteLock writerLock;\n    final Sync sync;&#x2F;&#x2F;执行所有同步机制\n    public ReentrantReadWriteLock() &#123;\n        this(false);\n    &#125;\n    public ReentrantReadWriteLock(boolean fair) &#123;\n        sync &#x3D; fair ? new FairSync() : new NonfairSync();\n        readerLock &#x3D; new ReadLock(this);\n        writerLock &#x3D; new WriteLock(this);\n    &#125;\n    public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;\n    public ReentrantReadWriteLock.ReadLock  readLock()  &#123; return readerLock; &#125;\n    &#x2F;&#x2F;AQS的子类NonfairSync和FairSyn的公共父类\n    abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n        abstract boolean readerShouldBlock();&#x2F;&#x2F;区分公平锁和非公平锁\n        abstract boolean writerShouldBlock();&#x2F;&#x2F;区分公平锁和非公平锁\n        &#x2F;&#x2F;以下为AQS模板方法的抽象方法的实现\n        protected final boolean tryRelease(int releases) &#123;&#125;\n        protected final boolean tryAcquire(int acquires) &#123;&#125;\n        protected final boolean tryReleaseShared(int unused) &#123;&#125;\n        protected final int tryAcquireShared(int unused) &#123;&#125;\n\n        final boolean tryWriteLock() &#123;&#125;\n        final boolean tryReadLock() &#123;&#125;      \n    &#125;\n    static final class NonfairSync extends Sync &#123;\n        final boolean writerShouldBlock() &#123;return false; &#125;\n        final boolean readerShouldBlock() &#123;return apparentlyFirstQueuedIsExclusive();&#125;\n    &#125;\n    static final class FairSync extends Sync &#123;\n        final boolean writerShouldBlock() &#123;return hasQueuedPredecessors();&#125;\n        final boolean readerShouldBlock() &#123;return hasQueuedPredecessors();&#125;\n    &#125;\n&#125;\n写锁实现\n\n代码\npublic static class WriteLock implements Lock, java.io.Serializable &#123;\n    private final Sync sync;\n    protected WriteLock(ReentrantReadWriteLock lock) &#123;sync &#x3D; lock.sync;&#125;\n    public void lock() &#123;sync.acquire(1);&#125;\n    public void unlock() &#123;sync.release(1);&#125;\n    public boolean tryLock( ) &#123;return sync.tryWriteLock();&#125;\n    public void lockInterruptibly() throws InterruptedException &#123;\n        sync.acquireInterruptibly(1);\n    &#125;\n    public boolean tryLock(long timeout, TimeUnit unit)\n        \t\t\t\t\t\tthrows InterruptedException &#123;\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    &#125;\n    \n    public Condition newCondition() &#123;return sync.newCondition();&#125;\n    public boolean isHeldByCurrentThread() &#123;return sync.isHeldExclusively();&#125;\n    public int getHoldCount() &#123;return sync.getWriteHoldCount();&#125;\n&#125;\nstate：低16位表示，0表示没有加写锁，1表示已经加写锁，大于1表示写锁的可重入次数\n\n实现原理\n\nlock：lock调用AQS的acquire方法，其中的tryAcquire方法的实现在Sync中\nprotected final boolean tryAcquire(int acquires) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    int w &#x3D; exclusiveCount(c);&#x2F;&#x2F;高16位的值，也就是写锁的加锁情况\n    &#x2F;&#x2F;1.已经加读锁或写锁（state!&#x3D;0）\n    if (c !&#x3D; 0) &#123;\n        &#x2F;&#x2F; 已加读锁(w&#x3D;&#x3D;0)或者当前加写锁的线程不是自己\n        if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())\n            return false;&#x2F;&#x2F;去排队\n        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        &#x2F;&#x2F; 获取到了写锁\n        setState(c + acquires);&#x2F;&#x2F;更新写锁的重入次数\n        return true;\n    &#125;\n    &#x2F;&#x2F;2.没有加锁（state&#x3D;0）\n    if (writerShouldBlock() ||\n        !compareAndSetState(c, c + acquires))\n        return false;&#x2F;&#x2F;去排队\n    setExclusiveOwnerThread(current);\n    return true;&#x2F;&#x2F;获取了锁\n&#125;\n&#x2F;&#x2F;writerShouldBlock函数控制锁是否位公平锁，在state&#x3D;0，也就是没有加读锁和\n&#x2F;&#x2F;写锁的情况下，如果writerShouldBlock返回值为true，那么线程不尝试竞争锁，\n&#x2F;&#x2F;而是直接去排队，如果writerShouldBlock返回值是false，那么线程尝试竞争锁，\n&#x2F;&#x2F;失败再去排队。\n&#x2F;&#x2F;对于非公平锁，总是返回false，对于公平锁如果等待队列中有线程，则返回true\ntrylock调用tryRelease，实现在Sync中\nprotected final boolean tryRelease(int releases) &#123;\n    &#x2F;&#x2F;tryRelease是AQS工作在独占模式下的函数，只能用于排他锁，也就是写锁\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    &#x2F;&#x2F;更新state值，写锁的重入次数-releases，对于锁来说，releases总是等于1\n    int nextc &#x3D; getState() - releases;\n    &#x2F;&#x2F;只有更新之后的state值为0时，才可以将写锁释放\n    boolean free &#x3D; exclusiveCount(nextc) &#x3D;&#x3D; 0;\n    if (free)\n        setExclusiveOwnerThread(null);\n    setState(nextc);\n    return free;\n&#125;\n\n\n\n\n读锁实现\n\n代码\npublic static class ReadLock implements Lock, java.io.Serializable &#123;\n    private final Sync sync;\n    protected ReadLock(ReentrantReadWriteLock lock) &#123;sync &#x3D; lock.sync;&#125;\n    public void lock() &#123;sync.acquireShared(1);&#125;\n    public void unlock() &#123;sync.releaseShared(1);&#125;\n    public boolean tryLock() &#123;return sync.tryReadLock();&#125;\n    public void lockInterruptibly() throws InterruptedException &#123;\n        sync.acquireSharedInterruptibly(1);\n    &#125;\n    public boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException &#123;\n        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n    &#125;\n    public Condition newCondition() &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n&#125;\nstate：高16位表示，0表示没有加读锁，1表示已经加读锁，大于1表示读锁总共被获取了多少次（每个线程对读锁重入的次数相加），使用ThreadLocal变量存储重入次数\n\n实现原理\n\nlock：lock调用AQS的acquireShared方法，其中的tryAcquireShared实现在Sync中\npublic final void acquireShared(int arg) &#123;\n    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争读锁\n        doAcquireShared(arg);&#x2F;&#x2F;竞争失败去排队\n&#125;\n&#x2F;&#x2F;返回-1表示竞争锁失败，返回1表示竞争锁成功\nprotected final int tryAcquireShared(int unused) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    &#x2F;&#x2F;一些优化代码\n    return fullTryAcquireShared(current);\n&#125;\nfinal int fullTryAcquireShared(Thread current) &#123;\n    HoldCounter rh &#x3D; null;\n    &#x2F;&#x2F;如果state没加锁或者是加了读锁，那么线程会通过CAS操作改变state值来竞争锁;\n    &#x2F;&#x2F;如果其他线程也在竟争读锁，并且竞争成功，那么此线程就会竟争失败;\n    &#x2F;&#x2F;于是，此线程就要自旋(for循环)再次尝试去竞争读锁。\n    for (;;) &#123;\n        int c &#x3D; getState();\n        if (exclusiveCount(c) !&#x3D; 0) &#123;&#x2F;&#x2F;已加写锁\n            &#x2F;&#x2F;如果加写锁的线程不是此线程，那么读锁也加不成，直接返回-1\n            &#x2F;&#x2F;否则，读写锁支持锁降级，加了写锁的线程可以再加读锁\n            if (getExclusiveOwnerThread() !&#x3D; current)\n                return -1;\n        &#125; \n        &#x2F;&#x2F;理论上讲，如果没有加写锁，不管有没有加读锁，都可以去竞争读锁了，\n        &#x2F;&#x2F;毕竟读锁是共享锁。但是，存在两个特殊情况:\n        &#x2F;&#x2F;1.对于公平锁来说，如果等待队列不为空，并且当前线程没有持有读锁(重入加\n        &#x2F;&#x2F;锁)，那么，线程就要去排队。\n        &#x2F;&#x2F;2.对于非公平锁来说，如果等待队列中队首线程(接下来要被唤醒的）是写线\n        &#x2F;&#x2F;程，那么，线程就要去排队。这样做是为了避免请求写锁的线程迟迟获取不\n        &#x2F;&#x2F;到写锁。\n        else if (readerShouldBlock()) &#123;&#x2F;&#x2F;上述1和2情况在此时返回true      \n            if (readHolds.get().count &#x3D;&#x3D; 0)&#x2F;&#x2F;此线程没有持有读锁，不能重入\n                return -1;\n            &#x2F;&#x2F;以下是对上述代码中readHolds的解释:readHolds是ThreadLocal变量，保存\n            &#x2F;&#x2F;跟这个线程的读锁重入次数。如果重入次数为0，表示没有加读锁，返回-1去\n            &#x2F;&#x2F;排队。如果重入次数大于等于0，表示已加读锁，可以继续重入，不用排队。\n        &#125;\n        if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        &#x2F;&#x2F;CAS竞争读锁，此时有可能还有其他线程在竞争读锁或写锁\n        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;&#x2F;&#x2F;SHARED_UNIT&#x3D;1&lt;&lt;16\n            &#x2F;&#x2F;竞争读锁成功\n            readHolds.get().count++;&#x2F;&#x2F;更新线程重入次数\n            return 1;&#x2F;&#x2F;成功获取读锁\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;负责排队和等待唤醒，与之前的acquireQueued有两个不同\nprivate void doAcquireShared(int arg) &#123;\n    final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;一：标记此线程等待的是共享锁\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;) &#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head) &#123;\n                int r &#x3D; tryAcquireShared(arg);\n                if (r &gt;&#x3D; 0) &#123;\n                    &#x2F;&#x2F;区别二：如果下一个节点对应的线程也在等待读锁，那么顺道唤醒它\n                    &#x2F;&#x2F;线程获取到读锁之后，如果下一个节点对应的线程也在等待读锁，\n                    &#x2F;&#x2F;那么也会被唤醒。下一个节点对应的线程获取到读锁之后，又会去唤醒\n                    &#x2F;&#x2F;下下个节点对应的线程(如果下下个节点对应的线程也在等待读锁的\n                    &#x2F;&#x2F;话)。唤醒操作一直传播下去，直到遇到等待写锁的线程为止。\n                    setHeadAndPropagate(node, r);\n                    p.next &#x3D; null; &#x2F;&#x2F; help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed &#x3D; false;\n                    return;\n                &#125;\n            &#125;\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted &#x3D; true;\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            cancelAcquire(node);\n    &#125;\n&#125;\ntryReleaseShared\n&#x2F;&#x2F;当所有的读锁都释放之后（state变为0）才会返回true\nprotected final boolean tryReleaseShared(int unused) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    readHolds.get().count--;&#x2F;&#x2F;更新本线程对读锁的重入次数\n    for (;;) &#123;&#x2F;&#x2F;有可能多个线程同时释放读锁，同时CAS更新state，因此要自旋+CAS\n        int c &#x3D; getState();\n        int nextc &#x3D; c - SHARED_UNIT;&#x2F;&#x2F;相当于将读锁的加锁次数-1\n        if (compareAndSetState(c, nextc)) \n            return nextc &#x3D;&#x3D; 0;&#x2F;&#x2F;state变为0才会返回true，才会去唤醒等待队列中的线程\n    &#125;\n&#125;\n\n\n\n\n\n\n读写锁的升级版\n\nStampedLock是ReadWriteLock的进一步优化，在读写锁的基础上提供了乐观读锁。在读多写少的情况下，大部分操作都不会被写操作干扰，只有在真正被干扰的情况下再加读锁重复执行读操作。\npublic class Demo &#123;\n    private stampedLock slock &#x3D; new stampedLock();\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    \n    public void add(int idx, String elem) &#123;\n        long stamp &#x3D; slock.writeLock();&#x2F;&#x2F;加写锁\n        try &#123;\n            list.add(elem);\n        &#125;finally &#123;\n            slock.unlockWrite(stamp);&#x2F;&#x2F;释放写锁\n        &#125;\n    &#125;\n    \n    public String get(int idx) &#123;\n        long stamp &#x3D; slock.tryOptimisticRead(); &#x2F;&#x2F;加乐观读锁，不需要解锁\n        string res &#x3D; list.get(idx);\n        if (slock.validate(stamp)) &#123;&#x2F;&#x2F;时间错stamp没有被更改，即没写操作干扰\n            return res;\n        &#125; \n        &#x2F;&#x2F;有写操作干扰，读期间，writeLock()函数有被执行，重新使用读锁，重新执行读操作\n        stamp &#x3D; slock.readLock(); &#x2F;&#x2F;加读锁\n        try &#123;\n            return list.get(idx);\n        &#125;finally &#123;\n            slock.unlockRead(stamp);&#x2F;&#x2F;释放读锁\n        &#125;\n    &#125;\n&#125;\n\n\n\n3.无锁编程1.CAS\n概述：CAS指的是先检查后更新这类复合操作，全称为Compare And Set或Compare And Swap。示例代码如下：\npublic class Demo&#123;\n  private int state &#x3D; 0;\n  &#x2F;&#x2F;state 为共享变量，0表示没有加锁，多个线程调用tryAcquire()函数，谁将state变为1，谁就获取锁\n  public boolean tryAcquire()&#123;\n    &#x2F;&#x2F;非线程安全，因为下面操作非原子操作，可以通过硬件层面提供的CAS原子指令\n    if(state &#x3D;&#x3D; 0)&#123;\n      state &#x3D; 1;\n      return true;\n    &#125;\n    return false;\n  &#125;\n&#125;\n硬件指令：x86提供的原子指令为cmpxchg[目标操作数],[源操作数]。\n\n用于存储变量当前值的目标操作数C，用于存储变量的更新值源操作数N，隐藏的位于寄存器上的存储变量的期望值E\n当执行cmpxchg指令时，CPU先判断C是否等于E，相等的话，将更新值N赋值给C，并将ZF标志位设为1；如果不想等的话，CPU将当前值C赋值给期望值E，并将ZF标识位设为0，表示更新值失败。\n因为CPU是一个指令一个指令执行的，所以cmpxchg在单核计算机上是原子操作，在多核计算机上需要用LOCK cmpxchg[目标操作数],[源操作数]，LOCK前缀主要用于同步缓存和内存，锁定总线，禁止多个CPU核同时操作一块共享的内存单元。\n\n\nnative方法\n\n因为Java无法使用底层的CPU指令，JVM的Unsafe类中提供了大量的native方法，对底层操作进行了封装，比如根据地址直接访问内存。但是增加了程序发生指针问题的风险，通过看JVM源码才能获得Unsafe类中native方法的代码实现（C++）\n\nUnsafe类中提供了3个CAS方法\n&#x2F;&#x2F;expected是旧值，x是新值\npublic final native boolean compareAndSwapObject(\n  Object o, long offset,Object expected,Object x);\n\npublic final native boolean compareAndSwapInt(\n  Object o, long offset,int expected,int x);\n\npublic final native boolean compareAndSwapLong(\n  Object o, long offset,long expected,long x);\n\n\ncompareAndSwapInt源码实现\n&#x2F;&#x2F;以下代码位于safe.cpp中\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(\n  JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);\n\toop p &#x3D; JNIHandles::resolve(obj);\n\tjint* addr &#x3D; (jint *) index_oop_rom_field_offset_long(p, offset);\n\treturn (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;\nUNSAFE_END\n  \ninline jint Atomic::cmpxchg(\n\tjint exchange_value, volatile jint* dest, jint compare_value) &#123;\n\tint mp &#x3D; os::is_MP();\n  &#x2F;&#x2F;调用了汇编代码，执行cmpxchg汇编指令\n\t__asm__ volatile (LOCK_IF_MP(%4) &quot; cmpxchgl %1 , (%3)&quot;\n\t\t\t\t\t\t\t:&quot;&#x3D;a&quot;(exchange_value)\n\t\t\t\t\t\t\t:&quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)\n\t\t\t\t\t\t\t:&quot;cc&quot;, &quot;memory&quot;);\nreturn exchange_ value;\n&#125;\n\n\n使用CAS方法实现tryAcquire()函数\npublic class Demo&#123;\n  private int state &#x3D; 0;\n  \n  private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\n  private static final long stateOffset;\n  \n  static &#123;\n    try&#123;\n      stateOffset &#x3D; unsafe.objectFieldOffset(\n      \t\t\t\t\t\t\t\tDemo.class.getDeclaredField(&quot;state&quot;));\n    &#125;catch(Exception ex)&#123;\n      throw new Error(ex);\n    &#125;\n    public boolean tryAcquire()&#123;\n      return unsafe.compareAndSwapInt(this, stateOffset, 0, 1);\n    &#125;\n  &#125;\n&#125;\n\n\n失败处理：如果多个线程执行CAS操作，只有一个会成功，其他均会失败。此时可以根据不同的业务逻辑，选择不同的处理逻辑，既可以转去执行处理逻辑，也可以自旋执行CAS直到成功\npublic class Demo&#123;\n  private int id &#x3D; 0;\n  &#x2F;&#x2F;使用锁，相当于悲观锁，lock同理\n  public void incerment_lock()&#123;\n    synchronized(this)&#123;\n      id++;\n    &#125;\n  &#125;\n  &#x2F;&#x2F;失败则执行其他逻辑\n  public void inrement_CAS()&#123;\n    int oldValue &#x3D; id;\n    int newValue &#x3D; oldValue + 1;\n    unsafe.compareAndSwapInt(this,idOffset,oldValue,newValue);\n  &#125;\n  &#x2F;&#x2F;自旋+CAS，相当于乐观锁\n  public void incerment_CAS()&#123;\n    boolean succeded &#x3D; false;\n    while(!succeded)&#123;\n      int oldValue &#x3D; id;\n      int newValue &#x3D; oldValue + 1;\n      succeded &#x3D; unsafe.compareAndSwapInt(this,idOffset,oldValue,newValue);\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F;乐观素：乐观地认为不大可能会有资源竞争，不需要加锁，避免了阻塞导致的上下文切换，但消耗了更多的\n&#x2F;&#x2F;CPU资源，可通过限制自旋次数，避免大量自旋\n\n&#x2F;&#x2F;悲观锁：悲观地认为很有可能会出现资源竞争，需要加锁\n应用场景\n\n在不使用synchronized和lock时，实现一个线程安全的链表，假设只在结尾处插入\npublic class Demo&#123;\n  public static final class Node&#123;\n    private int threadId;\n    private Node prev;\n    private Node next;\n    public Node(int val,Node prev,Node next)&#123;\n      this.threadId &#x3D; val;\n      this.prev &#x3D; prev;\n      this.next &#x3D; next;\n    &#125;\n  &#125;\n  \n  private Node head &#x3D; new Node(-1,null,null);&#x2F;&#x2F;虚拟头节点\n  private Node tail &#x3D; head;\n  \n  public void addWaiter(int val) &#123;\n    Node waiter  &#x3D; new Node(val,null,null);\n    for(;;)&#123;\n      Node oldFail &#x3D; tail;\n      &#x2F;&#x2F;tail从旧值变成了新值，然后将此节点连到链表上\n      if(unsafe.compareAndSwapObject(this,tailOffset,oldTail,waiter))&#123;\n        waiter.prev &#x3D; oldTail;\n        oldTail.next &#x3D; waiter;\n        return;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n\n\n2.原子类\n\n\n\n\n\n\n\n\n因为实现自旋+CAS的代码比较复杂，JUC提供了各种原子类，封装了对各种类型数据的自旋+CAS操作\n\n原子类：原子类的每个操作都可以看成是原子操作，在多线程环境下，执行原子类的操作不会出现线程安全问题。主要可分为四类\n\n基本类型原子类AtomicInteger\n\n因为浮点数无法精确表示和比较大小，所以不包含double和float的原子类，对于char类型，需要将其转换为int类型，然后使用AtomicInteger\n\nAtomicInteger代码\npublic class AtomicInteger extends Number implements java.io.Serializable &#123;\n  &#x2F;&#x2F;创建Unsafe对象，获取value变量在AtomicInteger对象中的偏移位置\n  private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\n  private static final long valueOffset;\n  static &#123;\n    try &#123;\n      valueOffset &#x3D; unsafe.objectFieldOffset\n        (AtomicInteger.class.getDeclaredField(&quot;value&quot;));\n    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;\n  &#125;\n  &#x2F;&#x2F;默认为0\n  private volatile int value;\n  &#x2F;&#x2F;constructor getter setter...\n&#125;\nAtomicInteger原子操作\n\nCAS：如果value等于expect，就将value更新为update\npublic final boolean compareAndSet(int expect, int update) &#123;\n  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n&#125;\n增加：\n&#x2F;&#x2F;返回旧值\npublic final int getAndAdd(int delta) &#123;\n  return unsafe.getAndAddInt(this, valueOffset, delta);\n&#125;\n&#x2F;&#x2F;返回新值\npublic final int addAndGet(int delta) &#123;\n  return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n&#125;\n&#x2F;&#x2F;底层Unsafe实现，在多线程竞争执行时，CAS可能会执行失败，因此通过自旋重复执行CAS，直到成功an\npublic final int getAndAddInt(Object o, long offset, int delta) &#123;\n  int v;\n  do &#123;\n    v &#x3D; getIntVolatile(o, offset);\n  &#125; while (!compareAndSwapInt(o, offset, v, v + delta));\n  return v;\n&#125;\n自增：底层实现和增加函数同理，只是将delta设置为1\npublic final int getAndIncrement() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, 1);\n&#125;\npublic final int incrementAndGet() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n&#125;\n自减：底层实现和增加函数同理，只是讲delta设置为-1\npublic final int getAndDecrement() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, -1);\n&#125;\npublic final int decrementAndGet() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, -1) - 1;\n&#125;\n\n\n\n\n引用类型原子类\n\nAtomicReference\n\n实现\npublic class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;\n  private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\n  private static final long valueOffset;\n  static &#123;\n    try &#123;\n      valueOffset &#x3D; unsafe.objectFieldOffset\n        (AtomicReference.class.getDeclaredField(&quot;value&quot;));\n    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;\n  &#125;\n  private volatile V value;\n  &#x2F;&#x2F;constructor setter getter\n  public AtomicReference(V initialValue) &#123;\n    value &#x3D; initialValue;\n  &#125;\n  public final boolean compareAndSet(V expect, V update) &#123;\n    return unsafe.compareAndSwapObject(this, valueOffset, expect, update);\n  &#125;\n&#125;\n使用方式\npublic class DemoLock&#123;\n  private AtomicReference&lt;Thread&gt; owner &#x3D; null;\n  public boolean tryAcquire()&#123;\n    return owner.compareAndSet(null,Thread.currentThread());\n  &#125;\n&#125;\n\n\nAtomicStampedReference\n\n相对于AtomicReference，AtomicStampedReference增加了时间戳的概念，主要是用来解决CAS的ABA问题（链表操作头节点时，可能会出现两个线程同时更改同时写回的情况，线程不安全）\npublic class AtomicStampedReference&lt;V&gt; &#123;\n  private static class Pair&lt;T&gt; &#123;\n    &#x2F;&#x2F;引用对象\n    final T reference;\n    &#x2F;&#x2F;版本戳\n    final int stamp;\n    private Pair(T reference, int stamp) &#123;\n      this.reference &#x3D; reference;\n      this.stamp &#x3D; stamp;\n    &#125;\n    static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;\n      return new Pair&lt;T&gt;(reference, stamp);\n    &#125;\n  &#125;\n  private volatile Pair&lt;V&gt; pair;\n\n  public boolean compareAndSet(V expectedReference, V newReference,\n                               int expectedStamp,int newStamp) &#123;\n    Pair&lt;V&gt; current &#x3D; pair;\n    return\n      expectedReference &#x3D;&#x3D; current.reference &amp;&amp;\n      expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;\n      ((newReference &#x3D;&#x3D; current.reference &amp;&amp;\n        newStamp &#x3D;&#x3D; current.stamp) ||\n       casPair(current, Pair.of(newReference, newStamp)));\n  &#125;\n  private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;\n    return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);\n  &#125;\n&#125;\n既可以使用synchronized或lock加锁，也可以使用自旋+CAS来解决，但是使用AtomicReference会出现问题\n&#x2F;&#x2F;出现ABA问题\npublic class LinkedListThreadSafe&#123;\n  private AtomicReference&lt;Node&gt; head &#x3D; new AtomicReference&lt;&gt;(null);\n  public void addAtHead(Node newNode)&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeed)&#123;\n      Node oldHead &#x3D; head.get();\n      newNode.next &#x3D; oldHead;\n      &#x2F;&#x2F;链表结构已改变，但是oleHead和newNode没变，如下图\n      succeeded &#x3D; head.compareAndSet(oldHead,newNode);\n    &#125;\n  &#125;\n  public void removeAtHead()&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeeded)&#123;\n      Node oldHead &#x3D; head.get();\n      if(oldHead &#x3D;&#x3D; null) return;\n      Node nextNode &#x3D; oldHead.next;\n      succeeded &#x3D; head.compareAndSet(oldHead,nextNode);\n    &#125;\n  &#125;\n&#125;\n\n\n\n\n\n所以使用AtomicStampedReference改造：即便references存在ABA问题，但是stamp总在增加\npublic class LinkedList&#123;\n  private AtomicStampedReference&lt;Node&gt; head &#x3D; \n    \t\t\t\t\t\t\t\t\t\t\tnew AtomicStampedReference&lt;&gt;(null,0);&#x2F;&#x2F;stamp初始值为0\n  \n  public void addAtHead(Node newNode)&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeeded)&#123;\n      int oldStamp &#x3D; head.getStamp();\n      Node oldHead &#x3D; head.getReference();\n      newNode.next &#x3D; oldHead;\n      succeeded &#x3D; head.compareAndSet(oldHead,newNode,oldStamp,oldStamp+1);\n    &#125;\n  &#125;\n  public void removeAtHead()&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeeded)&#123;\n      int oldStamp &#x3D; head.getStamp();\n      Node oldHead &#x3D; head.getReference();\n      if(oldHead &#x3D;&#x3D; null) return;\n      Node nextNode &#x3D; oldHead.next;\n      succeeded &#x3D; head.compareAndSet(oldHead,nextNode,oldStamp,oldStamp+1);\n    &#125;\n  &#125;\n&#125;\n\n\nAtomicMarkableReference：与AtomicStampedReference作用相同，区别在于AtomicMarkableReference使用boolean类型的mark是否被更改来判断reference是否被更改过，原理同上\n\n\n\n数组类型原子类：AtomicIntegerArray中的原子操作和AtomicInteger中的原子操作一一对应，只是在操作中多了一个下标的入参，其他同AtomicInteger，只不过计算元素的偏移位置比较复杂\n&#x2F;&#x2F;AtomicInteger\npublic final boolean compareAndSet(int expect,int update)&#123;\n  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n&#125;\n&#x2F;&#x2F;AtomicIntegerArray\npublic final boolean compareAndSet(int i, int expect, int update)&#123;\n  return unsafe.compareAndSwapInt(array, checkedByteOffset(i), expect, update);\n&#125;\n对象属性原子类：如果某个类中的属性没有提供合适的原子操作，那么就可以使用对象属性原子类对其进行原子操作，前提属性是public的\npublic class Updater&#123;\n  private static AtomicIntegerFieldUpdater&lt;Node&gt; updator &#x3D; \n    \t\t\t\t\t\t\t\t\t\t\t\t\tAtomicIntegerFieldUpdater.newUpdater(Node.class,&quot;val&quot;);\n  \n  public static void incrementVal(Node node)&#123;\n    updator.incrementAndGet(node);\n  &#125;\n&#125;\n\n3.累加器\n没有累加器加锁方法\n\n改造前非线程安全\npublic class Counter&#123;\n  private long sum;\n  public long get()&#123;\n    return sum;\n  &#125;\n  public void add(long value)&#123;\n    sum +&#x3D; value;\n  &#125;\n&#125;\n三种改造方法\n&#x2F;&#x2F;加锁，性能影响大\npublic void add_lock(long value)&#123;\n  synchronized(this)&#123;\n    sum +&#x3D; value;\n  &#125;\n&#125;\n\n&#x2F;&#x2F;自旋+CAS，性能影响小，适合低并发\nprivate static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\nprivate static final long sumOffset;\nstatic&#123;\n  try&#123;\n    sumOffset &#x3D; unsafe.objectFieldOffset(Counter.class.getDeclaredField(&quot;sum&quot;));\n  &#125;catch(Exception ex)&#123;\n    throw new Error(ex);\n  &#125;\n&#125;\n\npublic void add_cas(long value)&#123;\n  boolean succeeded &#x3D; false;\n  while(!succeeded)&#123;\n    long oldValue &#x3D; sum;\n    succeeded &#x3D; unsafe.compareAndSwapLong(this,sumOffset,oldValue,oldValue+value);\n  &#125;\n&#125;\n&#x2F;&#x2F;原子类，实现简单\nprivate AtomicLong atomicSum &#x3D; new AtomicLong();\npublic void add_atomic(int value)&#123;\n  atomicSum.addAndGet(value);\n&#125;\n\n\nLongAdder累加器基本用法\npublic class CounterLongAdder&#123;\n  private LongAdder ladder &#x3D; new LongAdder();\n  \n  public void add(long value)&#123;\n    ladder.add(value);\n  &#125;\n  public long get()&#123;\n    &#x2F;&#x2F;sum用来返回累加之后的总和，高并发情况下，不能返回精确的累加值，为了高性能付出的代价\n    return ladder.sum();\n  &#125;\n&#125;\n数据分片\n\n作用：在高并发情况下，依然可以保持高性能。AtoimcLong因为多线程同时CAS更新一个累加变量，所以性能不高。但是LongAdder将一个累加变量分解为多个累加变量，多线程同时执行累加操作时，不同线程对不同的累加变量进行操作，线程之间互不影响，避免了一个线程需要等待另一个线程操作完之后再操作\n\n核心成员变量\nabstract class Striped64 extends Number &#123;\n  \n  &#x2F;&#x2F;NCPU表示JVM最大可用CPU核数，同时执行累加操作的线程数不可能大于CPU的核数，当cells数组的长度\n  &#x2F;&#x2F;大于等于NCPU时，cells数组中的累加变量个数便可以满足最大NCPU个线程同时互不干涉地执行累加操作\n  &#x2F;&#x2F;cells最大等于NCPU的最小2的幂次方，如NCPU为6，cells数组最大长度为8\n  static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();\n  &#x2F;&#x2F;cells数组保存多个累加变量，支持动态扩容，初始化为null，首次出现竞争时创建，Cell定义见下\n  transient volatile Cell[] cells;\n  &#x2F;&#x2F;当线程执行add()函数时，首先尝试CAS更新base（将新增值累加到base上），如果成功，则直接返回，\n  &#x2F;&#x2F;如果失败，则执行分片累加的逻辑（将新增值累加到cells数组中），即base只用在低并发情况下\n  transient volatile long base;\n  &#x2F;&#x2F;用来实现锁，类似ReentrantLock中的state字段，初始化为0，多个线程通过CAS竞争更新cellsBusy\n  &#x2F;&#x2F;谁先设置为1，谁就持有锁，这把锁用于避免多个线程同时创建cells数组、同时创建数组中Cell对象、\n  &#x2F;&#x2F;对cells数组进行动态扩容，三个操作的线程安全性\n  transient volatile int cellsBusy;\n  \n  &#x2F;&#x2F;LongAdder中add()函数\n  final void longAccumulate(long x, LongBinaryOperator fn,\n                            boolean wasUncontended) &#123; &#125;\n  \n  &#x2F;&#x2F;Cell只包含一个成员变量value，以及一个操作value的cas()函数\n  @sun.misc.Contended static final class Cell &#123;\n    volatile long value;\n    Cell(long x) &#123; value &#x3D; x; &#125;\n    \n    &#x2F;&#x2F; 实现value的CAS函数\n    final boolean cas(long cmp, long val) &#123;\n      return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n    &#125;\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long valueOffset;\n    static &#123;\n      try &#123;\n        UNSAFE &#x3D; sun.misc.Unsafe.getUnsafe();\n        Class&lt;?&gt; ak &#x3D; Cell.class;\n        valueOffset &#x3D; UNSAFE.objectFieldOffset\n          (ak.getDeclaredField(&quot;value&quot;));\n      &#125; catch (Exception e) &#123;\n        throw new Error(e);\n      &#125;\n    &#125;\n  &#125;\nLongAdder的累加过程\n\n源码\npublic class LongAdder extends Striped64 implements Serializable &#123;\n  &#x2F;&#x2F;用来累加\n  public void add(long x) &#123;\n    Cell[] as; long b, v; int m; Cell a;\n    &#x2F;&#x2F;低并发，没有cells，直接更新base\n    if ((as &#x3D; cells) !&#x3D; null || !casBase(b &#x3D; base, b + x)) &#123;\n      boolean uncontended &#x3D; true;\n      if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||\n          &#x2F;&#x2F;getProbe为哈希函数，返回当前线程的哈希值，getProbe()&amp;m相当于getProbe()%n\n          (a &#x3D; as[getProbe() &amp; m]) &#x3D;&#x3D; null ||\n          &#x2F;&#x2F;有cells，且更新对应cell成功，则直接返回\n          !(uncontended &#x3D; a.cas(v &#x3D; a.value, v + x)))\n        &#x2F;&#x2F;cells为空、线程要更新的cells对象为null、cas更新cells的对象值失败\n        longAccumulate(x, null, uncontended);\n    &#125;\n  &#125;\n&#125;\n\nabstract class Striped64 extends Number &#123;\n  &#x2F;&#x2F;wasUncontended&#x3D;true，fn&#x3D;null，x&#x3D;改变的值+1&#x2F;-1\n  final void longAccumulate(long x, LongBinaryOperator fn,\n                            boolean wasUncontended) &#123;\n    int h;\n    if ((h &#x3D; getProbe()) &#x3D;&#x3D; 0) &#123;\n      ThreadLocalRandom.current(); &#x2F;&#x2F; force initialization\n      h &#x3D; getProbe();\n      wasUncontended &#x3D; true;\n    &#125;\n    boolean collide &#x3D; false;                &#x2F;&#x2F; True if last slot nonempty\n    for (;;) &#123;\n      Cell[] as; Cell a; int n; long v;\n      if ((as &#x3D; cells) !&#x3D; null &amp;&amp; (n &#x3D; as.length) &gt; 0) &#123;\n        if ((a &#x3D; as[(n - 1) &amp; h]) &#x3D;&#x3D; null) &#123;\n          if (cellsBusy &#x3D;&#x3D; 0) &#123;       &#x2F;&#x2F; Try to attach new Cell\n            Cell r &#x3D; new Cell(x);   &#x2F;&#x2F; Optimistically create\n            if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; casCellsBusy()) &#123;\n              boolean created &#x3D; false;\n              try &#123;               &#x2F;&#x2F; Recheck under lock\n                Cell[] rs; int m, j;\n                if ((rs &#x3D; cells) !&#x3D; null &amp;&amp;\n                    (m &#x3D; rs.length) &gt; 0 &amp;&amp;\n                    rs[j &#x3D; (m - 1) &amp; h] &#x3D;&#x3D; null) &#123;\n                  rs[j] &#x3D; r;\n                  created &#x3D; true;\n                &#125;\n              &#125; finally &#123;\n                cellsBusy &#x3D; 0;\n              &#125;\n              if (created)\n                break;\n              continue;           &#x2F;&#x2F; Slot is now non-empty\n            &#125;\n          &#125;\n          collide &#x3D; false;\n        &#125;\n        else if (!wasUncontended)       &#x2F;&#x2F; CAS already known to fail\n          wasUncontended &#x3D; true;      &#x2F;&#x2F; Continue after rehash\n        else if (a.cas(v &#x3D; a.value, ((fn &#x3D;&#x3D; null) ? v + x :\n                                     fn.applyAsLong(v, x))))\n          break;\n        else if (n &gt;&#x3D; NCPU || cells !&#x3D; as)\n          collide &#x3D; false;            &#x2F;&#x2F; At max size or stale\n        else if (!collide)\n          collide &#x3D; true;\n        else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; casCellsBusy()) &#123;\n          try &#123;\n            if (cells &#x3D;&#x3D; as) &#123;      &#x2F;&#x2F; Expand table unless stale\n              Cell[] rs &#x3D; new Cell[n &lt;&lt; 1];\n              for (int i &#x3D; 0; i &lt; n; ++i)\n                rs[i] &#x3D; as[i];\n              cells &#x3D; rs;\n            &#125;\n          &#125; finally &#123;\n            cellsBusy &#x3D; 0;\n          &#125;\n          collide &#x3D; false;\n          continue;                   &#x2F;&#x2F; Retry with expanded table\n        &#125;\n        &#x2F;&#x2F;引入随机数，重新计算h\n        h &#x3D; advanceProbe(h);\n      &#125;\n      else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; cells &#x3D;&#x3D; as &amp;&amp; casCellsBusy()) &#123;\n        boolean init &#x3D; false;\n        try &#123;                           &#x2F;&#x2F; Initialize table\n          if (cells &#x3D;&#x3D; as) &#123;\n            Cell[] rs &#x3D; new Cell[2];\n            rs[h &amp; 1] &#x3D; new Cell(x);\n            cells &#x3D; rs;\n            init &#x3D; true;\n          &#125;\n        &#125; finally &#123;\n          cellsBusy &#x3D; 0;\n        &#125;\n        if (init)\n          break;\n      &#125;\n      else if (casBase(v &#x3D; base, ((fn &#x3D;&#x3D; null) ? v + x :\n                                  fn.applyAsLong(v, x))))\n        break;                          &#x2F;&#x2F; Fall back on using base\n    &#125;\n  &#125;\n&#125;\nlongAccumulate逻辑\n\n\n\n\n\n\n哈希优化\n\n源代码中频繁用到了哈希函数getProbe()、advanceProbe()，用于确定累加到cells中的哪个Cell对象\n\n优化：\n\n因为n为2的幂次方，所以getProbe()%n可以转化为getProbe()&amp;(n-1)，以提高计算速度\n哈希函数计算得到的哈希值，汇报存在线程对应的Thread对象的成员变量中，每次需要时，直接取出使用，如果失败（即两个线程同时更新同一个Cell对象），执行cas失败的线程会重新生成新的哈希值，更新到Thread对象中\n\n\n源码\n&#x2F;&#x2F;直接获取当前线程对应的Thread对象的PROBE成员变量值\nstatic final int getProbe() &#123;\n  return UNSAFE.getInt(Thread.currentThread(), PROBE);\n&#125;\n&#x2F;&#x2F;基于老的哈希值probe重新计算新的哈希值，并存储到当前线程对应的Thread对象的PROBE成员变量中\nstatic final int advanceProbe(int probe) &#123;\n  probe ^&#x3D; probe &lt;&lt; 13;   &#x2F;&#x2F; xorshift\n  probe ^&#x3D; probe &gt;&gt;&gt; 17;\n  probe ^&#x3D; probe &lt;&lt; 5;\n  UNSAFE.putInt(Thread.currentThread(), PROBE, probe);\n  return probe;\n&#125;\n\n\n去伪共享\n\nLongAdder在Cell的类定义的前面添加了一个注解@Contended注解，隐藏了一个优化：去伪共享，主要用于提高多线程并发执行效率，在DIsruptor高性能消息队列中也有用到\n\n伪共享：CPU操作缓存的最小单元是缓存行，不同CPU上的缓存行大小不同，可以为32字节、64字节或128字节。计算Cell对象大小，Cell对象头占12字节，value成员变量为long类型，占8个字节，对象头与value成员变量之间有4字节对齐填充，所以一个Cell对象占24字节，如果一个缓存行大小为64字节，那么两个Cell对象就可能存储在同一个缓存行中。当t1更改cellA的时候，会把缓存行设为无效，导致t2对cellB的缓存也会失效，t1和t2互相影响，导致缓存频繁失效\n\n为了解决伪共享的问题，可以使用@Contended注解。标记在类上会强制这个类的对象独占一个缓存行，不够的做对齐填充，标记在变量上的作用相同，强制这个变量独占一个缓存行\n\n\n\n非准确求和\n\nLongAdder中的sum()函数会累加base和cells中的Cell对象的value值，和便是最终的累加值。但这个值是不准确的，代码如下\npublic long sum() &#123;\n  Cell[] as &#x3D; cells; Cell a;\n  long sum &#x3D; base;\n  if (as !&#x3D; null) &#123;\n    for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;\n      if ((a &#x3D; as[i]) !&#x3D; null)\n        sum +&#x3D; a.value;\n    &#125;\n  &#125;\n  return sum;\n&#125;\n从代码中可以发现，LongAdder在执行sum()函数时，并没有加锁，也就是说，在执行sum()的同时，有可能其他线程正在执行add()函数。所以会使得累加值不准确\n\n\n\n\n4.ThreadLocal\n\n\n\n\n\n\n\n\n使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全\n\n基本用法\n\n将Java的变量粗略的分为两类，类的成员变量和函数内局部变量，对于类的成员变量在有多个线程共同访问时，就是共享变量，就可能存在线程安全问题；对于函数内局部变量，每个线程执行函数时会在自己的栈上创建私有的局部变量，函数局部变量仅限函数内可见，不同函数之间不可以共享局部变量。多个函数共享局部变量，需要通过参数传递的方式来实现，示例如下：\n\n在标准的Controller-Service-Repository三层结构的后端系统中，实现一个简单的调用链追踪功能\npublic class UserController&#123;\n  private static final Logger logger &#x3D; \n    \t\t\t\t\t\t\t\t\t\tLoggerFactory.getLogger(UserController.class);\n  private UserService userService &#x3D; new UserService();\n  \n  public long login(String username, String password)&#123;\n    &#x2F;&#x2F;创建traceId，通过traceId可以轻松得到一个接口请求的所有日志，方便通过日志查找代码问题\n    String traceId &#x3D; &quot;[&quot;+System.currentTimeMillis()+&quot;]&quot;;\n    &#x2F;&#x2F;所有的日志都带有traceId\n    logger.trace(traceId + &quot;username&quot; + username);\n    &#x2F;&#x2F;省略校验逻辑\n    return userService.login(username, password, traceId);&#x2F;&#x2F;传递traceId\n  &#125;\n&#125;\n\n\n上述代码需要在每个函数中定义traceId参数，将业务代码和非业务代码耦合在一起，为了解决这个问题，可以使用ThreadLocal，其作用域范围介于类的成员变量和函数内局部变量之间，既是线程私有的，又可以在函数之间共享，不但避免了线程安全问题，还能避免参数传递带来的代码耦合问题，重构如下：\n\n使用ThreadLocal重新实现调用链追踪功能，\npublic class Context&#123;\n  &#x2F;&#x2F;实现一个匿名类，重写initialValue方法来提供threadLocalTraceId的初始值\n  &#x2F;&#x2F;如果调用get之前没有调用set，ThreadLocal则会调用initialValue来初始化\n  private static final ThreadLocal&lt;String&gt; threadLocalTraceId &#x3D; \n    new ThreadLocal&lt;String&gt;()&#123;\n    @Override\n    protected String initialValue()&#123;\n      return &quot;[&quot;+System.currentTimeMillis()+&quot;]&quot;;\n    &#125;\n  &#125;;\n  public static void setTraceId(String traceId)&#123;\n    threadLocalTraceId.set(tracdId);\n  &#125;\n  public static String getTraceId()&#123;\n    return threadLocalTraceId.get();\n  &#125;\n  public static void remove()&#123;\n    threadLocalTraceId.remove;\n  &#125;\n&#125;\npublic class UserController&#123;\n  private static final Logger logger &#x3D; \n    LoggerFactory.getLogger(UserController.class);\n  private UserService userService &#x3D; new UserService();\n  \n  public long login(String username, String password)&#123;\n    &#x2F;&#x2F;所有日志都带有tracdId\n    logger.trace(Context.getTraceId()+&quot;username&quot;+username);\n    &#x2F;&#x2F;省略校验逻辑\n    return userService.login(username, password);&#x2F;&#x2F;通过Context传递tracdId\n  &#125;\n&#125;\n\n\nThreadLocal提供的api\npublic class ThreadLocal&lt;T&gt; &#123;\n  protected T initialValue() &#123;return null;&#125;\n  public T get() &#123; &#125;\n  public void set(T value) &#123; &#125;\n  public void remove() &#123; &#125;\n  &#x2F;&#x2F;...\n&#125;\n\n\n实现原理\n\n问题：ThreadLocal定义的一个变量怎么存储多个线程的数据？在类中定义的ThreadLocal变量如何分身到多个线程使用\n\n源码结构\n\nThreadLocal只定义了读写数据的方法，并没有定义任何成员变量来存储数据\npublic class ThreadLocal&lt;T&gt; &#123;\n  public ThreadLocal() &#123; &#125;\n  protected T initialValue() &#123; &#125;\n  public T get() &#123; &#125;\n  public void set(T value) &#123; &#125;\n  public void remove() &#123; &#125;\n  \n  public static class ThreadLocalMap&#123; &#125;\n&#125;\npublic class Thread implements Runnable&#123;\n  &#x2F;&#x2F;...\n  ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;\n  &#x2F;&#x2F;...\n&#125;\nThreadLocal的数据存储结构：数据是存储在线程对应的Thread对象的ThreadLocals成员变量中，类行为ThreadLocalMap是ThreadLocal的内部类，ThreadLocal类似于HashMap，键为ThreadLocal对象，值为Object对象\n\n\n\n\n函数底层实现原理\n\nset函数\npublic void set(T value) &#123;\n  Thread t &#x3D; Thread.currentThread();&#x2F;&#x2F;获取当前线程对应的Thread对象\n  ThreadLocalMap map &#x3D; getMap(t);&#x2F;&#x2F;获取Thread对象的threadLocals成员变量\n  if (map !&#x3D; null) &#123;&#x2F;&#x2F;threadLocals不为空，则添加键值对\n    map.set(this, value);\n  &#125; else &#123;&#x2F;&#x2F;threadLocals为空，则先创建再添加\n    createMap(t, value);\n  &#125;\n&#125;\nThreadLocalMap getMap(Thread t) &#123;\n  return t.threadLocals;\n&#125;\nvoid createMap(Thread t, T firstValue) &#123;\n  t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);\n&#125;\nget函数\npublic T get() &#123;\n  Thread t &#x3D; Thread.currentThread();&#x2F;&#x2F;获取当前线程对应的Thread对象\n  ThreadLocalMap map &#x3D; getMap(t);&#x2F;&#x2F;获取Thread对象的threadLocals成员变量\n  if (map !&#x3D; null) &#123;\n    ThreadLocalMap.Entry e &#x3D; map.getEntry(this);&#x2F;&#x2F;this是ThreadLocal变量\n    if (e !&#x3D; null) &#123;\n      @SuppressWarnings(&quot;unchecked&quot;)\n      T result &#x3D; (T)e.value;\n      return result;&#x2F;&#x2F;获取对应的数据值\n    &#125;\n  &#125;\n  &#x2F;&#x2F;map为null或者没有获取到对应的数据值，则执行初始化操作\n  return setInitialValue();\n&#125;\nprivate Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;\n  int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);&#x2F;&#x2F;找到位置，hash表\n  Entry e &#x3D; table[i];&#x2F;&#x2F;e为弱引用\n&#x2F;&#x2F;这里为什么要使用弱引用呢？原因是如果不使用弱引用，那么当持有value的强引用释放掉后，当线程没有回收释放时，threadLocalMap会一直持有ThreadLocal以及value的强引用d，导致value不能够被回收，从而造成内存泄漏。通过使用弱引用，当ThreadLocal的强引用释放掉后，通过一次系统gc检查，发现ThreadLocal对象只有threadLocalMap中Entry的弱引用持有，此时根据弱引用的机制就会回收ThreadLocal对象，从而避免了内存泄露。当然ThreadLocal还有一些额外的保护措施，\n  if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)\n    return e;\n  else\n    return getEntryAfterMiss(key, i, e);\n&#125;\nprivate T setInitialValue() &#123;\n  T value &#x3D; initialValue();&#x2F;&#x2F;默认返回null，可重写此函数，见Context示例\n  Thread t &#x3D; Thread.currentThread();\n  ThreadLocalMap map &#x3D; getMap(t);\n  if (map !&#x3D; null) &#123;\n    map.set(this, value);&#x2F;&#x2F;添加键值对\n  &#125; else &#123;\n    createMap(t, value);&#x2F;&#x2F;创建threadLocals\n  &#125;\n  if (this instanceof TerminatingThreadLocal) &#123;\n    TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) this);\n  &#125;\n  return value;\n&#125;\nremove函数\npublic void remove() &#123;\n  ThreadLocalMap m &#x3D; getMap(Thread.currentThread());\n  if (m !&#x3D; null) &#123;\n    m.remove(this);\n  &#125;\n&#125;\n\n\n\n\n应用场景：ReentrantReadWriteLock，记录每个线程的重入次数\n&#x2F;&#x2F;位于ReentrantReadWriteLock.java中\nstatic final class HoldCounter&#123;\n  int count &#x3D; 0;\n  final long tid &#x3D; getTheadId(Thread.currentThread());\n&#125;\n&#x2F;&#x2F;集成自ThreadLocal\nstatic final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt;&#123;\n  public HoldCounter initialValue()&#123;\n    return new HoldCounter();\n  &#125;\n&#125;\nprivate transient ThreadLocalHoldCounter readHolds;\n\n5.锁产生的问题（活跃性问题）\n死锁：多个线程互相等待对方持有的资源，而导致线程无法继续执行的问题\n\n死锁举例\npublic class Demo&#123;\n  private Object lock1 &#x3D; new Object();\n  private Object lock2 &#x3D; new Object();\n  \n  public void f()&#123;\n    synchronized(lock1)&#123;\n      synchronized(lock2)&#123;\n        &#x2F;&#x2F;业务代码\n      &#125;\n    &#125;\n  &#125;\n  public void g()&#123;\n    synchronized(lock2)&#123;\n      synchronized(lock1)&#123;\n        &#x2F;&#x2F;业务代码\n      &#125;\n    &#125;\n  &#125;\n&#125;\n死锁检测：将资源依赖情况组织成有向图，通过DFS算法来检查是否有环，有环即有死锁存在。在发生死锁时，可以使用jstack这类工具将线程的运行状态等重要信息打印出来，来分析死锁发生的原因\n\n避免死锁的方法\n\n统一线程请求锁的顺序：以转账为例，实际情况使用数据库锁（可看作进程级锁）\npublic class Transaction&#123;\n  public static void transfer(Account from,Account to,double transAmount)&#123;\n    Account lockFirst &#x3D; from;\n    Account lockSecond &#x3D; to;\n    &#x2F;&#x2F;如果不转换的话，没法确定from和to所引用的对象是否顺序全局一致，可能是A+B和B+A\n    if(form.id &gt; to.id)&#123;\n      lockFirst &#x3D; to;\n      lockSecond &#x3D; from;\n    &#125;\n    \n    synchronized(lockFirst)&#123;\n      synchronized(lockSecond)&#123;\n        from.amount -&#x3D; transAmount;\n        to.amount +&#x3D; transAmount;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n避免线程持有锁并等待锁；如果一个线程请求一个锁时，这个锁已经被其他线程持有，那么这个线程不再阻塞等待这个锁，而是释放掉所持有的所有锁，让其他线程先执行，实现如下：\npublic class Demo&#123;\n  private Lock lock1 &#x3D; new ReentrantLock();\n  private Lock lock2 &#x3D; new ReentrantLock();\n  \n  private void f()&#123;\n    for(;;)&#123;\n      lock1.lock();\n      try&#123;\n        boolean locked &#x3D; lock2.trylock();\n        if(locked)&#123;&#x2F;&#x2F;获取到锁\n          try&#123;\n            &#x2F;&#x2F;业务逻辑\n            return;\n          &#125;finally&#123;\n            lock2.unlock();\n          &#125;\n        &#125;&#x2F;&#x2F;else 没有获取lock2锁，执行finally，释放lock1锁\n      &#125;finally&#123;\n        lock1.unlock();\n      &#125;\n    &#125;\n  &#125;\n  \n  public void g()&#123;\n    for(;;)&#123;\n      lock2.lock();\n      try&#123;\n        boolean locked &#x3D; lock1.trylock();\n        if(locked)&#123;&#x2F;&#x2F;获取到锁\n          try&#123;\n            &#x2F;&#x2F;业务逻辑\n            return;\n          &#125;finally&#123;\n            lock1.unlock();\n          &#125;\n        &#125;&#x2F;&#x2F;else 没有获取lock1锁，执行finally，释放lock2锁\n      &#125;finally&#123;\n        lock2.unlock();\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n\n\n\n活锁：\n\n上述避免死锁的方法2会出现活锁的情况，如下图\n\n\n活锁相对于死锁来说，线程不会阻塞，持续消耗CPU资源，相对于死锁来说，性能损耗更大，但是发生概率更低\n\n解决方法：在线程执行的过程中，暂停随机的一段时间，打破两个线程的持续同步。具体可以既可以通过在trylock()后添加sleep()语句，也可以将trylock()改为带超时时间的trylock()\npublic void f()&#123;\n  Random r &#x3D; new Random();\n  for(;;)&#123;\n    lock1.lock();\n    try&#123;\n      boolean locked &#x3D; false;\n      try&#123;\n        locked &#x3D; lock2.trylock(r.nextLong()%10, TImeUnit.MILLISECONDS);\n      &#125;catch(InterruptedException e)&#123;\n        &#x2F;&#x2F;log error and return\n      &#125;\n      if(locked)&#123;&#x2F;&#x2F;两个锁都获取了\n        try&#123;\n          &#x2F;&#x2F;业务逻辑\n          return;\n        &#125;finally&#123;\n          lock2.unlock();\n        &#125;\n      &#125;&#x2F;&#x2F;else 没有获取lock2锁，执行finally，释放lock1锁\n    &#125;finally&#123;\n      lock1.unlock();\n    &#125;\n  &#125;\n&#125;\n\n\n饥饿：发生的情况\n\n迟迟获取不到死锁或活锁\n非公平锁中，线程排队一直有插队的线程\n\n\n\n4.同步工具\n\n\n\n\n\n\n\n\n主要包括条件变量、信号量、Latch（CountDownLatch）、Barrier（CyclicBarrier）等，用来实现各种线程协作模式。\n1.条件变量\n条件变量的由来\n\n实现一个大小无限制的队列，而且是阻塞队列并且需要是线程安全的\npublic class Queue&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n\n  public void put(String elem)&#123;\n    synchronized(this)&#123;\n      list.add(count, elem);\n      count++;\n    &#125;\n  &#125;\n  public String get()&#123;\n    for(;;)&#123;\n      while(count &lt;&#x3D; 0)&#123;\n        &#x2F;&#x2F;自旋等待队列不为空，但会消耗CPU资源\n        &#x2F;&#x2F;添加sleep()函数可减少CPU的浪费，但是会使得唤醒响应不及时\n      &#125;\n      synchronized(this)&#123;&#x2F;&#x2F;队列不为空时才加锁\n        if(count &gt; 0)&#123;&#x2F;&#x2F;双重检测，否则会出现同时取元素的访问越界\n          count--;\n          return list.get(count);\n        &#125;&#x2F;&#x2F;else 重新自旋等待队列不为空，所以需要一个for循环\n      &#125;\n    &#125;\n  &#125;\n&#125;\nJava的条件变量可以分为两种\n\nJava提供的内置条件变量，即Object类上的wait()和notify()，类比于synchronized\nJUC提供的条件变量，使用Condition接口上的await()和signal()，类比于JUC提供的Lock锁\n\n\n\n\n内置条件变量使用方式\n\nObject源码\npublic class Object &#123;\n  &#x2F;&#x2F;线程调用此函数进入WAITTINTG状态，有两种情况返回：其他线程调用notify或notifyAll唤醒；\n  &#x2F;&#x2F;线程被中断，此时wait函数会抛出InterruptedException\n  public final void wait() throws InterruptedException &#123;wait(0);&#125;\n  &#x2F;&#x2F;线程调用此函数进入WAITTING状态，有三种情况返回：其他线程调用notify或notifyAll唤醒；\n  &#x2F;&#x2F;线程被中断，此时wait函数会抛出InterruptedException；等待时间超过了预设的超时时间，\n  &#x2F;&#x2F;即timeout毫秒+nacos纳秒\n  public final void wait(long timeout, int nanos) throws InterruptedException &#123;&#125;\n  &#x2F;&#x2F;跟上一个函数的唯一区别在于超时时间，此函数的超时时间只能精确到毫秒\n  public final native void wait(long timeout) throws InterruptedException;\n \t&#x2F;&#x2F;唤醒一个调用了同一个对象上的wait()函数的线程 \n  public final native void notify();\n  &#x2F;&#x2F;唤醒所有调用了同一个对象上的wait()函数的线程\n  public final native void notifyAll();\n&#125;\n改写Queue\npublic class QueueCond&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      this.notify();&#x2F;&#x2F;通知\n    &#125;\n  &#125;\n  \n  public String get()&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          this.wait();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;\n  &#125;\n&#125;\n条件变量的通用使用模式\n\n\n执行wait()或notify()前先加锁：如果不加锁就会出现线程安全问题（同时满足条件变量，同时执行业务逻辑），线程执行wait时会进入等待队列并且释放锁，否则会产生死锁问题\n使用while循环避免假唤醒：\n一种情况是：多个线程同时调用wait等待状态变量来满足条件，只有一个线程调用notifyAll函数，所有线程都被唤醒，但只有一个线程能执行逻辑，需要while让线程再次进入wait状态\n另一种情况是：两个线程等待不同的状态变量（A和B），同时放在同一个等待队列（调用了同一个对象上的wait函数），如果A资源到了，会唤醒所有进程，只有等待A的线程才会被执行，等待B的需要重新调用wait函数\n\n\n\n\n\n\n内置条件变量实现原理\n\n在Synchronized内置锁的实现原理中，ObjectMonitor类中有三个等待队列：_cxq、_EntryList、_WaitSet\nclass ObjectMonitor&#123;\n  void* volatile _object;&#x2F;&#x2F;该Monitor锁所属的对象\n  void* volatile _owner;&#x2F;&#x2F;获取到该Monitor锁的线程\n  ObjectWaiter* volatile _cxq;&#x2F;&#x2F;没有获取到锁的线程暂时存入_cxq\n  ObjectWaiter* volatile _EntryList;&#x2F;&#x2F;存储等待被唤醒的线程\n  ObjectWaiter* volatile _WaitSet;&#x2F;&#x2F;存储调用了wait的线程\n&#125;\n当某个线程调用wait函数时，线程会先将自己放入_WaitSet中，然后释放锁，并调用park方法阻塞自己，当某个线程调用notify函数时，如果_cxq和_EntryList均为空，那么它从_WaitSet中取出一个线程，直接调用unpark方法取消这个线程的阻塞状态，让其去竞争锁。当调用了wait函数的线程再次获取到锁，便会从wait函数中返回，执行后续业务逻辑。\n\nnotifyAll和notify的区别在于notifyAll会将_WaitSet中的所有线程都取出，然后放入_EntryList中等待锁。所有调用了wait函数的线程会依次获取到锁，然后执行后续业务逻辑\n\n\n\nJUC条件变量使用方式\n\n使用方式\npublic interface Condition &#123;\n  &#x2F;&#x2F;作用同Object的wait\n  void await() throws InterruptedException;\n  &#x2F;&#x2F;不可被中断版本\n  void awaitUninterruptibly();\n  &#x2F;&#x2F;等待超过nacosTimeout纳秒时函数返回，返回值为等待的时间\n  long awaitNanos(long nanosTimeout) throws InterruptedException;\n  &#x2F;&#x2F;同上，但可以设置时间单位unit\n  boolean await(long time, TimeUnit unit) throws InterruptedException;\n  &#x2F;&#x2F;等待某个时间点dealline是函数返回，返回值false表示超时返回，true为中断或被唤醒\n  boolean awaitUntil(Date deadline) throws InterruptedException;\n  &#x2F;&#x2F;以下两函数同notify，notifyAll\n  void signal();\n  void signalAll();\n&#125;\n改写Queue\npublic class QueueCondJUC&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  private Lock lock &#x3D; new ReentrantLock();\n  private Condition condition &#x3D; lock.newCondition();\n  \n  private void put(String elem)&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      condition.signal();&#x2F;&#x2F;通知\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n  public String get()&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          condition.await();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n&#125;\n\n\nJUC条件变量使用原理\n\nLock通过newCondition函数来创建Condition对象，其中ConditionObject类是AQS的内部类\n&#x2F;&#x2F;位于ReetrantLock中\nfinal ConditionObject newCondition() &#123;\n  return new ConditionObject();\n&#125;\n&#x2F;&#x2F;位于AbstractQueuedSynchronizer中\npublic class ConditionObject implements Condition, java.io.Serializable &#123;\n  private transient Node firstWaiter;\n  private transient Node lastWaiter;\n  public ConditionObject()&#123; &#125;\n  &#x2F;&#x2F;实现了Condition中的所有方法\n&#125;\nReentrantLock中有一个存放等待锁线程的队列，ConditionObject对象中包含一个调用await函数线程的队列，称前者为Lock等待队列，后者为Condition等待队列\n\nLock等待队列用双向链表实现；Condition等待队列用单向链表实现，两者共用同一节点定义，只不过Condition等待队列使用Node类中的nextWaiter属性作为节点的后继指针。\nstatic final class Node&#123;\n  volatile Thread thread;\n  volatile Node prev;\n  volatile Node next;\n  Node nextWaiter;&#x2F;&#x2F;用于Condition\n&#125;\nConditionObject对象的ReentrantLock对象所维护的等待队列的结构示意图\n\n\n\n\nCondition接口中的方法在ConditionObject类中的实现\n\nawaitUninterruptibly函数：不响应中断，\npublic final void awaitUninterruptibly() &#123;\n  &#x2F;&#x2F;将线程包裹为Node节点添加到Condition等待队列尾部\n  Node node &#x3D; addConditionWaiter();\n  &#x2F;&#x2F;将state修改为0，表示释放了锁\n  int savedState &#x3D; fullyRelease(node);\n  &#x2F;&#x2F;阻塞等待被signal或signalAll唤醒\n  boolean interrupted &#x3D; false;\n  while (!isOnSyncQueue(node)) &#123;&#x2F;&#x2F;检查节点是否已移动到Lock等待队列中\n    &#x2F;&#x2F;调用park函数进入阻塞状态，在被中断或另一线程调用signal时会返回，\n    &#x2F;&#x2F;对于情况一：但是此函数不响应中断，因此线程中断唤醒之后，再次调用park阻塞\n    &#x2F;&#x2F;对于情况二：另一线程调用signal会先将Condition等待队列中的线程移动到Lock等待队列，\n    &#x2F;&#x2F;然后调用unpark函数唤醒线程，isOnSyncQueue作用就是检查是否已经移动\n    LockSupport.park(this);\n    if (Thread.interrupted())\n      interrupted &#x3D; true;\n  &#125;\n  &#x2F;&#x2F;acquireQueued用来排队等待锁，见Lock原理\n  if (acquireQueued(node, savedState) || interrupted)\n    selfInterrupt();\n&#125;\nsignal函数\n&#x2F;&#x2F;按照FIFO原则处理Condition等待队列中的线程\npublic final void signal() &#123;\n  if (!isHeldExclusively())\n    throw new IllegalMonitorStateException();\n  &#x2F;&#x2F;从Condition等待队列的头部取一个节点\n  Node first &#x3D; firstWaiter;\n  if (first !&#x3D; null)\n    doSignal(first);\n&#125;\nprivate void doSignal(Node first) &#123;\n  do &#123;\n    if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)\n      lastWaiter &#x3D; null;\n    first.nextWaiter &#x3D; null;\n  &#125; while (!transferForSignal(first) &amp;&amp;\n           (first &#x3D; firstWaiter) !&#x3D; null);\n&#125;\n&#x2F;&#x2F;将取的节点，放入Lock等待队列中，并调用unpack函数唤醒对应的线程\nfinal boolean transferForSignal(Node node) &#123;\n  if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n    return false;\n  Node p &#x3D; enq(node);\n  int ws &#x3D; p.waitStatus;\n  if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n    LockSupport.unpark(node.thread);\n  return true;\n&#125;\n\n\n\n\n\n2.信号量\n信号量\n\nJUC提供了Semaphore类来实现信号量，用来限制临界区和共享资源的并发访问。使用互斥锁，临界区和共享资源同时只被一个线程访问；使用信号量，临济区和共享资源同时可被多个线程访问。信号量可以看成共享锁，底层使用AQS实现。\n\n应用举例：一个接口服务器，同一时刻控制只有N个线程并发执行\n\n实现一：AtomicInteger原子类\npublic class Demo&#123;\n  &#x2F;&#x2F;apiX接口同时只允许10个线程并发执行\n  private final AtomicInteger permits &#x3D; new AtomicInteger(10);\n  \n  public void apiX()&#123;\n    int newPermits &#x3D; permits.decrementAndGet();\n    if(newPermits &lt; 0)&#123;\n      permits.incrementAndGet();\n      return;&#x2F;&#x2F;拒绝执行业务逻辑，直接返回\n    &#125;\n    \n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      permits.incrementAndGet();\n    &#125;\n  &#125;\n&#125;\n使用锁\npublic class Demo&#123;\n  &#x2F;&#x2F;apiX接口同时只允许10个线程并发执行\n  private int permits &#x3D; 10;\n  public void apiX()&#123;\n    if(permits &lt;&#x3D; 0)&#123;\n      return;\n    &#125;\n    synchronized(this)&#123;\n      if(permits &lt;&#x3D; 0)&#123;&#x2F;&#x2F;双重检测\n        return;\n      &#125;\n      permits--;\n    &#125;\n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      synchronized(this)&#123;\n        permits++;\n      &#125;\n    &#125;\n  &#125;\n&#125;\n等待通知机制：上述两种实现，在第11个线程调用apiX时，将无法获取到许可（permit），于是直接返回，这样会使得大量接口请求被拒绝。可以将无法获取许可的线程阻塞，等有许可的时候再唤醒，但是这样会让接口请求的响应时间增大。即可以用条件变量来实现\npublic class Demo&#123;\n  &#x2F;&#x2F;apiX接口同时只允许10个线程并发执行\n  private int permits &#x3D; 10;\n  private Lock lock &#x3D; new ReentrantLock();\n  private Condition condition &#x3D; lock.newCondition():\n  public void apiX()&#123;\n    &#x2F;&#x2F;阻塞访问condition\n    lock.lock():\n    try&#123;\n      while(permits &lt;&#x3D; 0)&#123;\n        &#x2F;&#x2F;线程阻塞\n        condition.awaitUninterruptibly();\n      &#125;\n      &#x2F;&#x2F;获取许可\n      permits--;\n    &#125;finally&#123;\n      lock.unlock();\n    &#125;\n    \n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      lock.lock();\n      permits++;\n      &#x2F;&#x2F;唤醒线程\n      condition.signal();\n      lock.unlock();\n    &#125;\n  &#125;\n&#125;\n\n\nSemaphore类\n\n如果信号量中的许可个数为1，那么信号量就退化成了互斥锁；如果互斥量的许可个数大于1，信号量就可以看作是一种共享锁\n信号量与锁的区别是，释放锁的线程必须持有锁，而信号量则不用。即没有调用acquire()函数的线程也可以直接调用release()函数，用来增加可用许可个数。此时，信号量不再是用来限制对临界区的并发访问，而是用来对共享资源的并发访问。\n\npublic class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;第一组，默认一次获取或释放的许可（permit）个数为1\n  public void acquire() throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly() &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire()&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release()&#123;&#125;\n  &#x2F;&#x2F;第二组，默认制定一次获取或释放的许可个数\n  public void acquire(int permits) throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly(int permits) &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire(int permits)&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(int permits, long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release(int permits)&#123;&#125;\n&#125;\n\n\n并发访问控制\n\n临界区并发访问控制\npublic class Demo&#123;\n  private final Semaphore semaphore &#x3D; new Semaphore(10);\n  \n  public void apiX()&#123;\n    semaphore.acquireUniterruptibly();\n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      semaphore.release();\n    &#125;\n  &#125;\n&#125;\n共享资源并发访问控制\npublic class QueueSemaphore&#123;\n  private static final int Q_SIZE &#x3D; 20;\n  &#x2F;&#x2F;表示队列中的空闲位置\n  private Semaphore semaphore &#x3D; new Semaphore(Q_SIZE);\n  private list&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(Q_SIZE);\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    &#x2F;&#x2F;当可用许可个数为0时，线程执行put函数时会阻塞在acquireUniterruptibly()函数中\n    semaphore.acquireUniterruptibly();\n    synchronized(this)&#123;\n      list.add(count, elem);\n      count++;\n    &#125;\n  &#125;\n  public String get()&#123;\n    if(count &#x3D;&#x3D; 0) return null;\n    synchronized(this)&#123;\n      if(count &#x3D;&#x3D; 0) return null;&#x2F;&#x2F;双重检测\n      String ret &#x3D; list.get(--count);\n      semaphore.release();\n      return ret;\n    &#125;\n  &#125;\n&#125;\n\n\n信号量的实现原理\n\n基于AQS\npublic class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;实现AQS\n  private final Sync sync;\n  abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n    Sync(int permits) &#123;setState(permits);&#125;\n    protected final boolean tryReleaseShared(int releases) &#123;&#125;\n  &#125;\n\n  static final class NonfairSync extends Sync &#123;\n    NonfairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      return nonfairTryAcquireShared(acquires);\n    &#125;\n  &#125;\n  \n  &#x2F;*\n  final int nonfairTryAcquireShared(int acquires) &#123;\n    for (;;) &#123;\n      int available &#x3D; getState();&#x2F;&#x2F;许可个数存放在state变量中\n      int remaining &#x3D; available - acquires;\n      if (remaining &lt; 0 ||\n          compareAndSetState(available, remaining))\n        return remaining;\n    &#125;\n  &#125;\n  *&#x2F;\n\n  static final class fairSync extends Sync &#123;\n    fairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      for (;;) &#123;\n        if (hasQueuedPredecessors()) return -1;&#x2F;&#x2F;比NonfairSync多了这一行\n        int available &#x3D; getState();\n        int remaining &#x3D; available - acquires;\n        if (remaining &lt; 0 ||\n            compareAndSetState(available, remaining))\n          return remaining;\n      &#125;\n    &#125;\n  &#125;\n\n  public Semaphore(int permits) &#123;&#x2F;&#x2F;默认非公平模式\n    sync &#x3D; new NonfairSync(permits);\n  &#125;\n  public Semaphore(int permits, boolean fair) &#123;&#x2F;&#x2F;指定工作模式（公平&#x2F;非公平）\n    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);\n  &#125;\n  &#x2F;&#x2F;暂时省略核心方法的实现\n&#125;\n\n\nacquireUninterruptibly()函数\n\n源码\n&#x2F;&#x2F;位于Semaphore.java中\npublic void acquireUninterruptibly() &#123;\n  sync.acquireShared(1);\n&#125;\n&#x2F;&#x2F;位于AbstractQueuedSynchronizer.java中\npublic final void acquireShared(int arg) &#123;\n  if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争获取许可，返回值&lt;0表示失败，需要排队等待许可\n    doAcquireShared(arg);&#x2F;&#x2F;排队等待许可\n&#125;\n&#x2F;&#x2F;其中tryAcquireShared()函数的代码实现位于NonfairSync和FairSync中，实现见上\n&#x2F;&#x2F;两种实现均通过自旋+CAS的方式获取许可，唯一区别是从等待队列中取还是可以插队\n\n\nrelease()函数\npublic void release() &#123;\n  sync.releaseShared(1);\n&#125;\npublic final boolean releaseShared(int arg) &#123;\n  if (tryReleaseShared(arg)) &#123;\n    doReleaseShared();\n    return true;\n  &#125;\n  return false;\n&#125;\n&#x2F;&#x2F;采用自旋+CAS来更新state\nprotected final boolean tryReleaseShared(int releases) &#123;\n  for (;;) &#123;\n    int current &#x3D; getState();\n    int next &#x3D; current + releases;\n    if (next &lt; current) &#x2F;&#x2F; overflow\n      throw new Error(&quot;Maximum permit count exceeded&quot;);\n    if (compareAndSetState(current, next))\n      return true;\n  &#125;\n&#125;\n&#x2F;&#x2F;用来唤醒排队等待许可的第一个线程，即等待队列中的第一个线程，详见ReentrantReadWriteLock\nprivate void doReleaseShared() &#123;\n  for (;;) &#123;\n    Node h &#x3D; head;\n    if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;\n      int ws &#x3D; h.waitStatus;\n      if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;\n        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n          continue;            &#x2F;&#x2F; loop to recheck cases\n        unparkSuccessor(h);\n      &#125;\n      else if (ws &#x3D;&#x3D; 0 &amp;&amp;\n               !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n        continue;                &#x2F;&#x2F; loop on failed CAS\n    &#125;\n    if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed\n      break;\n  &#125;\n&#125;\n\n\n\n\n\n3.Latch&amp;Barrier\n\n\n\n\n\n\n\n\n用于线程之间的协调执行\n\nCountDownLatch的用法\n\n中文叫锁存器，源码如下，\npublic class CountDownLatch &#123;\n  &#x2F;&#x2F;具体化抽象模版方法类AQS\n  private static final class Sync extends AbstractQueuedSynchronizer &#123;\n    Sync(int count) &#123;setState(count);&#125;&#x2F;&#x2F;将count值存储在AQS的state中\n    protected int tryAcquireShared(int acquires) &#123;&#x2F;&#x2F;实现AQS的抽象方法\n      return (getState() &#x3D;&#x3D; 0) ? 1 : -1;&#x2F;&#x2F;检查count是不是为0了\n    &#125;\n    protected boolean tryReleaseShared(int releases) &#123;&#x2F;&#x2F;实现AQS的抽象方法\n      &#x2F;&#x2F; Decrement count; signal when transition to zero\n      for (;;) &#123;\n        int c &#x3D; getState();\n        if (c &#x3D;&#x3D; 0)\n          return false;\n        int nextc &#x3D; c-1;\n        if (compareAndSetState(c, nextc))\n          return nextc &#x3D;&#x3D; 0;\n      &#125;\n    &#125;\n  &#125;\n  \n  private final Sync sync;\n  \n  &#x2F;&#x2F;构造函数，传入count值\n  public CountDownLatch(int count) &#123;\n    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);\n    this.sync &#x3D; new Sync(count);\n  &#125;\n  &#x2F;&#x2F;阻塞等待count值变为0\n  public void await() throws InterruptedException &#123;\n    sync.acquireSharedInterruptibly(1);&#x2F;&#x2F;使用Sync的模版方法编程\n  &#125;\n  public boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException &#123;\n    &#x2F;&#x2F;使用Sync的模版方法编程\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n  &#125;\n  &#x2F;&#x2F;将count值减一\n  public void countDown() &#123;\n    sync.releaseShared(1);&#x2F;&#x2F;使用Sync的模版方法编程\n  &#125;\n&#125;\n类似于Thread类中的join()函数，用于一个线程等待其他多个线程的事件发生，对于join()函数来说，这里的事件指的是线程结束。对于CountDownLatch来说，这里的事件可以根据业务逻辑来定义。另外，使用join需要知道被等待的线程是谁，而CountDownLatch则不需要。因此CountDownLatch相对于join更加通用\n\n示例：\npublic class DemoJoin&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new RunnableForJoin());\n    THread t2 &#x3D; new THread(new RunnableForJoin());\n    t1.start();\n    t2.start();\n    t1.join();&#x2F;&#x2F;join只用来等待线程执行结束，并且必须知道被等待线程是谁\n    t2.join();\n  &#125;\n  public static class RunnableForJoin implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;业务逻辑\n    &#125;\n  &#125;\n&#125;\npublic class DemoLatch&#123;\n  private static final CountDownLatch latch &#x3D; new CountDownLatch(2);\n  public static void main(String[] args) throws InterruptedException&#123;\n    new Thread(new RunnableForLatch()).start();\n    new Thread(new RunnbaleForLatch()).start();\n    latch.await();&#x2F;&#x2F;等待something执行完成而非等待线程结束，并且不需要知道在等谁\n    &#x2F;&#x2F;执行后续逻辑\n  &#125;\n  public static class RunnableForLatch implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;do something\n      latch.countDown();\n      &#x2F;&#x2F;do otheer thing\n    &#125;\n  &#125;\n&#125;\n\n\nCountDownLatch的实现原理\n\n底层依赖AQS来实现，代码结构大致为：具体化抽象模版方法类AQS；在具体类Sync中实现AQS中的抽象方法；使用具体类Sync中的模版方法来编程\n\nawait函数：await函数直接调用AQS的acquireSharedInterruptibly函数，源码如下，其中count值存在state中。\npublic final void acquireSharedInterruptibly(int arg)\n  throws InterruptedException &#123;\n  if (Thread.interrupted())\n    throw new InterruptedException();\n  &#x2F;&#x2F;调用tryAcquireShared函数查看state，如果state为0，则直接返回，\n  &#x2F;&#x2F;否则，调用doAcquireSharedInterruptibly函数阻塞等待state变为0\n  if (tryAcquireShared(arg) &lt; 0)\n    doAcquireSharedInterruptibly(arg);&#x2F;&#x2F;阻塞等待state为0\n&#125;\n&#x2F;&#x2F;原理同ReentrantReadWriteLock的doAcquireShared函数\nprivate void doAcquireSharedInterruptibly(int arg)\n  throws InterruptedException &#123;\n  final Node node &#x3D; addWaiter(Node.SHARED);\n  boolean failed &#x3D; true;\n  try &#123;\n    for (;;) &#123;\n      final Node p &#x3D; node.predecessor();\n      if (p &#x3D;&#x3D; head) &#123;\n        int r &#x3D; tryAcquireShared(arg);\n        if (r &gt;&#x3D; 0) &#123;\n          setHeadAndPropagate(node, r);\n          p.next &#x3D; null; &#x2F;&#x2F; help GC\n          failed &#x3D; false;\n          return;\n        &#125;\n      &#125;\n      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n          parkAndCheckInterrupt())\n        throw new InterruptedException();\n    &#125;\n  &#125; finally &#123;\n    if (failed)\n      cancelAcquire(node);\n  &#125;\n&#125;\ncountDown函数：直接调用AQS的releaseShared函数来实现，源码如下，\n@ReservedStackAccess\npublic final boolean releaseShared(int arg) &#123;\n  &#x2F;&#x2F;将state减1，如果此时state变为0，则执行doReleaseShared\n  if (tryReleaseShared(arg)) &#123;\n    &#x2F;&#x2F;唤醒等待队列中的线程，即唤醒调用了await函数的线程\n    doReleaseShared();\n    return true;\n  &#125;\n  return false;\n&#125;\n\n\nCyclicBarrier的用法\n\n中文名为栅栏，主要用于多个线程互相等待，互相等待的线程都就位之后，再同时开始执行。\npublic class CyclicBarrier &#123;\n  &#x2F;&#x2F;构造函数，传入parties\n  public CyclicBarrier(int parties) &#123;\n    this(parties, null);\n  &#125;\n  public CyclicBarrier(int parties, Runnable barrierAction) &#123;\n    if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();\n    this.parties &#x3D; parties;\n    this.count &#x3D; parties;\n    this.barrierCommand &#x3D; barrierAction;\n  &#125;\n  &#x2F;&#x2F;调用await函数的线程会将parties减一，如果不为0，则阻塞，直到为0为止\n  public int await() throws InterruptedException, BrokenBarrierException &#123;\n    try &#123;\n      return dowait(false, 0L);\n    &#125; catch (TimeoutException toe) &#123;\n      throw new Error(toe); &#x2F;&#x2F; cannot happen\n    &#125;\n  &#125;\n  public int await(long timeout, TimeUnit unit)\n    throws InterruptedException,BrokenBarrierException,TimeoutException &#123;\n    return dowait(true, unit.toNanos(timeout));\n  &#125;\n&#125;\n示例\npublic class Demo&#123;\n  &#x2F;&#x2F;创建parties为10的CyclicBarrier对象，用于10个线程之间相互等待，尽管10个线程的启动（执行\n  &#x2F;&#x2F;start函数）的时间不同，但每个线程结束都会调用await函数，将paeties减一，然后检查parties\n  &#x2F;&#x2F;如果不为0，则当前线程阻塞等待，如果parties为0，则当前线程唤醒所有调用了await函数的线程。\n  private static final CyclicBarrier barrier &#x3D; new CyclicBarrier(10);\n  public static void main(String[] args)&#123;\n    for(int i&#x3D;0; i&lt;10; ++i)&#123;\n      new Thread(new Runnbale()&#123;\n        @Override\n        public void run()&#123;\n          try&#123;\n            barrier.await();\n          &#125;catch(InterruptedException e)&#123;&#x2F;&#x2F;当前线程被中断\n            e.printStackTrace();\n          &#125;catch(BrokenBarrierException e)&#123;&#x2F;&#x2F;其他线程调用await()期间被中断\n            e.printStachTrace();\n          &#125;\n          &#x2F;&#x2F;执行业务逻辑\n        &#125;\n      &#125;).start();\n    &#125;\n    &#x2F;&#x2F;主线程需要等待以上10个线程执行结束，方法有以下3种：\n    &#x2F;&#x2F;1.sleep() 2.join() 3.CountDownLatch()\n  &#125;\n&#125;\n使用CountDownLatch实现CyclicBarrier的功能\npublic class Demo&#123;\n  &#x2F;&#x2F;10个线程都调用await函数阻塞等待count为0，主线程调用countDown函数将count值减一，变为0，\n  &#x2F;&#x2F;然后唤醒调用了await函数的10个线程，实现10个线程同步执行的功能\n  private static final CountDownLatch latch &#x3D; new CountDownLatch(1);\n  public static void main(String[] args)&#123;\n    for(int i &#x3D; 0; i&lt; 10; ++i)&#123;\n      new Thread(new Runnable()&#123;\n        @Override\n        public void run()&#123;\n          try&#123;\n            latch.await();\n          &#125;catch(InterruptedExceptino e)&#123;\n            e.printStackTrace();\n          &#125;\n          &#x2F;&#x2F;执行业务逻辑\n        &#125;\n      &#125;).start();\n    &#125;\n    latch.countDown();\n    &#x2F;&#x2F;主线程需要等待以上10个线程执行结束，方法有以下3种：\n    &#x2F;&#x2F;1.sleep() 2.join() 3.CountDownLatch()\n  &#125;\n&#125;\n\n\nCyclicBarrier的实现原理：使用条件变量来实现\npublic class CyclicBarrier &#123;\n  private final ReentrantLock lock &#x3D; new ReentrantLock();\n  private final Condition trip &#x3D; lock.newCondition();\n  private final int parties;\n  public CyclicBarrier(int parties) &#123;\n    this(parties, null);\n  &#125;\n  &#x2F;&#x2F;函数返回值线程调用await()函数之后的parties剩余值\n  &#x2F;&#x2F;await调用的dowait，省略了对InterruptedException和BrokenBarrierException的处理\n  private int dowait(boolean timed, long nanos)throws InterruptedException, \n  BrokenBarrierException,TimeoutException &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      int index &#x3D; --count;\n      if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F;最后一个调用await()的线程，唤醒其他线程\n        trip.signalAll();&#x2F;&#x2F;在breakBarrier中\n        return 0;\n      &#125;\n      trip.await();\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n&#125;\n在接口性能测试中的应用：接口并发性能测试代码，如果测试N个接口请求并发执行时接口的性能，我们需要创建N个测试线程，让每个测试线程循环执行接口请求，并且记录每个接口请求的响应时间。主线程通过CountDownLatch来等待其他测试线程执行完成，然后，再通过记录的运行数据统计接口的性能，比如平均响应时间、QPS等。使用CyclicBarrier，让各测试线程更加精确地同时开始执行，以便更加准确地测试执行并发下的接口性能。\npublic class ApiBenchmark&#123;\n  private static int numThread &#x3D; 20;&#x2F;&#x2F;并发度为20\n  private static int numReqPerThread &#x3D; 1000;&#x2F;&#x2F;每个线程请求1000次接口\n  \n  private static CountDownLatch latch &#x3D; new CountDownLatch(numThread);\n  private static CyclicBarrier barrier &#x3D; new CyclicBarrier(numThread);\n  \n  public static void main(String[] args)throws InterruptedException&#123;\n    &#x2F;&#x2F;创建线程\n    Thread[] threads &#x3D; new Thread[numThread];\n    TestRunnable[] runnables &#x3D; new TestRunnable[numThread];\n    for(int i &#x3D; 0; i &lt; numThread; ++i)&#123;\n      runnable[i] &#x3D; new TestRunnable();\n      thread[i] &#x3D; new Thread(runnable[i]);\n    &#125;\n    &#x2F;&#x2F;启动线程\n    long startTime &#x3D; System.nanoTime();\n    for(int i &#x3D; 0; i &lt; numThread; ++i)&#123;\n      thread[i].start();\n    &#125;\n    &#x2F;&#x2F;等待测试线程结束\n    latch.await();\n    long endTime &#x3D; System.nanoTime();\n    &#x2F;&#x2F;统计接口性能\n    long qps &#x3D; (numThread*numReqPerThread*1000)&#x2F;((endTime-startTIme)&#x2F;1000000);\n    float avgRespTime &#x3D; 0.0f;\n    for(int i &#x3D; 0; i &lt; numThread; ++i)&#123;\n      for(Long respTime : runnables[i].respTime)&#123;\n        avgRespTime +&#x3D; respTime;\n      &#125;\n    &#125;\n    avgRespTime &#x2F;&#x3D; (numThread*numReqPerThread);\n  &#125;\n  \n  public static class TestRunnable implements Runnable&#123;\n    public List&lt;Long&gt; respTimes &#x3D; new ArrayList&lt;&gt;();\n    @Override\n    public void run()&#123;\n      try&#123;\n        &#x2F;&#x2F;所有线程同时开始执行\n        barrier.await();\n      &#125;catch(InterruptedException e)&#123;\n        e.printStackTrace();\n      &#125;catch(BrokenBarrierException e)&#123;\n        e.printStackTrace();\n      &#125;\n      for(int i &#x3D; 0; i &lt; numReqPerThread; ++i)&#123;\n        long reqStartTime &#x3D; System.nanoTime();\n        &#x2F;&#x2F;调用接口\n        long reqEndTime &#x3D; System.nanoTime();\n        respTimes.add(reqEndTime-reqStartTime);\n      &#125;\n      latch.countDown();\n    &#125;\n  &#125;\n&#125;\n\n5.并发容器\n\n\n\n\n\n\n\n\nConcurrentHashMap、各种阻塞队列\n\nJava容器回顾：除了废弃的几个，都不是线程安全的\n\nList：ArrayList、LinkedList、Vector（废弃）\nStack：Stack（废弃）\nQueue：ArrayDeque、LinkedList、PriorityQueue\nSet：HashSet、LinkedHashSet、TreeSet\nMap：HashMap、LinkedHashMap、TreeMap、HashTable（废弃）\n\n\nJava并发容器：为了更符合开发者的编程习惯，JCF将非线程安全容器和线程安全容器（并发容器）分开来设计，在非多线程环境下，使用非线程安全的容器，性能更高。\n\n并发容器：\n\nSynchronizedCollection\nSynchronizedSet、SynchronizedSortedSet、SynchronizedNavigableSet\nSynchronizedList、SynchronizedRandomAccessList\nSynchronizedMap、SynchronizedSortedMap、SynchronizedNavigableMap\n\n\n创建方法\n\n\n创建示例\nList list &#x3D; Collections.synchronziedList(new LinkedList&lt;&gt;());\n源码示例：通过使用synchronized加锁来避免线程安全问题\npublic static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;\n  return (list instanceof RandomAccess ?\n          new SynchronizedRandomAccessList&lt;&gt;(list) :\n          new SynchronizedList&lt;&gt;(list));\n&#125;\nstatic class SynchronizedList&lt;E&gt;\n  extends SynchronizedCollection&lt;E&gt; implements List&lt;E&gt; &#123;\n  final List&lt;E&gt; list;\n\n  SynchronizedList(List&lt;E&gt; list) &#123;\n    super(list);\n    this.list &#x3D; list;\n  &#125;\n  SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;\n    super(list, mutex);\n    this.list &#x3D; list;\n  &#125;\n\n  public boolean equals(Object o) &#123;\n    if (this &#x3D;&#x3D; o)\n      return true;\n    synchronized (mutex) &#123;return list.equals(o);&#125;\n  &#125;\n  public int hashCode() &#123;\n    synchronized (mutex) &#123;return list.hashCode();&#125;\n  &#125;\n\n  public E get(int index) &#123;\n    synchronized (mutex) &#123;return list.get(index);&#125;\n  &#125;\n  public E set(int index, E element) &#123;\n    synchronized (mutex) &#123;return list.set(index, element);&#125;\n  &#125;\n  public void add(int index, E element) &#123;\n    synchronized (mutex) &#123;list.add(index, element);&#125;\n  &#125;\n  public E remove(int index) &#123;\n    synchronized (mutex) &#123;return list.remove(index);&#125;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;\n\n\nJUC并发容器：因为上述Java提供的并发容器代码实现简单，锁粒度大而导致并发性能不高，于是JUC变实现了一套更高性能的并发容器，使用了分段加锁、写时复制、无锁编程等技术进行了全新的实现。主要提供了以下并发容器，按照Java容器的对应关系进行分类\n\nList：JUC提供了CopyOnWriteArrayList，只适合读多写少的场景，没有LinkedList相关的并发容器\nStack：栈可以用双端队列（Deque）来替代，JUC没有提供相关的容器\nQueue：\n非阻塞并发队列（基于链表实现）：ConcurrentLinkedDequeue、ConcurrentLinkedQueue\n阻塞并发队列：ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue、DelayQueue、SynchronousQueue、LinkedTransferQueue\n\n\nSet：CopyOnWriteArraySet（对应HashSet）、ConcurrentSkipListSet（对应TreeSet）\nMap：ConcurrentHashMap（对应HashMap）、ConcurrentSkipListMap（对应TreeMap）\n\n\n\n\n1.并发阻塞\n阻塞并发队列\n\n阻塞并发队列有两个特点：线程安全和支持读写阻塞。读写阻塞即队列空时读操作阻塞，直到队列有新数据写入；队列满时写操作阻塞，直到队列有数据被读走。阻塞并发队列一般用于实现生产者-消费者模型。\nJUC提供的阻塞并发队列有：ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue、DelayQueue、SynchronousQueue、LinkedTransferQueueQ\n\n\nBlockingQueue\n\nArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue的实现原理类似，都是基于ReentrantLock锁来实现线程安全，基于Condition条件变量来实现阻塞等待，下面将以ArrayBlockingQueue为例\n\nArrayBlockingQueue\n\n源码一：使用方法和普通队列类似，只不过增加了读写可阻塞\npublic class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;\n  implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;\n  final Object[] items;\n  int takeIndex;&#x2F;&#x2F;下一次入队时，数据存储的下标位置\n  int putIndex;&#x2F;&#x2F;下一次出队时，出队数据的下标位置\n  int count;&#x2F;&#x2F;队列中的元素个数\n\n  final ReentrantLock lock;&#x2F;&#x2F;加锁实现线程并发安全\n  private final Condition notEmpty;&#x2F;&#x2F;用来阻塞读，等待非空条件的发生\n  private final Condition notFull;&#x2F;&#x2F;用来阻塞写，等待非满条件的发生\n\n  public ArrayBlockingQueue(int capacity) &#123;\n    this(capacity, false);\n  &#125;\n  &#x2F;&#x2F;支持公平和非公平两种工作模式，默认为非公平\n  public ArrayBlockingQueue(int capacity, boolean fair) &#123;\n    if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException();\n    this.items &#x3D; new Object[capacity];&#x2F;&#x2F;底层基于数组实现的有界阻塞并发队列\n    lock &#x3D; new ReentrantLock(fair);&#x2F;&#x2F;公平性依赖锁的公平性来实现，即是否可插队获取锁\n    notEmpty &#x3D; lock.newCondition();\n    notFull &#x3D;  lock.newCondition();\n  &#125;\n  &#x2F;&#x2F;见下\n&#125;\n源码二：支持读写阻塞的put和take函数\n&#x2F;&#x2F;入队函数，支持阻塞写\npublic void put(E e) throws InterruptedException &#123;\n  checkNotNull(e);\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lockInterruptibly();&#x2F;&#x2F;加锁，被中断时会抛出异常\n  try &#123;\n    while (count &#x3D;&#x3D; items.length)&#x2F;&#x2F;循环是为了避免假唤醒，唤醒后还再检查一遍\n      notFull.await();&#x2F;&#x2F;调用await函数，等待非满条件的唤醒，\n    enqueue(e);&#x2F;&#x2F;入队\n  &#125; finally &#123;\n    lock.unlock();&#x2F;&#x2F;解锁\n  &#125;\n&#125;\nprivate void enqueue(E x) &#123;\n  &#x2F;&#x2F;调用enqueue时已加锁，不用担心线程安全问题，而且队列未满，不需要处理队列满的情况\n  final Object[] items &#x3D; this.items;\n  items[putIndex] &#x3D; x;&#x2F;&#x2F;放入队列对应位置\n  if (++putIndex &#x3D;&#x3D; items.length)\n    putIndex &#x3D; 0;&#x2F;&#x2F;循环队列\n  count++;\n  notEmpty.signal();&#x2F;&#x2F;唤醒等待执行读的线程\n&#125;\n\n&#x2F;&#x2F;出队函数，支持阻塞读\npublic E take() throws InterruptedException &#123;\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lockInterruptibly();\n  try &#123;\n    while (count &#x3D;&#x3D; 0)\n      notEmpty.await();&#x2F;&#x2F;等待非空条件的发生，\n    return dequeue();&#x2F;&#x2F;队列非空时，执行出队操作，并返回出队元素\n  &#125; finally &#123;\n    lock.unlock();\n  &#125;\n&#125;\nprivate E dequeue() &#123;\n  &#x2F;&#x2F;不需要处理线程安全问题以及队列为空的情况\n  final Object[] items &#x3D; this.items;\n  @SuppressWarnings(&quot;unchecked&quot;)\n  E x &#x3D; (E) items[takeIndex];\n  items[takeIndex] &#x3D; null;\n  if (++takeIndex &#x3D;&#x3D; items.length)\n    takeIndex &#x3D; 0;\n  count--;\n  if (itrs !&#x3D; null)\n    itrs.elementDequeued();\n  notFull.signal();\n  return x;\n&#125;\n\n\n\n源码三：非阻塞的offer和poll函数，只通过ReentrantLock锁来保证线程安全，没有通过条件变量来实现阻塞读写\npublic boolean offer(E e) &#123;\n  Objects.requireNonNull(e);\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lock();\n  try &#123;\n    if (count &#x3D;&#x3D; items.length)\n      return false;\n    else &#123;\n      enqueue(e);\n      return true;\n    &#125;\n  &#125; finally &#123;\n    lock.unlock();\n  &#125;\n&#125;\npublic E poll() &#123;\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lock();\n  try &#123;\n    return (count &#x3D;&#x3D; 0) ? null : dequeue();\n  &#125; finally &#123;\n    lock.unlock();\n  &#125;\n&#125;\n\n\n其余三个：均适用ReentrantLock来保证线程安全性，使用Condition条件变量来实现读写操作的阻塞等待\n\nLinkedBlockingQueue是基于链表实现的有界阻塞并发队列，默认大小为Integer.MAX_VALUE，也可以指定队列大小\nLinkedBlockingDeque与LinkedBlockingQueue的区别在于，它是一个双端队列，支持两端读写操作\nPriorityBlockingQueue是一个无界阻塞并发优先级队列，底层基于支持扩容的堆来实现，写操作永远不需要阻塞，只有读操作会阻塞\n\n\n\n\nDelayQueue\n\n源码一：延迟阻塞并发队列，底层基于PriorityQueue来实现，因为PriorityQueue支持动态扩容，所以DelayQueue为无界队列，写永远都不会阻塞，只有读会阻塞。DelayQueue中存储的每个元素都必须实现Delayed接口，提供延迟被读取时间delayTime，PriorityQueue按照delayTime的大小将元素组织成最小顶堆，也就是说，堆顶的元素是delayTime最小的元素，应该最先被读取到。\npublic class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;\n  implements BlockingQueue&lt;E&gt; &#123;\n  private final transient ReentrantLock lock &#x3D; new ReentrantLock();&#x2F;&#x2F;可重入锁\n  private final PriorityQueue&lt;E&gt; q &#x3D; new PriorityQueue&lt;E&gt;();&#x2F;&#x2F;支持动态扩容\n  \n  private Thread leader;&#x2F;&#x2F;线程指定等待队列头元素\n  private final Condition available &#x3D; lock.newCondition();\n&#125;\n&#x2F;&#x2F;DelayQueue存储的每个元素都需要实现Delayed接口\npublic interface Delayed extends Comparable&lt;Delayed&gt; &#123;\n  long getDelay(TimeUnit unit);&#x2F;&#x2F;按照delayTime的大小来建堆\n&#125;\n源码二：take函数，包含两个逻辑，针对leader线程的逻辑和针对非leader线程的逻辑。当多个线程先后调用take函数，第一个线程就是leader线程，剩下的就是非leader线程。第一个线程执行读取操作完成之后，第二个线程便称为leader线程。\n\n非leader线程直接调用await函数阻塞，等待leader线程执行完成之后调用signal来唤醒\nleader线程读取的是队首的元素，如果队首的元素delayTime大于0，那么leader线程会调用awaitNanos阻塞delayTime时间，当delayTime时间过去之后，leader线程自动唤醒，为了避免假唤醒（插队情况见下），leader线程会检查队首元素的delayTime是否真正变为小于等于0，如果是，则队首元素出队，调用signal唤醒第二个线程，第二个线程就成了leader线程\n插队情况：如果一个线程执行take函数时，如果检查发现队列不为空，并且队首元素的delayTime小于等于0，于是，不管是不是有其他线程在调用await或awaitNanos阻塞等待，这个线程都会直接读取队首元素并返回\n\n\npublic E take() throws InterruptedException &#123;\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lockInterruptibly();\n  try &#123;\n    for (;;) &#123;&#x2F;&#x2F;自旋，以免假唤醒\n      E first &#x3D; q.peek();\n      if (first &#x3D;&#x3D; null) available.await();&#x2F;&#x2F;put函数会调用signal唤醒它\n      else &#123;\n        long delay &#x3D; first.getDelay(NANOSECONDS);&#x2F;&#x2F;获取延迟时间\n        if (delay &lt;&#x3D; 0L) return q.poll();&#x2F;&#x2F;元素到期被读取，会有插队情况\n        first &#x3D; null;  \n        if (leader !&#x3D; null) available.await();&#x2F;&#x2F;不是第一个读阻塞等待的线程\n        else &#123;&#x2F;&#x2F;第一个读阻塞等待的线程\n          Thread thisThread &#x3D; Thread.currentThread();\n          leader &#x3D; thisThread;\n          try &#123;\n            available.awaitNanos(delay);&#x2F;&#x2F;等待delay时间自己唤醒\n          &#125; finally &#123;\n            if (leader &#x3D;&#x3D; thisThread)\n              leader &#x3D; null;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125; finally &#123;\n    &#x2F;&#x2F;唤醒第二个写阻塞等待的线程\n    if (leader &#x3D;&#x3D; null &amp;&amp; q.peek() !&#x3D; null)\n      available.signal();\n    lock.unlock();\n  &#125;\n&#125;\n示例：简单的任务延迟执行框架\npublic class Demo&#123;\n  public static class Job inplements Delayed&#123;\n    private String name;\n    private long scheduleTime;&#x2F;&#x2F;millisecond\n\n    public Job(String name, long scheduleTime)&#123;\n      this.name &#x3D; name;\n      this.scheduleTime &#x3D; scheduleTime;\n    &#125;\n    public void run()&#123;\n      System.out.println(&quot;I am &quot; + name);\n    &#125;\n    @Override\n    public long getDelay(TimeUnit unit)&#123;\n      long delayTime &#x3D; scheduleTime - System.currentTimeMillis();\n      return unit.convert(delayTime, TimeUnit.MILLISECONDS);\n    &#125;\n    @Override\n    public int compareTo(Delayed o)&#123;\n      return (int) (this.getDelay(TimeUnit.NANOSECONDS)) - \n        o.getDelay(TimeUnit.NANOSECONDS));\n    &#125;\n  &#125;\n  public static void main(String[] args) throws InterruptedException&#123;\n    DelayQueue&lt;Job&gt; jobs &#x3D; new DelayQueue&lt;&gt;();\n    &#x2F;&#x2F;job1、job2、job3的delayTime分别为1s、2s、3s\n    jobs.put(new Job(&quot;job1&quot;, System.currentTimeMillis()+1000));\n    jobs.put(new Job(&quot;job2&quot;, System.currentTimeMillis()+2000));\n    jobs.put(new Job(&quot;job3&quot;, System.currentTimeMillis()+3000));\n    Thread t1 &#x3D; new Thread(new JobRunnable(jobs));\n    Thread t2 &#x3D; new Thread(new JobRunnable(jobs));\n    &#x2F;&#x2F;t1和t2均调用take，然后都阻塞，1s后，t1从阻塞中唤醒，读取到job1，2s后，t2从阻塞总唤醒\n    &#x2F;&#x2F;读取到job2，\n    t1.start();\n    t2.start();\n    t1.join();&#x2F;&#x2F;确保子线程执行完毕后才能执行主线程\n    t2.join();\n  &#125;\n  &#x2F;&#x2F;新线程，先执行take从队列中拿job，然后运行改job\n  private static class JobRunnable implements Runnable&#123;\n    private DelatQueue&lt;Job&gt; jobs;\n    public JobRunnable(DelayQueue&lt;Job&gt; jobs)&#123;this.jobs &#x3D; jobs;&#125;\n    @Override\n    public void run()&#123;\n      try&#123;\n        Job job &#x3D; job.take();\n        job.run();\n      &#125;catch(InterruptedException e)&#123;\n        e.printStackTrace();\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n\nSynchronousQueue：用于两个线程之间传递数据，每个put操作必须阻塞等待take操作，队列中不存储任何元素，使用的很少，示例如下：\npublic class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    SynchronousQueue&lt;String&gt; sq &#x3D; new SynchronizedQueue&lt;&gt;();\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        try&#123;\n          sq.put(&quot;a&quot;);&#x2F;&#x2F;每个put操作必须阻塞等待take操作\n          System.out.println(&quot;put done!&quot;);\n        &#125;catch (InterruptedException e)&#123;\n          e.printStackTrace();\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(3000);\n    System.out.println(&quot;sleep done!&quot;);\n    sq.take();&#x2F;&#x2F;每个put操作必须阻塞等待take操作\n    System.out.println(&quot;take done!&quot;);\n  &#125;\n&#125;\n&#x2F;&#x2F;先后输出sleep done! take done! put done!\nLinkedTransferQueue：基于链表实现的无界阻塞并发队列，是LinkedBlockingQueue和SynchronousQueue的综合体，提供了transfer函数，跟SynchronousQueue的put函数的功能相同，调用transfer的线程会一直阻塞，知道数据被其他线程消费才会返回。使用的较少，示例代码如下\npublic class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    LinkedTransferQueue&lt;String&gt; ltq &#x3D; new LinkedTransferQueue&lt;&gt;();\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        ltq.put(&quot;a&quot;);&#x2F;&#x2F;不需要阻塞等待\n        System.out.println(&quot;put done!&quot;);\n        try&#123;\n          ltq.transfer(&quot;b&quot;);&#x2F;&#x2F;会阻塞等待\n          System.out.println(&quot;transfer done!&quot;);\n        &#125;catch (InterruptedException e)&#123;\n          e.printStackTrace();\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(3000);\n    System.out.println(&quot;sleep done!&quot;);\n    ltq.take();&#x2F;&#x2F;put写入的数据\n    ltq.take();&#x2F;&#x2F;transfer写入的数据\n    System.out.println(&quot;take done!&quot;)\n  &#125;\n&#125;\n&#x2F;&#x2F;先后输出put done! sleep done! take done! transfer done!\n\n2.分段加锁\n\n\n\n\n\n\n\n\nHashMap不是线程安全的，HashTable、SynchronizedMap虽然是线程安全的，但采用粗力度锁，并发性能不佳，所以JUC提供了ConcurrentHashMap，利用分段加锁等技术来提高并发性能\n\nHashMap线程不安全分析：共享资源是table数组及其table数组中的链表，主要分析get中的读操作、put中的写操作、扩容操作、树化操作之间的线程安全性\n\n\n\n读操作与读操作、写操作、扩容、树化之间是否线程安全\n读操作和读操作不存在线程安全问题：不涉及临界资源竞争\n读操作和写操作也不存在线程安全问题：写操作添加到table数组中链表的尾部，读操作从链表头遍历\n读操作和扩容之间存在线程安全问题：扩容时，会将数据一点一点移动，扩容初期会导致读取失败\n读操作和树化之间不存在线程安全问题：链表中的节点定义和红黑树中的节点定义不相同，所以树化的时候，HashMap无法将链表中的节点直接搬移到红黑树中，而是采用复制的方式，重新创建新的红黑树节点，将key、value复制到新创建的红黑树节点，然后在将节点添加到红黑树中。红黑树构建完成后，才会将table数组中的引用更新指向红黑树，所以是写时复制操作，读操作和树化之间无影响\n\n\n写操作与写操作、扩容、树化之间是否线程安全\n写操作与写操作之间存在线程安全问题：都是尾插，会导致线程不安全\n写操作和扩容之间存在线程安全问题：扩容搬移数据和写操作是并行执行写操作，会导致线程不安全\n写操作和树化之前存在线程安全问题：在红黑树构建完成但table数组中的引用没更新前，导致写入的数据无法搬移到红黑树中，会导致写操作无效\n\n\n扩容与扩容、树化之间是否线程安全\n扩容和扩容之间存在线程安全问题：两个线程同时执行扩容操作，会争抢搬移老的table数组中的数据，最终引用仅指向一个新数组，所以会导致数据的大量丢失\n扩容和树化之间存在线程安全问题：树化过程中另一线程若扩容，会因为搬移数据导致树化操作只能针对链表中的部分数据进行，进而导致数据大量丢失\n\n\n树化与树化之前是否线程安全\n树化与树化之前不存在线程安全问题：树化通过写时复制来实现，两个树化同时进行只会导致生成两个重复的红黑树，并不会引起数据丢失的问题\n\n\n\n\nConcurrentHashMap介绍\n\nHashTable和SynchronizedMap都通过简单的对所有方法加锁，来解决线程安全问题，SynchronziedMap的引入是为了让JCF框架的类结构更加清晰，线程安全容器和非线程安全容器相分离，线程安全容器通过统一的方式（Collections的synchronizedXXX方法）来创建\nJDK8版本的ConcurrentHashMap比JDK7版本的分段加锁力度更小，并发度更高，扩容方式有所不同，size实现更高效等优势\nConcurrentHashMap中，table数组被分段加锁，如果table数组的大小为n，那么就对应存在n把锁，每一个链表独享一把锁，不同链表之间的操作可以多线程并行执行，互不影响，以此来提高并发性能\n\n\nget函数的实现原理\n\nget函数就是读操作，没有加锁的处理逻辑，get函数可以跟任何操作（读操作、写操作、树化、扩容）并行执行，并发性能极高\nget与其他操作没有线程安全问题，但get和扩容操作之间因为有线程安全问题，所以需要特殊处理\n\n\nput函数的实现原理\npublic V put(K key, V value) &#123;\n  return putVal(key, value, false);\n&#125;\n\n&#x2F;** Implementation for put and putIfAbsent *&#x2F;\nfinal V putVal(K key, V value, boolean onlyIfAbsent) &#123;\n  if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();&#x2F;&#x2F;空值\n  int hash &#x3D; spread(key.hashCode());&#x2F;&#x2F;求hash值\n  int binCount &#x3D; 0;\n  for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;&#x2F;&#x2F;遍历table\n    Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv;\n    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n      tab &#x3D; initTable();&#x2F;&#x2F;空hash表初始化，通过CAS操作\n    else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;空链表\n      if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))&#x2F;&#x2F;cas操作增加元素\n        break;                   &#x2F;&#x2F; no lock when adding to empty bin\n    &#125;\n    else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)\n      tab &#x3D; helpTransfer(tab, f);\n    else if (onlyIfAbsent &#x2F;&#x2F; check first node without acquiring lock\n             &amp;&amp; fh &#x3D;&#x3D; hash\n             &amp;&amp; ((fk &#x3D; f.key) &#x3D;&#x3D; key || (fk !&#x3D; null &amp;&amp; key.equals(fk)))\n             &amp;&amp; (fv &#x3D; f.val) !&#x3D; null)\n      return fv;\n    else &#123;\n      V oldVal &#x3D; null;\n      synchronized (f) &#123;&#x2F;&#x2F;对头节点f加锁\n        if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;&#x2F;&#x2F;\n          if (fh &gt;&#x3D; 0) &#123;\n            binCount &#x3D; 1;\n            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;&#x2F;&#x2F;遍历链表看是否存在key跟写入数据相同的节点\n              K ek;\n              if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                  ((ek &#x3D; e.key) &#x3D;&#x3D; key ||\n                   (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;\n                oldVal &#x3D; e.val;&#x2F;&#x2F;存在\n                if (!onlyIfAbsent)\n                  e.val &#x3D; value;&#x2F;&#x2F;更新此节点的value\n                break;\n              &#125;\n              Node&lt;K,V&gt; pred &#x3D; e;\n              if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;不存在，写入到链表的尾部\n                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key, value);\n                break;\n              &#125;\n            &#125;\n          &#125;&#x2F;&#x2F;if\n          else if (f instanceof TreeBin) &#123;&#x2F;&#x2F;红黑树节点\n            Node&lt;K,V&gt; p;\n            binCount &#x3D; 2;\n            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) !&#x3D; null) &#123;\n              oldVal &#x3D; p.val;\n              if (!onlyIfAbsent)\n                p.val &#x3D; value;\n            &#125;\n          &#125;&#x2F;&#x2F;else if\n          else if (f instanceof ReservationNode)\n            throw new IllegalStateException(&quot;Recursive update&quot;);\n        &#125;&#x2F;&#x2F;if\n      &#125;&#x2F;&#x2F;synchronized\n      if (binCount !&#x3D; 0) &#123;\n        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)\n          &#x2F;&#x2F;树化，会加锁，创建红黑树，将链表数据复制到红黑树，将table[index]指向红黑树\n          treeifyBin(tab, i);\n        if (oldVal !&#x3D; null)\n          return oldVal;\n        break;\n      &#125;\n    &#125;&#x2F;&#x2F;else结束\n  &#125;\n  addCount(1L, binCount);\n  return null;\n&#125;\n\n\n写操作：两种加锁方式，链表为空的时候，通过CAS操作将table[index]指向写入数据对应的节点；链表不为空，先对头节点使用synchronized加锁，再执行写操作\n\n树化：写入操作完成后，如果链表中的节点个数大于等于树化阈值（默认为8），put会执行树化操作，尽管是写时复制操作，但是在树化的同时执行写入操作或扩容，会导致数据丢失，因此树化操作也需要使用synchronzied加锁\n\n扩容：扩容需要对整个table的所有链表加锁，也是通过分段加锁分段执行，对HashMap增加了两点改进\n\n写时复制：\n\n在创建好新的table数组之后，采用写时复制的方法，一点点复制，在全部复制完之后，才会将table引用指向新创建的table数组。\ntable会出现三种不同类型的链表，已复制未加锁链表、在复制已加锁链表、未复制未加锁链表，根据类型不同决定在那个table处理读、写、树化操作。\n类型的标记由新节点类型ForwardingNode标记，此节点类型的hash值为-1。在扩容的时候，将复制完解锁前的链表头节点换成ForwardingNode节点，并将ForwardingNode节点中的nextTable属性指向新创建的table数组，读、写、树化table数组的某个链表时，如果头节点的hash值为-1.就在这个节点的nextTable属性所指向的table数组中重新查找对应的链表，在执行相应操作\n\n\n复制替代搬移：扩容基于复制而非搬移实现，将老的table数组中的节点中的key、value等数据，复制一份存储在一个新创建的节点中，再将新创建的节点插入到新的table数组中\n\n多个线程共同协作完成扩容：\n\n每个线程根据transferIndex来决定具体负责哪几个链表的复制，transferIndex初始化为table.length，多个线程通过CAS修改transferIndex共享变量，谁成功更新，谁就获得[transferIndex-stride, transferIndex)之间的stride个链表的复制权，争夺失败的线程自旋重新执行CAS\npublic void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)&#123;\n  int n &#x3D; tab.length;\n  int stride;&#x2F;&#x2F;每个线程负责相邻的stride个链表\n  int NCPU &#x3D; Runtime.getRuntime().availableProcessors();\n  if((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)\n    stride &#x3D; MIN_TRANSFER_STRIDE;&#x2F;&#x2F;MIN_TRANSFER_STRIDE &#x3D; 16\n  \n  &#x2F;&#x2F;循环获取stride个链表的处理权并处理，直到没有剩余的链表要处理\n  while(transferIndex &gt; 0)&#123;\n    int oldIndex &#x3D; transferIndex;\n    int newIndex &#x3D; oldIndex &gt; stride ? oldIndex-stride : 0;\n    if(!cas(transferIndex, oldIndex, newIndex))&#123;\n      continue;&#x2F;&#x2F;失败继续，自旋CAS\n    &#125;\n    &#x2F;&#x2F;CAS成功，处理下标在[transferIndex-stride, transferIndex)之间的\n    &#x2F;&#x2F;table数组中的链表\n  &#125;\n&#125;\n执行table引用更新的线程：ConcurrentHashMap定义了一个int类型的sizeCtl变量，用来标记当前正在参与扩容的线程个数，进入和退出的线程通过CAS操作增减sizeCtl，如果变为0，那么这个线程就是最后一个线程，负责引用更新\n\n\n\n\n\n\n\nsize函数的实现原理\n\n扫描统计：每次调用size函数时，都把table数组中的所有链表都遍历一遍，统计得到总的元素个数。每次扫描都需要加锁，导致并发性能降低，执行效率也非常低\n实时统计：ConcurrentHashMap中维护一个size成员变量，每当执行增、删元素操作时，同步更新size，无论将size设置为AtomicInteger还是通过CAS更新size，在高并发场景下，都会存在性能问题，进而影戏那个增、删操作的性能\n非一致性统计：借鉴LongAdder的实现思路，每个链表维护一个实时统计的cellSize，表示这个链表的节点个数，当调用size函数时，每个链表的cellSize相加即可得到元素总个数，但会导致统计结果不一致\n\n\n\n3.写时复制\n\n\n\n\n\n\n\n\n写时复制并发容器：CopyOnWriteArrayList、CopyOnWriteArraySet\n\n基本原理：主要应用于并发容器中，为了避免读操作和写操作（增、删、改）同时发生而产生的线程安全问题，写时复制将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作，而对读操作继续在原始容器上进行，这样读写之间不会存在数据访问冲突，当写操作执行完成后，新创建的容器替代原始容器。以CopyOnWriteArrayList的源码为例，CopyOnWriteArraySet的底层存储结构使用的是基于CopyOnWriteArrayList\n&#x2F;&#x2F;CopyOnWriteArrayList是ArrayList的线程安全版本，也实现了List接口\npublic class CopyOnWriteArrayList&lt;E&gt;\n  implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;\n  final transient ReentrantLock lock &#x3D; new ReentrantLock();\n  private transient volatile Object[] array;\n  public CopyOnWriteArrayList() &#123;setArray(new Object[0]);&#125;\n\n  &#x2F;&#x2F;get()函数，读操作，直接按下标访问array数组\n  private E get(Object[] a, int index) &#123;\n    return (E) a[index];&#x2F;&#x2F;return (E) this.array[index];\n  &#125;\n  public E get(int index) &#123;return get(getArray(), index);&#125;\n  final Object[] getArray() &#123;return array;&#125;\n  &#x2F;&#x2F;add()函数，用于新增数据包含写时复制逻辑\n  public boolean add(E e) &#123;\n    &#x2F;&#x2F;使用可重入锁来保证写操作的线程安全性，避免两个线程同时执行写时复制\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      &#x2F;&#x2F;获得原始数组array\n      Object[] elements &#x3D; getArray();\n      int len &#x3D; elements.length;\n      &#x2F;&#x2F;添加数据时，首先创建一个长度比原始数组大一的数组，并拷贝数据到新数组\n      &#x2F;&#x2F;Arrays.copyOf()底层以来native方法System.arrayCopy()来实现，比较快速\n      Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);\n      &#x2F;&#x2F;将新数据添加到数据末尾\n      newElements[len] &#x3D; e;\n      &#x2F;&#x2F;修改array引用指向newElements\n      setArray(newElements);\n      return true;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n  &#x2F;&#x2F;remove()函数，删除元素，类似于add函数，\n  public E remove(int index) &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      Object[] elements &#x3D; getArray();\n      int len &#x3D; elements.length;\n      E oldValue &#x3D; get(elements, index);\n      int numMoved &#x3D; len - index - 1;\n      if (numMoved &#x3D;&#x3D; 0)&#x2F;&#x2F;删除array数组的最后一个元素\n        setArray(Arrays.copyOf(elements, len - 1));\n      else &#123;&#x2F;&#x2F;删除array数组内部的元素\n        Object[] newElements &#x3D; new Object[len - 1];\n        &#x2F;&#x2F;拷贝array中下标在[0, index-1]之间的元素到newElements\n        System.arraycopy(elements, 0, newElements, 0, index);\n        &#x2F;&#x2F;拷贝array中下标在[index+1, len-1]之间的元素到newElements\n        System.arraycopy(elements, index + 1, newElements, index,\n                         numMoved);\n        setArray(newElements);\n      &#125;\n      return oldValue;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n  &#x2F;&#x2F;set()函数，用于改元素\n  public E set(int index, E element) &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      Object[] elements &#x3D; getArray();\n      E oldValue &#x3D; get(elements, index);\n\n      if (oldValue !&#x3D; element) &#123;\n        int len &#x3D; elements.length;\n        Object[] newElements &#x3D; Arrays.copyOf(elements, len);\n        newElements[index] &#x3D; element;\n        setArray(newElements);\n      &#125; else &#123;\n        &#x2F;&#x2F; Not quite a no-op; ensures volatile write semantics\n        setArray(elements);\n      &#125;\n      return oldValue;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n&#125;\n读多写少\n\nCopyOnWriteArrayList源码显示，写操作需要加锁，只能串行执行，而且写操作执行写时复制逻辑，涉及大量数据的拷贝，因此写操作的执行效率很低，所以写时复制逻辑只适用于读多写少的应用场景\n对于写比较多的应用场景，可以使用链表，因为链表的增删操作是局部操作，可以使用之前的无锁编程技巧，在保证线程安全的同时，尽可能提高并发性能。所以对于写操作比较多的场景，可以使用链表来实现线程安全的List容器，具体实现见下一节\n\n\n弱一致性：CopyOnWriteArrayList源码显示，写操作的结果并非对读操作立即可见，这就导致了短暂的数据不一致，称为弱一致性，在某些业务场景下，会引发bug，如下：\npublic class Demo&#123;\n  private List&lt;Integer&gt; scores &#x3D; new CopyOnWriteArrayList&lt;&gt;();\n  \n  public void add(int idx, int score)&#123;\n    scores.add(idx, score);&#x2F;&#x2F;将数据插入到idx下标位置\n  &#125;\n  public int sum()&#123;\n    int ret &#x3D; 0;\n    for(int i &#x3D; 0; i &lt; scores.size(); ++i)&#123;\n      ret +&#x3D; scores.get(i);\n    &#125;\n    return ret;\n  &#125;\n&#125;\n\n\n遍历容器求和将存在重复统计的问题：如下图所示。线程A遍历原始数组进行累加，当累加完下标为3的元素23之后，线程B执行add(3, 17)函数，将array引用切换为指向新的数组。此时变量i的值仍然为4,线程A从下标为4的位置开始遍历新的数组，于是，元素23又被遍历累加了一遍。\n\n\n解决办法：CopyOnWriteArrayList提供了用于遍历容器的迭代器，在创建迭代器对象时，CopyOnWriteArrayList会将\npublic Iterator&lt;E&gt; iterator() &#123;\n  return new COWIterator&lt;E&gt;(getArray(), 0);\n&#125;\nstatic final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;\n  private final Object[] snapshot;&#x2F;&#x2F;指向原始数组\n  &#x2F;** Index of element to be returned by subsequent call to next.  *&#x2F;\n  private int cursor;\n\n  private COWIterator(Object[] elements, int initialCursor) &#123;\n    cursor &#x3D; initialCursor;\n    snapshot &#x3D; elements;\n  &#125;\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public E next() &#123;\n    if (! hasNext())\n      throw new NoSuchElementException();\n    return (E) snapshot[cursor++];\n  &#125;\n\t&#x2F;&#x2F;省略其他方法\n&#125;\n对sum函数重构如下\npublic int sum()&#123;\n  int ret &#x3D; 0;\n  Iterator&lt;Integer&gt; itr &#x3D; scores.iterator();\n  while(itr.hasNext())&#123;\n    ret +&#x3D; itr.next();\n  &#125;\n  return ret;\n&#125;\n\n\n连续存储\n\nJUC提供了CopyOnWriteArrayList、CopyOnWriteArraySet，却没有提供CopyOnWriteLinkedList、CopyOnWriteHashMap等其他类型的写时复制容器的原因：因为执行写操作需要复制整个数据，对于链表和哈希表来说，因为数据在内存中不是连续存储的，所以耗时非常大，写操作的性能无法满足工业级通用类对性能的要求。CopyOnWriteArrayList、CopyOnWriteArraySet底层都是基于数组来实现的，而且使用了JVM底层提供的native方法，通过C++代码中的指针实现了内存块的快速拷贝，\n&#x2F;&#x2F;位于System.java中\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,int length);\n支持写时复制的HashMap实现\npublic class Configuration&#123;\n  private static final Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\n  &#x2F;&#x2F;热更新，不需要加锁（只有一个线程调此函数），也不需要拷贝（全量更新配置）\n  public void reload()&#123;\n    Map&lt;String, String&gt; newMap &#x3D; new HashMap&lt;&gt;();\n    &#x2F;&#x2F;从配置文件加载配置，并解析放入newMap\n    map &#x3D; newMap;\n  &#125;\n&#125;\n\n\n\n6.线程管理1.线程状态\n线程状态概述\n\nLinux线程状态：NEW（新创建）、READY（就绪，等待CPU时间片）、RUNNING（使用CPU时间片）、WAITING（等待其他事件：I/O、锁）、TERMINATED（终止，未必立即销毁），转化关系如下\n\n\nJava线程状态：NEW（同Linux的NEW）、RUNNABLE、WAITING（执行特殊函数可进入）、TIMED_WAITING（执行特殊函数可进入）、BLOCKED、TERMINATED（同Linux的TERMINATED）\n\n\n与Linux的状态对应关系：RUNNABLE包括Linux的READY &amp; RUNNING &amp; 部分WAITING操作，因为Java应用层面不关心底层硬件的使用情况（CPU有没有在执行），所以Linux的RUNNING和等待I/O的WAITING都归类为RUNNABLE\n\n\nBLOCKED：只有两种状态，一种是线程执行synchronized语句，阻塞等待获取锁；另一种是线程执行Object.wait()后被notify()或notifyAll()唤醒，再次阻塞等待获取锁，synchronized阻塞和lock阻塞状态不同的原因如下\n\n执行JUC Lock的lock()函数时，底层调用LockSupport.park()进行阻塞，更底层又调用Unsafe.park()，对应线程状态变为WAITING，与synchronized进入的BLOCKED状态不同\nJava线程状态的修改是在JVM层面实现的，没有为上层（JDK和JUC）提供修改的函数，而是将线程状态耦合在了一些JVM提供的特殊函数和语法中（如Thread.sleep、Object.wait、synchronzied、Thread.join、Object.notify、Unsafe.park）\nJUC在实现Lock时，用到了JVM提供的Unsafe.park，所以线程进入WAITING状态（JVM在WAITING和BLOCKED之间选了WAITING，否则JUC的Condition调用await是会进入BLOCKED，与Object.wait的状态又不一致）\nsynchronized调用的park函数，JVM将其线程状态设置为BLOCKED\n\n\nsynchronized的park、Unsafe.park、LockSupport.park三个函数功能相同，区别在于synchronized的park是JVM内部私有的，只给synchronized使用；Unsafe.park给所有开发者使用；LockSupport.park是对Unsafe.park的封装为了JUC使用方便\n\n\n\n\n\n\n线程状态与函数对应关系\n\njstack是JVM自带的一个线程信息打印工具，能够打印线程的快照信息，比如函数调用栈信息、线程状态等，可以清晰地知道线程执行到哪里、处于什么状态、等待什么资源等。jstack常用于定位线程长时间卡顿问题，比如死锁、死循环等\n\njstack的使用：首先通过jps列出所有Java进程ID，查找要打印线程信息的进程ID，然后使用jstack 进程ID命令即可打印线程包含的所有线程的信息\n\n示例\n\n\n\n代码行为\n线程状态\n\n\n\nsynchronized阻塞时\nBLOCKED\n\n\nThread.sleep(long time)\nTIMED_WAITING\n\n\nThread.join()，基于Object.wait()\nWAITING\n\n\nObject.wait()\nWAITING\n\n\nObject.wait()被notify/notifyAll唤醒\nBLOCKED\n\n\nLock.lock()（LockSupport-&gt;Unsafe）\nWAITING\n\n\nCondition.await()（同上）\nWAITING\n\n\nSemaphore.aquire()（同上）\nWAITING\n\n\n\n\n\n线程状态与jstack的应用\n\n在平时开发的时候，有时会遇到CPU占用率100%、请求超时的情况，往往是因为死循环导致的。此时可以调用jstack将所有的进程运行信息都打印出来，查看线程的函数调用栈信息，定位哪个线程在执行循环操作。如果出现两个线程互相等待对方持有的锁，就说明出现了死锁\n\n示例\n\n代码\npublic class Demo01 &#123;\n    private static final Object obj1 &#x3D; new Object();\n    private static final Object obj2 &#x3D; new Object();\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                synchronized (obj1)&#123;\n                    try&#123;\n                        Thread.sleep(1000);\n                    &#125;catch (InterruptedException e)&#123;\n                        e.printStackTrace();\n                    &#125;\n                    synchronized (obj2)&#123;\n\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,&quot;t1&quot;);\n        t1.start();\n        Thread.sleep(500);\n        synchronized (obj2)&#123;\n            synchronized (obj1)&#123;\n\n            &#125;\n        &#125;\n    &#125;\n&#125;\njstack结果\n\n\n\n\n\n\n\n2.线程池\n线程池的简介（ThreadPoolExecutor类）\n\n线程池是池化技术的一种，常见的池化技术还有数据库连接池、对象池等。池化技术用来避免频繁的资源创建和销毁，提高资源的复用率，可以使得在需要线程的时候，直接从线程池中获取，在请求处理完成之后，再将线程归还给线程池，以供复用\n\n示例\npublic class Demo_pool&#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F;创建与配置\n        ThreadPoolExecutor pool &#x3D; new ThreadPoolExecutor(5, 10, 1000,\n                TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(15), \n                new ThreadFactory()&#123;\n            private final AtomicInteger idx &#x3D; new AtomicInteger(1);\n            @Override\n            public Thread newThread(Runnable r)&#123;\n                return new Thread(r, &quot;pool-&quot; + idx.getAndIncrement());\n            &#125;\n        &#125;, new ThreadPoolExecutor.DiscardPolicy());\n\n        &#x2F;&#x2F;执行\n        pool.execute(new Runnable()&#123;\n            @Override\n            public void run()&#123;\n                System.out.println(&quot;hello&quot;);\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;关闭\n        pool.shutdown();&#x2F;&#x2F;发起关闭请求\n        boolean terminated &#x3D; false;\n        while(!terminated)&#123;\n            &#x2F;&#x2F;返回值为false表示超时，返回值为true表示线程池真正关闭\n            terminated &#x3D; pool.awaitTermination(100, TimeUnit.SECONDS);\n        &#125;\n        System.out.println(&quot;pool is shutdown&quot;);\n    &#125;\n&#125;\n\n\n线程池的创建（JUC中会提供一些工厂方法来简化线程池的创建过程）\n&#x2F;&#x2F;ThreadPoolExecutor类最底层的构造函数\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) &#123;...&#125;\n\n\nint corePoolSize：核心线程池的大小，整个线程池分为核心和非核心两部分，核心线程池一旦创建就不会销毁、非核心线程在创建之后，如果长时间未使用，便会销毁\n\nint maximumPoolSize：整个线程池的大小（核心+非核心）\n\nlong keepAliveTime：非核心线程池中的线程销毁前的等待时间，单位为TimeUnit unit参数指定\n\nBlockingQueue&lt;Runnable&gt; workQueue：用来存储任务，核心线程池已满时的新请求线程会被放入此队列，等待线程处理。workQueue是阻塞队列，其他JUC提供的阻塞队列都可以在此处使用\n\nThreadFactory threadFactory：如果传入threadFactory工厂类对象，线程池中线程的创建均通过工厂类的newThread()方法来实现，可以自定义实现，例如附加一些线程名称等信息\n\nRejectedExecutionHandler handler：线程池中已存在maximumPoolSize个线程，等待队列workQueue（有界阻塞队列）已满时，新到来的任务就会触发拒绝策略，可以通过handler参数来设置拒绝策略\n&#x2F;&#x2F;RejectedExecutionHandler接口定义\npublic interface RejectedExecutionHandler &#123;\n  void rejectedExecution(Runnable r, ThreadPoolExecutor executor);\n&#125;\n&#x2F;&#x2F;ThreadPoolExecutor类中预先实现的拒绝策略\n&#x2F;&#x2F;拒绝策略：由任务递交者代替线程池来执行这个任务，递交者若关闭，则丢弃任务\npublic static class CallerRunsPolicy implements RejectedExecutionHandler &#123;\n  public CallerRunsPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n    if (!e.isShutdown()) &#123;\n      r.run();\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F;拒绝策略：直接放弃执行任务，并抛出RejectedExecutionException异常\npublic static class AbortPolicy implements RejectedExecutionHandler &#123;\n  public AbortPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n    throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +\n                                         &quot; rejected from &quot; +\n                                         e.toString());\n  &#125;\n&#125;\n&#x2F;&#x2F;拒绝策略：直接放弃执行任务\npublic static class DiscardPolicy implements RejectedExecutionHandler &#123;\n  public DiscardPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n  &#125;\n&#125;\n&#x2F;&#x2F;拒绝策略：删掉workQueue中的一个任务，再次调用execute执行当前任务\npublic static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;\n  public DiscardOldestPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n    if (!e.isShutdown()) &#123;\n      e.getQueue().poll();\n      e.execute(r);\n    &#125;\n  &#125;\n&#125;\n\n\n线程池的执行\n\n使用线程池执行任务，只需要将任务封装成Runnable对象，然后传递给execute()函数即可，任务的执行全部由execute()函数负责。线程池中的线程是动态的，有如下几种处理方式\n\n检查核心线程池是否已满，如果未满，则创建核心线程执行任务\n\n如果核心线程池已满，再检查等待队列是否已满，如果未满，则将任务放入等待队列\n\n如果等待队列已满，再检查非核心线程池是否已满，如果未满，则创建非核心线程执行任务\n\n如果核心线程池、非核心线程池、等待队列都满，则按照拒绝策略对任务进行处理\n\n\n\n\n线程池执行任务的过程，并非是从线程池中取出线程然后执行任务，而是将任务放在等待队列中等待线程的读取并执行。\n\n核心线程创建之后，会调用workQueue上的take函数，不停的从workQueue中取任务来执行，take函数是阻塞函数，即没有任务时线程会一直阻塞等待\n非核心线程创建之后，会调用workQueue上的poll函数，不停的从workQueue中取任务处理，poll函数也是阻塞的，但是其会设置阻塞的超时时间，如果poll函数的阻塞时间超过keepAliveTime，poll就会从阻塞中返回并执行线程销毁逻辑\n\n\n\n\n线程池的关闭\n&#x2F;&#x2F;线程池会拒绝接受新的任务，但是会将正在执行的任务和等待队列中的任务全部执行完\npublic void shutdown() &#123;&#125;\n&#x2F;&#x2F;线程池会拒绝接受新的任务，而且会清空等待队列，并向所有的线程发送中断请求，调用take或poll阻塞等待的线\n&#x2F;&#x2F;程会被中断然后结束，正在执行任务的线程在收到中断请求后，既可以中断终止执行，也可以继续执行任务，\n&#x2F;&#x2F;返回值为等待队列中未被执行的任务\npublic List&lt;Runnable&gt; shutdownNow() &#123;&#125;\n\n&#x2F;&#x2F;确保所有的线程都已经结束，需要调用awaitTermination函数阻塞等待\nwhile(!terminated)&#123;\n  &#x2F;&#x2F;返回值为false表示超时，返回值为true表示线程池真正关闭\n  terminated &#x3D; pool.awaitTermination(100, TimeUnit.SECONDS);\n&#125;\n线程池的配置\n\nCOU密集型程序：线程池可以等于或大于可用CPU核数\n\nI/O密集型程序：程序的大部分时间都在执行I/O操作，可以将线程池设置的大一些，以便众多线程轮流使用CPU\n\n计算公式\n\n通过监控统计，得知线程池执行的任务平均CPU耗时为cpu_time毫秒，平均I/O耗时（非CPU耗时）为io_time毫秒，线程池大小设置参考公式为pool_size = (cpu_time + io_time)/cpu_time，此公式计算出的线程池大小指的是CPU利用率100%时对应的线程池大小\n\n示例：cpu_time = 1/3总耗时，io_time = 2/3总耗时，单核CPU上，线程池需要设置为3，CPU的利用率将会是100%，如下图\n\n\n上述公式的前提：没有瓶颈操作+没有瓶颈资源\n\n瓶颈操作：尽管Redis执行命令这一任务是I/O密集型，应该将线程池开大点，才能充分利用CPU资源，但是Redis执行命令的过程中，I/O操作才是瓶颈操作，就算开很大的线程池让CPU利用率高达100%，但是命令的执行都会阻塞在I/O操作上，整体的执行效率并不会提高，这是就该关注I/O的利用率，而不是使用更多的线程\n瓶颈资源：任务的执行依赖数据库，数据库是通过数据库连接池来管理的，假设数据库连接池的大小是N，当线程数大于N时，数据库连接就成了瓶颈资源，多余的线程需要等待连接池，并不会提高整体的执行效率，此时的连接池中的数据库连接就是瓶颈资源，此时就应该以充分利用瓶颈资源为目标，也就是说，线程池的大小应该设置为跟数据库连接池大小相当才合理\n\n\n\n\n\n\n\n3.线程中断\n\n\n\n\n\n\n\n\n线程执行业务逻辑的过程中，有可能被提前终止，所以需要一些安全的线程终止方式，避免突然中止业务逻辑导致的数据不一致、资源得不到回收等问题\n\n基于标志终止线程\npublic class Demo&#123;\n  private static volatile boolean stopped &#x3D; false;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;&#x2F;&#x2F;t1是长时间运行的程序\n        int count &#x3D; 0;\n        while(!stopped)&#123;&#x2F;&#x2F;t1运行中会检查stopped是否为true\n          System.out.println(count++);\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    stopped &#x3D; true;&#x2F;&#x2F;想终止t1，就将stopped设置为true\n  &#125;\n&#125;\n基于中断终止线程\n\n基于中断终止线程可以直接使用线程提供的内部中断标志位，不用自己定义，Thread提供了以下3个函数来操作中断标志位\n&#x2F;&#x2F;Thread.java\npublic void interrupt();&#x2F;&#x2F;设置中断标志位\npublic boolean isInterrupted();&#x2F;&#x2F;检查中断标志位是否设置\npublic static boolean interrupted();&#x2F;&#x2F;检查并清除中断标志位\n示例：思想与基于标志终止线程一样，只不过用了线程的标志位\npublic class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread (new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        int count &#x3D; 0;\n        while(!Thread.currentThread().isInterrupted())&#123;\n          System.out.println(count++);\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    t1.interrupt();\n  &#125;\n&#125;\n\n&#x2F;&#x2F;中断并不是强制的，只是发起了中断请求，线程可以无视中断，也可以在中断前进行善后工作，避免数据\n&#x2F;&#x2F;不一致或资源无法回收等问题的发生\npublic class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        int count &#x3D; 0;\n        while(true)&#123;&#x2F;&#x2F;无视中断\n          System.out.println(count++);\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    t1.interrupt();&#x2F;&#x2F;发起中断请求\n  &#125;\n&#125;\n\n\n基于中断异常终止线程\n\n线程正在执行阻塞函数的时候，比如Thread.sleep()，此时线程无法响应中断请求，也就无法及时终止线程。实际上这些阻塞函数都会在接收到中断请求的时候，停止执行并抛出InterruptedException中断异常，可以基于中断异常来终止线程，示例如下\npublic class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        int count &#x3D; 0;\n        while(!Thread.currentThread().isInterrupted())&#123;\n          System.out.println(count++);\n          try&#123;\n            Thread.sleep(10000);&#x2F;&#x2F;10s\n          &#125;catch (InterruptedException e)&#123;&#x2F;&#x2F;sleep的过程中响应中断请求，并抛出异常\n            &#x2F;&#x2F;因为大部分阻塞函数在抛出InterruptedException前，会调用interrupted函数清除\n            &#x2F;&#x2F;中断标志位，所以需要下面这条语句重新设置线程的中断标志位，也可以直接return\n            Thread.currentThread().interrupted();\n          &#125;\n        &#125;&#x2F;&#x2F;while\n      &#125;&#x2F;&#x2F;run\n    &#125;);\n    t1.start();\n    Thread.sleep(2000);\n    t1.interrupt();\n  &#125;\n&#125;\nJava中断 VS OS中断：Java中断完全由Java语言来实现，并不依赖OS中断。Java中断用来中断线程，OS中断用来中断CPU，每当一个CPU周期结束，就会查看中断寄存器是否有中断请求，如果有，则在事先设置好的中断向量表找到对应的中断处理函数入口地址，然后跳转执行中断处理程序。一般来说，常用的OS中断有I/O中断、时钟中断、异常、系统调用中断等\n\n其他可支持中断的阻塞函数\n&#x2F;&#x2F;Lock 接口\nvoid lock();&#x2F;&#x2F;不可中断\nvoid lockInterrutibly() throws InterruptedException;&#x2F;&#x2F;可中断\n&#x2F;&#x2F;Condition 类\nvoid await() throws InterruptedException;&#x2F;&#x2F;可中断\nvoid awaitUninterruptiblu();&#x2F;&#x2F;不可中断\n&#x2F;&#x2F;Semaphore 类\npublic void acquire() throws InterruptedException;&#x2F;&#x2F;可中断\npublic void acquireUninterruptibly();&#x2F;&#x2F;不可中断\n\n\nlock的实现原理：不可中断\n&#x2F;&#x2F;ReentrantLock.java\nstatic final class FairSync extends Sync &#123;\n  final void lock() &#123;\n    acquire(1);\n  &#125;\n&#125;\n&#x2F;&#x2F;AbstractQueuedSynchronizer.java\npublic final void acquire(int arg) &#123;\n  &#x2F;&#x2F;tryAcquire尝试竞争获取锁，如果获取失败，则执行acquireQueued函数排队等待\n  if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    &#x2F;&#x2F;acquireQueued返回true表示收到了中断请求，在内部清除了中断标志位，所以需要重设标志位\n    selfInterrupt();&#x2F;&#x2F;内部执行Thread.currentThread().interrupt();重设中断标志位\n&#125;\nfinal boolean acquireQueued(final Node node, int arg) &#123;\n  boolean failed &#x3D; true;\n  try &#123;\n    boolean interrupted &#x3D; false;\n    for (;;) &#123;\n      final Node p &#x3D; node.predecessor();&#x2F;&#x2F;返回前一个节点\n      if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;&#x2F;&#x2F;前节点是头节点，特殊处理\n        setHead(node);\n        p.next &#x3D; null; &#x2F;&#x2F; help GC\n        failed &#x3D; false;\n        return interrupted;&#x2F;&#x2F;返回是否被中断过\n      &#125;&#x2F;&#x2F;if\n\t\t\t&#x2F;&#x2F;parkAndCheckInterrupt被中断并返回true，for循环再次执行\n      &#x2F;&#x2F;parkAndCheckInterrupt，所以中断请求不会终止acquireQueued\n      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())\n        interrupted &#x3D; true;\n    &#125;&#x2F;&#x2F;for\n  &#125; finally &#123;\n    if (failed)\n      cancelAcquire(node);\n  &#125;\n&#125;\n&#x2F;&#x2F;返回的情况一：被其他线程唤醒（调用AQS中的release函数）\n&#x2F;&#x2F;返回的情况二：被其他线程中断（调用interrupt函数），返回true\nprivate final boolean parkAndCheckInterrupt() &#123;\n  LockSupport.park(this);&#x2F;&#x2F;底层调用Unsafe.park\n  return Thread.interrupted();&#x2F;&#x2F;检查并清除中断设置\n&#125;\n&#x2F;&#x2F;LockSupport.java\npublic static void park(Object blocker) &#123;\n  Thread t &#x3D; Thread.currentThread();\n  setBlocker(t, blocker);\n  &#x2F;&#x2F;Linux下，底层采用pthread_cond_wait()条件变量来实现，其中不包括中断标志位的检测逻辑\n  &#x2F;&#x2F;当另一个线程调用interrupt设置中断标志位之后，\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n&#125;\nlockInterrutibly的实现原理：可中断\n&#x2F;&#x2F;ReentrantLock.java\npublic void lockInterruptibly() throws InterruptedException &#123;\n  sync.acquireInterruptibly(1);\n&#125;\n&#x2F;&#x2F;AbstractQueuedSynchronizer.java\npublic final void acquireInterruptibly(int arg) throws InterruptedException &#123;\n  &#x2F;&#x2F;收到中断请求之后，会终止函数并抛出InterruptedException\n  if (Thread.interrupted()) throw new InterruptedException();\n  if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n&#125;\n&#x2F;&#x2F;\nprivate void doAcquireInterruptibly(int arg) throws InterruptedException &#123;\n  final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n  boolean failed &#x3D; true;\n  try &#123;\n    for (;;) &#123;\n      final Node p &#x3D; node.predecessor();\n      if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n        setHead(node);\n        p.next &#x3D; null; &#x2F;&#x2F; help GC\n        failed &#x3D; false;\n        return;\n      &#125;\n      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())\n        &#x2F;&#x2F;parkAndCheckInterrupt因中断返回时，会直接抛出异常\n        throw new InterruptedException();\n    &#125;\n  &#125; finally &#123;\n    if (failed)\n      cancelAcquire(node);\n  &#125;\n&#125;\n\n\n\n\n\n虚拟机1.编译执行1.编译链接\n编译执行流程：Java的编译执行的整个过程包括前端编译、类加载、解释执行、JIT编译执行\n\n\n前端编译\n\n将.java文件编译成.class文件（字节码）的过程，由javac编译器来完成，通过词法分析、语法分析、语义分析等方法将源代码翻译成字节码（编译型语言翻译结果为机器码），并且还包裹特有的注解处理、解语法糖操作\n\n注解处理：从JDK6开始，可以根据JSR269规范来开发注解插件（包含定义注解、使用注解、对应的注解处理器），在前端编译时会调用注解插件来执行相应的注解处理器代码。例如Lombok插件的注解处理器根据@getter、@setter等注解为类的变量生成getter、setter方法，由于是SOURCE级别的注解，所以只作用于编译之前\n\n解语法糖：在一开始Java更注重开发效率，这就导致Java更适合做业务系统开发，C/C++更适合底层的系统级开发。Java为了提高开发效率，提供了很多与法糖，即对基本语法的二次封装，主要为了提高易用性，例如泛型、自动装箱拆箱、for-each遍历、内部类等，在做前端编译的时候，会还原为基本语法，也就是说字节码不包含语法糖、JVM也不会感知到语法糖，语法糖仅存在于源码中\n\n泛型：编译时会进行类型擦除，泛型只用于编译时的类型检查，字节码中不存在，所以称为伪泛型\n\n自动拆装箱：方便基本类型和包装类的互相转换\nInteger iobj &#x3D; 12; &#x2F;&#x2F;底层实现为Integer iobj &#x3D; Integer.valueOf(12);\nint i &#x3D; iobj; &#x2F;&#x2F;底层实现为：int i &#x3D; iobj.intValue();\nfor-each循环\nList&lt;String&gt; arr &#x3D; Arrays.asList(&quot;chen&quot;, &quot;zi&quot;, &quot;jun&quot;);\nfor(String s : arr)&#123;\n  System.out.println(s);\n&#125;\nIterator&lt;String&gt; itr &#x3D; arr.iterator();&#x2F;&#x2F;增强for循环底层依赖迭代器遍历\nwhile(itr.hasNext())&#123;\n  System.out.println(itr.next());\n&#125;\n内部类\npublic class A&#123;&#x2F;&#x2F;A.class\n  public class B&#123;&#125;&#x2F;&#x2F;内部类，编译为A$B.class\n  public void f()&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;&#x2F;&#x2F;匿名内部类，编译为A$1.class\n      @Override\n      public void run()&#123;\n        System.out.println(&quot;anonymous inner class.&quot;);\n      &#125;\n    &#125;);\n  &#125;\n&#125;\n\n\n\n\n类加载\n\n在Java应用程序中，类的字节码是按需加载到内存中的，当第一次创建某个类的对象，或调用某个类的方法时，这个类就会被加载到内存中，之后便一直保存在内存中。类加载过程包括验证、准备、解析、初始化等步骤，类的加载遵从双亲委派机制，不同的类由不同的classLoader加载器来加载\n\n字节码格式示例\n\n代码，Demo.java\npublic class Demo&#123;\n  private String greeting &#x3D; &quot;hello&quot;;\n  public String greet(String name)&#123;\n    return greeting;\n  &#125;\n&#125;\n经过javac编译器编程为Demo.class文件，再用javap工具反编译，示例如下。常量池中的符号引用包括这个类所涉及到的类、接口、方法、成员变量的名称和描述符，当执行代码时，虚拟机根据符号引用找到所引用的类、接口、方法等信息，查找对应的内存存储地址，然后再调整执行\n\n\n\n\n\n\n解释执行\n\n对于C/C++，代码会被事先编译出机器指令（可执行文件），然后再交由CPU来执行；对于Java来说，编译出的.class文件，需要由JVM逐条取出，边解释为机器码，边交由CPU执行\n\n示例：虚拟机从main开始执行，执行Demo类对象的创建语句时，虚拟机发现内存中没有Demo类的字节码信息，于是通过类加载器在classpath对应的路径下查找Demo.class文件，并将其加载到内存中。之后虚拟机根据类的字节码在堆中创建demo对象，当虚拟机执行demo.greet(“hello”);时，虚拟机根据对象demo中的类指针，找到内存中的Demo类，然后在类的方法中查找greet函数对应的字节码，最后逐句解释执行\npublic class App&#123;\n  public static void main(String[] args)&#123;\n    Demo demo &#x3D; new Demo();\n    demo.greet(&quot;hello&quot;);\n  &#125;\n&#125;\n\n\nJIT编译执行\n\n解释执行需要在执行的过程中，将字节码解释为机器码，再交由CPU执行，边解释边执行，效率比C/C++低，因此引入了JIT（Just-In-Time）编译执行，也称即时编译或运行时编译\n对于一些经常运行的热点代码，可以将其编译为机器码并存储下来，不需要边解释边执行，而且可以利用运行信息做优化\nAOT（Ahead Of Time Compile）编译，运行前编译，类似于C/C++的编译，但是仍支持一次编写，到处运行的特点，代码的可移植性由AOT编译器来负责，而C/C++代码的可移植性完全由程序员来运行\n\n\n\n2.JIT编译\nJIT编译器\nHotSpot虚拟机支持两种JIT编译器，区别在于编译时间和编译优化程度\nClient编译器（C1编译器）：只进行局部的编译优化，编译时间短，编译优化程度低\nServer编译器（C2编译器）：进行局部和全局优化，编译时间长，编译优化程度高\n\n\nJVM有两种运行模式，Client模式和Server模式，这两种模式就是基于JIT编译器类型来区分的，所以对于长时间运行的服务器程序，可以使用Server模式牺牲一些编译时间，生成一些高效的机器码\n\n\n分层编译\n在Java7之前，两种JIT编译器只能通过参数二选一，但是Java7引入了分层编译的技术，对编译类型做了更加细化的区分，虚拟机可以根据代码、实际运行情况，选择不同的编译类型，更有针对性\n分层编译有5个层级：解释执行、使用不带编译优化的Clinet编译器、使用仅带部分编译优化的Client编译器、使用带有所有编译优化的Client编译器、使用Server编译器\n分层编译在Java8中稳定成熟，所以JVM默认开启分层编译技术，当分层编译技术关闭时，JVM直接选择使用Server编译器\n\n\n热点探测\n热点代码：主要包括被多次执行的方法和被多次执行的循环，JIT编译的对象是方法，对循环的编译是编译循环所在的整个方法\n计数器：HotSpot虚拟机使用计数器来统计方法或循环的执行次数，以此来判断方法或循环是否是热点代码。JVM对每个方法维护两个计数器，方法调用计数器和回边计数器，前者用来统计方法的执行次数，后者用来统计方法内循环的执行次数\n阈值：当某个方法的方法调用计数器的值和回边计数器的值的总和超过某个阈值时，虚拟机就会对方法进行JIT编译。Client编译器下阈值是1500，Server编译器下是10000，可以通过参数更改。但是开启分层编译后，会使用动态阈值，根据当前编译方法数以及编译线程数动态计算得到\n热度衰减机制：防止因为运行时间长而超过阈值的代码被判定为成热点代码，此机制（通过-XX:-UseCounterDecay开关）在超过一定的时间（通过-XX:CounterHalfLifeTIme设置）限制之后，如果某个方法没有达到触发JIT编译的阈值要求，那么这个方法的方法计数器的值就减半，回边计数器不存在此机制\n\n\n\n3.编译优化\n编译优化：在编译代码时，对代码进行优化，减少无效、冗余代码，以便生成更加高效的机器码，在一定程度上，编译优化的质量决定了编译器是否优秀，编程语言是否高效\nJIT编译优化策略：方法内联、逃逸分析、无用代码消除、循环展开、消除公共子表达式、范围检查消除、空值检查消除等\n方法内联\n函数调用会涉及栈帧的压栈、出栈、现场的保存和恢复，很耗时，为了提高效率，将短小的函数（getter、setter）嵌入到函数调用处，通过内存的增加减少时间的消耗，并可以进行进一步的优化\n内联的要求：函数短小（字节码小于325字节）+调用次数达到阈值（大于等于100次）、或者字节码小于35字节+方法调用次数少于100次\nfinal：将方法设置为final会有助于触发方法内联，特别是多态的情况下，因为final声明的函数不会被重载，所以可以直接通过类的方法来内联，而不用分析是否有重载变化函数的情况\n\n\n逃逸分析\nJIT编译器通过分析对象的使用范围来优化对象的内存存储方式和访问方式，针对不同的逃逸分析结果，有3种不同的优化策略：栈上分配、标量替换、锁消除\n栈上分配：编译器分析完，发现某个对象使用范围仅限于某个函数内部（没有逃逸到方法外），就可以启动栈上分配编译优化，将对象作为局部变量直接分配在栈上\n标量替换：如果某个对象只在某个函数内使用，并且函数内只访问对象的基本类型成员变量等标量数据，就可以使用基本类型变量替代对象\n锁消除：对不存在多线程并发访问的代码（逃逸到线程外），编译器会去掉其中保证线程安全的加锁逻辑\n\n\n\n\n\n\n\n2.类加载器1.类加载\n类加载过程：虚拟机将类的二进制字节码加载到内存中，以便创建类的对象或者执行类上的方法\n\n验证：验证所加载的类字节码格式是否符合JVM规范，因为类字节码来源包括javac编译工具编译、网络的类字节码、通过字节码生成工具生成的类字节码，所以不可控的来源是的类字节码可能被恶意篡改，因此需要合法性的校验\n准备：虚拟机为类的静态变量分配内存，并初始化为默认值。对于static final修饰的静态常量，直接初始化指定值；对于只有static修饰的变量，初始化为默认值而不是代码指定值，指定值会在下面的初始化阶段赋予\n解析：解析类似C++中的链接，把类字节码的常量池中的符号引用（间接引用）转换为直接引用。常量池存储了所涉及的类、方法、变量等描述符，这一步就是将描述符转化为可以直接访问的内存存储地址（直接引用）\n初始化：虚拟机执行静态变量的初始化代码，包括初始化语句（private static int a = 25;）、静态代码块（static &#123; a = 13; &#125;）\n\n\n类加载机制\n\n类加载器：类加载由类加载器来完成，虚拟机定义了几种不同类型的类加载器：\n\n启动类加载器（BootStrap ClassLoader）：负责加载$JAVA_HOME/jre/lib/rt.jar包中的类\n扩展类加载器（Extension ClassLoader）：负责加载$JAVA_HOME/jre/lib/ext目录下的jar包中的类\n应用程序类加载器（Application ClassLoader）：负责加载classpath所指定路径下的其余类\n\n\n双亲委派机制\n\n尽管每个加载器负责的路径是明确的，但是当虚拟机无法根据全限定名（如java.lang.StringUtils）找到路径和对应的类加载器时，虚拟机需要通过在各个类加载器所负责的路径下查找这个类，当有重复的时候，需要机制来确定加载哪一个类，所以虚拟机设计了双亲委派机制\n\n双亲委派机制定义了类加载器之间的父子关系，如下图所示\n\n类加载器父子关系示例代码\nimport sun.applet.AppletClassLoader;\n\npublic class Demo01 &#123;\n  &#x2F;&#x2F;默认父类加载器为AppClassLoader\n  public static class ClassLoaderA extends ClassLoader &#123;\n  &#125;\n\n  &#x2F;&#x2F;通过构造函数指定父类加载器\n  public static class ClassLoaderB extends ClassLoader &#123;\n    public ClassLoaderB(ClassLoader parent) &#123;\n      super(parent);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F;ClassLoaderB的父类加载器为ClassloaderA\n  &#x2F;&#x2F;ClassLoaderA的父类加载器为AppClassloader\n  &#x2F;&#x2F;AppClassLoader的父类加载器为ExtClassLoader\n  &#x2F;&#x2F;ExtClassLoader的父类加载器为null,实际为BootrapClassLoader\n  &#x2F;&#x2F;由于其由C++代码实现，因此无法在打印结果中显示。\n  public static void main(String[] args) &#123;\n    ClassLoaderA loaderA &#x3D; new ClassLoaderA();\n    ClassLoaderB loaderB &#x3D; new ClassLoaderB(loaderA);\n\n    &#x2F;&#x2F;Demo01$ClassLoaderA@4aa298b7\n    System.out.println(loaderA);\n    &#x2F;&#x2F;Demo01$ClassLoaderB@7d4991ad\n    System.out.println(loaderB);\n    &#x2F;&#x2F;Demo01$ClassLoaderA@4aa298b7\n    System.out.println(loaderB.getParent());\n    &#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2\n    System.out.println(loaderB.getParent().getParent());\n    &#x2F;&#x2F;sun.misc.Launcher$ExtClassLoader@28d93b30\n    System.out.println(loaderB.getParent().getParent().getParent());\n    &#x2F;&#x2F;null\n    System.out.println(\n      loaderB.getParent().getParent().getParent().getParent());\n  &#125;\n&#125;\n在某个类加载器接收到某个类的加载请求时（使用new或反射创建类的对象时，默认为请求应用程序类加载器加载对应的类），如果这个类加载器之前没有加载过这个类，那么他便委托父类加载器加载这个类，如果父类没有加载过则继续向上委托直到有类加载器加载了这个类，如果达到最顶层父类加载器还没有的话，就从上往下请求各个类加载器在自己负责的路径下查找并加载这个类\n\n\n双亲委派机制可以有效防止对核心类的恶意修改，比如在自己的路径下定义一个新的java.util.String类，请求应用程序类加载器来加载，意图覆盖核心类库中的String类，但是，基于双亲委派机制，应用程序类加载器会委托父类加载器来加载java.util.String类，最终仍然会由启动类加载器加载核心类库中的String类\n\n\n\n\n\n自定义类加载器\n\n默认通过应用程序加载器加载类，但是某些特殊的类在加载的过程中需要特殊处理，无法将特殊处理逻辑插入到应用程序类加载器中，这个时候就需要自定义类加载器，将特殊处理逻辑插入到自定义类加载器中，通过调用自定义类加载器上的loadClass函数来加载这个类，达到对这个类特殊加载的目的\n\n自定义类加载器：定义继承自ClassLoader类的子类，并重写其中的findClass函数，其定义如下\nprotected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n  throw new ClassNotFoundException(name);\n&#125;\nClassLoader是一个模版方法模式类，其中的loadClass函数是模版方法，里面包含类加载的整个逻辑，比如双亲委派机制的实现逻辑，findClass函数为模版方法模式中的抽象方法，被loadClass函数使用，用来根据类名查找类\nprotected Class&lt;?&gt; loadClass(String name, boolean resolve)\n  throws ClassNotFoundException\n&#123;\n  synchronized (getClassLoadingLock(name)) &#123;\n    &#x2F;&#x2F; First, check if the class has already been loaded\n    Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n    if (c &#x3D;&#x3D; null) &#123;\n      long t0 &#x3D; System.nanoTime();\n      try &#123;\n        if (parent !&#x3D; null) &#123;\n          c &#x3D; parent.loadClass(name, false);\n        &#125; else &#123;\n          c &#x3D; findBootstrapClassOrNull(name);\n        &#125;\n      &#125; catch (ClassNotFoundException e) &#123;\n        &#x2F;&#x2F; ClassNotFoundException thrown if class not found\n        &#x2F;&#x2F; from the non-null parent class loader\n      &#125;\n\n      if (c &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; If still not found, then invoke findClass in order\n        &#x2F;&#x2F; to find the class.\n        long t1 &#x3D; System.nanoTime();\n        c &#x3D; findClass(name);\n\n        &#x2F;&#x2F; this is the defining class loader; record the stats\n        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n        sun.misc.PerfCounter.getFindClasses().increment();\n      &#125;\n    &#125;\n    if (resolve) &#123;\n      resolveClass(c);\n    &#125;\n    return c;\n  &#125;\n&#125;\n默认情况下自定义类加载器的父类为应用程序类加载器，可以在构造函数中指定自定义类加载器的父类加载器\n&#x2F;&#x2F;默认父类加载器为AppClassLoader\npublic static class ClassLoaderA extends ClassLoader&#123;\n  @Override\n  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n&#x2F;&#x2F;通过构造函数指定父类加载器\npublic static class ClassLoaderB extends ClassLoader&#123;\n  public ClassLoaderB(ClassLoader parent)&#123;\n    super(parent);\n  &#125;\n  @Override\n  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n自定义类加载器\n&#x2F;&#x2F;从文件系统的绝对路径下读取类的二进制字节码，通过调用CLassLoader的defineClass函数将二进制的\n&#x2F;&#x2F;字节码转化成Class对象，以此来实现一个加载特定路径下的类的加载器\npublic class FileSystemClassLoader extends ClassLoader&#123;\n  private String rootDir;\n  public FileSystemClassLoader(String rootDir)&#123;\n    this.rootDir &#x3D; rootDir;\n  &#125;\n  @Override\n  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n    String path &#x3D; rootDir + File.separatorChar + \n      name.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;\n    byte[] bytecode &#x3D; null;\n    try(InputStream input &#x3D; new FileInputStream(path))&#123;\n      ByteArrayOutputStream byteStream &#x3D; new ByteArrayOutputStream();\n      byte[] buffer &#x3D; new byte[4096];\n      int readSize &#x3D; 0;\n      while((readSize &#x3D; input.read(buffer)) !&#x3D; -1)&#123;\n        byteStream.write(buffer, 0, readSize);\n      &#125;\n      bytecode &#x3D; byteStream.toByteArray();\n    &#125;catch(FileNotFoundException | IOException e)&#123;\n      e.printStackTrace();\n    &#125;\n    if(bytecode &#x3D;&#x3D; null)&#123;\n      throw new ClassNotFoundException(&quot;class name:&quot; + name);\n    &#125;else&#123;\n      return defineClass(name, bytecode, 0, bytecode.length);\n    &#125;\n  &#125;\n&#125;\npublic class Demo&#123;\n  public static void main(Stringp[] args) throws ClassNotFoundException&#123;\n    ClassLoader classLoader &#x3D; new FileSystemClassLoader(&quot;&#x2F;Users&#x2F;dajunnnnnn&quot;);\n    Class&lt;?&gt; clazz &#x3D; classLoader.loadCLass(&quot;com.code.hello&quot;);\n    System.out.println(clazz.getClassLoader());&#x2F;&#x2F;打印SystemFileClassLoader对象信息\n  &#125;\n&#125;\n\n\n\n2.双亲委派机制3.内存分区1.内存分区\n\n\n\n\n\n\n\n\n编译执行的结果会放在内存中，其中包括代码和数据，为了区分存储和管理不同的内容，所以JVM将内存划分为不同的分区，包括方法区、程序计数器、堆、虚拟机栈、本地方法栈\n\n\n方法区\n存储的主要内容\n类信息：类的权限定名和修饰符（访问标志 public、static、final等），父类、接口列表等相关信息\n方法信息：方法的名称和修饰符（入参、返回值、访问标志等），方法的字节码\n静态变量：静态变量隶属于类，因此存储在方法区而非堆上\n运行时常量池：此分区对应类字节码中的常量池，存储字面量和符号引用\n字符串常量池：此分区专门服务于字符串，避免String对象的重复创建，减少内存开销\nJIT编译代码缓存：此分区存储的是JIT编译之后的机器码\n\n\n方法区是一种抽象分区，不同JVM可以有不同的实现方式。以HotSpot为例，在Java7之前的版本，实现为永久代（Permanent Generation）；Java7中，方法区的字符串常量池和静态变量从永久代中移除，放入堆中；Java7之后，永久带被元空间（MetaSpace）取代，但字符串常量池和静态变量仍存储在堆中\n\n\n程序计数器\n虚拟机相当于一个抽象的计算机，也有自己的指令集（字节码集），因此也需要一个存储单元（程序计数器）用来存储下一条要执行的字节码的地址\n与PC寄存器不同的地方在于：PC寄存器是线程共享的，PC寄存器会随着线程的切换而进行保存和恢复，程序计数器是线程私有的，每个线程都会分配一个独立的程序计数器，记录当前线程执行到哪一行字节码。原因在于PC寄存器位于CPU，是稀缺资源；而程序计数器位于内存，资源相对富裕，线程独享能减少线程上下文切换的信息量，有利于提高线程切换的速度\n\n\n堆（见垃圾回收器）\n用来存储Java对象，在Java中对象的回收是有虚拟机中的垃圾收集器自动完成的，堆是垃圾收集器的主要工作分区，为了配合垃圾收集器算法，堆有以下划分\n年轻代（Young Generation）：\nEden区\nSurvivor区：From Survivor区、To Survivor区\n\n\n老年代（Old Generation）：\n\n\n\n\n虚拟机栈（见下一节）：函数调用中，主要用栈存储函数的局部变量、参数、返回地址等信息。栈是线程私有的，每个线程会有一个栈，因此也叫线程栈。Java中的栈叫做虚拟机栈\n本地方法栈\nJava提供了很多使用C/C++语言实现的native方法，很多Java函数最终是通过调用native方法来实现的。在JVM规范中，Java将服务于Java方法调用的栈，跟服务于native方法调用的栈做了区分，服务于Java方法调用的栈称为虚拟机栈，服务于native方法调用的栈称为本地方法栈。两个栈的功能相同，在具体的虚拟机实现中，如HotSpot中，把两栈合并为一个栈，同时存储Java方法调用的栈帧和native方法调用的栈帧\n默认线程栈的大小：不同平台下有区别，HotSpot默认的每个线程的栈大小为1MB（可更改），JVM可创建的线程个数由进程可用内存大小（计算机可用内存）除以线程栈大小决定，如果不够可以减小线程栈大小来支持创建更多的线程，如果因为函数调用深度太深导致栈溢出，可以通过增大线程栈大小来避免溢出\n\n\n\n2.栈内存3.堆内存4.垃圾回收\n\n\n\n\n\n\n\n\n不同于C++中需要显示地调用delete语句进行内存释放，Java中由JVM负责自动回收（垃圾回收），既提高了开发效率又避免了内存泄漏的问题\n1.可达性分析\n\n\n\n\n\n\n\n\n虚拟机在进行垃圾回收时，首先要判读哪些对象可以被回收，常用的判断算法为可达性分析。其中还会涉及到STW、安全点、安全区等知识\n\n引用计数\n\n是同可达性分析类似的另一种用来判断对象是否可以被回收的算法，但是因为存在问题不被虚拟机采用\n\n在Java中通过引用来表示变量和对象之间的关系，将对象赋值给变量就表示变量引用对象，有多少个变量引用某个对象，此对象的引用计数就是几，并随着变量而增减，知道引用计数为0，该对象被虚拟机当作垃圾回收\npublic void f()&#123;\n  Object a &#x3D; new Object();&#x2F;&#x2F;对象的引用计数为1\n  g(a);&#x2F;&#x2F;1\n  &#x2F;&#x2F;g(a)退出后，变量b的生命周期结束，对象的引用计数变为1\n&#125;&#x2F;&#x2F;f()函数结束，变量a的声明周期结束，对象的引用计数变为0，可以被垃圾回收\npublic void g(Object a)&#123;\n  Object b &#x3D; a;&#x2F;&#x2F;2\n  Object c &#x3D; a;&#x2F;&#x2F;3\n  Object d &#x3D; a;&#x2F;&#x2F;4\n  d &#x3D; new Object();&#x2F;&#x2F;3\n  c &#x3D; null;&#x2F;&#x2F;2\n&#125;\n问题：无法检测循环依赖，如两个对象互相引用，尽管都已经被设置为null，但是引用计数并不为0，仍然无法被回收\nWife hanmeimei &#x3D; new Wife(&quot;Hanmeimei&quot;);&#x2F;&#x2F;Wife对象的引用计数为1\nHusband lilei &#x3D; new Husband(&quot;Lilei&quot;);&#x2F;&#x2F;Husband对象的引用计数为1\nhanmeimei.husband &#x3D; lilei;&#x2F;&#x2F;Husband对象的引用计数为2\nlilei.wife &#x3D; hanmeimei;&#x2F;&#x2F;Wife对象的引用计数为2\nhanmeimei &#x3D; null;&#x2F;&#x2F;Wife对象的引用计数为1\nlilei &#x3D; null;&#x2F;&#x2F;Husband对象的引用计数为1\n&#x2F;&#x2F;剩下一个循环引用，应该被删除\n\n\n可达性分析\n\n把对象之间的引用关系用数据结构中的有向图来表示，图中的顶点表示对象，通过有向边表示变量对对象的引用。\n\n在有向图中，由一组特殊的顶点叫做GC Roots，GC Roots为堆外变量所直接引用的堆内对象，包括虚拟机栈、本地方法栈中的局部变量所直接引用的对象、方法区中静态变量所直接引用的对象等\n\n虚拟机以GC Roots为起点，遍历（DFS或BFS）整个图，可以遍历到的对象为可达对象，也叫做存活对象，遍历不到的对象为不可达对象，也叫做死亡对象，死亡对象会被虚拟机当作垃圾回收\n\n\n\n\nSTW（见垃圾回收器）\n\n运行在虚拟机上的应用程序启动的线程叫做用户线程，执行垃圾回收的线程叫做垃圾回收线程。由于线程之间的并行性，垃圾回收线程执行垃圾回收时，对象可能被用户线程更改，导致可达性分析结果存在误报和漏报的情况（只针对存活对象）\n误报：将非存活对象误报为存货对象。导致本该被垃圾回收的对象没有被回收，只需等待再次垃圾回收\n漏报：漏报存活对象，从而将其判定为死亡对象。会产生严重的问题，导致本不该被回收的对象被回收，从而导致程序出错，解决此问题最简单的方法就是STW（Stop The World），即停止所有用户线程的执行，知道垃圾回收结束，因此会影响程序性能。因此优化垃圾回收过程，尽量减少STW的时间，是各个垃圾回收器努力的重点\n\n\n安全点\n\nGC Roots的获得方式：遍历栈中的局部变量和方法区中的静态变量，找出引用类型变量，然后，再将引用类型变量所引用的对象放入GC Roots中\n\n每次更新垃圾回收都要遍历栈和方法区来查找GC Roots，效率非常低。所以，虚拟机使用OopMap来存储当前的GC Roots并动态更新。\n\n具体做法为：虚拟机先遍历查找一次GC Roots并初始化OopMap，然后在代码的执行过程中，如果有变量更新所引用的对象，那么虚拟机就同步更新OopMap，当虚拟机需要进行垃圾回收时，OopMap中存储的便是当前的GC Roots\n\n对于解释执行来说，上述做法可行，但是对于JIT编译执行来说，上述做法无法实现，因为JIT编译之后的机器码直接交由CPU执行，并不经虚拟机之手，虚拟机无法边执行指令边分析然后再动态更新OopMap，虚拟机需要在字节码编译为机器码时，静态地分析指令，为每一条指令存储此指令执行结束后对应的OopMap，这显然会浪费内存空间\n\n安全点：为了节约空间，虚拟机采用了时间换空间的策略，将为每个指令存储一个OopMap，改为只选取部分指令存储OopMap。这些被选取的指令称为安全点，当虚拟机启动垃圾回收并需要STW时，会向用户线程发送暂停的中断请求，此时，用户线程并不能立刻停止，而是需要运行到安全点之后才能停止，因为只有安全点处才记录了OopMap，只有所有线程都运行到安全点之后，虚拟机才能得到完整的GC Roots\n\n\n\n\n\n\n安全区\n\n大部分情况，用户线程在接收到暂停的中断请求之后，都可以在较短的时间内达到最近的安全点，但是在少数情况下，如果用户线程处于阻塞状态（如等待I/O读写就绪），就无法在较短的时间内达到最近的安全点，为了解决这个问题，虚拟机引入了一个新的概念：安全区，即不会改变对象引用关系的一段连续的代码区间\n当虚拟机执行垃圾回收并发起STW请求时，如果某个线程处于安全区，那么，这个线程并不需要停止执行，而是可以跟垃圾回收线程并行执行。但是，当用户线程离开安全区时，他需要检查虚拟机是否处于STW状态，如果是，用户线程需要阻塞等待STW结束，才能继续往下执行，以免用户线程跳出安全区之后，执行非安全代码导致对象引用关系的改变\n\n\n\n2.垃圾回收算法\n概述：垃圾回收算法用于回收死亡对象，分代垃圾回收算法是主流的垃圾回收算法，虚拟机将堆空间分为年轻代和老年代，针对不同的分代单独进行垃圾回收，针对年轻代的垃圾回收叫做YoundGC、针对老年代的垃圾回收叫做FullGC，FullGC比YoungGC慢很多，原因见下\n\n基础垃圾回收算法（标记使用可达性分析找出需要被回收的死亡对象）\n\n标记-清除：虚拟机将死亡对象所占用的内存空间释放，放入到空闲列表中。当创建对象时，虚拟机从空闲空间列表中，查找大小合适的空闲空间分配给对象。会出现内存碎片的问题，标记-清除后得到的空闲空间不连续，缺点是查找耗时、大对象无法分配\n\n标记-整理：又叫标记-压缩算法，在标记-清除算法的基础上，额外增加了整理的环节，先使用可达性分析标记存活对象所占用的内存空间，然后顺序遍历内存空间，将存活对象移动到内存的一端，从而解决内存碎片的问题，只需记录空闲空间的起始地址用于非配内存空间\n\n标记-复制：将整个内存分为轮流使用的两块内存，一块内存为对象分配内存空间，称为工作内存，另一块内存作为复制时备用（称为备用内存），当工作内存使用完之后，标记-复制算法将这块内存中的存活对象逐一复制到备用内存中，然后，两块内存互换角色。缺点：内存只有一般的利用率，长时间存活的对象会在两块内存复制多次，浪费时间\n\n\n\n分代垃圾回收算法\n\n不需回收：JVM将内存划分为方法区、程序计数器、堆、虚拟机栈、本地方法栈，其中程序计数器的内存非常小，并且随着线程的创建而创建、销毁而销毁。虚拟机栈和本地方法栈存储的是方法对应的栈帧，栈帧随着方法的调用而入栈，随着方法的退出而出栈，因此这三个分区中的垃圾，会随着生命周期的结束而被立刻回收，不需要经过虚拟机的垃圾回收线程的处理\n需要回收：堆中存储的是对象，对象供所有线程共享，作用域范围大，生命周期长，在使用完成之后并不会立刻回收，所以堆是进行垃圾回收的重点工作分区。方法区也会涉及垃圾回收，比如方法区中的一些无用的类（该类的所有对象都已被回收、类的Class对象没有任何变量在引用、加载该类的类加载器已经卸载）或者无用的String常量对象（存储在字符串常量池中的并且没有变量引用的String对象）\n对堆的垃圾回收：应用程序所创建的对象生命周期并不相同，有的生命周期长有的生命周期短。对于短的希望以较高的频率执行垃圾回收，尽快释放所占用的内存空间；对于长的希望以较低的频率进行垃圾回收，避免无效的垃圾回收\n分代垃圾回收算法：因此虚拟机将堆分为年轻代（Young Generation）和老年代（Old Generation）两个分区，年轻代存储声明周期比较短的对象、老年代存储声明周期比较长的对象。虚拟机针对不同的分代使用不同的基础垃圾回收算法（标记-清除、标记-整理、标记-复制），在基础垃圾回收算法之上增加分代之后的垃圾回收算法，叫做分代垃圾回收算法\n\n\n年轻代和YoungGC\n\n新创建的对象会分配在年轻代，因此年轻代也叫新生代（New Generation）。因为大部分对象存活时间都很短，所以年轻代适合标记-复制算法进行垃圾回收，只需要复制少量存活对象，复制耗时少，执行效率高\n\n为了提高标记-算法的内存利用率，将年轻代分为不均等的三个分区：一个Eden区和两个Survivor区。虚拟机将Eden区和一个Survivor区（From Survivor区）作为分配对象使用（工作分区），将另一个Survivor（To Survivor区）作为复制备用（备用分区）。当工作分区满了之后，虚拟机便执行标记-复制算法，将工作区的存活对象复制到To Survivor区，并交换两个Survivor区的角色\n\n\n一般情况下，Eden区比较大，Survivor区比较小，一般根据每次垃圾回收之后存活对象的比例，动态调整Eden区和Survivor区的大小比例，也可以通过JVM参数-XX:SurvivorRatio设置固定的比例，其值表示Eden区和一个Survivor区的大小比例\n\n空间分配担保机制：如果ToSurvivor区存不下一次垃圾回收之后的存活对象，虚拟机会借用老年代的部分空间，将存不下的对象存储在老年代中，老年代起到一个担保的作用（老年代也不够时会执行FullGC，如果仍不够空间则抛出OOM Error），这种处理机制叫做空间分配担保机制。缺点：部分生命周期短的对象存储到了老年代，等待很长时间才能被回收\n\n\n\n老年代和FullGC\n\n新生代存不下的对象、大对象、长期存活对象都会进入老年代\n大对象指的是占用大量连续内存空间的对象，比如大的字符串或数组，默认也会在年轻代创建，但如果设置了JVM参数-XX:PretenureSizeThreshold，当对象大小超过这个阈值，对象会直接在老年代创建，避免生命周期比较长的大对象在年轻代反复被复制\n长期存活的对象指的是经过多次年轻代垃圾回收仍然存活的对象，虚拟机在对象的对象头中记录对象的GC年龄，每经过一次GC，GC年龄就增一，当GC年龄超过一定阈值（默认15，或通过-XX:PretenureSizeThreshold设置）之后，对象便从年轻代移动到老年代。不过，人为设定一个固定值不够灵活，于是，虚拟机设计了动态年龄判断机制，结合存活对象的多少来动态的设置最大GC年龄\n动态年龄判断机制：统计YoungGC后，处于每个GC年龄值的对象占To Survivor区的比例，如果GC年龄&gt;=X（X取最大值）的对象占To Survivor区的比例超过50%（比例通过-XX:TargetSurvivorRatio来设置），那么GC年龄&gt;=X的对象都将直接进入老年代，不等GC年龄大于15\n\n\n老年代的垃圾回收\n因为老年代中的对象生命周期比较长，每次垃圾回收之后，存活对象比较多，所以采用标记-整理算法（标记-清除有内存碎片）进行回收，同理，永久代也使用标记-整理算法进行回收\n老年代的垃圾回收叫做OldGC，但是，在主流虚拟机的实现中，比如HotSpot JVM，在对老年代进行垃圾回收的同时，虚拟机会一并对年轻代和永久代进行垃圾回收，这种对整个堆的垃圾回收叫做FullGC\n因为YoungGC只对年轻代进行垃圾回收，年轻代中的对象的存活率比较低，可达性分析需要遍历的对象和需要进行复制的对象比较少，所以YoungGC比较快，因此也称为MinorGC。而FullGC针对整个堆进行垃圾回收，并且老年代和永久代中的对象的存活率比较高，可达性分析需要遍历的对象和垃圾回收需要处理的对象比较多，所以FullGC比较慢，因此也称为MajorGC\n\n\n\n\n\n3.垃圾回收器\n\n\n\n\n\n\n\n\n垃圾回收器是垃圾回收算法的具体实现，同一种垃圾回收算法可以有不同的实现方式，对应不同的垃圾回收器\n\n垃圾回收器的性能指标\n\n吞吐量：业务代码运行时间 / 应用程序总运行时间「总时间包括业务代码运行时间和垃圾回收/GC时间」\n停顿时间：垃圾回收导致应用程序完全停止业务执行的时间，及STW（Stop-The-World）时间\n资源消耗：资源指的是CPU、内存资源，比如Parallel垃圾回收器使用多线程进行垃圾回收，占用的CPU资源比Serial垃圾回收器多，CMS垃圾回收器的停顿时间虽然比较短，但需要预留内存\n其它指标：与虚拟机的垃圾回收的策略、堆和堆中各个分代大小的设置有关\n回收延迟：从一个对象死亡到被回收所经历的等待时间\n回收频率：隔多久进行一次垃圾回收\n\n\n\n\n四大类常用的垃圾回收器（分类依据：串行/并行、是否STW、针对年轻代/老年代）\n\nSerial垃圾回收器：使用单线程进行垃圾回收，并在垃圾回收时，虚拟机需要暂停应用程序的运行（即Stop The World），针对工作的分区不同有以下两种分类\n\nSerial New：用于年轻代的垃圾回收，基于标记-清除算法来实现\n\nSerial Old：用于老年代的垃圾回收，基于标记-整理算法来实现\n\n\n\nParallel垃圾回收器：使用多线程进行垃圾回收，可以充分利用CPU资源，同Serial，垃圾回收时需要暂停应用程序的运行，有以下三种分类\n\nParallel Scavenge（简称PS）：用于年轻代，基于标记-复制算法，与ParOld配合使用\n\nParallel New（简称ParNew）：用于年轻代，基于标记-复制算法，与CMS配合使用\n\nParallel Old（简称ParOld）：用于老年代，基于标记-整理算法\n\n\n\nCMS垃圾回收器：全称为Concurrent Mark Sweep，采用多线程执行垃圾回收，不同于Parallel，CMS不需要暂停应用程序，但是CMS不能用于年轻代的垃圾回收，年轻代默认使用Parallel New垃圾回收器\n\nCMS垃圾回收器将整个垃圾回收过程分为四个阶段：初始标记、并发标记、重新标记、并发清理，其中初始标记和重新标记需要暂停应用程序，其余两个阶段可以做到并发处理\n\nCMS垃圾回收器在应用程序并行执行的过程中会争抢CPU资源，因此CMS使用的并发线程数等于（CPU内核数+3）/ 4，并且需要在老年代未满的时候进行垃圾回收，为并发执行的应用程序预留内存\n\n预留内存通过JVM参数-XX:CMSInitiatingOccupancyFraction来指定已用内存占老年代的比值，超过此阈值就会触发CMS垃圾回收器的执行\n预留内存空间不够时，转而使用SerialOld垃圾回收器执行本次垃圾回收\n\n\n为了减少STW时间，CMS采用标记-清除算法来实现，相对于标记-整理算法，节省了整理空闲空间的时间，并且CMS针对内存碎片问题进行了改进，即在多次垃圾回收之后进行一次内存碎片的整理\n\n\n\nG1垃圾回收器：全称为Garbage First，是一个应用于堆上的垃圾回收器，借鉴分代的处理思路，G1垃圾回收器将整个堆划分为很多（2048）小的区域（Region），并进一步分为年轻代（Eden区或Survivor区）、老年代，如下图\n\n之前的垃圾回收器都是针对整个分代进行垃圾回收，当分代被划分为更小的区域后，每次垃圾回收时，虚拟机可以只回收分代中的部分区域，进一步缩短STW时间\n\nG1同CMS类似，都是多线程进行垃圾回收，并且回收的过程与应用程序并发执行，不同的地方是G1垃圾回收器整体使用标记-整理算法、局部（每个Region）使用标记-复制\n\n因为G1的STW时间可以预测，所以可以通过-XX:MaxGCPauseMillis设置可允许的最大STW时间，G1根据这个时间决定每次对多少个区域进行垃圾回收\n\n\n\n\n\n\n垃圾回收器的对比与选择\n\n默认Java7、Java8采用Parallel垃圾回收器，Java9采用G1垃圾回收器，可以通过设置JVM参数来指定项目使用的垃圾回收器\n\n\n实战建议\n\nSerial：单核系统，多个应用程序争用CPU资源的环境下，需要刻意限制虚拟机所占用资源的环境，比如运行在移动端的客户端程序\nParallel与CMS相比，前者吞吐量更大，后者停顿时间更少，对于离线服务，首选吞吐量达的Parallel垃圾回收器，对于实时服务，特别是对响应时间敏感的服务，首选停顿时间更少的CMS垃圾回收器\nJava9中，CMS被标记为Deprecated，使用G1取代，针对比较大的堆（大于6GB），首选停顿时间可控的G1垃圾回收器\n\n\n\n\n并发垃圾回收\n\n并发：并非完全并发，而是大部分时间不需要暂停应用程序，并发垃圾回收整个过程分为4个阶段，分别是：初始标记、并发标记、重新标记、并发清理，其中并发标记和并发清理这两个比较耗时的阶段可以与应用程序并发执行，而其余两个阶段仍需要暂停应用程序的执行\n回收过程：初始标记指的是标记GC Roots。并发标记指的是在应用程序不暂停的情况下，以GC Roots为起点，广度或深度优先遍历所有可达对象（存活对象），在并发标记的过程中，应用程序有可能修改对象之间的引用关系，导致并行标记过程出现误标或漏标的情况，重新标记所做的工作就是对误标和漏标进行修正。并发清理指的是在不暂停应用情况下，对标记出来的垃圾对象进行清理\n并发清理：前面三个阶段属于可达性分析，即标记-清除算法中的标记环节，并发清理是标记-清除算法中的清除环节。在并发清理过程中，如果存活对象变为死亡对象，只需要在下一次垃圾回收中被回收即可；而死亡对象不会再变成存活对象，因为死亡对象不再有变量（局部变量或静态变量）的直接或间接引用，因此应用程序是无法在代码中使用这些死亡对象（比如局部变量在函数执行结束后就被销毁了）\n\n\n三色标记算法\n\n三色标记算法主要用于可达性分析，其将遍历过程中的对象分别标记为：白色、灰色、黑色三种类型，各个颜色含义如下\n\n白色：对象没有遍历过，遍历开始时，所有对象都初始化白色，遍历结束后，仍为白表示对象不可达\n灰色：对象已经被遍历，但是对象所直接引用的对象还没有完全被遍历\n黑色：对象已经被遍历，并且对象所直接引用的对象都已经被遍历\n\n\n可达性分析基于图的广度或深度遍历算法来实现，这里以广度优先搜索为例\n\n初始化GC Roots为灰色，其余为白色\n从灰色集合中取出一个灰色对象，标记为黑色，将此对象直接引用的所有白色对象标记为灰色\n重复第二步，知道灰色集合中没有对象为止。此时黑色集合存放的是可达对象，也就是存活对象；白色集合中存在的是不可达对象，也就是死亡对象\n\n\n\n误标和漏标：在三色标记算法执行的过程中，由于并发标记不会暂停应用程序的执行，所以其在执行的过程中，有可能会改变对象的引用关系，从而导致存活对象的误标和漏标问题。误标指的是将非存活对象误标为存活对象（白的标成黑的），漏标指的是将其存活对象漏标，漏标的存活对象会被判定为死亡对象（黑的标成白的）\n\n误标：如果可达性分析进行到如下所示情况，此时应用程序执行objA.fieldB = null;这样一条语句后，由于B已经被标记为灰色，所以B及其所引用的对象仍然会被判定为存活对象\n\n漏标：当可达性分析进行到上图所示的状态，应用程序执行了如下两行代码后，效果如下图所示，此时因为A已经是黑色对象，所以不会再被遍历，因此尽管C是存活对象，但不会被遍历，从而出现漏标的问题\nobjA.fieldc &#x3D; objA.fieldB.fieldC;\nobjA.fieldB.fieldC &#x3D; null;\n\n\n\n\n\n\n\n\n增量更新和原始快照\n\n并发标记的误标和漏标问题会在重新标记中解决，其中误标问题不大，是可以接受的，只会导致垃圾对象延迟回收，但是漏标问题会导致应用程序运行出错，回收不该回收的对象，漏标产生的原因主要有以下两点，两者缺一不可\n新增引用：新增一个黑色对象对一个白色对象的引用\n删除引用：删除所有灰色对象到此白色对象的直接或间接引用\n\n\n针对以上两点，Java发明了两种漏标解决方案，针对第一点新增引用的漏标解决方案叫做增量更新，是CMS垃圾回收器所使用的方案；针对第二点删除引用的漏标解决方案叫做原始快照，是G1垃圾回收器所使用的方案，方案具体如下：\n增量更新：在并发标记的过程中，如果应用程序新增了一个黑色对象对一个白色对象的引用，虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下的白色对象为起点，重新进行可达性分析，这样漏标的白色对象会被重新标记为黑色对象\n原始快照：在并发标记的过程中，如果应用程序删除了一个灰色对象对一个白色对象的直接/间接引用，那么虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下来的白色对象为起点，重新进行可达性分析，这就相当于虚拟机对引用关系改变之前的原始快照进行可达性分析。不过，这些记录下的白色对象有可能是死亡对象，而重新标记阶段会将这些死亡对象重新标记为存活对象，因此，原始快照这种解决方案会导致误标问题，会导致垃圾对象延迟回收\n\n\n\n\n\n5.JVM实战1.JVM性能优化\nJVM性能指标\n\n对于垃圾回收来说，应用程序直接关注的性能指标主要就两个：GC频率和GC时间，也就是多久一次GC和GC一次多久\n一些决定GC频率和时间的内部性能指标\n年轻代中对象的增长速率\n每次YoungGC之后存活对象大小\n每次YoungGC之后进入老年代的对象大小\n老年代对象的增长速率\n\n\n\n\nJVM参数设置\n\nJVM参数一般有3种类型：标准参数（以-开头，比如-version）、X参数（以-X开头，比如-Xint，-Xms2048m）、XX参数（以-XX开头，比如-XX:PrintGCDetails、-XX:PermSize=512m）,这三种类型的参数的稳定性依次下降，即在Java版本更新的过程中，标准参数很少改动，X参数可能会改动，XX参数该懂的可能性比较大\nJVM参数有上百个，但是对绝大部分参数来说，默认的设置便是最普适、最合理的设置。常用的JVM GC参数只有几个，主要集中在内存分配和垃圾回收器的设置这两个方面，如下所示\n设置堆的大小：一般设置为相同的值，避免堆大小的调整而引起的性能损耗\n-Xms：Java堆内存的初始大小\n-Xmx：Java堆内存的最大大小\n\n\n设置年轻代和老年代的大小：设置年轻代大小的方法有三种，但是对于老年代的大小只需要通过堆大小减去年轻代大小即可得到\n-Xmn：年轻代的大小\n-XX:NewSize：年轻代的初始大小\n-XX:MaXNewSize：年轻代的最大大小\n-XX:NewRatio：年轻代与老年的大小比值，值为老年代/年轻代\n\n\n设置永久代或元空间的大小\n-XX:PermSize：永久代的初始大小\n-XX:MaxPermSize：永久代的最大大小，这两个参数只在1.7之前有效\n-XX:MetaspaceSize：元空间的初始大小\n-XX:MaxMetaspaceSize：元空间的最大大小，这两个参数只在1.8之后有效\n\n\n设置Eden区和survivor区的大小\n-XX:SurvivorRatio：一个Survivor区跟Eden区的大小比例，值为Eden区/Survivor区，注意：一共有两个Survivor区\n\n\n设置线程栈的大小\n-Xss：每个线程的栈大小，HotSpot JVM不区分虚拟机栈和本地方法栈，使用一个栈同时存储Java方法和本地方法的栈帧，因此这里只有一个栈大小的设置参数，线程栈大小默认为512KB或1MB，除非系统在运行的过程中，出现非代码因素导致的StackOverflow，才需要调整线程栈的大小，否则默认即可\n\n\n设置垃圾回收器\n-XX:+UseSerialGC：用Serial垃圾回收器\n-XX:+UseParallelGC：用Parallel垃圾回收器\n-XX:+UseConcMarkSweepGC：用CMS垃圾回收器\n-XX:+UseG1GC：用G1垃圾回收器\n\n\n\n\n\n\nJVM性能预估\n\n大部分情况针对JVM参数预设一些经验值，然后根据线上或压测的情况，在做调整优化即可\n\n也可以预估系统对内存的使用情况，每秒产生多少对象，对象的生命周期等，然后根据GC频率和GC时间针对性地设置JVM参数\n\n示例一：\n\n\n\n\nJVM性能调优\n\n在线上，可以基于jstat等工具得到的JVM性能统计数据，进一步做性能调优\n一般来说JVM性能调优所努力的方向是减少GC频率和GC时间，特别是FullGC频率和FullGC时间，相比较YoungGC来说，FullGC要慢很多，需要调整JVM参数，比如：\n增大年轻代的大小，增大Survivor区大小，让对象尽量在年轻代就被回收掉，减少老年代中对象的增长速率，从而降低FullGC频率\n增加老年代的大小也会降低FullGC的频率，但会增大FullGC的时间\n\n\n一般来说，如果堆不是很大，没有长期存活的大对象和内存泄漏，那么应用CMS垃圾回收器并调节年轻代、老年代、Survivor区等内存分配，完全可以将FullGC时间优化到合适的范围，否则可以选择GC时间可控的G1垃圾回收器\n大部分情况，不需要刻意的进行调优，只有当通过监控发现GC严重影响系统性能时，才有必要对JVM参数进行调优\n\n\n\n2.JVM问题排查\n\n\n\n\n\n\n\n\njstat、jmap\n\nJVM性能监控和分析工具\n\nGC统计信息监控：\n\n可视化：JConsole、VisualVM，不仅可以监控GC情况，还可以监控系统资源（CPU、内存等）的使用情况、线程的执行情况\n\njstat\n\n只需要通过jps命令查找到要监控的JVM进程ID，然后执行jstat -gcutil [vmid] [time-interval]即可\n\n\n各列含义如下：\n\nS0：表示Survivor0的内存使用率；S1：表示Survivor1的内存使用率；E：表示Eden区的内存使用率；O：表示老年代的内存使用率；M：表示Metaspace的内存使用率；\nYGC：YoungGC的次数；YGCT：YoungGC的总耗时；FGC：FullGC的次数； FGCT：FullGC的总耗时；GCT：GC的总耗时。\n\n\n\n\n\n\nGC详细日志分析\n\n\n-XX:+PrintGCDetails 打印详细GC日志\n\n-Xloggc:./logs/gc.log 详细GC日志存储的位置\n\n以上日志可以粗略的分为两类：ParNew日志和CMS日志\n\nParNew日志示例\n[GC (Allocation Failure) 4.527: [ParNew: 48243K-&gt;6054K(55296K), 0.0101725 secs] 48243K-&gt;11277K(96256K), 0.0103798 secs] [Times: user&#x3D;0.08 sys&#x3D;0.01, real&#x3D;0.01 secs]\n\n\nGC（Allocation Failure）：表示GC是因为内存分配失败触发的\n4.527：表示GC发生的时间（距离JVM启动所经历的秒数）\n**[ParNew：48243K-&gt;6054K(55296K)，0.0101725 secs]**：表示GC的情况。ParNew表示GC类型为Parallel New，48243K和6054K表示GC前后年轻代中对象的大小。55296K表示年轻代的总大小。0.0101725表示GC耗时\n48243K-&gt;11277K(96256K)，0.0103798 secs：48243K和11277K表示本次GC前后整个堆中对象的大小变化。96256K表示整个堆的总大小\n**[Times: user=0.08 sys=0.01, real=0.01 secs]**：表示GC具体的耗时分析。user=0.08表示GC线程使用CPU的时间，sys=0.01表示系统调用的时间，real=0.01表示墙上时钟，也就是从GC开始到结束所经历的时间，即STW停顿时间。注意，在多核多线程情况下，user时间为每个线程所使用的CPU时间之和，因此，它的大小很有可能超过real时间的大小\n\n\nCMS日志示例：CMS日志包含的信息比ParNew日志要多很多，其中，CMS Initial Mark、CMS-cocurrent-mark、CMS Final Remark、CMS-concurrent-sweep分别对应并发垃圾回收的四个阶段：初始标记、并发标记、重新标记、并发清理。除此之外，CMS日志中的CMS-concurrent-preclean和CMS-concurrent-reset为更加细化的并发垃圾回收阶段，负责CMS内部数据结构的调整工作，这里就不展开详细讲解了\n\n\n\n\n\nJVM内存快照获取和分析：\n\n当JVM出现问题时，比如OOM、频繁GC，我们希望得知当前堆中存储的对象情况，比如哪些对象占据了大量堆内存，我们就需要将当下的内存快照dump出来，然后利用工具来查看和分析\n\n常用的dump堆内存快照的方法有两种，一种是使用JVM参数，另一种是使用jmap命令行工具。具体如下所示。dump出来的堆内存快照为二进制文件，我们需要通过工具来查看，常用的查看工具有MAT、jhat等。\n方法一：使用JVM参数\n-XX:+HeapDumpBeforeFullGC\n-XX:HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath&#x3D;目录\n\n方法二：使用jmap命令行工具\njmap -dump:format&#x3D;b,file&#x3D;文件名 [pid] \n\n\n\n\nJVM常见问题一：OOM\n\n当程序申请不到足够的内存空间，并且JVM通过GC也无法释放出足够的内存空间时，JVM便会抛出OOM\npublic class Stack &#123;\n  private Object[] array;\n  private int capacity;\n  private int top;\n\n  public Stack(int capacity) &#123;\n    this.capacity &#x3D; capacity;\n    this.top &#x3D; 0;\n    this.array &#x3D; new Object[capacity];\n  &#125;\n\n  public void push(Object obj) &#123;\n    array[top++] &#x3D; obj;\n  &#125;\n\n  public Object pop() &#123;\n    &#x2F;&#x2F;只是将top值减一并返回对应的对象，并没有删除array数组对对象的引用关系\n    &#x2F;&#x2F;对象即便已经使用完成，也无法被回收\n    return array[--top];\n  &#125;\n&#125;\n&#x2F;&#x2F;改进版本的pop函数\npublic Object pop() &#123;\n  Object obj &#x3D; array[top-1];\n  array[top-1] &#x3D; null; &#x2F;&#x2F;删除引用关系\n  top--;\n  return obj;\n&#125;\nOOM一般有两种：永久代（元空间）的内存溢出和堆的内存溢出，分别对应以下两种错误信息\njava.lang.OutOfMemoryError: PermGen space(或 MetaSpace)\njava.lang.OutOfMemoryError: Java heap space\n导致内存溢出的常见的原因有如下几种\n\n设置的堆或永久代（元空间）的大小太小\n一次性创建过多的对象，比如通过SQL查询全表数据。\n应用程序使用完成的对象没有被及时释放，导致对应的内存无法被回收，长期积累，便会导致内存耗尽。我们把这种情况叫做内存泄露\n\n\n如何排查OOM问题\n\n当JVM出现OOM问题时，应用程序的对应表现一般是无法继续执行，如果应用程序是接口系统，那么接口将出现大量503错误。这时，我们通过查看日志，便会发现大量java.lang.OutOfMemoryError错误信息。为了排查出到底哪些对象长期存在并大量占用内存，我们需要通过jmap或JVM参数获取堆内存快照，并通过MAT等工具来查看和分析\n使用MAT工具可以得知内存泄漏的数据可能集中在哪些代码，然后就可以去分析源代码，看是否代码存在内存泄漏，又或者创建了太多长期存在的对象，最后可以尝试调大堆内存的大小\n\n\n\n\nJVM常见问题二：频繁GC\n\n一般OOM前会出现频繁GC，主要有两种：频繁YoungGC和频繁FullGC，单纯的频繁YoungGC往往是由年轻代空间太小导致的，只需要适当增大年轻代的大小即可解决这个问题，因为YoungGC只与存活对象的数量有关，与年轻代大小无关\n相对于频繁YoungGC，频繁FullGC会引发更加严重的问题，且解决起来更加复杂。因为FullGC更加消耗CPU资源并且STW停顿时间较长，所以，在发生频繁FullGC时，CPU利用率一般会飙升，并且会出现应用程序变慢的情况（比如接口请求处理速度变慢甚至大量超时）\n触发FullGC的主要原因是老年代空间不足。前面我们已经总结过，老年代的对象一般来源于长期存活的对象、大对象、空间分配担保。接下来，我们从这3个对象来源来分析频繁GC发生的原因。\n长期存活的对象：如果应用程序创建的长期存活的对象比较多，那么，我们可以适当调大老年代的大小，以减少FullGC的频率。不过，这种情况并不常见，大部分应用程序并不会创建太多的长期存活的对象。实际上，内存泄露往往才是导致对象长期存活无法回收的主要原因。如果每次FullGC回收率很低，释放出来的空间很少，那么就说明是存在内存泄露了。频繁FullGC一段时间之后，JVM便会出现OOM\n大对象：前面讲到，大对象会直接进入老年代。过多的大对象是引起频繁FullGC的最常见的原因之一。比如，在某个接口中执行了未分页SQL，一次性加载过多数据到内存中，当高并发下，接口大量被调用，就会导致大量大对象被创建，从而导致老年代空间不足，引发频繁FullGC。定位此种频繁FullGC发生的原因，我们需要在FullGC前（设置JVM参数-XX:+HeapDumpBeforeFullGC）dump内存快照，分析占用堆内存比较多的是哪个对象，以此来定位问题代码\n空间分配担保：前面讲到，在执行YoungGC时，如果To Survivor空间不足，JVM会触发空间分配担保，将对象存储到老年代。因此，如果每次YoungGC，To Survivor都被占满，那么，我们就要考虑增大To Survivor区，避免空间分配担保，减少进入老年代的对象数量\n\n\n\n\nJVM常见问题三：GC时间过长\n\n堆内存过大：前面讲到，年轻代使用标记-复制垃圾回收算法，并且，年轻代空间增大并不会导致存活对象增多，因此，YoungGC时间跟年轻代的大小无关，但是，老年代使用标记-整理或标记-清除垃圾回收算法，并且，老年代空间增大会导致存活对象增多，因此，FullGC时间跟老年代的大小有关。老年代过大会导致FullGC时间过长。针对比较大的堆内存，我们应该选择GC时间可控的G1垃圾回收器，或者在一台大物理内存的机器上部署多个JVM，以减小单个堆内存的大小\nConcurrent Mode Failure：前面讲到，CMS垃圾回收器采用并发垃圾回收算法，在垃圾回收的某些阶段，应用程序可以与之并发执行。应用程序的执行需要堆内存，因此，JVM在执行垃圾回收前，会预留一定的堆内存空间。但是，在执行垃圾回收的的过程中，如果预留空间不足，应用程序无法继续执行，那么，JVM便会抛出Concurrent Mode Failure错误，并且，暂停CMS垃圾回收器的执行，改为STW停顿时间更长的Serial Old垃圾回收器。垃圾回收器的中止和切换势必会增长FullGC时间。如果我们在GC详细日志中（通过设置JVM参数-XX:+PrintGCDetails得到）发现大量Concurrent Mode Failre字样，那么，我们就需要通过减小JVM参数-XX:CMSInitialOccupancyFraction的值来调大预留空间的大小\n操作系统swap：swap是操作系统中的概念。当物理内存不足时，操作系统会将物理内存中的部分不活跃的数据放入磁盘，当这部分数据重新被使用时，再从磁盘加载到物理内存中。这种数据在物理内存和磁盘之间换入换出的机制，就叫作swap。swap涉及磁盘I/O操作，非常影响进程的性能。如果设置的JVM堆内存大小超过物理内存大小，或者多个应用程序争用有限的物理内存，那么，就有可能触发swap而导致GC时间增长。解决这个问题的方法也很简单，尽量保证JVM堆大小不要超过物理内存的大小，并且为操作系统或者其他软件预留充足的物理内存，比如物理内存有8GB，我们设置JVM堆大小为6GB，预留2GB给操作系统和其他并发运行的软件\n\n\n\n新特性1.jdk9（2017.09）\n模块化\n\nJPMS（Java Platform Module System）是Java 9发行版的核心亮点。它也被称为Jigshaw项目。模块是新的结构，就像我们已经有包一样。使用新的模块化编程开发的应用程序可以看作是交互模块的集合，这些模块之间具有明确定义的边界和依赖关系。\n\nJPMS包括为编写模块化应用程序提供支持，以及将JDK源代码模块化。JDK 9 附带了大约 92 个模块（在 GA 版本中可以进行更改）。Java 9 Module System有一个”java.base“模块。它被称为基本模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于”java.base”。\n\n在java模块化编程中：\n\n一个模块通常只是一个 jar 文件，在根目录下有一个文件module-info.class。\n要使用模块，请将 jar 文件包含到modulepath而不是classpath. 添加到类路径的模块化 jar 文件是普通的 jar 文件，module-info.class文件将被忽略。\n\n\n典型的module-info.java类如下所示：\nmodule helloworld &#123;\n  exports com.alibaba.eight; \n&#125; \nmodule test &#123;\n  requires helloworld; \n&#125;\n总结：模块化的目的，是让jdk的各个组件可以被分拆，复用和替换重写，比如对java的gui不满意，可以自己实现一个gui，对java的语法不满意，可以把javac替换成其他语言和其他语言的编译器，比如kotlin和kotlinc等，没有模块化，几乎很难实现，每次修改某个模块，总不能把整个jdk给重新编译一遍，再发布一个整个sdk吧，模块化可以帮助更有效的定制化和部署\n\n\n\n优化API\n\n提供了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法\n接口支持私有方法\ntry-with-resources的改进\n\n\nJVM采用G1为默认垃圾收集器\n\n\n2.jdk10（2018.03）\n通过var关键字实现局部变量类型推断，是Java变为弱类型语言。虽然我们在代码中使用var进行了定义，但是对于虚拟机来说他是不认识这个var的，在java文件编译成class文件的过程中，会进行解糖，使用变量真正的类型来替代var\nvar value &#x3D; new MyObject();\nJVM的G1垃圾回收由单线程改成多线程并行处理，降低G1的停顿时间\n\n线程本地握手，允许在不执行全局VM安全点的情况下执行线程回调，可以停止单个线程，而不需要停止所有线程或不停止线程\n\n\n3.jdk11（2018.09 LTS）\n对Stream、Optional、集合API进行增强\n\nStream API改进：Collectors.teeting()，teeing 收集器已公开为静态方法Collectors::teeing。该收集器将其输入转发给其他两个收集器，然后将它们的结果使用函数合并\nList&lt;Student&gt; list &#x3D; Arrays.asList(\n        new Student(&quot;唐一&quot;, 55),\n        new Student(&quot;唐二&quot;, 60),\n        new Student(&quot;唐三&quot;, 90));\n\n&#x2F;&#x2F;平均分 总分\nString result &#x3D; list.stream().collect(Collectors.teeing(\n        Collectors.averagingInt(Student::getScore),\n        Collectors.summingInt(Student::getScore),\n        (s1, s2) -&gt; s1 + &quot;:&quot; + s2));\n\n&#x2F;&#x2F;最低分  最高分\nString result2 &#x3D; list.stream().collect(Collectors.teeing(\n        Collectors.minBy(Comparator.comparing(Student::getScore)),\n        Collectors.maxBy(Comparator.comparing(Student::getScore)),\n        (s1, s2) -&gt; s1.orElseThrow() + &quot;:&quot; + s2.orElseThrow()\n));\n\nSystem.out.println(result);\nSystem.out.println(result2);\n\n\n新增ZGC垃圾收集器：可伸缩低延迟垃圾收集器，ZGC可以看做是G1之上更细粒度的内存管理策略。由于内存的不断分配回收会产生大量的内存碎片空间，因此需要整理策略防止内存空间碎片化，在整理期间需要将对于内存引用的线程逻辑暂停，这个过程被称为”Stop the world”。只有当整理完成后，线程逻辑才可以继续运行。（并行回收）\n\nHttp Client重写，支持HTTP/1.1和HTTP/2 ，也支持 websockets\n\nJava 使用HttpURLConnection进行HTTP通信已经很长一段时间了。但随着时间的推移，要求变得越来越复杂，应用程序的要求也越来越高。在 Java 11 之前，开发人员不得不求助于功能丰富的库，如Apache HttpComponents或OkHttp等。\n作为JDK11中正式推出的新Http连接器，支持的功能还是比较新的，主要的特性有：\n完整支持HTTP 2.0 或者HTTP 1.1\n支持 HTTPS/TLS\n有简单的阻塞使用方法\n支持异步发送，异步时间通知\n支持WebSocket\n支持响应式流\n\n\nHTTP2.0其他的客户端也能支持，而HttpClient使用CompletableFuture作为异步的返回数据。WebSocket的支持则是HttpClient的优势。响应式流的支持是HttpClient的一大优势。\nHttpClient中的NIO模型、函数式编程、CompletableFuture异步回调、响应式流让HttpClient拥有极强的并发处理能力，所以其性能极高，而内存占用则更少。\n\n\n\n4.jdk12（2019.03）\nG1收集器的优化，将GC的垃圾分为强制部分和可选部分，强制部分会被回收，可选部分可能不会被回收，提高GC的效率。新增Shenandoah GC垃圾回收算法\n\n5.jdk13（2019.09）\nZGC优化，增强 ZGC 释放未使用内存，将标记长时间空闲的堆内存空间返还给操作系统，保证堆大小不会小于配置的最小堆内存大小，如果堆最大和最小内存大小设置一样，则不会释放内存还给操作系统\n\nSocketAPI 重构，Socket的底层实现优化，引入了NIO\n\n文本块升级 “”” ，引入了文本块，可以使用”””三个双引号表示文本块，文本块内部就不需要使用换行的转义字符\n&#x2F;&#x2F;改进前\nString json  &#x3D; &quot;&#123;\\r\\n&quot; + &quot;\\&quot;name\\&quot; : \\&quot;lingli\\&quot;,\\r\\n&quot; + &quot;\\&quot;website\\&quot; : \\&quot;https:&#x2F;&#x2F;www.alibaba.com&#x2F;\\&quot;\\r\\n&quot; + &quot;&#125;&quot;;\n&#x2F;&#x2F;改进后\nString json &#x3D; &quot;&quot;&quot; \n&#123;     \n    &quot;name&quot; : &quot;Baeldung&quot;,     \n    &quot;website&quot; : &quot;https:&#x2F;&#x2F;www.alibaba.com&#x2F;&quot; \n&#125; \n&quot;&quot;&quot;;\n\n\nisBlank()：如果字符串为空或字符串仅包含空格（包括制表符），则返回 true。注意与isEmpty() 不同，isEmpty()仅在长度为 0 时返回 true。\nlines()：将字符串拆分为字符串流，每个字符串包含一行。\nstrip() ：分别从开头和结尾；\nstripLeading()/stripTrailing()仅开始和仅结束删除空格。\nrepeat(int times)：返回一个字符串，该字符串采用原始字符串并按指定的次数重复该字符串。\nreadString()：允许从文件路径直接读取到字符串。\nwriteString(Path path)：将字符串直接写入指定路径处的文件。\nindent(int level)：缩进字符串的指定量。负值只会影响前导空格。\ntransform(Function f)：将给定的 lambda 应用于字符串。\n\n\n\n6.jdk14（2020.03）\n改进 NullPointerExceptions提示信息，打印具体哪个方法抛的空指针异常，避免同一行代码多个函数调用时无法判断具体是哪个函数抛异常的困扰，方便异常排查；\n\nswitch表达式语法扩展\n\n可以有返回值。此更改扩展了switch 语句以便它可以用作语句或表达式。不必为break每个 case 块定义一个语句，我们可以简单地使用箭头语法\nboolean isWeekend &#x3D; switch (day) &#123;\n  case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; false; \n  case SATURDAY, SUNDAY -&gt; true;\n  default -&gt; throw new IllegalStateException(&quot;Illegal day entry :: &quot; + day);\n&#125;;\n\n\nint size &#x3D; 3;\nString cn &#x3D; switch (size) &#123;\n    case 1 -&gt; &quot;壹&quot;;\n    case 2 -&gt; &quot;贰&quot;;\n    case 3, 4 -&gt; &quot;叁&quot;;\n    default -&gt; &quot;未知&quot;;\n&#125;;\nSystem.out.println(cn);\n&#x2F;&#x2F;要使用此预览功能，我们必须在应用程序启动期间使用–enable-preview标志明确指示 JVM。\nswitch表达式增加yield关键字用于返回结果，作用类似于return，如果没有返回结果则使用break\nboolean isWeekend &#x3D; switch (day) &#123;\n  case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; false; \n  case SATURDAY, SUNDAY -&gt; true;\n  default -&gt; throw new IllegalStateException(&quot;Illegal day entry :: &quot; + day);\n&#125;;\n\n\nint size &#x3D; 3;\nString cn &#x3D; switch (size) &#123;\n    case 1 -&gt; &quot;壹&quot;;\n    case 2 -&gt; &quot;贰&quot;;\n    case 3, 4 -&gt; &quot;叁&quot;;\n    default -&gt; &quot;未知&quot;;\n&#125;;\nSystem.out.println(cn);\n&#x2F;&#x2F;要使用此预览功能，我们必须在应用程序启动期间使用–enable-preview标志明确指示 JVM。\n\n\n\n7.jdk15（2020.09）\nSealed Classes（封闭类，预览），通过sealed关键字修饰抽象类限定只允许指定的子类才可以实现或继承抽象类，避免抽象类被滥用\n\n8.jdk16（2021.03）\ninstanceof模式匹配，instanceof类型匹配语法简化，可以直接给对象赋值，如if(obj instanceof String str),如果obj是字符串类型则直接赋值给了str变量\n之前：\n\nObject obj &#x3D; &quot;大阳&quot;;\nif (obj instanceof String) &#123;\n    String t &#x3D; (String) obj;\n    &#x2F;&#x2F; TODO\n&#125;\n\n现在：\n\nObject obj &#x3D; &quot;大阳&quot;;\nif (obj instanceof String t) &#123;\n    &#x2F;&#x2F; TODO 此时t已经是String类型了\n&#125;\n引入Record类型，类似于Lombok 的@Data注解，可以向Lombok一样自动生成构造器、equals、getter等方法\n&#x2F;**\n * record 记录类\n * 你也可以覆写equals() hashCode() toString()方法，不用写get、set了\n * @author DAYANG\n *&#x2F;\nrecord User(String name, Integer age) &#123;\n    \n    @Override\n    public String toString() &#123;\n        return &quot;User[&quot; +\n                &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age&#x3D;&quot; + age +\n                &#39;]&#39;;\n    &#125;\n    @Override\n    public boolean equals(Object obj) &#123;\n        return false;\n    &#125;\n    @Override\n    public int hashCode() &#123;\n        return 0;\n    &#125;\n&#125;\n提供用于打包独立 Java 应用程序的 jpackage 工具\n\n\n9.jdk17（2021.09 LTS）\nFree Java License\n\nSpring 6 和 Spring Boot 3需要JDK17\n\n正式引入密封类sealed class，限制抽象类的实现：在Java15之前，所有的类都可以没有限制地继承其他类–除非被继承类被声明为final类型，任何类都可以实现公共接口。现在在Java15中，一个类或者接口可以使用修饰符sealed声明为密封类或者接口，来限制其继承类。\n&#x2F;**\n * 定义一个抽象密封类Pet，它的实现类只能是Dog, Cat这两个，其他的实现类均不允许\n *&#x2F;\npublic abstract sealed class Pet\n    permits Dog, Cat &#123;&#125;\n\nfinal class Dog extends Pet &#123;\n&#125;\n\nfinal class Cat extends Pet &#123;\n    \n&#125;\n\n&#x2F;&#x2F;密封的类和接口限制了其他类或接口可以扩展或实现它们\npublic sealed interface Shape&#123;\n    final class Planet implements Shape &#123;&#125;\n    final class Star   implements Shape &#123;&#125;\n    final class Comet  implements Shape &#123;&#125;\n&#125;\n\npublic abstract sealed class Test&#123;\n    final class A extends Test &#123;&#125;\n    final class B extends Test &#123;&#125;\n    final class C extends Test &#123;&#125;\n&#125;\n\n10.JVM变化总结\nJDK9: 设置G1为JVM默认垃圾收集器\nJDK10：并行全垃圾回收器 G1，通过并行Full GC, 改善G1的延迟。目前对G1的full GC的实现采用了单线程-清除-压缩算法。JDK10开始使用并行化-清除-压缩算法。\nJDK11：推出ZGC新一代垃圾回收器（实验性）,目标是GC暂停时间不会超过10ms，既能处理几百兆的小堆，也能处理几个T的大堆。\nJDK14 ：删除CMS垃圾回收器;弃用 ParallelScavenge + SerialOld GC 的垃圾回收算法组合;将 zgc 垃圾回收器移植到 macOS 和 windows 平台\nJDk 15 : ZGC (JEP 377) 和Shenandoah (JEP 379) 不再是实验性功能。默认的 GC 仍然是G1。\nJDK16：增强ZGC，ZGC获得了 46个增强功能 和25个错误修复，控制stw时间不超过10毫秒\n\nData Structure基础1.大O复杂度表示法\n\n\n\n\n\n\n\n\n 一个不用具体的测试数据来测试，就可以粗略地估计算法执行效率的方法\n\n分析方法：\n只关注循环执行次数最多的一段代码\n加法法则：总复杂度等于量级最大的那段代码的复杂度\n乘法法则：嵌套代码的复杂度等于嵌套内外的代码复杂度乘积\n复杂度：O(1)&lt;O(log2 n)&lt;O(n)&lt;O(nlog2 n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)\n\n\n空间复杂度：\n循环、递归调用栈、辅存\n算法的储存空间与数据规模之间的增长关系，看额外的内存消耗而不是数据本身存储需要多少空间\n\n\n时间复杂度：\n不看低阶、不看系数、加法取大、乘法取积、最坏+平均+最好\n分类：\n最好：在最理想的情况下，如排序的数据恰好顺序\n最坏：最糟糕情况下，如要排序的数据恰好逆序\n低阶、常量、系数都不考虑\n平均：要用到概率论，求平均次数。即将每种情况发生的概率也考虑进去得到加权平均值\n均摊：摊还分析：把一次O（n）操作均摊到n-1次O（1）操作上，得到时间复杂度为O（1），一般都等于最好时间复杂度\n\n\n\n\n\n2.算法思想2.1贪心算法2.2分治算法2.3动态规划2.4回溯算法2.5枚举算法1.纯编程题\n\n\n\n\n\n\n\n\n题型说明：比重大，解决思路简单，但编程实现繁琐；如何准备：==多练-&gt;提高编程能力==\n1.1 解题技巧\n先忽略掉不容易处理的特殊情况，只考虑正常情况，==简化==编程。\n写代码前先写注释，通过==注释==让代码模块化，让思路更清晰。\n写完代码多举几个==特例==，来验证代码是否正确。\n\n1.2 解题步骤\n举例读懂题意，梳理题目要求\n列出测试用例（测试驱动开发）\n总结归纳处理思路（把逻辑中重复出现部分抽象出来）\n第一轮编写代码（写注释，让代码模块化，逻辑更清晰）\n使用测试用例验证代码，并完善代码\n\n1.3 例题\n\n\n拼多多.IP地址解析\n1.两数之和\n1108.IP地址无效化\n344.反转字符串\n\n\n\n剑指offer58-1\n125.验证回文串\n9.回文数\n58.最后一个单词长度\n\n\n剑指offer05\n剑指offer58-2\n26.删排序数组中重复项\n剑指offer67*\n\n\n\n\n\n\n\n\n2.找规律题\n\n\n\n\n\n\n\n\n题型说明：较常考，但不要花太多时间。难在找规律但编程实现简单\n2.1 解题技巧==举例总结规律，猜想距离验证==\n​    先抛开它是一道算法题，抛开要用计算机编程实现。我们针对某个具体的例子，去思考如何解决，实际上，解决具体的例子就是一个小学数学题或者智力题。我们去通过解决多个例子，从中得到启发，总结出规律，总结出针对任何例子的通用解决方案，然后翻译成代码。\n2.2 例题\n\n\n钉钉22暑期实习：换啤酒\n剑指offer61.扑克牌中的顺子\n面试题01.08零矩阵\n面试题16.11跳水板\n\n\n\n面试题01.05一次编辑\n面试题16.15珠玑妙算\n面试题16.04井字游戏\n55.跳跃游戏\n\n\n48.旋转图像*\n54.螺旋矩阵*\n240.搜索二维矩阵2*\n\n\n\n\n\n\n\n\n\n3.数组和链表\n\n\n\n\n\n\n\n\n==数据结构==就是指一组数据的存储结构，==算法==就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。数据结构是静态的，如果不在数据结构上构建算法，那么孤立的数据结构是没有用的，\n3.1数组\n\n\n\n\n\n\n\n\n数组用一组连续的内存空间，来存储一组具有相同数据类型的数据。\n\n数组的特点：按照下标快速访问数组元素。（基址加偏移量，其中偏移量=数据个数*数据大小）\n支持动态扩容的数组：==ArrayList==\n编程语言中的数组是一种数据类型，每种编程语言会结合自己语言的实现特点，对数组这种数据类型进行调整，并不会完全严格按照数据结构中数组的定义。\n基础知识：\n定义：Array是一种线性表数据结构，它用一种连续的内存空间，来存储一组具有相同类型的数据。\n操作：高效的查找（支持随机访问）\n插入：有序，需要移动数据；无序，直接加，原数据移最后即可\n删除：可以不直接删除，标记一下，最后一起删除（JVM标记清除垃圾回收算法的核心思想）\n下标从0开始\n警惕数组的访问越界，循环时要注意判定条件：a[k]_address = base_address + k * type_size\n下标的确切定义是偏移，相对首地址偏移的量\n适用情况\n基本类型（int，long）用数组\n数据大小事先知道，并且对数组的操作非常简单\n多维数据往往用多维数组更直观\n\n\n容器与数组的关系：一般业务开发，如Java中ArrayList完全可以解决，但做一些非常底层的开发，为了做到极致的性能可以用数组\n\n\n\n3.2链表\n\n\n\n\n\n\n\n\n链表用非连续的内存空间来存储数据，用过next指针将内存块串联在一起。==LinkedList为双向链表==\n\n经典案例：LRU缓存淘汰算法\n维护一个有序数组，越靠近链表尾部的节点是越早之前访问的，当有新的数据时，从头遍历，若已存在，则删掉重新插入到头部；若未存在，则可当内存满时删掉尾节点，插入到头部，内存未满直接插入到头部\n\n其它缓存淘汰机制：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）\npublic class LRUCache &#123;\n    private class DLinkedNode&#123;\n        private int key;\n        private int value;\n        public DLinkedNode prev;\n        public DLinkedNode next;\n        public DLinkedNode(int key, int value)&#123;\n            this.key &#x3D; key;\n            this.value &#x3D; value;\n        &#125;\n    &#125;\n    private Map&lt;Integer,DLinkedNode&gt; hashtable &#x3D; new HashMap&lt;Integer, DLinkedNode&gt;();\n    private int size;\n    private int capacity;\n    private DLinkedNode head;\n    private DLinkedNode tail;\n\n    public LRUCache(int capacity) &#123;\n        this.size &#x3D; 0;\n        this.capacity &#x3D; capacity;\n        this.head &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.tail &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.head.prev &#x3D; null;\n        this.head.next &#x3D; tail;\n        this.tail.prev &#x3D; head;\n        this.tail.next &#x3D; null;\n    &#125;\n\n    public int get(int key)&#123; &#x2F;&#x2F;在缓存中查找数据\n        if (size &#x3D;&#x3D; 0)&#123;\n            return -1;\n        &#125;\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node &#x3D;&#x3D; null)&#123;\n            return -1;\n        &#125;\n        removeNode(node);\n        addNodeAtHead(node);\n        return node.value;\n    &#125;\n\n    public void remove(int key)&#123; &#x2F;&#x2F;从缓存中删除数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            removeNode(node);\n            hashtable.remove(key);\n        &#125;\n    &#125;\n\n    private void addNodeAtHead(DLinkedNode node) &#123;\n        node.next &#x3D; head.next;\n        head.next.prev &#x3D; node;\n        head.next &#x3D; node;\n        node.prev &#x3D; head;\n    &#125;\n\n    private void removeNode(DLinkedNode node) &#123;&#x2F;&#x2F;特殊情况（删除尾节点、删除最后一个节点））\n        node.next.prev &#x3D; node.prev;\n        node.prev.next &#x3D; node.next;\n    &#125;\n\n    public void put(int key, int value)&#123;&#x2F;&#x2F;往缓存中添加一个数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            node.value &#x3D; value;\n            removeNode(node);\n            addNodeAtHead(node);\n        &#125;\n        if (size &#x3D;&#x3D; capacity)&#123;\n            hashtable.remove(tail.prev.key);\n            removeNode(tail.prev);\n            size--;\n        &#125;\n        DLinkedNode newNode &#x3D; new DLinkedNode(key,value);\n        addNodeAtHead(newNode);\n        hashtable.put(key, newNode);\n        size++;\n    &#125;\n&#125;\n\n\n\n定义：通过“指针”将一组零散的内存块串联起来使用\n链表结构\n单链表：数据data+后继指针next、尾节点指向null\n基本操作：插入、删除、访问、遍历（回文字符串：快慢指针）\n\n\n双向链表：前驱节点prev+ 数据data+后继指针next\n空间换时间的思想\n入或删除给定指针指向的节点时，比单链表高效\n查询的效率也会更高，可以记录上次查到的节点\n\n\n循环链表：尾节点指针指向头节点\n从链尾到链头比较方便\n简化约瑟夫问题\n\n\n双向循环链表\n\n\n链表书写技巧\n理解指针或引用的含义：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量\n警惕指针缺失或内存泄漏\n在插入时一定要注意操作的顺序，在删除时，一定要记得手动释放内存空间\n利用哨兵简化实现难度\n解决边界问题，从而防止对特殊条件的判断。如插入第一个节点和删除最后一个节点\n在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵节点，把这时的链表称为带头链表\n重点留意边界值处理\n如果链表为空，代码是否能正常工作\n如果链表只包含一个节点时，代码是否能正常工作\n如果链表只包含两个节点时，代码是否能正常工作\n代码逻辑在处理头节点和尾节点时，是否能正常工作\n\n\n\n\n\n&#x2F;&#x2F;LinkList\npublic class LinkList&#123;\n    public class Node&#123;\n        public int data;\n        public Node next;\n        public Node(int data, Node next)&#123;\n            this.data &#x3D; data;\n            this.next &#x3D; next;\n        &#125;\n    &#125;\n    private Node head &#x3D; null;\n    public void travel(Node node)&#123;\n        Node p &#x3D; head;\n        while(p!&#x3D;null)&#123;\n            &#x2F;&#x2F;处理p节点的数据\n            p &#x3D; p.next;\n        &#125;\n    &#125;\n    public Node find(int value)&#123;\n        Node p &#x3D; head;\n        while(p !&#x3D; null)&#123;\n            if(p.data &#x3D;&#x3D; value)\treturn p;\n            p &#x3D; p.next;\n        &#125;\n        return null;\n    &#125;\n    public void insertAtHead(int value)&#123;\n        Node newNode &#x3D; new Node(value,null);\n        newNode.next &#x3D; head;\n        head &#x3D; newNode;\n    &#125;\n    public void insetAtTail(int value)&#123;\n        Node newNode &#x3D; new Node(value, null);\n        if(head &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;优化2：添加虚拟head头节点&#x2F;哑节点&#x2F;哨兵节点，不需要考虑head &#x3D;&#x3D; null的情况\n            head &#x3D; newNode;\n        &#125;else&#123;\n            Node p &#x3D; head;\n            while(p.next !&#x3D; null)&#123;&#x2F;&#x2F;优化1：添加tail尾指针，但需要考虑空链表的特殊情况\n                p &#x3D; p.next;\n            &#125;\n            p.next &#x3D; newNode;\n        &#125;\n    &#125;\n    public void deleteNextNode(Node p)&#123;\n        if (p &#x3D;&#x3D; null || p.next &#x3D;&#x3D; null)&#123;return;&#125;\n\t\tp.next &#x3D; p.next.next;&#x2F;&#x2F;GC会回收        \n    &#125;\n    public void deleteNode(Node p)&#123;\n        if(p &#x3D;&#x3D; null || head &#x3D;&#x3D; null)&#123;return;&#125;\n        Node prev &#x3D; null;\n        Node q &#x3D; head;\n        while(q !&#x3D; null)&#123;\n            if(q &#x3D;&#x3D; p) break;\n            prev &#x3D; q;\n            q &#x3D; q.next;\n        &#125;\n        if(q &#x3D;&#x3D; null)return;&#x2F;&#x2F;没找到\n        if(prev &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;删除头节点\n            head &#x3D; head.next;\n        &#125;else&#123;&#x2F;&#x2F;删除非头节点\n            prev.next &#x3D; q.next;\n        &#125;\n    &#125;\n&#125;\n\n\n3.3题型\n\n\n\n\n\n\n\n\n题型有限，代码实现难，主要考编程能力，可能会出原题，经典题要写熟练！\n3.3.1 解题技巧\n链表相关题目都会涉及遍历，核心是通过画图举例确定遍历的三要素\n遍历的结束条件：p == null or p.next == null or …\n指针的初始值：p == head or …\n遍历的核心逻辑：视题目要求而定\n\n\n特殊情况处理：是否需要对==头节点==、==尾节点==、==空链表==等做特殊处理？\n引入==虚拟节点==：是否可以通过添加虚拟节点简化编程？\n\n###3.4例题\n\n\n\n203.移除链表元素\n876.链表的中间节点\n83.删除排序链表中的重复元素\n剑指offer25.合并排序链表\n\n\n\n2.两数相加\n206.反转链表\n234.回文链表\n328.奇偶链表\n\n\n25.K个一组翻转链表\n剑指offer22.链表倒数第K节点\n19.删除链表倒数第N结点\n160.相交链表\n\n\n141.环形链表\n\n\n\n\n\n4.栈和队列4.1栈\n\n\n\n\n\n\n\n\n先进后出，后进先出，只允许在一端（栈顶）插入和删除数据，当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构\npublic class Stack&#123;\n    public void push(int data)&#123;...&#125;\n    public int pop()&#123;return -1;&#125;&#x2F;&#x2F;弹出栈\n    public int peek()&#123;...&#125;&#x2F;&#x2F;不弹出栈\n&#125;\n\n\n\n4.1.1 顺序栈public class ArrayStack&#123;&#x2F;&#x2F;基于数组实现的顺序栈\n    private int[] items;&#x2F;&#x2F;数组\n    private int count;&#x2F;&#x2F;栈中元素个数\n    private int n;&#x2F;&#x2F;栈的大小\n    public ArrayStack(int n)&#123;\n        this.items &#x3D; new int[n];&#x2F;&#x2F;申请一个大小为n的数组空间\n        this.count &#x3D; 0;\n        this.n &#x3D; n;\n    &#125;\n    public boolean push(int item)&#123;\n        if(count &#x3D;&#x3D; n) return false;&#x2F;&#x2F;数组空间不够用了，入栈失败\n        &#x2F;&#x2F;将item放到下标为count的位置，并且count加1\n        items[count] &#x3D; item;\n        ++count;\n        return true;\n    &#125;\n    public int pop()&#123;\n        if(count &#x3D;&#x3D; 0) return -1;&#x2F;&#x2F;栈为空，则直接返回-1\n        &#x2F;&#x2F;返回下标为count-1的数组元素，并且栈中元素个数count-1\n        int value &#x3D; items[count-1];\n        --count;\n        return value;\n    &#125;\n    public int peek()&#123;\n        if(count &#x3D;&#x3D; 0) return -1;&#x2F;&#x2F;栈为空，则直接返回-1\n        return items[count-1];\n    &#125;\n&#125;\n\n\n\n4.1.2 链式栈public class LinkedListStack&#123;\n    private class Node&#123;\n        public int data;\n        public Node next;\n        public Node(int data,Node next)&#123;\n            this.data &#x3D; data;\n            this.Node &#x3D; next;\n        &#125;\n    &#125;\t\n    private Node head &#x3D; Null;\n    \n    public void push(int value)&#123;\n        Node newNode &#x3D; new Node(value,null);\n        newNode.next &#x3D; head;\n        head &#x3D; newNode;\n    &#125;\n    public int pop()&#123;\n    \tif(head &#x3D;&#x3D; null) return -1;\n        int value &#x3D; head.data;\n        head &#x3D; head.next;\n        return value;\n    &#125;\n    public int peek()&#123;\n        if(head &#x3D;&#x3D; null) return -1;\n        return head.data;\n    &#125;\n&#125;\n\n4.1.3经典应用\n浏览器的前进和后退\n两个栈，x和y，把首次浏览的页面压入栈x，当浏览器后退时，再依次从栈x中出栈，并压入栈y，当前进时再反过来\n\n\n函数调用中的应用\n我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。\n\n\n表达式求值\n维护两个栈，一个保存操作数，一个保存运算符\n\n\n括号匹配\n看是否是一对对括号\n\n\n\n4.2队列\n\n\n\n\n\n\n\n\n先进先出，后进后出，只允许在队列头部取出数据，尾部插入数据\npublic class Queue&#123;\n    public boolean enqueue(String data)&#123;...&#125;\n    public String dequeue()&#123;...&#125;\n    public String peek()&#123;...&#125;\n&#125;\n\n\n\n4.2.1 循环队列public class CircularQueue&#123;\n    private String[] items;\n    private int n;\n    private int head &#x3D; 0;\n    private int tail &#x3D; 0;\n    \n    public CircularQueue(int n)&#123;\n        this.items &#x3D; new String[n];\n        this.n &#x3D; n;\n    &#125;\n    \n    public boolean enqueue(String item)&#123;\n        if((tail + 1) % n &#x3D;&#x3D; head) return false;&#x2F;&#x2F;空一个位置，即为队列满\n        items[tail] &#x3D; item;\n        tail &#x3D; (tail + 1) % n;\n        return true;\n    &#125;\n    \n    public String dequeue()&#123;\n        if(head &#x3D;&#x3D; tail) return null;&#x2F;&#x2F;队列空，两个指针指向同一个位置\n        String ret &#x3D; items[head];&#x2F;&#x2F;head指向第一个元素\n        head &#x3D; (head + 1 ) % n;\n        return ret;\n    &#125;\n&#125;\n\n\n\n4.2.2 链表队列public class LinkedListQueue&#123;\n    private class Node&#123;\n        public String data;\n        public Node next;\n        public Node(String data,Node next)&#123;\n            this.data &#x3D; data;\n            this.next &#x3D; next;\n        &#125;\n    &#125;\n    private Node head &#x3D; null;\n    private Node tail &#x3D; null;\n    \n    public void enqueue(String value)&#123;\n        Node newNode &#x3D; new Node(value, null);\n        if(tail &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;空队列\n            head &#x3D; newNode;\n            tail &#x3D; newNode;\n        &#125;else&#123;\n            tail.next &#x3D; newNode;\n            tail &#x3D; newNode;\n        &#125;\n    &#125;\n    public String dequeue()&#123;\n        if(head &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;空队列\n            return null;\n        &#125;\n        String value &#x3D; head.data;\n        head &#x3D; head.next;\n        if(head &#x3D;&#x3D; null)&#123;\n            tail &#x3D;&#x3D; null;\n        &#125;\n        return value;\n    &#125;\n&#125;\n\n4.2.3经典应用\n在线程池等有限资源池中，当线程池已满，再请求时，如何处理\n非阻塞：直接拒绝\n阻塞：将请求排队等有空闲时再处理，用数组比用链表好\n\n\n\n4.3题型\n\n\n\n\n\n\n\n\n栈和队列处于平等地位，但在面试中，栈的出题量远多于队列，队列的题目很少\n4.3.1细分题型\n直接以栈为背景的题目：比如用栈实现队列、最小栈、栈排序\n连连消题目：字符串连连消、求表达式\n单调栈题目：栈延申出来的一种新的数据结构（不多，不怎么考，比较难）\n\n4.3.2例题\n\n\n剑指offer9.用两个栈实现队列\n225.用队列实现栈\n面试题03.05栈排序\n155.最小栈\n\n\n\n面试题03.01三合一\n20.有效的括号\n面试题16.26计算器\n772.基本计算器3\n\n\n1047删除字符串相邻重复项\n剑指offer31.栈的压入弹出序列\n739.每日温度\n42.接雨水\n\n\n84.柱状图中最大的矩形\n面试题03.06.动物收容所\n剑指59-2队列最大值\n剑指59-1滑动窗口最大值\n\n\n5.分治和递归5.1概念\n分治是一种思想，分而治之，具体到算法方面，就是将原问题划分成多个规模更小并且结构与原问题相同的子问题，先解决这些子问题，然后再合并其结果，就得到原问题的解。\n递归是一种编程技巧，一个函数自己调用自己。递归也具有结构相同，规模不同的特点，所以，涉及到用分治思想解决的问题，比较适合用递归来实现。\n\n==注：堆栈溢出常出现在工程中，解决方法：限制递归深度，或者改用非递归实现。==\n5.2重复计算问题如何解决\n运用备忘录：当有些全局变量需要定义的时候，我们可以在递归函数外侧嵌套一个非递归的壳。\n\nprivate int[] mem;\npublic int f(int n)&#123;\n    mem &#x3D; new int[n+1];\n    return f_r(n);\n&#125;\nprivate int f_r(int n)&#123;\n    if (n &#x3D;&#x3D; 1) return 1;\n    if (n &#x3D;&#x3D; 2) return 2;\n    if (mem[n] !&#x3D; 0) return mem[n];\n    mem[n] &#x3D; f_r(n-1) + f_r(n-2);\n    return mem[n];\n&#125;\n\n\n可以考虑是否可以用动态规划（DP）解决：回溯这类递归代码\n\n5.3编写递归代码的技巧\n怎么发现这个问题可以用递归来做：\n规模更小的问题，跟规模大点的问题，解决思路相同，但规模不同\n利用子问题的解可以组合得到原问题的解\n存在最小子问题，可以直接返回结果，即存在递归终止条件\n\n\n递归的正确编写姿势：\n我们可以假设子问题B,C已经解决，在此基础上思考如何解决原问题A，基于此，找递推公式+终止条件，然后翻译成代码\n\n\n\n==注：千万不要试图想清楚整个递和归的执行过程，实际上是进入了一个思维误区==\n\n时间复杂度和空间复杂度分析：\n时间复杂度：递推公式或者递归树\n空间复杂度：跟递归的函数调用栈最大深度成正比，即递归树的高度\n\n\n\n5.4题型\n解题技巧：寻找重复结构，是否能将问题结构转化成结构相同，规模更小的子问题，然后写递推公式，包括递归终止条件，然后翻译成代码。\n原问题解决思路和子问题解决思路是否一样\n子问题的解能否构造出原问题的解（递推公式）\n找到最小子问题（终止条件）\n\n\n\n6.排序6.1排序算法总览\nO（n^2）\n冒泡排序：一对对比较，一对对交换\n插入排序：分为已排和未排区间，取未排插入到已排。例：希尔排序\n选择排序：分为已排和未排区间，从未排选一个最小的插入到已排的\n希尔排序\n\n\nO（nlogn）\n归并排序：“分治思想”，分而治之，然后再合并\n快速排序：选一个pivot，大的放左，小的放右\n堆排序：先将数组原地建成一个堆，从下往上堆化，取堆顶元素，将下标n的元素放到堆顶，堆化\n二叉排序树排序\n\n\nO（n）\n计数排序：例：10G数据，100个桶\n基数排序：高考成绩排序，760个桶\n桶排序：10万个手机号码排序，从个位开始一位位进行桶或基数排序\n\n\n\n6.2排序算法细节####冒泡排序\n\n原理：整个冒泡排序包括多趟冒泡操作，每一趟冒泡操作都会遍历整个数组，依次对数组相邻的元素进行比较，看是否满足大小关系要求，如果不满足，就将他们互换位置，一趟冒泡至少一个元素移动到他应该在的位置，重复n次，就完成了n个数据的排序工作。\n代码实现\n\nvoid bubbleSort(int[] a,int n)&#123;\n    if(n &lt;&#x3D; 1) return;\n    for(int i &#x3D; 0; i &lt; n ; ++i)&#123;&#x2F;&#x2F;第几趟冒泡\n        boolean flag &#x3D; false;\n        for(int j &#x3D; 0; j &lt; n-i-1 ; ++j)&#123;\n            if(a[j] &gt; a[j+1])&#123;&#x2F;&#x2F;交换（相等不交换，所以是稳定的排序算法）\n                int temp &#x3D; a[j];\n                a[j] &#x3D; a[j+1];\n                a[j+1] &#x3D; temp;\n                flag &#x3D; true;\n            &#125;\n        &#125;\n        if(!flag) break;&#x2F;&#x2F;没有数据交换，提前结束\n    &#125;\n&#125;\n\n\n时间复杂度：O(n^2)，依靠顺序度和逆序度来求比较和交换操作的平均时间复杂度\n\n####插入排序\n\n\n\n\n\n\n\n\n\n==相等的不换：稳定的排序算法==\n\n原理：将数组分为两个区间（已排序，未排序），初始已排序区间只有一个元素，就是数组中的第一个元素，每次去未排序区间的元素，在已排序区间中找到合适的插入位置将其插入，保证已排序区间一直有序，重复直到未排序区间元素为空。\n\n代码实现\npublic static void insertionSort(int[] a, int n) &#123;\n        if (n &lt;&#x3D; 1) return;\n\n        for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n            int value &#x3D; a[i];\n            int j &#x3D; i - 1;\n            &#x2F;&#x2F; 查找要插入的位置并移动数据\n            for (; j &gt;&#x3D; 0; --j) &#123;\n                if (a[j] &gt; value) &#123;\n                    a[j + 1] &#x3D; a[j];\n                &#125; else &#123;\n                    break;\n                &#125;\n            &#125;\n            a[j + 1] &#x3D; value;\n        &#125;\n    &#125;\n\n\n时间复杂度：O(n^2)\n\n\n\n####选择排序\n\n原理：选择排序算法实现类似于插入排序，也将整个数组划分为已排序区间和未排序区间，不同点在于：选择排序算法每次从未排序区间中，找到最小的元素，将其放到已排序区间的末尾。\n代码：\n\npublic void selectionSort(int[] a,int n)&#123;\n    if(n &lt;&#x3D; 1) return;\n    for(int i &#x3D; 0; i &lt; n-1; ++i)&#123;\n        int minPos &#x3D; i;\n        for(int j &#x3D; i; j &lt; n; ++j)&#123;\n            if(a[j] &lt; a[minPos])&#123;&#x2F;&#x2F;非稳定算法，因为换了位置\n                minPos &#x3D; j;\n            &#125;\n        &#125;\n        int temp &#x3D; a[i];\n        a[i] &#x3D; a[minPos];\n        a[minPos] &#x3D; temp;\n    &#125;\n&#125;\n\n3.时间复杂度：O(n^2)\n归并排序\n\n\n\n\n\n\n\n\n==（重点）（稳定算法，merge有优先级）==\n\n原理：分治的思想，采用递归实现。如果要排序一个数组，先把数组从中间分成前后两部分，然后，对前后两部分分别排序，再将排序好的两部分合并在一起，这样整个数组就都有序了。\n代码：\n\npublic class MergeSort &#123;\n    \n  &#x2F;&#x2F; 归并排序算法, a是数组，n表示数组大小\n  public static void mergeSort(int[] a, int n) &#123;\n    mergeSortInternally(a, 0, n-1);\n  &#125;\n\n  &#x2F;&#x2F; 递归调用函数\n  private static void mergeSortInternally(int[] a, int p, int r) &#123;\n    &#x2F;&#x2F; 递归终止条件\n    if (p &gt;&#x3D; r) return;\n\n    &#x2F;&#x2F; 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值\n    int q &#x3D; p + (r - p)&#x2F;2;\n    &#x2F;&#x2F; 分治递归\n    mergeSortInternally(a, p, q);\n    mergeSortInternally(a, q+1, r);\n\n    &#x2F;&#x2F; 将A[p...q]和A[q+1...r]合并为A[p...r]\n    merge(a, p, q, r);\n  &#125;\n\n  private static void merge(int[] a, int p, int q, int r) &#123;\n    int i &#x3D; p;\n    int j &#x3D; q+1;\n    int k &#x3D; 0; &#x2F;&#x2F; 初始化变量i, j, k\n    int[] tmp &#x3D; new int[r-p+1]; &#x2F;&#x2F; 申请一个大小跟a[p...r]一样的临时数组\n    while (i&lt;&#x3D;q &amp;&amp; j&lt;&#x3D;r) &#123;\n      if (a[i] &lt;&#x3D; a[j]) &#123;\n        tmp[k++] &#x3D; a[i++]; &#x2F;&#x2F; i++等于i:&#x3D;i+1\n      &#125; else &#123;\n        tmp[k++] &#x3D; a[j++];\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 判断哪个子数组中有剩余的数据\n    int start &#x3D; i;\n    int end &#x3D; q;\n    if (j &lt;&#x3D; r) &#123;\n      start &#x3D; j;\n      end &#x3D; r;\n    &#125;\n\n    &#x2F;&#x2F; 将剩余的数据拷贝到临时数组tmp\n    while (start &lt;&#x3D; end) &#123;\n      tmp[k++] &#x3D; a[start++];\n    &#125;\n\n    &#x2F;&#x2F; 将tmp中的数组拷贝回a[p...r]\n    for (i &#x3D; 0; i &lt;&#x3D; r-p; ++i) &#123;\n      a[p+i] &#x3D; tmp[i];\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * 合并(哨兵)\n   *&#x2F;\n  private static void mergeBySentry(int[] arr, int p, int q, int r) &#123;\n    int[] leftArr &#x3D; new int[q - p + 2];\n    int[] rightArr &#x3D; new int[r - q + 1];\n\n    for (int i &#x3D; 0; i &lt;&#x3D; q - p; i++) &#123;\n      leftArr[i] &#x3D; arr[p + i];\n    &#125;\n    &#x2F;&#x2F; 第一个数组添加哨兵（最大值）\n    leftArr[q - p + 1] &#x3D; Integer.MAX_VALUE;\n\n    for (int i &#x3D; 0; i &lt; r - q; i++) &#123;\n      rightArr[i] &#x3D; arr[q + 1 + i];\n    &#125;\n    &#x2F;&#x2F; 第二个数组添加哨兵（最大值）\n    rightArr[r-q] &#x3D; Integer.MAX_VALUE;\n\n    int i &#x3D; 0;\n    int j &#x3D; 0;\n    int k &#x3D; p;\n    while (k &lt;&#x3D; r) &#123;\n      &#x2F;&#x2F; 当左边数组到达哨兵值时，i不再增加，直到右边数组读取完剩余值，同理右边数组也一样\n      if (leftArr[i] &lt;&#x3D; rightArr[j]) &#123;\n        arr[k++] &#x3D; leftArr[i++];\n      &#125; else &#123;\n        arr[k++] &#x3D; rightArr[j++];\n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n\n时间复杂度分析：\n递推公式：T(n) = T(n/2) + T(n/2) +n 和 T(1) = C\n递归树：O（nlogn）每层和为n个数据，一共log2n层\n\n\n\n快速排序（重点）\n原理：先找pivot，再按pivot划分，依靠分治思想进行继续对前后两部分进行划分并排序。\n代码：\n\npublic class QuickSort &#123;\n\n  &#x2F;&#x2F; 快速排序，a是数组，n表示数组的大小\n  public static void quickSort(int[] a, int n) &#123;\n    quickSortInternally(a, 0, n-1);\n  &#125;\n\n  &#x2F;&#x2F; 快速排序递归函数，p,r为下标\n  private static void quickSortInternally(int[] a, int p, int r) &#123;\n    if (p &gt;&#x3D; r) return;\n\n    int q &#x3D; partition(a, p, r); &#x2F;&#x2F; 获取分区点\n    quickSortInternally(a, p, q-1);\n    quickSortInternally(a, q+1, r);\n  &#125;\n\n  private static int partition(int[] a, int p, int r) &#123;\n    int pivot &#x3D; a[r];\n    int i &#x3D; p;\n    for(int j &#x3D; p; j &lt; r; ++j) &#123;\n      if (a[j] &lt; pivot) &#123;\n        if (i &#x3D;&#x3D; j) &#123;\n          ++i;\n        &#125; else &#123;\n          int tmp &#x3D; a[i];\n          a[i++] &#x3D; a[j];\n          a[j] &#x3D; tmp;\n        &#125;\n      &#125;\n    &#125;\n\n    int tmp &#x3D; a[i];\n    a[i] &#x3D; a[r];\n    a[r] &#x3D; tmp;\n\n    System.out.println(&quot;i&#x3D;&quot; + i);\n    return i;\n  &#125;\n&#125;\n\n\n桶排序（海量数据处理）\n\n计数排序（没什么用）\n\n基数排序（排序算法的稳定性）：多种指标按优先级排序\n\n\n6.3题型\n特殊排序：不是单纯的增减顺序，而是有一些特殊要求\nTop K：找到前K个大的，第K个大的……\n链表上的排序：数据结构由数组转换为链表，并进行排序\n排序预处理：排序只是问题的一部分预处理，可以运用库函数\n区间问题：（252题、56题） 先排序，再处理\n\n7.二分查找\n\n\n\n\n\n\n\n\n针对一个有序的数据集合，查找思想类似于分治，每次通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到要查找的元素或区间被缩小为0。局限：要是数组组织的有序数据，数据量不能过大也不能过小\n7.1原理​    又叫折半查找，在有序数组中快速查找元素，找中值比较，选择前或后某一部分，继续进行二分查找\n7.1.1其它查找\nB树、B+树\n\n定义：m叉树m个分支m-1个关键字；若根不是终端则至少两颗子树；除根节点外所有非叶至少m/2上取整颗子树\nB树不支持顺序查找，B+树支持顺序查找\nB树删除：兄弟够借（&gt;=2）就左旋借一圈；左右兄弟都不够借，父节点下来一个跟兄弟合并\n\n\nHash查找\n\n开放地址法（探测到表尾从表头起）&amp;拉链法\n线性探测：+K；= 线形探测再散列\n二次探测：冲突时按+1、-1、+4、-4、+9、-9\n如果m=13，ASL成功：除表中数据个数；ASL失败：除能映射到的地址个数！！！\n开放地址法删除：只做标记，不删除\n装填因子：表中记录数/散列表长度\n\n\n\n7.2代码实现public class BinarySearch &#123;\n\n    &#x2F;**\n     * 搜索区间：闭区间\n     * 循环结束条件：low &lt;&#x3D; high\n     * 更新：low，high\n     * 返回值：mid\n     * @param a\n     * @param n\n     * @param value\n     * @return\n     *&#x2F;\n    public int BiSearch(int[] a, int n, int value) &#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        while (low &lt;&#x3D; high) &#123;\n            int mid &#x3D; ( low + high ) &#x2F; 2;\n            if (a[mid] &#x3D;&#x3D; value)&#123;\n                return mid;\n            &#125;else if (a[mid] &lt; value) &#123;\n                low &#x3D; mid - 1;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n    &#x2F;**\n     * \n     * @param a\n     * @param n\n     * @param value\n     * @return\n     *&#x2F;\n    public int BiSearchRecur(int[] a, int n, int value) &#123;\n        return BiSearchRecur(a,0,n-1,value);\n    &#125;\n    public int BiSearchRecur(int[] a, int low, int high, int value)&#123;\n        if (low &gt; high) &#123;\n            return -1;\n        &#125;\n        int mid &#x3D; (low + high) &#x2F; 2;\n        if (a[mid] &#x3D;&#x3D; value)&#123;\n            return mid;\n        &#125;else if (a[mid] &lt; value)&#123;\n            return BiSearchRecur(a,mid+1, high, value);\n        &#125;else &#123;\n            return BiSearchRecur(a, low, mid-1, value);\n        &#125;\n    &#125;\n&#125;\n\n7.3复杂度分析\n时间复杂度：\n递推公式：T(n) = T(n/2) + C\n递归树：O(logn)\n\n\n\n7.4题型\n\n\n\n\n\n\n\n\n重点题型，大部分都是变形二分查找或二分答案，代码不长，但容易写对。难点在于：确定搜索区间，循环条件，区间更新，返回值。\n7.4.1解题技巧\n查找区间永远是闭区间[low,high]\n循环条件永远是：low &lt;= high\n对于low == high的情况，必要的时候特殊处理，在while内部补充退出条件\n返回值永远是mid，而不是low，high\nlow、high的更新永远是low = mid + 1和high = mid - 1\n对于非确定性查找，使用前后探测法，来确定搜索区间（不用while，而只更新low或high）\n先处理命中情况，再处理在左右半部分查找的情况\n\n==注：非确定查找：第一个、最后一个、第一个大于等于、最后一个小于等于、循环数组寻找最小值、寻找峰值==\n7.4.2题型例题一：查找第一个等于x，最后一个等于x的元素\npublic int BiSearch(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &#x3D;&#x3D; target) &#123;\n                \n                &#x2F;&#x2F;第一个等于\n                if (mid &#x3D;&#x3D; 0 || a[mid-1] !&#x3D; target) &#123; return mid;&#125;\n                else &#123;high &#x3D; mid - 1;&#125;\n                \n                &#x2F;&#x2F;最后一个等于\n&#x2F;&#x2F;                    if (mid &#x3D;&#x3D; n - 1  || a[mid+1] !&#x3D; target) &#123; return mid; &#125;\n&#x2F;&#x2F;                    else &#123; low &#x3D; mid + 1; &#125;\n                \n            &#125;else if (a[mid] &lt; target)&#123;\n                low &#x3D; mid + 1;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n\n\n例题二：查找第一个大于等于x，最后一个小于等于x的元素\npublic int BiSearch(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &gt;&#x3D; target)&#123;\n                if (mid &#x3D;&#x3D; 0 || a[mid-1] &lt; target)&#123;\n                     return mid;\n                &#125;else &#123;\n                    high &#x3D; mid - 1;\n                &#125;\n            &#125;else &#123;\n                low &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\npublic int BiSearch2(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &lt;&#x3D; target)&#123;\n                if (mid &#x3D;&#x3D; n-1 || a[mid+1] &gt; target)&#123;\n                     return mid;\n                &#125;else &#123;\n                    low &#x3D; mid + 1;\n                &#125;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n\n\n例题三：循环有序数组中查找元素x（33题无重复，81题有重复）\npublic int BiSearch(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &#x3D;&#x3D; target) &#123;\n                return mid;\n            &#125;else if (a[low] &lt;&#x3D; a[mid]) &#123; &#x2F;&#x2F;左有序\n                if (a[low] &lt;&#x3D; target &amp;&amp; target &lt; a[mid])&#123;\n                    high &#x3D; mid -1;\n                &#125;else &#123;\n                    low &#x3D; mid + 1;\n                &#125;\n            &#125;else &#123;\n                if ( a[mid] &lt; target &amp;&amp; a[mid] &lt;&#x3D; a[high])&#123;\n                    low &#x3D; mid + 1;\n                &#125;else &#123;\n                    high &#x3D; mid - 1;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n\n\n例题四：循环有序数组中查找最小元素（153题无重复，154题有重复）\npublic int BiSearch(int[] a, int n)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (low &#x3D;&#x3D; high)&#123;\n                return mid;\n            &#125;\n            if ((mid &#x3D;&#x3D; 0 &amp;&amp; a[mid] &lt; a[high]) \n                    ||(mid !&#x3D; 0 &amp;&amp; a[mid-1] &gt; a[mid]))&#123;\n                return mid;\n            &#125;else if (a[mid] &gt; a[high])&#123;&#x2F;&#x2F;右循环有序\n                low &#x3D; mid + 1;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n\n\n例题五：查找峰值（852题）\npublic int BiSearch(int[] a, int n)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (mid &#x3D;&#x3D; 0)&#123;\n                low &#x3D; mid + 1;\n            &#125;else if (mid &#x3D;&#x3D; n-1)&#123;\n                high &#x3D; mid - 1;\n            &#125;else if (a[mid] &gt; a[mid-1] &amp;&amp; a[mid] &gt; a[mid+1])&#123;\n                return mid;\n            &#125;else if (a[mid] &gt; a[mid-1])&#123;\n                low &#x3D; mid + 1;\n            &#125;else &#123;\n                high &#x3D; mid -1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\t\n\n\n\n例题六：二分答案（69题）\n8.哈希表\n\n\n\n\n\n\n\n\n散列表用的就是数组支持O（1）的随机访问特性，通过散列函数把元素的健值映射为下标，然后将数据存储在数组对应下标的位置。工业级散列表（Java中的HashMap源代码）\n8.1基础知识\n概念：==查找、tong’ji==\n\n哈希冲突解决办法：\n\n链表法：链表、红黑树、跳表\n开放寻址法：线性探测、二次探测、双重哈希\n\n\n动态扩容：\n\n因为哈希冲突的存在，哈希表的性能会因为装入数据的个数增加而降低，所以当哈希表性能下降到一定程度之后，就会触发扩容。其中这个参考指标称为装载因子（数据个数 / 槽的个数）。\n当达到阈值时，可以申请一个更大的哈希表，并将原哈希表数据重新计算hash值并搬移到新的哈希表（可以均摊到之后每次新数据插入操作，来避免集中扩容）。\n\n\nJava中的HashMap和HashSet：Map和Set为业务意义，其中Map意味着键值对(key,value)，Set意味着键(key)的无重复集合，并且两者都是对哈希表的封装\n\nHash查找\n\n开放地址法（探测到表尾从表头起）&amp;拉链法\n线性探测：+K；= 线形探测再散列\n二次探测：冲突时按+1、-1、+4、-4、+9、-9\n如果m=13，ASL成功：除表中数据个数；ASL失败：除能映射到的地址个数！！！\n开放地址法删除：只做标记，不删除\n装填因子：表中记录数/散列表长度\n\n\n\n8.2哈希表的扩展\n位图：\npublic class BiMap &#123;\n    private char[] a;\n    private int nBits;\n\n    public BiMap(int nBits)&#123;\n        this.nBits &#x3D; nBits;\n        this.a &#x3D; new char[(nBits-1)&#x2F;16+1];\n    &#125;\n    public void set(int k)&#123;\n        if (k&gt;nBits) &#123;\n            return;\n        &#125;\n        int charIndex &#x3D; k &#x2F; 16;\n        int biIndex &#x3D; k % 16;\n        a[charIndex] |&#x3D; (1 &lt;&lt; biIndex);\n    &#125;\n    public boolean get(int k)&#123;\n        if (k &gt; nBits) &#123;\n            return false;\n        &#125;\n        int charIndex &#x3D; k &#x2F; 16;\n        int biIndex &#x3D; k % 16;\n        return ( a[charIndex] &amp; (1 &lt;&lt; biIndex) ) !&#x3D; 0;\n    &#125;\n&#125;\n布隆过滤器：类似于位图，但空间不是一一对应，而是多个数据会共用同一个位，这样当位为true时，该数据可能存在，但当位为false时，该数据一定不存在，可以减少数据读取所耗时。\n\nLRU缓存：缓存主要包含3个操作：在缓存中查找一个数据；从缓存中删除一个数据；往缓存中添加一个数据（基于哈希表来快速查找，双向有序链表维护数据有序性的实现方案）\npackage main.java;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LRUCache &#123;\n    private class DLinkedNode&#123;\n        private int key;\n        private int value;\n        public DLinkedNode prev;\n        public DLinkedNode next;\n        public DLinkedNode(int key, int value)&#123;\n            this.key &#x3D; key;\n            this.value &#x3D; value;\n        &#125;\n    &#125;\n    private Map&lt;Integer,DLinkedNode&gt; hashtable &#x3D; new HashMap&lt;Integer, DLinkedNode&gt;();\n    private int size;\n    private int capacity;\n    private DLinkedNode head;\n    private DLinkedNode tail;\n\n    public LRUCache(int capacity) &#123;\n        this.size &#x3D; 0;\n        this.capacity &#x3D; capacity;\n        this.head &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.tail &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.head.prev &#x3D; null;\n        this.head.next &#x3D; tail;\n        this.tail.prev &#x3D; head;\n        this.tail.next &#x3D; null;\n    &#125;\n\n    public int get(int key)&#123; &#x2F;&#x2F;在缓存中查找数据\n        if (size &#x3D;&#x3D; 0)&#123;\n            return -1;\n        &#125;\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node &#x3D;&#x3D; null)&#123;\n            return -1;\n        &#125;\n        removeNode(node);\n        addNodeAtHead(node);\n        return node.value;\n    &#125;\n\n    public void remove(int key)&#123; &#x2F;&#x2F;从缓存中删除数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            removeNode(node);\n            hashtable.remove(key);\n        &#125;\n    &#125;\n\n    private void addNodeAtHead(DLinkedNode node) &#123;\n        node.next &#x3D; head.next;\n        head.next.prev &#x3D; node;\n        head.next &#x3D; node;\n        node.prev &#x3D; head;\n    &#125;\n\n    private void removeNode(DLinkedNode node) &#123;&#x2F;&#x2F;特殊情况（删除尾节点、删除最后一个节点））\n        node.next.prev &#x3D; node.prev;\n        node.prev.next &#x3D; node.next;\n    &#125;\n\n    public void put(int key, int value)&#123;&#x2F;&#x2F;往缓存中添加一个数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            node.value &#x3D; value;\n            removeNode(node);\n            addNodeAtHead(node);\n        &#125;\n        if (size &#x3D;&#x3D; capacity)&#123;\n            hashtable.remove(tail.prev.key);\n            removeNode(tail.prev);\n            size--;\n        &#125;\n        DLinkedNode newNode &#x3D; new DLinkedNode(key,value);\n        addNodeAtHead(newNode);\n        hashtable.put(key, newNode);\n        size++;\n    &#125;\n&#125;\n\n8.3题型\n\n\n\n\n\n\n\n\n重点，但题不难，只是一个配角为了提高查找效率，大部分可以直接使用编程语言现有的实现类\n纯粹考察哈希表的题目不难，也不多。大部分情况下，哈希表只不过是一个小配角，配合解决其他算法类型的题目。用到哈希表的场景也比较明确，就是为了提高查找效率，让查找的时间复杂度降为O(1)，\n例题：LRU缓存\n9.二叉树9.1二叉树的前中后序遍历\n递归\n\npublic void preOrder(Node root)&#123;\n    if(root &#x3D;&#x3D; null) return;\n    System.out.println(root.data);\n    preOrder(root.left);\n    preOrder(root.right);\n&#125; \npublic void inOrder(Node root)&#123;\n    if(root &#x3D;&#x3D; null) return;\n    inOrder(root.left);\n    System.out.println(root.data);\n    inOrder(root.right);\n&#125;\npublic void postOrder(Node root)&#123;\n    if(root &#x3D;&#x3D; null) return;\n    postOrder(root.left);\n    postOrder(root.right);\n    System.out.println(root.data);\n&#125;\n\n\n\n非递归\n\nclass Solution &#123;\n        private class TreeNode &#123;\n            int val;\n            TreeNode left;\n            TreeNode right;\n            TreeNode(int x) &#123;\n                val &#x3D; x;\n            &#125;\n        &#125;\n        private class SFrame&#123;\n            public int status &#x3D; 1;\n            public TreeNode node &#x3D; null;\n            public SFrame(int status,TreeNode node)&#123;\n                this.status &#x3D; status;\n                this.node &#x3D; node;\n            &#125;\n        &#125;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        public List&lt;Integer&gt; preOrderTraversal(TreeNode root)&#123;\n            if (root &#x3D;&#x3D; null)&#123;\n                return result;\n            &#125;\n            Stack&lt;SFrame&gt; stack &#x3D; new Stack&lt;&gt;();\n            stack.push(new SFrame(1,root));\n            while (!stack.isEmpty())&#123;\n                if (stack.peek().status &#x3D;&#x3D; 1)&#123;\n                    result.add(stack.peek().node.val);&#x2F;&#x2F;前序\n                    stack.peek().status &#x3D; 2;\n                    if (stack.peek().node.left !&#x3D; null)&#123;\n                        stack.push(new SFrame(1,stack.peek().node.left));\n                    &#125;\n                    continue;\n                &#125;\n                if (stack.peek().status &#x3D;&#x3D; 2)&#123;\n&#x2F;&#x2F;                    result.add(stack.peek().node.val);&#x2F;&#x2F;中序\n                    stack.peek().status &#x3D; 3;\n                    if (stack.peek().node.right !&#x3D; null)&#123;\n                        stack.push(new SFrame(1,stack.peek().node.right));\n                    &#125;\n                    continue;\n                &#125;\n                if (stack.peek().status &#x3D;&#x3D; 3)&#123;\n&#x2F;&#x2F;                    result.add(stack.peek().node.val);&#x2F;&#x2F;后序\n                    stack.pop();\n                &#125;\n            &#125;\n            return result;\n        &#125;\n    &#125;\n\n\n\n\n层次遍历\n\n&#x2F;&#x2F;层次遍历（链队列）\n&#x2F;&#x2F;层次遍历易于找到某节点的父节点\nclass Solution &#123;\n        private class TreeNode &#123;\n            int val;\n            TreeNode left;\n            TreeNode right;\n            TreeNode(int x) &#123;\n                val &#x3D; x;\n            &#125;\n        &#125;\n        private List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;\n            dfs(root,0);\n            return result;\n        &#125;\n        private void dfs(TreeNode root,int level)&#123;\n            if (root &#x3D;&#x3D; null)&#123;\n                return;\n            &#125;\n            if(level &gt; result.size()-1)&#123;\n                result.add(new ArrayList&lt;&gt;());\n            &#125;\n            result.get(level).add(root.val);\n            dfs(root.left,level+1);\n            dfs(root.right,level+1);\n        &#125;\n    &#125;\n\n&#x2F;&#x2F;求高度（非递归层次遍历）\nint Btdepth(BiTree T)&#123;\n    if（!T)\n        return 0;\n    int front&#x3D;-1,rear&#x3D;-1;\n    int last&#x3D;0,level&#x3D;0;\n    BiTree Q[MaxSize];&#x2F;&#x2F;线形队列\n    Q[++rear] &#x3D; T;\n    BiTree p;\n    while(front&lt;rear)&#123;\n        p&#x3D;Q[++front];\n        if(p-&gt;lchild)\n            Q[++rear]&#x3D;p-&gt;lchild;\n        if(p-&gt;rchild)\n            Q[++rear]&#x3D;p-&gt;rchild;\n        if(front&#x3D;&#x3D;last)&#123;\n            level++;\n            last&#x3D;rear;&#x2F;&#x2F;下一层最右端节点\n        &#125;\n    &#125;\n    return level;\n&#125;\n\n&#x2F;&#x2F;求层数（递归）\nint depth(BiTree T,int level)&#123;\n    if(T)&#123;\n        if(T-&gt;lchild)\n            depth(T-&gt;lchild,++level);\n            level—-;\n        if(T-&gt;rchild)\n            depth(T-&gt;rchild,++level);\n            level—-;\n    &#125;\n    &#x2F;&#x2F;level初值为0，此时level即为层数\n&#125;\n\n\n\n\n9.2二叉查找树(BST)的查找，插入，删除\n\n\n\n\n\n\n\n\n二叉查找树中序遍历结果有序，是从小到大的排列\nimport java.util.TreeSet;\n\npublic class BST &#123;\n\n    public static class Node &#123;\n        private int data;\n        private Node left;\n        private Node right;\n\n        public Node(int data) &#123;\n            this.data &#x3D; data;\n            left &#x3D; null;\n            right &#x3D; null;\n        &#125;\n    &#125;\n\n    public void insertReverse(Node root, int data) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            root &#x3D; new Node(data);\n            return;\n        &#125;\n        insert_r(root, data);\n    &#125;\n\n    public void insert_r(Node root, int data) &#123;\n        if (data &gt; root.data) &#123;\n            if (root.right &#x3D;&#x3D; null) &#123;\n                root.right &#x3D; new Node(data);\n            &#125; else &#123;\n                insert_r(root.right, data);\n            &#125;\n        &#125; else &#123;\n            if (root.left &#x3D;&#x3D; null) &#123;\n                root.left &#x3D; new Node(data);\n            &#125; else &#123;\n                insert_r(root.left, data);\n            &#125;\n        &#125;\n    &#125;\n\n    public void insert(Node root, int data) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            root &#x3D; new Node(data);\n            return;\n        &#125;\n        Node p &#x3D; root;\n        while (p !&#x3D; null) &#123;\n            if (data &gt; p.data) &#123;\n                if (p.right &#x3D;&#x3D; null) &#123;\n                    p.right &#x3D; new Node(data);\n                    return;\n                &#125;\n                p &#x3D; p.right;\n            &#125; else &#123;\n                if (p.left &#x3D;&#x3D; null) &#123;\n                    p.left &#x3D; new Node(data);\n                    return;\n                &#125;\n                p &#x3D; p.left;\n            &#125;\n        &#125;\n    &#125;\n\n    public Node find_r(Node root, int data) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        if (root.data &#x3D;&#x3D; data) &#123;\n            return root;\n        &#125;\n        if (root.data &gt; data) &#123;\n            return find_r(root.left, data);\n        &#125; else &#123;\n            return find_r(root.right, data);\n        &#125;\n    &#125;\n\n    public Node find(Node root, int data) &#123;\n        Node p &#x3D; root;\n        while (p !&#x3D; null) &#123;\n            if (p.data &gt; data)&#123;\n                p &#x3D; p.left;\n            &#125;else if (p.data &lt; data)&#123;\n                p &#x3D; p.right;\n            &#125;else &#123;\n                return p;\n            &#125;\n        &#125;\n        return null;\n    &#125;\n\n    public void delete(Node root,int data)&#123;\n        Node p &#x3D; root;\n        Node pp &#x3D; null;\n        while (p !&#x3D; null &amp;&amp; p.data !&#x3D; data)&#123;&#x2F;&#x2F;找到要删除的节点和其父节点\n            pp &#x3D; p;\n            if (data &gt; p.data)&#123;\n                p &#x3D; p.right;\n            &#125;\n            else &#123;\n                p &#x3D; p.left;\n            &#125;\n        &#125;\n        if (p &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        if (p.left !&#x3D; null &amp;&amp; p.right !&#x3D; null)&#123;&#x2F;&#x2F;两个子节点\n            Node minP &#x3D; p.right;\n            Node minPP &#x3D; p;\n            while (minP.left !&#x3D; null)&#123;\n                minPP &#x3D; minP;\n                minP &#x3D; minP.left;\n            &#125;\n            p.data &#x3D; minP.data;\n            p &#x3D; minP;\n            pp &#x3D; minPP;\n        &#125;\n        Node child &#x3D; null;&#x2F;&#x2F;查找删除节点的子节点\n        if (p.left !&#x3D; null)&#123;\n            child &#x3D; p.left;\n        &#125;else if (p.right !&#x3D; null)&#123;\n            child &#x3D; p.right;\n        &#125;\n\n        if (pp &#x3D;&#x3D; null)&#123;\n            root &#x3D; child;&#x2F;&#x2F;删除的是根节点\n        &#125;else if (pp.left &#x3D;&#x3D; p)&#123;\n            pp.left &#x3D; child;\n        &#125;else &#123;\n            pp.right &#x3D; child;\n        &#125;\n    &#125;\n&#125;\n\nvoid JudgeAVL(BiTree bt,int &amp;balance,int &amp;h)&#123;\n    int bl&#x3D;0,br&#x3D;0,hl&#x3D;0,hr&#x3D;0;\n    if(btNULL)&#123;\n        h&#x3D;0;\n        balance&#x3D;1;\n    &#125;\n    else if(bt-&gt;lchildNULL&amp;&amp;bt-&gt;rchild&#x3D;&#x3D;NULL)&#123;\n        h&#x3D;1;\n        balance&#x3D;1;\n    &#125;\n    else&#123;\n        JudgeAVL(bt-&gt;lchild,bl,hl);\n        JudgeAVL(bt-&gt;rchild,br,hr);\n        h&#x3D;(hl&gt;hr?hl:hr)+1;\n        if(abs(hl-hr)&lt;2)&#x2F;&#x2F;本层平衡\n            balance&#x3D;bl&amp;&amp;br;&#x2F;&#x2F;子树平衡\n        else\n            balance&#x3D;0;\n    &#125;\n&#125;\n\n\n\n9.3平衡二叉查找树BBST，平衡二叉树AVL9.4Java中的TreeMap，TreeSet9.5B树、B+树\n定义：m叉树m个分支m-1个关键字；若根不是终端则至少两颗子树；除根节点外所有非叶至少m/2上取整颗子树\nB树不支持顺序查找，B+树支持顺序查找\nB树删除：兄弟够借（&gt;=2）就左旋借一圈；左右兄弟都不够借，父节点下来一个跟兄弟合并\n\n9.6线索二叉树typedef struct ThreadNode&#123;\n    ElemType data;\n    struct ThreadNode *lchild, *rchild;\n    int ltag,rtag;&#x2F;&#x2F;0为左孩子，1为前驱\n&#125;ThreadNode,*ThreadTree;\n&#x2F;&#x2F;左指前、右指后\n&#x2F;&#x2F;可以更方便地得到节点在遍历中的前驱和后继&#96;&#96;&#96;\n&#x2F;&#x2F;二叉树中序线索化\n&#x2F;&#x2F;可以在线索链表上也添加一个头节点：左指根，右指中序尾，中序第一个和最后一个都指向头节点。（双向线索链表）\nvoid InThread(ThreadTree &amp;p,ThreadTre &amp;pre)&#123;&#x2F;&#x2F;线索指向上一层\n    if(p!&#x3D;NULL)&#123;\n        InThread(p-&gt;lchild,pre);\n        if(p-&gt;lchild &#x3D;&#x3D; NULL)&#123;\n            p-&gt;lchild&#x3D;pre;\n            p-&gt;ltag&#x3D;1;\n        &#125;\n        if(pre!&#x3D;NULL&amp;&amp;pre-&gt;rchild&#x3D;&#x3D;NULL)&#123;\n            pre-&gt;rchild&#x3D;p;\n            pre-&gt;rtag&#x3D;1;\n        &#125;\n        pre&#x3D;p;\n        Inthread(p-&gt;rchild,pre);\n            &#x2F;&#x2F;先序线索化(p的左指针被改过)\n    &#x2F;&#x2F;if(0&#x3D;&#x3D;p-&gt;ltag) PreThread(p-&gt;lchild);\n    &#x2F;&#x2F;if(0&#x3D;&#x3D;p-&gt;rtag) PreThread(p-&gt;rchild);\n&#125;\n    &#125;\nvoid CreateInThread(ThreadTree T)&#123;\n    ThreadTree pre&#x3D;NULL;\n    if(T!&#x3D;NULL)&#123;\n        InThread(T,pre);\n        pre-&gt;rchild&#x3D;NULL;\n        pre-&gt;rtag&#x3D;1;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;线索二叉树遍历\nvoid Preorder(ThreadTree T)&#123;\n    ThreadNode *p &#x3D; T;\n    while(p!&#x3D;null)&#123;\n        while(p-&gt;ltag &#x3D;&#x3D; 0)&#123;\n            visit (p);\n            p&#x3D;p-&gt;lchild;\n        &#125;\n        visit(p)\n        p&#x3D;p-&gt;rchild;\n    &#125;\n&#125;\n\nThreadNode *getFirstNode(ThreadTree T)&#123;\n    ThreadNode *p&#x3D;T;\n    while(p-&gt;ltag &#x3D;&#x3D; 0)&#123;\n        p&#x3D;p-&gt;lchild;\n    &#125;\n    return p;&#x2F;&#x2F;返回最左下的节点\n&#125;\nThreadNode *getSuccessor(ThreadTree T)&#123;\n    ThreadNode *p&#x3D;T:\n    if(p-&gt;ltag&#x3D;&#x3D;0)\n        return(getFirstNode(p-&gt;lchild));\n    else\n        return p-&gt;rchild;\n&#125;\nvoid Inorder(ThreadTree T)&#123;\n    ThreadNode *p &#x3D;T;\n    while(p!&#x3D;null)&#123;\n        visit(p);\n        p&#x3D;getSuccessor(p);\n    &#125;\n&#125;\n\nvoid PostOrder(ThreadTree T)&#123;\n    ThreadNode *p&#x3D;T;\n    ThreadNode pre&#x3D;null;\n    while(null !&#x3D; p)&#123;\n        while(pre!&#x3D;p-&gt;lchild &amp;&amp; 0p-&gt;ltag)&#x2F;&#x2F;往左下找\n            p&#x3D;p-&gt;lchild;\n        while(null!&#x3D;p&amp;&amp;1p-&gt;rtag)&#123;&#x2F;&#x2F;开始访问\n            visit(p);\n            pre&#x3D;p;\n            p&#x3D;pre-&gt;rchild;\n        &#125;\n        if(T &#x3D;&#x3D; p)\n            visit(p);\n            p&#x3D;null;\n        while(null!&#x3D;p&amp;&amp;p-&gt;rchildpre)&#123;\n            visit(p);\n            pre&#x3D;p;\n            p&#x3D;p-&gt;parent;\n        &#125;\n        if(p!&#x3D;null&amp;&amp;p-&gt;rtag0)&#123;\n            p&#x3D;p-&gt;rchild;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;找左，访问，定根，找根，找右\n&#x2F;\n中序可找前可找后、先序可找后（找前需parent）、后序可找前（找后需parent，且注意根无后继）遍历需栈\n先找到序列中的第一个节点，然后依次找节点后继，直至其后继为空\n中序线索二叉树（左根右）找后继：若rtag&#x3D;1，p&#x3D;p-rchild（没有右子树）;否则遍历右子树中第一个访问的节点（右子树最左下的节点）。\n先序线索二叉树（根左右）找后继：如果有左孩子，左孩子为其后继；如果没左孩子但有右孩子，则右孩子为其后继；如果是叶节点，则右链域直接指示其后继。\n后续线索二叉树（左右根）找后继：1.若为根，则后继为空；2.若是双亲右孩子，或是双亲左孩子且双亲没有右子树，则其后继为双亲；3.若节点是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树按后序遍历列出的第一个节点。\n*&#x2F;\n\n&#x2F;&#x2F;先序遍历中序线索二叉树\nvoid PreOrderTraverse (ThreadTree)&#123;\n    ThreadNode *p &#x3D; T;\n    while(NULL!&#x3D;p)&#123;\n        while(0p-&gt;lTag)&#123;\n            Visit(P);\n            p&#x3D;p-&gt;lchild;\n        &#125;\n        while(1p-&gt;rchild)&#123;\n            p&#x3D;p-&gt;rchild;\n        &#125;\n        p&#x3D;p-&gt;rchild; \n    &#125;\n&#125;&#96;&#96;&#96;\n\n\n\n\n9.7题型套路\n二叉树前中后序遍历\n二叉树按层遍历\n二叉树上的递归\n二叉查找树\nLCA最近公共祖先（学会用递归实现！ ）\n二叉树转单，双，循环链表\n按照遍历结果反向构建二叉树\n二叉树上的最长路径和\n\n10.堆(使用优先级队列)10.1堆\n堆是完全二叉树，分为大顶堆，小顶堆\n自上而下堆化，自下而上堆化\n操作：往堆中插入数据，取堆顶元素，删除堆顶元素，更新元素值\n\npackage Week1;\n\n&#x2F;**\n * @author 10640\n *&#x2F;\npublic class Heap &#123;\n    private int a[];\n    private int n;\n    private int count;\n\n    public Heap(int capacity) &#123;\n        a &#x3D; new int[capacity];\n        n &#x3D; capacity;\n        count &#x3D; 0;\n    &#125;\n\n    public void insert(int data) &#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            return;\n        &#125;\n        ++count;\n        a[count] &#x3D; data;\n        int i &#x3D; count;\n\n        &#x2F;&#x2F;从下往上堆化\n        while (i &#x2F; 2 !&#x3D; 0 &amp;&amp; a[i] &gt; a[i &#x2F; 2]) &#123;\n            swap(a, i, i &#x2F; 2);\n            i &#x3D; i &#x2F; 2;\n        &#125;\n    &#125;\n\n    private void swap(int[] a, int i, int j) &#123;\n        int temp &#x3D; a[i];\n        a[j] &#x3D; a[i];\n        a[i] &#x3D; temp;\n    &#125;\n\n    public void removeTop() &#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            return;\n        &#125;\n        a[1] &#x3D; a[count];\n        --count;\n        heapify(a, count, 1);\n    &#125;\n\n    private void heapify(int[] a, int n, int i) &#123;\n        while (true) &#123;\n            int maxPos &#x3D; i;\n            if (i * 2 &lt;&#x3D; n &amp;&amp; a[i] &lt; a[i * 2]) &#123;\n                maxPos &#x3D; i * 2;\n            &#125;\n            if (i * 2 + 1 &lt;&#x3D; n &amp;&amp; a[i] &lt; a[i * 2 + 1]) &#123;\n                maxPos &#x3D; i * 2 + 1;\n            &#125;\n            if (maxPos &#x3D;&#x3D; i) &#123;\n                break;\n            &#125;\n            swap(a, i, maxPos);\n            i &#x3D; maxPos;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * take the top element of heap\n     *\n     * @return\n     *&#x2F;\n    public int top() &#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            return Integer.MAX_VALUE;\n        &#125;\n        return a[1];\n    &#125;\n\n    public void sort(int[] a, int n) &#123;\n        buildHeap(a, n);\n        int k &#x3D; n;\n        while (k &gt; 1) &#123;\n            swap(a, 1, k);\n            --k;\n            heapify(a, k, 1);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n10.2堆排序\n建堆：将数据原地组织成一个堆\n第一种：从前往后处理每个元素，对每个元素执行自下而上的堆化，O(nlogn)\n第二种：从后往前处理每个元素，对每个元素执行自上而下的堆化，O(n)\n\n\n排序：基于堆排序数据\n将堆顶元素与最后一个元素交换，最大元素就放到了下标为n的位置，堆大小-1\n交换之后的堆顶元素，自上而下堆化，重新构建成堆\n一直重复1，2直到堆中只剩下一个元素，排序结束\n\n\n\n10.3题型\n\n\n\n\n\n\n\n\n用PriorityQueue和compare（o1-o2为小顶堆，o2-o1为大顶堆）\n\n优先级队列\n利用优先级队列模拟堆的操作\n\nTOP K\n求前K大的维护小顶堆\n\n求中位数，百分位数\n维护两个堆，一个大顶堆，一个小顶堆\n\n\n11.字符串匹配（Trie树）11.1单模式串匹配算法：在主串中查找一个模式串\nBF算法：在主串中按顺序检查是否有跟模式穿匹配的\n\nRobin-Karp：通过Hash算法算出主串中的子串的Hash值，用Hash值来比较大小\n\nBoyer-Moore （高效）：当模式串和主串不匹配时，能够跳过一些不会匹配的情况，模式串可以多滑动几位\n\n坏字符规则：模式串从后向前匹配，找到坏字符，拿坏字符在模式串查找，并移到相应位置\n好后缀规则：遇到坏字符，将好后缀记录下来，在模式串中找此子串，并滑动到对应位置\n\n\nKMP算法：同上\n\n\n11.2多模式串匹配算法：在主串中查找多个模式串\nTrie树：适合前缀匹配，n叉树\nAC自动机：多模式匹配首选\n\n11.312.回溯\n\n\n\n\n\n\n\n\n回溯（backtrack）是重点，常考，并且DFS和动态规划的基础，因为回溯用到递归，比较绕，入门很难。\n12.1核心思想\n回溯的处理过程是一个穷举（或者叫枚举）的过程，枚举所有的解，找出其中满足期望的可行解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程归纳为多阶段决策模型。每个阶段的决策会对应多个选择，从可选的选择列表中，任意选择一个，然后继续进行下一阶段的决策。\n整个决策的过程，如果用图来形象化表示的话，就是一颗决策树。回溯穷举所有解来查找可行解的过程，就是在决策树中进行遍历的过程，遍历过程中记录的路径就是解。\n回溯一般使用递归来实现，递归树就跟决策树完全一样。递的过程进行函数调用，对应到递归树上为从一个节点进入它的子节点，归的过程进行函数调用返回，对应到递归树上是从子节点返回上一层节点。\n\n12.2代码模板\n12.3回溯相关题型\n全排列：给定n个不重复的数，求这组数的所有排列组合\n八皇后：\n0-1背包：穷举出2^n种装法，然后找出总重量小于等于Wkg的装法\n穷举出所有的组合：\n正则表达式：\n\n13.图13.1基础概念\n完全图：有向图边数0～n(n-1)、无向图边数0～n(n-1)/2（任意两个顶点之间都存在弧）\n子图：顶点和边的子集，生成子图：顶点都在的子图\n连通：无向图两个节点间有路径；强连通：有向图两个节点间有双向路径（！极大连通子图=连通分量；极大强连通子图=强连通分量）非连通图最多(n-1)(n-2)/2(C排列组合公式完全图去掉n-1条边)\n一个单独的顶点也是一个强连通分量\n生成树：包含全部顶点的一个极小连通子图，含有n-1条边（类似树，少一个不连通，多一个有回路）\n距离：两点间最短路径\n无向图某顶点的度为依附顶点的边的个数；有向图某顶点的度为入度和出度的和\nA^n对应i行j列数值为i到j路径长度为n的路径数目\n7个顶点无向图边数为16时必连通，n个节点连通无向图至少n-1条边，强连通有向图至少n条边\n判断是否是一棵树：连通：能否遍历全部顶点；是一棵树：无回路的的连通图或有n-1条边的连通图（一次遍历就能访问到n个顶点和n-1条边，无向图为2*（n-1）条边）\n\n13.2存储&#x2F;&#x2F;有向无权图，邻接矩阵\npublic class Graph&#123;\n    private int v;\n    private boolean matrix[][];\n    \n    public Graph(int v)&#123;\n        this.v &#x3D; v;\n        matrix &#x3D; new boolean[v][v];&#x2F;&#x2F;默认都为false\n    &#125;\n    \n    public void addEdge(int s,int t)&#123;\n        matrix[x][t] &#x3D; true;\n    &#125;\n&#125;\n&#x2F;&#x2F;有向无权图，邻接表\npublic class Graph&#123;\n    private int v;&#x2F;&#x2F;顶点个数\n    private LinkedList&lt;Integer&gt; adj[];&#x2F;&#x2F;邻接表\n    \n    public Graph(int v)&#123;\n        this.v &#x3D; v;\n        adj &#x3D; new LinkedList[v];\n        for(int i &#x3D; 0; i &lt; v ;++i)&#123;\n            adj[i] &#x3D; new LinkedList&lt;&gt;();\n        &#125;\n    &#125;\n    public void addEdge(int s,int t)&#123;\n        adj[s].add(t);\n    &#125;\n&#125;\n\n\n\n&#x2F;&#x2F;邻接矩阵\n#define MaxVertexNum 100\ntypedef char VertexType;\ntypedef int EdgeType;\ntypedef struct&#123;\n    VertexType Vex[MaxVertexNum];\n    EdgeType Edge[MaxVertexNum][MaxVertexNum];\n    int vexnum,arcnum;\n&#125;MGraph;\n&#x2F;&#x2F;无权图用1&#x2F;0，带权图用∞&#x2F;权值\n\n&#x2F;&#x2F;邻接表法（结构体非指针）\n#define MaxVertexNum 100\ntypedef struct ArcNode&#123;\n    int adjvex;&#x2F;&#x2F;邻接表弧头节点(指谁存谁)；逆邻接表弧尾节点（谁指的存谁）             \n    struct ArcNode *next;\n    &#x2F;&#x2F;InfoType info;\n&#125;ArcNode;\ntypedef struct VNode&#123;\n    VertexType data;\n    ArcNode *first;\n&#125;VNode,AdjList[MaxVertexNum];\ntypedef struct&#123;\n    AdjList vertices;&#x2F;&#x2F;是一个数组，用int表示点\n    int vexnum,arcnum;\n&#125;ALGraph;\n\n13.3BFS、DFS（C语言伪码版）\nBFS（类似树层次遍历），无权图求单源最短路径\nbool visited[MaxVertexNum];\nvoid BFSTraverse(Graph G)&#123;\n    for(i&#x3D;0;i&lt;G.vexnum;++i)\n        visited[i]&#x3D;FALSE;\n    InitQueue(Q);\n    for(i&#x3D;0;i&lt;G.vexnum;++i)\n        if(!visited[i])\n            BFS(G,i);\n&#125;\nvoid BFS(Graph G,int v)&#123;\n    visit(v);\n    visited[v]&#x3D;TRUE;\n    Enqueue(Q,v);\n    while(!isEmpty(Q))&#123;\n        DeQueue(Q,v);\n    for(w&#x3D;FirstNeighbor(G,v);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,v,w))\n        if(!visited[w])&#123;\n            visit(w);\n            visited[w]&#x3D;TRUE;\n            EnQueue(Q,w);\n        &#125;\n    &#125;\n&#125;\n\nvoid BFSMinDistance(Graph G,int u)&#123;\n&#x2F;&#x2F;d[i]从u到i节点最短路径\n    for(i&#x3D;0;i&lt;G.vexnum;++i)\n        d[i] &#x3D; ∞;\n    visited[u]&#x3D;TRUE;\n    d[u]&#x3D;0;\n    Enqueue(Q,u);\n    while(!isEmpty(Q))&#123;\n        DeQueue(Q,u);\n        for(w&#x3D;FirstNeighbor(G,u);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,u,w))\n            if(!visited[w])&#123;\n                visited[w]&#x3D;TRUE;\n                d[w]&#x3D;d[u]+1;\n                EnQueue(Q,w);\n           &#125;\n    &#125;\n&#125;\nDFS（递归、非递归）（类似树先序遍历）【判断是否有环】\nbool visited[MaxVertexNum];\nvoid DFSTraverse(Graph G)&#123;\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        visited[v]&#x3D;FALSE;\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        if(!visited[v])\n            DFS(G,v);\n&#125;\nvoid DFS(Graph G,int v)&#123;\n    visit(v);\n    visited[v]&#x3D;TRUE;\n    for(w&#x3D;FirstNeighbor(G,v);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,v,w))\n        if(!visited[w])&#123;\n            DFS(G,w);\n    &#125;\n&#125;\n\nvoid DFS(Graph g,int v)&#123;\n    int w;\n    InitStack(S);\n    for(i&#x3D;0;i&lt;g.vexnum;i++)\n        visited[i]&#x3D;FALSE;\n    Push(S,v);\n    visited[v]&#x3D;TRUE;\n    while(!isEmpty(S))&#123;\n        k&#x3D;Pop(S);\n        visit(k);&#x2F;&#x2F;先访问，后将子节点入栈\n        for(w&#x3D;FirstNeighbor(G,k);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,k,w))\n            if(!visited[w])&#123;\n                Push(S,w);\n                visited[w]&#x3D;true;&#x2F;&#x2F;防止再次入栈\n            &#125;\n    &#125;\n&#125;\n## - 输出Vi到Vj的所有简单路径\nvoid FindPath(Graph *G,int u,int v,int path[],int d)&#123;\n    int w,i;\n    ArcNode *P;\n    d++;\n    path[d]&#x3D;u;\n    visited[u]&#x3D;1;\n    if(uv)\n        print(path[]);\n    P&#x3D;G-&gt;adjlist[u].firstarc;\n    while(p!&#x3D;NULL)&#123;\n        w&#x3D;p-&gt;adjvex;\n        if(visited[w]0)\n            FindPath(G,w,v,path,d);\n        p&#x3D;p-&gt;nextarc;\n    &#125;\n    visited[u]&#x3D;0;&#x2F;&#x2F;恢复环境，使该节点可重新使用\n&#125;\n\n13.4BFS、DFS（java版）\n树是图的一种特殊情况，二叉树的层次遍历，实际上就是广度优先搜索，从根节点开始，一层层的从上往下遍历， 先遍历与根节点近的，再逐层遍历与根节点远的。图上的广度优先搜索（或遍历）跟树上的按层遍历很像，先查找离起始顶点s最近的，然后是次近的，依次往外搜索，直到找到终止顶点t（或所有顶点都遍历了一遍）。树的按层遍历需要用到队列，同理，图的广度优先搜索（或遍历）也要用到队列。除此之外，对于图的按层遍历，需要用一个visited数组，记录已经遍历过的顶点，防止图中存在环，出现循环遍历多次的情况。==广度优先搜索处理的是无权图，实际上，通过广度优先搜索找到的源点到终点的路径也是顶点s到顶点t的最短路径==\n前面提到广度优先搜索时一种“地毯式”的搜索策略，那么深度优先搜索（DFS）就是一种“不撞南墙不回头”的搜索策略。==DFS是图上的回溯==，沿着一条路一股脑地往前走，当走到无路可走时，再回退到上一个岔路口，选择另一条路继续前进。==树的前中后序遍历就是深度优先遍历==。前中后序的区别仅仅在于处理节点的时机的不同。换句话说：树上的深度优先遍历又分为三类：前中后序遍历。\n实际上，DFS也是一种回溯算法，也可以看做多阶段决策模型，用回溯模板解决。\n每个阶段都是基于当前节点移动到下一节点\n可选列表是：相邻并没有被访问过的节点\n当前阶段做不同的选择，对应下一阶段是不同的\n回溯的结束条件是：所有节点都已经访问完成或找到了终止节点\n在回溯的过程中，我们用visited数组，记录已经遍历过的顶点，以免循环重复遍历。\n\n\n\npackage Graph;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Graph &#123;\n    &#x2F;**\n     * 顶点个数\n     *&#x2F;\n    private int v;\n    &#x2F;**\n     * 邻接表\n     *&#x2F;\n    private LinkedList&lt;Integer&gt; adj[];\n\n    public Graph(int v) &#123;\n        this.v &#x3D; v;\n        adj &#x3D; new LinkedList[v];\n        for (int i &#x3D; 0; i &lt; v; i++) &#123;\n            adj[i] &#x3D; new LinkedList&lt;&gt;();\n        &#125;\n    &#125;\n\n    public void addEdge(int s, int t) &#123;\n        &#x2F;&#x2F;无向图一条边存两次\n        adj[s].add(t);\n        adj[t].add(s);\n    &#125;\n\n    &#x2F;**\n     * 广度优先搜索&#x2F;遍历算法\n     *\n     * @param s\n     * @param t\n     * @return\n     *&#x2F;\n    public void bfs_simple(int s, int t) &#123;\n        boolean[] visited &#x3D; new boolean[v];\n        Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();\n        queue.add(s);\n        visited[s] &#x3D; true;\n        while (!queue.isEmpty()) &#123;\n            int p &#x3D; queue.poll();\n            &#x2F;&#x2F;搜索时加上\n&#x2F;&#x2F;            if (p &#x3D;&#x3D; t)&#123;\n&#x2F;&#x2F;                return true;\n&#x2F;&#x2F;            &#125;\n            for (int i &#x3D; 0; i &lt; adj[p].size(); i++) &#123;\n                int q &#x3D; adj[p].get(i);\n                if (!visited[q]) &#123;\n                    visited[q] &#x3D; true;\n                    queue.add(q);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 支持打印从s到t的路径\n     *\n     * @param s\n     * @param t\n     *&#x2F;\n    public void bfs(int s, int t) &#123;\n        boolean[] visited &#x3D; new boolean[v];\n        Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();\n        queue.add(s);\n        visited[s] &#x3D; true;\n        &#x2F;&#x2F;+\n        int[] prev &#x3D; new int[v];\n        for (int i &#x3D; 0; i &lt; v; i++) &#123;\n            prev[i] &#x3D; -1;\n        &#125;\n        &#x2F;&#x2F;+\n        while (!queue.isEmpty()) &#123;\n            int p &#x3D; queue.poll();\n            if (p &#x3D;&#x3D; t) &#123;\n                &#x2F;&#x2F;+\n                print(prev, s, t);\n                &#x2F;&#x2F;+\n                return;\n            &#125;\n            for (int i &#x3D; 0; i &lt; adj[p].size(); i++) &#123;\n                int q &#x3D; adj[p].get(i);\n                if (!visited[q]) &#123;\n                    &#x2F;&#x2F;+\n                    prev[q] &#x3D; p;\n                    &#x2F;&#x2F;+\n                    visited[q] &#x3D; true;\n                    queue.add(q);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 有点类似于逆序打印链表\n     *\n     * @param prev\n     * @param s\n     * @param t\n     *&#x2F;\n    private void print(int[] prev, int s, int t) &#123;\n        if (prev[t] !&#x3D; -1 &amp;&amp; t !&#x3D; s) &#123;\n            print(prev, s, prev[t]);\n        &#125;\n        System.out.println(t + &quot;  &quot;);\n    &#125;\n\n    boolean found &#x3D; false;\n    private boolean[] visited &#x3D; new boolean[v];\n\n    public boolean dfs_simple(int s, int t) &#123;\n        dfs_simple(s, t);\n        return found;\n    &#125;\n\n    private void dfs_simple_r(int s, int t) &#123;\n        if (found) &#123;\n            return;\n        &#125;\n        visited[s] &#x3D; true;\n        if (s &#x3D;&#x3D; t) &#123;\n            found &#x3D; true;\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q]) &#123;\n                dfs_simple_r(q, t);\n            &#125;\n        &#125;\n    &#125;\n\n    private List&lt;Integer&gt; resultPath &#x3D; new ArrayList&lt;&gt;();\n\n    &#x2F;**\n     * 支持打印出从s到t的路径\n     * @param s\n     * @param t\n     * @return\n     *&#x2F;\n    public List&lt;Integer&gt; dfs(int s,int t)&#123;\n        dfs_r(s,t,new ArrayList&lt;&gt;());\n        return resultPath;\n    &#125;\n    public void dfs_r(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        visited[s] &#x3D; true;\n        path.add(s);\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                dfs_r(q,t,path);\n            &#125;\n        &#125;\n        path.remove(path.size()-1);\n    &#125;\n\n    public List&lt;Integer&gt; dfs2(int s,int t)&#123;\n        List&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();\n        path.add(s);\n        visited[s] &#x3D; true;\n        dfs_backtrack(s,t,path);\n        return resultPath;\n    &#125;\n\n    public void dfs_backtrack(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                path.add(q);\n                visited[q] &#x3D; true;\n                dfs_backtrack(q,t,path);\n                path.remove(path.size()-1);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n13.5图上其他算法1.最小生成树（PK算法）\n带权连通图的任意一个环中所包含的边权值均不相等时，其最小生成树是唯一的\nPrim：找点，适合求解边稠密的图\nKruskal：找边，适合求解边稀疏而顶点较多的图，采用堆来存放边的集合\n\n2.最短路径（DF算法）\nDijkstra：\n\n针对有权图的单源最短路径算法，并且要求没有负权边\n求有向图某一个顶点到其余各顶点的最短路径，dist[]源点到各顶点最短路径长度 path[]v到当前节点的最短路径的前驱节点，首先初始化，算距离改dist[],找最小改path[],加和比较继续迭代\n\n\nFloyd：\n\n针对有权图的多源最短路径算法，允许存在负权边，但不允许负权环\n求有向图每对顶点之间最短路径，用边矩阵作为A⁻¹进行迭代，每次加进来一个顶点，并遍历矩阵进行修改(A[i][j]&gt;A[i][k]+A[k][j])，最后得到任意两节点间最短路径矩阵\n\n\nBellman-Ford：\n\n针对有权图的单源最短路径算法，允许存在负权边\n\n\nA*算法：\n\n启发式搜索算法，求有权图的次优最短路线\n\n\n\n3.AOV网：拓扑排序\nDAG图（有向无环图）\n可判断有向图是否有回路\n邻接矩阵是三角矩阵，则存在拓扑序列\n\nbool TopologicalSort(Graph G)&#123;&#x2F;&#x2F;不用visited[]\n    InitStack(S);\n    for(int i&#x3D;0;i&lt;G.vexnum;i++)\n        if(indegree[i] &#x3D;&#x3D; 0)\n            Push(S,i);\n    int count &#x3D; 0;\n    while(!IsEmpty(S))&#123;\n        Pop(S,i);\n        print[count++]&#x3D;i;\n        for(p&#x3D;G.vertices[i].firstarc;p;p&#x3D;p-&gt;nextarc)&#123;\n            v&#x3D;p-&gt;adjvex;&#x2F;&#x2F;由边找到点\n            if(!(—-indegree[v]))\n                Push(S,v);\n        &#125;\n    &#125;\n    if(count&lt;G.vexnum)\n        return false;&#x2F;&#x2F;有环\n    else\n        return true;\n&#125;\n\n\n&#x2F;&#x2F;用DFS实现无环图拓扑排序！\nbool visited[MaxVertexNum];\nvoid DFSTraverse(Graph G)&#123;\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        visited[v]&#x3D;FALSE;\n    time &#x3D; 0&#x2F;&#x2F;有向无环图拓扑排序\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        if(!visited[v])\n            DFS(G,v);\n&#125;\nvoid DFS(Graph G,int v)&#123;\n    visit(v);\n    visited[v]&#x3D;TRUE;\n    for(w&#x3D;FirstNeighbor(G,v);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,v,w))\n        if(!visited[w])&#123;\n            DFS(G,w);\n    &#125;\n    time &#x3D; time+1;\n    finishTime[v]&#x3D;time;\n    &#x2F;&#x2F;时间从大到小排序即可得到拓扑排序\n    &#x2F;&#x2F;从下往上一层层加时间，最上面的时间最长\n    &#x2F;&#x2F;子孙先结束，祖先后结束\n&#125;\n\n&#x2F;&#x2F;逆拓扑排序\n&#x2F;&#x2F;从AOV网中选择一个没有后继的顶点并输出\n&#x2F;&#x2F;从网中删除该顶点和所有以它为终点的有向边\n&#x2F;&#x2F;重复以上两点，直到为空\n\n4.AOE网\n关键路径（最大路径长度）去大回小拓扑排序+逆拓扑排序=关键路径完成工程的最短时间=关键路径长度=最大路径长度\n顶点表示事件，有向边表示活动\n只有某节点所代表的事情发生后从该顶点出发的各有向边所代表的活动才能开始；只有进入某顶点的有向边所代表的活动都结束时，该顶点所代表的事件才能发生。Ve（k）、Vl（k）、e（i）、l（i）\n对于有多条关键路径的网，只有加快包含在所有关键路径上的关键活动才能达到缩短工期的目的。\n\n5.最大流 ，二分匹配\nFord-Fulkerson\nEdmonds-Karp\n\n13.6题型套路\n二维矩阵搜索或遍历\n\n最短路径（BFS）\n\n连通分量/连通性\n\n拓扑排序\n\nKahn算法：\n\n数据结构：如果s需要先于t执行，那就添加一条s指向t的边，所以每个顶点的入度表示这个顶点依赖多少个其它顶点，如果某个顶点的入度变成了0，就表示这个顶点没有依赖的顶点了，或者说这个顶点依赖的顶点都已执行\n\npublic void topoSortByKahn() &#123;\n  int[] inDegree &#x3D; new int[v];\n  for (int i &#x3D; 0; i &lt; v; i++) &#123;\n    for (int j &#x3D; 0; j &lt; adj[i].size(); j++) &#123;\n      int w &#x3D; adj[i].get(j);\n      inDegree[w]++;\n    &#125;\n  &#125;\n  LinkedList&lt;Integer&gt; zeroSet &#x3D; new LinkedList&lt;&gt;();\n  for (int i &#x3D; 0; i &lt; v; i++) &#123;\n    if (inDegree[i] &#x3D;&#x3D; 0) &#123;\n      zeroSet.add(i);\n    &#125;\n  &#125;\n  while (!zeroSet.isEmpty()) &#123;\n    int i &#x3D; zeroSet.remove();\n    System.out.println(&quot;-&gt;&quot; + i);\n    for (int j &#x3D; 0; j &lt; adj[i].size(); j++) &#123;\n      int k &#x3D; adj[i].get(j);\n      inDegree[k]--;\n      if (inDegree[k] &#x3D;&#x3D; 0) &#123;\n        zeroSet.add(k);\n      &#125;\n    &#125;\n  &#125;\n&#125;\nDFS算法：\n\n数据结构：如果s需要先于t执行，也就是说，t依赖s，那就添加一条t指向s的边。算法处理的核心思想是递归，对于顶点vertex，我们先输出它可到达的所有顶点，也就是说，先把它依赖的所有顶点输出，然后再输出自己，这个过程可以借助DFS实现\npublic void topoSortByDFS()&#123;\n  for (int i &#x3D; 0; i &lt; v; i++) &#123;\n    if (visited[i] &#x3D;&#x3D; false)&#123;\n      visited[i] &#x3D; true;\n      dfs(i);\n    &#125;\n  &#125;\n&#125;\npublic void dfs(int vertex)&#123;\n  for (int i &#x3D; 0; i &lt; adj[vertex].size(); i++) &#123;\n    int w &#x3D; adj[vertex].get(i);\n    if (visited[w] &#x3D; true)&#123;\n      continue;\n    &#125;\n    visited[w] &#x3D; true;\n    dfs(w);\n  &#125;\n  System.out.println(&quot;-&gt;&quot; + vertex);\n&#125;\n\n\n\n\n检测环\n\n\n14.动态规划1.理论知识\n适用问题：回溯+重复子问题（重复状态），部分问题可以使用回溯+备忘录的方法来解决。示例如下（0-1背包问题）\n\n构建多阶段决策模型：把每一层（每一阶段）重复的状态合并，只记录不同的状态，然后基于上一层（上一阶段）的状态集合，来推导下一层（下一阶段）的状态集合\n通过合并每一层重复的状态，这样就能保证每一层的状态个数不会超过w个（背包的承载重量）。于是，就可以避免回溯算法递归树中每层状态个数的指数级增长\n定义转移状态：使用一个boolean的二维数组表示，第i个物品放入后有哪几个重量是可行的\n状态转移方程：不断迭代，将可能的结果填入到二维数组相应的位置\n\n\n解题步骤\n\n可用回溯解决：使用穷举结果才能得到结果的问题（最值、可行、计数等）\n构建多阶段决策模型：看是否能将问题求解的过程分为多个阶段\n查看是否存在重复子问题：是否有多个路径到达同一状态\n定义状态：也就是如何记录每一阶段的不重复状态\n定义状态转移方程：也就是找到如何通过上一阶段的状态推导下一阶段的状态\n画状态转移表：辅助理解，验证正确性，确定状态转移的初始值\n\n\n0-1背包问题的最值、可行、计数\n\n最值\n\n示例一：有n个物品，选择其中一些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装物品总重量的最大值是多少\n\npublic int knapsack1(int[] weight, int n, int w)&#123;&#x2F;&#x2F;最值\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  dp[0][0] &#x3D; true;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; i++)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D;&#x3D; true || (j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] &#x3D;&#x3D; true))&#123;\n        dp[i][j] &#x3D; true;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; w; i &gt;&#x3D; 0 ; i--)&#123;&#x2F;&#x2F;输出结果\n    if(dp[n-1][i] &#x3D;&#x3D; true) &#123;\n      return i;\n    &#125;\n  &#125;\n  return 0;\n&#125;\n示例二：有n个物品，选择其中一些物品装入背包，正好装满背包所需物品最小个数（如果装不满，返回-1）\n\npublic int knapsack3(int[] weight, int n, int w)&#123;&#x2F;&#x2F;最值\n  int[][] dp &#x3D; new int[n][w+1];&#x2F;&#x2F;记录到达某个状态，最少物品数量\n  for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      dp[i][j] &#x3D; Integer.MAX_VALUE-1;&#x2F;&#x2F;解决越界问题\n    &#125;\n  &#125;\n  dp[0][0] &#x3D; 0;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; 1;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;&#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(j-weight[i] &lt; 0)&#123;\n        dp[i][j] &#x3D; dp[i-1][j];\n      &#125;else&#123;\n        dp[i][j] &#x3D; Math.min(dp[i-1][j], dp[i-1][j-weight[i]] + 1);&#x2F;&#x2F;会有越界问题\n      &#125;\n    &#125;\n  &#125;\n  if(dp[n-1][w] &#x3D;&#x3D; Integer.MAX_VALUE) &#123;\n    return -1;\n  &#125;\n  return dp[n-1][w];\n&#125;\n\n\n可行\n\n示例：有n个物品，选择其中一些物品装入背包，能不能正好装满背包\n\npublic boolean kanpsack2(int[] weight, int n, int w)&#123;&#x2F;&#x2F;可行\n  boolean[][] dp &#x3D; new boolean[n][w+1];&#x2F;&#x2F;默认值false\n  dp[0][0] &#x3D; true;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D; true || (j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] &#x3D;&#x3D; true))&#123;\n        dp[i][j] &#x3D; true;\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;\n\n\n计数\n\n示例：有n个物品，选择其中一些物品装入背包，装满背包有多少种不同的装法\n\npublic int knapsack4(int[] weight, int n, int w)&#123; &#x2F;&#x2F;计数\n  int[][] dp &#x3D; new int[n][w+1]; &#x2F;&#x2F;记录到达某个状态有几条路径\n  dp[0][0] &#x3D; 1;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; 1;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(j-weight[i] &lt; 0)&#123;\n        dp[i][j] &#x3D; dp[i-1][j];\n      &#125;else&#123;\n        dp[i][j] &#x3D; dp[i-1][j] + dp[i-1][j-weight[i]];\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;\n\n\n\n\n完全背包问题的最值、可行、计数\n\n背包可装物品总重量的最大值是多少\npublic int wanquan_1(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        if(dp[i-1][j-c*weight[i]])&#123;\n          dp[i][j] &#x3D; true;\n          break;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; w; i &gt;&#x3D; 0; --i)&#123;\n    if(dp[n-1][i] &#x3D;&#x3D; true)&#123;\n      return i;\n    &#125;\n  &#125;\n  return 0;\n&#125;\n是否能装满整个背包\npublic int wanquan_2(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        if(dp[i-1][j-c*weight[i]])&#123;\n          dp[i][j] &#x3D; true;\n          break;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;\n正好装满背包至少需要多少物品\npublic int wanquan_3(int[] weight, int n, int w)&#123;\n  int[][] dp &#x3D; new int[n][w+1];\n  for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      dp[i][j] &#x3D; Integer.MAX_VALUE;\n    &#125;\n  &#125;\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; i;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        if(dp[i-1][j-c*weight[i]] !&#x3D; Integer.MAX_VALUE &amp;&amp; dp[i-1][j-c*weight[i]]+c &lt; dp[i][j])&#123;\n          dp[i][j] &#x3D; dp[i-1][j-c*weight[i]] + c;\n          break;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;\n装满背包有多少种装法\npublic int wanquan_4(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; 1;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        dp[i][j] +&#x3D; dp[i+1][j-c*weight[i]];\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;\n\n\n空间优化\n\n问题：对于一组不同重量、不可分割的物品，选择其中一些物品装入背包，能不能正好装满背包\n\n\n\n\n\n2.经典问题\n背包问题（0-1、完全、多重、二维费用、分组、有依赖的）\n\n0-1\n\npublic int knapsack(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1]; &#x2F;&#x2F;默认为false\n  dp[0][0] &#x3D; true;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D;&#x3D; true)&#123;\n        dp[i][j] &#x3D; true;\n        if(j+weight[i] &lt;&#x3D; w)&#123;\n          dp[i][j+weight[i]] &#x3D; true;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(itn j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D;&#x3D; true || (j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] &#x3D;&#x3D; true))&#123;\n        dp[i][j] &#x3D; true;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; w; i &gt;&#x3D; 0; --i)&#123;&#x2F;&#x2F;输出结果\n    if(dp[n-1][i] &#x3D;&#x3D; true)&#123;\n      return i;\n    &#125;\n  &#125;\n  return 0;\n&#125;\n二维\n\npublic int knapsack_2(int[] weight, int[] value, int n, int w)&#123;\n  int[][] dp &#x3D; new int[n][w+1];\n  for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      dp[i][j] &#x3D;&#x3D; Integer.MIN_VALUE;\n    &#125;\n  &#125;\n  dp[0][0] &#x3D; 0;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; value[0];\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D; Integer.MIN_VALUE)&#123;\n        continue;\n      &#125;\n      dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j]);\n      if(j+weight[i] &lt;&#x3D; w)&#123;\n        dp[i][j+weight[i]] &#x3D; Math.max(dp[i][j+weight[i]], dp[i-1][j] + value[i]);\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] !&#x3D; Integer.MIN_VALUE)&#123;\n        dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j]);\n      &#125;\n      if(j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] !&#x3D; Integer.MIN_VALUE)&#123;\n        dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-weight[i]] + value[i]);\n      &#125;\n    &#125;\n  &#125;\n  int res &#x3D; Integer.MIN_VALUE;\n  for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n    if(res &lt; dp[n-1][j])&#123;\n      res &#x3D; dp[n-1][j];\n    &#125;\n  &#125;\n  return res;\n&#125;\n多重背包问题，装满背包有多少种装法\n\n\n\n\n路径问题\n\n打家劫舍和股票买卖\n\n一般动态规划问题，上一个阶段做了什么决策，不影响下一个阶段的决策。但是打家劫舍&amp;股票买卖这类问题，上一个阶段的决策会影响下一个阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值\n\n\n爬楼梯问题\n\n\n匹配问题（LCS、编辑距离）\n\n\n其他（LIS）\n\n\n3.动态规划相关题型15.其它1.海量数据处理\n\n\n\n\n\n\n\n\n一台机器的内存存不下，或者一台机器处理的太慢了\n\n处理的核心思想：分治\n单机：利用外存，分批加入内存处理\n多机：对数据分片，利用多机内存存储\n多机：并行计算，利用多线程、多机并行处理\n\n\n一些处理技巧\n外部排序：多路归并、桶排序\n哈希分片\n位图\n\n\n常见的问题\n海量数据排序\n海量数据查询\n海量数据TopK\n海量数据求频率TopK\n海量数据去重/找重\n两海量文件找重\n\n\n例题：先考虑非海量，再调整方案适配海量\n按照金额大小给10GB的订单文件进行排序\n法一：分成n份，对每一份排序，再从每一份中拿出一个数字，进行排序并一个一个存回外存\n法二：桶排序，把数据分成10个桶，再对每一个桶排序\n\n\n有一个IP地址白名单文件，包含10亿个IP地址，判断某IP是否在白名单中\n若能存下：只需要构造哈希表或红黑树\n因为所有IP地址（0~2^32-1）一个地址一位，一共只需要500MB，所以可以构成位图，可以在为图里查询\n位图放不下的时候，使用多机的内存，通过对每个IP求MD5（Hash后分布均匀）再进行Hash，放到不同的机器上，在对应机器上构造位图\n\n\n10亿个整数求Top100\n都能放到内存里，使用堆\n放不到内存里，也可以使用堆，顺序读数据，构造小顶堆\n\n\n100GB的搜索关键字文件，统计出现频率Top100关键词\n统计频率的方法：先排序再顺序扫描，或者使用Hash表\n单机上：\n多路归并排序、在统计出现频率、再通过堆求Top100\n通过Hash表：先分片，对每个关键词求MD5，求Hash，每次加载进去Hash值相同的一份，并统计频率再写回，一共N份，顺序读求TopK\n\n\n\n\n一个文件包含10亿条URL，有可能会有重复的，将重复的去掉\n如果内存能放下：排序/Hash去重\n排序去重\nHash分片，把每一个分片都放到内存，去重后写回\n\n\na，b两个文件，各自有50亿条URL，每条URL占用64字节，内存限制是4GB，找出a，b文件共同的URL\n分别排序，在顺序扫描，双指针问题\nHash分片分别分成成N份，每次各取出一份，去重，再写回\n\n\n\n\n配套练习\n如何从大量的URL中找出相同的URL（百度）\n如何从大量数据中找出高频词（百度）\n如何找出某一天访问百度网站最多的IP（百度）\n如何在大量的数据中找出不重复的整数（百度）\n如何在大量的数据中判断一个数是否存在（腾讯）\n如何查找最热门的查询串（腾讯）\n如何统计不同电话号码的个数（百度）\n如何从5亿个数中找出中位数（百度）\n如何按照query的频度排序（百度）\n如何找出排名前500的数（腾讯）\n\n\n\n2.双指针\n比较常考，主要用来求数对，特殊排序。单数组上前后指针、快慢指针、区间指针、双数组上的指针\n\n3.滑动窗口\n常用来解决：求连续子串、连续子序列、连续子数组\n\n4.前缀后缀匹配\n不常考，前缀和、后缀和、前缀积、后缀积、前缀最大、后缀最大\n支持频繁+快速的区间估计\n\n5.位运算\n\nDesign Pattern1.高质量代码评价原则\n可维护性（maintainability）bug 容易修复，修改、添加功能能够轻松完成\n可读性（readability）同事可以轻松地读懂你写的代码\n可扩展性（extensibility）代码预留了一些功能扩展点，不用改动大量的源代码，就你可以把新功能代码，直接插到扩展点上\n灵活性（flexibility）代码易扩展、易复用或者易用\n简洁性（simplicity）思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题\n可复用性（reusability）尽量减少重复代码的编写，复用已有的代码\n可测试性（testability）单元测试比较好写\n\n2.编程范式\n\n\n\n\n\n\n\n\nProgram = Logic+Control+Data Structure，有效地分离 Logic、Control（遍历数据、查找数据、多线程、并发、异步） 和 Data（用户的业务逻辑）是写出好程序的关键所在！Logic 部分才是真正有意义的（What），Control 部分只是影响 Logic 部分的效率（How）\n\n==如何分离control 和 logic==\n\nState Machine\n状态定义\n状态变迁\n条件状态的 action\n\n\nDSL – Domain Specific Language\nHTML，SQL，Unix Shell Script，AWK，正则表达式……\n\n\n编程范式\n面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC……\n函数式编程：修饰、管道、拼装\n逻辑推导式编程：Prolog    \n\n\n\n1.面向过程（C）\n面向过程编程，以过程（方法、函数、操作）作为组织代码的基本单元，以数据（成员变量、属性）与方法相分离为主要的特点，通过拼接一组顺序执行的方法来操作数据完成一项功能。\n适合开发微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅\n\n2.面向对象（Java）\nWhy\n\n面向对象VS面向过程\n面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。面向对象风格的代码组织成一组类，方法和数据机构被绑定在一起，定义在类中。\n面向过程比较适合处理流程只有一条主线的程序，面向过程更适合大规模复杂程序（网状处理流程）的开发，先建模为类再按照处理流程搭建起整个程序。\n==编程==：\n慎用getter、setter方法\n慎用全局变量和全局方法\n静态方法可以在不创建对象的情况下直接使用\n不用包含全部final变量的Constants类，慎用只包含静态方法的Utils类\n\n\n不定义数据和方法分离的类，例如MVC中将业务逻辑和数据分离开来（见贫血模型）\n\n\n面向对象编程是一种自底向上的思考方式，不是按照执行流程来分解任务，而是将任务翻译成一个一个小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务\n\n\n\n\nWhat\n\n面向对象：\n\n面向对象分析、面向对象设计：围绕着对象和类来做软件开发中的需求分析和系统设计的，分析和设计两个阶段最终的产出式类的设计，包括程序==被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互、将类组装起来并提供执行入口==。他们比其它的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地渡过面向对象编程环节。\n面向对象编程：一种编程范式或编程风格，他以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石\n面向对象编程语言：是一种支持类和对象的，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言\n\n\n四大特性：\n\n封装（Encapsulation）：\n\n类通过暴漏有限的访问接口，授权外部仅能通过类提供的方法（或叫函数）来访问内部信息或者数据。\n需要依靠编程语言本身提供一定的语法机制来支持，即访问访问权限控制（private、public等关键字）\n意义：对类中的属性可控使得代码易维护，仅暴漏必要的操作提高类的易用性，\n\n\n抽象（Abstraction）：\n\n抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。\n常通过编程语言提供的接口类（interface）或者抽象类（abstract）来实现抽象这一特性，使用者只需要了解接口类暴漏了哪些方法而不需要查看类里的具体实现逻辑。也可以依靠函数这一语法机制，调用者不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。\n帮助我们过滤掉许多非必要的信息，指导我们定义类的方法时，要有抽象思维，不要暴漏太多实现细节\n\n\n继承（Inheritance）：\n\n用来表示类之间is-a的关系\n通过编程语言中的特殊语法机制：Java中的extends、C++中的：，Python中的parentheses（）、Ruby中的&lt;，其中C++、Python、Perl支持多继承\n继承最大的一个好处就是代码复用，将两个类中的相同属性和方法抽象到父类中，但过度使用继承，继承层次过深过复杂，会导致代码的可读性、可维护性变差\n==多继承==：Java 不支持多重继承的原因 多重继承有副作用：钻石问题(菱形继承)。 假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。 考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从JDK1.8之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。\n\n\n多态（Polymorphism）：\n\n多态是指子类可以替换父类，提高代码的可扩展性和复用性，\n\n有三种实现方法\n\n继承加重写\n\n编程语言需要：支持父类对象可以引用子类对象、支持继承、支持子类可以重写父类的方法\npublic interface Iterator &#123;\n  boolean hasNext();\n  String next();\n  String remove();\n&#125;\n\npublic class Array implements Iterator &#123;\n  private String[] data;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法...\n&#125;\n\npublic class LinkedList implements Iterator &#123;\n  private LinkedListNode head;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法... \n&#125;\n\npublic class Demo &#123;\n  private static void print(Iterator iterator) &#123;\n    while (iterator.hasNext()) &#123;\n      System.out.println(iterator.next());\n    &#125;\n  &#125;\n  \n  public static void main(String[] args) &#123;\n    Iterator arrayIterator &#x3D; new Array();\n    print(arrayIterator);\n    \n    Iterator linkedListIterator &#x3D; new LinkedList();\n    print(linkedListIterator);\n  &#125;\n&#125;\n\n\n接口类\n\n更易扩展\npublic interface Iterator &#123;\n  boolean hasNext();\n  String next();\n  String remove();\n&#125;\n\npublic class Array implements Iterator &#123;\n  private String[] data;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法...\n&#125;\n\npublic class LinkedList implements Iterator &#123;\n  private LinkedListNode head;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法... \n&#125;\n\npublic class Demo &#123;\n  private static void print(Iterator iterator) &#123;\n    while (iterator.hasNext()) &#123;\n      System.out.println(iterator.next());\n    &#125;\n  &#125;\n  \n  public static void main(String[] args) &#123;\n    Iterator arrayIterator &#x3D; new Array();\n    print(arrayIterator);\n    \n    Iterator linkedListIterator &#x3D; new LinkedList();\n    print(linkedListIterator);\n  &#125;\n&#125;\n\n\nduck-typing语法\n\n只要两个类有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，是一些动态语言所特有的语法机制\nclass Logger:\n    def record(self):\n        print(“I write a log into file.”)\n        \nclass DB:\n    def record(self):\n        print(“I insert data into db. ”)\n        \ndef test(recorder):\n    recorder.record()\n\ndef demo():\n    logger &#x3D; Logger()\n    db &#x3D; DB()\n    test(logger)\n    test(db)\n\n\n\n\n\n\n\n\nWhere\n\n实战一：基于贫血模型的MVC架构VS基于充血模型的DDD架构\n\nMVC：M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。并根据具体的项目需求，做适当的调整。例如：现在前后端分离的项目Web或App项目中，一般后端项目分为Repository层、Service层、Controller层，其中Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴漏接口\n\nDDD：领域驱动设计（Domain Driven Design），主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。微服务的兴起加速了领域驱动设计的盛行。\n\n贫血模型：只包含数据不包含业务逻辑的类（UserEntity）\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Controller+VO(View Object)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserController&#123;\n    private UserService userService;&#x2F;&#x2F;通过构造函数或者IOC框架注入\n    \n    public UserVO getUserById(Long userId)&#123;\n        UserBo userBo &#x3D; userService.getUserById(userId);\n        userVo userVo &#x3D; [...convert userBo to userVo];\n        return userVo;\n    &#125;\n&#125;\npublic class UserVo&#123;&#x2F;&#x2F;省略其他属性，get、set、construct方法\n    private Long id;\n    private String name;\n    private String cellphone;\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Service+BO(Business Object)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserService&#123;\n    private UserRepository userRepository;&#x2F;&#x2F;通过构造函数或者IOC框架注入\n    \n    public UserBo getUserById(Long userId)&#123;\n        UserEntity userEntity &#x3D; userRepository.getUserById(userId);\n        UserBo userBo &#x3D; [...convert userEntity to userBo...];\n        return userBo;\n    &#125;\n&#125;\npublic class UserBo&#123;&#x2F;&#x2F;省略其他属性，get、set、construct方法\n    private Long id;\n    private String name;\n    private String cellphone;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Repository+Entity&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserRepository&#123;\n    public UserEntity getUserById(Long userId)&#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\npublic class UserEntity&#123;\n    &#x2F;&#x2F;省略其他属性和get、set、construct方法\n    private long id;\n    private String name;\n    private String cellphone;\n&#125;\n充血模型：数据和业务逻辑本封装到同一个类中\n\nService类负责与Repository层打交道，调用Repository类的方法，获取数据库中的数据，转换成领域模型Domain，然后由Domain来完成业务逻辑，最后调用Repository类的方法，将数据返回数据库。Service类负责跨领域模型的业务聚合功能，例如需要多个实体的操作。Service类负责一些功能性及第三方系统交互的工作。\nController层和Repository层，因为业务较少，所以没必改成充血模型\n\n\n基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。基于充血模型的DDD开发模式，更适合业务复杂的系统开发。\n\n落实到代码层面，就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中\n开发流程不同：\nSQL驱动开发：依据接口需求，去写SQL语句，定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码，业务逻辑包裹在一个大的SQL语句中，而Service层可以做的事情很少，新功能开发，只能重写新的SQL语句\n业务驱动开发（DDD）：在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法，领域模型相当于可复用的业务中间层，新功能的开发，都基于之前定义好的这些领域模型来完成。\n\n\n\n\n\n\n如何对接口鉴权这样一个功能开发做面向对象分析\n\n需求分析：先从最简单的方案想起，不断优化，得到若干条需求\n==需求设计==：\n划分模块-&gt;拆分功能点（名词）-&gt;组合成类\n定义类及其属性和方法：找动词作为候选的方法，再进一步筛选出真正的方法\n定义类与类之间的交互方式：UML包括六种：泛化、实现、关联、聚合、组合、依赖，==我们保留==：泛化（继承）、实现（接口）、组合（B是A的成员变量）、依赖（A与B有关系即可）\n将类组装起来并提供执行入口：main()或API接口\n\n\n编程实现：\n\n\n\n\nHow\n\n接口（has-a）VS抽象类（is-a）\n\n抽象类的特性：抽象类不允许被实例化，只能被继承（不能new出来一个对象）；抽象类可以包含属性和方法，其中方法既可以包含代码实现，也可以不包含代码实现（抽象方法）；子类继承抽象类，必须实现抽象类中的所有抽象方法。\n\n相比较于继承，抽象类可以更优雅的保证多态的特性\n\n\n接口的特性：接口不能包含属性（成员变量）；接口只能声明方法，方法不能包含代码实现；类实现接口的时候，必须实现接口中声明的所有方法。\n\n抽象类更多的是为了代码复用，而接口就更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或契约\n\n用抽象类模拟接口：\nclass Strategy &#123; &#x2F;&#x2F; 用抽象类模拟接口\n  public:\n    ~Strategy();\n    virtual void algorithm()&#x3D;0;&#x2F;&#x2F;virtual相当于abstract\n  protected:\n    Strategy();\n&#125;;\n\npublic class MockInteface &#123;\n    &#x2F;&#x2F;protected修饰构造函数，避免非同包下的类去实例化这个类\n    &#x2F;&#x2F;亦可见Guava包中的@VisibleForTesting\n  protected MockInteface() &#123;&#125;\n  public void funcA() &#123;\n      &#x2F;&#x2F;模拟不包含实现的接口，并且子类必须主动实现父类的方法\n    throw new MethodUnSupportedException();\n  &#125;\n&#125;\n\n\n如何决定该用抽象类还是接口：\n\n需要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类。从设计思路上来看，是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（抽象类）\n需要表示一种has-a的关系，并且是为了解决抽象而非代码复用的问题，我们就用接口。从设计思路上来看，是一种自上而下的设计思路，在编程的时候一般是先设计接口，再去考虑具体的实现。\n\n\n\n\n基于接口VS基于实现\n\n基于接口而不是基于实现编程，可以将接口和实现相分离，封装不稳定的实现细节，暴露稳定的接口，上游系统面向接口而非实现编程，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高扩展性。（越不稳定的系统，越是要在代码的扩展性、维护性上下功夫）\n在软件开发中，最大的挑战之一就是需求的不断变化，越抽象，越顶层，越脱离某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。\n如何做：\n函数的命名不能暴漏任何实现细节\n封装具体的实现细节\n为实现类定义抽象的接口，具体的实现类都依赖统一的接口定义，遵从一致的功能协议，使用者以来接口，而不是具体的实现类来编程。\n\n\n\n\n组合VS继承\n\n组合优先于继承，多用组合少用继承\n\n继承可能过深，继承关系过于复杂会影响到代码的可读性和可维护性，也无法处理特例问题\n\n通过组合、接口、委托三个技术解决继承的问题：针对每种特例实现一个相关接口，再实现一个实现类\npublic interface Flyable &#123;\n  void fly()；\n&#125;\npublic class FlyAbility implements Flyable &#123;\n  @Override\n  public void fly() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n&#x2F;&#x2F;省略Tweetable&#x2F;TweetAbility&#x2F;EggLayable&#x2F;EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable &#123;&#x2F;&#x2F;鸵鸟\n  private TweetAbility tweetAbility &#x3D; new TweetAbility(); &#x2F;&#x2F;组合\n  private EggLayAbility eggLayAbility &#x3D; new EggLayAbility(); &#x2F;&#x2F;组合\n  &#x2F;&#x2F;... 省略其他属性和方法...\n  @Override\n  public void tweet() &#123;\n    tweetAbility.tweet(); &#x2F;&#x2F; 委托\n  &#125;\n  @Override\n  public void layEgg() &#123;\n    eggLayAbility.layEgg(); &#x2F;&#x2F; 委托\n  &#125;\n&#125;\n如何判断改用组合还是继承：继承改写成组合意味着要做细粒度的类的划分，要定义更多的类和接口，增加代码复杂度和维护成本。\n\n如果继承层次低，可以使用继承。\n\n如果只是为了代码复用，则可以使用组合。\n\n如果不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现\n\n\n\n\n\n\n\n\n\n\n3.原型编程（JavaScript）\n定义：面向对象里面要有个 Class。但是 JavaScript 觉得不是这样的，它就是要基于原型编程，就不要 Class，就直接在对象上改就行了，基于编程的修改，直接对类型进行修改\n\n__proto__ 主要是安放在一个实际的对象中，用它来产生一个链接，一个原型链，用于寻找方法名或属性，等等。\nprototype 是用 new 来创建一个对象时构造__proto__ 用的。它是构造函数的一个属性。\n我们可以简单地认为：__proto__ 是所有对象用于链接原型的一个指针，而 prototype 则是 Function 对象的属性，其主要是用来当需要new一个对象时让 __proto__  指针所指向的地方。 对于超级对象 Function 而言， Function.__proto__ 就是 Function.prototype。\n\n\n面向对象\n&#x2F;&#x2F;Define human class\nvar Person &#x3D; function (fullName, email) &#123;\n  this.fullName &#x3D; fullName;\n  this.email &#x3D; email;\n  \n  this.speak &#x3D; function()&#123;\n    console.log(&quot;I speak English!&quot;);\n  &#125;;\n  this.introduction &#x3D; function()&#123;\n    console.log(&quot;Hi, I am &quot; + this.fullName);\n  &#125;;\n&#125;\n\n\n&#x2F;&#x2F;Define Student class\nvar Student &#x3D; function(fullName, email, school, courses) &#123;\n\n  Person.call(this, fullName, email);\n\n  &#x2F;&#x2F; Initialize our Student properties\n  this.school &#x3D; school;\n  this.courses &#x3D; courses;\n  \n  &#x2F;&#x2F; override the &quot;introduction&quot; method\n  this.introduction&#x3D; function()&#123;\n  console.log(&quot;Hi, I am &quot; + this.fullName + \n        &quot;. I am a student of &quot; + this.school + \n        &quot;, I study &quot;+ this.courses +&quot;.&quot;);\n  &#125;;\n  \n  &#x2F;&#x2F; Add a &quot;exams&quot; method\n  this.takeExams &#x3D; function()&#123;\n    console.log(&quot;This is my exams time!&quot;);\n  &#125;;\n&#125;;\n\n\n&#x2F;&#x2F; Create a Student.prototype object that inherits \n&#x2F;&#x2F; from Person.prototype.\nStudent.prototype &#x3D; Object.create(Person.prototype); \n\n&#x2F;&#x2F; Set the &quot;constructor&quot; property to refer to Student\nStudent.prototype.constructor &#x3D; Student;\n\n\n&#x2F;&#x2F;使用\nvar student &#x3D; new Student(&quot;Hao Chen&quot;, \n              &quot;haoel@hotmail.com&quot;,\n              &quot;XYZ University&quot;, \n              &quot;Computer Science&quot;);\nstudent.introduction();   \nstudent.speak();       \nstudent.takeExams(); \n\n&#x2F;&#x2F; Check that instanceof works correctly\nconsole.log(student instanceof Person);  &#x2F;&#x2F; true \nconsole.log(student instanceof Student); &#x2F;&#x2F; true\n\n4.函数式编程（Lisp）\n概念：只关心定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的，即==describe what to do, rather than how to do it==，有以下特点：\n\nstateless：函数不维护任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，打个比方，你给我数据我处理完扔出来。里面的数据是不变的。\nimmutable：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。\n优势：没有状态就没有伤害。并行执行无伤害。Copy-Paste 重构代码无伤害。函数的执行没有顺序上的问题。\n惰性求值：这需要编译器的支持，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。\n确定性：所谓确定性，就是像在数学中那样，f(x) = y 这个函数无论在什么场景下，都会得到同样的结果，而不是像程序中的很多函数那样。同一个参数，在不同的场景下（函数会根据运行中的状态信息的不同而发生变化）会计算出不同的结果，这个我们称之为函数的确定性。\n缺点：数据复制比较严重，但因为没有状态，并发不需要锁，可以提高并发的使用率\n\n\n函数式编程用到的技术\n\nfirst class function（头等函数） ：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改，并当成变量一样传递、返回，或是在函数中嵌套函数。\ntail recursion optimization（尾递归优化） ： 我们知道递归的害处，那就是如果递归很深的话，stack 受不了，并会导致性能大幅度下降。因此，我们使用尾递归优化技术——每次递归时都会重用 stack，这样能够提升性能。当然，这需要语言或编译器的支持。Python 就不支持。\nmap &amp; reduce ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做 Map 和 Reduce 操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用 for/while 循环，然后在各种变量中把数据倒过来倒过去的）这个很像 C++ STL 中 foreach、find_if、count_if 等函数的玩法。\npipeline（管道）：这个技术的意思是，将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。\nrecursing（递归） ：递归最大的好处就是简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。\ncurrying（柯里化） ：将一个函数的多个参数分解成多个函数， 然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。在 C++ 中，这很像 STL 中的 bind1st 或是 bind2nd。\nhigher order function（高阶函数）：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象满天飞一样。这个技术用来做 Decorator 很不错。\n\n\n函数式语言的三套件：Map、Reduce、Filter\n\nPipeline模式：pipeline（管道）借鉴于 Unix Shell 的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。\n\nDecorator（修饰器）模式：\n\nPython的Decorator\n\nPython 的 Decorator 在使用上和 Java 的 Annotation（以及 C# 的 Attribute）很相似，就是在方法名前面加一个 @XXX 注解来为这个方法装饰一些东西。但是，Java/C# 的 Annotation 太过于复杂了，需要先了解一堆 Annotation 的类库文档，几乎就是在学另外一门语言。\n\nPython的@注解语法糖：\n#当用某个 @decorator 来修饰某个函数 func 时（可以带参数）\n@decorator\ndef func():\n    pass\n#解释器会解释成下面这样的语句\nfunc &#x3D; decorator(func)\n#注意：还有一个赋值语句，把 decorator 这个函数的返回值赋值回了原来的 func。\n类方式的decorator：\nclass myDecorator(object):\n    def __init__(self, fn):\n        print &quot;inside myDecorator.__init__()&quot;\n        self.fn &#x3D; fn\n \n    def __call__(self):\n        self.fn()\n        print &quot;inside myDecorator.__call__()&quot;\n \n@myDecorator\ndef aFunction():\n    print &quot;inside aFunction()&quot;\n \nprint &quot;Finished decorating aFunction()&quot;\n \naFunction()\n \n# 输出：\n# inside myDecorator.__init__()\n# Finished decorating aFunction()\n# inside aFunction()\n# inside myDecorator.__call__()\n\n\nGo的Decorator\n\nGo没有修饰器语法糖\npackage main\n\nimport &quot;fmt&quot;\n\nfunc decorator(f func(s string)) func(s string) &#123;\n    return func(s string) &#123;\n        fmt.Println(&quot;Started&quot;)\n        f(s)\n        fmt.Println(&quot;Done&quot;)\n    &#125;\n&#125;\n\nfunc Hello(s string) &#123;\n    fmt.Println(s)\n&#125;\n\nfunc main() &#123;\n    decorator(Hello)(&quot;Hello, World!&quot;)\n&#125;\n\n\n\n\n\n5.泛型编程（C++）\nC 语言\n\nC语言特性：\n\nC 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；\n不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；\nC 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；\nC 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；\nC 语言传递参数一般是以值传递，也可以传递指针；\n通过指针，C 语言可以容易地对内存进行低级控制，然而这加大了编程复杂度；\n编译预处理让 C 语言的编译更具有弹性，比如跨平台。\n\n\nC语言的泛型：\n\n产生原因：通过使用一种更为通用的方式（抽象和隔离），让复杂的“世界”变得简单一些。\n\nC语言中的泛型实现：\n\n函数接口中增加了一个size参数\n函数的实现中使用了memcpy()函数\n函数的实现中使用了一个temp[size]数组\n示例一：\n\n&#x2F;&#x2F;宏定义实现，但会有重复执行的问题\n#define swap(x, y, size) &#123;\\\n  char temp[size]; \\\n  memcpy(temp, &amp;y, size); \\\n  memcpy(&amp;y,   &amp;x, size); \\\n  memcpy(&amp;x, temp, size); \\\n&#125;\n&#x2F;&#x2F;void*实现\nvoid swap(void* x, void* y, size_t size)\n&#123;\n     char tmp[size];\n     memcpy(tmp, y, size);\n     memcpy(y, x, size);\n     memcpy(x, tmp, size);\n&#125;\n\n\n\n示例二：\n\n&#x2F;&#x2F;非泛型\nint search(int* a, size_t size, int target) &#123;\n  for(int i&#x3D;0; i&lt;size; i++) &#123;\n    if (a[i] &#x3D;&#x3D; target) &#123;\n      return i;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n&#x2F;&#x2F;泛型\nint search(void* a, size_t size, void* target, \n  size_t elem_size, int(*cmpFn)(void*, void*) )\n&#123;\n  for(int i&#x3D;0; i&lt;size; i++) &#123;\n    &#x2F;&#x2F; why not use memcmp()\n    &#x2F;&#x2F; use unsigned char * to calculate the address\n    if ( cmpFn ((unsigned char *)a + elem_size * i, target) &#x3D;&#x3D; 0 ) &#123;\n      return i;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n\n\nC语言总结：\n\nC 语言设计目标：提供一种能以简易的方式编译、处理底层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言\nC语言的伟大之处：使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制\nC语言的缺陷：对于更高阶、更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务、更为抽象的语言。\n\n\n\n\nC++语言\n\nC++设计初衷：早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求，C++ 很大程度就是用来解决 C 语言中的各种问题和各种不方便的，如下：\n\n用引用来解决指针的问题。用 namespace 来解决名字空间冲突的问题。\n通过 try-catch 来解决检查返回值编程的问题。\n用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。\n通过重载操作符来达到操作上的泛型。（比如用&gt;&gt;操作符消除printf()的数据类型不够泛型的问题。）通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。\n\n\nC++泛型编程\n\n它通过类的方式来解决：让一个用户自定义的数据类型和内建的那些数据类型一致\n\n类里面会有构造函数、析构函数表示这个类的分配和释放。\n还有它的拷贝构造函数，表示了对内存的复制。\n还有重载操作符，像我们要去比较大于、等于、不等于。\n\n\n通过模板达到类型和算法的妥协：模板很好地取代了 C 时代宏定义带来的问题\n\n模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。\n模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。\n\n\n通过虚函数和运行时类型识别：可以写出基于抽象接口的泛型\n\n虚函数带来的多态在语义上可以支持“同一类”的类型泛型。\n运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。\n\n\n示例：\n\n使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。\n使用一个迭代器来遍历或是操作数据结构内的元素。\n\ntemplate&lt;typename T, typename Iter&gt;\nIter search(Iter pStart, Iter pEnd, T target) \n&#123;\n  for(Iter p &#x3D; pStart; p !&#x3D; pEnd; p++) &#123;\n    if ( *p &#x3D;&#x3D; target ) \n      return p;\n  &#125;\n  return NULL;\n&#125;\n\n\n使用typename T抽象了数据结构中存储数据的类型。\n使用typename Iter，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。\n我们对数据容器的遍历使用了Iter中的++方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。\n在函数的入参上使用了pStart和pEnd来表示遍历的起止。\n使用*Iter来取得这个“指针”的内容。这也是通过重载 * 取值操作符来达到的泛型。\n\n\n迭代器（简易版）：\n\n首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。\n它需要重载一些操作符，比如：取值操作*、成员操作-&gt;、比较操作==和!=，还有遍历操作++，等等。\n然后，还要typedef一些类型，比如value_type，告诉我们容器内的数据的实际类型是什么样子。\n还有一些，如begin()和end()的基本操作。\n我们还可以看到其中有一个pointer _ptr的内部指针来指向当前的数据（注意，pointer就是 T*）。\n\ntemplate &lt;class T&gt;\nclass container &#123;\npublic:\n  class iterator &#123;\n  public:\n    typedef iterator self_type;\n    typedef T   value_type;\n    typedef T*  pointer;\n    typedef T&amp;   reference;\n\n    reference operator*();\n    pointer operator-&gt;();\n    bool operator&#x3D;&#x3D;(const self_type&amp; rhs)；\n    bool operator!&#x3D;(const self_type&amp; rhs)；\n    self_type operator++() &#123; self_type i &#x3D; *this; ptr_++; return i; &#125;\n    self_type operator++(int junk) &#123; ptr_++; return *this; &#125;\n    ...\n    ...\n  private:\n    pointer _ptr;\n  &#125;;\n\n  iterator begin();\n  iterator end();\n  ...\n  ...\n&#125;;\n\n\n\n\n编程语言中的类型系统和泛型编程的本质\n\n类型系统：\n定义：用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。==任何语言都有类型系统，只是动态类型语言在运行时做类型检查==，一旦代码量比较大了，动态类型代码中出现“类型问题”而引发整个程序出错的情况非常多。\n功能：\n程序语言的安全性。使用类型可以让编译器侦测一些代码的错误，如“Hello, World” + 3这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。\n利于编译器的优化。 静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是 int ，那么编译就知道，这个类型会以 4 个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。\n代码的可读性。有类型的编程语言，可以让代码更易读和更易维护，代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。\n抽象化。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。\n\n\n缺点：类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。\n\n\n泛型：\n泛型的定义：屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型\n类型的本质：\n类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。\n不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。\n\n\n泛型的目的：\n标准化掉类型的内存分配、释放和访问。\n标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……\n标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……\n标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……\n\n\nC++实现泛型的技术\n通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。\n通过重载操作符，可以标准化类型的比较等操作。\n通过 iostream，标准化了类型的输入、输出控制。\n通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。\n通过迭代器来标准化数据容器的遍历操作。\n通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。\n通过函数式（函数对象），来标准化对于不同类型的特定操作。\n\n\n\n\n\n\n\n6.委托模式（Go）\n声明一个 struct，跟 C 很一样，然后直接把这个 struct 类型放到另一个 struct 里\n\n3.设计原则\n\n\n\n\n\n\n\n\n一些代码设计的经验总结，重点掌握：设计初衷，解决的编程问题，应用场景\n3.1SOLID原则\n\nSRP单一职责原则：==A class or module should hava a single responsibility==\n\n不要设计大而全的类，要设计粒度小、功能单一的类。也就是说，如果一个类包含了两个或以上业务不相干的功能，那么他的职责就不够单一，应该被拆分成多个功能单一、粒度更细的类。\n要判断职责是否单一，不能脱离具体的应用场景，所以可以先写一个粗粒度的类，满足业务需求，随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个独粒度的类拆分成几个更细粒度的类，这就是所谓的==持续重构==。\n==技巧==：\n类中的代码行数（200行内）、函数或属性过多（少于10个），会影响代码的可读性和可维护性，我们就需要对类进行拆分\n类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要对类进行拆分\n私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性\n比较难给类起一个合适的名字，很难用一个业务名词概括或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义的可能不够清晰\n类中大量的方法都是集中操作类中的某几个属性。\n\n\n\n\nOCP开闭原则：==Software entities(modules,classes,functions) should be open for extension,but closed for modification==\n\n添加一个新功能应该是，在已有的代码基础上扩展代码（新增模块、类、方法等），而非修改已有的代码（修改模块、类、方法等）\n\n指导思想：为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识，这些潜意识可能比任何开发技巧都重要。\n\n==方法==：多态、依赖注入、基于接口而非实现编程、大部分设计模式（装饰、策略、模板、职责链、状态）\n&#x2F;&#x2F;抽象意识\npublic interface MessageQueue&#123;&#x2F;*...*&#x2F;&#125;\npublic class KafkaMessageQueue implements MessageQueue&#123;&#x2F;*...*&#x2F;&#125;\npublic class RocketMQMessageQueue implements MessageQueue&#123;&#x2F;*...*&#x2F;&#125;\n\npublic interface MessageFromatter&#123;&#x2F;*...*&#x2F;&#125;\npublic class JsonMessageFromatter&#123;&#x2F;*...*&#x2F;&#125;\npublic class ProtoBufMessageFromatter&#123;&#x2F;*...*&#x2F;&#125;\n\npublic class Demo&#123;\n    private MessageQueue msgQueue;&#x2F;&#x2F;基于接口而非实现编程\n    public Demo(MessageQueue msgQueue)&#123;&#x2F;&#x2F;依赖注入\n        this.msgQueue &#x3D; msgQueue;\n    &#125;\n    &#x2F;&#x2F;msgFormatter:多态、依赖注入\n    public void senNotification(Notification notification, MessageFormatter msgFormatter)&#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n\nLSP里式替换原则：==子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏==\n\n虽然从定义描述和代码实现上来看，多态和里氏替换有点类似，但他们的关注角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，它是一种代码实现的思路。而里氏替换原则是一种设计原则，是用来直到继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。\n==按照协议来设计==：子类在设计的时候，要遵守父类的行为约定（或协议），父类定义了函数的行为约定，子类可以改变函数内部实现逻辑，但不能改变函数原有的行为约定（函数声明是实现的功能、对输入、输出、异常的约定、注释中所罗列的任何特殊说明）。\n==技巧==：用父类的单元测试来验证子类的代码，如果某些单元测试运行失败，就有可能违背里氏替换原则\n\n\nISP接口隔离原则：==Clients should not be forced to depend upon interfaces that they do not use==\n\n一组API接口集合：在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那么我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。\n单个API接口或函数：函数的设计要功能单一，不要将多个功能逻辑在一个函数中实现。接口隔离原则跟单一职责原则有点类似，但是单一职责原则针对的是模块、类、接口的设计；而接口隔离原则相对于单一职责原则，一方面他更侧重于接口的设计，另一方面它提供了一种判断接口是否职责单一的标准（如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够指责单一）。\nOOP中的接口概念：拆分成小接口，而不是一个大而全的config接口\n\n\nDIP依赖倒置原则：==High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.（高层模块和低层模块的划分就是，在调用链上，调用者属于高层，被调用者属于低层）==\n\n控制反转（IOC）：\n&#x2F;&#x2F;所有的流程都由程序员来控制\npublic class UserServiceTest&#123;\n    public static boolean doTest()&#123;\n        &#x2F;&#x2F;...\n    &#125;\n    public static void main(String[] args)&#123;&#x2F;&#x2F;这部分逻辑可以放到框架中\n        if(doTest()) &#123;\n            System.out.println(&quot;Test succeed.&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;Test failed.&quot;);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用\n&#x2F;&#x2F;框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可\n&#x2F;&#x2F;以利用框架来驱动整个程序流程的执行。这里的“控制”指的是对程序执行流程的控制，\n&#x2F;&#x2F;而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架\n&#x2F;&#x2F;之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了\n&#x2F;&#x2F;框架。\npublic abstract class TestCase &#123;\n  public void run() &#123;\n    if (doTest()) &#123;\n      System.out.println(&quot;Test succeed.&quot;);\n    &#125; else &#123;\n      System.out.println(&quot;Test failed.&quot;);\n    &#125;\n  &#125;\n  \n  public abstract boolean doTest();\n&#125;\n\npublic class JunitApplication &#123;\n  private static final List&lt;TestCase&gt; testCases &#x3D; new ArrayList&lt;&gt;();\n  \n  public static void register(TestCase testCase) &#123;\n    testCases.add(testCase);\n  &#125;\n  \n  public static final void main(String[] args) &#123;\n    for (TestCase case: testCases) &#123;\n      case.run();\n    &#125;\n  &#125;\n&#125;\n    \npublic class UserServiceTest extends TestCase &#123;\n  @Override\n  public boolean doTest() &#123;\n    &#x2F;&#x2F; ... \n  &#125;\n&#125;\n\n&#x2F;&#x2F; 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n\n依赖注入（DI）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用\n&#x2F;&#x2F;Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、\n&#x2F;&#x2F;验证码等消息给用户\n\n&#x2F;&#x2F; 非依赖注入实现方式\npublic class Notification &#123;\n  private MessageSender messageSender;\n  \n  public Notification() &#123;\n    this.messageSender &#x3D; new MessageSender(); &#x2F;&#x2F;此处有点像hardcode\n  &#125;\n  \n  public void sendMessage(String cellphone, String message) &#123;\n    &#x2F;&#x2F;...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  &#125;\n&#125;\n\npublic class MessageSender &#123;\n  public void send(String cellphone, String message) &#123;\n    &#x2F;&#x2F;....\n  &#125;\n&#125;\n&#x2F;&#x2F; 使用Notification\nNotification notification &#x3D; new Notification();\n\n&#x2F;&#x2F; 依赖注入的实现方式\npublic class Notification &#123;\n  private MessageSender messageSender;\n  \n  &#x2F;&#x2F; 通过构造函数将messageSender传递进来\n  &#x2F;&#x2F; 通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性,\n  &#x2F;&#x2F; 我们可以灵活地替换依赖的类。\n  public Notification(MessageSender messageSender) &#123;\n    this.messageSender &#x3D; messageSender;\n  &#125;\n  \n  public void sendMessage(String cellphone, String message) &#123;\n    &#x2F;&#x2F;...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  &#125;\n&#125;\n&#x2F;&#x2F;使用Notification\nMessageSender messageSender &#x3D; new MessageSender();\nNotification notification &#x3D; new Notification(messageSender);\n依赖注入框架（DI Framework）：\n\n在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。\n如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。\n我们只需要通过依赖注入框架提供的扩展点，简单==配置==一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现==由框架来自动创建对象、管理对象的生命周期、依赖注入==等原本需要程序员来做的事情\n\npublic class Demo &#123;\n  public static final void main(String args[]) &#123;\n    MessageSender sender &#x3D; new SmsSender(); &#x2F;&#x2F;创建对象\n    Notification notification &#x3D; new Notification(sender);&#x2F;&#x2F;依赖注入\n    notification.sendMessage(&quot;13918942177&quot;, &quot;短信验证码：2346&quot;);\n  &#125;\n&#125;\n依赖反转原则（DIP）：\n\n\n\n\n3.2其它原则\nKISS原则：==尽量保持简单==\n\n不要使用同事可能不懂的技术来实现代码，例如正则表达式或编程语言中的高级语法\n不要重复造轮子，要善于使用已经有的工具类库\n不要过度优化，不要过度使用一些奇技淫巧（位运算、复杂条件语句、过于底层函数）来优化代码，牺牲代码的可读性\n\n\nYAGNI原则：==You ain’t gonna need it 你不会需要它==，不要去设计当前用不到的功能，不要去编写当前用不到的代码，即不要过度设计，只需要预留好扩展点。\n\nDRY原则：==Don’t repeat yourself==，不要写重复的代码。\n\n实现逻辑重复：尽管代码的实现逻辑是重复的，但是语义上不是重复的，可以判定它并不违反DRY原则\n功能语义重复：实现逻辑不重复，但语义重复，那么也就是功能重复，我们认为它违反了DRY原则\n代码执行重复：例如对输入校验了两次\n\n\nLOD原则（Law of Demeter）：==Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.==\n\n高内聚，松耦合：\n\n高内聚：用来指导类本身的设计，相近的功能应该放到同一个类中，不想近的功能不要放到同一个类中，相近的功能往往会被同时更改，放到一个类中，代码容易维护\n低耦合：用来指导类与类之间依赖关系的设计，在代码中，类与类之间的依赖关系应该简单清晰，一个类的代码改动不会或者很少导致依赖类的代码改动\n\n\n迪米特法则\n\n\n\n\n3.3代码复用性\n代码复用性：\n代码复用：表示一种行为：开发新功能的时候，尽量复用已经存在的代码\n代码的可复用性：表示一段代码可被复用的特性或能力\nDRY原则：是一条原则，不要写重复的代码，但不重复不代表可复用\n\n\n==提高代码复用性的手段==：\n减少代码耦合：将某个功能的代码抽取出来成为一个独立的模块、类或函数\n满足单一职责原则：越细粒度的代码，代码的通用性越好\n模块化：要善于将功能独立的代码封装成模块\n业务与非业务逻辑分离：将业务与非业务代码抽离，抽取成通用的框架、类库、组件等\n通用代码下沉：代码分层之后，只允许上层调用下层，不允许下层调用上层\n继承、多态、抽象、封装：利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。\n应用模板等设计模式：一些设计模式，也能提高代码的复用性\n\n\n==Rule of Three==：除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。当遇到复用场景的时候，再进行重构使其复用\n\n3.4实战：系统设计\n需求分析：借鉴已有的系统，调研用户用例\n系统设计：\n合理将功能划分到不同模块\n设计模块与模块之间的交互关系\n设计模块的接口、数据库、业务模型\n\n\n为什么要使用MVC分层\n代码复用\n隔离变化\n隔离关注点，每层职责分明\n提高代码的可测试性\n应对系统的复杂性：当一个类过于庞大，我们就要基于业务做水平化（模块化）拆分，或者基于流程做垂直化（分层）拆分\n\n\nBO、VO、Entity存在的意义\n相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？\nVO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。\nVO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。\n为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！\n\n\n既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？\n将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段\n将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码\n\n\n代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢\nJava 中提供了多种数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作\n\n\nVO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？\n前面我们也提到过，Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的 Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。\n不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。\n\n\n\n\n\n3.5实战：框架设计\n划分功能性需求和非功能性需求，并且划分模块\n小步快跑，逐步迭代，TDD+Protoytpe：先聚焦一个简单的应用场景，基于此设计实现一个简单的模型\n面向对象设计和实现要做的事情，==就是把合适的代码放到合适的类中==（当要实现某个功能的时候，不管如何设计，所需要编写的代码量基本上是一样的，唯一的区别就是如何将这些代码划分到不同的类中。不同的人有不同的划分方法，对应得到的代码结构也不尽相同，比如类与类之间交互等）\n划分职责进而识别出有哪些类\n根据设计模式，定义类及类之间的关系\n将类组装起来并提供执行入口\n\n\n\n4.编程规范与代码重构\n\n\n\n\n\n\n\n\n《代码大全》、《代码整洁之道》、《重构》\n1.代码重构\n重构：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更容易理解，修改成本更低\n目的（why）：\n保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步\n优秀的代码和架构都是迭代出来的，无法从一开始就完全设计好\n重构是避免过度设计的有效手段，真正遇到问题时，在对代码进行重构\n重构是对设计思想、设计原则、设计模式、编程规范的一种应用\n\n\n对象（what）：\n大规模高层次重构：对顶层设计的重构，包括系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等\n小规模低层次重构：对代码细节的重构，主要针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等。\n\n\n时机（when）：\n可持续、可演进的方式，就像把单元测试、Code Review作为开发的一部分，也把持续重构作为开发的一部分，时刻保持重构意识\n\n\n方法（how）：\n对于大型重构，要提前做好完善的重构计划，分阶段进行，每个阶段完成一小部分代码的重构，然后提交、测试、运行，没有问题后在进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态\n小规模重构，因为影响范围小，改动耗时短，所以，随时都可以做\n\n\n\n\n保证重构不出错的技术手段：单元测试\n单元测试：有研发工程师自己来编写，用来测试自己写的代码的正确性，常用来测试一个类和函数是否都按照预期的逻辑执行，主要考研程序员思维的缜密程度\n单元测试的好处\n单元测试能有效地帮你发现代码中的bug\n写单元测试能帮你发现代码设计上的问题：如果单元测试写起来吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计的不够合理\n单元测试是对集成测试的有力补充\n写单元测试的过程本身就是代码重构的过程（自我Code Review）\n阅读单元测试能帮助你快速熟悉代码\n单元测试是TDD可落地执行的改进方案\n\n\n如何编写单元测试：\n针对代码设计覆盖各种输入、异常、边界条件的测试用例，然后将这些测试用例翻译成代码\n可以使用Junit、Spring Test等测试框架，JaCoCo、Cobertura等工具来做单元测试覆盖率统计\n不可以为了追求测试覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试，否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，原有的单元测试都会运行失败\n\n\n\n\n代码的可测试性：\n单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的基层测试，不应该需要测试依赖的外部系统\nmock：如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网路通信、文件系统等，那么就需要将被测试代码与外部系统解依赖，这种解依赖的方法就叫做mock，就是用一个“假”的服务替换真正的服务，其中mock的服务完全在我们的控制之下，模拟输出我们想要的数据。\n框架mock\n手动mock：通过继承并重写依赖类\n\n\n==提高代码的可测试性的手段==\n依赖注入而不是new的方式，可以很容易利用手动mock来测试\n\n\nAnti-Patterns：\n未决行为：代码的输出是随机或者说不确定的，比如跟时间、随机数有关的代码\n全局变量：全局变量时面向过程的编程风格，滥用会让编写单元测试变得困难\n静态方法：同全局变量一样，因为静态方法很难mock，但只有静态方法耗时太长，依赖外部资源，逻辑复杂，行为未决等情况下，我们才需要在单元测试中mock这个方法\n复杂继承：如果父类需要mock某个依赖对象，那么所有子类也都需要\n高耦合代码：如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试时，就需要mock这十几个以来的对象\n\n\n\n\n解耦\n降低代码的复杂性，保证代码松耦合、高内聚，保证代码不至于复杂到无法控制的有效手段，将依赖关系画出来，根据依赖关系来判断是否需要解耦重构\n解耦的方法：\n封装和抽象：例如Unix系统提供的open()文件操作函数\n中间层：简化依赖关系，使其都依赖中间层；在重构时，可以起到过渡的作用，让开发和重构同步进行\n模块化：构建复杂系统常用的手段，\n其他设计思想和原则：\n单一职责原则：减少依赖此类的其他类数量\n基于接口而非实现编程：有依赖关系的两个类之间，一个类的改动不会影响到另一个模块或类\n依赖注入：将代码之间的强耦合变为弱耦合，容易做到插拔替换\n多用组合少用继承：继承是一种强依赖关系，利用组合来替换继承，可以解耦\n迪米特法则：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口\n\n\n\n\n\n\n\n2.20条编程规范\n命名\n\n命名多长最合适：\n\n在足够表达含义的情况下，命名应当越短越好\n对于一些默认的，可以使用缩写，例如：sec-second、str-string、num-number、doc-document\n对于一些作用域比较小的变量，可以使用相对短的命名，比如函数内的临时变量\n\n\n利用上下文简化命名：\nUser user &#x3D; new User();\nuser.getName(); &#x2F;&#x2F; 借助user对象这个上下文\n\npublic void uploadUserAvatarImageToAliyun(String userAvatarImageUri);\n&#x2F;&#x2F;利用上下文简化为：\npublic void uploadUserAvatarImageToAliyun(String imageUri);\n命名要可读、可搜索：\n\n不使用一些生僻、难发音的英文单词来命名\nIDE中经常会用“关键词联想”的方法来自动补全和搜索，例如：大家都用selectXXX表示查询，那么就不要用queryXXX；大家都用insertXXX表示插入，那么就不要用addXXX\n\n\n如何命名接口和抽象类：\n\n对于接口的命名，一种是加前缀“I”，或者加后缀“Impl”\n对于抽象类的命名，可以加前缀“Abstract”\n\n\n\n\n注释\n\n注释到底该写什么：\n注释的目的是让代码更容易看懂，主要包括三方面：做什么、为什么、怎么做\n对于复杂的类，可以包括如何用，还可以写一些总结性的说明来让代码结构更清晰、更有条理\n\n\n注释是不是越多越好：\n类和函数一定要写注释、而且要写的尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性\n\n\n\n\n代码风格\n\n函数、类多大才合适：函数一屏内，类200行内\n一行代码多长最合适：一行代码最长不能超过IDE现实的宽度\n善用空行分割单元块：让代码结构更清晰、更有条理\n==四行缩进还是两格缩进==：==不要用tab缩进==，因为不同IDE下，tab键的显示宽度不同\n大括号是否要另起一行：同团队\n类中成员的排列顺序：\n依赖类按照字母序列从小到大排列\n在类中，成员变量排在函数的前面，成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通”的方式来排列，成员变量之间或函数之间，按照作用域范围从小到大的顺序来排列（先public，然后protected，最后private）\n\n\n\n\n编程技巧\n\n把代码分割成更小的单元块：\n\n当代码逻辑比较复杂的时候，可以提炼类或函数，让阅读代码的人不至于迷失在细节中\n\n&#x2F;&#x2F; 重构前的代码\npublic void invest(long userId, long financialProductId) &#123;\n  Calendar calendar &#x3D; Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) &#x3D;&#x3D; 1) &#123;\n    return;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：提炼函数之后逻辑更加清晰\npublic void invest(long userId, long financialProductId) &#123;\n  if (isLastDayOfMonth(new Date())) &#123;\n    return;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;\n\npublic boolean isLastDayOfMonth(Date date) &#123;\n  Calendar calendar &#x3D; Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) &#x3D;&#x3D; 1) &#123;\n   return true;\n  &#125;\n  return false;\n&#125;\n避免函数参数过多：参数不宜多于4个\n\n考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数\n\npublic User getUser(String username, String telephone, String email);\n\n&#x2F;&#x2F; 拆分成多个函数\npublic User getUserByUsername(String username);\npublic User getUserByTelephone(String telephone);\npublic User getUserByEmail(String email);\n\n\n\n\n将函数的参数封装成对象\n\npublic void postBlog(String title, String summary, String keywords, String content, String category, long authorId);\n\n&#x2F;&#x2F; 将参数封装成对象\npublic class Blog &#123;\n  private String title;\n  private String summary;\n  private String keywords;\n  private Strint content;\n  private String category;\n  private long authorId;\n&#125;\npublic void postBlog(Blog blog);\n勿用函数参数来控制逻辑：\n\n不要在函数中使用布尔类型的标识参数来控制内部逻辑，而是应该拆成两个函数，可读性上也要更好，但若经常一起调用，则可以选择不拆\n\npublic void buyCourse(long userId, long courseId, boolean isVip);\n\n&#x2F;&#x2F; 将其拆分成两个函数\npublic void buyCourse(long userId, long courseId);\npublic void buyCourseForVip(long userId, long courseId);\n\n\n遇到根据参数是否为 null来控制逻辑的情况，我们也应该将其拆分成多个函数\n\npublic List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;\n  if (startDate !&#x3D; null &amp;&amp; endDate !&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询两个时间区间的transactions\n  &#125;\n  if (startDate !&#x3D; null &amp;&amp; endDate &#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询startDate之后的所有transactions\n  &#125;\n  if (startDate &#x3D;&#x3D; null &amp;&amp; endDate !&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询endDate之前的所有transactions\n  &#125;\n  if (startDate &#x3D;&#x3D; null &amp;&amp; endDate &#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询所有的transactions\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 拆分成多个public函数，更加清晰、易用\npublic List&lt;Transaction&gt; selectTransactionsBetween(Long userId, Date startDate, Date endDate) &#123;\n  return selectTransactions(userId, startDate, endDate);\n&#125;\n\npublic List&lt;Transaction&gt; selectTransactionsStartWith(Long userId, Date startDate) &#123;\n  return selectTransactions(userId, startDate, null);\n&#125;\n\npublic List&lt;Transaction&gt; selectTransactionsEndWith(Long userId, Date endDate) &#123;\n  return selectTransactions(userId, null, endDate);\n&#125;\n\npublic List&lt;Transaction&gt; selectAllTransactions(Long userId) &#123;\n  return selectTransactions(userId, null, null);\n&#125;\n\nprivate List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;\n  &#x2F;&#x2F; ...\n&#125;\n函数设计要职责单一：\npublic boolean checkUserIfExisting(String telephone, String username, String email)  &#123; \n  if (!StringUtils.isBlank(telephone)) &#123;\n    User user &#x3D; userRepo.selectUserByTelephone(telephone);\n    return user !&#x3D; null;\n  &#125;\n  \n  if (!StringUtils.isBlank(username)) &#123;\n    User user &#x3D; userRepo.selectUserByUsername(username);\n    return user !&#x3D; null;\n  &#125;\n  \n  if (!StringUtils.isBlank(email)) &#123;\n    User user &#x3D; userRepo.selectUserByEmail(email);\n    return user !&#x3D; null;\n  &#125;\n  \n  return false;\n&#125;\n\n&#x2F;&#x2F; 拆分成三个函数\npublic boolean checkUserIfExistingByTelephone(String telephone);\npublic boolean checkUserIfExistingByUsername(String username);\npublic boolean checkUserIfExistingByEmail(String email);\n==移除过深的嵌套层次==：\n\n代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁。\n\n解决方法：\n\n去掉多余的 if 或 else 语句\n\n&#x2F;&#x2F; 示例一\npublic double caculateTotalAmount(List&lt;Order&gt; orders) &#123;\n  if (orders &#x3D;&#x3D; null || orders.isEmpty()) &#123;\n    return 0.0;\n  &#125; else &#123; &#x2F;&#x2F; 此处的else可以去掉\n    double amount &#x3D; 0.0;\n    for (Order order : orders) &#123;\n      if (order !&#x3D; null) &#123;\n        amount +&#x3D; (order.getCount() * order.getPrice());\n      &#125;\n    &#125;\n    return amount;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 示例二\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;\n    for (String str : strList) &#123;\n      if (str !&#x3D; null) &#123; &#x2F;&#x2F; 跟下面的if语句可以合并在一起\n        if (str.contains(substr)) &#123;\n          matchedStrings.add(str);\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;\n\n\n\n\n使用编程语言提供的 continue、break、return 关键字，提前退出嵌套\n\n&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null)&#123; \n    for (String str : strList) &#123;\n      if (str !&#x3D; null &amp;&amp; str.contains(substr)) &#123;\n        matchedStrings.add(str);\n        &#x2F;&#x2F; 此处还有10行代码...\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：使用continue提前退出\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null)&#123; \n    for (String str : strList) &#123;\n      if (str &#x3D;&#x3D; null || !str.contains(substr)) &#123;\n        continue; \n      &#125;\n      matchedStrings.add(str);\n      &#x2F;&#x2F; 此处还有10行代码...\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;\n\n\n\n\n调整执行顺序来减少嵌套\n\n&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;\n    for (String str : strList) &#123;\n      if (str !&#x3D; null) &#123;\n        if (str.contains(substr)) &#123;\n          matchedStrings.add(str);\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：先执行判空逻辑，再执行正常逻辑\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  if (strList &#x3D;&#x3D; null || substr &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;先判空\n    return Collections.emptyList();\n  &#125;\n\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  for (String str : strList) &#123;\n    if (str !&#x3D; null) &#123;\n      if (str.contains(substr)) &#123;\n        matchedStrings.add(str);\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;\n\n\n\n\n将部分嵌套逻辑封装成函数调用，以此来减少嵌套:\n\n&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) &#123;\n  if (passwords &#x3D;&#x3D; null || passwords.isEmpty()) &#123;\n    return Collections.emptyList();\n  &#125;\n  \n  List&lt;String&gt; passwordsWithSalt &#x3D; new ArrayList&lt;&gt;();\n  for (String password : passwords) &#123;\n    if (password &#x3D;&#x3D; null) &#123;\n      continue;\n    &#125;\n    if (password.length() &lt; 8) &#123;\n      &#x2F;&#x2F; ...\n    &#125; else &#123;\n      &#x2F;&#x2F; ...\n    &#125;\n  &#125;\n  return passwordsWithSalt;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：将部分逻辑抽成函数\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) &#123;\n  if (passwords &#x3D;&#x3D; null || passwords.isEmpty()) &#123;\n    return Collections.emptyList();\n  &#125;\n\n  List&lt;String&gt; passwordsWithSalt &#x3D; new ArrayList&lt;&gt;();\n  for (String password : passwords) &#123;\n    if (password &#x3D;&#x3D; null) &#123;\n      continue;\n    &#125;\n    passwordsWithSalt.add(appendSalt(password));\n  &#125;\n  return passwordsWithSalt;\n&#125;\n\nprivate String appendSalt(String password) &#123;\n  String passwordWithSalt &#x3D; password;\n  if (password.length() &lt; 8) &#123;\n    &#x2F;&#x2F; ...\n  &#125; else &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n  return passwordWithSalt;\n&#125;\n\n\n学会使用解释性变量：\n\n常量取代魔法数字\n\npublic double CalculateCircularArea(double radius) &#123;\n  return (3.1415) * radius * radius;\n&#125;\n\n&#x2F;&#x2F; 常量替代魔法数字\npublic static final Double PI &#x3D; 3.1415;\npublic double CalculateCircularArea(double radius) &#123;\n  return PI * radius * radius;\n&#125;\n\n\n\n\n使用解释性变量来解释复杂表达式\n\nif (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;\n  &#x2F;&#x2F; ...\n&#125; else &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\n&#x2F;&#x2F; 引入解释性变量后逻辑更加清晰\nboolean isSummer &#x3D; date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);\nif (isSummer) &#123;\n  &#x2F;&#x2F; ...\n&#125; else &#123;\n  &#x2F;&#x2F; ...\n&#125; \n\n\n\n3.实战：ID生成器\n如何发现代码质量问题：看这段代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等等，落实到具体细节：\n\n目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？\n是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？\n设计模式是否应用得当？是否有过度设计？\n代码是否容易扩展？如果要添加新功能，是否容易实现？\n代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？\n代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？\n代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？\n\n\n代码实现是否满足业务本身特有的功能和非功能需求：\n\n代码是否实现了预期的业务需求？\n逻辑是否正确？是否处理了各种异常情况？\n日志打印是否得当？是否方便 debug 排查问题？\n接口是否易用？是否支持幂等、事务等？\n代码是否存在并发问题？是否线程安全（共享变量）？\n性能是否有优化空间，比如，SQL、算法是否可以优化，是否可以不调用外部存储？\n是否有安全漏洞？比如输入输出校验是否全面？\n\n\n函数出错应该返回什么\n\n出错码：\n\nC语言没有异常的语法机制，所以通常返回错误码；而在Python和Java中大多使用异常来处理函数出错的情况\nC语言中有两种方式：\n直接占用函数的返回值，函数正常执行的返回值放到出参中\n将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码\n实际上，如果编程语言中有异常这种语法机制，就尽量不要使用错误码。异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息（exception 中可以有 message、stack trace 等信息）等\n\n\n\n\nNULL值\n\n在多数编程语言中，我们用 NULL 来表示“不存在”这种语义。但这是一种不好的设计思路，主要的理由有，使用时如果忘记做NULL值判断就可能会抛出空指针异常；或者代码有可能充斥着大量的NULL值判断逻辑影响代码的可读性\n某些时候NULL值不是异常而是正常情况，也可以用-1替换，代表数据不存在或没查找到\n\n\n空对象\n\n空对象设计模式（Null Object Design Pattern）\n空字符串、空集合：\n当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断。\n\n\n\n\n异常对象：\n\n运行时异常（Runtime Exception）\n\n对于运行时异常，我们在编写代码的时候，可以不用主动去 try-catch，编译器在编译代码的时候，并不会检查代码是否有对运行时异常做了处理。运行时异常也叫作非受检异常（Unchecked Exception）\n对于代码 bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以，我们倾向于使用非受检异常。\n\n\n编译时异常（Compile Exception）\n\n对于编译时异常，我们在编写代码的时候，需要主动去 try-catch 或者在函数定义中声明，否则编译就会报错，编译时异常也叫作受检异常（Checked Exception）\n对于可恢复异常、业务异常，比如提现金额大于余额的异常，我们更倾向于使用受检异常，明确告知调用者需要捕获处理。\n\n\n如何处理函数抛出的异常\n\n直接吞掉：如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 内将 func1() 抛出的异常吞掉\n原封不动re-throw：如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw\n包装成新的异常re-throw：如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw\n\n==总之，是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出。==\n\n\n\n\n\n\n4.实战：框架设计重构5.设计模式\n\n1.创建型设计模式1.单例模式\n概念：一个类在同一进程内只允许创建一个对象（或实例），那这个类就是一个单例类\n\n使用场景：\n\n处理资源访问冲突\n表示全局唯一类：配置信息类、ID生成器\n\n\n实现重点：\n\n构造函数是 private 的，避免外部通过 new 创建实例；\n考虑对象创建时的线程安全问题；\n考虑是否支持延迟加载（饿汉/懒汉）；\n考虑 getInstance() 性能是否高（是否加锁）。\n\n\n实现方式：\n\n饿汉式：在类加载时就创建并初始化好，线程安全，但不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例）\npublic class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private static final IdGenerator instance &#x3D; new IdGenerator();\n  private IdGenerator() &#123;&#125;\n  public static IdGenerator getInstance() &#123;\n    return instance;\n  &#125;\n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;\n懒汉式：支持延迟加载，但通过加锁使得并发度很低（并发度为1），如果频繁使用，因锁的消耗会导致性能瓶颈\npublic class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() &#123;&#125;\n  public static synchronized IdGenerator getInstance() &#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n      instance &#x3D; new IdGenerator();\n    &#125;\n    return instance;\n  &#125;\n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;\n双重检测：既支持延迟加载又支持高并发，有指令重排序相关问题（IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了），但高版本Java已解决\npublic class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() &#123;&#125;\n  public static IdGenerator getInstance() &#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n      synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁\n        if (instance &#x3D;&#x3D; null) &#123;\n          instance &#x3D; new IdGenerator();\n        &#125;\n      &#125;\n    &#125;\n    return instance;\n  &#125;\n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;\n静态内部类：SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。（Basic Syntax/语法/关键字/static有解释）\npublic class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private IdGenerator() &#123;&#125;\n\n  private static class SingletonHolder&#123;\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n  &#125;\n  \n  public static IdGenerator getInstance() &#123;\n    return SingletonHolder.instance;\n  &#125;\n \n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;\n枚举：通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性\npublic enum IdGenerator &#123;\n  INSTANCE;\n  private AtomicLong id &#x3D; new AtomicLong(0);\n \n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;\n线程唯一单例的实现（ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap）：\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n\n    private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances\n        &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    private IdGenerator() &#123;&#125;\n\n    public static IdGenerator getInstance() &#123;\n        Long currentThreadId &#x3D; Thread.currentThread().getId();\n        instances.putIfAbsent(currentThreadId, new IdGenerator());\n        return instances.get(currentThreadId);\n    &#125;\n\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;\n集群唯一单例实现：\n\n不同的进程间共享同一个对象，不能创建同一个类的多个对象。\n我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。\n为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。\n\npublic class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);\n    private static DistributedLock lock &#x3D; new DistributedLock();\n\n    private IdGenerator() &#123;&#125;\n\n    public synchronized static IdGenerator getInstance() \n        if (instance &#x3D;&#x3D; null) &#123;\n            lock.lock();\n            instance &#x3D; storage.load(IdGenerator.class);\n        &#125;\n    return instance;\n&#125;\n\npublic synchroinzed void freeInstance() &#123;\n    storage.save(this, IdGeneator.class);\n    instance &#x3D; null; &#x2F;&#x2F;释放对象\n    lock.unlock();\n&#125;\n\npublic long getId() &#123; \n    return id.incrementAndGet();\n&#125;\n&#125;\n\n&#x2F;&#x2F; IdGenerator使用举例\nIdGenerator idGeneator &#x3D; IdGenerator.getInstance();\nlong id &#x3D; idGenerator.getId();\nidGenerator.freeInstance();\n多例模式：\npublic class BackendServer &#123;\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT &#x3D; 3;\n  private static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\n\n  static &#123;\n    serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n    serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n    serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n  &#125;\n\n  private BackendServer(long serverNo, String serverAddress) &#123;\n    this.serverNo &#x3D; serverNo;\n    this.serverAddress &#x3D; serverAddress;\n  &#125;\n\n  public BackendServer getInstance(long serverNo) &#123;\n    return serverInstances.get(serverNo);\n  &#125;\n\n  public BackendServer getRandomInstance() &#123;\n    Random r &#x3D; new Random();\n    int no &#x3D; r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  &#125;\n&#125;\n&#x2F;&#x2F;同一类型的只能创建一个对象，不同类型的可以创建多个对象。\npublic class Logger &#123;\n  private static final ConcurrentHashMap&lt;String, Logger&gt; instances\n          &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n  private Logger() &#123;&#125;\n\n  public static Logger getInstance(String loggerName) &#123;\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  &#125;\n\n  public void log() &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);\n\n\n单例有哪些问题\n\n单例对 OOP 特性的支持不友好：因为需要硬编码，在更改实现时需要把每一处都替换掉\n\n单例会隐藏类之间的依赖关系：单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。\n\n单例对代码的扩展性不友好：如果需要创建两个单例类，需要对代码做较大改动\n\n单例对代码的可测试性不友好：单例类这种硬编码式的使用方式，无法实现 mock 替换依赖的外部资源。\n\n单例不支持有参数的构造函数：有以下解决方案：\n\n创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n\n    public static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            throw new RuntimeException(&quot;Run init() first.&quot;);\n        &#125;\n        return instance;\n    &#125;\n\n    public synchronized static Singleton init(int paramA, int paramB) &#123;\n        if (instance !&#x3D; null)&#123;\n            throw new RuntimeException(&quot;Singleton has been created!&quot;);\n        &#125;\n        instance &#x3D; new Singleton(paramA, paramB);\n        return instance;\n    &#125;\n&#125;\n\nSingleton.init(10, 50); &#x2F;&#x2F; 先init，再使用\nSingleton singleton &#x3D; Singleton.getInstance();\n将参数放到 getIntance() 方法中\npublic class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n\n    public synchronized static Singleton getInstance(int paramA, int paramB) &#123; \n        if (instance &#x3D;&#x3D; null) &#123; \n            instance &#x3D; new Singleton(paramA, paramB); \n        &#125; else if (instance.paramA &#x3D;&#x3D; paramA &amp;&amp; instance.paramB &#x3D;&#x3D; paramB) &#123;\n            return instance;\n        &#125; else &#123;\n            instance &#x3D; new Singleton(paramA, paramB);\n        &#125;\n        return instance; \n    &#125;\n&#125;\n\nSingleton singleton &#x3D; Singleton.getInstance(10, 50);\n将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。\npublic class Config &#123;\n  public static final int PARAM_A &#x3D; 123;\n  public static final int PARAM_B &#x3D; 245;\n&#125;\n\npublic class Singleton &#123;\n  private static Singleton instance &#x3D; null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() &#123;\n    this.paramA &#x3D; Config.PARAM_A;\n    this.paramB &#x3D; Config.PARAM_B;\n  &#125;\n\n  public synchronized static Singleton getInstance() &#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n      instance &#x3D; new Singleton();\n    &#125;\n    return instance;\n  &#125;\n&#125;\n\n\n\n\n有何替代的解决方案：\n\n将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。\n\n&#x2F;&#x2F; 1. 老的使用方式\npublic demofunction() &#123;\n  &#x2F;&#x2F;...\n  long id &#x3D; IdGenerator.getInstance().getId();\n  &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) &#123;\n  long id &#x3D; idGenerator.getId();\n&#125;\n&#x2F;&#x2F; 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator &#x3D; IdGenerator.getInsance();\ndemofunction(idGenerator);\n\n\n工厂模式\nIOC容器\n\n\n\n2.工厂模式\n简单工厂：直接将创建代码拿出来\n&#x2F;&#x2F;重构前\npublic class RuleConfigSource &#123;\n    public RuleConfig load(String ruleConfigFilePath) &#123;\n        String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n        IRuleConfigParser parser &#x3D; null;\n        if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new JsonRuleConfigParser();\n        &#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new XmlRuleConfigParser();\n        &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new YamlRuleConfigParser();\n        &#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new PropertiesRuleConfigParser();\n        &#125; else &#123;\n            throw new InvalidRuleConfigException(\n                &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n        &#125;\n\n        String configText &#x3D; &quot;&quot;;\n        &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n        RuleConfig ruleConfig &#x3D; parser.parse(configText);\n        return ruleConfig;\n    &#125;\n\n    private String getFileExtension(String filePath) &#123;\n        &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n        return &quot;json&quot;;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;重构后\npublic class RuleConfigSource &#123;\n    public RuleConfig load(String ruleConfigFilePath) &#123;\n        String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n        IRuleConfigParser parser &#x3D; RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n        if (parser &#x3D;&#x3D; null) &#123;\n            throw new InvalidRuleConfigException(\n                &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n        &#125;\n\n        String configText &#x3D; &quot;&quot;;\n        &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n        RuleConfig ruleConfig &#x3D; parser.parse(configText);\n        return ruleConfig;\n    &#125;\n\n    private String getFileExtension(String filePath) &#123;\n        &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n        return &quot;json&quot;;\n    &#125;\n&#125;\n&#x2F;&#x2F;第一种实现\npublic class RuleConfigParserFactory &#123;\n    public static IRuleConfigParser createParser(String configFormat) &#123;\n        IRuleConfigParser parser &#x3D; null;\n        if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new JsonRuleConfigParser();\n        &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new XmlRuleConfigParser();\n        &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new YamlRuleConfigParser();\n        &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new PropertiesRuleConfigParser();\n        &#125;\n        return parser;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;第二种实现：为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来\npublic class RuleConfigParserFactory &#123;\n    private static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n        cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n        cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n        cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n    &#125;\n\n    public static IRuleConfigParser createParser(String configFormat) &#123;\n        if (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;\n            return null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算\n        &#125;\n        IRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());\n        return parser;\n    &#125;\n&#125;\n工厂方法：利用多态去掉if分支（实现接口），利用工厂的工厂来简化使用（RuleConfigParserFactoryMap）。新增一种Parser只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类，将新的 parser factory 对象添加到 cachedFactories 中即可即可，符合开闭原则\npublic interface IRuleConfigParserFactory &#123;\n    IRuleConfigParser createParser();\n&#125;\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createParser() &#123;\n        return new JsonRuleConfigParser();\n    &#125;\n&#125;\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createParser() &#123;\n        return new XmlRuleConfigParser();\n    &#125;\n&#125;\n&#x2F;&#x2F;省略YamlRuleConfigParserFactory，PropertiesRuleConfigParserFactory\n\npublic class RuleConfigSource &#123;\n    public RuleConfig load(String ruleConfigFilePath) &#123;\n        String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\n        IRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n        if (parserFactory &#x3D;&#x3D; null) &#123;\n            throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n        &#125;\n        IRuleConfigParser parser &#x3D; parserFactory.createParser();\n\n        String configText &#x3D; &quot;&quot;;\n        &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n        RuleConfig ruleConfig &#x3D; parser.parse(configText);\n        return ruleConfig;\n    &#125;\n\n    private String getFileExtension(String filePath) &#123;\n        &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n        return &quot;json&quot;;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，\n&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n    private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n        cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n        cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n        cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());\n    &#125;\n\n    public static IRuleConfigParserFactory getParserFactory(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            return null;\n        &#125;\n        IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n        return parserFactory;\n    &#125;\n&#125;\n抽象工厂：在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应 8 个 parser 类。抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。\npublic interface IConfigParserFactory &#123;\n    IRuleConfigParser createRuleParser();\n    ISystemConfigParser createSystemParser();\n    &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\n\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createRuleParser() &#123;\n        return new JsonRuleConfigParser();\n    &#125;\n\n    @Override\n    public ISystemConfigParser createSystemParser() &#123;\n        return new JsonSystemConfigParser();\n    &#125;\n&#125;\n\npublic class XmlConfigParserFactory implements IConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createRuleParser() &#123;\n        return new XmlRuleConfigParser();\n    &#125;\n\n    @Override\n    public ISystemConfigParser createSystemParser() &#123;\n        return new XmlSystemConfigParser();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码\n应用场景：当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离\n\n第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。\n还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。==工厂方法模式==\n\n对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式\n\n依赖注入框架（依赖注入容器（Dependency Injection Container））\n\nDI 容器跟我们讲的工厂模式又有何区别和联系：实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。\n\nDI 容器的核心功能有哪些\n\n配置解析：我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象，例如Spring容器的配置文件\npublic class RateLimiter &#123;\n    private RedisCounter redisCounter;\n    public RateLimiter(RedisCounter redisCounter) &#123;\n        this.redisCounter &#x3D; redisCounter;\n    &#125;\n    public void test() &#123;\n        System.out.println(&quot;Hello World!&quot;);\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class RedisCounter &#123;\n    private String ipAddress;\n    private int port;\n    public RedisCounter(String ipAddress, int port) &#123;\n        this.ipAddress &#x3D; ipAddress;\n        this.port &#x3D; port;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n配置文件beans.xml：\n&lt;beans&gt;\n   &lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n   &lt;&#x2F;bean&gt;\n \n   &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot;&gt;\n     &lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n   &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n对象创建：在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。并且通过反射机制在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。\n\n对象生命周期管理：\n\n简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象\n我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好\n我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件\n\n\n\n\n以及如何实现一个简单的 DI 容器\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(\n            &quot;beans.xml&quot;);\n        RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter.test();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic interface ApplicationContext &#123;\n    Object getBean(String beanId);\n&#125;\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext &#123;\n    private BeansFactory beansFactory;\n    private BeanConfigParser beanConfigParser;\n\n    public ClassPathXmlApplicationContext(String configLocation) &#123;\n        this.beansFactory &#x3D; new BeansFactory();\n        this.beanConfigParser &#x3D; new XmlBeanConfigParser();\n        loadBeanDefinitions(configLocation);\n    &#125;\n\n    private void loadBeanDefinitions(String configLocation) &#123;\n        InputStream in &#x3D; null;\n        try &#123;\n            in &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);\n            if (in &#x3D;&#x3D; null) &#123;\n                throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);\n            &#125;\n            List&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);\n            beansFactory.addBeanDefinitions(beanDefinitions);\n        &#125; finally &#123;\n            if (in !&#x3D; null) &#123;\n                try &#123;\n                    in.close();\n                &#125; catch (IOException e) &#123;\n                    &#x2F;&#x2F; TODO: log error\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    @Override\n    public Object getBean(String beanId) &#123;\n        return beansFactory.getBean(beanId);\n    &#125;\n&#125;\n\npublic interface BeanConfigParser &#123;\n    List&lt;BeanDefinition&gt; parse(InputStream inputStream);\n    List&lt;BeanDefinition&gt; parse(String configContent);\n&#125;\n\npublic class XmlBeanConfigParser implements BeanConfigParser &#123;\n\n    @Override\n    public List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;\n        String content &#x3D; null;\n        &#x2F;&#x2F; TODO:...\n        return parse(content);\n    &#125;\n\n    @Override\n    public List&lt;BeanDefinition&gt; parse(String configContent) &#123;\n        List&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();\n        &#x2F;&#x2F; TODO:...\n        return beanDefinitions;\n    &#125;\n&#125;\n\npublic class BeanDefinition &#123;\n    private String id;\n    private String className;\n    private List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();\n    private Scope scope &#x3D; Scope.SINGLETON;\n    private boolean lazyInit &#x3D; false;\n    &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n\n    public boolean isSingleton() &#123;\n        return scope.equals(Scope.SINGLETON);\n    &#125;\n\n\n    public static enum Scope &#123;\n        SINGLETON,\n        PROTOTYPE\n    &#125;\n\n    public static class ConstructorArg &#123;\n        private boolean isRef;\n        private Class type;\n        private Object arg;\n        &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n    &#125;\n&#125;\n\npublic class BeansFactory &#123;\n    private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();\n    private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n        &#125;\n\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;\n                createBean(beanDefinition);\n            &#125;\n        &#125;\n    &#125;\n\n    public Object getBean(String beanId) &#123;\n        BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);\n        if (beanDefinition &#x3D;&#x3D; null) &#123;\n            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n        &#125;\n        return createBean(beanDefinition);\n    &#125;\n\n    @VisibleForTesting\n    protected Object createBean(BeanDefinition beanDefinition) &#123;\n        if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n\n        Object bean &#x3D; null;\n        try &#123;\n            Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());\n            List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();\n            if (args.isEmpty()) &#123;\n                bean &#x3D; beanClass.newInstance();\n            &#125; else &#123;\n                Class[] argClasses &#x3D; new Class[args.size()];\n                Object[] argObjects &#x3D; new Object[args.size()];\n                for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;\n                    BeanDefinition.ConstructorArg arg &#x3D; args.get(i);\n                    if (!arg.getIsRef()) &#123;\n                        argClasses[i] &#x3D; arg.getType();\n                        argObjects[i] &#x3D; arg.getArg();\n                    &#125; else &#123;\n                        BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());\n                        if (refBeanDefinition &#x3D;&#x3D; null) &#123;\n                            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());\n                        &#125;\n                        argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());\n                        argObjects[i] &#x3D; createBean(refBeanDefinition);\n                    &#125;\n                &#125;\n                bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);\n            &#125;\n        &#125; catch (ClassNotFoundException | IllegalAccessException\n                 | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;\n            throw new BeanCreationFailureException(&quot;&quot;, e);\n        &#125;\n\n        if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;\n            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n        return bean;\n    &#125;\n&#125;\n\n\n\n3.建造者模式\n为什么需要建造者模式\n\n构造函数的参数列表非常多时，可以使用set()函数来给成员变量赋值，以替代冗长的构造函数，但如果参数列表之间有依赖关系，或者一经构造就不能改变属性值时，建造者模式就派上用场了，使用场景如下：\n\n我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。\n如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。\n如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。\n\n\n我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。\npublic class ResourcePoolConfig &#123;\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) &#123;\n    this.name &#x3D; builder.name;\n    this.maxTotal &#x3D; builder.maxTotal;\n    this.maxIdle &#x3D; builder.maxIdle;\n    this.minIdle &#x3D; builder.minIdle;\n  &#125;\n  &#x2F;&#x2F;...省略getter方法...\n\n  &#x2F;&#x2F;我们将Builder类设计成了ResourcePoolConfig的内部类。\n  &#x2F;&#x2F;我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder &#123;\n    private static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n    private static final int DEFAULT_MAX_IDLE &#x3D; 8;\n    private static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\n    private String name;\n    private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n    private int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n    private int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() &#123;\n      &#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      if (maxIdle &gt; maxTotal) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n\n      return new ResourcePoolConfig(this);\n    &#125;\n\n    public Builder setName(String name) &#123;\n      if (StringUtils.isBlank(name)) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.name &#x3D; name;\n      return this;\n    &#125;\n\n    public Builder setMaxTotal(int maxTotal) &#123;\n      if (maxTotal &lt;&#x3D; 0) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.maxTotal &#x3D; maxTotal;\n      return this;\n    &#125;\n\n    public Builder setMaxIdle(int maxIdle) &#123;\n      if (maxIdle &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.maxIdle &#x3D; maxIdle;\n      return this;\n    &#125;\n\n    public Builder setMinIdle(int minIdle) &#123;\n      if (minIdle &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.minIdle &#x3D; minIdle;\n      return this;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()\n        .setName(&quot;dbconnectionpool&quot;)\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();\n\n\n与工厂模式有何区别：顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。\n\n\n4.原型模式\n原型模式的原理与应用\n\n如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。\n如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作\n\n&#x2F;&#x2F;代码有问题，重构见下\npublic class Demo &#123;\n  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n  private long lastUpdateTime &#x3D; -1;\n\n  public void refresh() &#123;\n    &#x2F;&#x2F; 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime &#x3D; lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n      &#125;\n      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n        SearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      &#125; else &#123;\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      &#125;\n    &#125;\n\n    lastUpdateTime &#x3D; maxNewUpdatedTime;\n    currentKeywords &#x3D; newKeywords;\n  &#125;\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  &#125;\n&#125;\n原型模式的实现方式：深拷贝和浅拷贝\n\n实现：浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：\n\n在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。\n\n如何实现深拷贝\n\n递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：\npublic class Demo &#123;\n  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n  private long lastUpdateTime &#x3D; -1;\n\n  public void refresh() &#123;\n    &#x2F;&#x2F; Deep copy\n    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new HashMap&lt;&gt;();\n    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;\n      SearchWord searchWord &#x3D; e.getValue();\n      SearchWord newSearchWord &#x3D; new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    &#125;\n\n    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime &#x3D; lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n      &#125;\n      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n        SearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      &#125; else &#123;\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      &#125;\n    &#125;\n\n    lastUpdateTime &#x3D; maxNewUpdatedTime;\n    currentKeywords &#x3D; newKeywords;\n  &#125;\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  &#125;\n\n&#125;\n先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：\npublic Object deepCopy(Object object) &#123;\n  ByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream();\n  ObjectOutputStream oo &#x3D; new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi &#x3D; new ObjectInputStream(bi);\n  \n  return oi.readObject();\n&#125;\n\n\n重构版本：我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。\npublic class Demo &#123;\n  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n  private long lastUpdateTime &#x3D; -1;\n\n  public void refresh() &#123;\n    &#x2F;&#x2F; Shallow copy\n    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime &#x3D; lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n      &#125;\n      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n        newKeywords.remove(searchWord.getKeyword());\n      &#125;\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    &#125;\n\n    lastUpdateTime &#x3D; maxNewUpdatedTime;\n    currentKeywords &#x3D; newKeywords;\n  &#125;\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  &#125;\n&#125;\n\n\n\n2.结构型设计模式1.代理模式\n\n\n\n\n\n\n\n\n代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。\n\n代理模式（Proxy Design Pattern）：在不改变类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能\n\n原始代码\npublic class UserController &#123;\n    &#x2F;&#x2F;...省略其他属性和方法...\n    private MetricsCollector metricsCollector; &#x2F;&#x2F; 依赖注入\n\n    public UserVo login(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        &#x2F;&#x2F; ... 省略login逻辑...\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n\n    public UserVo register(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        &#x2F;&#x2F; ... 省略register逻辑...\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n&#125;\n改动一：因为业务和框架耦合，类的职责不够单一，所以使用代理模式\n\n原始类定义了接口\npublic interface IUserController &#123;\n    UserVo login(String telephone, String password);\n    UserVo register(String telephone, String password);\n&#125;\n\npublic class UserController implements IUserController &#123;\n    &#x2F;&#x2F;...省略其他属性和方法...\n\n    @Override\n    public UserVo login(String telephone, String password) &#123;\n        &#x2F;&#x2F;...省略login逻辑...\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n\n    @Override\n    public UserVo register(String telephone, String password) &#123;\n        &#x2F;&#x2F;...省略register逻辑...\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n&#125;\n\npublic class UserControllerProxy implements IUserController &#123;\n    private MetricsCollector metricsCollector;\n    private UserController userController;\n\n    public UserControllerProxy(UserController userController) &#123;\n        this.userController &#x3D; userController;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    @Override\n    public UserVo login(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        &#x2F;&#x2F; 委托\n        UserVo userVo &#x3D; userController.login(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n\n    @Override\n    public UserVo register(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        UserVo userVo &#x3D; userController.register(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;UserControllerProxy使用举例\n&#x2F;&#x2F;因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n&#x2F;&#x2F;将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController &#x3D; new UserControllerProxy(new UserController());\n原始类未定义接口，只能使用继承：\npublic class UserControllerProxy extends UserController &#123;\n    private MetricsCollector metricsCollector;\n\n    public UserControllerProxy() &#123;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    public UserVo login(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        UserVo userVo &#x3D; super.login(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n\n    public UserVo register(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        UserVo userVo &#x3D; super.register(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n&#125;\n&#x2F;&#x2F;UserControllerProxy使用举例\nUserController userController &#x3D; new UserControllerProxy();\n\n\n改动二：因为需要实现原始类的所有方法，并且都添加相似的逻辑；并且每个原始类都得有一个代理类，所以采用==动态代理==\n\n动态代理（Dynamic Proxy）：不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理来替换原始类\n\nSpring AOP底层的实现原理就是基于动态代理，用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能，Spring为这些类创建动态代理对象，并在JVM中替代原始类对象，原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。\n\n实现：\n&#x2F;&#x2F;动态代理类\npublic class MetricsCollectorProxy &#123;\n    private MetricsCollector metricsCollector;\n\n    public MetricsCollectorProxy() &#123;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    &#x2F;&#x2F;封装了代理类的创建\n    public Object createProxy(Object proxiedObject) &#123;\n        &#x2F;&#x2F;返回Class数组，表示Class对象引用的类所实现的所有接口\n        Class&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();\n        DynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);\n        &#x2F;&#x2F;Proxy provides static methods for creating dynamic proxy classes and instances, \n        &#x2F;&#x2F;and it is also the superclass of all dynamic proxy classes created by those \n        &#x2F;&#x2F;methods.\n        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n    &#125;\n\n    private class DynamicProxyHandler implements InvocationHandler &#123;\n        private Object proxiedObject;\n\n        public DynamicProxyHandler(Object proxiedObject) &#123;\n            this.proxiedObject &#x3D; proxiedObject;\n        &#125;\n\n        &#x2F;&#x2F;所有方法的调用都会变成调用invoke方法，参数为生成的代理类、要调用的方法、对应的参数\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            long startTimestamp &#x3D; System.currentTimeMillis();\n            Object result &#x3D; method.invoke(proxiedObject, args);\n            long endTimeStamp &#x3D; System.currentTimeMillis();\n            long responseTime &#x3D; endTimeStamp - startTimestamp;\n            String apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n            RequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);\n            metricsCollector.recordRequest(requestInfo);\n            return result;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();\nIUserController userController &#x3D; (IUserController) proxy.createProxy(new UserController());\n\n\n应用场景\n\n业务系统的非功能性需求开发，比如：监控、统计、鉴权、限流、事务、幂等、日志\nRPC：将网络通信和数据编解码等细节隐藏起来，客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。示例代码\n缓存：基于Spring框架来开发，在AOP切面中完成接口缓存的功能，在应用启动的时候，从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。\n\n\n\n2.桥接模式\n\n\n\n\n\n\n\n\n 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。\n\n经典应用：JDBC驱动\n\nJDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行\n\nJDBC驱动用法\n&#x2F;&#x2F;第一件事情是要求 JVM 查找并加载指定的 Driver 类\n&#x2F;&#x2F;第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序，一共做了两件事\n\nString url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;;\nConnection con &#x3D; DriverManager.getConnection(url);\nStatement stmt &#x3D; con.createStatement()；\nString query &#x3D; &quot;select * from test&quot;;\nResultSet rs&#x3D;stmt.executeQuery(query);\nwhile(rs.next()) &#123;\n    rs.getString(1);\n    rs.getInt(2);\n&#125;\ncom.mysql.jdbc.Driver类\npackage com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;\n    static &#123;\n        try &#123;\n            java.sql.DriverManager.registerDriver(new Driver());\n        &#125; catch (SQLException E) &#123;\n            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);\n        &#125;\n    &#125;\n\n    &#x2F;**\n   * Construct a new driver and register it with DriverManager\n   * @throws SQLException if a database error occurs.\n   *&#x2F;\n    public Driver() throws SQLException &#123;\n        &#x2F;&#x2F; Required for Class.forName().newInstance()\n    &#125;\n&#125;\nDriverManager类\n&#x2F;&#x2F;当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，\n&#x2F;&#x2F;后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了\n&#x2F;&#x2F;相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因\npublic class DriverManager &#123;\n    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;DriverInfo&gt;();\n\n    &#x2F;&#x2F;...\n    static &#123;\n        loadInitialDrivers();\n        println(&quot;JDBC DriverManager initialized&quot;);\n    &#125;\n    &#x2F;&#x2F;...\n\n    public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123;\n        if (driver !&#x3D; null) &#123;\n            registeredDrivers.addIfAbsent(new DriverInfo(driver));\n        &#125; else &#123;\n            throw new NullPointerException();\n        &#125;\n    &#125;\n\n    public static Connection getConnection(String url, String user, String password) throws SQLException &#123;\n        java.util.Properties info &#x3D; new java.util.Properties();\n        if (user !&#x3D; null) &#123;\n            info.put(&quot;user&quot;, user);\n        &#125;\n        if (password !&#x3D; null) &#123;\n            info.put(&quot;password&quot;, password);\n        &#125;\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n\n应用二：重构API 接口监控告警\n\n针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。\n\n重构前\npublic enum NotificationEmergencyLevel &#123;\n    SEVERE, URGENCY, NORMAL, TRIVIAL\n&#125;\n\npublic class Notification &#123;\n    private List&lt;String&gt; emailAddresses;\n    private List&lt;String&gt; telephones;\n    private List&lt;String&gt; wechatIds;\n\n    public Notification() &#123;&#125;\n\n    public void setEmailAddress(List&lt;String&gt; emailAddress) &#123;\n        this.emailAddresses &#x3D; emailAddress;\n    &#125;\n\n    public void setTelephones(List&lt;String&gt; telephones) &#123;\n        this.telephones &#x3D; telephones;\n    &#125;\n\n    public void setWechatIds(List&lt;String&gt; wechatIds) &#123;\n        this.wechatIds &#x3D; wechatIds;\n    &#125;\n\n    public void notify(NotificationEmergencyLevel level, String message) &#123;\n        if (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;\n            &#x2F;&#x2F;...自动语音电话\n        &#125; else if (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;\n            &#x2F;&#x2F;...发微信\n        &#125; else if (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;\n            &#x2F;&#x2F;...发邮件\n        &#125; else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;\n            &#x2F;&#x2F;...发邮件\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler &#123;\n    public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;\n        super(rule, notification);\n    &#125;\n\n\n    @Override\n    public void check(ApiStatInfo apiStatInfo) &#123;\n        if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;\n            notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n        &#125;\n    &#125;\n&#125;\n重构后\npublic interface MsgSender &#123;\n    void send(String message);\n&#125;\n\npublic class TelephoneMsgSender implements MsgSender &#123;\n    private List&lt;String&gt; telephones;\n\n    public TelephoneMsgSender(List&lt;String&gt; telephones) &#123;\n        this.telephones &#x3D; telephones;\n    &#125;\n\n    @Override\n    public void send(String message) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n&#x2F;&#x2F;省略EmailMsgSender、WechatMsgSender\n\n\npublic abstract class Notification &#123;\n    &#x2F;&#x2F;组合\n    protected MsgSender msgSender;\n\n    public Notification(MsgSender msgSender) &#123;\n        this.msgSender &#x3D; msgSender;\n    &#125;\n\n    public abstract void notify(String message);\n&#125;\n\npublic class SevereNotification extends Notification &#123;\n    public SevereNotification(MsgSender msgSender) &#123;\n        super(msgSender);\n    &#125;\n\n    @Override\n    public void notify(String message) &#123;\n        msgSender.send(message);\n    &#125;\n&#125;\n&#x2F;&#x2F;省略UrgencyNotification、NormalNotification、TrivialNotification\n\n\n\n3.装饰者模式\n\n\n\n\n\n\n\n\n装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。例如JavaIO类\n\n特点：\n\n用组合替代继承\n\n装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。\nInputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nDataInputStream din &#x3D; new DataInputStream(bin);\nint data &#x3D; din.readInt();\n装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。\n\n\n\n装饰器模式与代理模式对比\n&#x2F;&#x2F;代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。\n&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A impelements IA &#123;\n    public void f() &#123; &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class AProxy implements IA &#123;\n    private IA a;\n    public AProxy(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 新添加的代理逻辑\n        a.f();\n        &#x2F;&#x2F; 新添加的代理逻辑\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A implements IA &#123;\n    public void f() &#123; &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class ADecorator implements IA &#123;\n    private IA a;\n    public ADecorator(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 功能增强代码\n        a.f();\n        &#x2F;&#x2F; 功能增强代码\n    &#125;\n&#125;\n实现\npublic abstract class InputStream &#123;\n    &#x2F;&#x2F;...\n    public int read(byte b[]) throws IOException &#123;\n        return read(b, 0, b.length);\n    &#125;\n\n    public int read(byte b[], int off, int len) throws IOException &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class BufferedInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n\n    protected BufferedInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现基于缓存的读数据接口...  \n&#125;\n\npublic class DataInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n\n    protected DataInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现读取基本类型数据的接口\n&#125;\n为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。例如：BufferedInputStream直接使用了FilterInputStream的close()，而没有重新实现\npublic class FilterInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n\n    protected FilterInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    public int read() throws IOException &#123;\n        return in.read();\n    &#125;\n\n    public int read(byte b[]) throws IOException &#123;\n        return read(b, 0, b.length);\n    &#125;\n\n    public int read(byte b[], int off, int len) throws IOException &#123;\n        return in.read(b, off, len);\n    &#125;\n\n    public long skip(long n) throws IOException &#123;\n        return in.skip(n);\n    &#125;\n\n    public int available() throws IOException &#123;\n        return in.available();\n    &#125;\n\n    public void close() throws IOException &#123;\n        in.close();\n    &#125;\n\n    public synchronized void mark(int readlimit) &#123;\n        in.mark(readlimit);\n    &#125;\n\n    public synchronized void reset() throws IOException &#123;\n        in.reset();\n    &#125;\n\n    public boolean markSupported() &#123;\n        return in.markSupported();\n    &#125;\n&#125;\n\n4.适配器模式\n\n\n\n\n\n\n\n\n适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。\n\n适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。\n\n实现方式：ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口，看情况选择哪种方式，接口大多相同则用类适配器，否则选用对象适配器\n\n类适配器：使用继承来实现\n&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n    public void fb() &#123;\n        &#x2F;&#x2F;... \n    &#125;\n    public void fc() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n&#125;\n\npublic class Adaptor extends Adaptee implements ITarget &#123;\n    public void f1() &#123;\n        super.fa();\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;\n对象适配器：使用组合来实现\n&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123;\n        &#x2F;&#x2F;... \n    &#125;\n    public void fb() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n    public void fc() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class Adaptor implements ITarget &#123;\n    private Adaptee adaptee;\n\n    public Adaptor(Adaptee adaptee) &#123;\n        this.adaptee &#x3D; adaptee;\n    &#125;\n\n    public void f1() &#123;\n        adaptee.fa(); &#x2F;&#x2F;委托给Adaptee\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    public void fc() &#123;\n        adaptee.fc();\n    &#125;\n&#125;\n\n\n应用场景\n\n封装有缺陷的接口设计：假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。\npublic class CD &#123; &#x2F;&#x2F;这个类来自外部sdk，我们无权修改它的代码\n  &#x2F;&#x2F;...\n  public static void staticFunction1() &#123; &#x2F;&#x2F;... &#125;\n  \n  public void uglyNamingFunction2() &#123; &#x2F;&#x2F;... &#125;\n\n  public void tooManyParamsFunction3(int paramA, int paramB, ...) &#123; &#x2F;&#x2F;... &#125;\n  \n   public void lowPerformanceFunction4() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\n&#x2F;&#x2F; 使用适配器模式进行重构\npublic interface ITarget &#123;\n  void function1();\n  void function2();\n  void fucntion3(ParamsWrapperDefinition paramsWrapper);\n  void function4();\n  &#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F; 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget &#123;\n  &#x2F;&#x2F;...\n  public void function1() &#123;\n     super.staticFunction1();\n  &#125;\n  \n  public void function2() &#123;\n    super.uglyNamingFucntion2();\n  &#125;\n  \n  public void function3(ParamsWrapperDefinition paramsWrapper) &#123;\n     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n  &#125;\n  \n  public void function4() &#123;\n    &#x2F;&#x2F;...reimplement it...\n  &#125;\n&#125;\n统一多个类的接口设计：某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。\npublic class ASensitiveWordsFilter &#123; &#x2F;&#x2F; A敏感词过滤系统提供的接口\n  &#x2F;&#x2F;text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n  \n  public String filterPoliticalWords(String text) &#123;\n    &#x2F;&#x2F; ...\n  &#125; \n&#125;\n\npublic class BSensitiveWordsFilter  &#123; &#x2F;&#x2F; B敏感词过滤系统提供的接口\n  public String filter(String text) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n\npublic class CSensitiveWordsFilter &#123; &#x2F;&#x2F; C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement &#123;\n  private ASensitiveWordsFilter aFilter &#x3D; new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter &#x3D; new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter &#x3D; new CSensitiveWordsFilter();\n  \n  public String filterSensitiveWords(String text) &#123;\n    String maskedText &#x3D; aFilter.filterSexyWords(text);\n    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n    maskedText &#x3D; bFilter.filter(maskedText);\n    maskedText &#x3D; cFilter.filter(maskedText, &quot;***&quot;);\n    return maskedText;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter &#123; &#x2F;&#x2F; 统一接口定义\n  String filter(String text);\n&#125;\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123;\n  private ASensitiveWordsFilter aFilter;\n  public String filter(String text) &#123;\n    String maskedText &#x3D; aFilter.filterSexyWords(text);\n    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  &#125;\n&#125;\n&#x2F;&#x2F;...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n&#x2F;&#x2F; 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n&#x2F;&#x2F; 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement &#123; \n  private List&lt;ISensitiveWordsFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n \n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123;\n    filters.add(filter);\n  &#125;\n  \n  public String filterSensitiveWords(String text) &#123;\n    String maskedText &#x3D; text;\n    for (ISensitiveWordsFilter filter : filters) &#123;\n      maskedText &#x3D; filter.filter(maskedText);\n    &#125;\n    return maskedText;\n  &#125;\n&#125;\n替换依赖的外部系统：当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。\n&#x2F;&#x2F; 外部系统A\npublic interface IA &#123;\n  &#x2F;&#x2F;...\n  void fa();\n&#125;\npublic class A implements IA &#123;\n  &#x2F;&#x2F;...\n  public void fa() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n&#x2F;&#x2F; 在我们的项目中，外部系统A的使用示例\npublic class Demo &#123;\n  private IA a;\n  public Demo(IA a) &#123;\n    this.a &#x3D; a;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;\nDemo d &#x3D; new Demo(new A());\n\n&#x2F;&#x2F; 将外部系统A替换成外部系统B\npublic class BAdaptor implemnts IA &#123;\n  private B b;\n  public BAdaptor(B b) &#123;\n    this.b&#x3D; b;\n  &#125;\n  public void fa() &#123;\n    &#x2F;&#x2F;...\n    b.fb();\n  &#125;\n&#125;\n&#x2F;&#x2F; 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n&#x2F;&#x2F; 只需要将BAdaptor如下注入到Demo即可。\nDemo d &#x3D; new Demo(new BAdaptor(new B()));\n兼容老版本接口：在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。\n&#x2F;&#x2F;暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor\npublic class Collections &#123;\n    public static Emueration emumeration(final Collection c) &#123;\n        return new Enumeration() &#123;\n            Iterator i &#x3D; c.iterator();\n\n            public boolean hasMoreElments() &#123;\n                return i.hashNext();\n            &#125;\n\n            public Object nextElement() &#123;\n                return i.next():\n            &#125;\n        &#125;\n    &#125;\n&#125;\n适配不同格式的数据：可以用在不同格式的数据之间的适配，比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型\nList&lt;String&gt; stooges &#x3D; Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);\n\n\n在Java日志中的作用：Slf4j定义了接口，但没有定义实现。因为JUL、JCL、log4j 等日志框架并没有将接口改造成符合Slf4j 接口规范。所以，Slf4j不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。\n&#x2F;&#x2F; slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger &#123;\n  public boolean isTraceEnabled();\n  public void trace(String msg);\n  public void trace(String format, Object arg);\n  public void trace(String format, Object arg1, Object arg2);\n  public void trace(String format, Object[] argArray);\n  public void trace(String msg, Throwable t);\n \n  public boolean isDebugEnabled();\n  public void debug(String msg);\n  public void debug(String format, Object arg);\n  public void debug(String format, Object arg1, Object arg2)\n  public void debug(String format, Object[] argArray)\n  public void debug(String msg, Throwable t);\n\n  &#x2F;&#x2F;...省略info、warn、error等一堆接口\n&#125;\n\n&#x2F;&#x2F; log4j日志框架的适配器\n&#x2F;&#x2F; Log4jLoggerAdapter实现了LocationAwareLogger接口，\n&#x2F;&#x2F; 其中LocationAwareLogger继承自Logger接口，\n&#x2F;&#x2F; 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n  implements LocationAwareLogger, Serializable &#123;\n  final transient org.apache.log4j.Logger logger; &#x2F;&#x2F; log4j\n \n  public boolean isDebugEnabled() &#123;\n    return logger.isDebugEnabled();\n  &#125;\n \n  public void debug(String msg) &#123;\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  &#125;\n \n  public void debug(String format, Object arg) &#123;\n    if (logger.isDebugEnabled()) &#123;\n      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    &#125;\n  &#125;\n \n  public void debug(String format, Object arg1, Object arg2) &#123;\n    if (logger.isDebugEnabled()) &#123;\n      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    &#125;\n  &#125;\n \n  public void debug(String format, Object[] argArray) &#123;\n    if (logger.isDebugEnabled()) &#123;\n      FormattingTuple ft &#x3D; MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    &#125;\n  &#125;\n \n  public void debug(String msg, Throwable t) &#123;\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  &#125;\n  &#x2F;&#x2F;...省略一堆接口的实现...\n&#125;\n\n5.门面模式\n\n\n\n\n\n\n\n\n为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。\n\n应用场景\n解决易用性问题：门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。\n解决性能问题：过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。组织门面接口和非门面接口的方法：如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。\n解决分布式事务问题：要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。\n\n\n\n6.组合模式\n\n\n\n\n\n\n\n\n将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让代码的使用者可以统一单个对象和组合对象的处理逻辑。\n\n应用一：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：动态地添加、删除某个目录下的子目录或文件；统计指定目录下的文件个数；统计指定目录下的文件总大小。\n\n重构前\n\npublic class FileSystemNode &#123;\n    private String path;\n    private boolean isFile;\n    private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\n    public FileSystemNode(String path, boolean isFile) &#123;\n        this.path &#x3D; path;\n        this.isFile &#x3D; isFile;\n    &#125;\n\n    public int countNumOfFiles() &#123;\n        &#x2F;&#x2F; TODO:...\n    &#125;\n\n    public long countSizeOfFiles() &#123;\n        &#x2F;&#x2F; TODO:...\n    &#125;\n\n    public String getPath() &#123;\n        return path;\n    &#125;\n\n    public void addSubNode(FileSystemNode fileOrDir) &#123;\n        subNodes.add(fileOrDir);\n    &#125;\n\n    public void removeSubNode(FileSystemNode fileOrDir) &#123;\n        int size &#x3D; subNodes.size();\n        int i &#x3D; 0;\n        for (; i &lt; size; ++i) &#123;\n            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n                break;\n            &#125;\n        &#125;\n        if (i &lt; size) &#123;\n            subNodes.remove(i);\n        &#125;\n    &#125;\n&#125;\n\n\n重构后\n\npublic abstract class FileSystemNode &#123;\n    protected String path;\n\n    public FileSystemNode(String path) &#123;\n        this.path &#x3D; path;\n    &#125;\n\n    public abstract int countNumOfFiles();\n    public abstract long countSizeOfFiles();\n\n    public String getPath() &#123;\n        return path;\n    &#125;\n&#125;\n\npublic class File extends FileSystemNode &#123;\n    public File(String path) &#123;\n        super(path);\n    &#125;\n\n    @Override\n    public int countNumOfFiles() &#123;\n        return 1;\n    &#125;\n\n    @Override\n    public long countSizeOfFiles() &#123;\n        java.io.File file &#x3D; new java.io.File(path);\n        if (!file.exists()) return 0;\n        return file.length();\n    &#125;\n&#125;\n\npublic class Directory extends FileSystemNode &#123;\n    private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\n    public Directory(String path) &#123;\n        super(path);\n    &#125;\n\n    @Override\n    public int countNumOfFiles() &#123;\n        int numOfFiles &#x3D; 0;\n        for (FileSystemNode fileOrDir : subNodes) &#123;\n            numOfFiles +&#x3D; fileOrDir.countNumOfFiles();\n        &#125;\n        return numOfFiles;\n    &#125;\n\n    @Override\n    public long countSizeOfFiles() &#123;\n        long sizeofFiles &#x3D; 0;\n        for (FileSystemNode fileOrDir : subNodes) &#123;\n            sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();\n        &#125;\n        return sizeofFiles;\n    &#125;\n\n    public void addSubNode(FileSystemNode fileOrDir) &#123;\n        subNodes.add(fileOrDir);\n    &#125;\n\n    public void removeSubNode(FileSystemNode fileOrDir) &#123;\n        int size &#x3D; subNodes.size();\n        int i &#x3D; 0;\n        for (; i &lt; size; ++i) &#123;\n            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n                break;\n            &#125;\n        &#125;\n        if (i &lt; size) &#123;\n            subNodes.remove(i);\n        &#125;\n    &#125;\n&#125;\n应用二：在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）\npublic abstract class HumanResource &#123;\n    protected long id;\n    protected double salary;\n\n    public HumanResource(long id) &#123;\n        this.id &#x3D; id;\n    &#125;\n\n    public long getId() &#123;\n        return id;\n    &#125;\n\n    public abstract double calculateSalary();\n&#125;\n\npublic class Employee extends HumanResource &#123;\n    public Employee(long id, double salary) &#123;\n        super(id);\n        this.salary &#x3D; salary;\n    &#125;\n\n    @Override\n    public double calculateSalary() &#123;\n        return salary;\n    &#125;\n&#125;\n\npublic class Department extends HumanResource &#123;\n    private List&lt;HumanResource&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\n    public Department(long id) &#123;\n        super(id);\n    &#125;\n\n    @Override\n    public double calculateSalary() &#123;\n        double totalSalary &#x3D; 0;\n        for (HumanResource hr : subNodes) &#123;\n            totalSalary +&#x3D; hr.calculateSalary();\n        &#125;\n        this.salary &#x3D; totalSalary;\n        return totalSalary;\n    &#125;\n\n    public void addSubNode(HumanResource hr) &#123;\n        subNodes.add(hr);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 构建组织架构的代码\npublic class Demo &#123;\n    private static final long ORGANIZATION_ROOT_ID &#x3D; 1001;\n    private DepartmentRepo departmentRepo; &#x2F;&#x2F; 依赖注入\n    private EmployeeRepo employeeRepo; &#x2F;&#x2F; 依赖注入\n\n    public void buildOrganization() &#123;\n        Department rootDepartment &#x3D; new Department(ORGANIZATION_ROOT_ID);\n        buildOrganization(rootDepartment);\n    &#125;\n\n    private void buildOrganization(Department department) &#123;\n        List&lt;Long&gt; subDepartmentIds &#x3D; departmentRepo.getSubDepartmentIds(department.getId());\n        for (Long subDepartmentId : subDepartmentIds) &#123;\n            Department subDepartment &#x3D; new Department(subDepartmentId);\n            department.addSubNode(subDepartment);\n            buildOrganization(subDepartment);\n        &#125;\n        List&lt;Long&gt; employeeIds &#x3D; employeeRepo.getDepartmentEmployeeIds(department.getId());\n        for (Long employeeId : employeeIds) &#123;\n            double salary &#x3D; employeeRepo.getEmployeeSalary(employeeId);\n            department.addSubNode(new Employee(employeeId, salary));\n        &#125;\n    &#125;\n&#125;\n\n7.享元模式\n\n\n\n\n\n\n\n\n当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的\n\n棋牌游戏\n\n重构前\npublic class ChessPiece &#123;&#x2F;&#x2F;棋子\n    private int id;\n    private String text;\n    private Color color;\n    private int positionX;\n    private int positionY;\n\n    public ChessPiece(int id, String text, Color color, int positionX, int positionY) &#123;\n        this.id &#x3D; id;\n        this.text &#x3D; text;\n        this.color &#x3D; color;\n        this.positionX &#x3D; positionX;\n        this.positionY &#x3D; positionX;\n    &#125;\n\n    public static enum Color &#123;\n        RED, BLACK\n    &#125;\n\n    &#x2F;&#x2F; ...省略其他属性和getter&#x2F;setter方法...\n&#125;\n\npublic class ChessBoard &#123;&#x2F;&#x2F;棋局\n    private Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\n    public ChessBoard() &#123;\n        init();\n    &#125;\n\n    private void init() &#123;\n        chessPieces.put(1, new ChessPiece(1, &quot;車&quot;, ChessPiece.Color.BLACK, 0, 0));\n        chessPieces.put(2, new ChessPiece(2,&quot;馬&quot;, ChessPiece.Color.BLACK, 0, 1));\n        &#x2F;&#x2F;...省略摆放其他棋子的代码...\n    &#125;\n\n    public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n        &#x2F;&#x2F;...省略...\n    &#125;\n&#125;\n重构后：因为需要保存太多盘棋局，耗费大量内存。因为id、text、color都相同，只是positionX、positionY 不同，所以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用，棋盘只需要记录每个棋子的位置信息就可以了。\n&#x2F;&#x2F; 享元类\npublic class ChessPieceUnit &#123;\n    private int id;\n    private String text;\n    private Color color;\n\n    public ChessPieceUnit(int id, String text, Color color) &#123;\n        this.id &#x3D; id;\n        this.text &#x3D; text;\n        this.color &#x3D; color;\n    &#125;\n\n    public static enum Color &#123;\n        RED, BLACK\n    &#125;\n\n    &#x2F;&#x2F; ...省略其他属性和getter方法...\n&#125;\n&#x2F;&#x2F;工厂模式，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的\npublic class ChessPieceUnitFactory &#123;\n    private static final Map&lt;Integer, ChessPieceUnit&gt; pieces &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));\n        pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));\n        &#x2F;&#x2F;...省略摆放其他棋子的代码...\n    &#125;\n\t&#x2F;&#x2F;取享元对象\n    public static ChessPieceUnit getChessPiece(int chessPieceId) &#123;\n        return pieces.get(chessPieceId);\n    &#125;\n&#125;\n&#x2F;&#x2F;棋子只剩下位置属性\npublic class ChessPiece &#123;\n    private ChessPieceUnit chessPieceUnit;\n    private int positionX;\n    private int positionY;\n\n    public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;\n        this.chessPieceUnit &#x3D; unit;\n        this.positionX &#x3D; positionX;\n        this.positionY &#x3D; positionY;\n    &#125;\n    &#x2F;&#x2F; 省略getter、setter方法\n&#125;\n\npublic class ChessBoard &#123;\n    private Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\n    public ChessBoard() &#123;\n        init();\n    &#125;\n\n    private void init() &#123;\n        chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(1), 0,0));\n        chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(2), 1,0));\n        &#x2F;&#x2F;...省略摆放其他棋子的代码...\n    &#125;\n\n    public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n        &#x2F;&#x2F;...省略...\n    &#125;\n&#125;\n\n\n文本编辑器\n\n重构前\npublic class Character &#123;&#x2F;&#x2F;文字\n    private char c;\n\n    private Font font;\n    private int size;\n    private int colorRGB;\n\n    public Character(char c, Font font, int size, int colorRGB) &#123;\n        this.c &#x3D; c;\n        this.font &#x3D; font;\n        this.size &#x3D; size;\n        this.colorRGB &#x3D; colorRGB;\n    &#125;\n&#125;\n&#x2F;&#x2F;在文本编辑器中，每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。\npublic class Editor &#123;\n    private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\n    public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n        Character character &#x3D; new Character(c, font, size, colorRGB);\n        chars.add(character);\n    &#125;\n&#125;\n重构后：实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，可以将它设计成享元，让不同的文字共享使用。\n&#x2F;&#x2F;享元类\npublic class CharacterStyle &#123;\n    private Font font;\n    private int size;\n    private int colorRGB;\n\n    public CharacterStyle(Font font, int size, int colorRGB) &#123;\n        this.font &#x3D; font;\n        this.size &#x3D; size;\n        this.colorRGB &#x3D; colorRGB;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        CharacterStyle otherStyle &#x3D; (CharacterStyle) o;\n        return font.equals(otherStyle.font)\n            &amp;&amp; size &#x3D;&#x3D; otherStyle.size\n            &amp;&amp; colorRGB &#x3D;&#x3D; otherStyle.colorRGB;\n    &#125;\n&#125;\n&#x2F;&#x2F;工厂方法\npublic class CharacterStyleFactory &#123;\n    private static final List&lt;CharacterStyle&gt; styles &#x3D; new ArrayList&lt;&gt;();\n\n    public static CharacterStyle getStyle(Font font, int size, int colorRGB) &#123;\n        CharacterStyle newStyle &#x3D; new CharacterStyle(font, size, colorRGB);\n        for (CharacterStyle style : styles) &#123;\n            if (style.equals(newStyle)) &#123;\n                return style;\n            &#125;\n        &#125;\n        styles.add(newStyle);\n        return newStyle;\n    &#125;\n&#125;\n&#x2F;&#x2F;剩余的字符类，字符类型是共享的\npublic class Character &#123;\n    private char c;\n    private CharacterStyle style;\n\n    public Character(char c, CharacterStyle style) &#123;\n        this.c &#x3D; c;\n        this.style &#x3D; style;\n    &#125;\n&#125;\n\npublic class Editor &#123;\n    private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\n    public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n        Character character &#x3D; new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));\n        chars.add(character);\n    &#125;\n&#125;\n\n\n在Integer、String中的应用\n\nInteger中：通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建。（其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据）\nInteger i1 &#x3D; 56;\nInteger i2 &#x3D; 56;\nInteger i3 &#x3D; 129;\nInteger i4 &#x3D; 129;\nSystem.out.println(i1 &#x3D;&#x3D; i2);&#x2F;&#x2F;true\nSystem.out.println(i3 &#x3D;&#x3D; i4);&#x2F;&#x2F;false\nString中：String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。\nString s1 &#x3D; &quot;小争哥&quot;;\nString s2 &#x3D; &quot;小争哥&quot;;\nString s3 &#x3D; new String(&quot;小争哥&quot;);\n\nSystem.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;true\nSystem.out.println(s1 &#x3D;&#x3D; s3);&#x2F;&#x2F;false\n\n\n\n3.行为型设计模式1.观察者模式\n\n\n\n\n\n\n\n\n在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。\n\n模板代码\npublic interface Subject &#123;\n    &#x2F;&#x2F;也可起名为attach\n    void registerObserver(Observer observer);\n    &#x2F;&#x2F;也可起名为detach\n    void removeObserver(Observer observer);\n    &#x2F;&#x2F;一个一个通知\n    void notifyObservers(Message message);\n&#125;\n&#x2F;&#x2F;被依赖的对象叫被观察者（Observable）；依赖的对象叫观察者（Observer）\npublic interface Observer &#123;\n    void update(Message message);\n&#125;\n&#x2F;&#x2F;Concrete：具体的\npublic class ConcreteSubject implements Subject &#123;\n    private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n\n    @Override\n    public void registerObserver(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    @Override\n    public void removeObserver(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    @Override\n    public void notifyObservers(Message message) &#123;\n        for (Observer observer : observers) &#123;\n            observer.update(message);\n        &#125;\n    &#125;\n\n&#125;\n\npublic class ConcreteObserverOne implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteObserverTwo implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n    &#125;\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ConcreteSubject subject &#x3D; new ConcreteSubject();\n        subject.registerObserver(new ConcreteObserverOne());\n        subject.registerObserver(new ConcreteObserverTwo());\n        subject.notifyObservers(new Message());\n    &#125;\n&#125;\n应用一同步阻塞方式：用户注册成功之后，采取发放投资体验金或者发放优惠卷等措施\n\n重构前\npublic class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n        promotionService.issueNewUserExperienceCash(userId);\n        return userId;\n    &#125;\n&#125;\n重构后\npublic interface RegObserver &#123;\n    void handleRegSuccess(long userId);\n&#125;\n\npublic class RegPromotionObserver implements RegObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Override\n    public void handleRegSuccess(long userId) &#123;\n        promotionService.issueNewUserExperienceCash(userId);\n    &#125;\n&#125;\n\npublic class RegNotificationObserver implements RegObserver &#123;\n    private NotificationService notificationService;&#x2F;&#x2F; 依赖注入\n\n    @Override\n    public void handleRegSuccess(long userId) &#123;\n        notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);\n    &#125;\n&#125;\n\npublic class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n    private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();\n\n    &#x2F;&#x2F; 一次性设置好，之后也不可能动态的修改，\n    &#x2F;&#x2F;如果想增加新的观察者，只需要添加一个实现了RegObserver接口的类，\n    &#x2F;&#x2F;并且通过setRegObserver()函数将它注册到UserController类中即可\n    public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;\n        regObservers.addAll(observers);\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n\n        &#x2F;&#x2F;同步阻塞方式：register() 函数依次调用执行每个观察者的 handleRegSuccess() 函数，\n        &#x2F;&#x2F;等到都执行完成之后，才会返回结果给客户端。  \n        for (RegObserver observer : regObservers) &#123;\n            &#x2F;&#x2F;非同进程时，使用RPC接口或Message Queue\n            observer.handleRegSuccess(userId);\n        &#125;\n        \n        &#x2F;&#x2F;异步非阻塞方式：当 userService.register() 函数执行完成之后，我们启动一个新的线程\n        &#x2F;&#x2F;来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不\n        &#x2F;&#x2F;需要等到所有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。\n        \n        return userId;\n    &#125;\n&#125;\n\n\n应用二异步非阻塞方式：EventBus（Google Guava）\n\n简单实现\n&#x2F;&#x2F; 第一种实现方式，其他类代码不变，就没有再重复罗列\n&#x2F;&#x2F;频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出\npublic class RegPromotionObserver implements RegObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Override\n    public void handleRegSuccess(Long userId) &#123;\n        Thread thread &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                promotionService.issueNewUserExperienceCash(userId);\n            &#125;\n        &#125;);\n        thread.start();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 第二种实现方式，其他类代码不变，就没有再重复罗列\n&#x2F;&#x2F;尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 \n&#x2F;&#x2F;register() 函数中，增加了这部分业务代码的维护成本\npublic class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n    private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();\n    &#x2F;&#x2F;实现线程池\n    private Executor executor;\n\n    public UserController(Executor executor) &#123;\n        this.executor &#x3D; executor;\n    &#125;\n\n    public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;\n        regObservers.addAll(observers);\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n\n        for (RegObserver observer : regObservers) &#123;\n            executor.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    observer.handleRegSuccess(userId);\n                &#125;\n            &#125;);\n        &#125;\n\n        return userId;\n    &#125;\n&#125;\nEventBus框架（事件总线）\n\n提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。\n\n重构后\npublic class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n\n    private EventBus eventBus;\n    private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;\n\n    public UserController() &#123;\n        &#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式\n        eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool\n                                     (DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); &#x2F;&#x2F; 异步非阻塞\n    &#125;\n\n    public void setRegObservers(List&lt;Object&gt; observers) &#123;\n        for (Object observer : observers) &#123;\n            &#x2F;&#x2F;用来注册任何类型（Object）的观察者，而在经典的观察者模式的实现中，\n            &#x2F;&#x2F;register() 函数必须接受实现了同一 Observer 接口的类对象。\n            eventBus.register(observer);\n        &#125;\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n        \n\t\t&#x2F;&#x2F;用来给观察者发送信息，当我们调用post()函数发送信息的时候，并非把消息发送给\n        &#x2F;&#x2F;所有的观察者，而是发送给可匹配的观察者，即接受的消息类型是发送消息（post\n        &#x2F;&#x2F;函数定义中的event）类型的父类\n        eventBus.post(userId);\n\n        return userId;\n    &#125;\n&#125;\n\npublic class RegPromotionObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Subscribe&#x2F;&#x2F;定义能接收的消息类型\n    public void handleRegSuccess(Long userId) &#123;\n        promotionService.issueNewUserExperienceCash(userId);\n    &#125;\n&#125;\n\npublic class RegNotificationObserver &#123;\n    private NotificationService notificationService;\n\n    @Subscribe\n    public void handleRegSuccess(Long userId) &#123;\n        notificationService.sendInboxMessage(userId, &quot;...&quot;);\n    &#125;\n&#125;\n\n\n@Subscribe注解：当通过 register() 函数将 DObserver 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe 注解找到 f1() 和 f2()，并且将两个函数能接收的消息类型记录下来（PMsg-&gt;f1，QMsg-&gt;f2）。当我们通过 post() 函数发送消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）。\npublic DObserver &#123;\n  &#x2F;&#x2F;...省略其他属性和方法...\n  \n  @Subscribe\n  public void f1(PMsg event) &#123; &#x2F;&#x2F;... &#125;\n  \n  @Subscribe\n  public void f2(QMsg event) &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\n\nEventBus框架实现\n\n\n\n\n\n\n2.模板模式\n\n\n\n\n\n\n\n\n模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。\n\n代码实现：模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。\npublic abstract class AbstractClass &#123;\n    &#x2F;&#x2F;定义为final，避免子类重写\n    public final void templateMethod() &#123;\n        &#x2F;&#x2F;...\n        method1();\n        &#x2F;&#x2F;...\n        method2();\n        &#x2F;&#x2F;...\n    &#125;\n\t&#x2F;&#x2F;定义为abstract是为了强迫子类去实现\n    protected abstract void method1();\n    protected abstract void method2();\n&#125;\n\npublic class ConcreteClass1 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n\n    @Override\n    protected void method2() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class ConcreteClass2 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n\n    @Override\n    protected void method2() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nAbstractClass demo &#x3D; ConcreteClass1();\ndemo.templateMethod();\n作用一：代码的复用\n\nJava InputStream：read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同\npublic abstract class InputStream implements Closeable &#123;\n    &#x2F;&#x2F;...省略其他代码...\n\n    public int read(byte b[], int off, int len) throws IOException &#123;\n        if (b &#x3D;&#x3D; null) &#123;\n            throw new NullPointerException();\n        &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125; else if (len &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n\n        int c &#x3D; read();\n        if (c &#x3D;&#x3D; -1) &#123;\n            return -1;\n        &#125;\n        b[off] &#x3D; (byte)c;\n\n        int i &#x3D; 1;\n        try &#123;\n            for (; i &lt; len ; i++) &#123;\n                c &#x3D; read();\n                if (c &#x3D;&#x3D; -1) &#123;\n                    break;\n                &#125;\n                b[off + i] &#x3D; (byte)c;\n            &#125;\n        &#125; catch (IOException ee) &#123;\n        &#125;\n        return i;\n    &#125;\n\t&#x2F;&#x2F;抽象方法\n    public abstract int read() throws IOException;\n&#125;\n\npublic class ByteArrayInputStream extends InputStream &#123;\n    &#x2F;&#x2F;...省略其他代码...\n\n    @Override\n    public synchronized int read() &#123;\n        return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;\n    &#125;\n&#125;\nJava AbstractList：addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的。\npublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;\n    rangeCheckForAdd(index);\n    boolean modified &#x3D; false;\n    for (E e : c) &#123;\n        add(index++, e);\n        modified &#x3D; true;\n    &#125;\n    return modified;\n&#125;\n\npublic void add(int index, E element) &#123;\n    throw new UnsupportedOperationException();\n&#125;\n\n\n作用二：框架的扩展\n\nJava Servlet：\n\n使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。\npublic class HelloServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doPost(req, resp);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        resp.getWriter().write(&quot;Hello World.&quot;);\n    &#125;\n&#125;\n在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。\n&lt;servlet&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;\n当我们在浏览器中输入网址（比如，http://127.0.0.1:8080/hello ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。\n\nHttpServlet的service()函数就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。\npublic void service(ServletRequest req, ServletResponse res)\n    throws ServletException, IOException\n&#123;\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &amp;&amp;\n          res instanceof HttpServletResponse)) &#123;\n        throw new ServletException(&quot;non-HTTP request or response&quot;);\n    &#125;\n    request &#x3D; (HttpServletRequest) req;\n    response &#x3D; (HttpServletResponse) res;\n    service(request, response);\n&#125;\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n&#123;\n    String method &#x3D; req.getMethod();\n    if (method.equals(METHOD_GET)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        if (lastModified &#x3D;&#x3D; -1) &#123;\n            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason\n            &#x2F;&#x2F; to go through further expensive logic\n            doGet(req, resp);\n        &#125; else &#123;\n            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince &lt; lastModified) &#123;\n                &#x2F;&#x2F; If the servlet mod time is later, call doGet()\n                &#x2F;&#x2F; Round down to the nearest second for a proper compare\n                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            &#125; else &#123;\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            &#125;\n        &#125;\n    &#125; else if (method.equals(METHOD_HEAD)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    &#125; else if (method.equals(METHOD_POST)) &#123;\n        doPost(req, resp);\n    &#125; else if (method.equals(METHOD_PUT)) &#123;\n        doPut(req, resp);\n    &#125; else if (method.equals(METHOD_DELETE)) &#123;\n        doDelete(req, resp);\n    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;\n        doOptions(req,resp);\n    &#125; else if (method.equals(METHOD_TRACE)) &#123;\n        doTrace(req,resp);\n    &#125; else &#123;\n        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);\n        Object[] errArgs &#x3D; new Object[1];\n        errArgs[0] &#x3D; method;\n        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    &#125;\n&#125;\n\n\nJUnit TestCase：\n\nJUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。\n\n在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。\npublic abstract class TestCase extends Assert implements Test &#123;\n    public void runBare() throws Throwable &#123;\n        Throwable exception &#x3D; null;\n        setUp();\n        try &#123;\n            runTest();\n        &#125; catch (Throwable running) &#123;\n            exception &#x3D; running;\n        &#125; finally &#123;\n            try &#123;\n                tearDown();\n            &#125; catch (Throwable tearingDown) &#123;\n                if (exception &#x3D;&#x3D; null) exception &#x3D; tearingDown;\n            &#125;\n        &#125;\n        if (exception !&#x3D; null) throw exception;\n    &#125;\n\n    &#x2F;**\n  * Sets up the fixture, for example, open a network connection.\n  * This method is called before a test is executed.\n  *&#x2F;\n    protected void setUp() throws Exception &#123;\n    &#125;\n\n    &#x2F;**\n  * Tears down the fixture, for example, close a network connection.\n  * This method is called after a test is executed.\n  *&#x2F;\n    protected void tearDown() throws Exception &#123;\n    &#125;\n&#125;\n\n\n\n\n回调（Callback）\n\n同步回调：相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。\npublic interface ICallback &#123;\n    void methodToCallback();\n&#125;\n\npublic class BClass &#123;\n    public void process(ICallback callback) &#123;\n        &#x2F;&#x2F;...\n        callback.methodToCallback();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class AClass &#123;\n    public static void main(String[] args) &#123;\n        BClass b &#x3D; new BClass();\n        \n        &#x2F;&#x2F;使用包裹了回调函数的类对象，我们简称为回调对象\n        &#x2F;&#x2F;A实现了methodToCallback()，并且调用process()，\n        &#x2F;&#x2F;process()函数又调用了methodToCallback()\n        \n        b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象\n            @Override\n            public void methodToCallback() &#123;\n                System.out.println(&quot;Call back me.&quot;);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n异步回调：通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。\n\n应用一：JdbcTemplate，Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。\n\nJdbcTemlate使用\npublic class JdbcTemplateDemo &#123;\n    private JdbcTemplate jdbcTemplate;\n\n    public User queryUser(long id) &#123;\n        String sql &#x3D; &quot;select * from user where id&#x3D;&quot;+id;\n        return jdbcTemplate.query(sql, new UserRowMapper()).get(0);\n    &#125;\n\n    class UserRowMapper implements RowMapper&lt;User&gt; &#123;\n        public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;\n            User user &#x3D; new User();\n            user.setId(rs.getLong(&quot;id&quot;));\n            user.setName(rs.getString(&quot;name&quot;));\n            user.setTelephone(rs.getString(&quot;telephone&quot;));\n            return user;\n        &#125;\n    &#125;\n&#125;\nJdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。\n@Override\npublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;\n    return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));\n&#125;\n\n@Override\npublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;\n    Assert.notNull(sql, &quot;SQL must not be null&quot;);\n    Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);\n    if (logger.isDebugEnabled()) &#123;\n        logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);\n    &#125;\n\t&#x2F;&#x2F;回调，实现了StatementCallback\n    class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;\n        @Override\n        public T doInStatement(Statement stmt) throws SQLException &#123;\n            ResultSet rs &#x3D; null;\n            try &#123;\n                rs &#x3D; stmt.executeQuery(sql);\n                ResultSet rsToUse &#x3D; rs;\n                if (nativeJdbcExtractor !&#x3D; null) &#123;\n                    rsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);\n                &#125;\n                return rse.extractData(rsToUse);\n            &#125;\n            finally &#123;\n                JdbcUtils.closeResultSet(rs);\n            &#125;\n        &#125;\n        @Override\n        public String getSql() &#123;\n            return sql;\n        &#125;\n    &#125;\n\n    return execute(new QueryStatementCallback());\n&#125;\n\n@Override\npublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;\n    Assert.notNull(action, &quot;Callback object must not be null&quot;);\n\n    Connection con &#x3D; DataSourceUtils.getConnection(getDataSource());\n    Statement stmt &#x3D; null;\n    try &#123;\n        Connection conToUse &#x3D; con;\n        if (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;\n            this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;\n            conToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);\n        &#125;\n        stmt &#x3D; conToUse.createStatement();\n        applyStatementSettings(stmt);\n        Statement stmtToUse &#x3D; stmt;\n        if (this.nativeJdbcExtractor !&#x3D; null) &#123;\n            stmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);\n        &#125;\n        T result &#x3D; action.doInStatement(stmtToUse);\n        handleWarnings(stmt);\n        return result;\n    &#125;\n    catch (SQLException ex) &#123;\n        &#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock\n        &#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.\n        JdbcUtils.closeStatement(stmt);\n        stmt &#x3D; null;\n        DataSourceUtils.releaseConnection(con, getDataSource());\n        con &#x3D; null;\n        throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);\n    &#125;\n    finally &#123;\n        JdbcUtils.closeStatement(stmt);\n        DataSourceUtils.releaseConnection(con, getDataSource());\n    &#125;\n&#125;\n\n\n应用二：setClickListner()，异步回调，往 setOnClickListener() 函数中注册好回调函数之后，并不需要等待回调函数执行\nButton button &#x3D; (Button)findViewById(R.id.button);\nbutton.setOnClickListener(new OnClickListener() &#123;\n    @Override\n    public void onClick(View v) &#123;\n        System.out.println(&quot;I am clicked.&quot;);\n    &#125;\n&#125;);\n应用三：addShutdownHook，异步调用\n\nJVM的Runtime.addShutdownHook(Thread hook)，当程序关闭时，JVM会自动调用Hook代码（Callback 更侧重语法机制的描述，Hook 更加侧重应用场景的描述。）\npublic class ShutdownHookDemo &#123;\n\n    private static class ShutdownHook extends Thread &#123;\n        public void run() &#123;\n            System.out.println(&quot;I am called during shutting down.&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n    &#125;\n\n&#125;\n当应用程序关闭的时候，JVM 会调用这个类的 runHooks() 方法，创建多个线程，并发地执行多个 Hook。我们在注册完 Hook 之后，并不需要等待 Hook 执行完成，所以，这也算是一种异步回调。\npublic class Runtime &#123;\n    public void addShutdownHook(Thread hook) &#123;\n        SecurityManager sm &#x3D; System.getSecurityManager();\n        if (sm !&#x3D; null) &#123;\n            sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n        &#125;\n        ApplicationShutdownHooks.add(hook);\n    &#125;\n&#125;\n\nclass ApplicationShutdownHooks &#123;\n    &#x2F;* The set of registered hooks *&#x2F;\n    private static IdentityHashMap&lt;Thread, Thread&gt; hooks;\n    static &#123;\n        hooks &#x3D; new IdentityHashMap&lt;&gt;();\n    &#125; catch (IllegalStateException e) &#123;\n        hooks &#x3D; null;\n    &#125;\n\n\n    static synchronized void add(Thread hook) &#123;\n        if(hooks &#x3D;&#x3D; null)\n            throw new IllegalStateException(&quot;Shutdown in progress&quot;);\n\n        if (hook.isAlive())\n            throw new IllegalArgumentException(&quot;Hook already running&quot;);\n\n        if (hooks.containsKey(hook))\n            throw new IllegalArgumentException(&quot;Hook previously registered&quot;);\n\n        hooks.put(hook, hook);\n    &#125;\n\n    static void runHooks() &#123;\n        Collection&lt;Thread&gt; threads;\n        synchronized(ApplicationShutdownHooks.class) &#123;\n            threads &#x3D; hooks.keySet();\n            hooks &#x3D; null;\n        &#125;\n\n        for (Thread hook : threads) &#123;\n            hook.start();\n        &#125;\n        for (Thread hook : threads) &#123;\n            while (true) &#123;\n                try &#123;\n                    hook.join();\n                    break;\n                &#125; catch (InterruptedException ignored) &#123;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n模板模式VS回调，在代码实现上，回调相对于模板模式会更加灵活\n\n像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。\n回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。\n如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。\n\n\n\n\n\n3.策略模式\n\n\n\n\n\n\n\n\n定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。\n\n主要用于解耦策略的定义、创建、使用这三部分\n\n策略的定义：基于接口而非实现编程\npublic interface Strategy &#123;\n    void algorithmInterface();\n&#125;\n\npublic class ConcreteStrategyA implements Strategy &#123;\n    @Override\n    public void  algorithmInterface() &#123;\n        &#x2F;&#x2F;具体的算法...\n    &#125;\n&#125;\n\npublic class ConcreteStrategyB implements Strategy &#123;\n    @Override\n    public void  algorithmInterface() &#123;\n        &#x2F;&#x2F;具体的算法...\n    &#125;\n&#125;\n策略的创建：对客户端封装策略创建细节（策略无状态就先创建，有状态就每次返回新创建的策略对象）\n&#x2F;&#x2F;无状态\npublic class StrategyFactory &#123;\n    private static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        strategies.put(&quot;A&quot;, new ConcreteStrategyA());\n        strategies.put(&quot;B&quot;, new ConcreteStrategyB());\n    &#125;\n\n    public static Strategy getStrategy(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n        &#125;\n        return strategies.get(type);\n    &#125;\n&#125;\n&#x2F;&#x2F;有状态\npublic class StrategyFactory &#123;\n    public static Strategy getStrategy(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n        &#125;\n\n        if (type.equals(&quot;A&quot;)) &#123;\n            return new ConcreteStrategyA();\n        &#125; else if (type.equals(&quot;B&quot;)) &#123;\n            return new ConcreteStrategyB();\n        &#125;\n\n        return null;\n    &#125;\n&#125;\n策略的使用：运行时（配置、用户输入、计算结果等）动态确定选用哪种策略\n&#x2F;&#x2F; 策略接口：EvictionStrategy\n&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory\npublic class UserCache &#123;\n    private Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();\n    private EvictionStrategy eviction;\n\n    public UserCache(EvictionStrategy eviction) &#123;\n        this.eviction &#x3D; eviction;\n    &#125;\n\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application &#123;\n    public static void main(String[] args) throws Exception &#123;\n        EvictionStrategy evictionStrategy &#x3D; null;\n        Properties props &#x3D; new Properties();\n        props.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));\n        String type &#x3D; props.getProperty(&quot;eviction_type&quot;);\n        evictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);\n        UserCache userCache &#x3D; new UserCache(evictionStrategy);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略\n&#x2F;&#x2F;策略模式退化成”面向对象的多态特性”或“基于接口而非实现编程原则”\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;...\n        EvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();\n        UserCache userCache &#x3D; new UserCache(evictionStrategy);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n\n避免分支判断逻辑：借助查表法来替代分支判断\n\n重构前\npublic class OrderService &#123;\n    public double discount(Order order) &#123;\n        double discount &#x3D; 0.0;\n        OrderType type &#x3D; order.getType();\n        if (type.equals(OrderType.NORMAL)) &#123; &#x2F;&#x2F; 普通订单\n            &#x2F;&#x2F;...省略折扣计算算法代码\n        &#125; else if (type.equals(OrderType.GROUPON)) &#123; &#x2F;&#x2F; 团购订单\n            &#x2F;&#x2F;...省略折扣计算算法代码\n        &#125; else if (type.equals(OrderType.PROMOTION)) &#123; &#x2F;&#x2F; 促销订单\n            &#x2F;&#x2F;...省略折扣计算算法代码\n        &#125;\n        return discount;\n    &#125;\n&#125;\n重构后\n&#x2F;&#x2F; 策略的定义\npublic interface DiscountStrategy &#123;\n    double calDiscount(Order order);\n&#125;\n&#x2F;&#x2F; 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...\n\n&#x2F;&#x2F; 策略的创建\npublic class DiscountStrategyFactory &#123;\n    private static final Map&lt;OrderType, DiscountStrategy&gt; strategies &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());\n        strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());\n        strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());\n    &#125;\n\n    public static DiscountStrategy getDiscountStrategy(OrderType type) &#123;\n        return strategies.get(type);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 策略的使用\npublic class OrderService &#123;\n    public double discount(Order order) &#123;\n        OrderType type &#x3D; order.getType();\n        DiscountStrategy discountStrategy &#x3D; DiscountStrategyFactory.getDiscountStrategy(type);\n        return discountStrategy.calDiscount(order);\n    &#125;\n&#125;\n\n\n应用：实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔（文件可能很大）\n\n重构前\npublic class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n            quickSort(filePath);\n        &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n            externalSort(filePath);\n        &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n            concurrentExternalSort(filePath);\n        &#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n            mapreduceSort(filePath);\n        &#125;\n    &#125;\n\n    private void quickSort(String filePath) &#123;\n        &#x2F;&#x2F; 快速排序\n    &#125;\n\n    private void externalSort(String filePath) &#123;\n        &#x2F;&#x2F; 外部排序\n    &#125;\n\n    private void concurrentExternalSort(String filePath) &#123;\n        &#x2F;&#x2F; 多线程外部排序\n    &#125;\n\n    private void mapreduceSort(String filePath) &#123;\n        &#x2F;&#x2F; 利用MapReduce多机排序\n    &#125;\n&#125;\n\npublic class SortingTool &#123;\n    public static void main(String[] args) &#123;\n        Sorter sorter &#x3D; new Sorter();\n        sorter.sortFile(args[0]);\n    &#125;\n&#125;\n第一次重构后：基于接口而非实现编程\npublic interface ISortAlg &#123;\n    void sort(String filePath);\n&#125;\n\npublic class QuickSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class ExternalSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class ConcurrentExternalSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class MapReduceSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        ISortAlg sortAlg;\n        if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n            sortAlg &#x3D; new QuickSort();\n        &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n            sortAlg &#x3D; new ExternalSort();\n        &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n            sortAlg &#x3D; new ConcurrentExternalSort();\n        &#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n            sortAlg &#x3D; new MapReduceSort();\n        &#125;\n        sortAlg.sort(filePath);\n    &#125;\n&#125;\n第二次重构后：工厂模式\npublic class SortAlgFactory &#123;\n    private static final Map&lt;String, ISortAlg&gt; algs &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        algs.put(&quot;QuickSort&quot;, new QuickSort());\n        algs.put(&quot;ExternalSort&quot;, new ExternalSort());\n        algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());\n        algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());\n    &#125;\n\n    public static ISortAlg getSortAlg(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n        &#125;\n        return algs.get(type);\n    &#125;\n&#125;\n\npublic class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        ISortAlg sortAlg;\n        if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);\n        &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);\n        &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);\n        &#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);\n        &#125;\n        sortAlg.sort(filePath);\n    &#125;\n&#125;\n第三次重构后：用表移除分支判断\npublic class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n    private static final List&lt;AlgRange&gt; algs &#x3D; new ArrayList&lt;&gt;();\n    static &#123;\n        algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));\n        algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));\n        algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));\n        algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));\n    &#125;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        ISortAlg sortAlg &#x3D; null;\n        for (AlgRange algRange : algs) &#123;\n            if (algRange.inRange(fileSize)) &#123;\n                sortAlg &#x3D; algRange.getAlg();\n                break;\n            &#125;\n        &#125;\n        sortAlg.sort(filePath);\n    &#125;\n\n    private static class AlgRange &#123;\n        private long start;\n        private long end;\n        private ISortAlg alg;\n\n        public AlgRange(long start, long end, ISortAlg alg) &#123;\n            this.start &#x3D; start;\n            this.end &#x3D; end;\n            this.alg &#x3D; alg;\n        &#125;\n\n        public ISortAlg getAlg() &#123;\n            return alg;\n        &#125;\n\n        public boolean inRange(long size) &#123;\n            return size &gt;&#x3D; start &amp;&amp; size &lt; end;\n        &#125;\n    &#125;\n&#125;\n\n\n\n4.职责链模式\n\n\n\n\n\n\n\n\n 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。\n\n实现一\npublic abstract class Handler &#123;\n    protected Handler successor &#x3D; null;\n\n    public void setSuccessor(Handler successor) &#123;\n        this.successor &#x3D; successor;\n    &#125;\n\n    public final void handle() &#123;\n        &#x2F;&#x2F;如果没有handled判断，则可以全部处理一遍\n        boolean handled &#x3D; doHandle();\n        if (successor !&#x3D; null &amp;&amp; !handled) &#123;\n            successor.handle();\n        &#125;\n    &#125;\n\n    protected abstract boolean doHandle();\n&#125;\n\npublic class HandlerA extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; HandlerChain和Application代码不变\n实现二\npublic interface IHandler &#123;\n    boolean handle();\n&#125;\n\npublic class HandlerA implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerChain &#123;\n    private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();\n\n    public void addHandler(IHandler handler) &#123;\n        this.handlers.add(handler);\n    &#125;\n\n    public void handle() &#123;\n        for (IHandler handler : handlers) &#123;\n            boolean handled &#x3D; handler.handle();\n            if (handled) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        HandlerChain chain &#x3D; new HandlerChain();\n        chain.addHandler(new HandlerA());\n        chain.addHandler(new HandlerB());\n        chain.handle();\n    &#125;\n&#125;\n应用：敏感词过滤\npublic interface SensitiveWordFilter &#123;\n    boolean doFilter(Content content);\n&#125;\n\npublic class SexyWordFilter implements SensitiveWordFilter &#123;\n    @Override\n    public boolean doFilter(Content content) &#123;\n        boolean legal &#x3D; true;\n        &#x2F;&#x2F;...\n        return legal;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似\n\npublic class SensitiveWordFilterChain &#123;\n    private List&lt;SensitiveWordFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n\n    public void addFilter(SensitiveWordFilter filter) &#123;\n        this.filters.add(filter);\n    &#125;\n\n    &#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.\n    public boolean filter(Content content) &#123;\n        &#x2F;&#x2F;职责链\n        for (SensitiveWordFilter filter : filters) &#123;\n            if (!filter.doFilter(content)) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\npublic class ApplicationDemo &#123;\n    public static void main(String[] args) &#123;\n        SensitiveWordFilterChain filterChain &#x3D; new SensitiveWordFilterChain();\n        filterChain.addFilter(new AdsWordFilter());\n        filterChain.addFilter(new SexyWordFilter());\n        filterChain.addFilter(new PoliticalWordFilter());\n\n        boolean legal &#x3D; filterChain.filter(new Content());\n        if (!legal) &#123;\n            &#x2F;&#x2F; 不发表\n        &#125; else &#123;\n            &#x2F;&#x2F; 发表\n        &#125;\n    &#125;\n&#125;\n应用：过滤器、拦截器\n\nServelt Filter：可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数\n\n使用\npublic class LogFilter implements Filter &#123;\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#x2F;&#x2F; 在创建Filter时自动调用，\n    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）\n  &#125;\n\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    chain.doFilter(request, response);\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  &#125;\n\n  @Override\n  public void destroy() &#123;\n    &#x2F;&#x2F; 在销毁Filter时自动调用\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 在web.xml配置文件中如下配置：\n&lt;filter&gt;\n  &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;\n  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;\nFilterChain处理方式（Tomcat）\npublic final class ApplicationFilterChain implements FilterChain &#123;\n    private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter\n    private int n; &#x2F;&#x2F;filter的个数\n    private ApplicationFilterConfig[] filters;\n    private Servlet servlet;\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response) &#123;\n        if (pos &lt; n) &#123;\n            ApplicationFilterConfig filterConfig &#x3D; filters[pos++];\n            Filter filter &#x3D; filterConfig.getFilter();\n            filter.doFilter(request, response, this);\n            &#x2F;&#x2F;递归调用，实现前后双向拦截\n            &#x2F;&#x2F;System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n            &#x2F;&#x2F;chain.doFilter(request, response);\n    \t\t&#x2F;&#x2F;System.out.println(&quot;拦截发送给客户端的响应.&quot;);            \n        &#125; else &#123;\n            &#x2F;&#x2F; filter都处理完毕后，执行servlet\n            servlet.service(request, response);\n        &#125;\n    &#125;\n\n    public void addFilter(ApplicationFilterConfig filterConfig) &#123;\n        for (ApplicationFilterConfig filter:filters)\n            if (filter&#x3D;&#x3D;filterConfig)\n                return;\n\n        if (n &#x3D;&#x3D; filters.length) &#123;&#x2F;&#x2F;扩容\n            ApplicationFilterConfig[] newFilters &#x3D; new ApplicationFilterConfig[n + INCREMENT];\n            System.arraycopy(filters, 0, newFilters, 0, n);\n            filters &#x3D; newFilters;\n        &#125;\n        filters[n++] &#x3D; filterConfig;\n    &#125;\n&#125;\n\n\nSpring Interceptor\n\n使用\npublic class LogInterceptor implements HandlerInterceptor &#123;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n        return true; &#x2F;&#x2F; 继续后续的处理\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;这里总是被执行.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;在Spring MVC配置文件中配置interceptors\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;*&quot;&#x2F;&gt;\n            &lt;bean class&#x3D;&quot;com.xzg.cd.LogInterceptor&quot; &#x2F;&gt;\n                &lt;&#x2F;mvc:interceptor&gt;\n                    &lt;&#x2F;mvc:interceptors&gt;\n实现：在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。\npublic class HandlerExecutionChain &#123;\n    private final Object handler;\n    private HandlerInterceptor[] interceptors;\n\n    public void addInterceptor(HandlerInterceptor interceptor) &#123;\n        initInterceptorList().add(interceptor);\n    &#125;\n\n    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                if (!interceptor.preHandle(request, response, this.handler)) &#123;\n                    triggerAfterCompletion(request, response, null);\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                interceptor.postHandle(request, response, this.handler, mv);\n            &#125;\n        &#125;\n    &#125;\n\n    void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)\n        throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                try &#123;\n                    interceptor.afterCompletion(request, response, this.handler, ex);\n                &#125; catch (Throwable ex2) &#123;\n                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n5.状态模式\n\n\n\n\n\n\n\n\n一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中\n\n有限状态机（Finite State Machine，FSM），有三个组成部分：状态（State）、事件（Event）、动作（Action）\npublic enum State &#123;\n    SMALL(0),\n    SUPER(1),\n    FIRE(2),\n    CAPE(3);\n\n    private int value;\n\n    private State(int value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public int getValue() &#123;\n        return this.value;\n    &#125;\n&#125;\n\npublic class MarioStateMachine &#123;\n    private int score;\n    private State currentState;\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; State.SMALL;\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public void obtainCape() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public void meetMonster() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState;\n    &#125;\n&#125;\n\npublic class ApplicationDemo &#123;\n    public static void main(String[] args) &#123;\n        MarioStateMachine mario &#x3D; new MarioStateMachine();\n        mario.obtainMushRoom();\n        int score &#x3D; mario.getScore();\n        State state &#x3D; mario.getCurrentState();\n        System.out.println(&quot;mario score: &quot; + score + &quot;; state: &quot; + state);\n    &#125;\n&#125;\n状态机实现方式一：分支逻辑法，参照状态转移图，直接将每一个状态转移翻译成代码\npublic class MarioStateMachine &#123;\n    private int score;\n    private State currentState;\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; State.SMALL;\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        if (currentState.equals(State.SMALL)) &#123;\n            this.currentState &#x3D; State.SUPER;\n            this.score +&#x3D; 100;\n        &#125;\n    &#125;\n\n    public void obtainCape() &#123;\n        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;\n            this.currentState &#x3D; State.CAPE;\n            this.score +&#x3D; 200;\n        &#125;\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;\n            this.currentState &#x3D; State.FIRE;\n            this.score +&#x3D; 300;\n        &#125;\n    &#125;\n\n    public void meetMonster() &#123;\n        if (currentState.equals(State.SUPER)) &#123;\n            this.currentState &#x3D; State.SMALL;\n            this.score -&#x3D; 100;\n            return;\n        &#125;\n\n        if (currentState.equals(State.CAPE)) &#123;\n            this.currentState &#x3D; State.SMALL;\n            this.score -&#x3D; 200;\n            return;\n        &#125;\n\n        if (currentState.equals(State.FIRE)) &#123;\n            this.currentState &#x3D; State.SMALL;\n            this.score -&#x3D; 300;\n            return;\n        &#125;\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState;\n    &#125;\n&#125;\n状态机实现方式二：查表法\npublic enum Event &#123;\n    GOT_MUSHROOM(0),\n    GOT_CAPE(1),\n    GOT_FIRE(2),\n    MET_MONSTER(3);\n\n    private int value;\n\n    private Event(int value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public int getValue() &#123;\n        return this.value;\n    &#125;\n&#125;\n\npublic class MarioStateMachine &#123;\n    private int score;\n    private State currentState;\n\n    private static final State[][] transitionTable &#x3D; &#123;\n        &#123;SUPER, CAPE, FIRE, SMALL&#125;,\n        &#123;SUPER, CAPE, FIRE, SMALL&#125;,\n        &#123;CAPE, CAPE, CAPE, SMALL&#125;,\n        &#123;FIRE, FIRE, FIRE, SMALL&#125;\n    &#125;;\n\n    private static final int[][] actionTable &#x3D; &#123;\n        &#123;+100, +200, +300, +0&#125;,\n        &#123;+0, +200, +300, -100&#125;,\n        &#123;+0, +0, +0, -200&#125;,\n        &#123;+0, +0, +0, -300&#125;\n    &#125;;\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; State.SMALL;\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        executeEvent(Event.GOT_MUSHROOM);\n    &#125;\n\n    public void obtainCape() &#123;\n        executeEvent(Event.GOT_CAPE);\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        executeEvent(Event.GOT_FIRE);\n    &#125;\n\n    public void meetMonster() &#123;\n        executeEvent(Event.MET_MONSTER);\n    &#125;\n\n    private void executeEvent(Event event) &#123;\n        int stateValue &#x3D; currentState.getValue();\n        int eventValue &#x3D; event.getValue();\n        this.currentState &#x3D; transitionTable[stateValue][eventValue];\n        this.score +&#x3D; actionTable[stateValue][eventValue];\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState;\n    &#125;\n\n&#125;\n状态机实现方式三：状态模式，通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑\n&#x2F;&#x2F;所有状态类的接口，定义了所有的事件\npublic interface IMario &#123; \n    State getName();\n    &#x2F;&#x2F;以下是定义的事件\n    void obtainMushRoom();\n    void obtainCape();\n    void obtainFireFlower();\n    void meetMonster();\n&#125;\n\npublic class SmallMario implements IMario &#123;\n    private MarioStateMachine stateMachine;\n\n    public SmallMario(MarioStateMachine stateMachine) &#123;\n        this.stateMachine &#x3D; stateMachine;\n    &#125;\n\n    @Override\n    public State getName() &#123;\n        return State.SMALL;\n    &#125;\n\n    @Override\n    public void obtainMushRoom() &#123;\n        stateMachine.setCurrentState(new SuperMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 100);\n    &#125;\n\n    @Override\n    public void obtainCape() &#123;\n        stateMachine.setCurrentState(new CapeMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 200);\n    &#125;\n\n    @Override\n    public void obtainFireFlower() &#123;\n        stateMachine.setCurrentState(new FireMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 300);\n    &#125;\n\n    @Override\n    public void meetMonster() &#123;\n        &#x2F;&#x2F; do nothing...\n    &#125;\n&#125;\n\npublic class SuperMario implements IMario &#123;\n    private MarioStateMachine stateMachine;\n\n    public SuperMario(MarioStateMachine stateMachine) &#123;\n        this.stateMachine &#x3D; stateMachine;\n    &#125;\n\n    @Override\n    public State getName() &#123;\n        return State.SUPER;\n    &#125;\n\n    @Override\n    public void obtainMushRoom() &#123;\n        &#x2F;&#x2F; do nothing...\n    &#125;\n\n    @Override\n    public void obtainCape() &#123;\n        stateMachine.setCurrentState(new CapeMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 200);\n    &#125;\n\n    @Override\n    public void obtainFireFlower() &#123;\n        stateMachine.setCurrentState(new FireMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 300);\n    &#125;\n\n    @Override\n    public void meetMonster() &#123;\n        stateMachine.setCurrentState(new SmallMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() - 100);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 省略CapeMario、FireMario类...\npublic class MarioStateMachine &#123;\n    private int score;\n    private IMario currentState; &#x2F;&#x2F; 不再使用枚举来表示状态\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; new SmallMario(this);\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        this.currentState.obtainMushRoom();\n    &#125;\n\n    public void obtainCape() &#123;\n        this.currentState.obtainCape();\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        this.currentState.obtainFireFlower();\n    &#125;\n\n    public void meetMonster() &#123;\n        this.currentState.meetMonster();\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState.getName();\n    &#125;\n\n    public void setScore(int score) &#123;\n        this.score &#x3D; score;\n    &#125;\n\n    public void setCurrentState(IMario currentState) &#123;\n        this.currentState &#x3D; currentState;\n    &#125;\n&#125;\n\n6.迭代器（游标）模式\n\n\n\n\n\n\n\n\n迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，用来遍历容器\n\n实现：针对继承自List接口的两个类ArrayList和LinkerList，设计实现对应的迭代器，继承自Iterator接口的ArrayIterator和ListIterator\n\n迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。\n待遍历的容器对象通过依赖注入传递到迭代器类中。\n容器通过 iterator() 方法来创建迭代器。\n\n&#x2F;&#x2F;接口定义\npublic interface Iterator&lt;E&gt; &#123;\n    boolean hasNext();\n    void next();\n    E currentItem();\n&#125;\npublic interface List&lt;E&gt; &#123;\n    Iterator iterator();\n    &#x2F;&#x2F;...省略其他接口函数...\n&#125;\n\npublic class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    private int cursor;\n    private ArrayList&lt;E&gt; arrayList;\n\n    public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n        this.cursor &#x3D; 0;\n        this.arrayList &#x3D; arrayList;\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        return cursor !&#x3D; arrayList.size(); &#x2F;&#x2F;注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。\n    &#125;\n\n    @Override\n    public void next() &#123;\n        cursor++;\n    &#125;\n\n    @Override\n    public E currentItem() &#123;\n        if (cursor &gt;&#x3D; arrayList.size()) &#123;\n            throw new NoSuchElementException();\n        &#125;\n        return arrayList.get(cursor);\n    &#125;\n&#125;\n\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    &#x2F;&#x2F;...\n    public Iterator iterator() &#123;\n        return new ArrayIterator(this);\n    &#125;\n    &#x2F;&#x2F;...省略其他代码\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n        names.add(&quot;xzg&quot;);\n        names.add(&quot;wang&quot;);\n        names.add(&quot;zheng&quot;);\n\n        &#x2F;&#x2F;Iterator&lt;String&gt; iterator &#x3D; new ArrayIterator(names);\n        Iterator&lt;String&gt; iterator &#x3D; names.iterator();\n        \n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.currentItem());\n            iterator.next();\n        &#125;\n    &#125;\n&#125;\n优势：\n\n首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，有各种复杂的遍历方式。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。\n其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，同时对同一个容器进行遍历而互不影响。\n最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，基于接口而非具体的实现编程。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。\n\n\n未决行为\n\n在遍历的同时增删集合元素\npublic class Demo &#123; \n    public static void main(String[] args) &#123; \n        List names &#x3D; new ArrayList&lt;&gt;(); \n        names.add(&quot;a&quot;); \n        names.add(&quot;b&quot;); \n        names.add(&quot;c&quot;); \n        names.add(&quot;d&quot;); \n        Iterator iterator &#x3D; names.iterator(); \n        iterator.next();\n        \n        &#x2F;&#x2F;会使得元素移位，最后游标指向c而不是b\n        names.remove(&quot;a&quot;); \n        \n        &#x2F;&#x2F;也会使元素移位，\n        &#x2F;&#x2F;names.add(0, &quot;x&quot;);\n    &#125;\n&#125;\n如何应对：\n\n一种是遍历的时候不允许增删元素（难实现）\n\n另一种是增删元素之后让遍历报错：modCount记录集合被修改的次数，\npublic class ArrayIterator implements Iterator &#123;\n    private int cursor;\n    private ArrayList arrayList;\n    &#x2F;&#x2F;记录遍历开始时ModCount\n    private int expectedModCount;\n\n    public ArrayIterator(ArrayList arrayList) &#123;\n        this.cursor &#x3D; 0;\n        this.arrayList &#x3D; arrayList;\n        this.expectedModCount &#x3D; arrayList.modCount;\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        checkForComodification();\n        return cursor &lt; arrayList.size();\n    &#125;\n\n    @Override\n    public void next() &#123;\n        checkForComodification();\n        cursor++;\n    &#125;\n\n    @Override\n    public Object currentItem() &#123;\n        checkForComodification();\n        return arrayList.get(cursor);\n    &#125;\n\n    private void checkForComodification() &#123;\n        if (arrayList.modCount !&#x3D; expectedModCount)\n            throw new ConcurrentModificationException();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;代码示例\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n        names.add(&quot;a&quot;);\n        names.add(&quot;b&quot;);\n        names.add(&quot;c&quot;);\n        names.add(&quot;d&quot;);\n\n        Iterator&lt;String&gt; iterator &#x3D; names.iterator();\n        iterator.next();\n        names.remove(&quot;a&quot;);\n        iterator.next();&#x2F;&#x2F;抛出ConcurrentModificationException异常\n    &#125;\n&#125;\n\n\n遍历的同时安全地删除集合元素：Java语言的Iterator定义了一个remove()操作，安全的删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()会报错\npublic class ArrayList&lt;E&gt; &#123;\n    transient Object[] elementData;\n    private int size;\n\n    public Iterator&lt;E&gt; iterator() &#123;\n        return new Itr();\n    &#125;\n\n    private class Itr implements Iterator&lt;E&gt; &#123;\n        int cursor;       &#x2F;&#x2F; index of next element to return\n        &#x2F;&#x2F;用来记录游标指向的前一个元素\n        int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such\n        int expectedModCount &#x3D; modCount;\n\n        Itr() &#123;&#125;\n\n        public boolean hasNext() &#123;\n            return cursor !&#x3D; size;\n        &#125;\n\n        @SuppressWarnings(&quot;unchecked&quot;)\n        public E next() &#123;\n            checkForComodification();\n            int i &#x3D; cursor;\n            if (i &gt;&#x3D; size)\n                throw new NoSuchElementException();\n            Object[] elementData &#x3D; ArrayList.this.elementData;\n            if (i &gt;&#x3D; elementData.length)\n                throw new ConcurrentModificationException();\n            cursor &#x3D; i + 1;\n            return (E) elementData[lastRet &#x3D; i];\n        &#125;\n\n        public void remove() &#123;\n            if (lastRet &lt; 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try &#123;\n                ArrayList.this.remove(lastRet);\n                cursor &#x3D; lastRet;\n                lastRet &#x3D; -1;\n                expectedModCount &#x3D; modCount;\n            &#125; catch (IndexOutOfBoundsException ex) &#123;\n                throw new ConcurrentModificationException();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n应用：支持快照功能的迭代器\n\n需求\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(3);\nlist.add(8);\nlist.add(2);\n\nIterator&lt;Integer&gt; iter1 &#x3D; list.iterator();&#x2F;&#x2F;snapshot: 3, 8, 2\nlist.remove(new Integer(2));&#x2F;&#x2F;list：3, 8\nIterator&lt;Integer&gt; iter2 &#x3D; list.iterator();&#x2F;&#x2F;snapshot: 3, 8\nlist.remove(new Integer(3));&#x2F;&#x2F;list：8\nIterator&lt;Integer&gt; iter3 &#x3D; list.iterator();&#x2F;&#x2F;snapshot: 3\n\n&#x2F;&#x2F; 输出结果：3 8 2\nwhile (iter1.hasNext()) &#123;\n    System.out.print(iter1.next() + &quot; &quot;);\n&#125;\nSystem.out.println();\n\n&#x2F;&#x2F; 输出结果：3 8\nwhile (iter2.hasNext()) &#123;\n    System.out.print(iter1.next() + &quot; &quot;);\n&#125;\nSystem.out.println();\n\n&#x2F;&#x2F; 输出结果：8\nwhile (iter3.hasNext()) &#123;\n    System.out.print(iter1.next() + &quot; &quot;);\n&#125;\nSystem.out.println();\nAPI总览\npublic ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    &#x2F;&#x2F; TODO: 成员变量、私有函数等随便你定义\n\n    @Override\n    public void add(E obj) &#123;\n        &#x2F;&#x2F;TODO: 由你来完善\n    &#125;\n\n    @Override\n    public void remove(E obj) &#123;\n        &#x2F;&#x2F; TODO: 由你来完善\n    &#125;\n\n    @Override\n    public Iterator&lt;E&gt; iterator() &#123;\n        return new SnapshotArrayIterator(this);\n    &#125;\n&#125;\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    &#x2F;&#x2F; TODO: 成员变量、私有函数等随便你定义\n\n    @Override\n    public boolean hasNext() &#123;\n        &#x2F;&#x2F; TODO: 由你来完善\n    &#125;\n\n    @Override\n    public E next() &#123;&#x2F;&#x2F;返回当前元素，并且游标后移一位\n        &#x2F;&#x2F; TODO: 由你来完善\n    &#125;\n&#125;\n解决方案一：定义一个成员变量snapshot来存储快照，增加内存的消耗，但Java的拷贝是浅拷贝（只拷贝对象的引用）\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    private int cursor;\n    private ArrayList&lt;E&gt; snapshot;\n\n    public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n        this.cursor &#x3D; 0;\n        this.snapshot &#x3D; new ArrayList&lt;&gt;();\n        this.snapshot.addAll(arrayList);\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        return cursor &lt; snapshot.size();\n    &#125;\n\n    @Override\n    public E next() &#123;\n        E currentItem &#x3D; snapshot.get(cursor);\n        cursor++;\n        return currentItem;\n    &#125;\n&#125;\n解决方案二：标记删除\n\n在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。\n同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 addTimestamp&lt;snapshotTimestamp&lt;delTimestamp的元素才是属于这个迭代器的快照。\n\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    private static final int DEFAULT_CAPACITY &#x3D; 10;\n\n    private int actualSize; &#x2F;&#x2F;不包含标记删除元素\n    private int totalSize; &#x2F;&#x2F;包含标记删除元素\n\n    private Object[] elements;\n    private long[] addTimestamps;\n    private long[] delTimestamps;\n\n    public ArrayList() &#123;\n        this.elements &#x3D; new Object[DEFAULT_CAPACITY];\n        this.addTimestamps &#x3D; new long[DEFAULT_CAPACITY];\n        this.delTimestamps &#x3D; new long[DEFAULT_CAPACITY];\n        this.totalSize &#x3D; 0;\n        this.actualSize &#x3D; 0;\n    &#125;\n\n    @Override\n    public void add(E obj) &#123;\n        elements[totalSize] &#x3D; obj;\n        addTimestamps[totalSize] &#x3D; System.currentTimeMillis();\n        delTimestamps[totalSize] &#x3D; Long.MAX_VALUE;\n        totalSize++;\n        actualSize++;\n    &#125;\n\n    @Override\n    public void remove(E obj) &#123;\n        for (int i &#x3D; 0; i &lt; totalSize; ++i) &#123;\n            if (elements[i].equals(obj)) &#123;\n                delTimestamps[i] &#x3D; System.currentTimeMillis();\n                actualSize--;\n            &#125;\n        &#125;\n    &#125;\n\n    public int actualSize() &#123;\n        return this.actualSize;\n    &#125;\n\n    public int totalSize() &#123;\n        return this.totalSize;\n    &#125;\n\n    public E get(int i) &#123;\n        if (i &gt;&#x3D; totalSize) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return (E)elements[i];\n    &#125;\n\n    public long getAddTimestamp(int i) &#123;\n        if (i &gt;&#x3D; totalSize) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return addTimestamps[i];\n    &#125;\n\n    public long getDelTimestamp(int i) &#123;\n        if (i &gt;&#x3D; totalSize) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return delTimestamps[i];\n    &#125;\n&#125;\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    private long snapshotTimestamp;\n    private int cursorInAll; &#x2F;&#x2F; 在整个容器中的下标，而非快照中的下标\n    private int leftCount; &#x2F;&#x2F; 快照中还有几个元素未被遍历\n    private ArrayList&lt;E&gt; arrayList;\n\n    public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n        this.snapshotTimestamp &#x3D; System.currentTimeMillis();\n        this.cursorInAll &#x3D; 0;\n        this.leftCount &#x3D; arrayList.actualSize();;\n        this.arrayList &#x3D; arrayList;\n\n        justNext(); &#x2F;&#x2F; 先跳到这个迭代器快照的第一个元素\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        return this.leftCount &gt;&#x3D; 0; &#x2F;&#x2F; 注意是&gt;&#x3D;, 而非&gt;\n    &#125;\n\n    @Override\n    public E next() &#123;\n        E currentItem &#x3D; arrayList.get(cursorInAll);\n        justNext();\n        return currentItem;\n    &#125;\n\n    private void justNext() &#123;\n        while (cursorInAll &lt; arrayList.totalSize()) &#123;\n            long addTimestamp &#x3D; arrayList.getAddTimestamp(cursorInAll);\n            long delTimestamp &#x3D; arrayList.getDelTimestamp(cursorInAll);\n            if (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;\n                leftCount--;\n                break;\n            &#125;\n            cursorInAll++;\n        &#125;\n    &#125;\n&#125;\n\n\n\n7.访问者模式\n访问者模式访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。\n对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到 Double Disptach。如果某种语言支持 Double Dispatch，那就不需要访问者模式了。\n正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。\n\n8.备忘录模式\n备忘录模式备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。\n备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。\n对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。\n\n9.命令模式\n命令模式命令模式在平时工作中并不常用，你稍微了解一下就可以。\n落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。\n命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。\n\n10.解释器模式\n解释器模式解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。\n要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。\n解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。\n\n11.中介模式\n中介模式中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。\n观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。\n\nDistributed System1.分布式系统概述\n1.分布式协调与同步1.分布式互斥：排他性的资源访问方式\n集中式算法：有一个协调者来约束大家按顺序使用排他性资源\n分布式算法：先征求其他人的意见，其他人都不同的时候可以使用\n令牌环算法：组成令牌环结构，拿到令牌的可以访问临界资源\n两层结构分布式令牌环：例如广域网一个令牌环，每个局域网内还有一个令牌环\n\n2.分布式选举：选出集群的主节点\nBully算法：\n在所有活着的节点中，选取ID最大的节点作为主节点\n选举过程\n集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息（竞选成功），宣誓自己的主权；\n如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送 Election 消息（用于发起选举），并等待其他节点的回复；若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息（应答Election消息），则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；\n若接收到来自比自己 ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；\n若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。\n\n\n应用：MongoDB的副本集故障转移功能，MongoDB 的分布式选举中，采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。\n\n\nRaft算法：\n少数服从多数，获得投票最多的节点成为主节点\n选举过程\n初始化时，所有节点均为 Follower 状态（Leader的跟随着）。\n开始选主时，所有节点的状态由 Follower 转化为 Candidate（候选者，可以被选为新Leader），并向其他节点发送选举请求。\n其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的是，在每一轮选举中，一个节点只能投出一张票。\n若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader（主节点）其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。\n当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。\n\n\n应用：Google 开源的 Kubernetes，擅长容器管理与调度，为了保证可靠性，通常会部署 3 个节点用于数据备份。这 3 个节点中，有一个会被选为主，其他节点作为备。Kubernetes 的选主采用的是开源的 etcd 组件。而，etcd 的集群管理器 etcds，是一个高可用、强一致性的服务发现存储仓库，就是采用了 Raft 算法来实现选主和一致性的。\n\n\nZAB算法：\nZookeeper实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。\n选举基础\n节点的三种角色：Leader，主节点；Follower，跟随者节点；Observer，观察者，无投票权。\n节点的四个状态：\nLooking 状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。\nLeading 状态，即领导者状态，表示已经选出主，且当前节点为 Leader。\nFollowing 状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为 Following，表示对 Leader 的追随。\nObserving 状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。\n\n\n每个节点都有唯一的三元组：(server_id, server_zxID, epoch)，其中 server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。\n\n\n选举过程（3个Server的集群）：==server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。==\n第一步：当系统刚启动时，3 个服务器当前投票均为第一轮投票，即 epoch=1，且 zxID 均为 0。此时每个服务器都推选自己，并将选票信息&lt;epoch, vote_id, vote_zxID&gt; 广播出去。\n第二步：根据判断规则，由于 3 个 Server 的 epoch、zxID 都相同，因此比较 server_id，较大者即为推选对象，因此 Server 1 和 Server 2 将 vote_id 改为 3，更新自己的投票箱并重新广播自己的投票。\n第三步：此时系统内所有服务器都推选了 Server 3，因此 Server 3 当选 Leader，处于 Leading 状态，向其他服务器发送心跳包并维护连接；Server1 和 Server2 处于 Following 状态。\n\n\n\n\n\n3.分布式共识：存异求同\n多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程\nPoW（Proof-of-Work，工作量证明，区块链）：以每个节点或服务器的计算能力（即“算力”）来竞争记账权的机制，因此是一种使用工作量证明机制的共识算法。也就是说，谁的计算力强、工作能力强，谁获得记账权的可能性就越大。\nPoS（Proof-of-Stake，权益证明，以太坊）：由系统权益（每个节点占有货币的数量和时间）代替算力来决定区块记账权，拥有的权益越大获得记账权的概率就越大\nDPoS（Delegated Proof of Stake，委托权益证明，比特股和Steem）：类似股份制公司的董事会制度，普通股民虽然拥有股权，但进不了董事会，他们可以投票选举代表（受托人）代他们做决策。DPoS 是由被社区选举的可信帐户（受托人，比如得票数排行前 101 位）来拥有记账权\n\n4.分布式事务：\n就是在分布式系统中运行的事务，由多个本地事务组合而成\nACID理论和BASE理论\n基于XA协议的二阶段提交协议方法（ACID）\nXA是一个分布式事务协议，规定了事务管理器和资源管理器接口。事务管理器相当于协调者，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者，通常由数据库实现，比如 Oracle、DB2 等商业数据库都实现了 XA 接口\n基于 XA 协议的二阶段提交方法中，二阶段提交协议（Two-phase Commit Protocol，2PC），用于保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。执行过程如下：\n投票（Voting）：在这一阶段，协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，将操作信息记录到事务日志中但不提交（即不会修改数据库中的数据），待参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。\n提交（Commit）：当所有的参与者都返回了操作结果后，系统进入了第二阶段提交阶段。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送 DoCommit（提交）或 DoAbort（取消）指令。具体规则如下：\n若协调者从参与者那里收到的都是“Yes”消息，则向参与者发送“DoCommit”消息。参与者收到“DoCommit”消息后，完成剩余的操作（比如修改数据库中的数据）并释放资源（整个事务过程中占用的资源），然后向协调者返回“HaveCommitted”消息；\n若协调者从参与者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息。此时投票阶段发送“Yes”消息的参与者，则会根据之前执行操作时的事务日志对操作进行回滚，就好像没有执行过请求操作一样，然后所有参与者会向协调者发送“HaveCommitted”消息；\n协调者接收到来自所有参与者的“HaveCommitted”消息后，就意味着整个事务结束了。\n\n\n\n\n\n\n三阶段提交协议方法（ACID）\n为了更好地处理两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了超时机制和准备阶段。\n提交过程\n第一，CanCommit 阶段。协调者向参与者发送请求操作（CanCommit 请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到 CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。\n第二，PreCommit 阶段。\n如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：协调者向参与者发送 PreCommit 请求，进入预提交阶段。参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。\n假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：协调者向所有参与者发送“Abort”消息。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的中断操作。\n\n\n第三，DoCommit 阶段。\n执行提交阶段：若协调者接收到所有参与者发送的 Ack 响应，则向所有参与者发送 DoCommit 消息，开始执行阶段。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源，并向协调者发送 Ack 响应。协调者接收到所有参与者的 Ack 响应之后，完成事务。\n事务中断阶段：协调者向所有参与者发送 Abort 请求。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo 信息执行事务的回滚操作，释放所有锁住的资源，并向协调者发送 Ack 消息。协调者接收到参与者反馈的 Ack 消息之后，执行事务的中断，并结束事务。\n\n\n\n\n\n\n基于分布式消息的最终一致性方法（BASE）\n将事务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件，数据库或消息队列中，再通过业务规划进行失败重试。\n采用消息传递机制，并使用异步通信的方式，避免了通信阻塞，从而增加系统的吞吐量。\n\n\n\n5.分布式锁：\n与普通锁不同的是，分布式锁是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁。为了保证多个进程能看到锁，锁被存在公共存储（比如 Redis、Memcached、数据库等三方存储中），以实现多个进程并发访问同一个临界资源，同一时刻只有一个进程可访问共享资源，确保数据的一致性。\n基于关系型数据库实现分布式锁：首先创建一张表用于记录共享资源信息，然后通过操作该表的数据来实现共享资源信息的修改。当我们要锁住某个资源时，就在该表中增加一条记录，想要释放锁的时候就删除这条记录。数据库对共享资源做了唯一性约束，如果有多个请求被同时提交到数据库的话，数据库会保证只有一个操作可以成功，操作成功的那个线程就获得了访问共享资源的锁，可以进行操作。\n基于缓存实现分布式锁；\n基于缓存，也就是说把数据存放在计算机内存中，不需要写入磁盘，减少了 IO 读写\nRedis 通常可以使用 setnx(key, value) 函数来实现分布式锁。key 和 value 就是基于缓存的分布式锁的两个属性，其中 key 表示锁 id，value = currentTime + timeOut，表示当前时间 + 超时时间。也就是说，某个进程获得 key 这把锁后，如果在 value 的时间内未释放锁，系统就会主动释放锁。setnx 函数的返回值有 0 和 1：\n返回 1，说明该服务器获得锁，setnx 将 key 对应的 value 设置为当前时间 + 锁的有效时间。\n返回 0，说明其他服务器已经获得了锁，进程不能进入临界区。该服务器可以不断尝试 setnx 操作，以获得锁。\n\n\n\n\n基于 ZooKeeper 实现分布式锁\nZooKeeper 基于树形数据存储结构实现分布式锁，来解决多个进程同时访问同一临界资源时，数据的一致性问题。ZooKeeper 的树形数据存储结构主要由 4 种节点构成：\n持久节点（PERSISTENT）。这是默认的节点类型，一直存在于 ZooKeeper 中。\n持久顺序节点（PERSISTENT_SEQUENTIAL）。在创建节点时，ZooKeeper 根据节点创建的时间顺序对节点进行编号命名。\n临时节点（EPHEMERAL）。当客户端与 Zookeeper 连接时临时创建的节点。与持久节点不同，当客户端与 ZooKeeper 断开连接后，该进程创建的临时节点就会被删除。\n临时顺序节点（EPHEMERAL_SEQUENTIAL）。就是按时间顺序编号的临时节点。\n\n\n举例：以电商售卖吹风机的场景为例。假设用户 A、B、C 同时在 11 月 11 日的零点整提交了购买吹风机的请求，ZooKeeper 会采用如下方法来实现分布式锁：\n在与该方法对应的持久节点 shared_lock 的目录下，为每个进程创建一个临时顺序节点。吹风机就是一个拥有 shared_lock 的目录，当有人买吹风机时，会为他创建一个临时顺序节点。\n每个进程获取 shared_lock 目录下的所有临时节点列表，注册 Watcher，用于监听子节点变更的信息。当监听到自己的临时节点是顺序最小的，则可以使用共享资源。\n每个节点确定自己的编号是否是 shared_lock 下所有子节点中最小的，若最小，则获得锁。例如，用户 A 的订单最先到服务器，因此创建了编号为 1 的临时顺序节点 LockNode1。该节点的编号是持久节点目录下最小的，因此获取到分布式锁，可以访问临界资源，从而可以购买吹风机。若本进程对应的临时节点编号不是最小的，则分为两种情况：\n本进程为读请求，如果比自己序号小的节点中有写请求，则等待；\n本进程为写请求，如果比自己序号小的节点中有请求，则等待。\n\n\n\n\n\n\n\n2.分布式资源管理与负载调度1.集中式结构（Master/Slave架构）\n集中式结构就是，由一台或多台服务器组成中央服务器，系统内的所有数据都存储在中央服务器中，系统内所有的业务也均先由中央服务器处理。多个节点服务器与中央服务器连接，并将自己的信息汇报给中央服务器，由中央服务器统一进行资源和任务调度：中央服务器根据这些信息，将任务下达给节点服务器；节点服务器执行任务，并将结果反馈给中央服务器。\nGoogle Borg\nBorg是Google 内部使用的集群管理系统，采用了典型的集中式结构，负责提交、调度、开始、重启和管理 Google 运行在其上的所有应用\n在 Borg 中，一个集群称为一个 Cell，每个 Cell 里面有一个 Leader，称为 BorgMaster，即为中央服务器；其他服务器为节点服务器或从服务器，被称为 Borglet。\nBorgMaster：它由两个进程组成，一个是 Borgmaster 主进程，一个是独立的 scheduler 进程：\n主进程处理客户端的 RPC 请求，比如任务的执行状态更新或者查询等；同时，管理系统中所有实体的状态（比如，服务器、任务等），并负责和 Borglet 通信。\nscheduler 进程负责任务调度，通过任务对资源的需求以及当前 Borglet 所在服务器的资源情况进行匹配，为任务寻找一个合适的节点服务器执行。\n\n\nBorglet：它是运行在每个节点机器的一个 agent，负责任务的拉起、停止、重启等，并管理和收集本服务器资源，将任务的状态、服务器状态等信息上报给 BorgMaster。而 BorgMaster 会周期性地轮询每个 Borglet，以获取节点服务器的状态和资源信息等。\n\n\n\n\nKubernetes\nKubernetes 是 Google 开源的容器集群管理系统，是 Borg 的一个开源版本。Kubernetes 是用于自动部署、扩展和管理容器化应用程序的开源系统。其核心是，在集群的节点上运行容器化应用，可以进行自动化容器操作，包括部署、调度和在节点间弹性伸缩等。\nKubernetes 也是典型的集中式结构，一个 Kubernetes 集群，主要由 Master 节点和 Worker 节点组成，以及客户端命令行工具 kubectl 和其他附加项。\nMaster 节点。它运行在中心服务器上，Master 节点由 API Server、Scheduler、Cluster State Store 和 Control Manger Server 组成，负责对集群进行调度管理。\nAPI Server：是所有 REST 命令的入口，负责处理 REST 的操作，确保它们生效，并执行相关业务逻辑。\nScheduler：根据容器需要的资源以及当前 Worker 节点所在节点服务器的资源信息，自动为容器选择合适的节点服务器。\nCluster State Store：集群状态存储，默认采用 etcd，etcd 是一个分布式 key-value 存储，主要用来做共享配置和服务发现。\nControl Manager：负责整个集群的编排管理。它监视集群中节点的离开和加入，将集群的当前状态与 etcd 中存储的所需状态进行核对。比方说，当某个节点发生故障，它会在其它节点上增加新的 Pod 以匹配所需的副本数。\n\n\nWorker 节点。它作为真正的工作节点，运行在从节点服务器，包括 kubelet 和 kube-proxy 核心组件，负责运行业务应用的容器。\nkubelet：用于通过命令行与 API Server 进行交互，根据接收到的请求对 Worker 节点进行操作。也就是说，通过与 API Server 进行通信，接收 Master 节点根据调度策略发出的请求或命令，在 Worker 节点上管控容器（Pod），并管控容器的运行状态（比如，重新启动出现故障的 Pod）等。Pod 是 Kubernetes 的最小工作单元，每个 Pod 包含一个或多个容器。\nkube-proxy：负责为容器（Pod）创建网络代理 / 负载平衡服务，从 API Server 获取所有 Server 信息，并根据 Server 信息创建代理服务，这种代理服务称之为 Service。Kube-proxy 主要负责管理 Service 的访问入口，即实现集群内的 Pod 客户端访问 Service，或者是集群外访问 Service，具有相同服务的一组 Pod 可抽象为一个 Service。每个 Service 都有一个虚拟 IP 地址（VIP）和端口号供客户端访问。\n\n\n\n\n\n\nApache Mesos\nApache 旗下的开源分布式资源管理框架 Mesos被称为是分布式系统的内核，最初由加州大学伯克利分校的 AMPLab 开发，后在 Twitter 得到广泛使用。Mesos 只负责底层资源的管理和分配，并不涉及存储、任务调度等功能，因此 Mesos Master 对接的是 Spark、Hadoop、Marathon 等框架，用户的任务需要提交到这些框架上。也正因为此，Mesos 的任务调度框架是双层结构。\n在 Mesos 中，一个集群包括 Mesos Master 和多个 Mesos Agent。其中，Mesos Master 运行在中央服务器，Mesos Agent 运行在节点服务器上。\nMesos Master 负责收集和管理所有 Agent 所在服务器的资源和状态，并且对接 Spark、Hadoop 等框架，将集群中服务器的资源信息告知给这些框架，以便这些框架进行任务资源匹配和调度。\nMesos Agent 负责任务的拉起、停止、重启等，并负责收集所在服务器的资源 (比如 CPU、内存等) 信息和状态，上报给 Mesos Master。\n\n\n\n\n\n2.非集中式结构（分布式架构）\nAkka集群（JVM使用了）\nAkka 是一个开发库和运行环境，用于构建可扩展的、弹性的、快速响应的应用程序。Akka 框架是基于 Actor 模型实现的，采用了Gossip协议\nAkka 集群的两个重点是数据传输和集群组建及管理\n在 Akka 集群中，节点是对等的，也就是说每个节点是可以并发处理的，因此必然存在数据传输和一致性的问题。Akka 集群主要采用的是谁的时间戳最新（也就是数据最新），就以谁为准的原则。\n集群创建\n如果本节点为首种子节点，则把自己加入到集群列表中，即以自己为中心构建集群；\n如果本节点为种子节点，则向首种子节点请求加入集群，当首种子节点回复同意消息后，可以加入集群，否则不可加入集群；\n如果本节点为普通节点，则可以向任一种子节点（包括首种子节点）请求加入集群，收到同意后，则加入集群，否则不可加入集群。\n\n\n\n\n\n\nRedis集群\nRedis 是一个开源的、包含多种数据结构的高性能 Key-value 数据库\nRedis 集群中不存在中央节点，是典型的去中心化结构，每个节点均可与其他节点通信。所有节点均可负责存储数据、记录集群的状态（包括键值到正确节点的映射），客户端可以访问或连接到任一节点上。\n\n\nCassandra集群\nCassandra 集群的系统架构是基于一致性哈希的完全 P2P 结构，没有 Master 的概念，所有节点都是同样的角色，彻底避免了因为单点问题导致的系统不稳定。Cassandra 集群节点间的状态同步，也是通过 Gossip 协议来进行 P2P 通信的。\n在 Cassandra 集群中，每次客户端可以向集群中的任意一个节点请求数据，接收到请求的节点将 key 值进行哈希操作，找出在一致性哈希环上是哪些节点应该存储这个数据，然后将请求转发到相应节点上，并将查询结果反馈返回给客户端。\n\n\n\n3.单体调度\n分布式系统中的单体调度是指，一个集群中只有一个节点运行调度进程，该节点对集群中的其他节点具有访问权限，可以对其他节点的资源信息、节点状态等进行统一管理，同时根据用户下发的任务对资源的需求，在调度器中进行任务与资源匹配，然后根据匹配结果将任务指派给合适的节点。单体调度器拥有全局资源视图和全局任务，可以很容易地实现对任务的约束并实施全局性的调度策略。\nBorg调度设计：Scheduler组件，Scheduler 负责任务的调度，当用户提交一个作业给 BorgMaster 后，BorgMaster 会把该作业保存到 Paxos 仓库中，并将这个作业的所有任务加入等待队列中。调度器扫描任务等待队列，根据预定义的调度算法，将队列中的任务分配到满足作业需求且有足够资源的计算节点上。\nBorg调度算法：\n可行性检查：找到一组可以运行任务的机器\n评分：从可行的机器中选择一个合适的机器，其中常见的评分算法包括最差匹配（尽可能平均分配）和最佳匹配（尽可能塞满每一个）\n\n\n\n4.两层调度\n为了提升调度效率并支持多种类型的任务，把资源和任务分开调度，也就是说一层调度器只负责资源管理和分配，另外一层调度器负责任务与资源的匹配呢。\n两层调度结构对应的就是两层调度器，资源的使用状态同时由中央调度器和第二层调度器管理，中央调度器从整体上进行资源的管理与分配，将资源分配到第二层调度器；再由第二层调度器负责将资源与具体的任务配对，因此第二层调度可以有多个调度器，以支持不同的任务类型。\n\n\n5.共享状态调度\n沿袭了单体调度器的模式，通过将单体调度器分解为多个调度器，每个调度器都有全局的资源状态信息，从而实现最优的任务调度，提供了更好的可扩展性。也就是说，这种调度架构在支持多种任务类型的同时，还能拥有全局的资源状态信息。要做到这一点，这种调度架构的多个调度器需要共享集群状态，包括资源状态和任务状态等。\n\n\n3.分布式计算技术1.MapReduce\n抽象模型：MapReduce 分为 Map 和 Reduce 两个核心阶段，其中 Map 对应“分”，即把复杂的任务分解为若干个“简单的任务”执行；Reduce 对应着“合”，即对 Map 阶段的结果进行汇总\n\n2.Stream\n流计算强调的是实时性，数据一旦产生就会被立即处理，当一条数据被处理完成后，会序列化存储到缓存中，然后立刻通过网络传输到下一个节点，由下一个节点继续处理，而不是像 MapReduce 那样，等到缓存写满才开始处理、传输。为了保证数据的实时性，在流计算中，不会存储任何数据，就像水流一样滚滚向前。\n处理流程\n提交流式计算作业：流式计算作业是一种常驻计算服务（如天气预报），预先定义计算逻辑，并提交到流计算系统中，系统在整个运行期间处理逻辑不可更改，数据不存储。\n加载流式数据进行流计算：一旦启动将一直处于等待事件触发的状态，一旦有小批量数据进入流式数据存储，系统会立刻执行计算逻辑并迅速得到结果\n持续输出计算结果：在得到小批量计算结果后，立刻将结果数据写入在线/批量系统，无需等待整体数据的计算结果\n\n\nStorm\nStorm集群上有两种节点，主节点和工作节点\nNimbus 是整个 Storm 集群的主守护进程，以唯一实例的方式运行在主节点上。它负责把任务分配和分发给集群的工作节点，并监控这些任务的执行情况。当某个节点故障时，它会重新分配该故障节点上的任务到其它节点。\nSupervisor 是 Storm 集群里工作守护进程，每个工作节点都存在一个这样的实例。它通过 Zookeeper 与 Nimbus 守护进程进行通信。在接受到 Nimbus 分配的任务后，它会为每个任务启动单独的工作进程。\n\n\nStorm 为进行数据流（数据流是一个无界序列，是在分布式环境中并行创建、处理的一组元组）转换提供了基本组件 Spout 和 Bolt。 Spout 和 Bolt 有用户自定义的接口，用于运行特定应用程序的逻辑。\n\n\n\n3.Actor\nActor 类似于一个“黑盒”对象，封装了自己的状态和行为，使得其他 Actor 无法直接观察到它的状态，调用它的行为。多个 Actor 之间通过消息进行通信，这种消息类似于电子邮箱中的邮件。Actor 接收到消息之后，才会根据消息去执行计算操作\nActor模型的三要素是状态、行为和消息\n状态（State）。Actor 的状态指的是，Actor 组件本身的信息，相当于 OOP 对象中的属性。Actor 的状态会受 Actor 自身行为的影响，且只能被自己修改。\n行为（Behavior）。Actor 的行为指的是，Actor 的计算处理操作，相当于 OOP 对象中的成员函数。Actor 之间不能直接调用其他 Actor 的计算逻辑。Actor 只有收到消息才会触发自身的计算行为。\n消息（Mail）。Actor 的消息以邮件形式在多个 Actor 之间通信传递，每个 Actor 会有一个自己的邮箱（MailBox），用于接收来自其他 Actor 的消息，因此 Actor 模型中的消息也称为邮件。一般情况下，对于邮箱里面的消息，Actor 是按照消息达到的先后顺序（FIFO）进行读取和处理的。\n\n\n处理流程\nActor1 和 Actor3 先后向 Actor2 发送消息，消息被依次放入 Actor2 的 MailBox 队列的队尾 ;\nActor2 从 MailBox 队列的队首依次取出消息执行相应的操作，由于 Actor1 先把消息发送给 Actor2，因此 Actor2 先处理 Actor1 的消息；\nActor2 处理完 Actor1 的消息后，更新内部状态，并且向其他 Actor 发送消息，然后处理 Actor3 发送的消息。\n\n\n\n4.流水线\n将一个大任务拆分位多个步骤执行，不同的步骤可以采用不同的进程执行，这使得不同任务可以并行执行，从而提高了系统效率\n流水线计算模式的原理：TensorFlow 运用了流水线模式对输入数据进行预处理，因此称为输入流水线（TensorFlow Training Input Pipelines）。其数据输入流水线主要包含 3 个步骤\n提取（Extract）。通过多种途径读取数据，比如内存、本地的 HDD 或 SSD、远程的 HDFS、GCS 等。数据的种类也有很多，比如图像数据、文本数据、视频数据等。\n转换（Transform）。使用 CPU 处理器对输入的数据进行解析以及预处理操作，包括混合重排（shuffling）、批处理（batching）, 以及一些特定的转换。比如图像解压缩和扩充、文本矢量化、视频时序采样等。\n加载（Load）。将转换后的数据加载到执行机器学习模型的加速器设备上，比如 GPU 或 TPU。\n\n\n\n4.分布式通信技术1.远程调用\n\n\n\n\n\n\n\n\n因为基于HTTP请求，不适用于有低时延要求的大规模分布式系统，需要更底层的网络协议\n\n远程过程调用（Remote Procedure Call）：封装底层细节，使得远程过程调用和调用一次本地服务没什么不同\nDubbo：\n在引入服务注册中心（简化调用关系，从而减少通信量）的基础上，又加入了监控中心组件（用来监控服务的调用情况，以方便进行服务治理）\n工作流程\n服务提供方将自身提供的服务注册到服务注册中心；\n服务调用方需要向注册中心预订调用服务的提供方地址列表；\n服务注册中心将服务对应的提供方地址列表返回给调用方；\n服务调用方根据服务地址信息进行远程服务调用；\n服务调用方和服务提供方定时向监控中心发送服务调用次数及调用时间等信息。\n\n\n\n\n远程方法调用（Remote Method Invocation）\nRMI 是一个用于实现 RPC 的 Java API，能够让本地 Java 虚拟机上运行的对象调用远程方法如同调用本地方法，隐藏通信细节。RMI 可以说是 RPC 的一种具体形式，其原理与 RPC 基本一致，唯一不同的是 RMI 是基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种基于对象的 RPC 实现。（典型框架有EJB，企业级JavaBean）\n\n\n\n2.发布订阅\n发布订阅的三要素是生产者、消费者和消息中心，生产者负责产生数据放到消息中心，消费者向消息中心订阅自己感兴趣的消息，当发布者推送数据到消息中心后，消息中心根据消费者订阅情况将相关数据推送给对应的订阅者。\n在分布式通信领域中，消息系统一般有两种典型的模式：\n点对点（P2P Point to Point）：生产者将消息发送到消息中心，然后消费者从消息中心取出对应的消息进行消费。消息被消费后，消息中心不再存储该消息，因此其他消费者无法再消费该消息。也就是说，点对点模式虽然支持多个消费者，但一个消息只能被一个消费者消费，不允许重复消费。\n发布订阅（Pub/Sub Publish/Subscribe）：生产者可以发送消息到消息中心，而消息中心通常以主题（Topic）进行划分，每条消息都会有相应的主题，消息会被存储到自己所属的主题中，订阅该主题的所有消费者均可获得该消息进行消费。\n\n\nKafka\n架构包括：生产者（Producer）、消费者（Consumer）、消息中心（Broker）\nZookeeper集群：\n用来协调和管理Broker和Consumer，实现了 Broker 和 Consumer 的解耦，并为系统提供可靠性保证。\nZooKeeper 中会存储一些元数据信息，比如对于 Broker，会存储主题对应哪些分区（Partition），每个分区的存储位置等；对于 Consumer，会存储消费组（Consumer Group）中包含哪些 Consumer，每个 Consumer 会负责消费哪些分区等。\nPartition（分区）：在 Kafka 中，为了解决消息存储的负载均衡和系统可靠性问题，所以引入了主题和分区的概念。其中，主题是一个逻辑概念，指的是消息类型或数据类型，就好比电子论文案例所讲的分布式是一个主题。而分区是针对主题而言的，指的是一个主题的内容可以被划分成多个集合，分布在不同的 Broker 上，不同的 Broker 在不同的节点上。这里的集合就是分区，其中同一个分区只属于一个 Broker。\nConsumer Group（消费组）：Kafka 中的消费组，指的是多个消费者的一个集合。一个消费组中的消费者共同消费主题消息，并且主题中每个消息只可以由消费组中的某一个消费者进行消费。在消息过多的情况下，单个消费者消费能力有限时，会导致消费效率过低，从而导致 Broker 存储溢出，丢弃一部分消息。Kafka 为了解决这个问题，所以引入了消费组。\n\n\n\n\n\n\n\n3.消息队列\n队列是一种具有先进先出特点的数据结构，消息队列是基于队列实现的，存储具有特定格式的消息数据，比如定义一个包含消息类型、标志消息唯一性的 ID、消息内容的一个结构体作为消息数据的特定格式。消息以特定格式放入这个队列的尾部后可以直接返回，并不需要系统马上处理，之后会有其他进程从队列头部开始读取消息，按照消息放入的顺序逐一处理。\nRocketMQ消息队列原理及工作机制\nRokcetMQ 共包括 NameServer Cluster、Producer Cluster、Broker Cluster 和 Consumer Cluster 共 4 部分。\nNameServer Cluster，指的是名字服务器集群。这个集群的功能与 Kafka 中引入的 ZooKeeper 类似，提供分布式服务的协同和管理功能，在 RocketMQ 中主要是管理 Broker 的信息，包括有哪些 Broker、Broker 的地址和状态等，以方便生产者获取 Broker 信息发布消息，以及订阅者根据 Broker 信息获取消息。\nProducer Cluster，指的是生产者集群，负责接收用户数据，然后将数据发布到消息队列中心 Broker Cluster。好处如下：\n一是，多个 Producer 可以并发接收用户的输入数据，提升业务处理效率；\n二是，考虑到可靠性问题，如果只有一个 Producer 接收用户输入数据，当这个 Producer 故障后，整个业务就无法运行了。\n\n\nConsumer Cluster，指的是消费者集群，负责从 Broker 中获取消息进行消费。Consumer 以集群方式进行部署的好处是，提升消费者的消费能力，以避免消息队列中心存储溢出，消息被丢弃。\nBroker Cluster，指的是 Broker 集群，负责存储 Producer Cluster 发布的数据，以方便消费者进行消费。Broker Cluster 中的每个 Broker 都进行了主从设计，即每个 Broker 分为 Broker Master 和 Broker Slave，Master 既可以写又可以读，Slave 不可以写只可以读。每次 Broker Master 会把接收到的消息同步给 Broker Slave，以实现数据备份。一旦 Broker Master 崩溃了，就可以切换到 Broker Slave 继续提供服务。这种设计的好处是，提高了系统的可靠性。\n\n\n工作流程\n首先启动 NameServer，然后启动 Broker。Broker 启动后，会主动找 NameServer 建立连接，并将自己的信息注册到 NameServer 上。注册完毕后，Broker 会周期性地给 NameServer 发送心跳包，比如每隔 1s 发送一次，以告知 NameServer 自己还活着；心跳包里还可以包括 Broker 当前存储的数据信息，也就是说 Broker 可以周期性地向 NameServer 更新自己的数据信息，以保证 NameServer 上存储的数据是最新的。\n创建主题，并确定这个主题的数据放入哪些 Broker 中。\n当 Producer 生产消息发送到主题时，需要先到 NameServer 查询该主题存放在哪些 Broker 中，获取到相关 Broker 信息后，将消息发送给这些 Broker 进行存储。\nConsumer 要从主题消费消息，也需要首先到 NameServer 查询一下该主题的消息存储在哪些 Broker 上，然后去相应的 Broker 获取消息进行消费。\n\n\n\n\n\n5.分布式数据存储1.CAP理论\n保CA弃P：MySQL\n保CP弃A：Redis、HBase、Zookeeper\nZookeeper：当出现网络分区时，如果其中一个分区的节点数大于集群总节点数的一半，那么这个分区可以再选出一个 Leader，仍然对用户提供服务，但在选出 Leader 之前，不能正常为用户提供服务；如果形成的分区中，没有一个分区的节点数大于集群总节点数的一半，那么系统不能正常为用户提供服务，必须待网络恢复后，才能正常提供服务。\n\n\n保AP弃C：CoachDB、Eureka、Cassandra、DynamoDB，多用于查询网站\n\n2.分布式存储系统三要素\n分布式存储系统：将用户需要存储的数据根据某种规则存储到不同的机器上，当用户想要获取指定数据时，再按照规则到存储数据的机器里获取\n顾客生产和消费数据：根据数据的特征可以被划分为三类：\n结构化：指关系模型数据，其特征是数据关联较大、格式固定。一般采用分布式关系数据库进行存储和查询\n半结构化：指非关系模型的，有基本固定结构模式的数据，其特征是数据之间关系比较简单。一般采用键值对形式来表示，比如 HTML 文档可以将标签设置为 key，标签对应的内容可以设置为 value，因此一般采用分布式键值系统进行存储和使用。\n非结构化：没有固定模式的数据，其特征是数据之间关联不大。比如文本数据就是一种非结构化数据。这种数据可以存储到文档中，通过 ElasticSearch（一个分布式全文搜索引擎）等进行检索。\n\n\n导购确定数据位置：\n数据分片技术：分布式存储系统按照一定的规则将数据存储到相对应的存储节点中，或者到相对应的存储节点中获取想要的数据\n数据复制技术：缓解单点压力，将数据进行备份，以使得多个节点存储该数据\n\n\n货架存储数据：\n分布式数据库，通过表格来存储结构化数据，方便查找。常用的分布式数据库有 MySQL Sharding、Microsoft SQL Azure、Google Spanner、Alibaba OceanBase 等。\n分布式键值系统，通过键值对来存储半结构化数据。常用的分布式键值系统有 Redis、Memcache 等，可用作缓存系统。\n分布式存储系统，通过文件、块、对象等来存储非结构化数据。常见的分布式存储系统有 Ceph、GFS、HDFS、Swift 等。\n\n\n\n3.数据分布方式\n哈希（一步，Redis）：首先确定一个哈希函数，然后通过计算得到对应的存储节点\n一致性哈希（两步，Cassandra）：\n将存储节点和数据都映射到一个首尾相连的哈希环上，存储节点可以根据 IP 地址进行哈希，数据通常通过顺时针方向寻找的方式，来确定自己所属的存储节点，即从数据映射在环上的位置开始，顺时针方向找到的第一个存储节点\n这种改进可以很好地解决哈希方法存在的稳定性问题。当节点加入或退出时，仅影响该节点在哈希环上顺时针相邻的后继节点。\n\n\n带有限负载的一致性哈希（Google Cloud Pub/Sub、HAProxy）：给每个存储节点设置了一个存储上限值来控制存储节点添加或移除造成的数据不均匀。当数据按照一致性哈希算法找到相应的存储节点时，要先判断该存储节点是否达到了存储上限；如果已经达到了上限，则需要继续寻找该存储节点顺时针方向之后的节点进行存储\n带虚拟节点的一致性哈希（Memcached）：根据每个节点的性能，为每个节点划分不同数量的虚拟节点，并将这些虚拟节点映射到哈希环中，然后再按照一致性哈希算法进行数据映射和存储\n\n4.分布式数据复制技术\n如何让主备数据库保持一致的技术，主要有三类：\n同步复制技术（MySQL集群的全复制模式）：当用户请求更新数据时，主数据库必须要同步到备数据库之后才可给用户返回，即如果主数据库没有同步到备数据库，用户的更新操作会一直阻塞。这种方式保证了数据的强一致性，但牺牲了系统的可用性。\n异步复制技术（MySQL集群的数据复制模式）：当用户请求更新数据时，主数据库处理完请求后可直接给用户响应，而不必等待备数据库完成同步，即备数据库会异步进行数据的同步，用户的更新操作不会因为备数据库未完成数据同步而导致阻塞。显然，这种方式保证了系统的可用性，但牺牲了数据的一致性。\n半同步复制技术：用户发出写请求后，主数据库会执行写操作，并给备数据库发送同步请求，但主数据库不用等待所有备数据库回复数据同步成功便可响应用户，也就是说主数据库可以等待一部分备数据库同步完成后响应用户写操作执行成功\n一种是，当主数据库收到多个备数据库中的某一个回复数据同步成功后，便可给用户响应写操作完成；（MySQL集群一主多备下，也支持半同步复制模式）\n另一种是，主数据库等超过一半节点（包括主数据库）回复数据更新成功后，再给用户响应写操作成功。（Zookeeper、Azure的Cloud SQL Server、Kubernetes 中保存集群所有网络配置和对象状态信息的 Etcd 组件）\n\n\n\n5.分布式数据缓存技术\n分布式缓存就是指在分布式环境或系统下，把一些热门数据存储到离用户近、离应用近的位置，并尽量存储到更快的设备，以减少远程数据传输的延迟，让用户和应用可以很快访问到想要的数据。\nRedis：Redis 集群是一个典型的去中心化结构，每个节点都负责一部分数据的存储，同时，每个节点还会进行主备设计来提高 Redis 的可靠性，与缓存有关的三个特性：\n支持多数据结构：Redis 是一个基于内存的 key-value 数据库，为了方便支持多应用的缓存，比如缓存文本类型、数据库的查询结果（字段与字段对应的值）等等，支持的数据结构不仅有简单的 k／v 类型，还可以支持 List、Set、Hash 等复杂类型的存储。\n支持持久化：持久化是指，将数据从内存这种易失性存储设备中写入磁盘，从而让数据永久保存。Redis 中存储的数据虽然是基于内存的，但它也提供了持久化的机制，主要有两种方式：RDB 和 AOF。\nRDB（Redis DataBase），也称快照方式，简单来说就是 Redis 会定时将内存中的数据备份到磁盘中，形成一个快照，比如每天保存一下过去一周的数据。这样当节点出现故障时，可以根据快照恢复到不同版本的数据。这种方式有一个明显的缺点，是会造成数据丢失，即当节点出现故障时，新数据可能还未备份到磁盘中。\nAOF（Append Only File）的出现主要弥补了 RDB 数据不一致的问题，记录下 Redis 中所有的更新操作。\nAOF_FSYNC_NO （不同步），即不会自动触发写操作的同步；\nAOF_FSYNC_EVERYSEC （每秒同步），即每隔一秒都会将写操作同步到磁盘；\nAOF_FSYNC_ALWAYS （每次写都同步），即每次发生写操作会立即同步到磁盘。\n\n\n\n\n主备同步：\n\n\nMemcached\n\n6.分布式高可靠1.负载均衡\n轮询策略（Dubbo、Nginx）：轮询策略是一种实现简单，却很常用的负载均衡策略，核心思想是服务器轮流处理用户请求，以尽可能使每个服务器处理的请求数相同。轮询策略主要包括顺序轮询和加权轮询。（Nginx默认的负载均衡策略就是一种改进的加权轮询策略）\n随机策略（Dubbo）：当用户请求到来时，会随机发到某个服务节点进行处理，可以采用随机函数实现。这里，随机函数的作用就是，让请求尽可能分散到不同节点，防止所有请求放到同一节点或少量几个节点上。\n哈希和一致性哈希（Redis、Memcached、Cassandra）：哈希函数设置合理的话，负载会比较均衡。而且，相同 key 的请求会落在同一个服务节点上，可以用于有状态请求的场景。除此之外，带虚拟节点的一致性哈希策略还可以解决服务器节点异构的问题。\n\n2.流量控制\n漏桶策略（Sentinel、Jaeger）：无论用户请求有多少，无论请求速率有多大，“漏桶”都会接收下来，但从漏桶里出来的请求是固定速率的，保证服务器可以处理得游刃有余。当“漏桶”因为容量限制放不下更多的请求时，就会选择丢弃部分请求。这种思路其实就是一种“宽进严出”的策略。\n令牌桶策略（Guava的RateLimiter）：有一个固定容量的存放令牌的桶，我们以固定速率向桶里放入令牌，桶满时会丢弃多出的令牌。每当请求到来时，必须先到桶里取一个令牌才可被服务器处理，也就是说只有拿到了令牌的请求才会被服务器处理。\n\n3.故障隔离\n采用一定的策略，以实现当某个模块故障时，不会影响其他模块继续提供服务，以保证整个系统的可用性。所以说，故障隔离，可以避免分布式系统出现大规模的故障，甚至是瘫痪，降低损失。在分布式系统中，要实现故障隔离，通常需要在进行系统设计时，提前对可能出现的故障进行预防，以使得在出现故障后能实现故障隔离。此外，由于是提前设计预防的，因此故障隔离还可以帮助我们快速定位故障点。主要有两个维度：以功能模块为粒度、以资源为粒度\n线程级隔离：使用不同的线程池处理不同的请求任务。当某种请求任务出现故障时，负责其他请求任务的线程池不会受到影响，即会继续提供服务，从而实现故障的隔离\n进程级隔离：将系统按照功能分为不同的进程，分布到相同或不同的机器中。如果系统的进程分布到不同机器上的话，从资源的角度来看，也可以说成是主机级的故障隔离。因为从另一个层面看，系统确实分布到了不同机器上，当某个机器出现故障时，不会对其他机器造成影响。\n资源隔离（微服务）：将分布式系统的所有资源分成几个部分，每部分资源负责一个模块，这样系统各个模块就不会争抢资源，即资源之间互不干扰。这种方式不仅可以提高硬件资源利用率，也便于系统的维护与管理，可以大幅提升系统性能。\n\n4.故障恢复\n故障类型\n节点故障\n一类是硬件故障，比如机器硬盘损坏、内存接触不良等；\n另一类是软件故障，比如由于请求过多，超过服务器处理能力上限，导致无法处理，又或者是机器被攻击，导致机器瘫痪等。\n\n\n网络故障：路由器故障、DNS故障、网络线路断裂\n\n\n故障检测\n基于历史心跳信息预测故障的策略：φ 值故障检测，通常会设置一个阈值Ф，若当前心跳计算得到的 φ≥Ф，则判断心跳超时，否则心跳未超时\n\n\n故障恢复\n单节点故障：对于单节点故障问题，往往采取主备策略，即当主节点故障后，从备节点中选出一个作为新的主节点，以继续提供服务。\n网络故障：而对于网络故障问题的解决方案，简单来说就是 C、A、P 选择的问题，即在分布式系统的可用性和数据一致性之间做权衡。根据不同的应用场景，选择不同的解决方案。\n\n\n\n2.分布式架构文章1.Distributed systems theory for the distributed systems engineer1.Book\nDistributed Systems for fun and profit（入门）\nDesigning Data Intensive Application（实践）\nDistributed Systems: Principles and Paradigms（原理）\nScable Web Architecture and Distributed Systems（应用）\nNotes on distributed systems for young bloods（教训）\nthe fallacies of distributed computing （谬论）\n\n==You should Know==\n\n安全属性：任何坏的事情都不会发生，例如不会返回不一致的值\n活性属性：好事终会发生，例如每个系统调用最后都会逐渐返回\n\n2.Failure and Time\n\n\n\n\n\n\n\n\n构建分布式系统的许多困难都是因为：1.进程会失败，2.无法告知已经做了什么\n\n失败层次模型：Byzantine failures ⊃ authentification detectable byzantine failures（不改值） ⊃ performance failures（不准时到） ⊃ omission failures（回复无限晚） ⊃ crash failures（停止响应） ⊃ fail-stop failures（可检测）前面的failure出现，也可以假设后面的出现\n\n决定事情发展的先后顺序：\n\nVector clocks：\n\n向量钟是一个在分布式系统中确定事件的并行顺序或者检测因果关系违规的数据结构，通常一个包含N个进程的向量钟是一个N个逻辑钟（logical clock）的array/vector，并且一个进程一个时钟，每个进程保存一个全局时钟数组最大可能值的副本\n\n\n\n\n\n\n\nFLP result：在异步环境中，如果节点间的网络延迟没有上限，只要有一个恶意的节点存在，就没有算法能在有限的时间内达成共识。\n\n不同的时间模型：\n\n同步、部分同步、异步\n\n\n错误检测：\n\n基本属性\n\n完整性Completeness：在每个崩溃的进程都被部分或所有正确的进程永久怀疑之后存在一段时间\n\n强一致：需要所有正确的进程来怀疑故障\n弱一致：只需要一个正确的过程来怀疑故障\n\n\n准确性Accuracy：在一些正确的进程永远不会被任何正确的进程所怀疑之后存在一度时间\n\n\n\nDynamo（Pinging）\n\n算法思想：一个节点将询问其它节点是否存活，如果其他节点及时回复，则认为他们存活\n不保证失败检测延时，且对消息丢失不敏感\n只对一定大小的系统非常有用\n\n\nGossip（Heartbeat）\n\n算法思想：一个节点定期向外广播本节点依旧存活的信息，为了提高效率，通过肩驮或者引用其他网络消息\n很短的失败检测延时，但对消息丢失很敏感\n具有可伸缩性和可扩展性，使得它成为具有弱一致性模型和大型系统的理想选择\n\n\n\n\n\n3.The basic tension of fault tolerance\nquorum技术\n\n法定人数（quorum）是分布式事务为了被允许在分布式系统中执行操作而必须获得的最小投票数\n基于quorum的投票可以确保单副本可串行性的控制方法，以及在存在网络分区的情况下确保事务原子性的提交方法\n\n\n共识协议：\n\n定义在一个分布式系统中让一系列节点都同意某些事（值，操作，决定）\n\n三种属性：Agreement（都同意）,Validity（值有效）,Termination（能结束）\n\n2PC：只能决定是否接受，不能决定取什么值，且只能是二值变量（低延迟，脆弱）\n\nStep1：Contact every participant, suggest a value and gather their responses（每个人都可以当组织者）\nStep2：If everyone agrees, contact every participant again to let them know. Otherwise, contact every participant to abort the consensus.\nTolerance to failures:\nstep1中任何节点出错都能处理，当step2处理一般时，若组织者出错，则有参与者充当协调员来充当组织者，协调员也崩溃了则有恢复节点去接管\n如果事务可以随时回滚，那么协议可以在节点超时时恢复，但如果协议必须将任何提交决策视为永久性的，那么错误的失败可能会使整个事情陷入停顿。\n\n\n\n\n3PC：高可用。网络分区后不可用\n\n把step2拆开：准备提交阶段和提交/中止阶段\n恢复节点可以确定是已提交阶段还是未提交阶段\n\n\nPaxos：\n\nPROPOSERS:\n\nSubmit a proposal numbered n to a majority of acceptors. Wait for a majority of acceptors to reply.\nIf the majority reply ‘agree’, they will also send back the value of any proposals they have already accepted. Pick one of these values, and send a ‘commit’ message with the proposal number and the value. If no values have already been accepted, use your own. If instead a majority reply ‘reject’, or fail to reply, abandon the proposal and start again.\nIf a majority reply to your commit request with an ‘accepted’ message, consider the protocol terminated. Otherwise, abandon the proposal and start again.\n\n\nACCEPTORS:\n\nOnce a proposal is received, compare its number to the highest numbered proposal you have already agreed to. If the new proposal is higher, reply ‘agree’ with the value of any proposals you have already accepted. If it is lower, reply ‘reject’, along with the sequence number of the highest proposal.\nWhen a ‘commit’ message is received, accept it if a) the value is the same as any previously accepted proposal and b) its sequence number is the highest proposal number you have agreed to. Otherwise, reject it.\n\n\nFailure tolerance：\n\n一半节点失效也可以运行，应付f个失败只需要提供2f+1个acceptors，Properser失败可以有另一个新Proposer接管，\n\nA failure mode\n\n\n\n\n\n\n\n最终一致性：\n\n以较弱的系统行为保证为代价来避免这种tension\nDynamo\nLife Beyond Transactions\n\n\n\n4.Basic primitives\n\n\n\n\n\n\n\n\n一些分布式系统的构建模块\n\nLeader election \nBully algorithm：在同步分布式系统中从分布式计算进程中动态选举coordinator（未失败的进程中具有最高进程ID）\nIf P has the highest process ID, it sends a Victory message to all other processes and becomes the new Coordinator. Otherwise, P broadcasts an Election message to all other processes with higher process IDs than itself.\nIf P receives no Answer after sending an Election message, then it broadcasts a Victory message to all other processes and becomes the Coordinator.\nIf P receives an Answer from a process with a higher ID, it sends no further messages for this election and waits for a Victory message. (If there is no Victory message after a period of time, it restarts the process at the beginning.)\nIf P receives an Election message from another process with a lower ID it sends an Answer message back and starts the election process at the beginning, by sending an Election message to higher-numbered processes.\nIf P receives a Coordinator message, it treats the sender as the coordinator.\n\n\n\n\nConsistent snapshotting \nDistributed Snapshots: Determining Global States of a Distributed System\n\n\nConsensus \n2PC、Paxos\n\n\nDistributed state machine replication \n一种通过复制服务器并且协调客户端与服务器副本交互的实现容错服务的方法1. \n\n\nBroadcast - delivering messages to more than one node at once\nAtomic broadcast - can you deliver a message to all nodes in a group, or none?\nGossip (the classic paper)\nCausal multicast (but also consider the enjoyable back-and-forth between Birman and Cheriton).\n\n\nChain replication (a neat way of ensuring consistency and ordering of writes by organizing nodes into a virtual linked list).\nThe original paper\nA set of improvements for read-mostly workloads\nAn experiential report by @slfritchie\n\n\n\n5.Fundamental Results\n如果在进程间丢失信息，就不能实现一致性存储并响应所有请求（CAP定理）\n\n共识是不可能以下面这样的方式实现的\n\n总是正确的\n即使一台机器在异步系统中发生故障并出现停止响应\n\n\n一般来说，不到两轮消息就不可能达成共识\n\n原子广播（Atomic broadcast）和共识一样难，如果你解决了原子广播，你就解决了共识\n\n\n6.CALM &amp; CDRT\nCALM:\n全称为：Consistency As Logical Monotonicity（逻辑单调性的一致性），当且仅当问题是单调时，问题才具有一致的，无需协调的分布式实现\nCALM定理是为了避免分布式事务机制中的协调机制，视图实现如同没有红绿灯的交通路口，需要程序员对业务问题进行设计，保证问题的单调性，也就是说，输出结果与输入数据的之间数据没有关联关系，输入数据的前后顺序不会影响输出结果，典型案例如CRDT\n\n\nCRDT:\n全称为：Conflict-free replicated data type（无冲突的复制数据类型），在网络中多计算机之间被复制的数据结构，并且副本之间可以独立和同时更新，副本之间无需协调，在数学上总是有可能解决可能出现的不一致。\n有两种方法可以提供强大的最终一致性：\noperation-based CDRTs：传输操作，例如对整数+20或者-10操作，操作不是幂等的\nstate-based CDRTs：传输整个状态，所有被一个函数合并，这个函数是可交换的、关联的和幂等的。\n\n\n\n\n\n2.Fallacies of Distributed Computing Explained\n网络是稳定的\ninfrastructure side：硬件与软件冗余、权衡失败的风险和所需投资\nsoftware side：线路上丢失请求响应消息\n\n\n网络传输的延迟是零\n进行更少的系统调用，并假设你有足够的带宽，使得每次调用移动更多的数据\nAjax：允许用户使用消化数据所花费的空闲时间来检索更多的数据，但仍需考虑延迟问题 \n\n\n网络的带宽是无穷大\n有更新的更占带宽的程序，例如视频\n丢包：传输更大的数据可以容忍更高的丢包率\n\n\n网络是安全的\n从第一天，从架构级别开始就需要考虑安全问题\n执行威胁建模并且评估安全风险\n\n\n网络的拓扑不会改变\n不要依赖于特定的端点或路由\n可能希望提供位置透明度或者发现服务\n\n\n只有一个系统管理员\n有专门的工具来监控正在运行的实例\n在更新时确定系统不同部分是否同步运行\n\n\n传输数据的成本为零\n代码转为二进制、系统设备\n\n\n整个网络是同构的\n必须假设互用性将会在不久被使用\n不依赖于单一协议，可以考虑XML\n\n\n\n3.Notes on Distributed Systems for Young Bloods\nChoose id spaces wisely. \nExtract services.\n\n\n分布式系统之所以复杂，就是因为它太容易出错了。这意味着，你要把处理错误的代码当成正常功能的代码来处理。\n开发一个健壮的分布式系统的成本是单体系统的几百倍甚至几万倍。这意味着，我们要自己开发一个，需要能力很强的开发人员。\n非常健壮的开源的分布式系统并不多，或者说基本没有。这意味着，如果你要用开源的，那么你需要 hold 得住其源码。\n管理或是协调多个服务或机器是非常难的。这意味着，我们要去读很多很多的分布式系统的论文，利用CAP理论评判系统。\n在分布式环境下，出了问题是很难 debug 的。这意味着，我们需要非常好的监控和跟踪系统，还需要经常做演练和测试，并且通过功能特性来迭代而不是直接迭代大版本。\n在分布式环境下，你需要更科学地分析和统计。这意味着，我们要用 P90 这样的统计指标，而不是平均值，我们还需要做容量计划和评估。\n在分布式环境下，需要应用服务化，可以保证部分可用。这意味着，我们需要一个服务开发框架，比如 SOA 或微服务。\n在分布式环境下，故障不可怕，可怕的是影响面过大，时间过长。这意味着，我们需要花时间来开发我们的自动化运维平台。\n在分布式环境下，利用数据局部性原理，并且不总把缓存写回磁盘，合理的安排索引，后期可以更多的选择。\n\n4.Scalable Web Architecture and Distributed Systems\n\n\n\n\n\n\n\n\n图片托管应用：功能性需求：写图片到服务器、请求一个图片。非功能性需求：图片数量可扩展、下载需要低延迟、上传的图片一直存在、系统应易于维护、系统具有高性价比\n\nWeb分布式系统设计的原则\n\n\n\n\n\n\n\n\n在一般情况下，一个设计可能会牺牲其中的一个或几个原则\n\n**可用性(Availability)**：网站的响应时间对许多公司的名声和正常运作都非常的关键。对一些大型在线零售站点来说，即使是几分钟的不可访问都会导致上万元的收入损失，因此将系统设计得持续可访问，并在失效后可恢复，既是一个业务需求，也是一个技术需求。分布式系统的高可用性要求仔细考虑关键组件的冗余，部分系统失效后的恢复，以及问题发生后降低影响。\n**性能(Performance)**：网站性能是绝大多数网站重点考虑的。网站的速度不仅影响着用户使用的满意度，还影响着搜索引擎排名，与收入和顾客保留直接相关。因此，创建一个响应迅速、延迟低的优化系统非常重要。\n**可靠性(Reliability)**：一个系统需要是可靠的，例如请求的数据会一直返回相同的结果，而在数据改变或更新后，同样的请求应当返回新的数据。需要让用户知道，如果一些东西写入或存入了系统，会一直存留，在未来取回时仍然存在。\n**可扩展性(Scalability)**：对于大型分布式系统而言，系统大小只是需要考虑可扩展性的一个方面。系统的可扩展性通常是指应对大量负载的能力，提高这一能力同样重要。可扩展性还可以用来指代系统的多个不同参数：可以处理多少额外的流量；存储容量是否容易添加；甚至是可以多处理多少事务。\n**可管理性(Manageablity)**：设计容易管理的系统是另一个重要的考虑。系统的可管理性即操作（维护与升级）的可扩展性。可管理性需要考虑的事情包括诊断与理解发生的问题的容易程度，更新和修改的容易程度，以及系统运行的简单程度。（即，系统是否没有错误和异常地持续运行？）\n**成本(Cost)**：成本是一个重要因素。显然，成本包括硬件和软件的花费，但考虑系统部署和维护的花费也很重要。系统开发时间、运行消耗甚至是培训成本都应该被考虑进来。成本应当包括所有者的全部花费。\n\n服务（Service）\n当考虑可扩展性系统设计时，对功能进行解耦，并将系统的每一个部分各自考虑成具有清晰定义的接口的服务，会很有帮助。即==面向服务的架构(Service-Oriented Architecture, SOA)==，每一个服务都有它自己清晰的功能环境，和这个环境之外的任何事物的交互都通过抽象的接口（特别是其他服务的公开API）进行\n==在我们的例子中==\n首先将上传和检索图片的请求分解成两个服务，即==读写分离==\n问题1：写入比读出慢\n问题2：Web服务器可维护的同时连接数有上限，主要是写连接的问题\n\n\n其它解决：Flickr解决这个读/写问题的方法是将将用户分布到不同的==shard==上。每个shard只能处理一小部分的用户，在用户数量增长时，将更多的shard加入集群中\n\n\n\n冗余（Redundancy）\n为了优雅地处理失效问题，一个Web架构必须有服务和数据的冗余。同样的原则也适用于服务。如果有一个应用的核心功能，保证有多个拷贝或多个版本在同时运行，可以免于单个服务结点失效的危害。\n在系统中如果有两个相同实例在运行，当其中一个失效或退化，系统可以==故障转移(failover)==到另一个健康的拷贝上。\n或者创建一个==无共享架构(shared-nothing architecture)==，在这个架构中，每个节点都独立于其他节点运行，没有中央调度服务器，也没有和其他节点协调进行的活动\n\n\n\n分区（Partition）\n数据集可能会有很大，导致单个服务器装不下；也可能是一个操作需要太多的计算资源，降低了性能，导致必须增加容量。在这样的情况下你有两种选择：垂直分区或是水平分区。\n垂直扩展：在一个服务器上加更多的磁盘驱动、更换更快的CPU、增加更多的内存\n水平扩展：增加更多的结点。通过将更多的数据存在其它服务器上，或者将操作或负载分离到其它节点上。最常见的技术就是将服务分解为多个分区(partition)，或是多个shard。\n问题1：数据局部性：当数据不在本地时，服务器需要耗时来在网络上请求\n问题2：不一致性：当有多个服务访问同一共享资源时，可能产生竞争条件\n\n\n\n\n\n故障处理（handing  failure）数据访问组件\n\n\n\n\n\n\n\n\n因为数据访问比对服务（内存）的访问慢，所以需要缓存、代理、索引和负载均衡器等策略使数据访问变得更快\n\n缓存：利用局部性原理：最近请求过的数据很可能会被再次请求。（==Redis==）可以在请求层节点插入缓存，也可以将缓存扩展到多个节点上，但同一个请求可能发往不同的结点，这会增加缓存不命中的次数，解决办法如下：\n\n全局缓存：所有节点使用相同的单一缓存空间，\n分布式缓存：每个节点都拥有一部分缓存数据，通常用一个全局唯一的散列函数分割，分布式缓存的缺点是补救缺失结点。\n\n\n代理：代理服务器是一个硬件/软件的中间片，从客户端接收请求，并转播到后端服务器。代理通常用来过滤请求和记录请求，有时候也用来变换请求（通过增加/删除头部，加密/解密，或是压缩）。\n\n想象一下在多个结点上有对同一个数据（叫它littleB）的请求，且这个数据不在缓存中。如果请求是通过代理发送，那么所有的请求就会被压缩成一个，这意味着我们只需要从磁盘上读一次littleB。这个设计会带来一些开销，因为每个请求的延迟会稍高，并且一些请求可能会因为要和相似的请求合并而有轻微的延期。但这种做法在高负载，尤其是一些数据被一次又一次地请求的情况下，会大幅提升性能。这和缓存很像，但与缓存将数据/文档存储起来不同，代理是优化对文档的请求或调用，充当这些客户的代理人。\n\n\n另一个使用请求的很好方式是不仅仅压缩对同一个数据的请求，还压缩对原存储中相距很近（在磁盘上连续）的数据的请求。使用这个策略最大化了请求的数据局部性，可以降低请求延迟。例如，我们有一堆结点请求B的一部分：B1，B2，等。我们可以将设定代理识别空间局部性，将它们压缩为同一个请求，只返回bigB，这样就极大地减小了从数据源读的次数。（见图1.15）。这可以在你从TB级的数据中随机访问时减少很多请求时间！代理还在高负载或是缓存空间有限时非常有用，因为它们能一次处理一批数据。\n\n\n\n\n索引：通过增加存储开销和写操作时间（因为你必须同时写数据和更新索引）来换取更快的读。\n\n多层索引\n倒排索引\n\n\n负载均衡器：负载均衡器每个架构上的首要部分，将负载分布到负责请求服务的结点上，这使系统中多个结点可以透明地服务同一个功能。（==Nginx==）\n\n会话粘性：浏览器缓存、cookie、URL重写\n反向代理：根据请求的类型不同发往不同的结点\n测试结点健康度：如果一个结点不响应或过载了，可以从处理请求的池中移除，利用系统中不同结点的冗余。\n\n\n\n队列：对写数据的高效管理\n\n\n\n\n\n\n\n\nRabbitMQ、Zookeeper、Redis\n\n一个任务来到后，被添加到队列中，结点在它们有容量处理任务的时候从队列中取出下一个。\n队列使客户可以用异步的方式工作，提供了一个对客户请求和响应策略上的抽象。在异步系统中，客户请求一个任务，服务端响应一个消息，确认任务收到，然后客户就可以周期性检查任务状态，只在任务完成之后请求结果。在客户等待异步请求完成时，它可以随意进行其他工作，甚至是发送其他服务的异步请求。后者是队列和消息在分布式系统中应用的例子。\n\n5.The twelve-factor app==12-Factor为构建如下的SaaS应用提供了方法论：==\n\n使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入项目\n和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性\n适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源\n将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发\n可以在工具、架构和开发流程不发生明显变化的前提下实现扩展\n\n\n基准代码：一份基准代码，多份部署\n​        基准代码使用Git和Code Repo来管理，基准代码和应用之间总是保持一一对应的关系。一旦有多个基准代码，就是一个分布式系统，分布式系统中的每一个组件都是一个应用；当有多个应用共享一份代码时，可以将共享代码拆分为独立的类库。尽管每个应用只对应一份基准代码，但可以同时存在多份部署（包括不同版本的预发布）。\n\n依赖：显示声明依赖关系\n​        应用程序不会隐式依赖系统级的类库，通过依赖清单确切地声明所有依赖项，在运行过程中通过依赖隔离工具来确保程序不会调用系统中存在但清单中未声明的依赖项，并且这一做法会统一到应用和开发环境，显示声明依赖的优点之一是为新进开发者简化了环境配置流程。\n​        应用程序不会隐式依赖某些系统工具，如果应用必须使用某些系统工具，那么这些工具应该被包含在应用之中。\n\n配置：在环境中存储配置\n​        应用的配置（数据库的配置、第三方证书）在不同部署（预发布、生产环境、开发环境）间会有很大差异，因此推荐将应用的配置存储于环境变量中，因为环境变量方便修改，且不动一行代码。\n​        一方面，按部署分组成development、test、production环境。另一方面，环境变量的粒度要足够小，且相对独立，他们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。\n\n后端服务：把后端服务当作附加资源\n​        后端服务是指程序运行所需要的通过网络调用的各种服务，如本地服务（数据库、消息队列系统、缓存系统等），第三方发布和管理的服务（STMP邮件发送服务、数据收集服务、数据存储服务）。\n​        应用程序通过一个url或者其它存储在配置中的服务定位/服务证书来获取服务，应用程序将每个不同的后端服务当作一份资源，这些资源和它们附属的部署保持松耦合，即不改变代码就可以更改服务，部署可以按需加载或卸载资源。\n\n构建、发布、运行：严格分离构建和运行\n​        基准代码转化为一份部署需要三个阶段：构建阶段将代码仓库转化为可执行包、发布阶段将构建的结果和当前部署所需配置相结合、运行阶段针对选定的发布版本在执行环境中启动一系列应用程序进程。\n​        部署工具通常提供发布管理工具，可以回退至较旧的发布版本。每一个发布的版本必须对应一个唯一的发布ID，发布的版本一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。\n​        新的代码在部署之前，需要开发人员触发构建操作，但运行阶段可以自动进行。此外运行阶段应该保持尽可能少的模块，减少故障发生是引发的问题，但构建阶段可以相对复杂一些，因为错误信息能立刻展示在开发人员面前，从而被妥善处理。\n\n进程：以一个或多个无状态进程运行应用\n​        应用的进程必须无状态且无共享，任何需要持久化的数据都要存储在后端服务内，比如数据库，内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存。粘性session不好，session中的数据应该保存在带有过期时间的缓存中。\n\n端口绑定：通过端口绑定提供服务\n​        互联网应用有时会运行于服务器的容器之内，例如Java运行于Tomat。应用程序应该完全自我加载，而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用通过端口绑定来提供服务，并监听发送至该端口的请求。\n​        通常的思路是将网络服务器类库通过依赖声明载入应用，如Java的Jetty。完全由客户端，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。HTTP并不是唯一一个可以由端口绑定提供的服务，其实所有服务器软件都可以通过进程绑定端口来等待请求，这也就意味着一个应用可以成为另一个应用的后端服务，调用方将服务方提供的响应URL当作资源存入配置以备将来调用\n\n并发：通过进程模型进行扩展\n​        任何计算机程序，一旦启动，就会生成一个或多个进程，例如：在程序启动之初JVM提供了一个超级进程，并通过多线程实现内部的开发管理。\n​        通过借鉴Unix守护进程模型，把不同的工作分配给不同的进程类型，例如：常驻的后台工作交给worker进程负责，应用进程具备无共享、水平分区的特性，所以添加并发会变得简单。应用进程不需要守护进程，而是借助操作系统的进程管理器（systemd、分布式的进程管理云平台）,来管理输出流，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。\n\n易处理：快速启动和优雅终止可最大化健壮性\n​        应用进程是易处理的，意味着它们可以瞬间开启或停止。这有利于快速、弹性的伸缩应用，迅速部署变化的代码和配置，稳健的部署应用。\n​        进程应当追求最小启动时间，并且一旦接受终止信号就会优雅的终止。对于网络进程，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出，此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。对于worker进程来说，优雅终止是指将当前任务退回队列，此类型的进程所隐含的要求是可重复执行， 这主要由将结果包装进事务或是使幂等来实现。\n​        进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。\n\n开发环境与线上环境等价：尽可能的保持开发、预发布、线上环境相同\n​        减少部署所需时间，开发人员密切参与部署过程，尽量保证开发环境以及线上环境的一致性。不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。\n\n日志：把日志当作事件流\n​        日志使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。日志应该是事件流的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。\n​        不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。\n\n管理进程：后台管理任务当作一次性进程运行\n​        进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务。一次性管理进程应该和正常的常驻进程使用同样的环境。这些管理进程和任何其他的进程一样使用相同的代码和配置，基于某个发布版本运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。\n\n\n3.实践1.系统设计总览1.扩展性\n可扩展性视频\n垂直扩展\n水平扩展\n缓存\n负载均衡\n数据库复制\n数据库分区\n\n\n可扩展性文章（http://www.lecloud.net/tagged/scalability/chrono）\n克隆：每个服务器包含相同的代码仓库，并且不再本地磁盘缓存任何用户相关的数据，这些数据都被存在类似于Redis这样的中心化的仓库中，但会引发数据部署不一致的问题\n数据库：从一开始反范式化（不用Joins），并且用类似于MongoDB这样的NoSQL数据库，并在应用层来实现连接操作，但依旧会越来越慢\n缓存：添加缓存层，缓存许多对象而不是缓存查询结果，即先用class处理数据再缓存类实例，而且可以通过异步访问提高访问速度\n异步：\n提起做好时间密集型的工作：动态内容-&gt;静态内容\n特殊需求必须处理：通过类似与RabbitMQ的消息队列\n\n\n\n\n\n2.权衡与取舍\nPerformance VS Scalability\n性能表现在单个用户访问的快慢，可扩展性是指在资源扩展时性能所增长的比例，对于上线的服务可扩展性指的是为冗余加资源不会导致性能下降\n\nLatency VS thoughtput\n延迟指的是执行操作/运算d饿到结果所花费的时间，吞吐量指的是单位时间执行此类操作？运算的数量\n\nAvailability VS Consistency\n\nCAP理论\n一致性：每次访问都能得到最新的数据，但会得到错误响应\n可用性：每次访问都能收到非错响应，但不保证获取最新数据\n分区容错性：在任意分区网络故障的情况下，系统仍能继续运行\n\n\nCP：等待分区节点的响应可能会导致延时响应，用在：业务需要原子读写\nAP：响应节点上数据可能不是最新的，当分区解析完，写入操作可能需要时间来传播，如果业务需求允许最终一致性，或当由外部故障时要求系统继续运行\n\n\n一致性模式（Weak、Eventual、Strong）\n\n弱一致性：在写入之后，访问不一定能看到。在视频聊天、实时多人游戏用的多\n最终一致性：再写入后，访问最终能看到写入数据（通常在数毫秒内），数据被异步复制。用在DNS，Emil，在高可用系统中效果不错\n强一致性：在写入后，访问立即可见，数据被同步复制。用在文件系统和关系型数据库\n\n\n可用性模式\n\n故障切换（Fail-over）：增加硬件增加复杂性、会丢失数据\n工作到备用切换（Active-passive）：工作服务器周期发信号给备用服务器，多信号中断，则备用服务器切换为工作服务器的IP地址，并恢复服务。也称为主从切换\n双工作切换（Active-active）：双方都管控流量，分散负载。也成为主主切换\n\n\n复制（Replication）：见数据库主从复制和主主复制\n\n\n可用性指标\n\n99.9% availability - three 9s\n\n\n\nDuration\nAcceptable downtime\n\n\n\nDowntime per year\n8h 45min 57s\n\n\nDowntime per month\n43m 49.7s\n\n\nDowntime per week\n10m 4.8s\n\n\nDowntime per day\n1m 26.4s\n\n\n\n99.99% availability - four 9s\n\n\n\nDuration\nAcceptable downtime\n\n\n\nDowntime per year\n52min 35.7s\n\n\nDowntime per month\n4m 23s\n\n\nDowntime per week\n1m 5s\n\n\nDowntime per day\n8.6s\n\n\n\n\n\n\n3.Domain name system\n把域名转换成IP地址，分层次结构\n缺陷：\n虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。\n虽然它们通常由政府，网络服务提供商和大公司管理，但 DNS 服务管理仍可能是复杂的。\nDNS 服务最近遭受DDoS 攻击。\n\n\n\n4.Content delivery network\n内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，CDN 的 DNS 解析会告知客户端连接哪台服务器。\nCDN推送：当你服务器上的内容变动时，推送CDN接受新内容并重写URL。内容只有在更新或更改时才推送，流量最小化，但存储最大化。（上传整个数据）\nCDN拉取：当第一个用户请求该资源时，从服务器上拉去资源。将内容先留在自己的服务其上并更改URL，直到内容被缓存在CDN上为止。（取下来一部分）\n缺陷\nCDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。\n如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。\nCDN 需要更改静态内容的 URL 地址以指向 CDN。\n\n\n\n5.Load Balancer\n将传入的请求分发到应用服务器和数据库等计算资源，并返回给恰当的客户端。主要为了：防止请求进入不好的服务器、防止资源过载、帮助消除单一的故障点\n通常会设置多个LB，以免发生故障，并基于多种方式来路由流量\n随机\n最少负载\nSession/cookie\n轮询调度或加权轮询调度\n四层负载均衡：根据IP，执行NAT来向上游服务器转发网络数据包\n七层负载均衡：根据请求头、cookie等来决定如何分发，送给特定的服务器\n\n\n水平扩展：负载均衡器帮助水平扩展，提高性能和可用性\n缺陷\n如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。\n引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。\n单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。\n\n\n\n6.Reverse proxy(Web server)\n反向代理时一种可以集中调用内部服务，并提供统一接口给公共客户的web服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端\n优势：\n增加安全性\n提高可扩展性和灵活性\n压缩服务器响应\n直接返回命中的缓存结果\n直接提供静态内容\n\n\n缺陷\n引入反向代理会增加系统的复杂度。\n单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如故障转移）会进一步增加复杂度。\n\n\n\n7.Platform Layer（应用层）\n将web层和应用层分离，可以独立缩放和配置这两层，添加新的API只需要添加应用层服务器，而不需要改变web服务器\n单一职责原则：提倡小型的，自治的服务共同合作，小团队通过提供小型的服务，可以更激进地计划增长\n==微服务==：可以描述为一些列可以独立部署的小型的，模块化服务，每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标\n==服务发现==：像Consul、Etcd和Zookeeper这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。Health checks可以帮助确认服务的完整性和是否经常使用一个HTTP路径。Consul和Etcd都有一个内建的key-value存储用来存储配置信息和其他的共享信息。\n缺陷：\n添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。\n微服务会增加部署和运营的复杂度。\n\n\n\n8-1.RDBMS\nACID特性\n\n扩展技术：\n\nmaster-slave replication：主库同时负责读写，并复制写入到若干从库，从库只负责读\n\nmaster-master replication：两个主库都负责读写，写入时互相协调，难以保证一致性\n\nfederation(联合)：联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：论坛、用户和产品，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。效率低。\n\nsharding(分片)：分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。会带类复杂的SQL查询\n\ndenormalization(非规范化)：试图以写入性能为代价来换取读取性能 ，在多个表中冗余数据副本，以避免高成本的联结操作\n\nSQL tuning(调优)：利用基准测试和性能分析可以得到以下优化方案\n\n改进模式\n\n为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。\n使用CHAR类型存储固定长度的字段，不要用VARCHAR。\nCHAR 在快速、随机访问时效率很高。如果使用 VARCHAR，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。\n\n\n使用 TEXT 类型存储大块的文本，例如博客正文。TEXT 还允许布尔搜索。使用 TEXT 字段需要在磁盘上存储一个用于定位文本块的指针。\n使用 INT 类型存储高达 2^32 或 40 亿的较大数字。\n使用 DECIMAL 类型存储货币可以避免浮点数表示错误。\n避免使用 BLOBS 存储实际对象，而是用来存储存放对象的位置。\nVARCHAR(255) 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。\n在适用场景中设置 NOT NULL 约束来提高搜索性能。\n\n\n使用正确的索引\n\n你正查询（SELECT、GROUP BY、ORDER BY、JOIN）的列如果用了索引会更快。\n索引通常表示为自平衡的 B 树，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。\n设置索引，会将数据存在内存中，占用了更多内存空间。\n写入操作会变慢，因为索引需要被更新。\n加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。\n\n\n避免高成本的联结操作\n\n有性能需要，可以进行非规范化。\n\n\n分割数据表\n\n将热点数据拆分到单独的数据表中，可以有助于缓存。\n\n\n调优查询缓存\n\n在某些情况下，查询缓存可能会导致性能问题。\n\n\n\n\n\n\n\n8-2.NoSQL\n\n\n\n\n\n\n\n\nNoSQL is a collection of data items represented in a key-value store, document store, wide column store, or a graph database. Data is denormalized, and joins are generally done in the application code. 大多数NoSQL无法实现真正符合ACID的事务，支持最终一致性\n\nBASE特性\nBasically available：系统保证可用性\nSoft state：即使没有输入，系统状态也可能随时间变化\nEventual consistency：经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入\n\n\nkey-value store：O(1)的读写，用内存或SSD存储数据，性能很高，通常用于存储简单数据模型或频繁修改的数据\ndocument store：将文档抽象为键-值存储，文档存储了指定对象的全部信息，基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。\nwide column store：\n抽象模型：嵌套的 ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt; 映射\n类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。\n列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。\n\n\ngraph database\n在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。\n\n\n\n==SQL or NoSQL==\n\n选取SQL的原因：结构化数据、严格的模式、关系型数据、需要复杂的连接操作、事务、清晰的扩展模式、通过索引进行查询非常快、社区资源丰富\n选取NoSQL的原因：半结构化数据、动态或灵活的模式、非关系型数据、不需要复杂的联结操作、存储TB或PB级别的数据、高数据密集的工作负载、IOPS高吞吐量\n适合NoSQL的示例数据：埋点数据和日志数据、排行榜或得分数据、类似购物车的临时数据、频繁访问的热表、元数据或查找表\n\n9.缓存\n客户端缓存：缓存可以位于客户端（操作系统或者浏览器）、服务端或者不同的缓存层\nCDN缓存：CDN也被视为一种缓存\nWeb服务器缓存：反向代理和缓存可以直接提供静态和动态内容，Web服务器同样也可以缓存请求，返回相应的结果而不必连接应用服务器\n数据库缓存：数据库的默认配置中通常包含缓存级别，调整配置，在不同情况下使用不同的模式可以进一步提高性能\n应用缓存：基于内存的缓存比如Reids是应用程序和数据存储之间的一种键值存储。\n数据库查询级别的缓存：将查询语句的哈希值与查询结果存储在缓存中，会遇到以下问题：\n很难用复杂的查询删除已缓存结果\n如果一条数据比如表中某数据的一项被改变，则需要删除所有可能包含已更改项的缓存\n\n\n对象级别的缓存：将数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：\n如果对象的基础数据已更改，那么从缓存中删掉这个对象\n允许异步处理：workers通过使用最新的缓存对象来组装对象\n建议缓存的内容：用户会话、完全渲染的Web页面、活动流、用户图数据\n\n\n何时更新缓存\n缓存模式：首先从缓存中查找记录，如果所需数据不在缓存中，则从数据库中加载所需内容，并将查询结果存储到缓存中（Memcached）\n直写模式：应用向缓存中添加或更新数据，缓存同步地写入数据存储，返回所需内容\n回写模式：在缓存中增加或者更新条目，异步写入数据，提高写入性能\n刷新：可以将缓存配置成在到期之前自动刷新最近访问过的内容，如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低\n\n\n\n10.异步\n消息队列：消息队列接受、保留和传递信息，不阻塞用户操作，作业在后台处理。如RabbitMQ\n任务队列：当任务队列接收任务及其相关数据，运行它们，然后传递其结果。它们可以支持调度，并可用于在后台运行计算密集型作业\n背压：如果队列开始明显增长，那么队列的大小可能会超过内存大小，导致高速缓存未命中。背压可以通过限制队列大小，从而使得队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将的到服务器忙或HTTP503状态码，以便稍后重试。\n缺陷：简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。\n\n2.互联网架构模板\n1.存储层\nSQL\n\nOracle太贵，使用开源的MySQL\n性能要求越来越高，将数据拆分到多个数据库实例，将这部分功能（数据如何拆分和组合）独立成中间件，例如百度的DBProxy、淘宝的TDDL、MySQL的MySQL Router\nSQL服务器越来越多，每个业务都有自己的SQL集群，资源浪费而且维护成本高，在SQL集群上构建SQL存储平台，以对业务透明的形式提供资源分配、数据备份、迁移、容灾、读写分离、分库分表等一系列操作，例如淘宝的UMP系统\n\n\nNoSQL\n\n在数据结构上和性能上来弥补MySQL的不足，而且NoSQL一般自己本身就提供集群功能\nNoSQL发展到一定规模后，通常都会在NoSQL集群的基础上在实现统一存储平台，主要有以下几种功能：\n资源动态按需动态分配：例如同一台 Memcache 服务器，可以根据内存利用率，分配给多个业务使用。\n资源自动化管理：例如新业务只需要申请多少 Memcache 缓存空间就可以了，无需关注具体是哪些 Memcache 服务器在为自己提供服务。\n故障自动化处理：例如某台 Memcache 服务器挂掉后，有另外一台备份 Memcache 服务器能立刻接管缓存请求，不会导致丢失很多缓存数据。\n\n\n\n\n小文件存储\n\n小文件具有：数据小，数量巨大，访问量大的特点\n由于大数据的火爆，可以选用在开源方案（HBase、Hadoop）的基础上封装一个小文件存储平台，例如淘宝的TFS、京东JFS\n\n\n大文件存储\n\n互联网行业的大文件主要分为两类：\n\n业务上的大数据：Youtube的视频、电影网站的电影\n海量的日志数据：各种访问日志、操作日志、用户轨迹日志等\n\n\n著名的有：Google的三篇大数据论文、Yahoo开源的Hadoop系列（HDFS、HBase），因为对照论文实现的成本太高，所以一般使用开源方案，例如：Hadoop、HBase、Storm、Hive等，或者基于开源方案封装成大数据平台：淘宝的云梯系统、腾讯的TDW系统\n\n\n\n\n2.开发层和服务层\n开发框架：优选成熟的框架，避免盲目追逐新技术，公司内大多使用统一的开发框架，例如：Java的SSM、Ruby的Ruby on Rails、PHP的ThinkPHP、Python的Django\n\nWeb服务器：使用开源方案，主要和开发语言相关，例如：通用的Apache、Java的Tomcat、Python/PHP的Nginx\n\n容器：传统的虚拟化技术是虚拟机，解决了跨平台的问题，但太厚重，Docker的容器技术，随软没有跨平台、但启动快、几乎不占资源。Docker推动了自动化运维和微服务设计\n\n配置中心：集中管理各个系统的配置，检查方便、协作效率高，配置中心相当于备份了系统的配置，能够快速搭建环境\n\n服务中心：主要是为了解决上面提到的跨系统依赖的“配置”和“调度问题，一般有两种实现方式：\n\n服务名字系统：类似于DNS，将Service名称解析为host+port+接口名称\n\n服务总线系统：类似于总线，由总线系统完成调用，服务请求方不需要直接和服务提供方交互\n\n两者的对比：\n\n\n\n消息队列\n\n互联网业务的一个特点就是快，这就要求很多业务处理采用异步的方式\n消息队列可以简化系统间的依赖，使得增加新的消息生产者变的简单，开源方案有：RocketMQ、Kafka、ActiveMQ\n\n\n\n3.网络层\n\n\n\n\n\n\n\n\n为了满足互联网的高性能和高可用\n\n负载均衡\nDNS：一般用来实现地理级别的均衡，但缺点式缓存时间长、不够灵活，可以尝试HTTP-DNS的功能，即使用一个HTTP协议实现一个私有DNS\nNginx、LVS、F5：用于同一地点内机器级别的负载均衡，其中Nginx是软件的7层负载均衡、LVS是内核的4层负载均衡、F5是硬件的4层负载均衡\n\n\nCDN：将内容缓存在离用户最近的地方，用户访问缓存的内容而不是站点实时的内容，大多从CDN服务商购买CDN服务即可\n多机房：单机房难以保证业务的高可用，多机房设计最核心的因素就是如何处理时延带来的影响\n多中心：以多机房为前提，更复杂，重点在于保证：数据一致性和数据事务性\n\n4.用户层和业务层\n用户管理：\n通过互联网将众多分散的用户连接起来\n单点登录（SSO）：多个子系统不可能每个都管理这么庞大的用户，所以需要单点登录，实现手段主要有：cookie、JSONP、token等，目前最成熟的开源方案是CAS架构\n授权登录：当业务做大成了平台后，开放成为了促进业务进一步发展的手段，需要允许第三方应用接入，由此引出授权登录，现在最流行的授权登录就是OAuth2.0\n虽然用户量巨大，但是因为不同用户间登录基本没有关系，可以使用一个简单的负载均衡就能轻松应对\n\n\n消息推送：\n消息推送的不同路径，分为短信、邮件、站内信、App推送。除了App，不同的途径基本上调用不同的API即可完成，技术上没有什么难度，例如：短信需要依赖运营商的短信接口、邮件需要依赖邮件服务商的邮件接口、站内信是系统提供的消息通知功能。\nApp主要分为iOS和Android推送，iOS系统比较规范和封闭，基本上只能使用苹果的APNS；Android在国内大厂会自己实现一套消息推送机制\n消息推送主要包括三个功能：\n海量设备和用户管理﻿﻿：消息推送的设备数量众多，存储和管理这些设备是比较复杂的；同时，为了针对不同用户进行不同的业务推广，还需要收集用户的一些信息，简单来说就是将用户和设备关联起来，需要提取用户特征对用户进行分类或者打标签等。\n连接保活：﻿﻿要想推送消息必须有连接通道，但是应用又不可能一直在前台运行，大部分设备为了省电省流量等原因都会限制应用后台运行，限制应用后台运行后连接通道可能就被中断了，导致消息无法及时的送达。连接保活是整个消息推送设计中细节和黑科技最多的地方，例如应用互相拉起、找手机厂商开白名单等。\n消息管理﻿﻿：实际业务运营过程中，并不是每个消息都需要发送给每个用户，而是可能根据用户的特征，选择一些用户进行消息推送。由于用户特征变化很大，各种排列组合都有可能，将消息推送给哪些用户这部分的逻辑要设计得非常灵活，才能支撑花样繁多的业务需求，具体的设计方案可以采取规则引擎之类的微内核架构技术。\n\n\n\n\n存储云、图片云\n互联网业务场景中，用户会上传多种类型的文件数据，例如微信用户发朋友圈时上传图片，微博用户发微博时上传图片、视频，优酷用户上传视频，淘宝卖家上传商品图片等，这些文件具备几个典型特点：数据量大、文件体积小、访问有时效性\n通过CDN+小文件存储来实现，或直接购买云服务\n\n\n业务层技术\n互联网的业务千差万别，不同的业务分解下来有不同的系统，所以业务层没有办法提炼一些公共的系统或者组件。抛开业务上的差异，各个互联网业务发展最终面临的问题都是类似的：业务复杂度越来越高。也就是说，业务层面对的主要技术挑战是“复杂度”。复杂度越来越高的一个主要原因就是系统越来越庞大，业务越来越多。幸运的是，面对业务层的技术挑战，我们都可以通过“拆”，化整为零、分而治之，将整体复杂性分散到多个子业务或者子系统里面去。具体拆的方式你可以查看专栏前面可扩展架构模式部分的分层架构、微服务、微内核等。\n随着子系统数量越来越多，如果达到几百上千，另外一个复杂度问题又会凸显出来：子系统数量太多，已经没有人能够说清楚业务的调用流程了，出了问题排查也会特别复杂。此时应该怎么处理呢，总不可能又将子系统合成大系统吧？最终答案还是“合”，正所谓“合久必分、分久必合”，但合的方式不一样，此时采取的“合”的方式是按照“高内聚、低耦合”的原则，将职责关联比较强的子系统合成一个虚拟业务域，然后通过网关对外统一呈现，类似于设计模式中的 Facade 模式。\n\n\n\n5.平台层\n运维平台\n\n运维平台核心的职责分为四大块：配置、部署、监控、应急，每个职责对应系统生命周期的一个阶段，如下所示：\n配置：主要负责资源的管理。例如，机器管理、IP 地址管理、虚拟机管理等。\n部署：主要负责将系统发布到线上。例如，包管理、灰度发布管理、回滚等。\n监控：主要负责收集系统上线运行后的相关数据并进行监控，以便及时发现问题。\n应急：主要负责系统出故障后的处理。例如，停止程序、下线故障机器、切换 IP 等。\n\n\n运维平台的核心要素式：标准化、平台化、自动化、可视化。\n\n\n测试平台\n\n测试平台核心的职责当然就是测试了，包括单元测试、集成测试、接口测试、性能测试等，都可以在测试平台来完成。测试平台的核心目的是提升测试效率，从而提升产品质量，其设计关键就是自动化\n\n架构如图：\n\n\n\n用例管理：测试自动化的主要手段就是通过脚本或者代码来进行测试，例如单元测试用例是代码、接口测试用例可以用 Python 来写、可靠性测试用例可以用 Shell 来写。为了能够重复执行这些测试用例，测试平台需要将用例管理起来，管理的维度包括业务、系统、测试类型、用例代码。例如，网购业务的订单系统的接口测试用例。\n资源管理：测试用例要放到具体的运行环境中才能真正执行，运行环境包括硬件（服务器、手机、平板电脑等）、软件（操作系统、数据库、Java 虚拟机等）、业务系统（被测试的系统）。除了性能测试，一般的自动化测试对性能要求不高，所以为了提升资源利用率，大部分的测试平台都会使用虚拟技术来充分利用硬件资源，如虚拟机、Docker 等技术。\n任务管理：任务管理的主要职责是将测试用例分配到具体的资源上执行，跟踪任务的执行情况。任务管理是测试平台设计的核心，它将测试平台的各个部分串联起来从而完成自动化测试。\n数据管理：测试任务执行完成后，需要记录各种相关的数据（例如，执行时间、执行结果、用例执行期间的 CPU、内存占用情况等）\n\n\n\n\n数据平台\n\n数据：数据平台的核心职责主要包括三部分：数据管理、数据分析和数据应用\n\n数据管理数据管理包含数据采集、数据存储、数据访问和数据安全四个核心职责，是数据平台的基础功能。\n\n数据采集：从业务系统搜集各类数据。例如，日志、用户行为、业务数据等，将这些数据传送到数据平台。\n数据存储：将从业务系统采集的数据存储到数据平台，用于后续数据分析。\n数据访问：负责对外提供各种协议用于读写数据。例如，SQL、Hive、Key-Value 等读写协议。\n数据安全：通常情况下数据平台都是多个业务共享的，部分业务敏感数据需要加以保护，防止被其他业务读取甚至修改，因此需要设计数据安全策略来保护数据。\n\n\n数据分析数据分析包括数据统计、数据挖掘、机器学习、深度学习等几个细分领域。\n\n数据统计：根据原始数据统计出相关的总览数据。例如，PV、UV、交易额等。\n数据挖掘：数据挖掘这个概念本身含义可以很广，为了与机器学习和深度学习区分开，这里的数据挖掘主要是指传统的数据挖掘方式。例如，有经验的数据分析人员基于数据仓库构建一系列规则来对数据进行分析从而发现一些隐含的规律、现象、问题等，经典的数据挖掘案例就是沃尔玛的啤酒与尿布的关联关系的发现。\n机器学习、深度学习：机器学习和深度学习属于数据挖掘的一种具体实现方式，由于其实现方式与传统的数据挖掘方式差异较大，因此数据平台在实现机器学习和深度学习时，需要针对机器学习和深度学习独立进行设计。\n\n\n数据应用数据应用很广泛，既包括在线业务，也包括离线业务。例如，推荐、广告等属于在线应用，报表、欺诈检测、异常检测等属于离线应用。数据应用能够发挥价值的前提是需要有“大数据”，只有当数据的规模达到一定程度，基于数据的分析、挖掘才能发现有价值的规律、现象、问题等。如果数据没有达到一定规模，通常情况下做好数据统计就足够了，尤其是很多初创企业，无须一开始就参考 BAT 来构建自己的数据平台。\n\n\n\n管理平台\n\n管理平台的核心职责就是权限管理，无论是业务系统（例如，淘宝网）、中间件系统（例如，消息队列 Kafka），还是平台系统（例如，运维平台），都需要进行管理。如果每个系统都自己来实现权限管理，效率太低，重复工作很多，因此需要统一的管理平台来管理所有的系统的权限。权限管理主要分为两部分：身份认证、权限控制\n身份认证：确定当前的操作人员身份，防止非法人员进入系统。例如，不允许匿名用户进入系统。为了避免每个系统都自己来管理用户，通常情况下都会使用企业账号来做统一认证和登录。\n权限控制：根据操作人员的身份确定操作权限，防止未经授权的人员进行操作。例如，不允许研发人员进入财务系统查看别人的工资。\n\n\n\n\n\n3.服务端高并发分布式架构演进之路1. 概述本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。（特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径）\n2. 基本概念在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：\n\n分布式系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上\n高可用系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性\n集群一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性\n负载均衡请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的\n正向代理和反向代理系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。\n\n3. 架构演进3.1 单机架构\n以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。\n\n\n\n\n\n\n\n\n\n随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务\n3.2 第一次演进：Tomcat与数据库分开部署\nTomcat和数据库分别独占服务器资源，显著提高两者各自性能。\n\n\n\n\n\n\n\n\n\n随着用户数的增长，并发读写数据库成为瓶颈\n3.3 第二次演进：引入本地缓存和分布式缓存\n在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。\n\n\n\n\n\n\n\n\n\n缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢\n3.4 第三次演进：引入反向代理实现负载均衡\n在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。\n\n\n\n\n\n\n\n\n\n反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈\n3.5 第四次演进：数据库读写分离\n把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。\n\n\n\n\n\n\n\n\n\n业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能\n3.6 第五次演进：数据库按业务分库\n把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。\n\n\n\n\n\n\n\n\n\n随着用户数的增长，单机的写库会逐渐会达到性能瓶颈\n3.7 第六次演进：把大表拆分为小表\n比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。\n这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。\n目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。\n\n\n\n\n\n\n\n\n\n数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈\n3.8 第七次演进：使用LVS或F5来使多个Nginx负载均衡\n由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。\n此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。\n\n\n\n\n\n\n\n\n\n由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同\n3.9 第八次演进：通过DNS轮询实现机房间的负载均衡\n在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。\n\n\n\n\n\n\n\n\n\n随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求\n3.10 第九次演进：引入NoSQL数据库和搜索引擎等技术\n当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。\n当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。\n\n\n\n\n\n\n\n\n\n引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难\n3.11 第十次演进：大应用拆分为小应用\n按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。\n\n\n\n\n\n\n\n\n\n不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级\n3.12 第十一次演进：复用的功能抽离成微服务\n如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。\n\n\n\n\n\n\n\n\n\n不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱\n3.13 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异\n通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。\n\n\n\n\n\n\n\n\n\n业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难\n3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理\n目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。\n在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在3.14节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。\n\n\n\n\n\n\n\n\n\n使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低\n3.15 第十四次演进：以云平台承载系统\n系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。\n所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：\n\nIaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；\nPaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；\nSaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。\n\n\n\n\n\n\n\n\n\n\n至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论\n4. 架构设计总结\n架构的调整是否必须按照上述演变路径进行？不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。\n对于将要实施的系统，架构应该设计到什么程度？对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。\n服务端架构和大数据架构有什么区别？所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。\n有没有一些架构设计的原则？\nN+1设计。系统中的每个组件都应做到没有单点故障；\n回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；\n禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；\n监控设计。在设计阶段就要考虑监控的手段；\n多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；\n采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；\n资源隔离设计。应避免单一业务占用全部资源；\n架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；\n非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；\n使用商用硬件。商用硬件能有效降低硬件故障的机率；\n快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；\n无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。\n\n\n\n4.高性能架构1.数据库集群\n读写分离\n原理：将数据库读写操作分散到不同的节点上，将访问压力分散到集群中的多个节点，但是没有分散存储压力\n基本实现：\n数据库服务器搭建主从集群，一主一从，一主多从等\n数据库主机负责读写操作，从机只负责读操作\n数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据\n业务服务器将写操作发给数据库主机，将读操作发给数据库从机\n\n\n主从复制延迟：（MySQL可能达到1秒）\n写操作后的读操作指定发给数据库主服务器（对业务侵入和影响大）\n读从机失败后再读一次主机（增加主机的读操作压力）\n关键业务读写操作全部指向主机，非关键业务采用读写分离\n\n\n分配机制：（实现机制）\n程序代码封装（Taobao Distributed Data Layer）：在代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理（实现简单，但不通用，故障情况下主从切换需要修改配置并重启）\n中间件封装（MySQL Router）：独立出一套系统出来，实现读写操作分离和数据库服务器连接的管理，对于业务服务器来说，访问中间件和访问数据库没有区别（支持多种编程语言，实现复杂，性能要求高，可以探测数据库服务器的主从切换）\n\n\n\n\n分库分表\n原理：按照业务模块将数据分散到不同的数据库服务器，既可以分散访问压力，又可以分散存储压力\n问题：无法使用SQL的join查询、无法通过事务统一修改、成本高（一般单台数据库服务器可以支撑10万用户量级的业务）\n分表：\n垂直分表：表记录相同但包含不同的列，适合将表中某些不常用且占了大量空间的列拆分出去\n水平分表：表的列相同但包含不同的行，适合表行数特别大的表，当数据量达到千万级别时就需要警觉，会引入如下复杂性\n路由：水平分表后，某条数据具体数据哪个切分后的子表，需要增加路由算法进行计算，常见的路由算法有：\n范围路由：选取有序的数据列作为路由的条件，不同分段分散到不同的数据库表中\nHash路由：选取某个列或几个列组合的值进行Hash运算，然后根据Hash结果分散到不同的数据库表中\n配置路由：用一张独立的路由表来记录路由信息，设计简单，使用灵活，扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了\n\n\njoin：需要在业务代码或数据库中间件进行多次join操作，然后将结果合并\ncount()：多个count()结果相加、记录数表（新建一张表，插入删除成功都更新次表）\norder by：只能由业务代码或者数据库中间件分别查询每个子表中的数据，然后汇总进行排序\n\n\n实现：和数据库读写分离类似，分库分表具体的实现方式也是程序代码封装和中间件封装\n\n\n\n\n\n2.NoSQL\nK-V存储：解决关系数据库无法存储数据结构的问题，但只能保证隔离性和一致性无法保证隔离性和一致性，==Redis==\n文档数据库：解决关系数据库强schema约束的问题，一般存储JSON格式的数据，适合电商和游戏这类业务场景，无法保证事务性，无法实现join操作，==MongoDB==\n列式数据库：解决关系数据库大数据场景下的I/O问题，业务同时读取多个列时效率高（不需读出整行数据），能够一次性完成对一行中的多个列的写操作，大多应用于大数据分析和统计场景，==HBase==\n全文搜索引擎：解决关系数据库的全文搜索性能问题，==Elasticsearch==\n原理：倒排索引，建立单词到文档的索引，根据关键词来查询文档内容\n\n\n\n3.缓存：使用程序代码实现或中间件来实现\n缓存穿透：缓存没有发挥作用（存储数据不存在、缓存数据生成耗费大量时间或资源）\n\n缓存雪崩：当缓存失效（过期）后引起系统性能急剧下降的情况\n\n更新锁机制：\n​        对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值\n​        对于采用分布式集群的业务系统，由于存在几十上百台服务器，即使单台服务器只有一个线程更新缓存，但几十上百台服务器一起算下来也会有几十上百个线程同时来更新缓存，同样存在雪崩的问题。因此分布式集群的业务系统要实现更新锁机制，需要用到分布式锁，如 ZooKeeper。\n\n后台更新机制：\n​        由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。\n​        当缓存系统内存不够时，会“踢掉”一些缓存数据，从缓存被“踢掉”到下一次定时更新缓存的这段时间内，业务线程读取缓存返回空值，而业务线程本身又不会去更新缓存，因此业务上看到的现象就是数据丢了，解决方式有：\n\n后台线程除了定时更新缓存，还要频繁地去读取缓存，如果发现缓存被“踢了”就立刻更新缓存\n业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存\n\n\n缓存热点：\n​        缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。\n​        缓存副本设计有一个细节需要注意，就是不同的缓存副本不要设置统一的过期时间，否则就会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期时间范围，不同的缓存副本的过期时间是指定范围内的随机值。\n\n\n\n\n4.单服务器\nPPC\n\n全称为Process per connection，即每次有新的连接就新建一个进程取专门处理这个连接的请求，实现简单，适合服务器的连接数没那么多的情况，如数据库服务器\n缺点：fork代价高、父子进程通信复杂（IPC）、支持的并发连接数量有限\nprefork：用来解决fork代价高使得用户访问时感觉响应较慢的问题，系统在启动的时候预先创建好进程，然后才开始接收用户的请求\n\n\nTPC\n\n全称Thread per connection，即每次有新的连接就新建一个线程去专门处理这个连接的请求，解决fork代价高和进程通信复杂的问题\n缺点：高并发时还是有性能问题、进程间的互斥和共享复杂又引入死锁问题、多线程会互相影响\nprethread：预先创建线程。然后才开始接受用户的请求，常见的实现方式有以下几种\n主进程accept，然后将连接交给某个线程处理\n子线程都尝试去accpet，最终只有一个线程accept成功\n\n\n\n\nReactor（Dispatcher模式）\n\nI/O多路复用+线程池\n\nReactor模式三种实现\n\n单Reactor单进程/线程：实现简单、无多核CPU优势、Handler 在处理某个连接上的业务时，整个进程无法处理其他连接的事件，==Redis==，C语言一般单进程，Java一般单线程\n\nReactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。\n如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。\n如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的 Handler）来进行响应。\nHandler 会完成 read-&gt; 业务处理 -&gt;send 的完整业务流程。\n\n\n\n单Reactor多线程：充分利用多核CPU，但多线程数据共享和访问比较复杂，Reactor 承担所有事件的监听和响应，只在主线程中运行，瞬间高并发时会成为性能瓶颈。\n\n主线程中，Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。\n如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。\n如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的 Handler）来进行响应。\nHandler 只负责响应事件，不进行业务处理；Handler 通过 read 读取到数据后，会发给 Processor 进行业务处理。\nProcessor 会在独立的子线程中完成真正的业务处理，然后将响应结果发给主进程的 Handler 处理；Handler 收到响应后通过 send 将响应结果返回给 client。\n\n\n\n多Reactor多进程/线程：==Nginx 采用多 Reactor 多进程，多 Reactor 多线程的实现有 Memcache 和 Netty==\n\n父进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 接收，将新的连接分配给某个子进程。\n子进程的 subReactor 将 mainReactor 分配的连接加入连接队列进行监听，并创建一个 Handler 用于处理连接的各种事件。\n当有新的事件发生时，subReactor 会调用连接对应的 Handler（即第 2 步中创建的 Handler）来进行响应。\nHandler 完成 read→业务处理→send 的完整业务流程。\n\n\n\n\n\n\n\nProactor：\n\nReactor 可以理解为“来了事件我通知你，你来处理”，而 Proactor 可以理解为“来了事件我来处理，处理完了我通知你”\n\n方案：\n\nProactor Initiator 负责创建 Proactor 和 Handler，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核。\nAsynchronous Operation Processor 负责处理注册请求，并完成 I/O 操作。\nAsynchronous Operation Processor 完成 I/O 操作后通知 Proactor。\nProactor 根据不同的事件类型回调不同的 Handler 进行业务处理。\nHandler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。\n\n\n\n\n\n\n5.集群负载均衡\n出现原因：高性能集群的复杂性主要体现在需要增加一个负载均衡器，以及为任务选择一个合适的任务分配算法，但负载均衡不只是为了计算单元的负载达到均衡状态\n\n负载均衡分类\n\nDNS负载均衡：\n一般用来实现地理级别的均衡，本质是DNS解析同一域名可以返回不同的IP地址，例如北京的用户访问北京的机房、南方的用户访问深圳的机房\n优点是：简单、成本低，就近访问提升访问速度；缺点有：更新不及时（DNS缓存的时间比较长）、扩展性差（无法对DNS负载均衡进行更改）、分配策略比较简单\n\n\n硬件负载均衡：\n通过单独的硬件设备来实现负载均衡功能，可以理解为一个用于负载均衡的基础网络设备\n优点是：功能强大、性能强大、稳定性高、支持安全防护，缺点有：价格昂贵、扩展能力差\n\n\n软件负载均衡：\n通过负载均衡软件来实现负载均衡功能，常见的有Nginx是软件的7层负载均衡、LVS是Linux内核的4层负载均衡，4层和7层区别就在于协议和灵活性\n优点是简单、便宜、灵活，缺点是：性能一般、功能没有硬件负载均衡那么强大、一般不具备防火墙和防DDoS攻击等安全功能\n\n\n\n\n负载均衡典型架构：DNS负载均衡用于实现地理级别的负载均衡；硬件负载均衡用来实现集群级别的负载均衡；软件负载均衡用来实现机器级别的负载均衡\n\n算法：\n\n分类：\n\n任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的“平均”可以是绝对数量的平均，也可以是比例或者权重上的平均。\n负载均衡类：负载均衡系统根据服务器的负载来进行分配，这里的负载并不一定是通常意义上我们说的“CPU 负载”，而是系统当前的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量系统的压力。\n性能最优类：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。\nHash 类：负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上。常见的有源地址 Hash、目标地址 Hash、session id hash、用户 ID Hash 等。\n\n\n轮询：\n\n负载均衡系统收到请求后，按照顺序轮流分配到服务器上\n只要服务器在运行，运行状态是不关注的\n\n\n加权轮询：\n\n负载均衡系统根据服务器权重进行任务分配，这里的权重一般是根据硬件配置进行静态配置的，采用动态的方式计算会更加契合业务，但复杂度也会更高\n解决不同服务器处理能力有差异的问题\n\n\n负载最低优先\n\n负载均衡系统将任务分配给当前负载最低的服务器\n不同指标：\nLVS 这种 4 层网络负载均衡设备，可以以“连接数”来判断服务器的状态，服务器连接数越大，表明服务器压力越大。\nNginx 这种 7 层网络负载系统，可以以“HTTP 请求数”来判断服务器状态（Nginx 内置的负载均衡算法不支持这种方式，需要进行扩展）。\n如果我们自己开发负载均衡系统，可以根据业务特点来选择指标衡量系统压力。如果是 CPU 密集型，可以以“CPU 负载”来衡量系统压力；如果是 I/O 密集型，可以以“I/O 负载”来衡量系统压力。\n\n\n\n\n性能最优类\n\n负载最低优先类算法是站在服务器的角度来进行分配的，而性能最优优先类算法则是站在客户端的角度来进行分配的，优先将任务分配给处理速度最快的服务器，通过这种方式达到最快响应客户端的目的。\n复杂度\n负载均衡系统需要收集和分析每个服务器每个任务的响应时间，在大量任务处理的场景下，这种收集和统计本身也会消耗较多的性能。\n为了减少这种统计上的消耗，可以采取采样的方式来统计，即不统计所有任务的响应时间，而是抽样统计部分任务的响应时间来估算整体任务的响应时间。采样统计虽然能够减少性能消耗，但使得复杂度进一步上升，因为要确定合适的采样率，采样率太低会导致结果不准确，采样率太高会导致性能消耗较大，找到合适的采样率也是一件复杂的事情。\n无论是全部统计还是采样统计，都需要选择合适的周期：是 10 秒内性能最优，还是 1 分钟内性能最优，还是 5 分钟内性能最优……没有放之四海而皆准的周期，需要根据实际业务进行判断和选择，这也是一件比较复杂的事情，甚至出现系统上线后需要不断地调优才能达到最优设计。\n\n\n\n\nHash类\n\n源地址 Hash：将来源于同一个源 IP 地址的任务分配给同一个服务器进行处理，适合于存在事务、会话的业务。例如，当我们通过浏览器登录网上银行时，会生成一个会话信息，这个会话是临时的，关闭浏览器后就失效。网上银行后台无须持久化会话信息，只需要在某台服务器上临时保存这个会话就可以了，但需要保证用户在会话存在期间，每次都能访问到同一个服务器，这种业务场景就可以用源地址 Hash 来实现。\nID Hash：将某个 ID 标识的业务分配到同一个服务器中进行处理，这里的 ID 一般是临时性数据的 ID（如 session id）。例如，上述的网上银行登录的例子，用 session id hash 同样可以实现同一个会话期间，用户每次都是访问到同一台服务器的目的。\n\n\n\n\n\n5.高可用架构1.CAP理论2.FMEA方法\nFMEA（Failure mode and effects analysis，故障模式与影响分析），FMEA 是一种在各行各业都有广泛应用的可用性分析方法，通过对系统范围内潜在的故障模式加以分析，并按照严重程度进行分类，以确定失效对于系统的最终影响。在软件架构设计领域，FMEA 并不能指导我们如何做架构设计，而是当我们设计出一个架构后，再使用 FMEA 对这个架构进行分析，看看架构是否还存在某些可用性的隐患。\n在架构设计领域，FMEA 的具体分析方法是：\n给出初始的架构设计图。\n假设架构中某个部件发生故障。\n分析此故障对系统功能造成的影响。\n根据分析结果，判断架构是否需要进行优化。\n\n\nFMEA 分析表\n功能点：从用户角度看的，例如登录、注册\n故障模式：系统会出现什么样的故障，包括故障点和故障形式，不需要给出具体原因，只需要给出故障现象，并且尽量精确量化，例如MySQL响应时间达到3秒\n故障影响：当发生故障模式中米哦啊书的故障时，功能点具体会受到什么影响，例如：20%的用户无法登录\n严重程度：站在业务的角度对应的故障的影响程度，一般分为：致命/高/中/低/无，严重程度按照公式（严重程度=功能点重要程度*故障影响范围*功能点受损程度）进行评估，例如：\n致命：超过 70% 用户无法登录。\n高：超过 30% 的用户无法登录。\n中：所有用户登录时间超过 5 秒、所有用户都无法修改资料。\n低：10% 的用户登录时间超过 5 秒、20% 的用户无法修改头像。\n\n\n故障原因：将故障模式未列出的故障原因列出，因为：不同的故障原因发生概率不相同、检测手段和处理措施不一样\n故障概率：某个具体故障原因发生的概率，一般分为：高、中、低三档，要注意如下几点\n硬件：随着使用时间的推移，故障概率会越来越高\n开源系统自研系统：成熟的开源系统bug率低，刚发布的开源系统bug率会高一些\n\n\n风险程度：综合严重程度和故障概率来一起判断某个故障的最终等级（风险程度=严重程度*故障概率），有可能某个故障影响非常严重，但其概率很低，最终来看风险程度就很低\n已有措施：针对具体的故障原因，系统现在是否提供了某些措施来应对，包括检测告警、容错、自恢复等\n规避措施：为了降低故障发生概率而做的一些事情\n技术手段：为了避免MogoDB丢失数据，在MySQL中冗余一份\n管理手段：为了降低磁盘坏道的概率，强制统一更换服务时间超过俩年的磁盘\n\n\n解决措施：为了解决问题而做的一些事情：\n为了解决密码暴力破解，增加密码重试次数限制\n为了解决拖库导致数据泄露，将数据库中的敏感数据加密保存\n为了解决非法访问，增加白名单控制\n\n\n后续规划：综合前面的分析，就可以看出哪些故障我们目前还缺乏对应的措施，哪些已有措施还不够，针对这些不足的地方，再结合风险程度进行排序，给出后续的改进规划。这些规划既可以是技术手段，也可以是管理手段；可以是规避措施，也可以是解决措施。同时需要考虑资源的投入情况，优先将风险程度高的系统隐患解决。例如：\n地震导致机房业务中断：这个故障模式就无法解决，只能通过备份中心规避，尽量减少影响；而机柜断电导致机房业务中断：可以通过将业务机器分散在不同机柜来规避。‘敏感数据泄露：这个故障模式可以通过数据库加密的技术手段来解决。\nMongoDB 断电丢数据：这个故障模式可以通过将数据冗余一份在 MySQL 中，在故障情况下重建数据来规避影响。\n\n\n\n\n\n3.存储高可用架构\n\n\n\n\n\n\n\n\n本质：通过将数据复制到多个存储设备，以数据冗余的方式来实现高可用\n\n双机架构\n\n主备复制\n\n实现：几乎所有存储系统都支持，例如：MySQL、Redis、MongoDB等，内部的后台管理系统使用的多，例如学生管理系统\n\n优点：\n\n对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。\n对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。\n\n\n缺点：\n\n备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。\n故障后需要人工干预，无法自动恢复。\n\n\n\n\n主从复制\n\n实现：写少读多的业务使用的比较多。例如，论坛、BBS、新闻网站这类业务\n\n优点\n\n主从复制在主机故障时，读操作相关的业务可以继续运行。\n主从复制架构的从机提供读操作，发挥了硬件的性能。\n\n\n缺点\n\n客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。\n从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。\n故障时需要人工干预。\n\n\n\n\n双机切换（主备/主从切换）\n\n设计：\n\n系统自动决定主机角色，并完成角色切换\n\n主备间状态判断\n\n状态传递的渠道：是相互间互相连接，还是第三方仲裁？\n状态检测的内容：例如机器是否掉电、进程是否存在、响应是否缓慢等。\n\n\n切换决策\n\n切换时机：什么情况下备机应该升级为主机？是机器掉电后备机才升级，还是主机上的进程不存在就升级，还是主机响应时间超过 2 秒就升级，还是 3 分钟内主机连续重启 3 次就升级等。\n切换策略：原来的主机故障恢复后，要再次切换，确保原来的主机继续做主机，还是原来的主机故障恢复后自动成为新的备机？\n自动程度：切换是完全自动的，还是半自动的？例如，系统判断当前需要切换，但需要人工做最终的确认操作（例如，单击一下“切换”按钮）。\n\n\n数据冲突解决\n​        当原有故障的主机恢复后，新旧主机之间可能存在数据冲突。例如，用户在旧主机上新增了一条 ID 为 100 的数据，这个数据还没有复制到旧的备机，此时发生了切换，旧的备机升级为新的主机，用户又在新的主机上新增了一条 ID 为 100 的数据，当旧的故障主机恢复后，这两条 ID 都为 100 的数据，应该怎么处理？\n\n\n\n常见架构\n\n互连式\n\n实现\n\n缺点：如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。\n\n\n\n中介式\n\n实现\n\n优点\n\n连接管理更简单：主备机无须再建立和管理多种类型的状态传递连接通道，只要连接到中介即可，实际上是降低了主备机的连接管理复杂度。\n状态决策更简单：主备机的状态决策简单了，无须考虑多种类型的连接通道获取的状态信息如何决策的问题，只需要按照下面简单的算法即可完成状态决策。\n无论是主机还是备机，初始状态都是备机，并且只要与中介断开连接，就将自己降级为备机，因此可能出现双备机的情况。\n主机与中介断连后，中介能够立刻告知备机，备机将自己升级为主机。\n如果是网络中断导致主机与中介断连，主机自己会降级为备机，网络恢复后，旧的主机以新的备机身份向中介上报自己的状态。\n如果是掉电重启或者进程重启，旧的主机初始状态为备机，与中介恢复连接后，发现已经有主机了，保持自己备机状态不变。\n主备机与中介连接都正常的情况下，按照实际的状态决定是否进行切换。例如，主机响应时间超过 3 秒就进行切换，主机降级为备机，备机升级为主机即可。\n\n\n\n\n缺点：如果中介自己宕机了，整个系统就进入了双备的状态，写操作相关的业务就不可用了。–Zookeeper已解决\n\n\n\n模拟式\n\n实现：主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态\n\n优点：实现更加简单，因为省去了状态传递通道的建立和管理工作\n\n缺点：模拟式读写操作获取的状态信息只有响应信息（例如，HTTP 404，超时、响应时间超过 3 秒等），没有互连式那样多样（除了响应信息，还可以包含 CPU 负载、I/O 负载、吞吐量、响应时间等），基于有限的状态来做状态决策，可能出现偏差\n\n\n\n\n\n\n\n主主复制\n\n实现：两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作\n\n如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的。主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。例如，用户登录产生的 session 数据（可以重新登录生成）、用户行为的日志数据（可以丢失）、论坛的草稿数据（可以丢失）等\n\n\n\n\n\n集群和分区\n\n数据集群\n\n数据集中集群：数据集中集群与主备、主从这类架构相似，我们也可以称数据集中集群为 1 主多备或者 1 主多从。无论是 1 主 1 从、1 主 1 备，还是 1 主多备、1 主多从，数据都只能往主机中写，而读操作可以参考主备、主从架构进行灵活多变，见Zookeeper的ZAB算法\n\n数据分散集群：数据分散集群指多个服务器组成一个集群，每台服务器都会负责存储一部分数据；同时，为了提升硬件利用率，每台服务器又会备份一部分数据。数据分散集群中的每台服务器都可以处理读写请求，因此不存在数据集中集群中负责写的主机那样的角色。但在数据分散集群中，必须有一个角色来负责执行数据分配算法，这个角色可以是独立的一台服务器，也可以是集群自己选举出的一台服务器。如果是集群服务器选举出来一台机器承担数据分区分配的职责，则这台服务器一般也会叫作主机，但我们需要知道这里的“主机”和数据集中集群中的“主机”，其职责是有差异的。见Hadoop或Elasticsearch\n\n\n\n数据分区\n\n我们需要基于地理级别的故障来设计高可用架构\n\n数据量：数据量越大，分区规则会越复杂\n\n分区规则：地理位置有近有远，因此可以得到不同的分区规则，包括洲际分区、国家分区、城市分区。具体采取哪种或者哪几种规则，需要综合考虑业务范围、成本等因素\n\n复制规则：\n\n集中式：\n\n实现：存在一个总的备份中心，所有的分区都将数据备份到备份中心\n\n优缺点：\n\n设计简单，各分区之间并无直接联系，可以做到互不影响。\n扩展容易，如果要增加第四个分区（例如，武汉分区），只需要将武汉分区的数据复制到西安备份中心即可，其他分区不受影响。\n成本较高，需要建设一个独立的备份中心。\n\n\n\n\n互备式:\n\n实现：互备式备份指每个分区备份另外一个分区的数据\n\n优缺点：\n\n设计比较复杂，各个分区除了要承担业务数据存储，还需要承担备份功能，相互之间互相关联和影响。\n扩展麻烦，如果增加一个武汉分区，则需要修改广州分区的复制指向武汉分区，然后将武汉分区的复制指向北京分区。而原有北京分区已经备份了的广州分区的数据怎么处理也是个难题，不管是做数据迁移，还是广州分区历史数据保留在北京分区，新数据备份到武汉分区，无论哪种方式都很麻烦。\n成本低，直接利用已有的设备。\n\n\n\n\n独立式：\n\n实现：独立式备份指每个分区自己有独立的备份中心、\n\n优缺点：\n\n设计简单，各分区互不影响。\n扩展容易，新增加的分区只需要搭建自己的备份中心即可。\n成本高，每个分区需要独立的备份中心，备份中心的场地成本是主要成本，因此独立式比集中式成本要高很多。\n\n\n\n\n\n\n\n\n\n\n\n4.计算高可用架构\n\n\n\n\n\n\n\n\n通过冗余来规避部分故障的风险，单台服务器是无论如何都达不到这个目标的。所以需要通过增加更多服务器来达到计算高可用\n\n主备\n\n实现\n\n主机执行所有计算任务。例如，读写数据、执行操作等。\n当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务发送给备机，此时系统处于不可用状态。\n如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续将任务发送给主机。\n如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机（即原来的备机）；同时，为了继续保持主备架构，需要人工增加新的机器作为备机。\n\n\n优缺点：主备架构的优点就是简单，主备机之间不需要进行交互，状态判断和切换操作由人工执行，系统实现很简单。而缺点正好也体现在“人工操作”这点上，因为人工操作的时间不可控，可能系统已经发生问题了，但维护人员还没发现，等了 1 个小时才发现。发现后人工切换的操作效率也比较低，可能需要半个小时才完成切换操作，而且手工操作过程中容易出错。例如，修改配置文件改错了、启动了错误的程序等\n\n\n\n主从\n\n实现\n\n正常情况下，主机执行部分计算任务（如图中的“计算任务 A”），备机执行部分计算任务（如图中的“计算任务 B”）。\n当主机故障（例如，主机宕机）时，任务分配器不会自动将原本发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功。\n如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续按照原有的设计策略分配任务，即计算任务 A 发送给主机，计算任务 B 发送给从机。\n如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将原来的从机升级为主机（一般只是修改配置即可），增加新的机器作为从机，新的从机准备就绪后，任务分配器继续按照原有的设计策略分配任务。\n\n\n优缺点：优点：主从架构的从机也执行任务，发挥了从机的硬件性能。缺点：主从架构需要将任务分类，任务分配器会复杂一些。\n\n\n\n集群\n\n对称集群（负载均衡集群）：\n\n正常情况下，任务分配器采取某种策略（随机、轮询等）将计算任务分配给集群中的不同服务器。\n当集群中的某台服务器故障后，任务分配器不再将任务分配给它，而是将任务分配给其他服务器执行。\n当故障的服务器恢复后，任务分配器重新将任务分配给它执行。\n\n\n非对称集群：非对称集群中不同服务器的角色是不同的，不同角色的服务器承担不同的职责。以 Master-Slave 为例，部分任务是 Master 服务器才能执行，部分任务是 Slave 服务器才能执行。\n\n集群会通过某种方式来区分不同服务器的角色。例如，通过 ZAB 算法选举，或者简单地取当前存活服务器中节点 ID 最小的服务器作为 Master 服务器。\n任务分配器将不同任务发送给不同服务器。例如，图中的计算任务 A 发送给 Master 服务器，计算任务 B 发送给 Slave 服务器。\n当指定类型的服务器故障时，需要重新分配角色。例如，Master 服务器故障后，需要将剩余的 Slave 服务器中的一个重新指定为 Master 服务器；如果是 Slave 服务器故障，则并不需要重新分配角色，只需要将故障服务器从集群剔除即可。\n\n\n\n\n\n5.业务高可用架构\n异地多活架构（用来解决系统级故障）\n\n定义：异地就是指地理位置上不同的地方，多活就是不同地理位置的系统都能提供业务服务。例如：共享单车、滴滴出行、支付宝、微信这类业务，需要做异地多活，这类业务系统中断后，对用户的影响很大。\n用途：用来应对系统级的故障，例如机器宕机、机房故障和网络故障等问题\n架构模式：同城异区、跨城异地、跨国异地\n\n\n跨城异地多活设计技巧：\n\n保证核心业务的异地多活\n保证核心数据最终一致性\n采用多种手段同步数据\n只保证绝大部分用户的异地多活\n\n\n跨城异地多活设计流程：\n\n业务分级：按照一定的标准将业务进行分级，挑选出核心的业务，只为核心业务设计异地多活，降低方案整体复杂度和实现成本。常见的分级标准有下面几种：\n\n访问量大的业务\n核心业务\n产生大量收入的业务\n\n\n数据分类：挑选出核心业务后，需要对核心业务相关的数据进一步分析，目的在于识别所有的数据及数据特征，这些数据特征会影响后面的方案设计。常见的数据特征分析维度有：\n\n数据量：这里的数据量包括总的数据量和新增、修改、删除的量\n唯一性：唯一性指数据是否要求多个异地机房产生的同类数据必须保证唯一，数据的唯一性影响业务的多活设计，如果数据不需要唯一，那就说明两个地方都产生同类数据是可能的；如果数据要求必须唯一，要么只能一个中心点产生数据，要么需要设计一个数据唯一生成的算法\n实时性：实时性指如果在 A 机房修改了数据，要求多长时间必须同步到 B 机房\n可丢失性：可丢失性指数据是否可以丢失\n可恢复性：可恢复性指数据丢失后，是否可以通过某种手段进行恢复，如果数据可以恢复，至少说明对业务的影响不会那么大，这样可以相应地降低异地多活架构设计的复杂度\n\n\n数据同步\n\n存储系统同步：这是最常用也是最简单的同步方式。例如，使用 MySQL 的数据主从数据同步、主主数据同步。\n消息队列同步：采用独立消息队列进行数据同步，常见的消息队列有 Kafka、ActiveMQ、RocketMQ 等。消息队列同步适合无事务性或者无时序性要求的数据\n重复生成：数据不同步到异地机房，每个机房都可以生成数据，这个方案适合于可以重复生成的数据。例如，登录产生的 cookie、session 数据、缓存数据等\n\n\n异常处理\n\n多通道同步：多通道同步的含义是采取多种方式来进行数据同步，其中某条通道故障的情况下，系统可以通过其他方式来进行同步，这种方式可以应对同步通道处故障的情况\n\n同步和访问结合：这里的访问指异地机房通过系统的接口来进行数据访问。例如业务部署在异地两个机房 A 和 B，B 机房的业务系统通过接口来访问 A 机房的系统获取账号信息\n\n日志记录：日志记录主要用于用户故障恢复后对数据进行恢复，其主要方式是每个关键操作前后都记录相关一条日志，然后将日志保存在一个独立的地方，当故障恢复后，拿出日志跟数据进行对比，对数据进行修复。常见的日志保存方式有：\n\n服务器上保存日志，数据库中保存数据，这种方式可以应对单台数据库服务器故障或者宕机的情况。\n本地独立系统保存日志，这种方式可以应对某业务服务器和数据库同时宕机的情况。例如，服务器和数据库部署在同一个机架，或者同一个电源线路上，就会出现服务器和数据库同时宕机的情况。\n日志异地保存，这种方式可以应对机房宕机的情况。\n\n\n用户补偿\n\n\n\n\n\n接口级故障\n\n表现为：系统没宕机、网络没中断、但业务却出现问题了，例如业务响应缓慢、大量访问超时和大量访问出现异常\n\n出现原因：\n\n内部原因：程序bug导致死循环、某个接口导致数据库慢查询、程序逻辑不完善导致耗尽内存等\n外部原因：黑客攻击、促销或者抢购引入超出平时几倍甚至几十倍的用户、第三方系统大量请求、第三方系统响应缓慢等\n解决接口级故障的核心思想和异地多活一样：优先保证核心业务、优先保证绝大部分用户\n\n\n常见应对方式：\n\n降级：降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能，常见的实现降级的方式：\n\n系统后门降级：系统提供一个降级URL，当访问这个URL时，就相当于执行降级指令。实现成本低，但需要一台一台去操作\n独立系统降级：将降级操作独立到一个单独的系统中，实现复杂的权限管理、批量操作等功能\n\n\n熔断：按照规则停掉外部接口的访问，防止某些外部接口故障导致自己的系统处理能力急剧下降或者出故障。==降级是应对系统自身的故障，而熔断是应对外部系统故障==。熔断机制有两个关键点：一是需要有一个统一的API调用层，二是阈值的设计\n\n限流：降级是从系统功能优先级的角度考虑如何应对故障，而限流是从用户访问压力的角度来考虑如何应对故障，限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃，常见的限流方式可以分为两类：\n\n基于请求限流：从外部访问的请求角度来考虑限流，常见的方式有两种：\n限制总量：也就是限制某个指标的累计上限\n限制时间量：限制一段时间内某个指标的上限\n\n\n基于资源限流：从内部考虑，找到系统内部影响性能的关键资源，对其使用上限进行限制，常见的内部资源包括连接数、文件句柄、线程数和请求队列\n\n==限流算法==：\n\n时间窗：会限制一定时间窗口内的请求量或者资源消耗量，根据实现方式又可以细分为固定时间窗和滑动时间窗\n桶算法：用一个虚拟的桶来临时存储一些东西，根据桶里面放的东西，又可以细分为漏桶（消息队列）和令牌桶\n\n\n排队：实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间，例如Kafka\n\n\n\n\n\n\n6.分布式数据存储与分析1.大数据技术的来龙去脉\n三架马车和基础设施\n\n存储-GFS\n核心功能：存储数据（分布式文件系统）、并发写入（顺序写入）\n缺陷：缺乏高可用性、“至少一次”的弱一致性\n\n\n计算-MapReduce\n核心功能：数据本地化的并行计算、系统容错和自动恢复\n缺陷：计算模型简单、海量硬盘读写\n\n\n在线服务-Bigtable\n核心功能：在线服务、高性能随机读写、自动调度和分片\n缺陷：缺少Schema、缺少跨行事务\n\n\nChubby锁服务：实现了Paxos算法，保障数据一致性的分布式锁\nThrift序列化：数据怎么序列化、分布式系统之间怎么通信（RPC）\n\n\nOLAP和OLTP数据库\n\nMapReduce的发展方向\n编程模型：通过一门DSL，进一步降低写MapReduce的门槛（Pig、Hive）\n执行引擎：延时高，没法当成交互式系统来给数据分析师使用，于是有了Dremel这个交互式查询引擎的论文，采用数据列存储+并行数据库的方式\n多轮迭代问题：每一个MapReduce都需要读写一次硬盘，浪费了很多的硬盘读写，于是有了Spark，通过把数据放在内存而不是硬盘里，大大提升了分布式数据计算性能\n\n\nBigtable的发展方向\n事务问题和Schema问题，Megastore在Bigtable之上，实现了类SQL的接口，提供了Schema，以及简单的跨行事务，弥补了关系型数据库的特性\n异地多活和跨数据中心问题，Spanner能做到全局一致性\n\n\n\n\n\n实时数据处理的抽象进化\n\n从MapReduce到Dremel，虽然查询数据的时间大大缩短了，但是计算的数据仍然是固定的、预先确定的，这样系统往往有着数分钟到数小时的数据延时，所以为了解决这个问题，流式数据处理就走上了舞台\n流批协同：Lambda架构，S4，Strom\n流批一体：Kappa架构，Kafka\n流式数据处理模型：Dataflow模型，Flink，Apache Beam\n\n\n\n论文脉络\n\n知识地图\n\n具体技术栈\nHadoop\n\n\n\n\n\n\n\n\n分布式文件存储系统\nHDFSYarn\n\n\n\n\n\n\n\n\n资源管理、调度和分配\nMapReduceHive（离线）\n\n\n\n\n\n\n\n\n把SQL语言翻译成MapReduce程序\nSpark（实时）\n\n\n\n\n\n\n\n\n实时通用计算，替代MapReduce\nKafka\n\n\n\n\n\n\n\n\n消息队列，异步、解耦、消峰\nFlink（Kafka2.0?）\n\n\n\n\n\n\n\n\n实时流式计算\n\n\n2.分布式数据存储\nGoogle系\nGFS\nColossus\nBigtable\nChubby\nThrift\nLSM-Tree\n\n\nMegastore\nSpanner\nDapper\nF1\nBorg\n\n\nFaceBook：DynamoDB\nAmazon：Aurora\n\n3.数据分析\nOLAP\nMapReduce\nHive\nDremel\n\n\n流式实时数据处理\nStorm\nS4\nKafka\nKappa Architecture\nDataflow\nFlink\n\n\n\n4.资源调度\nRaft\nBorg\nOmega\nKubernetes\n\n5.新三驾马车\nCaffeine - Towards uniformed representation and acceleration for deep convolutional neural networks\nPregel - A System for Large-Scale Graph Processing\nDremel - Interactive Analysis of Web-Scale Datasets\n\nSpring Family\nSpring Framework\n\n\n\n\n\n\n\n\nSpring是一套项目，其中最核心的是容器模块（modules of the core container），其中包括一个配置模型和一个依赖注入机制。Spring还包括消息传递、事务数据、持久化、和网络（Spring MVC、Spring WebFlux）。\n1.IOC Container1.概述\n原理：进程可以仅通过构造器参数、工厂方法参数、从工厂方法构造或返回对象实例后设置的属性来简单的定义进程的依赖。然后当创建bean的时候容器注入这些依赖。\nBeanFactory：通过 org.springframework.beans 和 org.springframework.context 包实现。BeanFactory接口提供了一种给高级配置机制，能够管理任何类型的对象，ApplicationContext是BeanFactory的子接口，并添加了AOP特性、Event publication、应用层特性上下文（如：WebApplicationContext）\nBean：在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化、组装和管理的对象，否则，bean只是应用程序中的众多对象之一。bean以及bean之间的依赖关系反映在容器使用的配置元数据中。\n\n2.Container\n概述：\n\norg.springframework.context.ApplicationContext接口用于Spring IoC容器并且负责bean的实例化、配置、组装，容器通过读取配置元数据来获取关于要实例化、配置、组装哪些对象的指令。配置元数据可以是XML文件、Java注解、Java代码。\nApplicationContext接口的实现主要有：ClassPathXmlApplicationContext和 FileSystemXmlApplicationContext\n一些概念：\nPOJO：plain old java objects简单的Java对象，一般用在数据层映射到数据库表的类，类的属性与表字段一一对应\nPOJO持久化之后==〉PO，persistent object，增加了一些getter、setter方法\nPOJO传输过程中==〉DTO，data transfer object，比如一张表有100个字段，对应的PO有100个属性，但view层只需要10个字段，所以依靠只有10个属性的DTO来传输数据给client，可以提高性能\nPOJO用作表示层==〉VO，view object，用于页面展示\n\n\nDAO：data access object数据访问对象，用来封装对数据库的访问（CRUD），可以把POJO持久化为PO，用PO组装出VO、DTO\nBO：Business Object，即业务对象。一般用在业务层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递。\ncontroller层：控制请求url用哪个service层逻辑\nservice层：带有业务逻辑的数据访问API\n\n\n\n\n配置元数据：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                           https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;!-- services.xml --&gt;\n    &lt;bean id&#x3D;&quot;petStore&quot; \n          class&#x3D;&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDao&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;itemDao&quot; ref&#x3D;&quot;itemDao&quot;&#x2F;&gt;\n        &lt;!-- additional collaborators and configuration for this bean go here --&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- daos.xml --&gt;\n     &lt;bean id&#x3D;&quot;accountDao&quot;\n        class&#x3D;&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;\n        &lt;!-- additional collaborators and configuration for this bean go here --&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;itemDao&quot; \n          class&#x3D;&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;\n        &lt;!-- additional collaborators and configuration for this bean go here --&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- more bean definitions for data access objects go here --&gt;    \n\n&lt;&#x2F;beans&gt;\n安装容器：ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);，将配置文件加载到一起的方法：\n&lt;beans&gt;\n    &lt;import resource&#x3D;&quot;services.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;resources&#x2F;messageSource.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;&#x2F;resources&#x2F;themeSource.xml&quot;&#x2F;&gt;\n\n    &lt;bean id&#x3D;&quot;bean1&quot; class&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;bean2&quot; class&#x3D;&quot;...&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n使用容器：后者使用@Autowired注解进行依赖注入\n&#x2F;&#x2F; create and configure beans\nApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);\n\n&#x2F;&#x2F; retrieve configured instance\nPetStoreService service &#x3D; context.getBean(&quot;petStore&quot;, PetStoreService.class);\n\n&#x2F;&#x2F; use configured instance\nList&lt;String&gt; userList &#x3D; service.getUsernameList();\n\n3.Bean\n概述：bean定义：包限定类名、行为方式（范围、生命周期回调）、依赖的其它bean的引用、其他配置（池的大小限制、管理连接池的bean中使用的连接数）\n\n\n\nProperty\nExplained in…\n\n\n\nClass\nInstantiating Beans\n\n\nName\nNaming Beans\n\n\nScope\nBean Scopes\n\n\nConstructor arguments\nDependency Injection\n\n\nProperties\nDependency Injection\n\n\nAutowiring mode\nAutowiring Collaborators\n\n\nLazy initialization mode\nLazy-initialized Beans\n\n\nInitialization method\nInitialization Callbacks\n\n\nDestruction method\nDestruction Callbacks\n\n\n\n命名bean（Naming Beans）\n\n一个bean只有一个标识符，且必须在容器中是唯一的，如果需要其他的标识符，则被认为是别名（aliases），xml文件中用id属性标识，用name属性指定别名，命名规则为小写字母开头和驼峰命名\n在别处指定别名&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;\n\n\n实例化bean（Instantiating Beans）\n\nbean定义本质上是创建一个或多个对象的方法，当被访问到时，容器会查看bean的命名和定义来创建实际对象（class属性对应的类）\n\n通过构造器实例化：当使用构造方法创建bean时，所有普通类都可以被Spring使用并兼容（一般为仅有默认空参构造和gettet、setter方法的类），正在开发的类不需要实现任何特定的接口或以特定的方式进行编码，只需指定bean类就足够了，但根据该特定bean的IoC类型需要一个默认空参的构造方法\n\n通过静态工厂方法实例化：在定义使用静态工厂方法从创建的bean时，使用class属性来指定包含静态工厂方法的类，并使用名为factory-method的属性来指定工厂方法本身的名称。这种bean定义的用途之一是在遗留代码中调用静态工厂\n\nxml配置：&lt;bean id=&quot;clientService&quot;    class=&quot;examples.ClientService&quot;    factory-method=&quot;createInstance&quot;/&gt;\n\n使用：一个可与上面的bean定义一起工作的类\npublic class ClientService &#123;\n    private static ClientService clientService &#x3D; new ClientService();\n    private ClientService() &#123;&#125;\n\n    public static ClientService createInstance() &#123;\n        return clientService;\n    &#125;\n&#125;\n\n\n通过实例工厂方法实例化：与通过静态工厂方法进行实例化类似，使用实例工厂方法进行实例化从容器中调用现有bean的非静态方法来创建新bean。class属性需要为空，并在factory-bean属性中指定当前（或父级或祖先）容器中的bean名称（包含要调用以创建对象的实例方法），使用factory-method属性设置工厂方法本身的名称\n\nxml文件\n&lt;!-- the factory bean, which contains a method called createInstance() --&gt;\n&lt;bean id&#x3D;&quot;serviceLocator&quot; class&#x3D;&quot;examples.DefaultServiceLocator&quot;&gt;\n    &lt;!-- inject any dependencies required by this locator bean --&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;clientService&quot;\n    factory-bean&#x3D;&quot;serviceLocator&quot;\n    factory-method&#x3D;&quot;createClientServiceInstance&quot;&#x2F;&gt;\n\n&lt;bean id&#x3D;&quot;accountService&quot;\n    factory-bean&#x3D;&quot;serviceLocator&quot;\n    factory-method&#x3D;&quot;createAccountServiceInstance&quot;&#x2F;\n相关类：\npublic class DefaultServiceLocator &#123;\n\n    private static ClientService clientService &#x3D; new ClientServiceImpl();\n    private static AccountService accountService &#x3D; new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() &#123;\n        return clientService;\n    &#125;\n\n    public AccountService createAccountServiceInstance() &#123;\n        return accountService;\n    &#125;\n&#125;\n\n\n确定bean的运行时类型：对指定bean名称的BeanFactory.getType调用\n\n\n\n\n4.Dpendencies\n\n\n\n\n\n\n\n\n如何从多个独立的bean定义到完全实现的应用程序\n\n依赖注入\n\n定义：通过定义需要的依赖，并将这些依赖注入到bean中，这个过程是直接构造实例的逆过程。可以使得代码更简洁，更方便测试。对强制依赖项使用构造函数，对可选依赖使用setter方法。\n\n基于构造器的依赖注入：通过容器调用具有多个参数的构造函数来完成，每个参数代表一个依赖项，构造器可以有多个参数，&lt;constructor-arg ....../&gt;\n\nxml\n&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;\n    &lt;!-- constructor injection using the nested ref element --&gt;\n    &lt;constructor-arg&gt;\n        &lt;ref bean&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;\n    &lt;&#x2F;constructor-arg&gt;\n    &lt;!-- constructor injection using the neater ref attribute --&gt;\n    &lt;constructor-arg ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;\n    &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;anotherExampleBean&quot; class&#x3D;&quot;examples.AnotherBean&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;yetAnotherBean&quot; class&#x3D;&quot;examples.YetAnotherBean&quot;&#x2F;&gt;\njava\npublic class ExampleBean &#123;\n\n    private AnotherBean beanOne;\n    private YetAnotherBean beanTwo;\n    private int i;\n\n    public ExampleBean(\n        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;\n        this.beanOne &#x3D; anotherBean;\n        this.beanTwo &#x3D; yetAnotherBean;\n        this.i &#x3D; i;\n    &#125;\n&#125;\n\n\n基于Setter的依赖注入：是通过容器在调用无参构造函数来实例化bean后调用bean上的settet方法来完成的\n\nxml\n&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;\n    &lt;!-- setter injection using the nested ref element --&gt;\n    &lt;property name&#x3D;&quot;beanOne&quot;&gt;\n        &lt;ref bean&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;\n    &lt;&#x2F;property&gt;\n    &lt;!-- setter injection using the neater ref attribute --&gt;\n    &lt;property name&#x3D;&quot;beanTwo&quot; ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;integerProperty&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;anotherExampleBean&quot; class&#x3D;&quot;examples.AnotherBean&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;yetAnotherBean&quot; class&#x3D;&quot;examples.YetAnotherBean&quot;&#x2F;&gt;\njava\npublic class ExampleBean &#123;\n\n    private AnotherBean beanOne;\n    private YetAnotherBean beanTwo;\n    private int i;\n\n    public void setBeanOne(AnotherBean beanOne) &#123;\n        this.beanOne &#x3D; beanOne;\n    &#125;\n\n    public void setBeanTwo(YetAnotherBean beanTwo) &#123;\n        this.beanTwo &#x3D; beanTwo;\n    &#125;\n\n    public void setIntegerProperty(int i) &#123;\n        this.i &#x3D; i;\n    &#125;\n&#125;\n\n\n一般都用xml、注解（@controller、@Component）、@Bean，\n\n\n\n依赖注入处理流程：\n\n通过所有bean的元数据的描述构造并初始化ApplicationContext\n对每一个bean，它的依赖关系以属性、构造函数或静态工厂方法的参数的形式表示，并在实际创建bean时提供给bean\n每个属性或构造函数参数都是要设置的值的实际定义，或是对容器中另一个bean的引用\n作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型\n\n\n其他细节\n\nStraight Values（原语、字符串） &lt;property/&gt; 的value属性\n&lt;bean id&#x3D;&quot;myDataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;\n    &lt;!-- results in a setDriverClassName(String) call --&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;misterkaoli&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n内嵌bean\n&lt;bean id&#x3D;&quot;outer&quot; class&#x3D;&quot;...&quot;&gt;\n    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;\n    &lt;property name&#x3D;&quot;target&quot;&gt;\n        &lt;bean class&#x3D;&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;\n            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Fiona Apple&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n集合\n\nP命名空间、C命名空间\n\n\n\n延迟初始化bean：单例bean常常会很早初始化，当不需要提前初始化bean来验证错误时，可以将bean定义标记为延迟初始化来防止单例bean的预实例化。lazy bean不会被太早实例化，not.lazy bean会被很早实例化\n&lt;bean id&#x3D;&quot;lazy&quot; class&#x3D;&quot;com.something.ExpensiveToCreateBean&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean name&#x3D;&quot;not.lazy&quot; class&#x3D;&quot;com.something.AnotherBean&quot;&#x2F;&gt;\n自动装配\n\n自动装配的四种模式\nno：不自动装配，bean引用必须有ref元素定义\nbyName：按属性名自动装配，Spring寻找与需要自动装配的属性同名的bean，例如有setMaster()方法的bean会去找名为master的bean定义\nbyType：如果容器中恰好存在一个属性类型的bean，则让属性自动装配；如果存在多个，则需要使用byType自动装配\nconstructor：与byType类似，但适用于构造函数参数，如果容器中没有一个构造函数参数类型的bean，则会引发致命错误\n\n\n推荐在项目中一直使用自动装配，否则会混淆，自动装配设施无法使用注释样式配置，例如@Autowired\n\n\n\n5.Bean Scopes\n概览：后四个仅在web相关的Spring ApplicationContext生效\n\n\n\nScope\nDescription\n\n\n\nsingleton\n(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.\n\n\nprototype\nScopes a single bean definition to any number of object instances.\n\n\nrequest\nScopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition.\n\n\nsession\nScopes a single bean definition to the lifecycle of an HTTP Session.\n\n\napplication\nScopes a single bean definition to the lifecycle of a ServletContext.\n\n\nwebsocket\nScopes a single bean definition to the lifecycle of a WebSocket.\n\n\n\nsingleton：&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;\n\nprototype：&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;\n\nweb相关：\n\n初始化配置\n&lt;!--启动服务器时，通过监听器加载spring运行环境--&gt;\n  &lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n  &lt;&#x2F;listener&gt;\n&lt;!--将HTTP请求对象绑定到为该请求提供服务的线程--&gt;\n  &lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n  &lt;&#x2F;filter&gt;\n  &lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;filter-mapping&gt;\n通过注解来定义scope\n\n\n\n\n6.Container Extension Points\n\n\n\n\n\n\n\n\nSpring可以通过插入特殊集成接口的实现来扩展IoC容器\n\nBeanPostProcessor\n\n通过实现其提供的回调方法，来提供定制的实例化逻辑、依赖解析逻辑。可以在Spring容器完成实例化、配置和初始化bean之后，BeanPostProcessor实例开始进行自己的工作\npublic interface BeanPostProcessor &#123;\n    @Nullable\n    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;return bean;&#125;\n    @Nullable\n    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;return bean;&#125;\n&#125;\nAOP自动代理就是BeanPostProcessor的实现，在系统启动的时候就全加载好\n\n使用：通过实现BeanPostProcessor接口的方法，并注册成bean，来在其它bean初始化的前后进行定制操作，一个例子是：Spring的实现类AutowiredAnnotationBeanPostProcessor\n\n\n\nBeanFactoryPostProcessor\n\n与BeanPostProcessor的一个主要区别是BeanFactoryPostProcessor对bean配置元数据进行操作，也就是说IoC容器允许BeanFactoryPostProcessor读取配置元数据，并可能在容器实例化除BeanFactoryPostProcessor实例之外的任何bean之前更改它\n\nSpring中预定义的：\n\nPropertyOverrideConfigurer\n\nPropertySourcesPlaceholderConfigurer：可以使用标准Java属性格式将bean定义中的属性值外化到单独的文件中，例如可以不用改xml就可以自定义数据库的URL和密码。在运行时，PropertySourcesPlaceholderConfigurer应用于替换DataSource的某些属性的元数据，真实值来自外部的jdbc.properties文件\n&lt;!--加载properties文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath*:jdbc.properties&quot;&#x2F;&gt;\n&lt;!--数据源--&gt;\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n\nFactoryBean\n\n\n7.基于注解的容器配置\n可以将post-processor注册为单独的bean，也可以在xml中加&lt;context:annotation-config/&gt;，这个元素隐式注册了：\n\nConfigurationClassPostProcessor\nAutowiredAnnotationBeanPostProcessor\nCommonAnnotationBeanPostProcessor\nPersistenceAnnotationBeanPostProcessor\nEventListenerMethodProcessor\n\n\n@Required：用于bean属性setter方法，相关属性必须通过bean定义中显示属性值或自动装配来填充。（需要提前将RequiredAnnotationBeanPostProcessor注册为bean），Spring5.1弃用\npublic class SimpleMovieLister &#123;\n    private MovieFinder movieFinder;\n    @Required\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n@Autowired：原理见自动装配\n\n用在构造函数上，Spring4.3开始不再需要，但如果有多个构造函数则需要使用\npublic class MovieRecommender &#123;\n    private final CustomerPreferenceDao customerPreferenceDao;\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n用于传统的setter方法：\npublic class SimpleMovieLister \n    private MovieFinder movieFinder;\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n用于字段，甚至可以将其与构造函数混用\npublic class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n    @Autowired\n    private MovieCatalog movieCatalog;\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n\n\n@Primary表示当多个bean成为自动装配的候选者时，应该优先考虑特定的bean\n@Configuration\npublic class MovieConfiguration &#123;\n\n    @Bean\n    @Primary\n    public MovieCatalog firstMovieCatalog() &#123; ... &#125;\n\n    @Bean\n    public MovieCatalog secondMovieCatalog() &#123; ... &#125;\n    &#x2F;&#x2F; ...\n&#125;\npublic class MovieRecommender &#123;\n\t&#x2F;&#x2F;自动装配firstMovieCatalog\n    @Autowired\n    private MovieCatalog movieCatalog;\n    &#x2F;&#x2F; ...\n&#125;\n@Qualifier：可以将限定符值与特定参数相关联，缩小类型匹配的范围，以便为每个参数选择特定的bean：\npublic class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog,\n                        CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog &#x3D; movieCatalog;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n@Resource：采用名称属性，默认将该值解释为要注入的bean名称，如果没有明确指定名称，如果是字段，则采用字段名称，如果是setter方法，则采用bean属性名称\npublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n    @Resource(name&#x3D;&quot;myMovieFinder&quot;) \n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n&#125;\n@Value：通常用于注入外部化属性\n@Component\npublic class MovieRecommender &#123;\n\n    private final String catalog;\n    &#x2F;&#x2F;application.properties中有catalog.name&#x3D;MovieCatalog\n    &#x2F;&#x2F;catalog的值就为MovieCatalog\n    public MovieRecommender(@Value(&quot;$&#123;catalog.name&#125;&quot;) String catalog) &#123;\n        this.catalog &#x3D; catalog;\n    &#125;\n&#125;\n&#x2F;&#x2F;还需以下配置\n@Configuration\n@PropertySource(&quot;classpath:application.properties&quot;)\npublic class AppConfig &#123; &#125;\n@PostConstruct&amp;@PreDestroy\npublic class CachingMovieLister &#123;\n\n    @PostConstruct\n    public void populateMovieCache() &#123;\n        &#x2F;&#x2F; populates the movie cache upon initialization...\n    &#125;\n\n    @PreDestroy\n    public void clearMovieCache() &#123;\n        &#x2F;&#x2F; clears the movie cache upon destruction...\n    &#125;\n&#125;\n\n8.基于Java的容器配置\n@Compoent：\n\n任何满足存储库角色（DAO）的类的标记，用途是异常的自动翻译，类似的其它原型注解有：@Controller（表示层）、@Service（服务层）、@Repository（持久层），尽量不选@Component而选后面那三个\n\nSpring能自动检测原型类，并使用ApplicationContext注册相应的BeanDefinition实例，要自动检测这些类并注册相应的bean，需要将@ComponentScan(basePackages = &quot;org.example&quot;)添加到@Configuration类中\n\n用@Component定义bean元数据：将bean定义元数据贡献给容器\n@Component\npublic class FactoryMethodComponent &#123;\n    @Bean\t&#x2F;&#x2F;表示工厂方法和其它bean定义属性\n    @Qualifier(&quot;public&quot;)\n    public TestBean publicInstance() &#123;\n        return new TestBean(&quot;publicInstance&quot;);\n    &#125;\n\n    public void doWork() &#123;\n        &#x2F;&#x2F; Component method implementation omitted\n    &#125;\n&#125;\n\n\n@Configuration\n\n用@Configuration注释一个类表明一个对象时bean定义的来源，此外，Configuration类允许通过调用同一类中的其它@Bean方法来定义bean间的依赖关系\n@Configuration\npublic class AppConfig &#123;\n    @Bean\n    public MyService myService() &#123;\n        return new MyServiceImpl();\n    &#125;\n&#125;\n&#x2F;&#x2F;与下面xml语句相同：\n&#x2F;&#x2F;&lt;beans&gt;\n&#x2F;&#x2F;    &lt;bean id&#x3D;&quot;myService&quot; class&#x3D;&quot;com.acme.services.MyServiceImpl&quot;&#x2F;&gt;\n&#x2F;&#x2F;&lt;&#x2F;beans&gt;\n当@Configuration类作为输入提供时，@Configuration类本身被注册为bean定义，并且类中所有声明的@Bean方法也被注册为bean定义，使用AnnotationConfigApplicationContext访问\npublic static void main(String[] args) &#123;\n    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n    MyService myService &#x3D; ctx.getBean(MyService.class);\n    myService.doStuff();\n&#125;\n\n\n\n@Bean\n\n用于表示一个方法实例化、配置和初始化一个由IoC容器管理的新对象，与&lt;beans/&gt;元素的作用相同。可以使用此方法来制定为方法返回值的类型的ApplicationContext中注册bean定义。可以和任何Spring的@Component一起使用，但是通常与@Configurationbean一起使用。\n@Configuration\npublic class AppConfig &#123;\n    @Bean&#x2F;&#x2F;默认情况，bean名称与方法名称相同\n    public TransferServiceImpl transferService() &#123;\n        return new TransferServiceImpl();\n    &#125;\n    &#x2F;&#x2F;可以有任意数量的参数来描述构建该bean所需的依赖项\n    &#x2F;&#x2F;@Bean\n    &#x2F;&#x2F; public TransferService transferService(AccountRepository accountRepository) &#123;\n    &#x2F;&#x2F;     return new TransferServiceImpl(accountRepository);\n    &#x2F;&#x2F;&#125;\n&#125;\n\n\n@Import：\n\n从另一个配置类加载@Bean定义：\n@Configuration\npublic class ServiceConfig &#123;\n    @Bean\n    public TransferService transferService(AccountRepository accountRepository) &#123;\n        return new TransferServiceImpl(accountRepository);\n    &#125;\n&#125;\n@Configuration\npublic class RepositoryConfig &#123;\n    @Bean\n    public AccountRepository accountRepository(DataSource dataSource) &#123;\n        return new JdbcAccountRepository(dataSource);\n    &#125;\n&#125;\n@Configuration\n@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)\npublic class SystemTestConfig &#123;\n    @Bean\n    public DataSource dataSource() &#123;\n        &#x2F;&#x2F; return new DataSource\n    &#125;\n&#125;\npublic static void main(String[] args) &#123;\n    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SystemTestConfig.class);\n    &#x2F;&#x2F; everything wires up across configuration classes...\n    TransferService transferService &#x3D; ctx.getBean(TransferService.class);\n    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);\n&#125;\n自动装配\n@Configuration\npublic class ServiceConfig &#123;\n    @Autowired\n    private AccountRepository accountRepository;\n    @Bean\n    public TransferService transferService() &#123;\n        return new TransferServiceImpl(accountRepository);\n    &#125;\n&#125;\n\n@Configuration\npublic class RepositoryConfig &#123;\n    &#x2F;&#x2F;bean仅定义一个构造函数，则无需指定指定@Autowired\n    private final DataSource dataSource;\n    public RepositoryConfig(DataSource dataSource) &#123;\n        this.dataSource &#x3D; dataSource;\n    &#125;\n    @Bean\n    public AccountRepository accountRepository() &#123;\n        return new JdbcAccountRepository(dataSource);\n    &#125;\n&#125;\n@Configuration\n@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)\npublic class SystemTestConfig &#123;\n    @Bean\n    public DataSource dataSource() &#123;\n        &#x2F;&#x2F; return new DataSource\n    &#125;\n&#125;\npublic static void main(String[] args) &#123;\n    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SystemTestConfig.class);\n    &#x2F;&#x2F; everything wires up across configuration classes...\n    TransferService transferService &#x3D; ctx.getBean(TransferService.class);\n    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);\n&#125;\n\n\n\n2.AOP\n\n\n\n\n\n\n\n\n面向切面编程通过提供另一种思考程序结构的方式来补充面向对象编程，提供了中间件解决方案\n1.概念\nAspect：跨多个类的关注点的模块化，例如事务管理\nJoin point：程序执行过程中的一个点，例如方法的执行和异常的处理\nAdvice：Aspect在特定的Join point采取的行动，包括around、before、after（running、throwing、finally）\npointcut：匹配连接点的谓词，Advice和pointcut表达式相关联，并在任何与pointcut匹配的join point运行，例如执行具有特定名称的方法\nIntroduction：代表一个类型声明额外的方法或字段，例如可以使用introduction让bean实现isModified接口，来简化缓存\nTarget object：An object being advised by one or more aspects，即被代理对象\nAOP proxy：由AOP框架创建的对象，用于实现aspect\nWeaving：将apsects和其他应用程序类型或对象链接以创建建议对象\n\n2.@AspectJ\n配置启用@AspectJ支持\n@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig &#123;\n\n&#125;\n声明一个切面（aspect）\n@Aspect\npublic class NotVeryUsefulAspect &#123;\n\n&#125;\n声明一个切点（pointcut），有很多方式，详见文档\n&#x2F;&#x2F;名为anyOldTransfer的切入点，与任何名为transfer的方法执行相匹配\n@Pointcut(&quot;execution(* transfer(..))&quot;) &#x2F;&#x2F; the pointcut expression\nprivate void anyOldTransfer() &#123;&#125; &#x2F;&#x2F; the pointcut signature\n声明一个建议（advice）\n@Aspect\npublic class BeforeExample &#123;\n    @Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)\n    public void doAccessCheck() &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n@Aspect\npublic class AfterReturningExample &#123;\n    @AfterReturning(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)\n    public void doAccessCheck() &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n@Aspect\npublic class AroundExample &#123;\n    @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;)\n    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;\n        &#x2F;&#x2F; start stopwatch\n        Object retVal &#x3D; pjp.proceed();\n        &#x2F;&#x2F; stop stopwatch\n        return retVal;\n    &#125;\n&#125;\n例子\n@Aspect\npublic class ConcurrentOperationExecutor implements Ordered &#123;\n\n    private static final int DEFAULT_MAX_RETRIES &#x3D; 2;\n\n    private int maxRetries &#x3D; DEFAULT_MAX_RETRIES;\n    private int order &#x3D; 1;\n\n    public void setMaxRetries(int maxRetries) &#123;\n        this.maxRetries &#x3D; maxRetries;\n    &#125;\n\n    public int getOrder() &#123;\n        return this.order;\n    &#125;\n\n    public void setOrder(int order) &#123;\n        this.order &#x3D; order;\n    &#125;\n\n    @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;)\n    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;\n        int numAttempts &#x3D; 0;\n        PessimisticLockingFailureException lockFailureException;\n        do &#123;\n            numAttempts++;\n            try &#123;\n                return pjp.proceed();\n            &#125;\n            catch(PessimisticLockingFailureException ex) &#123;\n                lockFailureException &#x3D; ex;\n            &#125;\n        &#125; while(numAttempts &lt;&#x3D; this.maxRetries);\n        throw lockFailureException;\n    &#125;\n&#125;\n\n3.Data Access1.Transaction Management\n事务抽象，其余的去实现如下方法\n\nimperative transaction management \npublic interface PlatformTransactionManager extends TransactionManager &#123;\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n    void commit(TransactionStatus status) throws TransactionException;\n    void rollback(TransactionStatus status) throws TransactionException;\n&#125;\nreactive transaction management\npublic interface ReactiveTransactionManager extends TransactionManager &#123;\n    Mono&lt;ReactiveTransaction&gt; getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n    Mono&lt;Void&gt; commit(ReactiveTransaction status) throws TransactionException;\n    Mono&lt;Void&gt; rollback(ReactiveTransaction status) throws TransactionException;\n&#125;\n\n\n声明式事务管理（Declarative）\n\n开启事务注解的方式：@EnableTransactionManagement\n@Transactional：\ntransactionManager\n==propagation==\nisolation\ntimeout\nreadOnly\n\n\n\n\n编程式事务管理（Programmatic）\n\nTransactionTemplate\n\nTransactionCallback\nTransactionCallbackWithoutResult\n\n@SpringBootApplication\n@Slf4j\npublic class ProgrammaticTransactionDemoApplication implements CommandLineRunner &#123;\n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n    public static void main(String[] args) &#123;\n        SpringApplication.run(ProgrammaticTransactionDemoApplication.class, args);\n    &#125;\n    @Override\n    public void run(String... args) throws Exception &#123;\n        transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;\n            @Override\n            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123;\n                jdbcTemplate.execute(&quot;INSERT INTO FOO (ID, BAR) VALUES (1, &#39;aaa&#39;)&quot;);\n                transactionStatus.setRollbackOnly();\n            &#125;\n        &#125;);\n    &#125;\n&#125;\nTransactionOperation\n\nPlatformTransactionManager\n\n可以传入TransactionDefinition进行定义\n\n\n\n\n\n2.JDBC\n包层次结构\n\norg.springframework.jdbc.core：JdbcTemplate、simple子包中simpleJdbcInsert、SimpleJdbcCall类、namedparam子包中NamedParameterJdbcTemplate\norg.springframework.jdbc.datasource：DataSource类、embedded子包中内嵌数据库的支持（HSQL、H2、Derby）\norg.springframework.jdbc.object：关系数据库的查询、更新、存储程序\norg.springframework.jdbc.support：SQLException、一些工具类\n\n\nJDBC Processing\n\nJdbcTemplate\n\n可以处理资源的创建和释放，主要用于运行数据库的查询、更新、存储，对ResultSet实例执行迭代并提取返回的参数值，捕获JDBC异常并翻译成通用的。方法有：query、queryForObject、queryForList、update、execute\n\nQuerying\n&#x2F;&#x2F;返回整数\nint countOfActorsNamedJoe &#x3D; this.jdbcTemplate.queryForObject(\n        &quot;select count(*) from t_actor where first_name &#x3D; ?&quot;, Integer.class, &quot;Joe&quot;);\n&#x2F;&#x2F;返回String\nString lastName &#x3D; this.jdbcTemplate.queryForObject(\n        &quot;select last_name from t_actor where id &#x3D; ?&quot;,String.class, 1212L);\n&#x2F;&#x2F;返回 single domain对象\nActor actor &#x3D; jdbcTemplate.queryForObject(\n        &quot;select first_name, last_name from t_actor where id &#x3D; ?&quot;,\n        (resultSet, rowNum) -&gt; &#123;\n            Actor newActor &#x3D; new Actor();\n            newActor.setFirstName(resultSet.getString(&quot;first_name&quot;));\n            newActor.setLastName(resultSet.getString(&quot;last_name&quot;));\n            return newActor;\n        &#125;,\n        1212L);\n&#x2F;&#x2F;返回链表\nList&lt;Actor&gt; actors &#x3D; this.jdbcTemplate.query(\n        &quot;select first_name, last_name from t_actor&quot;,\n        (resultSet, rowNum) -&gt; &#123;\n            Actor actor &#x3D; new Actor();\n            actor.setFirstName(resultSet.getString(&quot;first_name&quot;));\n            actor.setLastName(resultSet.getString(&quot;last_name&quot;));\n            return actor;\n        &#125;);\nUpdating\n&#x2F;&#x2F;插入\nthis.jdbcTemplate.update(\n        &quot;insert into t_actor (first_name, last_name) values (?, ?)&quot;,\n        &quot;Leonor&quot;, &quot;Watling&quot;);\n&#x2F;&#x2F;更新\nthis.jdbcTemplate.update(\n        &quot;update t_actor set last_name &#x3D; ? where id &#x3D; ?&quot;,\n        &quot;Banjo&quot;, 5276L);\n&#x2F;&#x2F;删除\nthis.jdbcTemplate.update(\n        &quot;delete from t_actor where id &#x3D; ?&quot;,\n        Long.valueOf(actorId));\nexecute可执行一切SQL语句：this.jdbcTemplate.execute(&quot;create table mytable (id integer, name varchar(100))&quot;);\n\n最佳实践\n@Repository \npublic class JdbcCorporateEventDao implements CorporateEventDao &#123;\n    private JdbcTemplate jdbcTemplate;\n    @Autowired \n    public void setDataSource(DataSource dataSource) &#123;\n        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource); \n    &#125;\n    \n    public void doExecute() &#123;\n        this.jdbcTemplate.execute(\n            &quot;create table mytable (id integer, name varchar(100))&quot;);\n    &#125;\n    \n    public int getCount() &#123;\n        return this.jdbcTemplate.queryForObject(\n            &quot;select count(*) from mytable&quot;, Integer.class);\n    &#125;\n&#125;\n&#x2F;&#x2F;取回自动递增的key\nfinal String INSERT_SQL &#x3D; &quot;insert into my_test (name) values(?)&quot;;\nfinal String name &#x3D; &quot;Rob&quot;;\nKeyHolder keyHolder &#x3D; new GeneratedKeyHolder();\njdbcTemplate.update(connection -&gt; &#123;\n    PreparedStatement ps &#x3D; connection.prepareStatement(INSERT_SQL, new String[] &#123; &quot;id&quot; &#125;);\n    ps.setString(1, name);\n    return ps;\n&#125;, keyHolder);\n&#x2F;&#x2F; keyHolder.getKey() now contains the generated key\n\n\nNamedParameterJdbcTemplate：对JdbcTemplate的一层封装，简化有参数的SQL\n\nSQLExceptionTranslator：翻译SQLException和org.sf.dao.DataAccessException的接口，其中一个默认实现是SQLErrorCodeSQLExceptionTranslator，可以解析错误码。Spring会将数据操作的异常转换为DataAccessException，无论使用何种数据访问方式，都能使用一样的异常\npublic class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator &#123;\n\n    protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) &#123;\n        if (sqlEx.getErrorCode() &#x3D;&#x3D; -12345) &#123;\n            return new DeadlockLoserDataAccessException(task, sqlEx);\n        &#125;\n        return null;\n    &#125;\n&#125;\n&#x2F;&#x2F;注入方法：\nCustomSQLErrorCodesTranslator tr &#x3D; new CustomSQLErrorCodesTranslator();\nthis.jdbcTemplate.setExceptionTranslator(tr);\n\n\nDatabase Connections\n\nDataSource：\n\n连接工厂，使得一个容器或者一个框架从应用代码中隐藏连接池和事务管理问题，业务开发人员不再需要知道连接数据库的信息。\n\n如果是JDBC，那么可以通过JNDI（通过配置而不是放在一起的单一url）来获得数据源；也可以配置数据库连接池（HikariCP/druid）。\n\nHikariCP：Spring原生支持，性能强，字节码级别优化、大量小改进，但功能少。相关配置见文档：https://github.com/brettwooldridge/HikariCP\ndruid：功能多，内置强大的监控功能，SQL放注入，内置加密配置。相关配置见文档https://github.com/alibaba/druid/wiki/FAQ\n\n\nDriverManagerDataSource和SimpleDriverDataSource仅应该用在测试的时候：\nDriverManagerDataSource dataSource &#x3D; new DriverManagerDataSource();\ndataSource.setDriverClassName(&quot;org.hsqldb.jdbcDriver&quot;);\ndataSource.setUrl(&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:&quot;);\ndataSource.setUsername(&quot;sa&quot;);\ndataSource.setPassword(&quot;&quot;);\n\n\nDataSourceUtils：提供一些静态方法去从JNDI获得连接和关闭连接，支持线程绑定的连接，比如DataSourceTransactionManager\n\n配置多数据源（二选一）\n\n配置@Primary类型的Bean\n\n排除SpringBoot的三个自动配置类，自己实现相关配置\n@Bean\n@ConfigurationProperties(&quot;foo.datasource&quot;)\npublic DataSourceProperties fooDataSourceProperties() &#123;\n    return new DataSourceProperties();\n&#125;\n\n@Bean\npublic DataSource fooDataSource() &#123;\n    DataSourceProperties dataSourceProperties &#x3D; fooDataSourceProperties();\n    log.info(&quot;foo datasource: &#123;&#125;&quot;, dataSourceProperties.getUrl());\n    return dataSourceProperties.initializeDataSourceBuilder().build();\n&#125;\n\n@Bean\n@Resource\npublic PlatformTransactionManager fooTxManager(DataSource fooDataSource) &#123;\n    return new DataSourceTransactionManager(fooDataSource);\n&#125;\n\n\n\n\nBatch Operations：通过组织成批处理，可以限制与数据库的连接往返次数\n\n通过实现BatchPreparedStatementSetter接口的setValues和getBatchSize方法来实现，通过InterruptibleBatchPreparedStatementSetter来在输入用完的时候中断一个批处理\npublic class JdbcActorDao implements ActorDao &#123;\n    private JdbcTemplate jdbcTemplate;\n    \n    public void setDataSource(DataSource dataSource) &#123;\n        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);\n    &#125;\n\n    public int[] batchUpdate(final List&lt;Actor&gt; actors) &#123;\n        return this.jdbcTemplate.batchUpdate(\n                &quot;update t_actor set first_name &#x3D; ?, last_name &#x3D; ? where id &#x3D; ?&quot;,\n                new BatchPreparedStatementSetter() &#123;\n                    &#x2F;&#x2F;给准备好的语句传递参数\n                    public void setValues(PreparedStatement ps, int i) throws SQLException &#123;\n                        Actor actor &#x3D; actors.get(i);\n                        ps.setString(1, actor.getFirstName());\n                        ps.setString(2, actor.getLastName());\n                        ps.setLong(3, actor.getId().longValue());\n                    &#125;\n                    &#x2F;&#x2F;batch的尺寸\n                    public int getBatchSize() &#123;\n                        return actors.size();\n                    &#125;\n                &#125;);\n    &#125;\n&#125;\nNamedParameterJdbcTemplate\npublic class JdbcActorDao implements ActorDao &#123;\n    private NamedParameterTemplate namedParameterJdbcTemplate;\n\n    public void setDataSource(DataSource dataSource) &#123;\n        this.namedParameterJdbcTemplate &#x3D; new NamedParameterJdbcTemplate(dataSource);\n    &#125;\n\n    public int[] batchUpdate(List&lt;Actor&gt; actors) &#123;\n        return this.namedParameterJdbcTemplate.batchUpdate(\n                &quot;update t_actor set first_name &#x3D; :firstName, last_name &#x3D; :lastName where id &#x3D; :id&quot;,\n                SqlParameterSourceUtils.createBatch(actors));\n    &#125;\n\n    &#x2F;&#x2F; ... additional methods\n&#125;\n\n\nSimpleJdbc和SimpleJdbcCall利用通过JDBC取回的数据库元数据简化配置\n\nSpringBoot的自动配置：\n\nDataSourceAutoConfiguration配置DataSource\nDataSourceTransactionManagerAutoConfiguration配置DataSourceTransactionManager\nJdbcTemplateAutoConfiguration配置JdbcTemplate\n\n\n\n3.O/R Mapping1.JPA\n\n\n\n\n\n\n\n\nJava Persistence API，为对象关系映射提供了一种基于POJO的持久化模型，简化数据持久化代码的开发工作，为Java社区屏蔽不同持久化API的差异\n\n常用注解：\n\n实体：\n@Entity：定义实体\n``@MappedSuperclass`：有多个实体的类，有一个父类，可以在父类上标注\n@Table(name)：name即表名，将实体和表关联起来\n\n\n主键：\n@Id：比较主键\n@GeneratedValue(strategy, generator)：自增序列、自动生成，标注生成策略和生成器\n@SequenceGenerator(name,sequenceName)：指明用的是一个什么样的序列\n\n\n映射：\n@Column(name, nullable, length, insertable, updatable)\n@JoinTable(name)、@JoinColumn(name)：用来做关联用的\n\n\n关系：\n@OneToOne、@OneToMany、@ManyToOne、@MangToMany\n@OrderBy\n\n\n\n\n操作数据库（声明@EnableJpaRepositories）\n\n继承Repository&lt;T,ID&gt;接口\n\nCrudRepository&lt;T,ID&gt;\npublic interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123;\n\t&lt;S extends T&gt; S save(S entity);\n\t&lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities);\n\tOptional&lt;T&gt; findById(ID id);\n\tboolean existsById(ID id);\n\tIterable&lt;T&gt; findAll();\n\tIterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);\n\tlong count();\n\tvoid deleteById(ID id);\n\tvoid delete(T entity);\n\tvoid deleteAll(Iterable&lt;? extends T&gt; entities);\n\tvoid deleteAll();\n&#125;\nPagingAndSortingRepository&lt;T,ID&gt;\n@NoRepositoryBean\npublic interface BaseRepository&lt;T, Long&gt; extends PagingAndSortingRepository&lt;T, Long&gt; &#123;\n    List&lt;T&gt; findTop3ByOrderByUpdateTimeDescIdAsc();\n&#125;\npublic interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123;\n\n  Iterable&lt;T&gt; findAll(Sort sort);\n\n  Page&lt;T&gt; findAll(Pageable pageable);\n&#125;\nJpaRepository&lt;T,ID&gt;\n\n\n\n定义查询：通过名字生成对应的查询方法\n\n根据方法名\nfind…By…. / read…By… / query…By… / get…By…\ncount…By…\n….OrderBy…[Asc / Desc]\nAnd / Or / IgnoreCase\nTop / First / Distinct\n\n\n分页查询\nPagingAndSortingRepository&lt;T，ID&gt;\nPageable / Sort\nSlice&lt;T&gt;/ Page&lt;T&gt;\n\n\n\n\n\n\n底层原理\n\nRepository Bean是如何创建的\n\nrepository的BeanDefinition的注册：\n\nJpaRepositoriesRegistrar\n\nclass JpaRepositoriesRegistrar extends RepositoryBeanDefinitionRegistrarSupport &#123;\n    JpaRepositoriesRegistrar() &#123;\n    &#125;\n\t&#x2F;&#x2F;激活@EnableJpaRepositories\n    protected Class&lt;? extends Annotation&gt; getAnnotation() &#123;\n        return EnableJpaRepositories.class;\n    &#125;\n\t&#x2F;&#x2F;返回了JpaRepositoryConfigExtension\n    protected RepositoryConfigurationExtension getExtension() &#123;\n        return new JpaRepositoryConfigExtension();\n    &#125;\n&#125;\n\n\nRepositoryBeanDefinitionRegistrarSupport.registerBeanDefinitions\n取得registry和extension相关信息，并调用delegate.registerRepositoriesIn(registry, extension);将BeanDefinition注册到注册中心。方法内部，使用RepositoryBeanDefinitionBuilder 依据DefaultRepositoryConfiguration创建，注意此时创建的BeanDefinition的beanClass是JpaRepositoryFactoryBean\n注册Repository Bean（类型是JpaRepositoryFactoryBean）\n\n\n\n\n创建repository：\n\nRepositoryFactoryBeanSupport.afterPropertiesSet首先创建了一个数据仓库工厂（JpaRepositoryFactory）。然后调用工厂的getRepository方法，实际逻辑还是他（JpaRepositoryFactory）的父类RepositoryFactorySupport中。最核心的是使用了spring aop的动态代理生成了repository实例。\n注意JpaRepositoryFactory的getRepositoryBaseClass方法硬编码为SimpleJpaRepository,这个类实现了常见的CURD操作。\n\n\n通过RepositoryConfigurationExtensionSupport.getRepositoryConfigurations取得所有Repository的配置\n\n通过JpaRepositoryFactory.getTargetRepository创建了实际的Repository的bean\n\n\n\n接口中的方法是如何被解释的\n\nRepositoryFactorySupport.getRepository添加了Advice\nDefaultMethodInvokingMethodInterceptor\nQueryExecutorMethodInterceptor\n\n\nAbstractJpaQuery.execute执行具体的查询\n语法解析在Part中\n\n\n\n\n\n2.Lombok\n\n\n\n\n\n\n\n\n能够自动嵌入IDE和构建工具，提升开发效率\n\n@Getter / @Setter\n@ToString\n@NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor\n@Data\n@Builder\n@Slf4j / @CommonsLog / @Log4j2\n\n3.MyBatis\n\n\n\n\n\n\n\n\n持久层框架，支持定制化SQL、存储过程和高级映射。免除了几乎所有的JDBC代码及相关配置，可以通过注解来配置和映射原始类型、接口和Java POJO为数据库中的记录\n\n基础使用\n\n添加jar包依赖，编写配置\n\nxml\nmybatis.mapper-locations &#x3D; classpath* : mapper&#x2F;**&#x2F;*.xml\nmybatis.type-aliases-package &#x3D;类型别名的包名\nmybatis.type-handlers-package &#x3D; TypeHandler扫描包名\nmybatis.configuration.map-underscore-to-camel-case &#x3D; true\n注解\n\n@MapperScan配置扫描位置，添加在Application上，值为mapper的包名\n@Mapper定义接口，添加在定义的mapper接口上\n\n\n\n\nMapper的定义和扫描\n\n\n\nMyBatis Generator\n\nMyBatis代码生成器，根据数据库表生成相关代码：POJO、Mapper接口、SQL Map XML\n\n产生的代码：\n\n匹配table接口的类，包括：\na class to match the primary key of the table (if there is a primary key)\na class to match the non-primary key fields of the table (except BLOB fields)\na class to include the BLOB fields of a table (if the table has BLOB fields)\na class to enable dynamic selects, updates, and deletes\n\n\nMBG为每个table生成的SQL包括：\ninsert\nupdate by primary key\nupdate by example (using a dynamic where clause)\ndelete by primary key\ndelete by example (using a dynamic where clause)\nselect by primary key\nselect by example (using a dynamic where clause)\ncount by example\n\n\n\n\n生成方式：\n\n通过XML配置文件在Java代码中运行MBG，生成配置见官网\nprivate void generateArtifacts() throws Exception &#123;\n    List&lt;String&gt; warnings &#x3D; new ArrayList&lt;String&gt;();\n    boolean overwrite &#x3D; true;\n    File configFile &#x3D; new File(&quot;generatorConfig.xml&quot;);\n    ConfigurationParser cp &#x3D; new ConfigurationParser(warnings);\n    Configuration config &#x3D; cp.parseConfiguration(configFile);\n    DefaultShellCallback callback &#x3D; new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator &#x3D; new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n&#125;\n通过Java配置代码在Java代码中运行MBG\nprivate void generateArtifacts() throws Exception &#123;\n    List&lt;String&gt; warnings &#x3D; new ArrayList&lt;String&gt;();\n    boolean overwrite &#x3D; true;\n    Configuration config &#x3D; new Configuration();\n\n    &#x2F;&#x2F;   ... fill out the config object as appropriate...\n\n    DefaultShellCallback callback &#x3D; new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator &#x3D; new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n&#125;\n\n\n\n\nMyBatis PageHelper\n\n用来做分页，支持多种数据库和多种分页方式，官方网站：https://pagehelper.github.io/\n\n使用\n&#x2F;&#x2F;第一种，RowBounds方式的调用\nList&lt;Country&gt; list &#x3D; sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(0, 10));\n\n&#x2F;&#x2F;第五种，参数对象\n&#x2F;&#x2F;如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页\n&#x2F;&#x2F;有如下 User 对象\npublic class User &#123;\n    &#x2F;&#x2F;其他fields\n    &#x2F;&#x2F;下面两个参数名和 params 配置的名字一致\n    private Integer pageNum;\n    private Integer pageSize;\n&#125;\n&#x2F;&#x2F;存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数\npublic interface CountryMapper &#123;\n    List&lt;Country&gt; selectByPageNumSize(User user);\n&#125;\n&#x2F;&#x2F;当 user 中的 pageNum!&#x3D; null &amp;&amp; pageSize!&#x3D; null 时，会自动分页\nList&lt;Country&gt; list &#x3D; countryMapper.selectByPageNumSize(user);\n\n\n\n4.ApplicationContext\nSpring上下文常用接口\nBeanFactory\nDefaultListableBeanFactory\n\n\nApplicationContext\nClassPathXmlApplicationContext\nFileSystemXmlApplicationContext\nAnnotationConfigApplicationContext\n\n\nWebApplicationContext\n\n\n定义：Root WebApplicationContext通常包含基础设施bean，例如需要在多个Servlet实例之间共享的数据存储库和业务服务。这些bean是可被继承的，并且可以在特定于Servlet的子WebApplicatioinContext中被覆盖，该子WebApplicationContext通常包含给定Servlet的本地bean\n对bean做aop增强问题：\n子类有则用子类的bean，子类没有则用父类的bean\n在父上下文开启增强，父的bean均被增强，子的bean均未被增强；在子上下文开启增强，子的bean均被增强，父的bean未被增强\n要想都被增强，则需要都开启aop的自动配置并且在父类上定义aop\n\n\n\n\n5.Validation6.Data Binding7.Type Conversion8.Null-safetySpring MVC\n\n\n\n\n\n\n\n\n Model：提供要展示的数据，分为Dao层和Service层。取数据和处理业务（CRUD）；View：用户界面；Controller：接收用户请求，提交给Model处理请求，并返回处理完毕后的模型View，充当调度员的工作。\n1.使用1.定义映射关系\n@Controller：标记某个类是一个控制器（URI和处理逻辑的映射），是@Component注解的一个特例。可以与@ResponseBody组合成@RestController。通过@Indexed优化（为@Controller等模式注解添加索引，提升应用启动性能）\n\n@RequestMapping：提供路由信息，用于将web请求映射到请求处理类，一些可选参数如下\n\npath和value用于指定映射路径，method用于指定请求方法（Get、POST等方法），通过RequestMethod来指定\nparams指定有哪些参数，或没有哪些参数（!），headers用来指定请求头中有哪些参数，或没有哪些参数（!）\nconsumes和produces用于限定请求与响应格式，通过MediaType来指定\n\n\n一些快捷方式\n\n@RequestMapping\n\n@GetMapping / @PostMapping / @PutMapping / @DeleteMapping / @PatchMapping\n\n示例\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_JSON_VALUE,\n             produces &#x3D; MediaType.APPLICATION_JSON_UTF8_VALUE)\n@ResponseStatus(HttpStatus.CREATED)\npublic CoffeeOrder create(@RequestBody NewOrderRequest newOrder) &#123;\n    log.info(&quot;Receive new Order &#123;&#125;&quot;, newOrder);\n    Coffee[] coffeeList &#x3D; coffeeService.getCoffeeByName(newOrder.getItems())\n        .toArray(new Coffee[] &#123;&#125;);\n    return orderService.createOrder(newOrder.getCustomer(), coffeeList);\n&#125;\n\n\n\n2.定义处理方法（Handler Methods）\n@RequestBody：方法参数是一个请求体，通过HttpMessageConverter读取请求正文并将其反序列化Object\n@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)\n@ResponseBody\npublic Account handle() &#123;\n    &#x2F;&#x2F; ...\n&#125;\n@ResponseBody：方法返回一个响应体，通过HttpMessageConverter将返回序列化到响应正文\n@PostMapping(&quot;&#x2F;accounts&quot;)\npublic void handle(@RequestBody Account account) &#123;\n    &#x2F;&#x2F; ...\n&#125;\n@ResponseStatus：返回的状态码，通过HttpStatus来指定 \n\n@PathVariable：请求URI中的变量\n&#x2F;&#x2F;样例一\n@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n    &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F;样例二\n@Controller\n@RequestMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&quot;)\npublic class OwnerController &#123;\n    @GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n@RequestParam：请求URI中的参数，可以将Servlet请求参数绑定到控制器中的方法参数\n@GetMapping\npublic String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) &#123; \n    Pet pet &#x3D; this.clinic.loadPet(petId);\n    model.addAttribute(&quot;pet&quot;, pet);\n    return &quot;petForm&quot;;\n&#125;\n@MatrixVariable：匹配URI中多个参数中的一个，Matrix Variable中，多个变量用;分隔\n&#x2F;&#x2F; GET &#x2F;pets&#x2F;42;q&#x3D;11;r&#x3D;22\n@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;\n    &#x2F;&#x2F; petId &#x3D;&#x3D; 42\n    &#x2F;&#x2F; q &#x3D;&#x3D; 11\n&#125;\n\n3.其它操作\n定义类型转换\n\nSpringBoot在WebMvcConfiguration中的WebMvcAutoConfigurationAdapter中有一个addFormatters方法，会搜索以下三种bean来添加\n@Override\npublic void addFormatters(FormatterRegistry registry) &#123;\n    for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;\n        registry.addConverter(converter);\n    &#125;\n    for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;\n        registry.addConverter(converter);\n    &#125;\n    for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;\n        registry.addFormatter(formatter);\n    &#125;\n&#125;\n添加自定义的Converter：可以将一种类型转换成另一种类型\n@Component\npublic class StudentConvert implements Converter&lt;String ,Student&gt; &#123;\n\n    @Override\n    public Student convert(String text) &#123;\n        if (NumberUtils.isParsable(text)) &#123;\n            Student s &#x3D;  new Student();\n            s.setAge(Integer.parseInt(text));\n            return s;\n        &#125;\n        return new Student();\n    &#125;\n&#125;\n添加自定义的Formatter：只能将String转换为另一种类型，比Converter优先级高\n@Component\npublic class MoneyFormatter implements Formatter&lt;Money&gt; &#123;\n    &#x2F;**\n     * 处理 CNY 10.00 &#x2F; 10.00 形式的字符串\n     *&#x2F;\n    @Override\n    public Money parse(String text, Locale locale) throws ParseException &#123;\n        if (NumberUtils.isParsable(text)) &#123;\n            return Money.of(CurrencyUnit.of(&quot;CNY&quot;), NumberUtils.createBigDecimal(text));\n        &#125; else if (StringUtils.isNotEmpty(text)) &#123;\n            String[] split &#x3D; StringUtils.split(text, &quot; &quot;);\n            if (split !&#x3D; null &amp;&amp; split.length &#x3D;&#x3D; 2 &amp;&amp; NumberUtils.isParsable(split[1])) &#123;\n                return Money.of(CurrencyUnit.of(split[0]),\n                                NumberUtils.createBigDecimal(split[1]));\n            &#125; else &#123;\n                throw new ParseException(text, 0);\n            &#125;\n        &#125;\n        throw new ParseException(text, 0);\n    &#125;\n\n    @Override\n    public String print(Money money, Locale locale) &#123;\n        if (money &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        return money.getCurrencyUnit().getCode() + &quot; &quot; + money.getAmount();\n    &#125;\n&#125;\n\n\n定义校验：通过Validator对绑定结果进行验证，参数添加@Valid注解，如果需要自己处理异常返回，则只需要添加BindingResult参数\n&#x2F;&#x2F;实体\npublic class NewCoffeeRequest &#123;\n    @NotEmpty\n    private String name;\n    @NotNull\n    private Money price;\n    &#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;自定义检验失败处理\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D;\n             MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addCoffee(@Valid NewCoffeeRequest newCoffee,\n                        BindingResult result) &#123;\n    if (result.hasErrors()) &#123;\n        &#x2F;&#x2F; 这里先简单处理一下，后续讲到异常处理时会改\n        log.warn(&quot;Binding Errors: &#123;&#125;&quot;, result);\n        return null;\n    &#125;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;\n&#x2F;&#x2F;SpringMVC来帮助处理\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; \n             MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addCoffeeWithoutBindingResult(@Valid NewCoffeeRequest newCoffee) &#123;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;\nMultipart上传（文件），SpringBoot自动配置MultipartAutoConfiguration\n&#x2F;&#x2F;通过文件批量创建\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.MULTIPART_FORM_DATA_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic List&lt;Coffee&gt; batchAddCoffee(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;\n    List&lt;Coffee&gt; coffees &#x3D; new ArrayList&lt;&gt;();\n    if (!file.isEmpty()) &#123;\n        BufferedReader reader &#x3D; null;\n        try &#123;\n            reader &#x3D; new BufferedReader(\n                new InputStreamReader(file.getInputStream()));\n            String str;\n            while ((str &#x3D; reader.readLine()) !&#x3D; null) &#123;\n                String[] arr &#x3D; StringUtils.split(str, &quot; &quot;);\n                if (arr !&#x3D; null &amp;&amp; arr.length &#x3D;&#x3D; 2) &#123;\n                    coffees.add(coffeeService.saveCoffee(arr[0],\n                                                         Money.of(CurrencyUnit.of(&quot;CNY&quot;),\n                                                                  NumberUtils.createBigDecimal(arr[1]))));\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            log.error(&quot;exception&quot;, e);\n        &#125; finally &#123;\n            IOUtils.closeQuietly(reader);\n        &#125;\n    &#125;\n    return coffees;\n&#125;\n\n2.运行机制DispatcherServlet1.请求处理\n主要组件\n\ncontroller：定义了每个请求怎么处理\nxxxResolver\nViewResolver\nHandlerExceptionResolver\nMultipartResolver\n\n\nHandlerMapping：请求怎么映射到controller\n\n\n处理流程：\n\ndoService绑定一些属性：WebApplicationContext、LocaleResolver、ThemeResolver，然后进入doDispatch\n&#x2F;&#x2F; Make framework objects available to handlers and view objects.\nrequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, \n                     getWebApplicationContext());\nrequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\nrequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\nrequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());\n处理Multipart：如果是则将请求转为MultipartHttpServletRequest\nprocessedRequest &#x3D; checkMultipart(request);\nmultipartRequestParsed &#x3D; (processedRequest !&#x3D; request);\nHandler处理：如果找到对应的Handler，执行Controller及前后置处理器逻辑\n&#x2F;&#x2F; Determine handler for the current request.\nmappedHandler &#x3D; getHandler(processedRequest);\n&#x2F;&#x2F;前置处理\nif (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;\n&#x2F;&#x2F; Actually invoke the handler.\nmv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n&#x2F;&#x2F;后置处理\nmappedHandler.applyPostHandle(processedRequest, response, mv);\n处理返回的Model，呈现视图\nprocessDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);\n\n\n\n2.视图解析\nViewResolver与View接口的实现类有：AbstractCachingViewResolver、UrlBasedViewResolver、FreeMarkerViewResolver、ContentNegotiatingViewResolver、InternalResourceViewResolver。都是用来解析出view对象，再用view对象做呈现\n\n视图解析逻辑\n\n有modelandview的视图解析逻辑：\n\nDispatcherServlet中的initStrategies()初始化了对应的ViewResolver\nprotected void initStrategies(ApplicationContext context) &#123;\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n    initHandlerMappings(context);\n    initHandlerAdapters(context);\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n&#125;\nDispatcherServlet中的doDispatch()中的processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);会做从视图名到视图的解析，通过render呈现视图，在render中通过resolveViewName解析出view对象，\n\n\n\n使用@ResponseBody的视图解析逻辑：\n\n在HandlerAdapter.handle()的中完成了Response输出\n\nRequestMappingHandlerAdapter中的handleInternal中执行invokeHandlerMethod()，方法内设置所有ReturnValueHandler，之后执行方法\ninvocableMethod.invokeAndHandle(webRequest, mavContainer);\n\n\n在这个方法中取得返回值returnValue，然后调用HandlerMethodReturnValueHandlerComposite.handleReturnValue()，对Handler进行处理\nthis.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n\n\nRequestResponseBodyMethodProcessor.handleReturnValue(）中的writeWithMessageConverters对结果进行输出到Response中 \n\n\n\n\n\n\n\n\n\n\n常用视图（文档中的viewtechnology）\n\n配置MessageConverter：通过WebMvcConfigurer的configureMessageConverters()，SpringBoot会自动查找HttpMessageConverters进行注册\n@Override\npublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n    this.messageConvertersProvider.ifAvailable((customConverters) -&gt; converters\n                                               .addAll(customConverters.getConverters()));\n&#125;\nSpringBoot对Jackson的支持：JacksonAutoConfiguration\n\n通过@JsonComponent注册JSON序列化组件\n&#x2F;&#x2F;序列化\n@JsonComponent\npublic class MoneySerializer extends StdSerializer&lt;Money&gt; &#123;\n    protected MoneySerializer() &#123;\n        super(Money.class);\n    &#125;\n\n    @Override\n    public void serialize(Money money, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;\n        jsonGenerator.writeNumber(money.getAmount());\n    &#125;\n&#125;\n&#x2F;&#x2F;反序列化\n@JsonComponent\npublic class MoneyDeserializer extends StdDeserializer&lt;Money&gt; &#123;\n    protected MoneyDeserializer() &#123;\n        super(Money.class);\n    &#125;\n\n    @Override\n    public Money deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123;\n        return Money.of(CurrencyUnit.of(&quot;CNY&quot;), p.getDecimalValue());\n    &#125;\n&#125;\nJackson2ObjectMapperBuilderCustomizer\n&#x2F;&#x2F;转成带缩进的\n@Bean\npublic Jackson2ObjectMapperBuilderCustomizer jacksonBuilderCustomizer() &#123;\n    return builder -&gt; builder.indentOutput(true);\n&#125;\n\n\n视图呈现：ModelandView、jsp、Thymeleaf\n\n\n\n\n3.异常处理\n异常解析\n\n核心接口为HandlerExceptionResolver，实现类主要有：\n\nSimpleMappingExceptionResolver\nDefaultHandlerExceptionResolver\nResponseStatusExceptionResolver：处理加了ResponseStatus注解的类\nExceptionHandlerExceptionResolver\n\n\n异常处理方法：\n\n处理方法：@ExceptionHandler\n\n添加位置：\n\n拦截一个Controller：@Controller、@RestController\n&#x2F;&#x2F;验证时如果抛出FormValidationException异常\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addCoffee(@Valid NewCoffeeRequest newCoffee,\n                        BindingResult result) &#123;\n    if (result.hasErrors()) &#123;\n        log.warn(&quot;Binding Errors: &#123;&#125;&quot;, result);\n        throw new FormValidationException(result);\n    &#125;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;\n&#x2F;&#x2F;定义异常处理\n@ResponseStatus(HttpStatus.BAD_REQUEST)\n@Getter\n@AllArgsConstructor\npublic class FormValidationException extends RuntimeException &#123;\n    private BindingResult result;\n&#125;\n拦截所有Controller：``@ControllerAdvice、@RestControllerAdvice`\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_JSON_UTF8_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addJsonCoffee(@Valid @RequestBody NewCoffeeRequest newCoffee,\n                            BindingResult result) &#123;\n    if (result.hasErrors()) &#123;\n        log.warn(&quot;Binding Errors: &#123;&#125;&quot;, result);\n        throw new ValidationException(result.toString());\n    &#125;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;\n\n@RestControllerAdvice\npublic class GlobalControllerAdvice &#123;\n    @ExceptionHandler(ValidationException.class)\n    @ResponseStatus(HttpStatus.BAD_REQUEST)&#x2F;&#x2F;返回400\n    public Map&lt;String, String&gt; validationExceptionHandler(ValidationException exception) &#123;\n        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;message&quot;, exception.getMessage());\n        return map;\n    &#125;\n&#125;\n\n\n\n\n\n\n拦截器\n\n\n==附加：==SpringMVC底层原理：Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，Spring的web框架围绕DispatcherServlet设计，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 下图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 \n\nDispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。\n\n我们假设请求的url为 : http://localhost:8080/SpringMVC/hello\n如上url拆分成三部分：http://localhost:8080服务器域名；SpringMVC部署在服务器上的web站点；hello表示控制器\n\n通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。\n\nHandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。\n\nHandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。\n\nHandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。\n\nHandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。\n\nHandler让具体的Controller执行。\n\nController将具体的执行信息返回给HandlerAdapter,如ModelAndView。\n\nHandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。\n\nDispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。\n\n视图解析器将解析的逻辑视图名传给DispatcherServlet。\n\nDispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。\n\n最终视图呈现给用户。\n\n\n3.RestTemplate\n构建\n@Bean\npublic RestTemplate restTemplate(RestTemplateBuilder builder) &#123;\n    return builder.build();\n&#125;\n常用方法\n\nGET请求\ngetForObject()：String s = restTemplate.getForObject(coffeeUri, String.class);\ngetForEntity()\n\n\nPOST请求\npostForObject()：Coffee response = restTemplate.postForObject(coffeeUri, request, Coffee.class);\npostForEntity()\n\n\nPUT请求\nput()\n\n\nDELETE请求\ndelete()\n\n\n\n\n构建URI\n\n构造URI：UriComponentsBuilder\nURI uri &#x3D; UriComponentsBuilder\n\t\t\t\t.fromUriString(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;coffee&#x2F;&#123;id&#125;&quot;)\n\t\t\t\t.build(1);\n构造相对于当前请求的URI：ServletUriComponentsBuilder\n\n构造指向Controller的URI：MvcUriComponentsBuilder\n\n\n\n\n4.URI设计\n识别资源\n找到领域名词，即能用CRUD操作的名词\n将资源组织为集合，即集合资源；或合并为符合资源\n计算或处理函数\n\n\n选择合适的资源粒度\n服务端的角度：网络效率、表述的多少、客户端的易用程度\n客户端的角度：可缓存性、修改频率、可变性\n\n\n设计URI\n使用域及子域对资源进行合理的分组或划分\n在URI的路径部分使用斜杠分隔符(/)来表示资源之间的层次关系\n在URI的路径部分使用逗号(,)和分号(﹔)来表示非层次元素\n使用连字符(-)和下划线(_)来改善长路径中名称的可读性\n在URI的查询部分使用“与”符号(&amp;）来分隔参数\n在URI中避免出现文件扩展名（例如.php，.aspx和.jsp )\n\n\n选择格式的HTTP方法和返回码\nHTTP方法\n组合\n状态码\n\n\n设计资源的表述\nJSON\nMappingJackson2HttpMessageConverter\nGsonHttpMessageConverter\nJsonbHttpMessageConverter\n\n\nXML\nMappingJackson2XmlHttpMessageConverter\nJaxb2RootElementHttpMessageConverter\n\n\nHTML\n\n\n\n5.Spring SessionSpring Data1.MongoDB1.MongoDB\n\n\n\n\n\n\n\n\nMongoDB 是一种基于分布式文件存储的文档数据库，由 C++ 语言编写，它所具备的可扩展性和灵活性可以满足您对查询和索引的需求，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\n\n\nMongoDB中的CRUD\n\n创建数据库\npublic class CrudInsert &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            &#x2F;&#x2F; insert code goes here\n            &#x2F;&#x2F; display the results of your operation\n        &#125;\n    &#125;\n&#125;\n读数据\nimport com.mongodb.client.*;\nimport com.mongodb.client.model.Filters.*;\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\npublic class CrudRead &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;planets&quot;);\n            \n            &#x2F;&#x2F; find code goes here\n            MongoCursor&lt;Document&gt; cursor &#x3D; coll.find().iterator();\n            &#x2F;&#x2F;第一种查询 eq语句\n            &#x2F;&#x2F;Bson filter &#x3D; eq(&quot;hasRings&quot;, true);\n            &#x2F;&#x2F;第二种查询 lt语句\n            &#x2F;&#x2F;Bson filter &#x3D; lt(&quot;surfaceTemperatureC.mean&quot;, 15);\n            &#x2F;&#x2F;第三种查询 and语句\n            &#x2F;&#x2F;Bson filter &#x3D; and(lt(&quot;surfaceTemperatureC.mean&quot;, 15), gt(&quot;surfaceTemperatureC.min&quot;, -100));\n            &#x2F;&#x2F;执行语句\n            &#x2F;&#x2F;MongoCursor&lt;Document&gt; cursor &#x3D; coll.find(filter).iterator();\n            \n            &#x2F;&#x2F; iterate code goes here\n            try &#123;\n                while (cursor.hasNext()) &#123;\n                    System.out.println(cursor.next().toJson());\n                &#125;\n            &#125; finally &#123;\n                cursor.close();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#123;&quot;_id&quot;: &#123;&quot;$oid&quot;: &quot;621ff30d2a3e781873fcb65c&quot;&#125;, &quot;name&quot;: &quot;Mercury&quot;, &quot;orderFromSun&quot;:1, &quot;hasRings&quot;: false, &quot;mainAtmosphere&quot;: [], &quot;surfaceTemperatureC&quot;: &#123;&quot;min&quot;: -173, &quot;max&quot;: 427, &quot;mean&quot;: 67&#125;&#125;\n&#x2F;&#x2F;...\n插入\npublic class CrudInsert &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;comets&quot;);\n            &#x2F;&#x2F; insert code goes here\n            List&lt;Document&gt; documents &#x3D; new ArrayList&lt;&gt;();\n            Document doc1 &#x3D; new Document(&quot;name&quot;, &quot;Halley&#39;s Comet&quot;).append(&quot;officialName&quot;, &quot;1P&#x2F;Halley&quot;).append(&quot;orbitalPeriod&quot;, 75).append(&quot;radius&quot;, 3.4175).append(&quot;mass&quot;, 2.2e14);\n            Document doc2 &#x3D; new Document(&quot;name&quot;, &quot;Wild2&quot;).append(&quot;officialName&quot;, &quot;81P&#x2F;Wild&quot;).append(&quot;orbitalPeriod&quot;, 6.41).append(&quot;radius&quot;, 1.5534).append(&quot;mass&quot;, 2.3e13);\n            Document doc3 &#x3D; new Document(&quot;name&quot;, &quot;Comet Hyakutake&quot;).append(&quot;officialName&quot;, &quot;C&#x2F;1996 B2&quot;).append(&quot;orbitalPeriod&quot;, 17000).append(&quot;radius&quot;, 0.77671).append(&quot;mass&quot;, 8.8e12);\n            \n            documents.add(doc1);\n            documents.add(doc2);\n            documents.add(doc3);\n            \n            InsertManyResult result &#x3D; coll.insertMany(documents);\n            \n            &#x2F;&#x2F; display the results of your operation\n            result.getInsertedIds().values().forEach(doc -&gt; System.out.println(doc.asObjectId().getValue()));\n        &#125;\n    &#125;\n&#125;\n更新\npublic class CrudUpdate &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;comets&quot;);\n            &#x2F;&#x2F; update code goes here\n            Bson filter &#x3D; Filters.empty();\n            Bson update &#x3D; Updates.mul(&quot;Radius&quot;, 1.60934);\n            UpdateResult result &#x3D; coll.updateMany(filter, update);\n            &#x2F;&#x2F; display the results of your operation\n            System.out.println(&quot;Number of documents updated: &quot; + result.getModifiedCount());\n        &#125;\n    &#125;\n&#125;\n删除\npublic class CrudDelete &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;comets&quot;);\n            &#x2F;&#x2F; delete code goes here\n            Bson filter &#x3D; Filters.and(Filters.gt(&quot;OrbitalPeriod&quot;, 5), Filters.lt(&quot;OrbitalPeriod&quot;, 85));\n            DeleteResult result &#x3D; coll.deleteMany(filter);\n\n            &#x2F;&#x2F; amount deleted code goes here\n            System.out.println(&quot;Number of documents deleted: &quot; +result.getDeletedCount());\n        &#125;\n    &#125;\n&#125;\n\n\n\n2.Spring Data相关\n注解\n\n@Document：\n@Id：转换成MongoDB中的object ID\n\n@Document\npublic class Coffee &#123;\n    @Id\n    private String id;\n    private String name;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n    &#x2F;&#x2F;...\n&#125;\nMongoTemplate\n\nsave/remove\nCoffee saved &#x3D; mongoTemplate.save(espresso);\nCriteria/Query/Update\nList&lt;Coffee&gt; list &#x3D; mongoTemplate.find(\n    Query.query(Criteria.where(&quot;name&quot;).is(&quot;espresso&quot;)), Coffee.class);\nUpdateResult result &#x3D; mongoTemplate.updateFirst(\n    query(where(&quot;name&quot;).is(&quot;espresso&quot;)),\n    new Update().set(&quot;price&quot;, Money.ofMajor(CurrencyUnit.of(&quot;CNY&quot;), 30))\n    .currentDate(&quot;updateTime&quot;),\n    Coffee.class);\n\n\nRepository\n\n@EnableMongoRepositories\n\n对应接口\n\nMongoRepository&lt;T，ID&gt;\npublic interface CoffeeRepository extends MongoRepository&lt;Coffee, String&gt; &#123;\n    List&lt;Coffee&gt; findByName(String name);\n&#125;\n\n@SpringBootApplication\n@EnableMongoRepositories\npublic class MongoRepositoryDemoApplication implements CommandLineRunner &#123;\n\t@Autowired\n\tprivate CoffeeRepository coffeeRepository;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(MongoRepositoryDemoApplication.class, args);\n\t&#125;\n\n\t@Bean\n\tpublic MongoCustomConversions mongoCustomConversions() &#123;\n\t\treturn new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));\n\t&#125;\n\n\t@Override\n\tpublic void run(String... args) throws Exception &#123;\n\t\tCoffee espresso &#x3D; Coffee.builder()\n\t\t\t\t.name(&quot;espresso&quot;)\n\t\t\t\t.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tCoffee latte &#x3D; Coffee.builder()\n\t\t\t\t.name(&quot;latte&quot;)\n\t\t\t\t.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\n\t\tcoffeeRepository.insert(Arrays.asList(espresso, latte));\n\t\tcoffeeRepository.findAll(Sort.by(&quot;name&quot;))\n\t\t\t\t.forEach(c -&gt; log.info(&quot;Saved Coffee &#123;&#125;&quot;, c));\n\t\tThread.sleep(1000);\n\t\tlatte.setPrice(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 35.0));\n\t\tlatte.setUpdateTime(new Date());\n\t\tcoffeeRepository.save(latte);\n\t\tcoffeeRepository.findByName(&quot;latte&quot;)\n\t\t\t\t.forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c));\n\n\t\tcoffeeRepository.deleteAll();\n\t&#125;\n&#125;\nPagingAndSortingRepository&lt;T，ID&gt;\n\nCrudRepository&lt;T，ID&gt;\n\n\n\n\n\n底层原理\n\n\n2.Redis\n\n\n\n\n\n\n\n\nRedis是高性能的Key-Value数据库，可以存储键（字符串）和五种不同类型（字符串、列表、集合、散列表、有序集合）的值之间的映射\n1.Redis\n概述\n\nRedis客户端启动：中文乱码时在后面加上-raw\n\n本地\n$ redis-cli\nredis 127.0.0.1:6379&gt;\nredis 127.0.0.1:6379&gt; PING\nPONG\n远程\n$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;\nredis 127.0.0.1:6379&gt;\nredis 127.0.0.1:6379&gt; PING\nPONG\n\n\nredis支持的命令：https://redis.io/commands/\n\n脚本：Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。\n\n备份与恢复：SAVE命令用于创建当前数据库的备份，如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。\n\n性能测试：redis-benchmark [option] [option value]\n\n\n\n数据类型：\n\nstring：最基本的类型，类型安全（可以包含任何数据），最大能存储512MB\nredis 127.0.0.1:6379&gt; SET runoob &quot;菜鸟教程&quot;\nOK\nredis 127.0.0.1:6379&gt; GET runoob\n&quot;菜鸟教程&quot;\nhash：是一个键值对集合，是一个String类型的field和value的映射表，适合存储对象，每个 hash 可以存储 2^32 -1个键值对（40多亿）\nredis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; HMSET runoob field1 &quot;Hello&quot; field2 &quot;World&quot;\n&quot;OK&quot;\nredis 127.0.0.1:6379&gt; HGET runoob field1\n&quot;Hello&quot;\nredis 127.0.0.1:6379&gt; HGET runoob field2\n&quot;World&quot;\nlist：简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部或者尾部，每个列表可以存储 2^32 -1个元素（40多亿）\nredis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; lpush runoob redis\n(integer) 1\nredis 127.0.0.1:6379&gt; lpush runoob mongodb\n(integer) 2\nredis 127.0.0.1:6379&gt; lpush runoob rabbitmq\n(integer) 3\nredis 127.0.0.1:6379&gt; lrange runoob 0 10\n1) &quot;rabbitmq&quot;\n2) &quot;mongodb&quot;\n3) &quot;redis&quot;\nset：String类型的无序集合，集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)，每个集合可以存储 2^32 -1个元素（40多亿）\nredis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; sadd runoob redis\n(integer) 1\nredis 127.0.0.1:6379&gt; sadd runoob mongodb\n(integer) 1\nredis 127.0.0.1:6379&gt; sadd runoob rabbitmq\n(integer) 1\nredis 127.0.0.1:6379&gt; sadd runoob rabbitmq\n(integer) 0\nredis 127.0.0.1:6379&gt; smembers runoob\n1) &quot;redis&quot;\n2) &quot;rabbitmq&quot;\n3) &quot;mongodb&quot;\nzset(sorted set：有序集合)：Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。\nredis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; zadd runoob 0 redis\n(integer) 1\nredis 127.0.0.1:6379&gt; zadd runoob 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq\n(integer) 1\nredis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq\n(integer) 0\nredis 127.0.0.1:6379&gt; ZRANGEBYSCORE runoob 0 1000\n1) &quot;mongodb&quot;\n2) &quot;rabbitmq&quot;\n3) &quot;redis&quot;\n\n\n特性\n\nRedis HyperLogLog：Redis 在 2.8.9 版本添加了 HyperLogLog 结构。Redis HyperLogLog 是用来做基数（不重复元素）统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。\n\n发布订阅 (pub/sub) ：是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道\n\n订阅频道\nredis 127.0.0.1:6379&gt; SUBSCRIBE runoobChat\nReading messages... (press Ctrl-C to quit)\n1) &quot;subscribe&quot;\n2) &quot;runoobChat&quot;\n3) (integer) 1\n#待发布频道发布完后，此订阅频道会收到如下信息\n 1) &quot;message&quot;\n2) &quot;runoobChat&quot;\n3) &quot;Redis PUBLISH test&quot;\n 1) &quot;message&quot;\n2) &quot;runoobChat&quot;\n3) &quot;Learn redis by runoob.com&quot;\n发布频道\nredis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;\n(integer) 1\nredis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;\n(integer) 1\n\n\n事务：Redis 事务可以一次执行多个命令， 并且带有以下保证：\n\n批量操作在发送 EXEC 命令前被放入队列缓存。\n收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。\n在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n事务不是原子性的，只是打包的批量执行脚本，但是每条命令的执行是原子性的\n\nredis 127.0.0.1:6379&gt; MULTI\nOK\nredis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;\nQUEUED\nredis 127.0.0.1:6379&gt; GET book-name\nQUEUED\nredis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;\nQUEUED\nredis 127.0.0.1:6379&gt; SMEMBERS tag\nQUEUED\nredis 127.0.0.1:6379&gt; EXEC\n1) OK\n2) &quot;Mastering C++ in 21 days&quot;\n3) (integer) 3\n4) 1) &quot;Mastering Series&quot;\n   2) &quot;C++&quot;\n   3) &quot;Programming&quot;\n脚本：Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。\nredis 127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second\n1) &quot;key1&quot;\n2) &quot;key2&quot;\n3) &quot;first&quot;\n4) &quot;second&quot;\nStream：\n\nRedis 5.0 版本新增加的数据结构，主要用于消息队列（MQ，Message Queue）。Redis的发布订阅 (pub/sub)的消息无法持久化，即无法记录历史消息，如果出现网络断开、Redis 宕机等，消息就会被丢弃。而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。\nRedis Stream的结构如下，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。每个 Stream 都有唯一的名称，它就是 Redis 的 key，在首次使用 xadd 指令追加消息时自动创建\nConsumer Group ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。\nlast_delivered_id ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。\npending_ids ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。\n\n\n相关操作\n\n\n管道技术：\n\nRedis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：\n客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。\n服务端处理命令，并将结果返回给客户端。\n\n\nRedis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。可以显著提高redis服务的性能\n\n\n\n\n\n2.Spring Data相关\nconnection to redis：无论用哪个包，都可以通过RedisConnection和RedisConnecctionFactory两个接口来取回与Redis的连接，并且屏蔽了底层的异常转换细节。\n\nLettuce连接操作如下\n\n导入依赖\n&lt;dependencies&gt;\n  &lt;!-- other dependency elements omitted --&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;6.2.0.RELEASE&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n创建连接工厂：工厂创建的LettuceConnection共享相同的线程安全的原生连接来做无锁非事务的操作，通过设置shareNativeConnection为false可以使用专用的连接。\n@Configuration\nclass AppConfig &#123;\n    @Bean\n    public LettuceConnectionFactory redisConnectionFactory() &#123;\n        return new LettuceConnectionFactory(new RedisStandaloneConfiguration(&quot;server&quot;, 6379));\n        \n        &#x2F;&#x2F;Lettuce集成了Netty的原生接口，可以使用Unix的socket来与Redis通信\n        &#x2F;&#x2F; return new LettuceConnectionFactory(\n        &#x2F;&#x2F;new RedisSocketConfiguration(&quot;&#x2F;var&#x2F;run&#x2F;redis.sock&quot;));\n    &#125;\n&#125;\n&#x2F;&#x2F;使用\n&#x2F;&#x2F;通过依赖注入和RedisConnection redisConnection &#x3D; redisConnectionFactory.getConnection();\n&#x2F;&#x2F;可通过redisConnection来操作Redis\n写主读从：通过用LettuceClientConfiguration来配置\n@Configuration\nclass WriteToMasterReadFromReplicaConfiguration &#123;\n    @Bean\n    public LettuceConnectionFactory redisConnectionFactory() &#123;\n\t&#x2F;&#x2F;客户端配置\n        LettuceClientConfiguration clientConfig &#x3D; LettuceClientConfiguration.builder()\n            .readFrom(REPLICA_PREFERRED)\n            .build();\n\t&#x2F;&#x2F;服务端配置\n        RedisStandaloneConfiguration serverConfig &#x3D; new RedisStandaloneConfiguration(&quot;server&quot;, 6379);\n\n        return new LettuceConnectionFactory(serverConfig, clientConfig);\n    &#125;\n&#125;\n\n\nJedis客户端：Jedis不是线程安全的，通过JedisPool获得Jedis实例，直接使用Jedis中的方法\npublic interface CoffeeRepository extends JpaRepository&lt;Coffee, Long&gt; &#123; &#125;\n\n@Service\npublic class CoffeeService &#123;\n    @Autowired\n    private CoffeeRepository coffeeRepository;\n    public List&lt;Coffee&gt; findAllCoffee() &#123;\n        return coffeeRepository.findAll();\n    &#125;\n&#125;\n\n@EnableTransactionManagement\n@SpringBootApplication\n@EnableJpaRepositories\npublic class SpringBucksApplication implements ApplicationRunner &#123;\n\t@Autowired\n\tprivate CoffeeService coffeeService;\n\t@Autowired\n\tprivate JedisPool jedisPool;\n\t@Autowired\n\tprivate JedisPoolConfig jedisPoolConfig;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(SpringBucksApplication.class, args);\n\t&#125;\n\n\t@Bean\n\t@ConfigurationProperties(&quot;redis&quot;)\n\tpublic JedisPoolConfig jedisPoolConfig() &#123;\n\t\treturn new JedisPoolConfig();\n\t&#125;\n\t@Bean(destroyMethod &#x3D; &quot;close&quot;)\n\tpublic JedisPool jedisPool(@Value(&quot;$&#123;redis.host&#125;&quot;) String host) &#123;\n\t\treturn new JedisPool(jedisPoolConfig(), host);\n\t&#125;\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception &#123;\n\t\tlog.info(jedisPoolConfig.toString());\n\n\t\ttry (Jedis jedis &#x3D; jedisPool.getResource()) &#123;\n\t\t\tcoffeeService.findAllCoffee().forEach(c -&gt; &#123;\n\t\t\t\tjedis.hset(&quot;springbucks-menu&quot;,\n\t\t\t\t\t\tc.getName(),\n\t\t\t\t\t\tLong.toString(c.getPrice().getAmountMinorLong()));\n\t\t\t&#125;);\n\n\t\t\tMap&lt;String, String&gt; menu &#x3D; jedis.hgetAll(&quot;springbucks-menu&quot;);\n\t\t\tlog.info(&quot;Menu: &#123;&#125;&quot;, menu);\n\n\t\t\tString price &#x3D; jedis.hget(&quot;springbucks-menu&quot;, &quot;espresso&quot;);\n\t\t\tlog.info(&quot;espresso - &#123;&#125;&quot;,\n\t\t\t\t\tMoney.ofMinor(CurrencyUnit.of(&quot;CNY&quot;), Long.parseLong(price)));\n\t\t&#125;\n\t&#125;\n&#125;\n\n\nLettuce和Jedis的特性支持\n\n\n\nSupported Feature\nLettuce\nJedis\n\n\n\nStandalone Connections\nX\nX\n\n\nMaster/Replica Connections\nX\n\n\n\nRedis Sentinel\nMaster Lookup, Sentinel Authentication, Replica Reads\nMaster Lookup\n\n\nRedis Cluster\nCluster Connections, Cluster Node Connections, Replica Reads\nCluster Connections, Cluster Node Connections\n\n\nTransport Channels\nTCP, OS-native TCP (epoll, kqueue), Unix Domain Sockets\nTCP\n\n\nConnection Pooling\nX (using commons-pool2)\nX (using commons-pool2)\n\n\nOther Connection Features\nSingleton-connection sharing for non-blocking commands\nPipelining and Transactions mutually exclusive. Cannot use server/connection commands in pipeline/transactions.\n\n\nSSL Support\nX\nX\n\n\nPub/Sub\nX\nX\n\n\nPipelining\nX\nX (Pipelining and Transactions mutually exclusive)\n\n\nTransactions\nX\nX (Pipelining and Transactions mutually exclusive)\n\n\nDatatype support\nKey, String, List, Set, Sorted Set, Hash, Server, Stream, Scripting, Geo, HyperLogLog\nKey, String, List, Set, Sorted Set, Hash, Server, Scripting, Geo, HyperLogLog\n\n\nReactive (non-blocking) API\nX\n\n\n\n\n部署方式\n\nSentinel 支持：是Redis的一种高可用方案\n\n通过RedisSentinelConfiguration来配置哨兵模式\n&#x2F;&#x2F; Lettuce\n@Bean\npublic RedisConnectionFactory lettuceConnectionFactory() &#123;\n    RedisSentinelConfiguration sentinelConfig &#x3D; new RedisSentinelConfiguration()\n        .master(&quot;mymaster&quot;)\n        .sentinel(&quot;127.0.0.1&quot;, 26379)\n        .sentinel(&quot;127.0.0.1&quot;, 26380);\n    return new LettuceConnectionFactory(sentinelConfig);\n&#125;\n&#x2F;&#x2F; Jedis\n@Bean\npublic RedisConnectionFactory jedisConnectionFactory() &#123;\n    RedisSentinelConfiguration sentinelConfig &#x3D; new RedisSentinelConfiguration()\n        .master(&quot;mymaster&quot;)\n        .sentinel(&quot;127.0.0.1&quot;, 26379)\n        .sentinel(&quot;127.0.0.1&quot;, 26380);\n    return new JedisConnectionFactory(sentinelConfig);\n&#125;\n&#x2F;&#x2F;使用\n\n通过配置文件\nspring.redis.sentinel.master: name of the master node.\nspring.redis.sentinel.nodes: Comma delimited list of host:port pairs.\nspring.redis.sentinel.username: The username to apply when authenticating with Redis Sentinel (requires Redis 6)\nspring.redis.sentinel.password: The password to apply when authenticating with Redis Sentinel\n和其中一个哨兵直接交互：使用RedisConnectionFactory.getSentinelConnection()或者RedisConnection.getSentinelCommands()可以访问配置的第一个活跃的Sentinel\n\n\n\n==Redis Cluster==\n\n数据自动分片，分成16384个Hash Slot，在部分节点失效时有一定可用性\nRedisClusterConfiguration\n\n\n\n\nRedisTemplate：封装了序列化和连接管理，提供更多的易于操作的API\n\nRedisTemplate&lt;K,V&gt;示例：opsForXxx()\n@Service\npublic class CoffeeService &#123;\n    private static final String CACHE &#x3D; &quot;springbucks-coffee&quot;;\n    @Autowired\n    private CoffeeRepository coffeeRepository;\n    @Autowired\n    private RedisTemplate&lt;String, Coffee&gt; redisTemplate;\n\n    public Optional&lt;Coffee&gt; findOneCoffee(String name) &#123;\n        &#x2F;&#x2F;获取操作\n        HashOperations&lt;String, String, Coffee&gt; hashOperations &#x3D; redisTemplate.opsForHash();\n        if (redisTemplate.hasKey(CACHE) &amp;&amp; hashOperations.hasKey(CACHE, name)) &#123;\n            &#x2F;&#x2F;name指定的数据在缓存中，则从缓存中取出\n            return Optional.of(hashOperations.get(CACHE, name));\n        &#125;\n        ExampleMatcher matcher &#x3D; ExampleMatcher.matching()\n                .withMatcher(&quot;name&quot;, exact().ignoreCase());\n        Optional&lt;Coffee&gt; coffee &#x3D; coffeeRepository.findOne(\n                Example.of(Coffee.builder().name(name).build(), matcher));\n        if (coffee.isPresent()) &#123;\n           \t&#x2F;&#x2F;加入缓存\n            hashOperations.put(CACHE, name, coffee.get());\n            &#x2F;&#x2F;设置过期时间！！！\n            redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);\n        &#125;\n        return coffee;\n    &#125;\n&#125;\n\nStringRedisTemplate：简化操作\npublic class Example &#123;\n  @Autowired\n  private StringRedisTemplate redisTemplate;\n  public void addLink(String userId, URL url) &#123;\n    redisTemplate.opsForList().leftPush(userId, url.toExternalForm());\n  &#125;\n&#125;\n\n\n缓存\n\nSpring Data的缓存抽象\n\n为不同的缓存提供一层抽象  \n\n为Java方法增加缓存，缓存执行结果\n支持ConcurrentMap、EhCache、Caffeine、JCache (JSR-107)\n接口\norg.springframework.cache.Cache\norg.springframework.cache.cacheManager\n\n\n\n\n基于注解的缓存：@EnableCaching，开启缓存支持\n\n@Cacheable：如果方法结果已经在缓存里了，就直接在缓存中去；如果不在，就执行并将执行结果放入缓存中\n@CacheEvict：缓存清理\n@CachePut：不管执行情况，直接做缓存的设置\n@caching：对上面的操作进行打包，在里面放入多个操作\n@cacheConfig：对缓存进行设置，比如设置缓存的名字\n\n\n示例\n@Service\n@CacheConfig(cacheNames &#x3D; &quot;coffee&quot;)\npublic class CoffeeService &#123;\n    @Autowired\n    private CoffeeRepository coffeeRepository;\n    @Cacheable\n    public List&lt;Coffee&gt; findAllCoffee() &#123;\n        return coffeeRepository.findAll();\n    &#125;\n    @CacheEvict\n    public void reloadCoffee() &#123;\n    &#125;\n&#125;\n@EnableTransactionManagement\n@SpringBootApplication\n@EnableJpaRepositories\n@EnableCaching(proxyTargetClass &#x3D; true)\npublic class SpringBucksApplication implements ApplicationRunner &#123;\n\t@Autowired\n\tprivate CoffeeService coffeeService;\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(SpringBucksApplication.class, args);\n\t&#125;\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception &#123;\n\t\tlog.info(&quot;Count: &#123;&#125;&quot;, coffeeService.findAllCoffee().size());\n\t\tfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n\t\t\tcoffeeService.findAllCoffee();&#x2F;&#x2F;在缓存中读取的\n\t\t&#125;\n\t\tcoffeeService.reloadCoffee();\n        &#x2F;&#x2F;SQL查询，重新获取\n\t\tcoffeeService.findAllCoffee().forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c.getName()));\n\t&#125;\n&#125;\n\n\n\n使用Redis作为缓存\n\n配置\nspring.cache.type&#x3D;redis\nspring.cache.cache-names&#x3D;coffee\nspring.cache.redis.time-to-live&#x3D;5000\nspring.cache.redis.cache-null-values&#x3D;false\n\nspring.redis.host&#x3D;localhost\n配置管理\n@Bean\npublic RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123;\n\treturn RedisCacheManager.create(connectionFactory);\n&#125;\n&#x2F;&#x2F;RedisCacheManager的配置，默认无锁可选择加锁\nRedisCacheManager cm &#x3D; RedisCacheManager.builder(connectionFactory)\n\t.cacheDefaults(defaultCacheConfig())\n\t.withInitialCacheConfigurations(singletonMap(&quot;predefined&quot;, defaultCacheConfig().disableCachingNullValues()))\n\t.transactionAware()\n\t.build();\n&#x2F;&#x2F;RedisCache的配置\nRedisCacheConfiguration config &#x3D; RedisCacheConfiguration.defaultCacheConfig()\n    .entryTtl(Duration.ofSeconds(1))\n\t.disableCachingNullValues();\n\n\n\n\n\n3.ElasticSearch\n\n\n\n\n\n\n\n\nElasticsearch 是一个分布式的 RESTful 搜索和分析引擎，可用来集中存储您的数据，以便您对形形色色、规模不一的数据进行搜索、索引和分析。\n1.ElasticSearch2.Spring Data相关Spring Boot\n\n\n\n\n\n\n\n\n用来快速创建基于Spring的应用程序，不需要像Spring有很多配置，使得开发者更专注于业务\n1.概览1.用SpringBoot开发\n构建系统：\n\n用Maven或Gradle构建系统，将版本号提取的管理方法\n\nStarter Dependency：直接面向功能，一站式获得所有相关依赖，定制自己的起步依赖示例如下\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;groupId&gt;geektime.spring.hello&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;geektime-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;name&gt;geektime-spring-boot-starter&lt;&#x2F;name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;geektime.spring.hello&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;geektime-spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;geektime.spring.hello&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;greeting&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n配置加载机制\n\n外化配置加载顺序：\n\n测试类的配置\n命令行参数（–server.port=9000）\nSystem.getProperties\n操作系统环境变量\napplication.properties：先带profile的和jar包外的\n\n\napplication.properties\n\n位置：有默认的位置，可以通过spring.config.name等属性来更改\nRelaxed Binding\n\n\nPropertySource抽象\n\n@PropertySource\n\n@ConfigurationProperties\n@ConfigurationProperties(prefix &#x3D; &quot;spring.jdbc&quot;)\npublic class JdbcProperties &#123;\n    private final Template template &#x3D; new Template();\n    public Template getTemplate() &#123;\n        return this.template;\n    &#125;\n    public static class Template &#123;\n        &#x2F;&#x2F;spring.jdbc.template.fetchSize属性\n        private int fetchSize &#x3D; -1;\n        private int maxRows &#x3D; -1;\n        @DurationUnit(ChronoUnit.SECONDS)\n        private Duration queryTimeout;\n        public int getFetchSize() &#123;\n            return this.fetchSize;\n        &#125;\n        public void setFetchSize(int fetchSize) &#123;\n            this.fetchSize &#x3D; fetchSize;\n        &#125;\n        public int getMaxRows() &#123;\n            return this.maxRows;\n        &#125;\n        public void setMaxRows(int maxRows) &#123;\n            this.maxRows &#x3D; maxRows;\n        &#125;\n        public Duration getQueryTimeout() &#123;\n            return this.queryTimeout;\n        &#125;\n        public void setQueryTimeout(Duration queryTimeout) &#123;\n            this.queryTimeout &#x3D; queryTimeout;\n        &#125;\n    &#125;\n&#125;\n定制PropertySource\n\n实现PropertySource&lt;T&gt;\n从Environment取得PropertySources\n将自己的PropertySource添加到合适的位置\n\npublic class RandomValuePropertySource extends PropertySource&lt;Random&gt; &#123; \n\n\tprivate static final Log logger &#x3D; LogFactory.getLog(RandomValuePropertySource.class);\n\n\tpublic RandomValuePropertySource(String name) &#123;\n\t\tsuper(name, new Random());\n\t&#125;\n\n\tpublic RandomValuePropertySource() &#123;\n\t\tthis(RANDOM_PROPERTY_SOURCE_NAME);\n\t&#125;\n\n\t@Override\n\tpublic Object getProperty(String name) &#123;\n\t\tif (!name.startsWith(PREFIX)) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\tif (logger.isTraceEnabled()) &#123;\n\t\t\tlogger.trace(&quot;Generating random property for &#39;&quot; + name + &quot;&#39;&quot;);\n\t\t&#125;\n\t\treturn getRandomValue(name.substring(PREFIX.length()));\n\t&#125;\n\n\tprivate Object getRandomValue(String type) &#123;\n\t\tif (type.equals(&quot;int&quot;)) &#123;\n\t\t\treturn getSource().nextInt();\n\t\t&#125;\n\t\tif (type.equals(&quot;long&quot;)) &#123;\n\t\t\treturn getSource().nextLong();\n\t\t&#125;\n\t\tString range &#x3D; getRange(type, &quot;int&quot;);\n\t\tif (range !&#x3D; null) &#123;\n\t\t\treturn getNextIntInRange(range);\n\t\t&#125;\n\t\trange &#x3D; getRange(type, &quot;long&quot;);\n\t\tif (range !&#x3D; null) &#123;\n\t\t\treturn getNextLongInRange(range);\n\t\t&#125;\n\t\tif (type.equals(&quot;uuid&quot;)) &#123;\n\t\t\treturn UUID.randomUUID().toString();\n\t\t&#125;\n\t\treturn getRandomBytes();\n\t&#125;\n&#125;\n\n\n\n\n\n\n\n代码结构\n\n不适用default包，而是使用翻转域名的方式，例如：com.example.project\n将application类放在根包下，代码结构如下：\n\n\n配置类：\n\n导入附加的配置类：将@Configuration加到每一个类上，@Import能用来导入额外的配置类，可以用@ComponentScan来自动地提取所有Spring成分（components）\n导入XML配置：用@Configuration修饰类，相当于把该类作为Spring的xml配置文件中的&lt;beans&gt;，然后就可以用@ImportResource来载入配置文件\n\n\nBeans&amp;DI\n\n可以用@ComponentScan找到bean，如果将application放到顶层，那么用@SpringBootApplication就不用再用@ComponentScan，而且使得应用成分（@Component, @Service, @Repository, @Controller, and others）都被自动注册成Spring Beans\n\n使用构造器注入时候，如果一个bean有超过一个构造器，可以使用@Autowired来标记让Spring使用哪一个\n@Service\npublic class MyAccountService implements AccountService &#123;\n\n    private final RiskAssessor riskAssessor;\n    private final PrintStream out;\n\n    @Autowired\n    public MyAccountService(RiskAssessor riskAssessor) &#123;\n        this.riskAssessor &#x3D; riskAssessor;\n        this.out &#x3D; System.out;\n    &#125;\n\n    public MyAccountService(RiskAssessor riskAssessor, PrintStream out) &#123;\n        this.riskAssessor &#x3D; riskAssessor;\n        this.out &#x3D; out;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;\n\n\n开发工具（spring-boot-devtools依赖）\n\napplication.properties文件：可以配置属性，提高性能\n\n自动重启：当类路径下文件有改变时，会有类加载问题\n\n日志会记录\n\n资源会被重新载入，不想载入：spring.devtools.restart.exclude=static/**,public/**\n\n关闭自动重启：\n@SpringBootApplication\npublic class MyApplication &#123;\n    public static void main(String[] args) &#123;\n        System.setProperty(&quot;spring.devtools.restart.enabled&quot;, &quot;false&quot;);\n        SpringApplication.run(MyApplication.class, args);\n    &#125;\n&#125;\n使用触发文件：在resource文件下新建.reloadtrigger文件，文件里有spring.devtools.restart.trigger-file=.reloadtrigger，仅在此文件被更新时，才会发生重启\n\n\n\n\n\n\n2.Auto Configuration\n\n\n\n\n\n\n\n\n基于添加的JAR依赖自动对Spring Boot应用程序进行配置\n\n@SpringBootApplication注解，包括三个特性：\n\n@EnableAutoConfiguration：启动SpringBoot的自动配置机制，猜测开发者想怎样配置，比如spring-boot-starter-web加了Tomcat和Spring MVC，自动配置假设开发者想要开发一个web应用，并且据此设计Spring\n@ComponentScan：在application所在的包启动@Component扫描\n@SpringBootConfiguration：启动在上下文中注册额外的bean或导入额外的配置类，有助于在集成测试中进行配置检测\n\n\n原理\n\n@EnableAutoConfiguration导入了AutoConfigurationImportSelector帮助加载spring.factories中的org.springframework.boot.autoconfigure.EnableAutoConfiguration属性\n条件注解\n条件注解\n@Conditional：Spring4.0引入\n\n\n类条件\n@ConditionalOnClass：配置了某个类时\n@ConditionalOnMissingClass：没有配置了某个类时\n\n\n属性条件\n@conditionalOnProperty：配置了某个属性时\n\n\nBean条件\n@ConditionalOnBean：配置了某个Bean时\n@ConditionalOnMissingBean：没有配置某个Bean时\n@ConditionalOnSingleCandidata：上下文只有一个候选Bean，或一个Primary的Bean\n\n\n其他条件\n资源条件：@ConditionalOnResource\nWeb应用条件：@ConditionalOnWebApplication：是Web应用\nWeb应用条件：@ConditionalOnNotWebApplication：不是Web应用\n@conditionalOnExpression\n@Conditional0nJava\n@conditionalOnJndi\n\n\n\n\n了解自动配置的情况：通过命令行添加--debug，可以看到执行结果，主要是通过ConditionEvaluationReportLoggingListener来输出 \nPositive matches：匹配的自动配置\nNegative matches：没匹配的自动配置\nExclusions：排除掉了哪些自动配置\nUnconditional classes：无条件配置的自动配置\n\n\n\n\n定制\n\n编写Java Config（@Configuration），添加条件（@Conditional），定位自动配置（META-INF/spring.factories）\n@Configuration\n@ConditionalOnClass(GreetingApplicationRunner.class)\npublic class GreetingAutoConfiguration &#123;\n    @Bean\n    @ConditionalOnMissingBean(GreetingApplicationRunner.class)\n    @ConditionalOnProperty(name &#x3D; &quot;greeting.enabled&quot;, havingValue &#x3D; &quot;true&quot;, matchIfMissing &#x3D; true)\n    public GreetingApplicationRunner greetingApplicationRunner() &#123;\n        return new GreetingApplicationRunner();\n    &#125;\n&#125;\n\n\n\n3.运行监测管理1.Actuator\n概述：依赖spring-boot-starter-actuator，HTTP访问/actuator/\\&lt;id\\&gt;，有以下配置可选\n\n端口与路径\nmanagement.server.address=\nmanagement.server.port=\nmanagement.endpoints.web.base-path=/actuator\nmanagement.endpoints.web.path-mapping.&lt;id&gt;=路径\n\n\n开启Endpoint\nmanagement.endpoint.&lt;id&gt;.enabled=true\nmanagement.endpoints.enabled-by-default=false\n\n\n暴漏Endpoint\nmanagement.endpoints.jmx.exposure.exclude=\nmanagement.endpoints.jmx.exposure.include=*\nmanagement.endpoints.web.exposure.exclude=\nmanagement.endpoints.web.exposure.include=info,health\n\n\n\n\n常用Endpoint\n\n\n\n2.Health Indicator\n通过HealthIndicatorRegistry收集信息，HealthIndicator实现具体检查逻辑，有以下配置项\n\nmanagement.health.defaults.enabled=truelfalse\nmanagement.health.&lt;id&gt;.enabled=true\nmanagement.endpoint.health.show-details=never lwhen-authorizedlalways\n\n\nSpring Boot自带的Health Indicator\n\n自定义Health Indicator：实现HealthIndicator接口，根据自定义检查逻辑返回对应Health状态，其中Health中包含状态和详细描述信息\n@Component\npublic class CoffeeIndicator implements HealthIndicator &#123;\n    @Autowired\n    private CoffeeService coffeeService;\n    @Override\n    public Health health() &#123;\n        long count &#x3D; coffeeService.getCoffeeCount();\n        Health health;\n        if (count &gt; 0) &#123;\n            health &#x3D; Health.up()\n                    .withDetail(&quot;count&quot;, count)\n                    .withDetail(&quot;message&quot;, &quot;We have enough coffee.&quot;)\n                    .build();\n        &#125; else &#123;\n            health &#x3D; Health.down()\n                    .withDetail(&quot;count&quot;, 0)\n                    .withDetail(&quot;message&quot;, &quot;We are out of coffee.&quot;)\n                    .build();\n        &#125;\n        return health;\n    &#125;\n&#125;\n\n3.Micrometer\n特性\n\n多维度度量，支持Tag\n预制大量探针，如：缓存、类加载器、GC、CPU利用率、线程池\n与Spring深度整合，支持多种监控系统，如Prometheus、JMX\n\n\n度量指标\n\n核心接口为Meter，内置了一些实现，如Gauge、Timer等\n访问的URL\n/acutator/metrics\n/actuator/prometheus\n\n\n在SpringBoot 2.x中的度量项：JVM、CPU、日志、启动时间等\n\n\n自定义度量指标\n\n通过MeterRegistry注册Meter\n提供MeterBinder Bean 让 Spring Boot自动绑定\n通过MeterFilter进行定制\n\n@Service\n@Transactional\n@Slf4j\npublic class CoffeeOrderService implements MeterBinder &#123;\n    @Autowired\n    private CoffeeOrderRepository orderRepository;\n\t&#x2F;&#x2F;监控订单数\n    private Counter orderCounter &#x3D; null;\n\n    public CoffeeOrder get(Long id) &#123;\n        return orderRepository.getOne(id);\n    &#125;\n\n    public CoffeeOrder createOrder(String customer, Coffee...coffee) &#123;\n        CoffeeOrder order &#x3D; CoffeeOrder.builder()\n                .customer(customer)\n                .items(new ArrayList&lt;&gt;(Arrays.asList(coffee)))\n                .state(OrderState.INIT)\n                .build();\n        CoffeeOrder saved &#x3D; orderRepository.save(order);\n        log.info(&quot;New Order: &#123;&#125;&quot;, saved);\n        orderCounter.increment();\n        return saved;\n    &#125;\n    @Override\n    public void bindTo(MeterRegistry meterRegistry) &#123;\n        this.orderCounter &#x3D; meterRegistry.counter(&quot;order.count&quot;);\n    &#125;\n&#125;\n\n\n4.定制运行参数\n修改容器配置\n\n端口\nserver.port\nserver.address\n\n\n压缩\nserver.compression.enabled\nserver.compression.min-response-size\nserver.compression.mime-types\n\n\nTomcat特定配置\nserver.tomcat.max-connections=10000\nserver.tomcat.max-http-post-size=2MB\nserver.tomcat.max-swallow-size=2MB\nserver.tomcat.max-threads=200\nserver.tomcat.min-spare-threads=10\n\n\n\n\n配置HTTPS支持\n\n通过参数进行配置\n\nserver.port=8443\nserver.ssl.*\nserver.ssl.key-store\nserver.ssl.key-store-type，JKS或者PKCS12\nserver.ssl.key-store-password=secret\n\n\n\nserver.port&#x3D;8443\n#springbucks.p12为整证书文件\nserver.ssl.key-store&#x3D;classpath:springbucks.p12\nserver.ssl.key-store-type&#x3D;PKCS12\nserver.ssl.key-store-password&#x3D;spring\nJava生成证书命令：keytool -genkey -alias别名 -storetype仓库类型 -keyalg算法 -keysize长度-keystore文件名 -validity 有效期\n\n客户端HTTPS支持\n\n配置HttpClient ( &gt;= 4.4 )\n\nSSLContextBuilder构造SSLContext\nsetSSLHostnameverifier(new NoopHostnameVerifier())\n\n\n配置RequestFactory\n\nHttpComponentsClientHttpRequestFactory\nsetHttpClient()\n\n\n\n@SpringBootApplication\n@Slf4j\npublic class CustomerServiceApplication &#123;\n\t@Value(&quot;$&#123;security.key-store&#125;&quot;)\n\tprivate Resource keyStore;\n\t@Value(&quot;$&#123;security.key-pass&#125;&quot;)\n\tprivate String keyPass;\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew SpringApplicationBuilder()\n\t\t\t\t.sources(CustomerServiceApplication.class)\n\t\t\t\t.bannerMode(Banner.Mode.OFF)\n\t\t\t\t.web(WebApplicationType.NONE)\n\t\t\t\t.run(args);\n\t&#125;\n\t@Bean\n\tpublic HttpComponentsClientHttpRequestFactory requestFactory() &#123;\n\t\tSSLContext sslContext &#x3D; null;\n\t\ttry &#123;\n\t\t\tsslContext &#x3D; SSLContextBuilder.create()\n\t\t\t\t\t&#x2F;&#x2F; 会校验证书\n\t\t\t\t\t.loadTrustMaterial(keyStore.getURL(), keyPass.toCharArray())\n\t\t\t\t\t&#x2F;&#x2F; 放过所有证书校验\n&#x2F;&#x2F;\t\t\t\t\t.loadTrustMaterial(null, (certificate, authType) -&gt; true)\n\t\t\t\t\t.build();\n\t\t&#125; catch(Exception e) &#123;\n\t\t\tlog.error(&quot;Exception occurred while creating SSLContext.&quot;, e);\n\t\t&#125;\n\n\t\tCloseableHttpClient httpClient &#x3D; HttpClients.custom()\n\t\t\t\t.evictIdleConnections(30, TimeUnit.SECONDS)\n\t\t\t\t.setMaxConnTotal(200)\n\t\t\t\t.setMaxConnPerRoute(20)\n\t\t\t\t.disableAutomaticRetries()\n\t\t\t\t.setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())\n\t\t\t\t.setSSLContext(sslContext)\n\t\t\t\t.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE)\n\t\t\t\t.build();\n\n\t\tHttpComponentsClientHttpRequestFactory requestFactory &#x3D;\n\t\t\t\tnew HttpComponentsClientHttpRequestFactory(httpClient);\n\n\t\treturn requestFactory;\n\t&#125;\n\n\t@Bean\n\tpublic RestTemplate restTemplate(RestTemplateBuilder builder) &#123;\n\t\treturn builder\n\t\t\t\t.setConnectTimeout(Duration.ofMillis(100))\n\t\t\t\t.setReadTimeout(Duration.ofMillis(500))\n\t\t\t\t.requestFactory(this::requestFactory)\n\t\t\t\t.build();\n\t&#125;\n&#125;\n\n\n\n\n配置HTTP/2支持\n\n配置SSL\nHTTP库：OKHttp\n\n\n\n5.打包成Docker镜像2.核心特性1.SpringApplication\n启动失败：如果应用启动失败，FailureAnalyzers将会提示错误信息并且给出修复错误的方式。如果没有FailureAnalyzers可以处理，仍将会有全条件报告，只需要启动debug属性和DEBUG属性，例如：$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug\n懒加载：beans只有在需要时才会被创造，可以减少启动时间。但会推迟问题的出现，容易造成JVM内存不足，所以默认不支持，通过spring.main.lazy-initialization=true使用\n可用性：当部署在平台上后，应用可以向基础设施（K8s）提供关于自己可用性的信息。并且可以把状态暴露出来用于监听或者手动更改\nLiveness State：此状态用来告知内部，正在正确工作或者现在不能用但可以自行恢复，如果达不到此状态则说明应用不能恢复需要基础设施来重启它（通常不涉及外部系统，如数据库）\nReadiness State：此状态用来告知应用已经准备好，可以接受路由来的流量，一般发生在启动时或者流量太大时\n\n\n事件和监听：\n使用：用SpringApplication.addListeners(…)或SpringApplicationBuilder.listeners(…)方法，也可以创建META-INF/spring.factories文件，并在里面添加org.springframework.context.ApplicationListener=com.example.project.MyListener关键字\n事件按一定顺序依次被发送，有SpringApplication相关的事件和其它事件（如WebServerInitializedEvent），\n\n\n\n2.Externalized Configuration\n目的：可以使得同一应用在不同环境下运行，\n\n使用：通过@Value注入beans，通过Spring的Environment抽象访问，或者通过ConfigurationProperties绑定到结构化对象\n\n特殊的属性覆盖顺序：\n\n默认配置（以及SpringApplication.setDefaultProperties）\nConfiguration类的@PropertySource注解，直到上下文被刷新才会被加载进环境，所以对于一些属性来说太迟了\n配置文件（yaml文件同理，但会被properties覆盖）：\njar包内的application.properties\njar包内的特定应用的application&#123;profile&#125;.properties\njar包外的application.properties\njar包外的特定应用的application&#123;profile&#125;.properties\n\n\n操作系统环境变量、命令行参数（--server.port=9000）\n测试使用的相关属性\n\n\nExternal Application Properties：\n\nSpringBoot可以在指定目录下自动载入application.yaml文件（类路径、类路径/config、当前目录、当前目录的/config子目录、第一层子目录下的/config子目录）\n路径可以使用通配符（*）、属性占位符（$&#123;name:default&#125;）、配置特定文件（application-dev.properties）、导入附加的数据（spring.config.import=optional:file:./dev.properties）、导入无扩展名文件（spring.config.import=file:/etc/config/myconfig[.yaml]）、使用配置树（spring.config.import=optional:configtree:/etc/config/）\n\n\n类型安全的配置属性：\n@ConfigurationProperties(&quot;my.service&quot;)\npublic class MyProperties &#123;\n\t&#x2F;&#x2F;my.service.enabled, with a value of false by default.\n    private boolean enabled;\n    &#x2F;&#x2F;my.service.remote-address, with a type that can be coerced from String.\n    private InetAddress remoteAddress;\n    private final Security security &#x3D; new Security();\n\t\n    &#x2F;&#x2F; getters &#x2F; setters...\n    public static class Security &#123;\n\n        &#x2F;&#x2F;my.service.security.username, with a nested &quot;security&quot; object whose \n        &#x2F;&#x2F;name is determined by the name of the property. In particular, \n        &#x2F;&#x2F;the type is not used at all there and could have been SecurityProperties.\n        private String username;\n        private String password;\n        &#x2F;&#x2F;my.service.security.roles, with a collection of String that defaults to USER.\n        private List&lt;String&gt; roles &#x3D; new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;));\n        \n        &#x2F;&#x2F; getters &#x2F; setters...\n    &#125;\n&#125;\n\n3.JSON\n可以使用Gson、Jackson、JSON-8，但推荐使用Jackson\n\n自定义序列化器和反序列化器（默认用Jackson注册），用@JsonComponent 注解修饰 JsonSerializer和 JsonDeserializer实现，也可以直接用在外部类上：\n@JsonComponent\npublic class MyJsonComponent &#123;\n\n    public static class Serializer extends JsonSerializer&lt;MyObject&gt; &#123;\n\n        @Override\n        public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException &#123;\n            jgen.writeStartObject();\n            jgen.writeStringField(&quot;name&quot;, value.getName());\n            jgen.writeNumberField(&quot;age&quot;, value.getAge());\n            jgen.writeEndObject();\n        &#125;\n    &#125;\n\n    public static class Deserializer extends JsonDeserializer&lt;MyObject&gt; &#123;\n\n        @Override\n        public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException &#123;\n            ObjectCodec codec &#x3D; jsonParser.getCodec();\n            JsonNode tree &#x3D; codec.readTree(jsonParser);\n            String name &#x3D; tree.get(&quot;name&quot;).textValue();\n            int age &#x3D; tree.get(&quot;age&quot;).intValue();\n            return new MyObject(name, age);\n        &#125;\n    &#125;\n&#125;\n\n4.Task Excution and Scheduling\n如果上下文中缺少Executor，SpringBoot会自动配置一个具有合理默认值（可更改）的ThreadPoolTaskExecutor，可以自动关联到异步任务执行（@EnableAsync）和Spring MVC异步请求处理，如下：\n#16个线程，队列容量为100，线程空闲10s后被收回\nspring.task.execution.pool.max-size&#x3D;16\nspring.task.execution.pool.queue-capacity&#x3D;100\nspring.task.execution.pool.keep-alive&#x3D;10s\n\n5.其它\nProfiles：是一种分离应用程序配置部分使其仅在某些环境可用的方法，任何@Component, @Configuration 或 @ConfigurationProperties都可以被@Profile标记来限制加载的时间（可以使用spring.profiles.active=dev,hsqldb来指定那些配置文件处于活跃状态）如下所示：\n@Configuration(proxyBeanMethods &#x3D; false)\n@Profile(&quot;production&quot;)\npublic class ProductionConfiguration &#123;\n    &#x2F;&#x2F; ...\n&#125;\nLogging：\n\n日志格式：\n\nLog Level：ERROR、WARN、INFO、DEBUG、TRACE\n格式：日期和时间 日子级别 线程ID — [线程名] 类名 ：日志信息\n\n\n输出：\n\nconsole输出：默认有ERROR、WARN、INFO级别，可以加–debug来增加DEBUG级别\nFile输出：默认不输出到文件，需要在application.properties中设置logging.file.name 或 logging.file.path属性\n日志级别：通过logging.level.&lt;logger-name&gt;=&lt;level&gt;来指定日志级别\n\n\n\n\nInternationalization：SpringBoot支持本地化消息，以便应用程序可以满足不同语言偏好的用户，默认情况下，SpringBoot在类路径的根部目中查找资源包（messages.properties）的存在\n\n\n3.Web\n\n\n\n\n\n\n\n\n通过SpringBoot内嵌的Tomcat、Jetty、Undertow、Nwtty来构建一个自给自足的HTTP服务器\n1.Servelt Web Application\nSpring MVC ：\n\n可以通过@Controller后@RestControllerbeans来处理收到的HTTP请求，controller内的方法通过@RequestMapping来映射到HTTP：\n@RestController\n@RequestMapping(&quot;&#x2F;users&quot;)\npublic class MyRestController &#123;\n\n    private final UserRepository userRepository;\n\n    private final CustomerRepository customerRepository;\n\n    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) &#123;\n        this.userRepository &#x3D; userRepository;\n        this.customerRepository &#x3D; customerRepository;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;&#123;userId&#125;&quot;)\n    public User getUser(@PathVariable Long userId) &#123;\n        return this.userRepository.findById(userId).get();\n    &#125;\n\n    @GetMapping(&quot;&#x2F;&#123;userId&#125;&#x2F;customers&quot;)\n    public List&lt;Customer&gt; getUserCustomers(@PathVariable Long userId) &#123;\n        return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();\n    &#125;\n\n    @DeleteMapping(&quot;&#x2F;&#123;userId&#125;&quot;)\n    public void deleteUser(@PathVariable Long userId) &#123;\n        this.userRepository.deleteById(userId);\n    &#125;\n    \n&#125;\n功能变体WebMvc.fn将路由配置与请求的实际处理分开：\n@Configuration(proxyBeanMethods &#x3D; false)\npublic class MyRoutingConfiguration &#123;\n\n    private static final RequestPredicate ACCEPT_JSON &#x3D; accept(MediaType.APPLICATION_JSON);\n\n    @Bean\n    public RouterFunction&lt;ServerResponse&gt; routerFunction(MyUserHandler userHandler) &#123;\n        return route()\n            .GET(&quot;&#x2F;&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::getUser)\n            .GET(&quot;&#x2F;&#123;user&#125;&#x2F;customers&quot;, ACCEPT_JSON, userHandler::getUserCustomers)\n            .DELETE(&quot;&#x2F;&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::deleteUser)\n            .build();\n    &#125;\n\n&#125;\n\n@Component\npublic class MyUserHandler &#123;\n\n    public ServerResponse getUser(ServerRequest request) &#123;\n        &#x2F;&#x2F;...\n        return ServerResponse.ok().build();\n    &#125;\n\n    public ServerResponse getUserCustomers(ServerRequest request) &#123;\n        &#x2F;&#x2F; ...\n        return ServerResponse.ok().build();\n    &#125;\n\n    public ServerResponse deleteUser(ServerRequest request) &#123;\n        &#x2F;&#x2F;...\n        return ServerResponse.ok().build();\n    &#125;\n\n&#125;\n支持Spring MVC自动配置、可以自动将HTTP请求和响应转换为JSON、静态内容在 /static (or /public or /resources or /META-INF/resources)内提取、内置欢迎页（index.html）\n\n通过查看请求路径并将其与应用程序中定义的映射匹配，将传入的HTTP请求映射到处理程序。默认不开启后缀匹配但可以使用查询参数来确保像 &quot;GET /projects/spring-boot?format=json&quot; 能被映射到 @GetMapping(&quot;/projects/spring-boot&quot;)（spring.mvc.contentnegotiation.favor-parameter=true）\n\n\n\n\n2.Spring Security\nMVC Security、WebFlux Security\nOAuth2\nClient\nResource Server\nAuthorization Server\n\n\n\n3.Spring Session可以自动配置：JDBC、Redis、MongoDB\n4.Data5.其它Spring Cloud1.Spring Cloud Alibaba1.Nacos Discovery\n简介：可以自动将服务注册到Nacos服务端，并且能够动态地感知和刷新某个服务实例的服务列表。Nacos Discovery适配了Netflix Ribbon，可以使用RestTemplate或OpenFeign进行服务调用\n\n使用：\n\n启动Nacos服务器：添加依赖，启动Nacos Server，在http://ip:8848查看控制台\n\n将Provider服务注册到Nacos：添加依赖和配置信息，启动应用实例即可\n\n通过Nacos使用Consumer服务：可以使用LoadBalanceClient和RestTemplate的方式，也可以使用带负载均衡的RestTemplate和FeignClient\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class NacosConsumerApp &#123;\n    @RestController\n    public class NacosController&#123;\n        @Autowired\n        private LoadBalancerClient loadBalancerClient;\n        @Autowired\n        private RestTemplate restTemplate;\n        @Value(&quot;$&#123;spring.application.name&#125;&quot;)\n        private String appName;\n\n        @GetMapping(&quot;&#x2F;echo&#x2F;app-name&quot;)\n        public String echoAppName()&#123;\n            &#x2F;&#x2F;使用 LoadBalanceClient 和 RestTemplate 结合的方式来访问\n            ServiceInstance serviceInstance &#x3D; loadBalancerClient.choose(&quot;nacos-provider&quot;);\n            String url &#x3D; String.format(&quot;http:&#x2F;&#x2F;%s:%s&#x2F;echo&#x2F;%s&quot;,\n                                       serviceInstance.getHost(),serviceInstance.getPort(),appName);\n            System.out.println(&quot;request url:&quot;+url);\n            return restTemplate.getForObject(url,String.class);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;实例化 RestTemplate 实例\n    @Bean\n    public RestTemplate restTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(NacosConsumerApp.class,args);\n    &#125;\n&#125;\n\n\n其它\n\nNacos Discovery对外暴露的Endpoint id为nacos-discovery，其中包含两种属性\nsubscribe: 显示了当前服务有哪些服务订阅者\nNacosDiscoveryProperties: 当前应用 Nacos 的基础配置信息\n\n\n配置信息：见文档\n\n\n\n2.Nacos Config\n使用\n\nNacos Config使用DataId和Group确定一个配置，并且可以选择配置格式\n\n服务端初始化：同Nacos Discovery，启动后，添加配置\n\n客户端使用方式：\n\n创建标准的Spring Boot应用\n@SpringBootApplication\npublic class NacosConfigApplication &#123;\n\n    public static void main(String[] args) &#123;\n        ConfigurableApplicationContext applicationContext &#x3D; SpringApplication.run(ConfigApplication.class, args);\n        String userName &#x3D; applicationContext.getEnvironment().getProperty(&quot;user.name&quot;);\n        String userAge &#x3D; applicationContext.getEnvironment().getProperty(&quot;user.age&quot;);\n        System.err.println(&quot;user name :&quot;+userName+&quot;; age: &quot;+userAge);\n    &#125;\n&#125;\n添加bootstrap.properties配置文件来配置Nacos Server地址\n# DataId 默认使用 &#96;spring.application.name&#96; 配置跟文件扩展名结合(配置格式默认使用 \n#properties), GROUP 不配置默认使用 DEFAULT_GROUP。因此该配置文件对应的 Nacos \n#Config 配置的 DataId 为 nacos-config.properties, GROUP 为 DEFAULT_GROUP\nspring.application.name&#x3D;nacos-config\nspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848\n启动后将输出\n2018-11-02 14:24:51.638  INFO 32700 --- [main] c.a.demo.provider.ConfigApplication    : Started ConfigApplication in 14.645 seconds (JVM running for 15.139)\nuser name :nacos-config-properties; age: 90\n2018-11-02 14:24:51.688  INFO 32700 --- [-127.0.0.1:8848] s.c.a.AnnotationConfigApplicationContext : Refreshing dorg.springframework.context.annotation.AnnotationConfigApplicationContext@a8c5e74: startup date [Fri Nov 02 14:24:51 CST 2018]; root of context hierarchy\n\n\n\n\n特性\n\n基于DataId为yaml的文件扩展名配置方式\n支持配置的动态更新\n支持profile粒度的配置\n\n\n其它\n\nNacos Config对外暴露的Endpoint\n配置信息\n\n\n\n3.Sentinel\n简介：Sentinel以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。具有完备的实时监控、广泛的开原生态、完善的SPI扩展点\n\n使用：添加依赖、添加@SentinelResource注解来标识资源是否被限流、降级，通过配置控制台，可以获得机器发现、单机资源实时监控、集群资源汇总，以及规则管理的功能\n@SpringBootApplication\npublic class Application &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ServiceApplication.class, args);\n    &#125;\n&#125;\n\n@RestController\npublic class TestController &#123;\n\n    @GetMapping(value &#x3D; &quot;&#x2F;hello&quot;)\n    @SentinelResource(&quot;hello&quot;)&#x2F;&#x2F;hello表示资源名\n    public String hello() &#123;\n        return &quot;Hello Sentinel&quot;;\n    &#125;\n&#125;·\n其它\n\n一些支持\n\nOpenFeign支持\nRestTemplate支持\nSpirngCloudGateway支持\n\n\n暴漏的Endpoint\n\n\n\n\n2.Spring Cloud Commons1.Application Context Services\n\n\n\n\n\n\n\n\n为应用程序的ApplicationContext提供实用程序和特殊服务（bootstrap context、encryption、refresh scope、environment endpoints）\n\nBootstrap Application Context\n\n是主application的父类，负责从外部源载入属性并且解码本地的外部属性文件的属性，可以与主上下文分离\nspring:\n  application:\n    name: foo\n  cloud:\n    config:\n      uri: $&#123;SPRING_CONFIG_URI:http:&#x2F;&#x2F;localhost:8888&#125;\n启动阶段引导加载的属性，常用配置即spring.application.name=服务名及其它配置中心相关\n\n\n\n\n2.Common Abstractions\n\n\n\n\n\n\n\n\n是一组抽象的通用类，用于不同的SpringCloud实现，例如Spring Cloud Netflix和Spring Cloud Consul）\n\n@EnableDiscoveryClient：用于在META-INF/spring.factories中搜索DiscoveryClient接口和ReactiveDiscoveryClient的实现。发现客户端的实现向spring.factories中加了一个配置类，主要实现有Eureka、Consul、Zookeeper、Nacos。Spring Cloud默认提供了阻塞的和响应式的服务发现客户端，可以通过配置关闭spring.cloud.discovery.enabled=false。有DiscoveryClient的实现在classpath，就可以不加此注解。\npublic interface DiscoveryClient extends Ordered &#123;\n\tint DEFAULT_ORDER &#x3D; 0;\n\tString description();\n\tList&lt;ServiceInstance&gt; getInstances(String serviceId);\n\tList&lt;String&gt; getServices();\n\t@Override\n\tdefault int getOrder() &#123;\n\t\treturn DEFAULT_ORDER;\n\t&#125;\n&#125;\n\n\n如何获得服务地址：配置类中注入DiscoveryClient，通过它的getInstances()来得到服务相关信息\n@Component\n@Slf4j\npublic class CustomerRunner implements ApplicationRunner &#123;\n    @Autowired\n    private DiscoveryClient discoveryClient;\n    \n    private void showServiceInstances() &#123;\n        log.info(&quot;DiscoveryClient: &#123;&#125;&quot;, discoveryClient.getClass().getName());\n        discoveryClient.getInstances(&quot;waiter-service&quot;).forEach(s -&gt; &#123;\n            log.info(&quot;Host: &#123;&#125;, Port: &#123;&#125;&quot;, s.getHost(), s.getPort());\n        &#125;);\n    &#125;\n&#125;\n定制DiscoveryClient\n\n\n\nServiceRegistry：通过ServiceRegistry接口可以定制服务，Registration是一个标记接口。不同的ServiceRegistry实现有不同的Registry实现。默认ServiceRegistry实现自动注册运行的服务，并且提前触发InstancePreRegisteredEvent和InstanceRegisteredEvent两个事件。\npublic interface ServiceRegistry&lt;R extends Registration&gt; &#123;   \n\tvoid register(R registration);\n\tvoid deregister(R registration);\n\tvoid close();\n\tvoid setStatus(R registration, String status);\n\t&lt;T&gt; T getStatus(R registration);\n&#125;\n&#x2F;&#x2F;使用示例\n@Configuration\n@EnableDiscoveryClient(autoRegister&#x3D;false)\npublic class MyConfiguration &#123;\n    private ServiceRegistry registry;\n\n    public MyConfiguration(ServiceRegistry registry) &#123;\n        this.registry &#x3D; registry;\n    &#125;\n    &#x2F;&#x2F; called through some external process, such as an event or a custom actuator endpoint\n    public void register() &#123;\n        Registration registration &#x3D; constructRegistration();\n        this.registry.register(registration);\n    &#125;\n&#125;\nLoadBalancerClient：使用@LoadBalaced注解，实现ClientHttpRequestInterceptor接口的LoadBalancerInterceptor类，其中的LoadBalancerClient接口的execute方法，具体实现有RibbonLoadBalancerClient\n\nRestTemplate：classpath上需要有一个load-balancer实现\n@Configuration\npublic class MyConfiguration &#123;\n    @LoadBalanced\n    @Bean\n    RestTemplate restTemplate() &#123;\n        return new RestTemplate();\t&#x2F;&#x2F;RestTemplate Bean需要自己注册\n    &#125;\n&#125;\n\npublic class MyClass &#123;\n    @Autowired\n    private RestTemplate restTemplate;\n\n    public String doOtherStuff() &#123;\n        String results &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;stores&#x2F;stores&quot;, String.class);\n        return results;\n    &#125;\n&#125;\nWebClient\n@Configuration\npublic class MyConfiguration &#123;\n\n    @Bean\n    @LoadBalanced\n    public WebClient.Builder loadBalancedWebClientBuilder() &#123;\n        return WebClient.builder();\n    &#125;\n&#125;\n\npublic class MyClass &#123;\n    @Autowired\n    private WebClient.Builder webClientBuilder;\n\n    public Mono&lt;String&gt; doOtherStuff() &#123;\n        return webClientBuilder.build().get().uri(&quot;http:&#x2F;&#x2F;stores&#x2F;stores&quot;)\n                        .retrieve().bodyToMono(String.class);\n    &#125;\n&#125;\nWebFlux\n\n\n\n\n3.Circuit Breaker3.Spring Cloud Config\n概述：SpringCloudConfig提供了服务侧和客户侧在分布式系统中外化配置的支持，通过配置服务器（默认是git），能有一个中心化的地方来为不同环境的应用管理外部属性。当应用程序通过部署管道从开发到测试再进入生产时，可以管理这些环境之间的配置，并确保应用程序在迁移时具备运行所需的一切。\n\nSpring Cloud Config Server：提供了一个基于HTTP资源的API，使用@EnableConfigServer\n\nEnvironment Repository\n\n为配置服务器存储配置数据，并为Environment对象提供服务，这个Environment是Spring域内的Environment的浅拷贝，有三个变量&#123;application&#125;、&#123;profile&#125;、&#123;label&#125;\nspring:\n  application:\n    name: foo\n  profiles:\n    active: dev,mysql\nGit Backend：EnvironmentRepository的默认实现是Git客户端，要更改存储库的位置，可以在applicatioin.yml中设置spring.cloud.config.server.git.uri。为了要扩展配置服务器，并使其具有高可用性，需要让所有服务器的所有实例都执行同一个存储库，因此只有共享文件系统才能工作。相关配置见文档\n\n\n\n\n\n\n其它\n\n健康检查：用来检查更多应用程序以及自定义配置文件和自定义标签\nSecurity：可以以任何对你有意义的方式保护你的配置服务器，SpringScurity、配置用户名和密码\n\n\n\n4.Spring Cloud OpenFeign\n概念\n\nFeign：声明式web服务客户端，让写web服务客户端变得更简单\n\n\n\n\n使用\n\n加注解\n\n@EnableFeignClient\n@FeignClient\n\n\n定义接口\n@FeignClient(name &#x3D; &quot;waiter-service&quot;, contextId &#x3D; &quot;coffeeOrder&quot;)\npublic interface CoffeeOrderService &#123;\n    @GetMapping(&quot;&#x2F;order&#x2F;&#123;id&#125;&quot;)\n    CoffeeOrder getOrder(@PathVariable(&quot;id&quot;) Long id);\n\n    @PostMapping(path &#x3D; &quot;&#x2F;order&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_JSON_VALUE,\n            produces &#x3D; MediaType.APPLICATION_JSON_UTF8_VALUE)\n    CoffeeOrder create(@RequestBody NewOrderRequest newOrder);\n&#125;\n简单配置\nfeign.client.config.default.connect-timeout&#x3D;500\nfeign.client.config.default.read-timeout&#x3D;500\n\n\n\n5.Spring Cloud Sleuth\n简介：用于分布式链路追踪，它能追踪请求和消息从而可以将消息与相应的日志条目相关联，支持导出到OpenZipkin来可视化链路，追踪过程一个Trace的所有Span如下\n\n\nzipkin和sleuth\n\n使用\n\nspan的声明周期\n\nstart，开始一个span时，会记录它被分配的名称和开始时间戳；end，span完成，如果span被采样，则会被收集到Zipkin\n&#x2F;&#x2F; Start a span. If there was a span present in this thread it will become\n&#x2F;&#x2F; the &#96;newSpan&#96;&#39;s parent.\nSpan newSpan &#x3D; this.tracer.nextSpan().name(&quot;calculateTax&quot;);\ntry (Tracer.SpanInScope ws &#x3D; this.tracer.withSpan(newSpan.start())) &#123;\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can tag a span\n    newSpan.tag(&quot;taxValue&quot;, taxValue);\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can log an event on a span\n    newSpan.event(&quot;taxCalculated&quot;);\n&#125;\nfinally &#123;\n    &#x2F;&#x2F; Once done remember to end the span. This will allow collecting\n    &#x2F;&#x2F; the span to send it to a distributed tracing system e.g. Zipkin\n    newSpan.end();\n&#125;\ncontinue：span继续，例如在另一个线程里\nSpan spanFromThreadX &#x3D; this.tracer.nextSpan().name(&quot;calculateTax&quot;);\ntry (Tracer.SpanInScope ws &#x3D; this.tracer.withSpan(spanFromThreadX.start())) &#123;\n    executorService.submit(() -&gt; &#123;\n        &#x2F;&#x2F; Pass the span from thread X\n        Span continuedSpan &#x3D; spanFromThreadX;\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; You can tag a span\n        continuedSpan.tag(&quot;taxValue&quot;, taxValue);\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; You can log an event on a span\n        continuedSpan.event(&quot;taxCalculated&quot;);\n    &#125;).get();\n&#125;\nfinally &#123;\n    spanFromThreadX.end();\n&#125;\ncreate with explicit parent：可以创建一个新span，并为其设置显示显示父级\n&#x2F;&#x2F; let&#39;s assume that we&#39;re in a thread Y and we&#39;ve received\n&#x2F;&#x2F; the &#96;initialSpan&#96; from thread X. &#96;initialSpan&#96; will be the parent\n&#x2F;&#x2F; of the &#96;newSpan&#96;\nSpan newSpan &#x3D; null;\ntry (Tracer.SpanInScope ws &#x3D; this.tracer.withSpan(initialSpan)) &#123;\n    newSpan &#x3D; this.tracer.nextSpan().name(&quot;calculateCommission&quot;);\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can tag a span\n    newSpan.tag(&quot;commissionValue&quot;, commissionValue);\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can log an event on a span\n    newSpan.event(&quot;commissionCalculated&quot;);\n&#125;\nfinally &#123;\n    &#x2F;&#x2F; Once done remember to end the span. This will allow collecting\n    &#x2F;&#x2F; the span to send it to e.g. Zipkin. The tags and events set on the\n    &#x2F;&#x2F; newSpan will not be present on the parent\n    if (newSpan !&#x3D; null) &#123;\n        newSpan.end();\n    &#125;\n&#125;\n\n\n通过注解管理Spans\n\n创建新的span：@NewSpan\n\nContinuing Spans：@ContinueSpan\n&#x2F;&#x2F; method declaration\n@ContinueSpan(log &#x3D; &quot;testMethod11&quot;)\nvoid testMethod11(@SpanTag(&quot;testTag11&quot;) String param);\n&#x2F;&#x2F; method execution\nthis.testBean.testMethod11(&quot;test&quot;);\nthis.testBean.testMethod13();\nTag设置\n\n\n\n\n\n其它\n\n\n6.Spring Cloud Stream1.概览\n概念：用来构建消息驱动的微服务应用。\n\napplication模型：应用通过和外部代理暴漏的destinations和输入输出参数来建立绑定从而与外部世界通信。绑定所需要的代理细节由特定于中间件的Binder处理\n\n\nBinder抽象：通过SpringBoot配置，Binder使得应用和中间件之间的连接方式更灵活。相同的代码可以配置不同的中间件\n\npub-sub：应用间的通信模型，可以减少生产者和消费者之间通信的复杂性，不用打破现有的流就可以增加新的，降低了微服务之间的耦合程度。如下图，HTTP发布的的数据被Averages和Ingest HDFS两个微服务所订阅\n\n\n消费组：为给定应用扩展多个实例也很重要，一个应用的不同实例会处在一个竞争的消费者关系中，其中只有一个实例需要处理给定的消息，通过消费组的概念来实现这个模型。订阅给定目标的所有组都会收到一份数据副本，但每个组内只会有一个成员收到此副本。\n\n分区支持：支持在给定应用程序的多个实例之间划分数据，多个生产者实例向多个消费者实例发送数据，并确保由共同特征标识的数据由同一消费者实例处理。\n\n\n\n编程模型\n\nDestination Binders：是提供与外部消息传递系统集成的组件，负责连接、委托（delegation）和路由与生产者消费者之间的消息、数据类型转换、调用用户代码等。\n\nBindings：外部消息传递系统和应用程序提供消息的生产者和消费者之间的桥梁，Bindings的名字有几种转换生成方式（见文档）\n\n生产&amp;消费信息：\n\n概览\n\n将消息处理程序声明为Java.util.function.Function的应用程序实例，输入输出必须绑定到由提供的目标提供的destination binder暴露的公开的外部destinations\n@SpringBootApplication\npublic class MyFunctionBootApp &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(MyFunctionBootApp.class);\n\t&#125;\n    &#x2F;&#x2F;默认绑定到 toUpperCase-in-0 和 toUpperCase-out-0\n\t@Bean\n\tpublic Function&lt;String, String&gt; toUpperCase() &#123;\n\t\treturn s -&gt; s.toUpperCase();\n\t&#125;\n&#125;\n将消息处理程序声明为Java.util.function.Supplier的应用程序实例\n@SpringBootApplication\npublic static class SourceFromSupplier &#123;\n\t@Bean\n\tpublic Supplier&lt;Date&gt; date() &#123;\n\t\treturn () -&gt; new Date(12345L);\n\t&#125;\n&#125;\n将消息处理程序声明为Java.util.function.Consumer的应用程序实例\n@SpringBootApplication\npublic static class SinkFromConsumer &#123;\n\t@Bean\n\tpublic Consumer&lt;String&gt; sink() &#123;\n\t\treturn System.out::println;\n\t&#125;\n&#125;\n\n\nSuppliers(Sources)\n\n不同于Functions和Consumer由事件触发，Suppliers不订阅任何in-bound目的地，所以需要其它机制触发。框架有一个默认的拉取机制，默认情况会每秒执行一次，向output目的地发送一个消息\n可以选择每秒触发一次、总共只触发一次、触发有限次（通过Flux）\n\n\n向output发送数据\n\n标准的MVC：StreamBridge将非流应用程序和SpringCloudStream桥接\n@SpringBootApplication\n@Controller\npublic class WebSourceApplication &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(WebSourceApplication.class, &quot;--spring.cloud.stream.source&#x3D;toStream&quot;);\n\t&#125;\n\n\t@Autowired\n\tprivate StreamBridge streamBridge;\n\n\t@RequestMapping\n\t@ResponseStatus(HttpStatus.ACCEPTED)\n\tpublic void delegateToSupplier(@RequestBody String body) &#123;\n\t\tSystem.out.println(&quot;Sending &quot; + body);\n        &#x2F;&#x2F;第一次调用时家那个启动output bindings的创建\n\t\tstreamBridge.send(&quot;toStream-out-0&quot;, body);\n\t&#125;\n&#125;\n\n\n\n\n\n\n\nBinders\n\nproducer&amp;consumer：producer是向绑定目的地发送消息的任何组件；consumer是从绑定目的地接收消息的任何组件\n\nBinder SPI\npublic interface Binder&lt;T, C extends ConsumerProperties, P extends ProducerProperties&gt; &#123;\n    Binding&lt;T&gt; bindConsumer(String bindingName, String group, T inboundBindTarget, C consumerProperties);\n    Binding&lt;T&gt; bindProducer(String bindingName, T outboundBindTarget, P producerProperties);\n&#125;\nBinder Detection：\n\nSpringCloudStream依靠于Binder SPI的实现来执行将用户代码连接（绑定）到消息代理的任务。每个Binder实现通常连接同一种类型的消息传递系统\nClasspath Detection：默认依靠SpringBoot的自动配置来配置binding进程，如果classpath上发现了一个单一的Binder实现，SpringCloudStream就会自动的使用它\n\n\n\n\n\n2.RabbitMQ\nRabbitMQ Binder Overview\n默认RabbitMQ Binder将每一个destination映射到一个TopicExchange，对于每个消费组，一个队列绑定到该TopicExchange，每个消费者实例有一个对应于组队列的RabbitMQ Consumer接口。对于分区了的producers和consumers，队列是分区索引的后缀，并且用这个分区索引作为路由key。对于匿名consumers有一个自动删除队列。\n\n\n配置选项\n\n\n3.KafkaSpring SecurityTest\n工具：Postman（后端测试）&amp;Swagger（接口文档）\nSpring Boot Testing\n使用spring-boot-starter-test来测试，它包括了JUnit Jupiter、AssertJ、Hamcrest等库\n测试Spring应用：可以通过不依赖Spring直接用new来实例化对象或者用mock对象而不是真正的依赖项。Spring提供集成测试模块，能够直接向org.springframework:spring-test声明一个依赖，或者使用spring-boot-starter-test来传递它，详见Spring\n测试SpringBoot应用：\nSpringBoot提供了@SpringBootTest注解，当需要SpringBoot的特性时，他是Spring-test的@ContextConfiguration注解的替代品，这个注解会通过SpringApplication创建测试中使用的应用上下文来工作，默认是不开启服务器的，但可以通过webEnvironment来重定义：\nMOCK（默认）：加载一个Web ApplicationContext来提供一个模拟Web环境，不启动嵌入式服务器，但如果类路径上没有可用的Web环境，则此模式会回退到非Web ApplicationContext，\nRANDOM_PORT：加载一个WebServerApplicationContext并提供一个真实的Web环境。嵌入式服务器启动并侦听随机端口。\nDEFINED_PORT：加载一个WebServerApplicationContext并提供一个真实的Web环境，嵌入式服务器侦听定义的端口或默认的端口（8080）\nNONE：使用SpringApplication加载ApplicationContext但不提供任何Web环境\n\n\n@Transactional的测试，这个事务会在测试方法结束后默认回滚\n检测测试配置：@Test会自动搜索主要配置，@TestConfiguration类可以覆盖配置并通过@Import导入配置\n使用模拟（mock）环境测试：@AutoConfigureMockMvc\n模拟和窥探Beans：@MockBean用于定义一个应用上下文中的一个bean的Mockito模拟\nAuto-configured Tests：用来自动载入测试需要的程序片段，可以选择一个@…Test注释并手动包含其它片段的@AutoConfigure…注释\n\n\n\n\nActuator1. \n\nSOA1.Containers(Docker)2.Configuration Management(Ansible)3.Container Orchestration(Kubernetes)4.Infrastructure Provisioning(Terraform)5.Service Mesh(Istio/Consul)的Demo1.架构及相关技术\n简介：使用前后端分离架构，后端基于SpringBoot框架，商城系统包括：商品展示、商品搜索、商品推荐、订单流程、用户中心模块；管理系统包括商品管理、订单管理、财务管理模块。\n\n主要技术：框架方面使用SpringBoot做为应用的整体框架、SpringSecurity做为认证和授权框架、MyBatis做为ORM框架；数据存储方面使用MySQL和MongoDB分别做为SQL和NoSQL存储、使用Redis作为缓存、使用ElasticSearch做为搜索引擎、使用RabbitMQ做为消息队列、使用Druid做为数据数据库连接池；访问入口使用Nginx做为静态资源服务器、使用LogStash和Kibana进行日志的收集和查看、使用Maven和Docker打包应用。（cms_*：内容管理模块相关表、oms_*：订单管理模块相关表、pms_*：商品模块相关表）\n\n架构图概览\n\n\n","slug":"Note-Java","date":"2023-04-20T08:37:55.000Z","categories_index":"","tags_index":"","author_index":"Dajunnnnnn"},{"id":"75ca176d6b382373bec123f05862c849","title":"Java并发","content":"Java并发1.线程\n线程\n\n线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING\n\n\n线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N）\n\nJava使用用户线程模型，上层JVM通过协作式调度来管理这些用户线程，可以在一个线程执行过程中暂停切换到另一线程执行，底层JVM将Java线程映射到操作系统的线程，由操作系统调度和管理\n启动main函数时启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个（主）线程。多个线程共享进程的堆（新建的对象）和方法区资源（已加载的类信息、静态变量、常量、JIT代码），但每个线程有自己的程序计数器、虚拟机栈和本地方法栈\n多线程：减少了上下文的开销，提高了系统的并发能力，减弱IO与CPU的速度差；但会造成死锁、内存泄漏、线程不安全等问题\n\n\n线程安全\n\n线程安全：描述的对象可以是函数也可以是类，线程安全意味者不同线程并发执行相同的函数，或者不同线程执行一个类的不同函数，因为线程切换，函数内的指令都可以任意交叉执行，最终任意执行顺序得到的结果都是相同的，符合预期的\n\n临界区：可能会引起线程不安全的局部代码块，有两个特征，一是访问了共享资源、二是包含复合操作（先检查在执行、先读取再修改后写入）\n&#x2F;&#x2F;先检查再执行\npublic class Singleton &#123;\n    private static Singleton instance;\n    private Singleton()&#123;&#125;\n    public static Singleton getInstance()&#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;先读取再修改后写入\npublic class Demo &#123;\n    private int count &#x3D; 0;\n    public void increment()&#123;\n        count++;\n    &#125;\n&#125;\n同步互斥：用于保证线程安全的访问临界区资源的方法\n\n\n\n\n\n线程创建\n\n实现Runnable接口的run()和start()；继承Thread类重写run方法和start方法，==可用Thread类的已有方法==\n&#x2F;&#x2F;class ThreadDemo extends Thread &#123; 内容同下 &#125; \nclass RunnableDemo implements Runnable &#123;\n   private Thread t;\n   private String threadName;\n   \n   RunnableDemo( String name) &#123; threadName &#x3D; name; &#125;\n   \n   public void run() &#123;\n      &#x2F;&#x2F;线程内需要做的操作\n   &#125;\n   \n   public void start () &#123;\n      if (t &#x3D;&#x3D; null) &#123;\n         t &#x3D; new Thread (this, threadName);\n         t.start ();\n      &#125;\n   &#125;\n&#125;\n通过Callable接口和FutureTask类创建线程，==可创建有返回值的线程（在call函数中实现）==\npublic class CallableThreadTest implements Callable&lt;Integer&gt; &#123;\n    public static void main(String[] args)  \n    &#123;  \n        CallableThreadTest ctt &#x3D; new CallableThreadTest();  \n      \t&#x2F;&#x2F;使用FutureTask包装Callable接口的实现类\n        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);\n        for(int i &#x3D; 0;i &lt; 100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  \n            if(i&#x3D;&#x3D;20)  \n            &#123;  \n                new Thread(ft,&quot;有返回值的线程&quot;).start();&#x2F;&#x2F;call相当于run，但是有返回值  \n            &#125;  \n        &#125;  \n        try  \n        &#123;  \n            System.out.println(&quot;子线程的返回值：&quot;+ft.get());&#x2F;&#x2F;得到call函数的返回值   \n        &#125; catch (InterruptedException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125; catch (ExecutionException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n    &#125;\n    @Override  \n    public Integer call() throws Exception  \n    &#123;  \n        int i &#x3D; 0;  \n        for(;i&lt;100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  \n        &#125;  \n        return i;  \n    &#125;  \n&#125;\n==注意事项==\n\n直接使用Thread类的run方法：new一个Thread类，线程进入NEW状态，调用start方法，启动一个线程并使线程进入READY状态，当分配到时间片后就可以开始运行了，start会执行线程的相应准备工作，然后自动执行run方法的内容，这是真正的多线程工作，但是直接执行run方法，会把run方法当作一个main线程下的普通方法来执行，并不会在某个线程中执行它，所以这并不是多线程工作\nsleep与wait的区别：sleep是Thread类的静态本地方法，wait则是Object类的本地方法\nsleep方法没有释放锁，wait释放了锁\nwait是让获得对象锁的进程实现等待，会自动释放当前线程占有的对象锁，每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）\n因为Sleep是让当前线程暂停执行，不涉及到对象类，所以也不需要对象锁\n\n\nsleep常用于暂停执行，wait方法常用于线程间交互/通信\nwait方法被调用后，线程不会自动苏醒，需要notify方法或notifyAll方法，sleep执行完线程会自动苏醒，或者也可以使用wait(long timeout)超时后自动苏醒\n\n\n\n\n\n\n线程池创建\n\n线程池出现的原因：因为线程过多会增加创建、调度线程的开销，所以通过线程池提前创建若干线程，一方面避免了处理任务时频繁的，创建销毁线程的开销，另一方面避免了线程数量膨胀导致的过分调度问题，并且可以集中管理线程资源，提高系统稳定性\n\nThreadPoolExecutor\n\n基础\n\n继承链\n\nExecutor接口：声明了execute方法，使得用户不需要关注如何创建线程， 只需要传入实现了Runnable接口的线程任务类\nExecutorService接口：声明了执行一批异步生成Future的方法；声明了管控线程池的方法（关闭等方法）\nAbstractExecutorService：将执行任务的流程串联起来，保证下层的实现只需关注一个执行任务的方法\nThreadPoolExecutor：实现复杂的运行部分（维护自身的生命周期、管理线程和任务）\n\n\n参数：corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler\n\n运行状态\n\n\n\n\n池内线程创建过程：首先使用工厂函数针对新任务创建线程直到数量达到核心线程池数量，然后将新任务存储在工作队列中，待工作队列满了之后创建一个新线程来处理任务（没任务一段时间后会被销毁），直到总线程数量达到最大线程池数量后，后续的新任务根据拒绝策略来确定对应操作\n\nworker进程实现了Runnable接口继承自AQS，持有一个线程thread（通过TheradFactory来创建），一个初始化任务firstTask\n确定线程状态：线程池通过一张hash表来保存线程的引用，通过增删引用来控制线程的生命周期。因为使用了AQS锁来实现独占锁，根据独占锁的状态反应线程现在的执行状态\nworker线程增加（addWorker方法）：增加一个线程，有两个参数firstTask和core，根据core的值判断现有线程数在哪个区见\nworker线程的回收：线程池中的回收依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程倍JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可\nworker线程执行任务：worker类中的run方法调用了runWorker方法来执行任务，轮询获取任务，再获取锁，直到没有任务\n\n\n任务与线程的匹配：通过生产者消费者模型，缓存任务，供线程池针对任务进行线程的分配\n\n线程池使用AtomicInteger变量维护：运行状态（runState）和线程数量（workerCount）\n&#x2F;&#x2F;高三位保存runState，低29位保存workerCount\nprivate final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));\n\n\n\n\n示例\n\nThreadPoolExecutor\npublic class ThreadPoolExecutorDemo &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个线程池，包含5个线程\n        ThreadPoolExecutor executor &#x3D; (ThreadPoolExecutor) Executors.newFixedThreadPool(5);\n        &#x2F;&#x2F; 提交10个任务给线程池执行\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            Runnable worker &#x3D; new WorkerThread(&quot;Task &quot; + i);\n            executor.execute(worker);\n        &#125;\n        &#x2F;&#x2F; 关闭线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) &#123;\n            &#x2F;&#x2F; 等待线程池中的任务执行完毕\n        &#125;\n        System.out.println(&quot;All tasks have been completed.&quot;);\n    &#125;\n&#125;\n\nclass WorkerThread implements Runnable &#123;\n    private String taskName;\n\n    public WorkerThread(String taskName) &#123;\n        this.taskName &#x3D; taskName;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot; executing &quot; + taskName);\n        try &#123;\n            &#x2F;&#x2F; 模拟执行任务需要的时间\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\nExecutor框架的Executors\n&#x2F;&#x2F;1.创建\nExecutorService service &#x3D; Executors.newFixedThreadPool(10);\n&#x2F;&#x2F;2.执行\nservice.execute(new MyThread());\nservice.execute(new MyThread());\nservice.execute(new MyThread());\nservice.execute(new MyThread());\n&#x2F;&#x2F;3.关闭连接\nservice.shutdown();\n\n\n\n\n\n2.互斥2.1synchronized\n粒度：对象锁（this、newObject）、局部代码锁、类锁（Demo.class）\n\n静态synchronized方法和非静态synchronized方法之间的调用不互斥（一个是类的锁一个是实例对象的锁）\n\n尽量不要使用synchronized(String a)，因为JVM中，字符串常量池具有缓存功能\n\n构造方法不能使用 synchronized 关键字修饰，因为构造方法本身就属于线程安全的，不存在同步的构造方法\npublic synchronized void add(int value) &#123;&#125; &#x2F;&#x2F;方法\nsynchronized (this)&#123;&#125; &#x2F;&#x2F;局部代码块\nsynchronized (obj1) &#123;&#125; &#x2F;&#x2F;内部的一个对象 Object obj1 &#x3D; new Object()\nsynchronized (Wallet.class) &#x2F;&#x2F;类锁\n\n\n锁类别：偏向锁（一个）、轻量级锁（不竞争）、重量级锁（竞争）\n\n通过MarkWork字段辨别锁的类别，新创建的对象处于无锁状态，随后自动变为偏向锁状态，线程可以通过CAS操作竞争偏向锁（单进程使用），竞争成功则执行完任务，执行完后锁会继续保持偏向锁状态，竞争失败则请求线程将锁升级为轻量级锁\n\n升级过程先暂停（JVM的STW）持有锁进程，如其在运行synchronized代码，则升级为轻量级锁（线程交叉使用不存在竞争），否则将MarkWork设置为无锁状态（偏向锁升级代价大，不如直接升级为轻量级锁）\n\n在轻量级锁状态，如果通过（自适应）自旋方式循环执行CAS操作请求锁达到一定数量仍未获得时，就申请升级为重量级锁，唤醒等待重量级锁的进程\n\n锁升级：通过CAS操作，持有锁的线程继续执行，请求锁的线程负责升级任务，包括创建Monitor锁，将自己放到Monitor锁的_cxq中，调用OS系统调用来阻塞自己\n\n解锁：先检查锁标志位，如果没有升级，只需要使用CAS操作解锁即可；如果已升级为重量级锁，那么持有轻量级锁的线程去唤醒等待重量级锁的进程\n\nMonitor锁（hotspot）：\nclass ObjectlMonitor &#123;\n    void * volatile _object;&#x2F;&#x2F;该Monitor锁所属的对象\n    void * volatile _owner;&#x2F;&#x2F;获取到该Monitor锁的线程\n    ObjectWaiter * volatile _cxq;&#x2F;&#x2F;没有获取到锁的线程暂时加入_cxq\n    ObjectWaiter * volatile _EntryList;&#x2F;&#x2F;存储等待被唤醒的线程\n    &#x2F;&#x2F;存储调用了wait()的线程，用来实现wait()、notify()线程同步功能\n\t\t&#x2F;&#x2F;wait、notify等方法也依赖于monitor对象\n    ObjectWaiter * volatile _waitSet;\n    &#x2F;&#x2F;...\n&#125;\n\n\n多个对象通过CAS操作（底层为cmpxchg指令）竞争_owner字段，没有获取到锁的线程加入_cxq队列中等待，待锁释放先通知_EntryList队列中的线程通过CAS操作竞争_owner字段，如果_EntryList队列为空，则将_cxq队列中移到_EntryList队列（一个负责存，一个负责取，减少并发冲突）\n内核线程执行上述步骤没得到锁时，会调用Linux的park函数自行阻塞；阻塞线程获取到锁之后，调用unpark函数来取消对应内核线程的阻塞状态\n\n\n\n\n\n\n锁优化\n\n锁消除：虚拟机在执行JIT编译时，有时会根据对代码的分析(逃逸分析)，去掉某些没有必要的锁（局部变量的锁）\n锁粗化：虚拟机在执行JIT编译时，有时会扩大加锁范围，将对多个小范围代码的加锁，合并一个对大范围代码的加锁（如for循环内的锁）\n\n\n\n2.2锁\n锁类别\n\n可重入锁：可以被同一个线程多次加锁的锁，即在锁没有解锁前，再次加锁，通过变量记录重入次数，JUC提供的锁都是可重入锁\n公平锁：线程会按照请求的先后顺序获得锁。synchronized是非公平锁（新请求可插队），ReentrantLock既支持公平锁也支持非公平锁，默认为非公平锁，通过在构造函数中添加true可声明为公平锁。非公平锁的性能比公平锁更好。ReentrantLock通过AQS（抽象队列同步器）来排队等待锁的线程\n可中断锁：对于synchronized来说，一个线程在阻塞等待锁时，是无法响应中断的，即不可被打断。JUC Lock接口提供了lockInterruptibly()函数，支持可响应中断的方式来请求锁（用于线程池，关闭正在执行的线程）\n非阻塞锁：JUC提供了tryLock()函数，支持非阻塞的方式获取锁，如果锁已经被其他线程获取，则不阻塞直接返回\n可超时锁：JUC提供了带参数的tryLock()函数，支持非阻塞获取锁的同时设置超时时间，tryLock()也可被中断，主要用于对响应时间敏感的系统，如Tomcat\n读写锁：为了提到并发度，可多次获得读锁，JUC提供了ReadWrite接口和其实现类ReetrantReadWriteLock。读锁是一种共享锁，可以被多个线程同时获取，写锁是排他锁，同时只能被一个线程获取，读写锁之间也是排他的（写优先）\n乐观读锁：StampedLock是对ReadWriteLock的进一步优化，提供了读锁、写锁和乐观读锁，其中的读锁和写锁与ReadWriteLock中的类似，乐观读锁是对读锁的进一步优化，在读多写少的时候，大部分读操作都不会被写操作干扰，因此连读锁都不需要加，只有验证真正有被写操作干扰的情况下，再加读锁即可\n\n\nAQS\n\n抽象队列同步器，与synchronized底层的ObjectMonitor类相似，都实现了排队线程、阻塞线程和唤醒线程等功能，但只有一个队列，且基于Java语言实现，是锁实现的原理，在ReentrantLock类有体现（Sync、NofairSync、FairSync都继承自AbstractQueuedSynchronizer）\n\nCLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）\n\n方法\n\nAQS定义了8个模板方法，可以分为两组：独占模式（Lock）和共享模式（Semaphore）\n&#x2F;&#x2F;独占模式\npublic final void acquire(int arg) &#123; ...&#125;\npublic final void acquirelnterruptibly(int arg)throws InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)throws InterruptedException &#123; ...&#125;\npublic final boolean release(int arg) &#123; ...&#125;\n&#x2F;&#x2F;共享模式\npublic final void acquireShared(int arg) &#123; ...&#125;\npublic final void acquireSharedInterruptibly(int arg)throws InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)throws InterruptedException &#123; ...&#125;\npublic final boolean releaseShared(int arg) &#123; ...&#125;\nAQS提供了4个抽象方法：没有声明为abstract是为了减少代码量，更灵活编写代码\n&#x2F;&#x2F;独占模式\nprotected boolean tryAcquire(int arg)&#123;throw new UnsupportedOperationException();&#125;\nprotected boolean tryRelease(int arg)&#123;throw new UnsupportedOperationException();&#125;\n&#x2F;&#x2F;共享模式\nprotected int tryAcquireShared(int arg) &#123;throw new UnsupportedOperationException();&#125;\nprotected boolean tryReleaseShared(int arg) &#123;throw new UnsupportedOperationException();&#125;\n\n\n\n\nReetrantLock：定义了两个继承自AQS的子类：NofairSync和FairSync，分别用来实现非公平锁和公平锁，并且因为底层释放锁的逻辑相同，故又抽象出公共父类Sync（未完待续）\n\nReadWriteLock：读锁不可以转成写锁，但在写锁释放前加读锁，在写锁释放后线程持有的锁自动从写锁降级为读锁（未完待续）\n\nStampedLock：在读写锁的基础上提供了乐观读锁。在读多写少的情况下，大部分操作都不会被写操作干扰，只有在真正被干扰的情况下再加读锁重复执行读操作（未完待续）\n\n\n2.3补充（改成JMM？）\n关键字：volatile、synchronized、final\nvolatile：每次都去主内存读取，修改立即写入内存（c语言中的volatile的意思是禁用cpu缓存）\n解决可见性问题：用volatile修饰的变量，在编译成机器指令时，会加入特殊指令，使得CPU对此变量的修改立即写入内存，并通过其它CPU更新缓存数据\n解决有序性问题：volatile通过禁止指令重排序来解决有序性问题，并且是部分指令重排\n内存屏障：JMM定义了4个细粒度的内存屏障，其底层依赖CPU提供的内存屏障指令（StoreStore、StoreLoad、LoadLoad、LoadStore）分别禁止屏障前后的写写、写读、读读、读写操作重排\nJMM内存模型定义部分禁止重排序的方法：volatile写操作后或者volatile读操作前会添加[StoreLoad]来防止volatile写和读的重排序，一般选择添加在写后面，因为读多写少。\n\n\n解决原子性问题\n在32位计算机上，读写64位的long或double类型数据，会执行两次内存读写操作，如果用volatile修饰，那么编译器会在两次读或写之间锁定总线指令，保证变量读写的原子性，但在64位机上就不需要了\n自增语句（count++）因为是对寄存器的值进行操作，但是volatile对变量只能保证立刻写入内存让所有CPU的缓存失败，所以不能影响寄存器内的值，需要synchronized关键字\n\n\n\n\nsynchronized：通过让原本并发执行的代码串行执行，并且每次加锁和释放锁，都会同步CPU缓存和内存中的数据，可以解决可见性、有序性、原子性的问题\nfinal：JMM对final的语义做了增强，禁止编译器将构造函数中对final变量的写操作，重排序到对象引用之后，也就是禁止初始化对象（构造函数中的语句）和将内存空间赋值给引用的重排序，否则在多线程环境下，一个线程可能看到final变量的两个不同的值\n\n\nsynchronized和volatile有什么区别（互补）\nvolatile关键字是线程同步的轻量级实现，所以性能比synchronized好，但是volatile只能用于变量而synchronized可以修饰方法以及代码块\nvolatile关键字能保证数据的可见性，但不能保证数据的原子性，synchronized关键字两者都能保证\nvolatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized关键字解决的是多个线程之间访问资源的同步性\n\n\nsynchronized和ReentrantLock有什么区别\n相同点：两者都是可重入锁，即线程可以再次获取自己的内部锁，不可重入的此时会产生死锁\nReentrantLock属于可中断锁，获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理；synchronized锁属于不可中断锁，一旦线程申请了锁，就只能等到拿到锁之后才能进行其他的逻辑处理\nsynchronized依赖于JVM（用户不能直接看到代码）而ReentrantLock依赖于API（lock、unlock等方法）\nReentrantLock 比 synchronized 增加了一些高级功能，如可中断锁、公平锁、可超时锁、非阻塞锁、选择性通知（锁可以绑定多个条件）\nsynchronized需要和wait、notify结合才能实现等待/通知机制，ReentrantLock类通过Condition接口和newCondition方法实现\nCondition接口可以实现多路通知功能，也就是在一个Lock对象中可以创建多个Condition实例（对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活\n在使用notify()/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”\nsynchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题\n而Condition实例的signalAll()方法，只会唤醒注册在该Condition实例中的所有等待线程\n\n\n\n\n\n3.同步2.1条件变量\nObject类：执行wait()或notify()前先加锁、使用while循环避免假唤醒，底层依赖ObjectMonitor\npublic class QueueCond&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      this.notify();&#x2F;&#x2F;通知\n    &#125;\n  &#125;\n  \n  public String get()&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          this.wait();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;\n  &#125;\n&#125;\nCondition接口：使用前后需要lock和unlock，使用中要while，底层依赖ConditionObject（AQS的内部类）\npublic class QueueCondJUC&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  private Lock lock &#x3D; new ReentrantLock();\n  private Condition condition &#x3D; lock.newCondition();\n  \n  private void put(String elem)&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      condition.signal();&#x2F;&#x2F;通知\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n  public String get()&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          condition.await();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n&#125;\n\n2.2信号量（Semaphore）\nSemaphore类\n\n信号量与锁的区别是：释放锁的线程必须持有锁，而信号量则不用。即没有调用acquire()函数的线程也可以直接调用release()函数，用来增加可用许可个数。此时，信号量不再是用来限制对临界区的并发访问，而是用来对共享资源的并发访问\n如果信号量中的许可个数为1，那么信号量就退化成了互斥锁；如果互斥量的许可个数大于1，信号量就可以看作是一种共享锁\n\npublic class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;第一组，默认一次获取或释放的许可（permit）个数为1\n  public void acquire() throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly() &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire()&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release()&#123;&#125;\n\n  &#x2F;&#x2F;第二组，默认制定一次获取或释放的许可个数\n  public void acquire(int permits) throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly(int permits) &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire(int permits)&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(int permits, long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release(int permits)&#123;&#125;\n&#125;\n应用：共享资源并发访问控制\npublic class QueueSemaphore&#123;\n  private static final int Q_SIZE &#x3D; 20;\n  &#x2F;&#x2F;表示队列中的空闲位置\n  private Semaphore semaphore &#x3D; new Semaphore(Q_SIZE);\n  private list&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(Q_SIZE);\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    &#x2F;&#x2F;当可用许可个数为0时，线程执行put函数时会阻塞在acquireUniterruptibly()函数中\n    semaphore.acquireUniterruptibly();\n    synchronized(this)&#123;\n      list.add(count, elem);\n      count++;\n    &#125;\n  &#125;\n  public String get()&#123;\n    if(count &#x3D;&#x3D; 0) return null;\n    synchronized(this)&#123;\n      if(count &#x3D;&#x3D; 0) return null;&#x2F;&#x2F;双重检测\n      String ret &#x3D; list.get(--count);\n      semaphore.release();\n      return ret;\n    &#125;\n  &#125;\n&#125;\n原理\n\n调用semaphore.acquire()，线程尝试获取许可证，如果 state &gt;= 0的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 state的值 state=state-1。如果 state&lt;0的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程\n调用semaphore.release();，线程尝试释放许可证，并使用 CAS 操作去修改 state的值 state=state+1。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 state的值 state=state-1，如果 state&gt;=0则获取令牌成功，否则重新进入阻塞队列，挂起线程。\n\npublic class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;实现AQS，模版模式\n  private final Sync sync;\n  abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n    Sync(int permits) &#123;setState(permits);&#125;\n    protected final boolean tryReleaseShared(int releases) &#123;&#125;\n  &#125;\n\n  static final class NonfairSync extends Sync &#123;\n    NonfairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      return nonfairTryAcquireShared(acquires);\n    &#125;\n  &#125;\n  \n  &#x2F;*\n  final int nonfairTryAcquireShared(int acquires) &#123;\n    for (;;) &#123;\n      int available &#x3D; getState();&#x2F;&#x2F;许可个数存放在state变量中\n      int remaining &#x3D; available - acquires;\n      if (remaining &lt; 0 ||\n          compareAndSetState(available, remaining))\n        return remaining;\n    &#125;\n  &#125;\n  *&#x2F;\n\n  static final class fairSync extends Sync &#123;\n    fairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      for (;;) &#123;\n        if (hasQueuedPredecessors()) return -1;&#x2F;&#x2F;比NonfairSync多了这一行\n        int available &#x3D; getState();\n        int remaining &#x3D; available - acquires;\n        if (remaining &lt; 0 ||\n            compareAndSetState(available, remaining))\n          return remaining;\n      &#125;\n    &#125;\n  &#125;\n\n  public Semaphore(int permits) &#123;&#x2F;&#x2F;默认非公平模式\n    sync &#x3D; new NonfairSync(permits);\n  &#125;\n\n  public Semaphore(int permits, boolean fair) &#123;&#x2F;&#x2F;指定工作模式（公平&#x2F;非公平）\n    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);\n  &#125;\n  &#x2F;&#x2F;暂时省略核心方法的实现\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;acquireUninterruptibly()函数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;位于Semaphore.java中\npublic void acquireUninterruptibly() &#123;\n  sync.acquireShared(1);\n&#125;\n&#x2F;&#x2F;位于AbstractQueuedSynchronizer.java中\npublic final void acquireShared(int arg) &#123;\n  if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争获取许可，返回值&lt;0表示失败，需要排队等待许可\n    doAcquireShared(arg);&#x2F;&#x2F;排队等待许可\n&#125;\n&#x2F;&#x2F;其中tryAcquireShared()函数的代码实现位于NonfairSync和FairSync中，实现见上\n&#x2F;&#x2F;两种实现均通过自旋+CAS的方式获取许可，唯一区别是从等待队列中取还是可以插队\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;release()函数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n\n2.3Latch&amp;Barrier\nCountDownLatch：等其他线程结束，允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕（是一次性的，不能重复使用）\npublic class DemoJoin&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new RunnableForJoin());\n    THread t2 &#x3D; new THread(new RunnableForJoin());\n    t1.start();\n    t2.start();\n    t1.join();&#x2F;&#x2F;join只用来等待线程执行结束，并且必须知道被等待线程是谁\n    t2.join();\n  &#125;\n  public static class RunnableForJoin implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;业务逻辑\n    &#125;\n  &#125;\n&#125;\npublic class DemoLatch&#123;\n  private static final CountDownLatch latch &#x3D; new CountDownLatch(2);\n  public static void main(String[] args) throws InterruptedException&#123;\n    new Thread(new RunnableForLatch()).start();\n    new Thread(new RunnbaleForLatch()).start();\n    latch.await();&#x2F;&#x2F;等待something执行完成而非等待线程结束，并且不需要知道在等谁\n    &#x2F;&#x2F;执行后续逻辑\n  &#125;\n  public static class RunnableForLatch implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;do something\n      latch.countDown();\n      &#x2F;&#x2F;do otheer thing\n    &#125;\n  &#125;\n&#125;\nCyclicBarrier：CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活\npublic class Demo&#123;\n  &#x2F;&#x2F;创建parties为10的CyclicBarrier对象，用于10个线程之间相互等待，尽管10个线程的启动（执行\n  &#x2F;&#x2F;start函数）的时间不同，但每个线程结束都会调用await函数，将paeties减一，然后检查parties\n  &#x2F;&#x2F;如果不为0，则当前线程阻塞等待，如果parties为0，则当前线程唤醒所有调用了await函数的线程。\n  private static final CyclicBarrier barrier &#x3D; new CyclicBarrier(10);\n  public static void main(String[] args)&#123;\n    for(int i&#x3D;0; i&lt;10; ++i)&#123;\n      new Thread(new Runnbale()&#123;\n        @Override\n        public void run()&#123;\n          try&#123;\n            barrier.await();\n          &#125;catch(InterruptedException e)&#123;&#x2F;&#x2F;当前线程被中断\n            e.printStackTrace();\n          &#125;catch(BrokenBarrierException e)&#123;&#x2F;&#x2F;其他线程调用await()期间被中断\n            e.printStachTrace();\n          &#125;\n          &#x2F;&#x2F;执行业务逻辑\n        &#125;\n      &#125;).start();\n    &#125;\n    &#x2F;&#x2F;主线程需要等待以上10个线程执行结束，方法有以下3种：\n    &#x2F;&#x2F;1.sleep() 2.join() 3.CountDownLatch()\n  &#125;\n&#125;\n\n4.JUC1.并发阻塞（xxxBlockingQueue）\n\n\n\n\n\n\n\n\n线程安全和支持读写阻塞，阻塞并发队列一般用于实现生产者-消费者模型\n\nxxxBlockingQueue：ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue的实现原理类似，都是基于ReentrantLock锁来实现线程安全，基于Condition条件变量来实现阻塞等待\nArrayBlockingQueue：有界队列实现类，底层采用数组来实现，一旦创建容量不能改变\n使用方法和普通队列类似，只不过增加了读写可阻塞，支持公平和非公平两种工作模式，默认为非公平\n支持读写阻塞的put和take函数（ReentrantLock+Condition）\n非阻塞的offer和poll函数，只通过ReentrantLock锁来保证线程安全，没有通过条件变量来实现阻塞读写\n\n\nLinkedBlockingQueue：基于链表实现的有界阻塞并发队列，默认大小为Integer.MAX_VALUE，可以指定队列大小\nLinkedBlockingDeque：与LinkedBlockingQueue的区别在于，它是一个双端队列，支持两端读写操作\nPriorityBlockingQueue：是一个无界阻塞并发优先级队列，底层基于支持扩容的堆来实现，写操作永远不需要阻塞，只有读操作会阻塞，不可插入null值且插入对象必须可比较大小（comparable）\n\n\nDelayQueue\n延迟阻塞并发队列，底层基于PriorityQueue来实现，因为PriorityQueue支持动态扩容，所以DelayQueue为无界队列，写永远都不会阻塞，只有读会阻塞\nDelayQueue中存储的每个元素都必须实现Delayed接口，提供延迟被读取时间delayTime，PriorityQueue按照delayTime的大小将元素组织成最小顶堆，也就是说，堆顶的元素是delayTime最小的元素，应该最先被读取到\ntake函数，包含两个逻辑，针对leader线程的逻辑和针对非leader线程的逻辑。当多个线程先后调用take函数，第一个线程就是leader线程，剩下的就是非leader线程。第一个线程执行读取操作完成之后，第二个线程便称为leader线程。\n非leader线程直接调用await函数阻塞，等待leader线程执行完成之后调用signal来唤醒\nleader线程读取的是队首的元素，如果队首的元素delayTime大于0，那么leader线程会调用awaitNanos阻塞delayTime时间，当delayTime时间过去之后，leader线程自动唤醒，为了避免假唤醒（插队情况见下），leader线程会检查队首元素的delayTime是否真正变为小于等于0，如果是，则队首元素出队，调用signal唤醒第二个线程，第二个线程就成了leader线程\n插队情况：如果一个线程执行take函数时，如果检查发现队列不为空，并且队首元素的delayTime小于等于0，于是，不管是不是有其他线程在调用await或awaitNanos阻塞等待，这个线程都会直接读取队首元素并返回\n\n\n\n\n较少使用\nSynchronousQueue：用于两个线程之间传递数据，每个put操作必须阻塞等待take操作，队列中不存储任何元素\nLinkedTransferQueue：基于链表实现的无界阻塞并发队列，是LinkedBlockingQueue和SynchronousQueue的综合体，提供了transfer函数，跟SynchronousQueue的put函数的功能相同，调用transfer的线程会一直阻塞，直到数据被其他线程消费才会返回\n\n\n\n2.分段加锁（ConcurrentHashMap）\n原理\n底层数据结构：ConcurrentHashMap底层采用数组+链表/红黑树（1.7使用分段数组+链表）\n实现线程安全的方式\nJDK1.7的ConcurrentHashMap：对整个桶数组进行分割分段，每一把锁只锁其中的一部分数据，多线程访问不同段的数据就不会产生锁竞争\nJDK1.8的ConcurrentHashMap：直接用Node数组+链表/红黑树来实现，并发控制使用synchronized和CAS来操作\nTreeNode是存储红黑树节点，被TreeBin包装，TreeBin通过root属性维护红黑树的根节点，因为红黑树在旋转的时候，根节点可能会被它原来的子节点替换掉，在这个时间点如果有其他线程要写这颗红黑树就会产生线程不安全问题，所以在ConcurrentHashMap中TreeBin通过waiter属性维护当前使用这颗红黑树的线程，来防止其他线程的进入\n\n\nConcurrentHashMap比HashTable效率高的原因：ConcurrentHashMap中，table数组被分段加锁，如果table数组的大小为n，那么就对应存在n把锁，每一个链表独享一把锁，不同链表之间的操作可以多线程并行执行，互不影响，以此来提高并发性能。而HashTable使用synchronized（同一把锁）来保证线程安全，效率低，当一个线程使用put时，另一个线程既不能使用put，也不能使用get\n\n\nConcurrentHashMap类（未完待续）\n\n3.写时复制（CopyOnWriteArrayList、CopyOnWriteArraySet）\n主要应用于并发容器中，为了避免读操作和写操作（增、删、改）同时发生而产生的线程安全问题，写时复制将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作，而对读操作继续在原始容器上进行，这样读写之间不会存在数据访问冲突，当写操作执行完成后，新创建的容器替代原始容器\n这样读操作完全不需要加锁，写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待\n\n\n弱一致性：CopyOnWriteArrayList源码显示，写操作的结果并非对读操作立即可见，这就导致了短暂的数据不一致，称为弱一致性，在某些业务场景下，会引发bug\n解决办法：CopyOnWriteArrayList提供了用于遍历容器的迭代器\n\n\n连续存储：JUC提供了CopyOnWriteArrayList、CopyOnWriteArraySet，却没有提供CopyOnWriteLinkedList、CopyOnWriteHashMap等其他类型的写时复制容器的原因：因为执行写操作需要复制整个数据，对于链表和哈希表来说，因为数据在内存中不是连续存储的，所以耗时非常大，写操作的性能无法满足工业级通用类对性能的要求。CopyOnWriteArrayList、CopyOnWriteArraySet底层都是基于数组来实现的，而且使用了JVM底层提供的native方法，通过C++代码中的指针实现了内存块的快速拷贝\n\n5.无锁编程\nCAS：CAS指的是先检查后更新这类复合操作，全称为Compare And Set或Compare And Swap。在CAS操作失败后，可以选择自旋直到CAS成功 或 执行失败处理相关的业务逻辑\n原子类：原子类的每个操作都可以看成是原子操作，在多线程环境下，执行原子类的操作不会出现线程安全问题\nLongAdder：（未完待续）\nThreadLocal：使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全。其作用域范围介于类的成员变量和函数内局部变量之间，既是线程私有的，又可以在函数之间共享，不但避免了线程安全问题，还能避免参数传递带来的代码耦合问题\nUnsafe类：（未完待续）\nFuture类：（未完待续）\n\n","slug":"Java并发","date":"2023-04-13T23:56:43.000Z","categories_index":"","tags_index":"java","author_index":"Dajunnnnnn"},{"id":"b4296f0600f693552b5b6c6b665f6025","title":"Java特性","content":"Java1.关键字\ntrue, false, 和 null 虽然不是关键字，但它们是不能用作标识符的文字和保留字\nstrictfp（精确浮点数，跨平台产生相同结果）、native（原生方法）\n\n\n\n\n\nclass\nreturn\nbyte\ntry\nif\n\n\n\nimport\npublic\nboolean\ncache\nelse\n\n\nextends\nprotected\nshort\nfinally\nfor\n\n\nimplements\nprivate\nint\nthrow\nwhile\n\n\nenum\n==final==\nchar\nthrows\ndo\n\n\ninterface\n==static==\nlong\nresource\nswitch\n\n\npackage\nabstract\nfloat\n==volatile==\ncase\n\n\nnew\nnative\ndouble\n==synchronized==\ndefault\n\n\nsuper\nconst\nvoid\n==transient==\nbreak\n\n\nthis\ngoto\ninstanceof\nstrictfp\ncontinue\n\n\n2.概念辨析\n值传递与引用传递\n\n引用类型（数组、接口、类）的数据存储在堆上，栈上存储的是堆的地址，直接更改对象对所有引用都可见，但不能像C++那样让引用指向新的对象\n引用数据判等：==判断两个引用是否指向同一对象，equals方法+重写的hashcode方法判断属性是否相等\n\n\n深拷贝、浅拷贝、引用拷贝\n\n深拷贝与浅拷贝：深拷贝会复制整个对象，包括对象包含的内部对象；浅拷贝会在堆上创建一个新对象，但是对象内部引用类型变量只会复制引用地址，不会直接复制内部数据\n\n引用拷贝：两个不同引用指向同一对象\n\n示例\npublic class Address implements Cloneable&#123;\n    private String name;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Address clone() &#123;\n        try &#123;\n            return (Address) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n\npublic class Person implements Cloneable &#123;\n    private Address address;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Person clone() &#123;\n        try &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;浅拷贝\n            Person person &#x3D; (Person) super.clone();\n            return person;\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;浅拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; true\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());\n\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;深拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@Override\npublic Person clone() &#123;\n    try &#123;\n        Person person &#x3D; (Person) super.clone();\n\t\t\t\t&#x2F;&#x2F;深拷贝\n        person.setAddress(person.getAddress().clone());\n        return person;\n    &#125; catch (CloneNotSupportedException e) &#123;\n        throw new AssertionError();\n    &#125;\n&#125;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; false\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());\n\n\n重载和重写的区别\n\n重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理（如构造函数）；重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法（如Override）\n如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的\n\n\n接口和抽象类\n\n共同点：都不能被实例化、都可以包含抽象方法，都可以有默认实现方法（default声明，子类可不实d现）\n不同点：\n接口主要是对API声明（参数类型、返回值类型、函数名），抽象类主要是为了代码复用\n一个类可以实现多个接口，但只能继承自一个抽象类\n接口中的成员变量只能是public static final类型的，不能被修改且必须有初始值，而抽象类的成员变量默认default，可在子类中被重新定义，也可被重新赋值\n\n\n\n\nfinal和static\n\n只有成员变量能被static、public、protected、private修饰，局部变量不行，但是两者都能被final修饰\n\n\n引用类型转换：仅限于有继承关系的类之间，分为向上转换和向下转换两种\n\n向上转换，自动类型转换，总是可以的\n向下转换需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已\n\n\n\n3.语法糖\nswitch支持String与枚举：int比数、char比ascii码、字符串用hashCode()和equals()，其它如short、byte、int都需要转换为整数\n\n泛型和类型擦除：编译时会使用泛型做类型检查，但是当代码编译为字节码之后，泛型中的类型参数和通配符都替换为上界限（==类型擦除==）\n\n泛型遇到重载：因为都会转成父类型，所以List&lt;String&gt;和List&lt;Integer&gt;这种重载会编译失败\n\n当泛型遇到catch：泛型的类型参数不能用在catch语句中，因为异常处理是由JVM在运行时刻来进行的，类型信息被擦除了，所以JVM是无法区分两个异常类型MyException&lt;String&gt;和MyException&lt;Integer&gt;的\n\n创建对象时：不能使用new T()来创建类型参数对象，在代码编译成字节之后类型信息已经擦除，所以，在运行时，JVM无法确定具体类型，也就无法知道T是否存在无参构造函数\n\n当泛型内包含静态变量：由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的\npublic class StaticTest&#123;\n    public static void main(String[] args)&#123;\n        GT&lt;Integer&gt; gti &#x3D; new GT&lt;Integer&gt;();\n        gti.var&#x3D;1;\n        GT&lt;String&gt; gts &#x3D; new GT&lt;String&gt;();\n        gts.var&#x3D;2;\n        System.out.println(gti.var); &#x2F;&#x2F;输出为2\n    &#125;\n&#125;\nclass GT&lt;T&gt;&#123;\n    public static int var&#x3D;0;\n    public void nothing(T x)&#123;&#125;\n&#125;\n因为需要继承自Object，所以基本类型不可以传入类型参数，只有引用类型可以。但是有语法糖可以让List&lt;int&gt;中的int替换为Integer，但是开发上依旧需要为每个基本类型分别定义多个不同的函数接口\n\n\n\n自动装箱与拆箱：原始类型byte, short, char, int, long, float, double, boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean\n\n基本类型和包装类型的区别：包装类型不赋值时是null，可用于范型，占用空间大\n\n基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 static 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中（JIT优化，逃逸分析，分配到栈上）\n基本数据类型存放在栈中是一个常见的误区！基本数据类型的成员变量如果没有被 static修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中\n类静态成员变量存放在方法区中！（方法区又叫静态区，跟堆一样，被所有线程共享，方法区包含所有的class和static变量）\n\n\n常量池\n\nInteger等包装类使用了常量池技术，IntegerCache类（享元模式）中会缓存值为-128到127之间的Integer对象，当通过自动装箱，也就是调用valueOf()来创建Integer对象时，如果要创建的Integer对象的值在-128到127之间，会从IntegerCache中直接返回，否则才会真正调用new方法创建，详见Integer类的valueOf()（JVM也提供了方法，可以自定义缓存的最大值）\n\nByte、Short、Integer、Long这四种包装类默认创建了数值[-128,128]的相应类型的缓存数据（存放在一个Cache数组中，由static代码块直接初始化），Character创建了数值在[0，127]范围的缓存数据，Boolean直接返回True或False（return (b ? TRUE : FALSE);）\n\n所有整型包装类对象之间值的比较，全部使用 equals 方法比较\nInteger i1 &#x3D; 40; &#x2F;&#x2F;触发自动装箱，使用缓存中的对象\nInteger i2 &#x3D; new Integer(40); &#x2F;&#x2F;新创建的对象\nSystem.out.println(i1&#x3D;&#x3D;i2); &#x2F;&#x2F;返回false\n\n\n示例代码：项目首选基本类型，业务相关可选包装类用null表示空而不是0\n&#x2F;&#x2F;自动装箱，语法糖，底层实现为：Integer iobj &#x3D; Integer。valueOf(12);\nInteger iobj &#x3D; 12;\n&#x2F;&#x2F;自动拆箱，语法糖，底层实现为：int i &#x3D; iobj.intValue();\nint i &#x3D; iobj;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;触发自动装箱和拆箱的几种情况&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;将基本类型数据赋值给包装类变量（包括参数传递）时，触发自动装箱\nint i1 &#x3D; 5\nInteger iobj1 &#x3D; 5;&#x2F;&#x2F;1\niobj &#x3D; i1;&#x2F;&#x2F;1\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(i1);&#x2F;&#x2F;1\n&#x2F;&#x2F;将包装类对象赋值给基本类型变量（包括参数传递）时，触发自动拆箱\nInteger iobj2&#x3D; new Integer(6);\nint i2 &#x3D; iobj2;&#x2F;&#x2F;2\n&#x2F;&#x2F;当包装类对象参与算术运算、关系运算（&lt;,&gt;）时，触发自动拆箱操作\nInteger iobj3 &#x3D; iobj1 + iobj2;\nboolean bl &#x3D; (iobj1 &lt; iobj2);\nbl &#x3D; (iobj1 &lt; 2);\n&#x2F;&#x2F;当包装类对象参与关系运算（&#x3D;&#x3D;），且另一方是基本类型数据时，触发自动拆箱操作。\nInteger iobj4 &#x3D; new Integer(123);\nbl &#x3D; (iob4 &#x3D;&#x3D; 123);\n\n\n方法变长参数：String… args用一个数组实现，用foreach遍历，编译后会被转变成数组\n\n枚举：当我们使用enum来定义一个枚举类型的时候，编译器会自动创建一个final类型的类继承Enum类，所以枚举类型不能被继承（public enum t&#123;&#125; =&gt; public final class T extends Enum&#123;&#125;）\n\n内部类：\n\n会独立于外部类，生成一个新的class文件，名字为外部类名$内部类名.class或外部类名$[序号].class，静态匿名内部类可访问静态成员变量+静态函数；普通匿名内部类不可访问外部函数中非final修饰的局部变量\n外部函数通过类似参数传递的方式，将局部变量通过值传递的方式传入到匿名内部类，这是外部函数局部变量的副本，所以如果能访问非final修饰的局部变量的话，内部类对其的更改不起作用，违反直觉，类似于形参的改变不影响实参\n\npublic interface I&#123;&#125;\npublic class A&#123;\n    private class B&#123;&#125; &#x2F;&#x2F;类似于ArrayList的内部类Itr\n    private class C implements I&#123;&#125;&#x2F;&#x2F;实现外部接口的内部类\n    public class D&#123;&#125;&#x2F;&#x2F;public修饰的内部类\n\t\tpublic static class E&#123;&#125;&#x2F;&#x2F;静态内部类\n    \n    public B getB()&#123; return new B(); &#125;\n    public I getC()&#123; return new C(); &#125;\n    public D getD()&#123; return new D(); &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.B b &#x3D; a.getB();&#x2F;&#x2F;编译报错，满足封装原则\n        I c &#x3D; a.getC();&#x2F;&#x2F;可访问\n        A.D d1 &#x3D; a.getD();\n        A.D d2 &#x3D; a.new D();\n\t\t\t\tA.E e &#x3D; new A.E();&#x2F;&#x2F;静态内部类的对象可以独立于外部类单独创建\n    &#125;\n&#125;\n条件编译：if的条件是final且为false时，对应代码块不被编译，主要出于对代码优化的考虑\n\n断言：其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行\n\n数值字面量：不管是整数还是浮点数，都允许在数字之间插入任意多个下划线，为了方便阅读\n\n增强for循环：for-each用了普通的for循环和Iterator迭代器的hasNext()方法，在遍历过程中不能增删内部元素，会抛出异常（可以使用Iterator.remove()方法在删除当前迭代对象的同时维护索引的一致性）\n\ntry-with-resource：在try()中写资源申请，就不用在finally中判断是否为null在关闭了，编译期帮助我们关闭了（资源类需要实现Java.lang.AutoClosale接口）\n\nlambda表达式：只有一个函数的接口叫做函数式接口，可以用Lambda表达式简化\n\nLambda表达式\n(类型 a,类型 b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\n(a,b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\na-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a为输入参数\n&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;没有入参\n方法引用：当Lambda中的逻辑已经有现成的方法实现时，可以直接使用方法引用。方法引用要求所引用的方法的参数列表的返回值，跟函数接口中未实现方法的参数列表和返回值完全一致，格式如下\n&#x2F;&#x2F;对象::实例方法\n&#x2F;&#x2F;类::静态方法\n&#x2F;&#x2F;类::实例方法\npublic class FPDemo &#123;\n    public static void main(String] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n\t\t\t\t\t\t&#x2F;&#x2F;直接引用String的方法\n            .filter(((Predicate&lt;String&gt;) String::isEmpty).negate())\n            &#x2F;&#x2F; .filter(s-&gt;s.isEmpty())\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            .map(String::length)\n            &#x2F;&#x2F;.map(s-&gt;s.length())\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;\n\n\n\n4.特殊语法\n反射：在运行的过程中动态告知JVM去创建对象、创建方法、获取类信息（构造函数、方法、成员变量、注解），重要应用见Spring框架的依赖注入\n\nClass类：是一个存储类的信息的特殊的类，提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等\n\nConstructor类：用来存储构造函数的信息，如通过newInstance()方法来进行有参/无参构造\nMethod类：存储方法的信息，如通过invoke()方法可以执行类中的对应方法\nField类：用来存储成员变量的信息\n\n\n获取反射的三种方法\n\n通过对象获取反射\nObject obj &#x3D; new Object(); &#x2F;&#x2F; 创建一个对象\nClass&lt;?&gt; clazz &#x3D; obj.getClass(); &#x2F;&#x2F; 获取 Class 对象\n通过类名获取反射\nClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.example.MyClass&quot;); &#x2F;&#x2F; 获取 Class 对象\n通过类字面常量获取反射\nClass&lt;?&gt; clazz &#x3D; MyClass.class; &#x2F;&#x2F; 获取 Class 对象\n\n\n反射攻击：在Constructor、Method、Field类，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限public void setAccessible(boolean flag)，利用这个方法，可以将私有的构造函数、方法、成员变量设置为可以访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量（打破单例类只能实例化一个对象的限制的情况）\n\n\n\n注解：注解相当于给元素打了一个tag，任何编译器或者应用程序通过反射可以访问的代码元素，都可以用注解去标识\n\n自定义注解：通过反射来读取注解，重要应用为Spring用注解代替XML配置文件\n&#x2F;&#x2F;Java内建注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override &#123;\n&#125;\n\n&#x2F;&#x2F;自定义注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimit &#123;\n\tpublic enum TimeUnit &#123; SECOND,MINUTE, HOUR, DAY,MONTH&#125;\n    string apiName();\n\tint limitCount();\n\tTimeUnit timeUnit() default TimeUnit.SECOND;\n&#125;\n元注解\n\n@Target：用来描述注解的使用范围（如类、接口、方法、成员变量等）\n@Retention：用来描述注解的可见范围、或叫生命周期（如源码可见、字节码可见、运行时可见）\n@Documented：表示注解信息会输出到Javadoc文档中\n@interface：class、interface、enum、@interface这四者是平级关系，@interface用来定义注解，在注解中，还可以定义一些变量，特殊的是注解使用方法来定义变量，对于只有一个变量的注解，可以将其定义为value，这样，在使用时，可以不指定变量的名称\n\n\n实践应用\n\n替代注释：Guava提供@VisibleForTesting注解在方法上进行标记，这个注解只起到注释的作用，并没有实际的作用\n作为标记：Java中有一种特殊的接口，叫做标记接口（Marker Interface）。标记接口中不包含任何方法，跟注解类似，起到标记作用，比如RandomAccess、Cloneable、Serializable，可以根据标记接口判断对象是否可以执行某些操作\n替代XML文件\n@Configuration注解修饰的类中的@Bean创建首字母小写的对象\n@Component注解创建同名对象，使用@Autowired注入对象\n\n\n\n\n\n\n动态代理（==未完待续==）\n\n静态代理：通过实现接口或继承的方式，通过注入原始类并添加新功能的方式实现。实现简单，但会导致项目中的类成倍增加，所有相关的类都需要增加代理类，重复代码多\n动态代理\n一般静态指的编译阶段，动态指的运行阶段。在代理模式上，静态代理指的是在编译阶段时生成代理类的字节码，动态代理指的是运行时生成代理类的字节码，且字节码只存在与内存中，并不会生成对应的class文件\n之所以可以实现动态代理，是因为JVM设计得非常灵活，只要是符合类的格式的字节码，都可以在运行时被JVM解析并加载，不管这个字节码是来自预先编译好的(class文件)，还是在内存中临时生成的(典型应用:动态代理)，又或者从网络加载而来的(典型应用: Applet)。这部分内容涉及到JVM的类加载机制，见JVM\n实现方法一：利用JDK提供的类来实现（InvocationHandler接口+Proxy类）\n实现方法二：使用第三方的字节码类库来实现，比如CGLIB、BECL、ASM、Javassit等直接编辑字节码\n\n\n\n\n\n\n\n5.工具类5.1String\nString不可变的原因\nfinal修饰的数组，数组内容是可变的private final char value[];\n但是String没有暴露更改该数组的公共方法\n因为String类是final修饰的，所以子类无法继承，避免了子类破坏String的不可变性\n\n\n常量池技术\nString类型跟Integer等包装类类似，使用常量池技术，并且==只有使用字符串常量赋值时，才触发==，如果字符串常量在常量池中已经创建过，则直接使用已经创建的对象。用new创建的对象不在常量池中\n除了使用字符串常量赋值外，还可以使用intern()方法，将分配在堆上的String对象，原模原样在常量池中复制一份。当无法用字符串常量赋值，但又有大量重复字符串时，就可以使用intern()方法复制到常量池中，代码中使用常量池中的String对象，原String对象就被JVM回收掉\n\n\n其它\nsubstring()\nsubstring(int beginIndex, int endIndex)方法截取并返回下标在[beginIndex, endIndex)范围内的子串\n在JDK7及其以上版本中，substring()方法会生成新的String对象来存储子串，但如果传入参数正好等于字符串的长度，那么会返回字符串本身，不会创建新对象\n在JDK6及以前的版本，通过substring()方法获取到的子串会共享char数组，并有count和offset属性标志子串的长度和起点\n\n\n运算符重载：C++能直接重载运算符，但Java并不支持（重载运算符是函数式编程、并且语法太复杂），但是String类却实现了加法操作String sc = sa + sb;，主要是因为String比较常用，所以延续了基本类型及其包装类的设计，这样使用起来就方便和统一\nStringBuilder与StringBuffer\n因为String不可变，用+拼接效率低，每次都需要创建新的String对象，所以Java设计了StringBuilder\nStringBuilder支持修改和动态扩容，可以用append()函数拼接，可以把StringBuilder看作是char类型的ArrayList（ArrayList）\n在平时开发中，经常用+号连接多个字符串，实际上底层就采用StringBuilder来实现\nStringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。\n相同情况下使用 StringBuilder相比使用 StringBuffer仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n\n\n\n\n\n5.2JCF框架\nArrayList动态扩容：在增加元素的时候要检测是否需要扩容，首先确定最小扩容量（最小是10），然后判断是否需要扩容（最小扩容量大于当前数组长度），执行grow函数进行扩容，扩容为原来的1.5倍，如果不够的话就直接使用最小扩容量来作为长度，避免多次扩容，若是1.5倍长度大于数组最大长度，则需要看最小扩容量是否大于最大容量，如果是则为MAX_VALUE否则为MAX_VALUE-8\npublic boolean add(E e) &#123;\n    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!\n    elementData[size++] &#x3D; e;\n    return true;\n&#125;\n\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;确定是否需要扩容，主要用在添加大量元素之前，减少增量分配的次数，通过提前扩容，可以提升性能&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic void ensureCapacity(int minCapacity) &#123;\n    int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n        &#x2F;&#x2F; any size if not default element table\n        ? 0\n        &#x2F;&#x2F; larger than default for default empty table. It&#39;s already\n        &#x2F;&#x2F; supposed to be at default size.\n        : DEFAULT_CAPACITY;\n\t\t&#x2F;&#x2F;如果期待最小容量大于已有的最大容量\n    if (minCapacity &gt; minExpand) &#123;\n        ensureExplicitCapacity(minCapacity);\n    &#125;\n&#125;\n&#x2F;&#x2F;得到最小扩容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) &#123;\n    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    &#125;\n    return minCapacity;\n&#125;\n&#x2F;&#x2F;得到最小扩容量，通过最小扩容量扩容\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n&#x2F;&#x2F;判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) &#123;\n    modCount++;\n\n    &#x2F;&#x2F; overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n\t\t\t\t&#x2F;&#x2F;调用grow方法进行扩容，调用此方法代表已经开始扩容了\n        grow(minCapacity);\n&#125;\nprivate void grow(int minCapacity) &#123;\n    &#x2F;&#x2F;oldCapacity为旧容量，newCapacity为新容量\n    int oldCapacity &#x3D; elementData.length;\n    &#x2F;&#x2F;将oldCapacity 右移一位，其效果相当于oldCapacity &#x2F;2，\n    &#x2F;&#x2F;我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);\n    &#x2F;&#x2F;然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity &#x3D; minCapacity;\n    &#x2F;&#x2F;再检查新容量是否超出了ArrayList所定义的最大容量，\n    &#x2F;&#x2F;若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n    &#x2F;&#x2F;如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为MAX_ARRAY_SIZE。\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity &#x3D; hugeCapacity(minCapacity);\n    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:\n    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n&#125;\n&#x2F;&#x2F;比较minCapacity和MAX_ARRAY_SIZE\nprivate static int hugeCapacity(int minCapacity) &#123;\n    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n&#125;\nHashMap\n\nSet容器包括HashSet、LinkedHashSet、TreeSet，从代码实现上来说，这三个类底层分别是依赖HashMap、LinkedHashMap、TreeMap。例如：往HashSet中存储对象obj，底层将obj作为key，一个空的Object对象作为value，一并存储到HashMap中\n\n底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）\n&#x2F;&#x2F; 包含另一个“Map”的构造函数\n public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);&#x2F;&#x2F;下面会分析到这个方法\n &#125;\nfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;\n    int s &#x3D; m.size();\n    if (s &gt; 0) &#123;\n        &#x2F;&#x2F; 判断table是否已经初始化\n        if (table &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-size\n            &#x2F;&#x2F; 未初始化，s为m的实际元素个数\n            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;\n            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            &#x2F;&#x2F; 计算得到的t大于阈值，则初始化阈值\n            if (t &gt; threshold)\n                threshold &#x3D; tableSizeFor(t);\n        &#125;\n        &#x2F;&#x2F; 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s &gt; threshold)\n            resize();\n        &#x2F;&#x2F; 将m中的所有元素添加至HashMap中\n        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;\n            K key &#x3D; e.getKey();\n            V value &#x3D; e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        &#125;\n    &#125;\n&#125;\n哈希函数\nstatic final int hash(Object key) &#123;\n    int h;\n\t\t&#x2F;&#x2F;key为null的值存储在下标为0的位置，但一个HashMap只能存储一个值为null的key\n\t\t&#x2F;&#x2F;hashCode底层为JNI，定义在Object类中，根据对象在内存中的地址来计算哈希值，子类中可以重写\n\t\t&#x2F;&#x2F;h^(h&gt;&gt;&gt;16)：数组长度一般不超过2^16，所以通过将h的高16位和低16位异或，来增加参与运算的信息\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n&#x2F;&#x2F;确定插入数组时的位置，使用位操作与数组长度n进行取模计算（前提是n为2的幂次方），防止索引越界\nint index &#x3D; hash(key)&amp;(n-1); &#x2F;&#x2F; n-1为 11111，与其进行&amp;运算，相当于对n取余数\n\npublic V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;&#x2F;&#x2F; hash表不为空，待查找链表有值\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node，先查hash(key)，再查key.equals()\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;检测是否哈希冲突\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            if (first instanceof TreeNode) &#x2F;&#x2F;已经树化，进行树上的查找\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);&#x2F;&#x2F;未树化，进行链表上的遍历查找\n        &#125;\n    &#125;\n    return null;\n&#125;\n装载因子：table大小（n）和装载因子（loadFactor）可以用默认的也可以通过构造函数传入，一般为0.75：\n\n权衡时间效率和空间效率之后的结果\n大概是[0.5,1]之间，因为小于0.5会有一半空间从来未用，当大于1时，哈希冲突的概率会大大增加，即使有链表和树化，也会影响性能\n因为table数组的大小n都是2的倍数，而且触发扩容的阈值threshold = n * loadfactor，所以，在[0.5,1]之间，只有0.75能使得得到的阈值一直是整数\n\npublic HashMap(int initialCapacity, float loadFactor) &#123;\n\t\t&#x2F;&#x2F;...initialCapacity和loadFactor的可行性检验代码...\n    this.loadFactor &#x3D; loadFactor;\n\t\t&#x2F;&#x2F;直接赋值的原因：此时table数组只声明未创建，其值为null，在第一次调用put()函数后，\n\t\t&#x2F;&#x2F;HashMap会先用threshold作为数组大小创建table数组，再将其重新赋值为真正的扩容阈值\n\t\t&#x2F;&#x2F;this.table &#x3D; new T[this.threshold];\n\t\t&#x2F;&#x2F;this.threshold *&#x3D; this.factor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);\n&#125;\n&#x2F;&#x2F;initialCapacity需要是2的幂次方，如果不是，需要寻找比initialCapacity大的第一个2的幂次方数\nstatic final int tableSizeFor(int cap) &#123; &#x2F;&#x2F; 1100  12 应该返回 10000\n    int n &#x3D; cap - 1; &#x2F;&#x2F; 1011\n    n |&#x3D; n &gt;&gt;&gt; 1; &#x2F;&#x2F; 0101 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 2; &#x2F;&#x2F; 0011 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 4; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 8; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 16; &#x2F;&#x2F; 0000 - 1111\n    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#x2F;&#x2F; 10000 16\n&#125;\n动态扩容：put后，若元素个数超过threshold=n*loadFactor时触发（n为table大小，loadFactor为装载因子）\n\nHashMap的默认初始化大小为16，之后每次扩充容量为原来的2倍，如果指定了大小，也会选择2的幂次来作为初始值\n因为Hashmap的容量大小是2的幂次方，所以可以通过&amp;运算来优化%运算。例如：（16 % 5 ）等价于 （16 &amp; （5 - 1））\n为了能把数据分配均匀，Hash值的范围是-2147483648 到 2147483647，很难碰撞，但是需要对数组取模，操作如上\n\n\n因为容量变大，位置会发生变化，将每个节点的hash值与新的容量取模，取模操作仍可以用位运算来替代，但JDK8中优化为：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）\n扫描table数组中的每一条链表，根据节点的下标是否更改，将链表中的节点分配到lo链表和hi链表，lo链表中存储的是下标值未变的节点，hi链表存储的是下标值有所改变的节点。处理完一条链表后，将lo链表和hi链表分别存储到新的table数组中的对应位置\n\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;使用resize创建新table\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)&#x2F;&#x2F;数组中链表头不存在，初始化\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123;&#x2F;&#x2F;数组中插入位置有链表头，遍历\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;先检查第一个节点\n            e &#x3D; p;&#x2F;&#x2F;找到\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;遍历链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;没找到，新建节点\n                    p.next &#x3D; newNode(hash, key, value, null);\n\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F;树化？红黑树转换，并不会直接转换成红黑树\n                    break;\n                &#125;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#x2F;&#x2F;找到\n                    break;\n                p &#x3D; e;&#x2F;&#x2F;继续遍历\n            &#125;\n        &#125;\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;&#x2F;&#x2F;更新值\n            afterNodeAccess(e);&#x2F;&#x2F;见LinkedHashMap\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);&#x2F;&#x2F;见LinkedHashMap\n    return null;\n&#125;\n\nfinal Node&lt;K,V&gt;[] resize() &#123;\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    int newCap, newThr &#x3D; 0;\n    if (oldCap &gt; 0) &#123;\n        &#x2F;&#x2F; 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 没超过最大值，就扩充为原来的2倍\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold\n        newCap &#x3D; oldThr;\n    else &#123;\n        &#x2F;&#x2F; signifies using defaults\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    &#x2F;&#x2F; 计算新的resize上限\n    if (newThr &#x3D;&#x3D; 0) &#123;\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)\n        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab;\n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 把每个bucket都移动到新的buckets中\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                oldTab[j] &#x3D; null;\n                if (e.next &#x3D;&#x3D; null)\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123;\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        &#x2F;&#x2F; 原索引\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        &#x2F;&#x2F; 原索引+oldCap\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    &#x2F;&#x2F; 原索引放到bucket里\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    &#x2F;&#x2F; 原索引+oldCap放到bucket里\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;\n链表树化：降低单个链表长度（jdk1.8新增的特性，1.7仅有链表）\n\n当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的大小大于等于64时，将会把链表转化为红黑树，这个过程就叫treeify（树化）\n\n如果table数组长度小于64，即便链表中的节点个数大于等于8，也不会触发treeify，而是触发扩容操作，将长链表拆分为短链表\n\n当红黑树中节点个数比较少时，HashMap会再将其转换回链表，因为维护红黑树的成本比较高，对于少许节点，使用链表存储更高效，红黑树转换为链表的过程，叫做untreeify，促发untreeify的场景有以下两个：\n\n删除键值对：如果红黑树满足以下结构，则会触发untreeify，这个结构的红黑树的节点个数应该处于[2,6]之间，尽管treeify的阈值是8，但untreeify的阈值是[2,6]之间的某个数，之所以不相等是为了避免频繁的插入删除操作，导致节点个数在7，8之间频繁波动\n&#x2F;&#x2F;removeTreeNode函数中\nif (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||\n    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;\n    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small\n    return;\n&#125;\n扩容：每一条链表都会分割为lo和hi两条，同理红黑树也会分割为lt和ht两个红黑树，lt中存储的是下标位置不变的节点，ht中存储的是下标位置变化的节点。不过，在构建lt和ht之前，会先统计属于lt和ht的节点个数lc和hc，如果lc小于等于6（UNTREEIFY_THRESHOLD静态常量），在新的table数组中，HashMap会使用链表来存储下标不变的节点，同理，如果hc小于等于6，在新的table数组中，HashMap会使用链表来存储下标改变的节点。\n\n\n\n\n\n\n\nCollections\n\nsort()：用来对List进行排序，默认为从小到大，支持传入Comparator接口的匿名类改为降序，底层依赖Arrays\n基本类型数组排序算法：JDK8及以后使用DualPivotQuickSort()，JDK7及其以前使用快排，使用不稳定排序\nDualPivotQuickSort根据长度和元素类型，使用双轴快速排序算法、插入排序、计数排序、归并排序等算法来组合进行排序操作\n\n\n对象数组排序算法：JDK8及其以后使用TimSort()，JDK7及其以前使用归并排序，使用的是稳定的排序方式\nTimSort用非递归版本归并排序，归并到阈值后开始进行二分插入排序算法，即在插入时选择用二分查找来确定插入位置\n\n\n\n\nbinarySearch()：用来对已排序的List容器进行二分查找，因为涉及元素比较，所以需要传入实现Comparable接口的对象或者主动传入Comparator接口的匿名类对象\nindexedBinarySearch：查找mid使用的是链表的get函数，需要从头遍历链表来得到对应值\niteratorBinarySearch：查找mid使用的是新定义的get函数，从上一次迭代器的位置（mid）开始向前或向后查找，需要遍历的范围变小了，执行效率就变高了\n\n\nsynchronizedXXX()：JCF中的容器都是非线程安全的，当要使用线程安全的容器时，首选使用JUC并发容器，但当没有合适的JUC并发容器可以使用时，可以使用Collectinos类中的synchronizedXXX()函数来创建线程安全的容器\n\n\n- \n\n\n","slug":"Java特性","date":"2023-04-13T11:25:47.000Z","categories_index":"","tags_index":"java","author_index":"Dajunnnnnn"},{"id":"9a0ea7adf62049ce83652b0a7c894a59","title":"Java数据结构","content":"Java数据结构1.数据结构1.1常用方法\n\n\n接口\nAPI\n\n\n\nCollection\nsize、isEmpty、contains、toArray、add、remove、clear\n\n\nList\nget(index)、set(index)、add(index,element)、remove(index)、indexOf()、lastIndexOf()、subList(from, to)、sort\n\n\nQueue\noffer(element)、poll()、peek()\n\n\nDuque\nofferFirst(E e)、offerLast(E e)、pollFirst()、pollLast()、peekFirst()、peekLast()、push(E e)、pop()\n\n\nSet\nsize、isEmpty、contains、toArray、add、remove\n\n\nSortedSet\nSortedSet subSet(E fromElement, E toElement)、headSet(E toElement)、tailSet(E fromElement)、first、last\n\n\nMap\nsize、isEmpty、containsKey、containsValue、get、put、remove、keySet、values、entrySet\n\n\nMap补\ngetOrDefault(Object key, V defaultValue)、putIfAbsent(K key, V value)、replace(K key, V oldValue, V newValue)\n\n\n1.2工具类\n\n\n类名\nAPI\n\n\n\nString\ncharAt、toCharArray、split、substring（新String）、indexOf、lastIndexOf、replace、length\n\n\nString补\ntrim、toLowerCase、toUpperCase、split(String regex)、format（格式化输出，同c）\n\n\nStringBuilder\nappend、toString、charAt、length、delete、replace、insert、reverse、indexOf、lastIndexOf\n\n\nCollections\nsort、binarySearch、reverse、swap、fill、copy、replaceAll、emptyXXX\n\n\nArrays\nsort、binarySearch、equals、fill、asList、copyOf、copyOfRange\n\n\nMath\nmin、max、abs、sqrt(double)、pow(double, double)、ceil（上整）、floor（下整）、round（四舍五入）\n\n\nMath补\nInteger.MAX_VALUE、Integer.MIN_VALUE、\n\n\nScanner\nnextInt、nextLong、nextLine（nextInt不会洗掉换行符，需要nextLine吸掉）\n\n\nSystem.out\nprintln、print、format(“x = %d, y = %f\\n”, x, y)\n\n\n1.3补充知识\nArrayList\n\n实现特殊接口\n\nRandomAccess：Arrays的静态方法binarySearch会根据接口调用不同的实现方法\nCloneable：使用clone方法，返回一个浅拷贝\n\n\n底层为可动态扩容的数组（支持存储null数据）\n\n首先==确定最小扩容量==，默认最小为10，如果传入的所需容量比10大，则按传入的所需容量来扩容\n\n然后==判断是否需要扩容==，如果前一阶段判定的需要容量比内部数组的长度大，则进行扩容\n\n使用位移操作，将容量扩展为内部数组长度的1.5倍，如果比需要容量小，则直接使用需要容量，防止多次扩容，然后使用System.arraycopy来复制数据\npublic static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);\n\n\n使用modCount：来记录容量更改的次数，每次调用ensureCapacityInternal就将modCount加1，容量不够使才改容量。用来确定迭代的过程中，是否有其他线程更改过数据，如果有人修改过，则抛出ConcurrentModificationException异常\n\n\n\nLinkedList\n\n可以根据引用的接口不同，使用不同方法，支持List、Queue、Deque，根据结构的不同可以调用不同的方法\n底层为双向链表，并且有头尾指针，支持存储null数据\n\n\nArrayDeque\n\n基于数组实现，性能比LinkedList好，也可用来实现栈\n\n\nPriorityQueue\n\n底层依赖堆来实现（使用可变长数组），默认情况下为小顶堆，最先出队列的为当前队列中的最小值，支持Comparator接口\nQueue&lt;Integer&gt; minH &#x3D; new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;小顶堆，默认大小为11\nQueue&lt;Integer&gt; maxH &#x3D; new PriorityQueue&lt;&gt;((i1, i2) -&gt; i2 - i1); &#x2F;&#x2F;大顶堆，默认大小为11\n不支持存储NULL和non-comparable对象，通过堆元素的上浮和下沉，实现了在O(logn)的时间复杂度内插入和删除堆顶元素\n\n堆的构建过程，需要比较节点中数据的大小，所以，添加到优先级队列中的元素，需要能够比较大小，方法有两种：基于Comparable接口和基于Comparator接口，都有时则优先使用comparator，详见siftUp\nprivate void siftUp(int k, E x) &#123;\n    if (comparator !&#x3D; null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n&#125;\n\n\nSet（HashSet、LinkedHashSet、TreeSet）\n\n底层实现分别为：HashMap、LinkedHashMap、TreeMap，存储对象的时候，使用对象作为key，一个空的Object对象作为value，插入到底层的Map中，不管\n如何检查重复：无论Set中是否已经存在了某元素，都会直接在底层进行插入，通过add方法的返回值来确定插入前是否有相同的元素\n应用场景：HashSet用于==不需要保证元素插入和取出顺序==的场景；LinkedHashSet用于==保证元素的插入和取出顺序满足FIFO==的场景（LinedHashMap底层使用双向有序链表+哈希表）；TreeSet用于支持对元素==自定义排序规则==的场景\n\n\nHashMap（==数组+链表/红黑树==）\n\n底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）\n底层数组长度为2的倍数：hash函数可以使用与n-1取交替代与n取余、装载因子使用0.75使得阈值（n*0.75）一直为整数、初始化的时候选择比传入参数大的最小2的幂次方数\n动态扩容：默认初始化大小为16，每次超过阈值的时候就扩容为原来的2倍；扫描数组的每一条链表，根据节点下标决定是否要更改，插入到lo链表（不需改）和hi链表（需要改），处理完一条链表，将新链表插入到对应位置\n新位置确定方式：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）\n链表树化：当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的长度大于等于64时，将会把链表转化为红黑树；如果table长度不满足则触发扩容操作；如果红黑树节点数在[2，6]之间，则退化为链表\n\n\n\n\nArrays的sort\n\nCollections的sort函数底层依赖的Arrays类的sort函数，如List接口中的sort的默认实现\n基本类型：使用==DualPivotQuickSort==，jdk7之前使用快排\n对快排进行改进，选取两个pivot，通过数组的长度决定什么时候选用双轴快排、插入排序、归并排序、记数排序\n\n\n对象数组：使用==TimSort==，jdk7之前使用归并\n使用非递归版本归并排序算法，在归并排序的过程中，大的排序区间不断分解为小的待排序区间，如果带排序区间的长度小于MIN_MERGE（32），就不再继续分解，转而执行二分插入排序算法\n二分插入排序：将数组分为已排序区间和未排序区间，通过二分查找，查找插入位置，当找到后，通过调用System.arraycopy()函数，将插入点之后的数据整体快速后移一位，腾出位置给要插入的数据\n\n\n\n\nString（final数组）\n\nString不可变的原因：内部是final修饰的数组（引用不可改但是数据可改）、没有提供更改数组的方法、String类也是final的子类无法继承，避免了子类破坏String的不变性\n常量池技术：使用字符串常量赋值时触发，直接复用常量池已存在的对象，也可以使用intern方法复制堆上对象到常量池并回收堆上的对象\n运算符重载：因为String比较常用，所以延续了基本类型和包装类的设计，实现了加法操作String sc = sa + sb;，底层使用了StringBuilder来实现（StringBuffer加了锁，是线程安全的）\n\n\n\n2.算法2.1复杂度分析\n分析方法\n加法原则：总复杂度等于量级最大的那段代码的复杂度\n乘法原则：嵌套代码的复杂度等于嵌套内外的代码复杂度乘积\n其他方法：某一条语句执行的总次数；数据被访问的次数；使用递归树来分析\n\n\n空间复杂度\n不关注存储数据所需要的空间，而是关注算法所需要的额外存储消耗（循环、递归调用栈、辅助存储）\n由于现有题型大多以耗时为指标，所以尽可能使用==以空间换时间==的思想\n\n\n时间复杂度\n不看低阶和常数系数、加法取大、乘法取积\n分类：最好、最坏、平均\n\n\n\n2.2技巧\n双指针\n\n前缀和数组：原始数组不会被修改的情况下，频繁查询某个区间的累加和\n\n前缀和数组中两个元素的差，及这段区间的累加和\n示例：原数组{3,5,2,-1,4,1}；前缀和数组{0,3,8,10,8,12,13}\n\n\n差分数组：频繁对原数组的某个区间的元素进行增减\n\n原理：对i→n的所有元素都加3，对j+1→n的所有元素都减3\n示例：原数组{8,2,6,3,1}；差分数组{8,-6,4,-3,-2}\n\n\n并查集（Union-Find）\nclass UF &#123;\n    &#x2F;&#x2F; 连通分量个数\n    private int count;\n    &#x2F;&#x2F; 存储每个节点的父节点\n    private int[] parent;\n\n    &#x2F;&#x2F; n 为图中节点的个数\n    public UF(int n) &#123;\n        this.count &#x3D; n;\n        parent &#x3D; new int[n];\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            parent[i] &#x3D; i;\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 将节点 p 和节点 q 连通\n    public void union(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        \n        if (rootP &#x3D;&#x3D; rootQ)\n            return;\n        \n        parent[rootQ] &#x3D; rootP;\n        &#x2F;&#x2F; 两个连通分量合并成一个连通分量\n        count--;\n    &#125;\n\n    &#x2F;&#x2F; 判断节点 p 和节点 q 是否连通\n    public boolean connected(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        return rootP &#x3D;&#x3D; rootQ;\n    &#125;\n\n    public int find(int x) &#123;\n        if (parent[x] !&#x3D; x) &#123;\n            parent[x] &#x3D; find(parent[x]);\n        &#125;\n        return parent[x];\n    &#125;\n\n    &#x2F;&#x2F; 返回图中的连通分量个数\n    public int count() &#123;\n        return count;\n    &#125;\n&#125;\nTree\n\n根据数组构建节点结构\npublic class Solution &#123;\n    static class TreeNode &#123;\n        int val;\n        TreeNode left;\n        TreeNode right;\n        public TreeNode(int x) &#123;\n            this.val &#x3D; x;\n            this.left &#x3D; null;\n            this.right &#x3D; null;\n        &#125;\n    &#125;\n    \n    &#x2F;**\n     * 根据数组构建二叉树\n     * @param arr 树的数组表示\n     * @return 构建成功后树的根节点\n     *&#x2F;\n    public TreeNode constructBinaryTree(final int[] arr) &#123;\n        &#x2F;&#x2F; 构建和原数组相同的树节点列表\n        List&lt;TreeNode&gt; treeNodeList &#x3D; arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;\n        TreeNode root &#x3D; null;\n        &#x2F;&#x2F; 把输入数值数组，先转化为二叉树节点列表\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; null;\n            if (arr[i] !&#x3D; -1) &#123; &#x2F;&#x2F; 用 -1 表示null\n                node &#x3D; new TreeNode(arr[i]);\n            &#125;\n            treeNodeList.add(node);\n            if (i &#x3D;&#x3D; 0) &#123;\n                root &#x3D; node;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 遍历一遍，根据规则左右孩子赋值就可以了\n        &#x2F;&#x2F; 注意这里 结束规则是 i * 2 + 1 &lt; arr.length，避免空指针\n        &#x2F;&#x2F; 为什么结束规则不能是i * 2 + 2 &lt; arr.length呢?\n        &#x2F;&#x2F; 如果i * 2 + 2 &lt; arr.length 是结束条件\n        &#x2F;&#x2F; 那么i * 2 + 1这个符合条件的节点就被忽略掉了\n        &#x2F;&#x2F; 例如[2,7,9,-1,1,9,6,-1,-1,10] 这样的一个二叉树,最后的10就会被忽略掉\n        for (int i &#x3D; 0; i * 2 + 1 &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; treeNodeList.get(i);\n            if (node !&#x3D; null) &#123;\n                &#x2F;&#x2F; 线性存储转连式存储关键逻辑\n                node.left &#x3D; treeNodeList.get(2 * i + 1);\n                &#x2F;&#x2F;  再次判断下 不忽略任何一个节点\n                if(i * 2 + 2 &lt; arr.length)\n                node.right &#x3D; treeNodeList.get(2 * i + 2);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n&#125;\n直接构建邻接表\nList&lt;Integer&gt;[] adjs &#x3D; new ArrayList[n];\nfor(int i &#x3D; 0; adjs.size(); i++)&#123;\n  adjs[i] &#x3D; new ArrayList&lt;&gt;();\n&#125;\nfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n  adjs[father].add(son);\n&#125;\n\n\nGraph\n&#x2F;&#x2F; 邻接表\n&#x2F;&#x2F; graph[x] 存储 x 的所有邻居节点\nList&lt;Integer&gt;[] graph;\n\n&#x2F;&#x2F; 邻接矩阵\n&#x2F;&#x2F; matrix[x][y] 记录 x 是否有一条指向 y 的边\nboolean[][] matrix;\n\n2.3算法思想\n排序\n\n基础排序算法\n\nO（n^2）\n\n冒泡排序：一对对比较，一对对交换\n\n插入排序：分为已排和未排区间，取未排插入到已排。例：希尔排序\n\n选择排序：分为已排和未排区间，从未排选一个最小的插入到已排的\n\n希尔排序\n\n\n\nO（nlogn）\n\n归并排序：“分治思想”，分而治之，然后再合并\n\n快速排序：选一个pivot，大的放左，小的放右\n\n堆排序：先将数组原地建成一个堆，从下往上堆化，取堆顶元素，将下标n的元素放到堆顶，堆化\n\n二叉排序树排序\n\n\n\nO（n）\n\n计数排序：例：10G数据，100个桶\n\n基数排序：高考成绩排序，760个桶\n\n桶排序：10万个手机号码排序，从个位开始一位位进行桶或基数排序\n\n\n\n\n\n常见题型\n\n特殊排序：不是单纯的增减顺序，而是有一些特殊要求\nTop K：找到前K个大的，第K个大的……\n链表上的排序：数据结构由数组转换为链表，并进行排序\n排序预处理：排序只是问题的一部分预处理，可以运用库函数\n区间问题：（252题、56题） 先排序，再处理\n\n\n\n\n二分查找：大部分都是变形二分查找或二分答案，代码不长，但容易写对。难点在于：确定搜索区间，循环条件，区间更新，返回值\n\n查找区间永远是闭区间[low,high]\n\n循环条件永远是：low &lt;= high\n\n对于low == high的情况，必要的时候特殊处理，在while内部补充退出条件\n\n返回值永远是mid，而不是low，high\n\nlow、high的更新永远是low = mid + 1和high = mid - 1\n\n对于非确定性查找，使用前后探测法，来确定搜索区间（不用while，而只更新low或high）\n\n先处理命中情况，再处理在左右半部分查找的情况\n\n非确定查找：第一个、最后一个、第一个大于等于、最后一个小于等于、循环数组寻找最小值、寻找峰值\n\n\n\nbfs\n&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离\nint BFS(Node start, Node target) &#123;\n    Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构\n    Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路\n    \n    q.offer(start); &#x2F;&#x2F; 将起点加入队列\n    visited.add(start);\n    int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数\n\n    while (q not empty) &#123;\n        int sz &#x3D; q.size();\n        &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F;\n        for (int i &#x3D; 0; i &lt; sz; i++) &#123;\n            Node cur &#x3D; q.poll();\n            &#x2F;* 划重点：这里判断是否到达终点 *&#x2F;\n            if (cur is target)\n                return step;\n            &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F;\n            for (Node x : cur.adj()) &#123;\n                if (x not in visited) &#123;\n                    q.offer(x);\n                    visited.add(x);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;* 划重点：更新步数在这里 *&#x2F;\n        step++;\n    &#125;\n&#125;\ndfs\n\n递归\n\n代码技巧：千万不要试图想清楚整个递和归的执行过程，实际上是进入了一个思维误区\n\n怎么发现这个问题可以用递归来做：\n\n规模更小的问题，跟规模大点的问题，解决思路相同，但规模不同\n\n利用子问题的解可以组合得到原问题的解\n\n存在最小子问题，可以直接返回结果，即存在递归终止条件\n\n\n\n递归的正确编写姿势：\n\n我们可以假设子问题B,C已经解决，在此基础上思考如何解决原问题A，基于此，找递推公式+终止条件，然后翻译成代码\n\n\n\n\n时间复杂度和空间复杂度分析：\n\n时间复杂度：递推公式或者递归树\n空间复杂度：跟递归的函数调用栈最大深度成正比，即递归树的高度\n\n\n解题技巧：寻找重复结构，是否能将问题结构转化成结构相同，规模更小的子问题，然后写递推公式，包括递归终止条件，然后翻译成代码\n\n原问题解决思路和子问题解决思路是否一样\n\n子问题的解能否构造出原问题的解（递推公式）\n\n找到最小子问题（终止条件）\n\n\n\n\n\n回溯：回溯是递归的副产品，只要有递归就会有回溯，本质就是穷举+剪枝\nresult &#x3D; []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n    \n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择\ndfs\npublic List&lt;Integer&gt; dfs(int s,int t)&#123;\n        List&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();\n        path.add(s);\n        visited[s] &#x3D; true;\n        dfs_backtrack(s,t,path);\n        return resultPath;\n    &#125;\n\n    public void dfs_backtrack(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                path.add(q);\n                visited[q] &#x3D; true;\n                dfs_backtrack(q,t,path);\n                path.remove(path.size()-1);\n            &#125;\n        &#125;\n    &#125;\n\n\ndp\n\n解题步骤\n\n可用回溯解决：使用穷举结果才能得到结果的问题（最值、可行、计数等）\n构建多阶段决策模型：看是否能将问题求解的过程分为多个阶段\n查看是否存在重复子问题：是否有多个路径到达同一状态\n定义状态：也就是如何记录每一阶段的不重复状态\n定义状态转移方程：也就是找到如何通过上一阶段的状态推导下一阶段的状态\n画状态转移表：辅助理解，验证正确性，确定状态转移的初始值\n\n\n代码结构\n# 自顶向下递归的动态规划\ndef dp(状态1, 状态2, ...):\n    for 选择 in 所有可能的选择:\n        # 此时的状态已经因为做了选择而改变\n        result &#x3D; 求最值(result, dp(状态1, 状态2, ...))\n    return result\n\n# 自底向上迭代的动态规划\n# 初始化 base case\ndp[0][0][...] &#x3D; base case\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)\n0-1背包的最值、可行、计数\n\n最值1：有n个物品，选择其中一些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装物品总重量的最大值是多少\n\n最值2：有n个物品，选择其中一些物品装入背包，正好装满背包所需物品最小个数（如果装不满，返回-1）\n\n可行：有n个物品，选择其中一些物品装入背包，能不能正好装满背包\n\n计数：有n个物品，选择其中一些物品装入背包，装满背包有多少种不同的装法\n\n\n\n完全背包（同一个物品可装n次）的最值、可行、计数\n\n背包可装物品总重量的最大值是多少\n是否能装满整个背包\n正好装满背包至少需要多少物品\n装满背包有多少种装法\n\n\n空间优化\n\n\n\n\n3.补充1.二叉树相关代码\n构建\npublic class TreeNode &#123;\n    int val;\n  \tTreeNode left;\n  \tTreeNode right;\n  \tTreeNode() &#123;&#125;\n  \tTreeNode(int val) &#123; this.val &#x3D; val; &#125;\n  \tTreeNode(int val, TreeNode left, TreeNode right) &#123;\n    \t\tthis.val &#x3D; val;\n    \t\tthis.left &#x3D; left;\n    \t\tthis.right &#x3D; right;\n  \t&#125;\n&#125;\n\n递归遍历\n&#x2F;&#x2F; 前序遍历·递归·LC144_二叉树的前序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n&#x2F;&#x2F; 中序遍历·递归·LC94_二叉树的中序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        inorder(root, res);\n        return res;\n    &#125;\n\n    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        inorder(root.left, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n        inorder(root.right, list);\n    &#125;\n&#125;\n&#x2F;&#x2F; 后序遍历·递归·LC145_二叉树的后序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        postorder(root, res);\n        return res;\n    &#125;\n\n    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        postorder(root.left, list);\n        postorder(root.right, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n    &#125;\n&#125;\n非递归遍历\n&#x2F;&#x2F; 前序遍历顺序：中-左-右，入栈顺序：中-右-左\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 中序遍历顺序: 左-中-右 入栈顺序： 左-右\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        TreeNode cur &#x3D; root;\n        while (cur !&#x3D; null || !stack.isEmpty())&#123;\n           if (cur !&#x3D; null)&#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;else&#123;\n               cur &#x3D; stack.pop();\n               result.add(cur.val);\n               cur &#x3D; cur.right;\n           &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;\n层序遍历\n&#x2F;&#x2F; 102.二叉树的层序遍历\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; resList &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        &#x2F;&#x2F;checkFun01(root,0);\n        checkFun02(root);\n\n        return resList;\n    &#125;\n\n    &#x2F;&#x2F;DFS--递归方式\n    public void checkFun01(TreeNode node, Integer deep) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        deep++;\n\n        if (resList.size() &lt; deep) &#123;\n            &#x2F;&#x2F;当层级增加时，list的Item也增加，利用list的索引值进行层级界定\n            List&lt;Integer&gt; item &#x3D; new ArrayList&lt;Integer&gt;();\n            resList.add(item);\n        &#125;\n        resList.get(deep - 1).add(node.val);\n\n        checkFun01(node.left, deep);\n        checkFun01(node.right, deep);\n    &#125;\n\n    &#x2F;&#x2F;BFS--迭代方式--借助队列\n    public void checkFun02(TreeNode node) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        Queue&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;TreeNode&gt;();\n        que.offer(node);\n\n        while (!que.isEmpty()) &#123;\n            List&lt;Integer&gt; itemList &#x3D; new ArrayList&lt;Integer&gt;();\n            int len &#x3D; que.size();\n\n            while (len &gt; 0) &#123;\n                TreeNode tmpNode &#x3D; que.poll();\n                itemList.add(tmpNode.val);\n\n                if (tmpNode.left !&#x3D; null) que.offer(tmpNode.left);\n                if (tmpNode.right !&#x3D; null) que.offer(tmpNode.right);\n                len--;\n            &#125;\n\n            resList.add(itemList);\n        &#125;\n\n    &#125;\n&#125;\n翻转二叉树\n&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;\n二叉树的所有路径\n&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;\n前序和后序构造二叉树\nclass Solution &#123;\n    Map&lt;Integer, Integer&gt; map;  &#x2F;&#x2F; 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (inBegin &gt;&#x3D; inEnd || postBegin &gt;&#x3D; postEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(postorder[postEnd - 1]);  &#x2F;&#x2F; 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定后序数列的个数\n        root.left &#x3D; findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right &#x3D; findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    &#125;\n&#125;\n前序和中序构造二叉树\nclass Solution &#123;\n    Map&lt;Integer, Integer&gt; map;\n    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数\n        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,\n                            inorder, inBegin, rootIndex);\n        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,\n                            inorder, rootIndex + 1, inEnd);\n\n        return root;\n    &#125;\n&#125;\n\n2.dp经典问题\n背包问题：0-1、完全、多重、二维费用、分组、有依赖的\n路径问题\n打家劫舍和股票买卖\n一般动态规划问题，上一个阶段做了什么决策，不影响下一个阶段的决策。但是打家劫舍&amp;股票买卖这类问题，上一个阶段的决策会影响下一个阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值\n\n\n爬楼梯\n匹配问题\n\n3.给定边怎么构造二叉树","slug":"算法基础","date":"2023-04-01T04:25:03.000Z","categories_index":"","tags_index":"algorithm","author_index":"Dajunnnnnn"}]