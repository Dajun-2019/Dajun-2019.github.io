{"title":"算法基础","uid":"ef3b137ddfca595334a5f18eaa3f5f69","slug":"算法基础","date":"2023-04-01T04:25:03.000Z","updated":"2023-04-05T02:01:46.731Z","comments":true,"path":"api/articles/算法基础.json","keywords":null,"cover":null,"content":"<h1 id=\"算法基础\"><a href=\"#算法基础\" class=\"headerlink\" title=\"算法基础\"></a>算法基础</h1><h2 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1.数据结构\"></a>1.数据结构</h2><h3 id=\"1-1常用方法\"><a href=\"#1-1常用方法\" class=\"headerlink\" title=\"1.1常用方法\"></a>1.1常用方法</h3><table>\n<thead>\n<tr>\n<th>接口</th>\n<th>API</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Collection</td>\n<td>size、isEmpty、contains、toArray、add、remove、clear</td>\n</tr>\n<tr>\n<td>List</td>\n<td>get(index)、set(index)、add(index,element)、remove(index)、indexOf()、lastIndexOf()、subList(from, to)、sort</td>\n</tr>\n<tr>\n<td>Queue</td>\n<td>offer(element)、poll()、peek()</td>\n</tr>\n<tr>\n<td>Duque</td>\n<td>offerFirst(E e)、offerLast(E e)、pollFirst()、pollLast()、peekFirst()、peekLast()、push(E e)、pop()</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>size、isEmpty、contains、toArray、add、remove</td>\n</tr>\n<tr>\n<td>SortedSet</td>\n<td>SortedSet<E> subSet(E fromElement, E toElement)、headSet(E toElement)、tailSet(E fromElement)、first、last</td>\n</tr>\n<tr>\n<td>Map</td>\n<td>size、isEmpty、containsKey、containsValue、get、put、remove、keySet、values、entrySet</td>\n</tr>\n<tr>\n<td>Map补</td>\n<td>getOrDefault(Object key, V defaultValue)、putIfAbsent(K key, V value)、replace(K key, V oldValue, V newValue)</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-2工具类\"><a href=\"#1-2工具类\" class=\"headerlink\" title=\"1.2工具类\"></a>1.2工具类</h3><table>\n<thead>\n<tr>\n<th>类名</th>\n<th>API</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String</td>\n<td>charAt、toCharArray、split、substring（新String）、indexOf、lastIndexOf、replace、length</td>\n</tr>\n<tr>\n<td>String补</td>\n<td>trim、toLowerCase、toUpperCase、split(String regex)、format（格式化输出，同c）</td>\n</tr>\n<tr>\n<td>StringBuilder</td>\n<td>append、toString、charAt、length、delete、replace、insert、reverse、indexOf、lastIndexOf</td>\n</tr>\n<tr>\n<td>Collections</td>\n<td>sort、binarySearch、reverse、swap、fill、copy、replaceAll、emptyXXX</td>\n</tr>\n<tr>\n<td>Arrays</td>\n<td>sort、binarySearch、equals、fill、asList、copyOf、copyOfRange</td>\n</tr>\n<tr>\n<td>Math</td>\n<td>min、max、abs、sqrt(double)、pow(double, double)、ceil（上整）、floor（下整）、round（四舍五入）</td>\n</tr>\n<tr>\n<td>Math补</td>\n<td>Integer.MAX_VALUE、Integer.MIN_VALUE、</td>\n</tr>\n<tr>\n<td>Scanner</td>\n<td>nextInt、nextLong、nextLine（nextInt不会洗掉换行符，需要nextLine吸掉）</td>\n</tr>\n<tr>\n<td>System.out</td>\n<td>println、print、format(“x = %d, y = %f\\n”, x, y)</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-3补充知识\"><a href=\"#1-3补充知识\" class=\"headerlink\" title=\"1.3补充知识\"></a>1.3补充知识</h3><ol>\n<li><p>ArrayList</p>\n<ul>\n<li><p>实现特殊接口</p>\n<ul>\n<li>RandomAccess：<code>Arrays</code>的静态方法<code>binarySearch</code>会根据接口调用不同的实现方法</li>\n<li>Cloneable：使用<code>clone</code>方法，返回一个浅拷贝</li>\n</ul>\n</li>\n<li><p>底层为可动态扩容的数组（支持存储null数据）</p>\n<ul>\n<li><p>首先==确定最小扩容量==，默认最小为10，如果传入的所需容量比10大，则按传入的所需容量来扩容</p>\n</li>\n<li><p>然后==判断是否需要扩容==，如果前一阶段判定的需要容量比内部数组的长度大，则进行扩容</p>\n</li>\n<li><p>使用位移操作，将容量扩展为内部数组长度的1.5倍，如果比需要容量小，则直接使用需要容量，防止多次扩容，然后使用<code>System.arraycopy</code>来复制数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);</code></pre></li>\n</ul>\n</li>\n<li><p>使用<code>modCount</code>：来记录容量更改的次数，每次调用<code>ensureCapacityInternal</code>就将<code>modCount</code>加1，容量不够使才改容量。用来确定迭代的过程中，是否有其他线程更改过数据，如果有人修改过，则抛出<code>ConcurrentModificationException</code>异常</p>\n</li>\n</ul>\n</li>\n<li><p>LinkedList</p>\n<ul>\n<li>可以根据引用的接口不同，使用不同方法，支持List、Queue、Deque，根据结构的不同可以调用不同的方法</li>\n<li>底层为双向链表，并且有头尾指针，支持存储null数据</li>\n</ul>\n</li>\n<li><p>ArrayDeque</p>\n<ul>\n<li>基于数组实现，性能比LinkedList好，也可用来实现栈</li>\n</ul>\n</li>\n<li><p>PriorityQueue</p>\n<ul>\n<li><p>底层依赖堆来实现（使用可变长数组），默认情况下为小顶堆，最先出队列的为当前队列中的最小值，支持Comparator接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Queue&lt;Integer&gt; minH &#x3D; new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;小顶堆，默认大小为11\nQueue&lt;Integer&gt; maxH &#x3D; new PriorityQueue&lt;&gt;((i1, i2) -&gt; i2 - i1); &#x2F;&#x2F;大顶堆，默认大小为11</code></pre></li>\n<li><p>不支持存储NULL和non-comparable对象，通过堆元素的上浮和下沉，实现了在<code>O(logn)</code>的时间复杂度内插入和删除堆顶元素</p>\n</li>\n<li><p>堆的构建过程，需要比较节点中数据的大小，所以，添加到优先级队列中的元素，需要能够比较大小，方法有两种：基于Comparable接口和基于Comparator接口，都有时则优先使用comparator，详见<code>siftUp</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void siftUp(int k, E x) &#123;\n    if (comparator !&#x3D; null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>Set（HashSet、LinkedHashSet、TreeSet）</p>\n<ul>\n<li>底层实现分别为：HashMap、LinkedHashMap、TreeMap，存储对象的时候，使用对象作为key，一个空的Object对象作为value，插入到底层的Map中，不管</li>\n<li>如何检查重复：无论Set中是否已经存在了某元素，都会直接在底层进行插入，通过add方法的返回值来确定插入前是否有相同的元素</li>\n<li>应用场景：HashSet用于==不需要保证元素插入和取出顺序==的场景；LinkedHashSet用于==保证元素的插入和取出顺序满足FIFO==的场景（LinedHashMap底层使用双向有序链表+哈希表）；TreeSet用于支持对元素==自定义排序规则==的场景</li>\n</ul>\n</li>\n<li><p>HashMap（==数组+链表/红黑树==）</p>\n<ul>\n<li>底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）</li>\n<li>底层数组长度为2的倍数：hash函数可以使用与n-1取交替代与n取余、装载因子使用0.75使得阈值（n*0.75）一直为整数、初始化的时候选择比传入参数大的最小2的幂次方数</li>\n<li>动态扩容：默认初始化大小为16，每次超过阈值的时候就扩容为原来的2倍；扫描数组的每一条链表，根据节点下标决定是否要更改，插入到lo链表（不需改）和hi链表（需要改），处理完一条链表，将新链表插入到对应位置<ul>\n<li>新位置确定方式：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）</li>\n<li>链表树化：当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的长度大于等于64时，将会把链表转化为红黑树；如果table长度不满足则触发扩容操作；如果红黑树节点数在[2，6]之间，则退化为链表</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Arrays的sort</p>\n<ul>\n<li>Collections的sort函数底层依赖的Arrays类的sort函数，如List接口中的sort的默认实现</li>\n<li>基本类型：使用==DualPivotQuickSort==，jdk7之前使用快排<ul>\n<li>对快排进行改进，选取两个pivot，通过数组的长度决定什么时候选用双轴快排、插入排序、归并排序、记数排序</li>\n</ul>\n</li>\n<li>对象数组：使用==TimSort==，jdk7之前使用归并<ul>\n<li>使用非递归版本归并排序算法，在归并排序的过程中，大的排序区间不断分解为小的待排序区间，如果带排序区间的长度小于MIN_MERGE（32），就不再继续分解，转而执行二分插入排序算法</li>\n<li>二分插入排序：将数组分为已排序区间和未排序区间，通过二分查找，查找插入位置，当找到后，通过调用System.arraycopy()函数，将插入点之后的数据整体快速后移一位，腾出位置给要插入的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>String（final数组）</p>\n<ul>\n<li>String不可变的原因：内部是final修饰的数组（引用不可改但是数据可改）、没有提供更改数组的方法、String类也是final的子类无法继承，避免了子类破坏String的不变性</li>\n<li>常量池技术：使用字符串常量赋值时触发，直接复用常量池已存在的对象，也可以使用intern方法复制堆上对象到常量池并回收堆上的对象</li>\n<li>运算符重载：因为String比较常用，所以延续了基本类型和包装类的设计，实现了加法操作<code>String sc = sa + sb;</code>，底层使用了StringBuilder来实现（StringBuffer加了锁，是线程安全的）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2.算法\"></a>2.算法</h2><h3 id=\"2-1复杂度分析\"><a href=\"#2-1复杂度分析\" class=\"headerlink\" title=\"2.1复杂度分析\"></a>2.1复杂度分析</h3><ol>\n<li>分析方法<ul>\n<li>加法原则：总复杂度等于量级最大的那段代码的复杂度</li>\n<li>乘法原则：嵌套代码的复杂度等于嵌套内外的代码复杂度乘积</li>\n<li>其他方法：某一条语句执行的总次数；数据被访问的次数；使用递归树来分析</li>\n</ul>\n</li>\n<li>空间复杂度<ul>\n<li>不关注存储数据所需要的空间，而是关注算法所需要的额外存储消耗（循环、递归调用栈、辅助存储）</li>\n<li>由于现有题型大多以耗时为指标，所以尽可能使用==以空间换时间==的思想</li>\n</ul>\n</li>\n<li>时间复杂度<ul>\n<li>不看低阶和常数系数、加法取大、乘法取积</li>\n<li>分类：最好、最坏、平均</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-2技巧\"><a href=\"#2-2技巧\" class=\"headerlink\" title=\"2.2技巧\"></a>2.2技巧</h3><ol>\n<li><p>双指针</p>\n</li>\n<li><p>前缀和数组：原始数组不会被修改的情况下，频繁查询某个区间的累加和</p>\n<ul>\n<li>前缀和数组中两个元素的差，及这段区间的累加和</li>\n<li>示例：原数组{3,5,2,-1,4,1}；前缀和数组{0,3,8,10,8,12,13}</li>\n</ul>\n</li>\n<li><p>差分数组：频繁对原数组的某个区间的元素进行增减</p>\n<ul>\n<li>原理：对i→n的所有元素都加3，对j+1→n的所有元素都减3</li>\n<li>示例：原数组{8,2,6,3,1}；差分数组{8,-6,4,-3,-2}</li>\n</ul>\n</li>\n<li><p>并查集（Union-Find）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class UF &#123;\n    &#x2F;&#x2F; 连通分量个数\n    private int count;\n    &#x2F;&#x2F; 存储每个节点的父节点\n    private int[] parent;\n\n    &#x2F;&#x2F; n 为图中节点的个数\n    public UF(int n) &#123;\n        this.count &#x3D; n;\n        parent &#x3D; new int[n];\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            parent[i] &#x3D; i;\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 将节点 p 和节点 q 连通\n    public void union(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        \n        if (rootP &#x3D;&#x3D; rootQ)\n            return;\n        \n        parent[rootQ] &#x3D; rootP;\n        &#x2F;&#x2F; 两个连通分量合并成一个连通分量\n        count--;\n    &#125;\n\n    &#x2F;&#x2F; 判断节点 p 和节点 q 是否连通\n    public boolean connected(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        return rootP &#x3D;&#x3D; rootQ;\n    &#125;\n\n    public int find(int x) &#123;\n        if (parent[x] !&#x3D; x) &#123;\n            parent[x] &#x3D; find(parent[x]);\n        &#125;\n        return parent[x];\n    &#125;\n\n    &#x2F;&#x2F; 返回图中的连通分量个数\n    public int count() &#123;\n        return count;\n    &#125;\n&#125;</code></pre></li>\n<li><p>Tree</p>\n<ul>\n<li><p>根据数组构建节点结构</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Solution &#123;\n    static class TreeNode &#123;\n        int val;\n        TreeNode left;\n        TreeNode right;\n        public TreeNode(int x) &#123;\n            this.val &#x3D; x;\n            this.left &#x3D; null;\n            this.right &#x3D; null;\n        &#125;\n    &#125;\n    \n    &#x2F;**\n     * 根据数组构建二叉树\n     * @param arr 树的数组表示\n     * @return 构建成功后树的根节点\n     *&#x2F;\n    public TreeNode constructBinaryTree(final int[] arr) &#123;\n        &#x2F;&#x2F; 构建和原数组相同的树节点列表\n        List&lt;TreeNode&gt; treeNodeList &#x3D; arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;\n        TreeNode root &#x3D; null;\n        &#x2F;&#x2F; 把输入数值数组，先转化为二叉树节点列表\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; null;\n            if (arr[i] !&#x3D; -1) &#123; &#x2F;&#x2F; 用 -1 表示null\n                node &#x3D; new TreeNode(arr[i]);\n            &#125;\n            treeNodeList.add(node);\n            if (i &#x3D;&#x3D; 0) &#123;\n                root &#x3D; node;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 遍历一遍，根据规则左右孩子赋值就可以了\n        &#x2F;&#x2F; 注意这里 结束规则是 i * 2 + 1 &lt; arr.length，避免空指针\n        &#x2F;&#x2F; 为什么结束规则不能是i * 2 + 2 &lt; arr.length呢?\n        &#x2F;&#x2F; 如果i * 2 + 2 &lt; arr.length 是结束条件\n        &#x2F;&#x2F; 那么i * 2 + 1这个符合条件的节点就被忽略掉了\n        &#x2F;&#x2F; 例如[2,7,9,-1,1,9,6,-1,-1,10] 这样的一个二叉树,最后的10就会被忽略掉\n        for (int i &#x3D; 0; i * 2 + 1 &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; treeNodeList.get(i);\n            if (node !&#x3D; null) &#123;\n                &#x2F;&#x2F; 线性存储转连式存储关键逻辑\n                node.left &#x3D; treeNodeList.get(2 * i + 1);\n                &#x2F;&#x2F;  再次判断下 不忽略任何一个节点\n                if(i * 2 + 2 &lt; arr.length)\n                node.right &#x3D; treeNodeList.get(2 * i + 2);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n&#125;</code></pre></li>\n<li><p>直接构建邻接表</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Integer&gt;[] adjs &#x3D; new ArrayList[n];\nfor(int i &#x3D; 0; adjs.size(); i++)&#123;\n  adjs[i] &#x3D; new ArrayList&lt;&gt;();\n&#125;\nfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n  adjs[father].add(son);\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>Graph</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 邻接表\n&#x2F;&#x2F; graph[x] 存储 x 的所有邻居节点\nList&lt;Integer&gt;[] graph;\n\n&#x2F;&#x2F; 邻接矩阵\n&#x2F;&#x2F; matrix[x][y] 记录 x 是否有一条指向 y 的边\nboolean[][] matrix;</code></pre></li>\n</ol>\n<h3 id=\"2-3算法思想\"><a href=\"#2-3算法思想\" class=\"headerlink\" title=\"2.3算法思想\"></a>2.3算法思想</h3><ol>\n<li><p>排序</p>\n<ul>\n<li><p>基础排序算法</p>\n<ul>\n<li><p>O（n^2）</p>\n<ul>\n<li><p>冒泡排序：一对对比较，一对对交换</p>\n</li>\n<li><p>插入排序：分为已排和未排区间，取未排插入到已排。例：希尔排序</p>\n</li>\n<li><p>选择排序：分为已排和未排区间，从未排选一个最小的插入到已排的</p>\n</li>\n<li><p>希尔排序</p>\n</li>\n</ul>\n</li>\n<li><p>O（nlogn）</p>\n<ul>\n<li><p>归并排序：“分治思想”，分而治之，然后再合并</p>\n</li>\n<li><p>快速排序：选一个pivot，大的放左，小的放右</p>\n</li>\n<li><p>堆排序：先将数组原地建成一个堆，从下往上堆化，取堆顶元素，将下标n的元素放到堆顶，堆化</p>\n</li>\n<li><p>二叉排序树排序</p>\n</li>\n</ul>\n</li>\n<li><p>O（n）</p>\n<ul>\n<li><p>计数排序：例：10G数据，100个桶</p>\n</li>\n<li><p>基数排序：高考成绩排序，760个桶</p>\n</li>\n<li><p>桶排序：10万个手机号码排序，从个位开始一位位进行桶或基数排序</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>常见题型</p>\n<ul>\n<li>特殊排序：不是单纯的增减顺序，而是有一些特殊要求</li>\n<li>Top K：找到前K个大的，第K个大的……</li>\n<li>链表上的排序：数据结构由数组转换为链表，并进行排序</li>\n<li>排序预处理：排序只是问题的一部分预处理，可以运用库函数</li>\n<li>区间问题：（252题、56题） 先排序，再处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二分查找：大部分都是变形二分查找或二分答案，代码不长，但容易写对。难点在于：确定搜索区间，循环条件，区间更新，返回值</p>\n<ul>\n<li><p>查找区间永远是闭区间[low,high]</p>\n</li>\n<li><p>循环条件永远是：low &lt;= high</p>\n</li>\n<li><p>对于low == high的情况，必要的时候特殊处理，在while内部补充退出条件</p>\n</li>\n<li><p>返回值永远是mid，而不是low，high</p>\n</li>\n<li><p>low、high的更新永远是low = mid + 1和high = mid - 1</p>\n</li>\n<li><p>对于非确定性查找，使用前后探测法，来确定搜索区间（不用while，而只更新low或high）</p>\n</li>\n<li><p>先处理命中情况，再处理在左右半部分查找的情况</p>\n</li>\n<li><p>非确定查找：第一个、最后一个、第一个大于等于、最后一个小于等于、循环数组寻找最小值、寻找峰值</p>\n</li>\n</ul>\n</li>\n<li><p>bfs</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离\nint BFS(Node start, Node target) &#123;\n    Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构\n    Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路\n    \n    q.offer(start); &#x2F;&#x2F; 将起点加入队列\n    visited.add(start);\n    int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数\n\n    while (q not empty) &#123;\n        int sz &#x3D; q.size();\n        &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F;\n        for (int i &#x3D; 0; i &lt; sz; i++) &#123;\n            Node cur &#x3D; q.poll();\n            &#x2F;* 划重点：这里判断是否到达终点 *&#x2F;\n            if (cur is target)\n                return step;\n            &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F;\n            for (Node x : cur.adj()) &#123;\n                if (x not in visited) &#123;\n                    q.offer(x);\n                    visited.add(x);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;* 划重点：更新步数在这里 *&#x2F;\n        step++;\n    &#125;\n&#125;</code></pre></li>\n<li><p>dfs</p>\n<ul>\n<li><p>递归</p>\n<ul>\n<li><p>代码技巧：千万不要试图想清楚整个递和归的执行过程，实际上是进入了一个思维误区</p>\n<ul>\n<li><p>怎么发现这个问题可以用递归来做：</p>\n<ul>\n<li><p>规模更小的问题，跟规模大点的问题，解决思路相同，但规模不同</p>\n</li>\n<li><p>利用子问题的解可以组合得到原问题的解</p>\n</li>\n<li><p>存在最小子问题，可以直接返回结果，即存在递归终止条件</p>\n</li>\n</ul>\n</li>\n<li><p>递归的正确编写姿势：</p>\n<ul>\n<li>我们可以假设子问题B,C已经解决，在此基础上思考如何解决原问题A，基于此，找递推公式+终止条件，然后翻译成代码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度和空间复杂度分析：</p>\n<ul>\n<li>时间复杂度：递推公式或者递归树</li>\n<li>空间复杂度：跟递归的函数调用栈最大深度成正比，即递归树的高度</li>\n</ul>\n</li>\n<li><p>解题技巧：寻找重复结构，是否能将问题结构转化成结构相同，规模更小的子问题，然后写递推公式，包括递归终止条件，然后翻译成代码</p>\n<ul>\n<li><p>原问题解决思路和子问题解决思路是否一样</p>\n</li>\n<li><p>子问题的解能否构造出原问题的解（递推公式）</p>\n</li>\n<li><p>找到最小子问题（终止条件）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>回溯：回溯是递归的副产品，只要有递归就会有回溯，本质就是穷举+剪枝</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">result &#x3D; []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n    \n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择</code></pre></li>\n<li><p>dfs</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public List&lt;Integer&gt; dfs(int s,int t)&#123;\n        List&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();\n        path.add(s);\n        visited[s] &#x3D; true;\n        dfs_backtrack(s,t,path);\n        return resultPath;\n    &#125;\n\n    public void dfs_backtrack(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                path.add(q);\n                visited[q] &#x3D; true;\n                dfs_backtrack(q,t,path);\n                path.remove(path.size()-1);\n            &#125;\n        &#125;\n    &#125;</code></pre></li>\n</ul>\n</li>\n<li><p>dp</p>\n<ul>\n<li><p>解题步骤</p>\n<ul>\n<li>可用回溯解决：使用穷举结果才能得到结果的问题（最值、可行、计数等）</li>\n<li>构建多阶段决策模型：看是否能将问题求解的过程分为多个阶段</li>\n<li>查看是否存在重复子问题：是否有多个路径到达同一状态</li>\n<li>定义状态：也就是如何记录每一阶段的不重复状态</li>\n<li>定义状态转移方程：也就是找到如何通过上一阶段的状态推导下一阶段的状态</li>\n<li>画状态转移表：辅助理解，验证正确性，确定状态转移的初始值</li>\n</ul>\n</li>\n<li><p>代码结构</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"># 自顶向下递归的动态规划\ndef dp(状态1, 状态2, ...):\n    for 选择 in 所有可能的选择:\n        # 此时的状态已经因为做了选择而改变\n        result &#x3D; 求最值(result, dp(状态1, 状态2, ...))\n    return result\n\n# 自底向上迭代的动态规划\n# 初始化 base case\ndp[0][0][...] &#x3D; base case\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</code></pre></li>\n<li><p>0-1背包的最值、可行、计数</p>\n<ul>\n<li><p>最值1：有n个物品，选择其中一些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装物品总重量的最大值是多少</p>\n</li>\n<li><p>最值2：有n个物品，选择其中一些物品装入背包，正好装满背包所需物品最小个数（如果装不满，返回-1）</p>\n</li>\n<li><p>可行：有n个物品，选择其中一些物品装入背包，能不能正好装满背包</p>\n</li>\n<li><p>计数：有n个物品，选择其中一些物品装入背包，装满背包有多少种不同的装法</p>\n</li>\n</ul>\n</li>\n<li><p>完全背包（同一个物品可装n次）的最值、可行、计数</p>\n<ul>\n<li>背包可装物品总重量的最大值是多少</li>\n<li>是否能装满整个背包</li>\n<li>正好装满背包至少需要多少物品</li>\n<li>装满背包有多少种装法</li>\n</ul>\n</li>\n<li><p>空间优化</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-补充\"><a href=\"#3-补充\" class=\"headerlink\" title=\"3.补充\"></a>3.补充</h2><h3 id=\"1-二叉树相关代码\"><a href=\"#1-二叉树相关代码\" class=\"headerlink\" title=\"1.二叉树相关代码\"></a>1.二叉树相关代码</h3><ol>\n<li><p>构建</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TreeNode &#123;\n    int val;\n  \tTreeNode left;\n  \tTreeNode right;\n  \tTreeNode() &#123;&#125;\n  \tTreeNode(int val) &#123; this.val &#x3D; val; &#125;\n  \tTreeNode(int val, TreeNode left, TreeNode right) &#123;\n    \t\tthis.val &#x3D; val;\n    \t\tthis.left &#x3D; left;\n    \t\tthis.right &#x3D; right;\n  \t&#125;\n&#125;\n</code></pre></li>\n<li><p>递归遍历</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 前序遍历·递归·LC144_二叉树的前序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n&#x2F;&#x2F; 中序遍历·递归·LC94_二叉树的中序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        inorder(root, res);\n        return res;\n    &#125;\n\n    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        inorder(root.left, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n        inorder(root.right, list);\n    &#125;\n&#125;\n&#x2F;&#x2F; 后序遍历·递归·LC145_二叉树的后序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        postorder(root, res);\n        return res;\n    &#125;\n\n    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        postorder(root.left, list);\n        postorder(root.right, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n    &#125;\n&#125;</code></pre></li>\n<li><p>非递归遍历</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 前序遍历顺序：中-左-右，入栈顺序：中-右-左\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 中序遍历顺序: 左-中-右 入栈顺序： 左-右\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        TreeNode cur &#x3D; root;\n        while (cur !&#x3D; null || !stack.isEmpty())&#123;\n           if (cur !&#x3D; null)&#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;else&#123;\n               cur &#x3D; stack.pop();\n               result.add(cur.val);\n               cur &#x3D; cur.right;\n           &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;</code></pre></li>\n<li><p>层序遍历</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 102.二叉树的层序遍历\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; resList &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        &#x2F;&#x2F;checkFun01(root,0);\n        checkFun02(root);\n\n        return resList;\n    &#125;\n\n    &#x2F;&#x2F;DFS--递归方式\n    public void checkFun01(TreeNode node, Integer deep) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        deep++;\n\n        if (resList.size() &lt; deep) &#123;\n            &#x2F;&#x2F;当层级增加时，list的Item也增加，利用list的索引值进行层级界定\n            List&lt;Integer&gt; item &#x3D; new ArrayList&lt;Integer&gt;();\n            resList.add(item);\n        &#125;\n        resList.get(deep - 1).add(node.val);\n\n        checkFun01(node.left, deep);\n        checkFun01(node.right, deep);\n    &#125;\n\n    &#x2F;&#x2F;BFS--迭代方式--借助队列\n    public void checkFun02(TreeNode node) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        Queue&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;TreeNode&gt;();\n        que.offer(node);\n\n        while (!que.isEmpty()) &#123;\n            List&lt;Integer&gt; itemList &#x3D; new ArrayList&lt;Integer&gt;();\n            int len &#x3D; que.size();\n\n            while (len &gt; 0) &#123;\n                TreeNode tmpNode &#x3D; que.poll();\n                itemList.add(tmpNode.val);\n\n                if (tmpNode.left !&#x3D; null) que.offer(tmpNode.left);\n                if (tmpNode.right !&#x3D; null) que.offer(tmpNode.right);\n                len--;\n            &#125;\n\n            resList.add(itemList);\n        &#125;\n\n    &#125;\n&#125;</code></pre></li>\n<li><p>翻转二叉树</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;</code></pre></li>\n<li><p>二叉树的所有路径</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;</code></pre></li>\n<li><p>前序和后序构造二叉树</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    Map&lt;Integer, Integer&gt; map;  &#x2F;&#x2F; 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (inBegin &gt;&#x3D; inEnd || postBegin &gt;&#x3D; postEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(postorder[postEnd - 1]);  &#x2F;&#x2F; 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定后序数列的个数\n        root.left &#x3D; findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right &#x3D; findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    &#125;\n&#125;</code></pre></li>\n<li><p>前序和中序构造二叉树</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    Map&lt;Integer, Integer&gt; map;\n    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数\n        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,\n                            inorder, inBegin, rootIndex);\n        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,\n                            inorder, rootIndex + 1, inEnd);\n\n        return root;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"2-dp经典问题\"><a href=\"#2-dp经典问题\" class=\"headerlink\" title=\"2.dp经典问题\"></a>2.dp经典问题</h3><ol>\n<li>背包问题：0-1、完全、多重、二维费用、分组、有依赖的</li>\n<li>路径问题</li>\n<li>打家劫舍和股票买卖<ul>\n<li>一般动态规划问题，上一个阶段做了什么决策，不影响下一个阶段的决策。但是打家劫舍&amp;股票买卖这类问题，上一个阶段的决策会影响下一个阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值</li>\n</ul>\n</li>\n<li>爬楼梯</li>\n<li>匹配问题</li>\n</ol>\n<h3 id=\"3-给定边怎么构造二叉树\"><a href=\"#3-给定边怎么构造二叉树\" class=\"headerlink\" title=\"3.给定边怎么构造二叉树\"></a>3.给定边怎么构造二叉树</h3>","text":"算法基础1.数据结构1.1常用方法 接口 API Collection size、isEmpty、contains、toArray、add、remove、clear List get(index)、set(index)、add(index,element)、remove(inde...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">算法基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.1常用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">1.2工具类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">1.3补充知识</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.1复杂度分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">2.2技巧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">2.3算法思想</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">3.补充</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">1.二叉树相关代码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-dp%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.dp经典问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%BB%99%E5%AE%9A%E8%BE%B9%E6%80%8E%E4%B9%88%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">3.给定边怎么构造二叉树</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"SaToken","uid":"a7db680819d5984afbc70473b0c79529","slug":"SaToken","date":"2023-04-13T11:03:17.000Z","updated":"2023-04-13T11:03:36.498Z","comments":true,"path":"api/articles/SaToken.json","keywords":null,"cover":null,"text":"Sa-Token 一款开源的、轻量级的Java权限认证框架，主要解决：登陆认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权等问题 1.登陆认证 登陆流程 用户提交name+password参数，调用登录接口 &#x2F;&#x2F;&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"19 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}