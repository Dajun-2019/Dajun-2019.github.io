{"title":"Note-C++","uid":"ad761ed2b5bb445c745eca7d55cac5dd","slug":"Note-C","date":"2023-04-20T08:46:07.000Z","updated":"2023-04-20T08:46:43.024Z","comments":true,"path":"api/articles/Note-C.json","keywords":null,"cover":[],"content":"<h1 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h1><h2 id=\"1-语言特性\"><a href=\"#1-语言特性\" class=\"headerlink\" title=\"1.语言特性\"></a>1.语言特性</h2><h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h3><h4 id=\"1-生命周期和编程范式\"><a href=\"#1-生命周期和编程范式\" class=\"headerlink\" title=\"1.生命周期和编程范式\"></a>1.生命周期和编程范式</h4><ol>\n<li><p>生命周期</p>\n<ul>\n<li>编码（Coding）：主要包括定义变量、写逻辑语句、实现各种数据结构、函数、类。需要遵循语言规范、设计文档、代码规范、设计模式。</li>\n<li>预处理（Pre-processing）：这个中间阶段主要依靠预处理器（Pre-processor）预先处理源代码，它的输入是编码阶段的源码文件，输出是经过预编译的源码文件，主要做了文字替换，即通过#include、#define、#if等预处理指令实现</li>\n<li>编译（Compiling）：包括编译（编译器）和链接（链接器）两步，生成可以在计算机上运行的二进制机器码。这里面包括很多复杂的操作，如分词、语法解析、生成目标码、优化等，并且编译器还会检查程序的语法、语义是否正确，发现错误就会产生编译失败（静态检查）。</li>\n<li>运行（Running）：将静态的程序载入内存，由CPU逐条语句执行，形成动态的进程。此阶段常做的是GDB调试、日志追踪、性能分析等，然后收集动态的数据，调整设计思路，在返回编码阶段。重走以上阶段，实现螺旋上升式的开发</li>\n</ul>\n</li>\n<li><p>编程范式（Paradigm）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220826145722693-20220921163542185-20221123125856118.png\" alt=\"image-20220826145722693\"></p>\n<ul>\n<li>面向过程：核心思想是<strong>命令</strong>，把任务分解成若干个步骤去执行，最终达成目标。主要来源于C语言，比如变量声明、表达式、分支/循环/跳转语句、函数等</li>\n<li>面向对象：核心思想是<strong>抽象</strong>和<strong>封装</strong>，将任务分解成一些高内聚低耦合的对象，对象间通过通信协作来完成任务，强调对象之间的关系和接口。主要包括class、public、private、virtual、this、构造函数、析构函数、友元函数等</li>\n<li>泛型：核心思想是<strong>类型</strong>，源自STL，也称为参数化类型、类型擦除，通过模版的方式而不是继承的方式来复用代码。基础是template关键字，然后是标准库的各种泛型容器和算法，比如vector、map、sort等</li>\n<li>模版元：核心思想是<strong>类型运算</strong>，操作的数据是编译时可见的类型，代码只能由编译器执行，而不能被运行时的CPU执行。主要通过库的方式来使用，比如type_traits、enable_if等，慎用</li>\n<li>函数式：核心思想是<strong>一切皆可调用</strong>，通过一系列连续或者嵌套的函数调用实现对数据的处理，从c++11引入了Lambda表达式</li>\n</ul>\n</li>\n<li><p>内存分配</p>\n<ol>\n<li>C语言的动态内存，用malloc()分配，用free()释放</li>\n<li>在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。<ol>\n<li>new 操作符会根据后面的数据类型来推断所需空间的大小。</li>\n<li>和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。</li>\n<li>为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>关键字概览</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>C++标准：C++98、C++03、C++11、C++14、C++17、C++20</p></blockquote>\n<ol>\n<li>流程控制：if、else、switch、case、default、goto、return、for、while、do、continue、break、</li>\n<li>面向对象：class、struct、union、enum、this、typedef、new、delete、</li>\n<li>数值操作<ol>\n<li>char、short、int、long、float、double、void、register（过时）、bool、true、false、wchar_t（宽字符）、char16_t（16位字符型）、char32_t（32位字符型）、sizeof（数据类型在编译期中的实现长度）、alignas（指定类型或对象的对齐要求）、alignof（查询类型的对齐要求）、typeid（获取一个变量或常量的真实数据类型）、nullptr（空指针）、auto（自动类型推导）、decltype（自动类型推导）</li>\n<li>unsigned、signed、const（只读变量）、volatile、mutable（修饰为可读可写）、static、extern（引用外部符号）、private、protected、public、constexpr（表示函数结果或对象是编译时决定的常量）、thread_local（变量具有线程周期）</li>\n<li>virtual（用于定义虚拟函数）、friend（声明友元函数）、inline（优化为内联函数）、explicit（防止类构造函数的隐式自动转换）、</li>\n</ol>\n</li>\n<li>其他<ol>\n<li>异常处理：throw、try、catch、noexcept（指定函数（模版）是否有异常抛出）</li>\n<li>命名空间：namespace（定义一个～）、using（引用一个）</li>\n<li>多态：operator（运算符重载）、template（定义或声明模版）、typename（用于将一个特殊的符号解释成一个类型）</li>\n<li>asm：在代码中嵌入汇编代码</li>\n<li>dynamic_cast（运行时类型检查，转换…）、static_cast（编译时的静态断言）、const_cast（同来修改const或volatile）、reinterpret_cast</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>特殊语法</p>\n<ol>\n<li><p>命名空间：namespace</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由&#123; &#125;包围。\nnamespace name&#123;\n    &#x2F;&#x2F;variables;\n    &#x2F;&#x2F;functions;\n    &#x2F;&#x2F;classes;\n&#125;\n&#x2F;&#x2F;使用1\nname::variable;\n&#x2F;&#x2F;使用2\nusing name::variable;\nvariable;</code></pre>\n\n\n\n<ol>\n<li><p>标准命名空间（std）：C++ 开发人员想了一个好办法，保留原来的库和头文件，它们在 C++ 中可以继续使用，然后再把原来的库复制一份，在此基础上稍加修改，把类、函数、宏等纳入命名空间 std 下，就成了新版 C++ 标准库。这样共存在了两份功能相似的库，使用了老式 C++ 的程序可以继续使用原来的库，新开发的程序可以使用新版的 C++ 库。</p>\n<ol>\n<li>为了避免头文件重名，新版 C++ 库也对头文件的命名做了调整，去掉了后缀<code>.h</code>。</li>\n<li>而对于原来C语言的头文件，也采用同样的方法，但在每个名字前还要添加一个<code>c</code>字</li>\n</ol>\n</li>\n<li><p>对于不带<code>.h</code>的头文件，所有的符号都位于命名空间 std 中，使用时需要声明命名空间 std；对于带<code>.h</code>的头文件，没有使用任何命名空间，所有符号都位于全局作用域。</p>\n</li>\n</ol>\n</li>\n<li><p>内联函数（Inline Function）:为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n\n&#x2F;&#x2F;内联函数，交换两个数的值\ninline void swap(int *a, int *b)&#123;\n    int temp;\n    temp &#x3D; *a;\n    *a &#x3D; *b;\n    *b &#x3D; temp;\n&#125;\n\nint main()&#123;\n    int m, n;\n    cin&gt;&gt;m&gt;&gt;n;\n    cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl;\n    swap(&amp;m, &amp;n);\n    cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl;\n\n    return 0;\n&#125;</code></pre>\n\n\n\n<ol>\n<li>注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。</li>\n<li>对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。</li>\n</ol>\n</li>\n<li><p>C++默认参数：当函数调用中省略了实参时自动使用的一个值，这个值就是给形参指定的默认值</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n\n&#x2F;&#x2F;带默认参数的函数\nvoid func(int n, float b&#x3D;1.2, char c&#x3D;&#39;@&#39;)&#123;\n    cout&lt;&lt;n&lt;&lt;&quot;, &quot;&lt;&lt;b&lt;&lt;&quot;, &quot;&lt;&lt;c&lt;&lt;endl;\n&#125;\n\nint main()&#123;\n    &#x2F;&#x2F;为所有参数传值\n    func(10, 3.5, &#39;#&#39;);\n    &#x2F;&#x2F;为n、b传值，相当于调用func(20, 9.8, &#39;@&#39;)\n    func(20, 9.8);\n    &#x2F;&#x2F;只为n传值，相当于调用func(30, 1.2, &#39;@&#39;)\n    func(30);\n\n    return 0;\n&#125;</code></pre>\n\n<ol>\n<li>C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-编码阶段\"><a href=\"#2-编码阶段\" class=\"headerlink\" title=\"2.编码阶段\"></a>2.编码阶段</h4><ul>\n<li>代码格式：多用空格分隔开变量与操作符，多用空行分隔开代码块</li>\n<li>标识符命名：遵循一些共识（用于循环的 i/j/k、用于计数的 count、表示指针的 p/ptr、表示缓冲区的 buf/buffer、表示变化量的 delta、表示总和的 sum），命名风格主要有以下三种，应取各家所长<ul>\n<li>匈牙利命名：给成员变量加“m_”前缀（member），给全局变量加“g_”前缀（global），比如 m_count、g_total</li>\n<li>CamelCase：在Java中非常流行，单词首字母大写，比如MyJobClass、tryToLock</li>\n<li>snake_case：全是小写，单词之间用下划线连接，比如unordered_set、shrink_to_fit</li>\n</ul>\n</li>\n<li>注释：一般包括作者、目的、用途、工作原理、注意事项、可能的返回值等信息，最后用英文</li>\n</ul>\n<h4 id=\"3-预处理阶段\"><a href=\"#3-预处理阶段\" class=\"headerlink\" title=\"3.预处理阶段\"></a>3.预处理阶段</h4><ul>\n<li><p>格式示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#                              &#x2F;&#x2F; 预处理空行\n#if __linux__                  &#x2F;&#x2F; 预处理检查宏是否存在\n#   define HAS_LINUX    1      &#x2F;&#x2F; 宏定义，有缩进\n#endif                         &#x2F;&#x2F; 预处理条件语句结束\n#                              &#x2F;&#x2F; 预处理空行</code></pre></li>\n<li><p>包含文件：因为#include可以包含任何东西，所以需要防止代码被重复包含，通过加上Include Guard，即使用“#ifndef/#define/#endif”来保护整个头文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#ifndef _XXX_H_INCLUDED_\n#define _XXX_H_INCLUDED_\n\n...    &#x2F;&#x2F; 头文件内容\n\n#endif &#x2F;&#x2F; _XXX_H_INCLUDED_</code></pre></li>\n<li><p>技巧：编写一些代码片段，存进“*.inc”文件里，然后有选择地加载，用得好的话，可以实现“源码级别的抽象”</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;改造前\nstatic uint32_t  calc_table[] &#x3D; &#123;  &#x2F;&#x2F; 非常大的一个数组，有几十行\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,\n    0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\n    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    ...                          \n&#125;;\n&#x2F;&#x2F;改造后，把数组内的数单独摘出来，另存为一个“*.inc”文件\nstatic uint32_t  calc_table[] &#x3D; &#123;\n#  include &quot;calc_values.inc&quot;        &#x2F;&#x2F; 非常大的一个数组，细节被隐藏\n&#125;;</code></pre></li>\n<li><p>宏定义（#define/#undef）</p>\n<ul>\n<li><p>#define可以定义源码级别的文本替换，无视c++语法限制，替换任何文字、定义常量 / 变量、实现函数功能、为类型起别名（typedef）、减少重复代码……但是为了可读性需要慎用</p>\n</li>\n<li><p>使用方法：</p>\n<ul>\n<li><p>宏的展开没有效率损失：对于一些调用频繁的小代码片段，用宏封装比用inline关键字效果更好，因为是源码级别无条件内联</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;摘自Nginx\n#define ngx_tolower(c)      ((c &gt;&#x3D; &#39;A&#39; &amp;&amp; c &lt;&#x3D; &#39;Z&#39;) ? (c | 0x20) : c)\n#define ngx_toupper(c)      ((c &gt;&#x3D; &#39;a&#39; &amp;&amp; c &lt;&#x3D; &#39;z&#39;) ? (c &amp; ~0x20) : c)\n\n#define ngx_memzero(buf, n)       (void) memset(buf, 0, n)</code></pre></li>\n<li><p>宏是没有作用域概念的，永远是全局生效：对于一些用来简化代码、起临时作用的宏，最好是用完后尽快用“#undef”取消定义，避免冲突的风险</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define CUBE(a) (a) * (a) * (a)  &#x2F;&#x2F; 定义一个简单的求立方的宏\n\ncout &lt;&lt; CUBE(10) &lt;&lt; endl;        &#x2F;&#x2F; 使用宏简化代码\ncout &lt;&lt; CUBE(15) &lt;&lt; endl;        &#x2F;&#x2F; 使用宏简化代码\n\n#undef CUBE                      &#x2F;&#x2F; 使用完毕后立即取消定义</code></pre></li>\n<li><p>宏定义前先检查：如果之前有定义就先 undef，然后再重新定义</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#ifdef AUTH_PWD                  &#x2F;&#x2F; 检查是否已经有宏定义\n#  undef AUTH_PWD                &#x2F;&#x2F; 取消宏定义\n#endif                           &#x2F;&#x2F; 宏定义检查结束\n#define AUTH_PWD &quot;xxx&quot;           &#x2F;&#x2F; 重新宏定义</code></pre></li>\n<li><p>宏定义代码中的常量，消除“魔术数字”“魔术字符串”</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define MAX_BUF_LEN    65535\n#define VERSION        &quot;1.0.18&quot;</code></pre></li>\n<li><p>宏定义命名空间：用宏来代替直接定义命名空间，很容易识别出命名空间的开始和结束</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define BEGIN_NAMESPACE(x)  namespace x &#123;\n#define END_NAMESPACE(x)    &#125;\n\nBEGIN_NAMESPACE(my_own)\n\n...      &#x2F;&#x2F; functions and classes\n\nEND_NAMESPACE(my_own)</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>条件编译（#if/#else/#endif）</p>\n<ul>\n<li><p>通过判断宏的数值来产生不同的源码，改变源文件的形态。条件编译有两个要点，一个是条件指令“#if”，另一个是后面的“判断依据”，也就是定义好的各种宏，而这个“判断依据”是条件编译里最关键的部分。</p>\n</li>\n<li><p>通常编译环境都会有一些预定义宏，比如 CPU 支持的特殊指令集、操作系统 / 编译器 / 程序库的版本、语言特性等，使用它们就可以早于运行阶段，提前在预处理阶段做出各种优化，产生出最适合当前系统的源码。</p>\n</li>\n<li><p>示例：</p>\n<ul>\n<li><p>__cplusplus：标记了C++的版本号，可以判断是C还是C++</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#ifdef __cplusplus                      &#x2F;&#x2F; 定义了这个宏就是在用C++编译\n    extern &quot;C&quot; &#123;                        &#x2F;&#x2F; 函数按照C的方式去处理\n#endif\n    void a_c_function(int a);\n#ifdef __cplusplus                      &#x2F;&#x2F; 检查是否是C++编译\n    &#125;                                   &#x2F;&#x2F; extern &quot;C&quot; 结束\n#endif\n\n#if __cplusplus &gt;&#x3D; 201402                &#x2F;&#x2F; 检查C++标准的版本号\n    cout &lt;&lt; &quot;c++14 or later&quot; &lt;&lt; endl;    &#x2F;&#x2F; 201402就是C++14\n#elif __cplusplus &gt;&#x3D; 201103              &#x2F;&#x2F; 检查C++标准的版本号\n    cout &lt;&lt; &quot;c++11 or before&quot; &lt;&lt; endl;   &#x2F;&#x2F; 201103是C++11\n#else   &#x2F;&#x2F; __cplusplus &lt; 201103          &#x2F;&#x2F; 199711是C++98\n#   error &quot;c++ is too old&quot;               &#x2F;&#x2F; 太低则预处理报错\n#endif  &#x2F;&#x2F; __cplusplus &gt;&#x3D; 201402         &#x2F;&#x2F; 预处理语句结束</code></pre></li>\n<li><p>编译器会提供一些与优化相关的底层系统信息</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#if defined(__cpp_decltype_auto)        &#x2F;&#x2F;检查是否支持decltype(auto)\n    cout &lt;&lt; &quot;decltype(auto) enable&quot; &lt;&lt; endl;\n#else\n    cout &lt;&lt; &quot;decltype(auto) disable&quot; &lt;&lt; endl;\n#endif  &#x2F;&#x2F;__cpp_decltype_auto\n\n#if __GNUC__ &lt;&#x3D; 4\n    cout &lt;&lt; &quot;gcc is too old&quot; &lt;&lt; endl;\n#else   &#x2F;&#x2F; __GNUC__ &gt; 4\n    cout &lt;&lt; &quot;gcc is good enough&quot; &lt;&lt; endl;\n#endif  &#x2F;&#x2F; __GNUC__ &lt;&#x3D; 4\n\n#if defined(__SSE4_2__) &amp;&amp; defined(__x86_64)\n    cout &lt;&lt; &quot;we can do more optimization&quot; &lt;&lt; endl;\n#endif  &#x2F;&#x2F; defined(__SSE4_2__) &amp;&amp; defined(__x86_64)</code></pre></li>\n<li><p>使用“#if 1”“#if 0”来显式启用或者禁用大段代码，要比“/* … */”的注释方式更安全，也更清楚</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#if 0          &#x2F;&#x2F; 0即禁用下面的代码，1则是启用\n  ...          &#x2F;&#x2F; 任意的代码\n#endif         &#x2F;&#x2F; 预处理结束\n\n#if 1          &#x2F;&#x2F; 1启用代码，用来强调下面代码的必要性\n  ...          &#x2F;&#x2F; 任意的代码\n#endif         &#x2F;&#x2F; 预处理结束</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-编译阶段\"><a href=\"#4-编译阶段\" class=\"headerlink\" title=\"4.编译阶段\"></a>4.编译阶段</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>有很多复杂的知识，与编译原理有关</p></blockquote>\n<ul>\n<li><p>属性（attribute）</p>\n<ul>\n<li><p>给变量、函数、类等贴上一个编译阶段的标签，方便编译器识别处理。没有新增关键字，而是通过[[…]]的方式，方括号中间就是属性标签，c++11只有两个属性，noreturn和carries_dependency ，c++14新增了deprecated属性，后续还有更多属性</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">[[noreturn]]              &#x2F;&#x2F; 属性标签\nint func(bool flag)       &#x2F;&#x2F; 函数绝不会返回任何值\n&#123;\n    throw std::runtime_error(&quot;XXX&quot;);\n&#125;</code></pre></li>\n<li><p>GCC的属性都在gnu::里，示例如下：</p>\n<ul>\n<li>deprecated：与 C++14 相同，但可以用在 C++11 里</li>\n<li>unused：用于变量、类型、函数等，表示虽然暂时不用，但最好保留着，因为将来可能会用</li>\n<li>constructor：函数会在 main() 函数之前执行，效果有点像是全局对象的构造函数</li>\n<li>destructor：函数会在 main() 函数结束之后执行，有点像是全局对象的析构函数</li>\n<li>always_inline：要求编译器强制内联函数，作用比 inline 关键字更强</li>\n<li>hot：标记“热点”函数，要求编译器更积极地优化</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">[[gnu::unused]]      &#x2F;&#x2F; 声明下面的变量暂不使用，不是错误\nint nouse;  </code></pre></li>\n</ul>\n</li>\n<li><p>静态断言（static_assert）</p>\n<ul>\n<li><p>assert：用来断言一个表达式必定为真，比如数字必须是正数，指针必须非空，函数必须返回true。当程序（也就是 CPU）运行到 assert 语句时，就会计算表达式的值，如果是 false，就会输出错误消息，然后调用 abort() 终止程序的执行。（assert 虽然是一个宏，但在预处理阶段不生效，而是在运行阶段才起作用，所以又叫“动态断言”）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">assert(i &gt; 0 &amp;&amp; &quot;i must be greater than zero&quot;);\nassert(p !&#x3D; nullptr);\nassert(!str.empty());</code></pre></li>\n<li><p>static_assert：是一个关键字而不是宏，只在编译时生效，运行阶段不可见。类似于assert，在编译阶段检测各种条件的断言，编译期会看是不是true，如果不是，则导致编译失败。（static_assert 运行在编译阶段，只能看到编译时的常数和类型，看不到运行时的变量、指针、内存数据等）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template&lt;int N&gt;\nstruct fib\n&#123;\n    static_assert(N &gt;&#x3D; 0, &quot;N &gt;&#x3D; 0&quot;);&#x2F;&#x2F;保证模板参数必须大于等于零\n\n    static const int value &#x3D;\n        fib&lt;N - 1&gt;::value + fib&lt;N - 2&gt;::value;\n&#125;;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-运行阶段\"><a href=\"#5-运行阶段\" class=\"headerlink\" title=\"5.运行阶段\"></a>5.运行阶段</h4><ol>\n<li><p>C++中一个类会有六大基本函数：构造函数、析构函数、拷贝构造函数、拷贝赋值函数、转移构造函数、转移赋值函数。C++编译期会自动为我们生成这些函数的默认实现，省去我们重复编写的时间。</p>\n<ul>\n<li><p>对于比较重要的构造函数和析构函数，应该用=default的形式，明确告诉编译器，应该实现这个函数，让编译期做好优化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoClass final \n&#123;\npublic:\n    DemoClass() &#x3D; default;  &#x2F;&#x2F; 明确告诉编译器，使用默认实现\n   ~DemoClass() &#x3D; default;  &#x2F;&#x2F; 明确告诉编译器，使用默认实现\n&#125;;</code></pre></li>\n<li><p>使用=delete明确地禁用某个函数形式，可以用于任何函数（成员函数、自由函数）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoClass final \n&#123;\npublic:\n    DemoClass(const DemoClass&amp;) &#x3D; delete;              &#x2F;&#x2F; 禁止拷贝构造\n    DemoClass&amp; operator&#x3D;(const DemoClass&amp;) &#x3D; delete;  &#x2F;&#x2F; 禁止拷贝赋值\n&#125;;</code></pre></li>\n<li><p>因为 C++ 有隐式构造和隐式转型的规则，如果类里有单参数的构造函数，或者是转型操作符函数，为了防止意外的类型转换，保证安全，就要使用“explicit”将这些函数标记为“显式”</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoClass final \n&#123;\npublic:\n    explicit DemoClass(const string_type&amp; str)  &#x2F;&#x2F; 显式单参构造函数\n    &#123; ... &#125;\n\n    explicit operator bool()                  &#x2F;&#x2F; 显式转型为bool\n    &#123; ... &#125;\n&#125;;</code></pre></li>\n</ul>\n</li>\n<li><p>C++11新特性</p>\n<ul>\n<li><p>委托构造（delegating constructor）：多个构造函数有相同的部分，原先需要提取出来，放到一个init()函数里，然后构造函数去调用，C++11可以使用委托构造，一个构造函数直接调用另一个构造函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoDelegating final\n&#123;\nprivate:\n    int a;                              &#x2F;&#x2F; 成员变量\npublic:\n    DemoDelegating(int x) : a(x)        &#x2F;&#x2F; 基本的构造函数\n    &#123;&#125;  \n\n    DemoDelegating() :                 &#x2F;&#x2F; 无参数的构造函数\n        DemoDelegating(0)               &#x2F;&#x2F; 给出默认值，委托给第一个构造函数\n    &#123;&#125;  \n\n    DemoDelegating(const string&amp; s) : &#x2F;&#x2F; 字符串参数构造函数\n        DemoDelegating(stoi(s))        &#x2F;&#x2F; 转换成整数，再委托给第一个构造函数\n    &#123;&#125;  \n&#125;;</code></pre></li>\n<li><p>成员变量初始化（In-class member initializer）：类有很多成员变量的时候，写构造函数需要写一长串名字来逐个初始化，C++11可以在类里声明变量的同时给它赋值，实现初始化</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoInit final                  &#x2F;&#x2F; 有很多成员变量的类\n&#123;\nprivate:\n    int                 a &#x3D; 0;        &#x2F;&#x2F; 整数成员，赋值初始化\n    string              s &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; 字符串成员，赋值初始化\n    vector&lt;int&gt;         v&#123;1, 2, 3&#125;;   &#x2F;&#x2F; 容器成员，使用花括号的初始化列表\npublic:\n    DemoInit() &#x3D; default;             &#x2F;&#x2F; 默认构造函数\n   ~DemoInit() &#x3D; default;             &#x2F;&#x2F; 默认析构函数\npublic:\n    DemoInit(int x) : a(x) &#123;&#125;         &#x2F;&#x2F; 可以单独初始化成员，其他用默认值\n&#125;;</code></pre></li>\n<li><p>类型别名（Type Alias）：C++11 扩展了关键字 using 的用法，增加了 typedef 的能力，可以定义类型别名。它的格式与 typedef 正好相反，别名在左边，原名在右边，是标准的赋值形式，所以易写易读。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using uint_t &#x3D; unsigned int;        &#x2F;&#x2F; using别名\ntypedef unsigned int uint_t；      &#x2F;&#x2F; 等价的typedef\n  \n&#x2F;&#x2F;在写类的时候，标准库里的类型名字都很长，可以通过using来给他们起别名\n\nclass DemoClass final\n&#123;\npublic:\n    using this_type         &#x3D; DemoClass;          &#x2F;&#x2F; 给自己也起个别名\n    using kafka_conf_type   &#x3D; KafkaConfig;        &#x2F;&#x2F; 外部类起别名\n\npublic:\n    using string_type   &#x3D; std::string;            &#x2F;&#x2F; 字符串类型别名\n    using uint32_type   &#x3D; uint32_t;              &#x2F;&#x2F; 整数类型别名\n\n    using set_type      &#x3D; std::set&lt;int&gt;;          &#x2F;&#x2F; 集合类型别名\n    using vector_type   &#x3D; std::vector&lt;std::string&gt;;&#x2F;&#x2F; 容器类型别名\n\nprivate:\n    string_type     m_name  &#x3D; &quot;tom&quot;;              &#x2F;&#x2F; 使用类型别名声明变量\n    uint32_type     m_age   &#x3D; 23;                  &#x2F;&#x2F; 使用类型别名声明变量\n    set_type        m_books;                      &#x2F;&#x2F; 使用类型别名声明变量\n\nprivate:\n    kafka_conf_type m_conf;                       &#x2F;&#x2F; 使用类型别名声明变量\n&#125;;</code></pre></li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h3 id=\"2-自动类型推导（auto-decitype）\"><a href=\"#2-自动类型推导（auto-decitype）\" class=\"headerlink\" title=\"2.自动类型推导（auto/decitype）\"></a>2.自动类型推导（auto/decitype）</h3><ol>\n<li><p>自动类型推导就是让计算机去运算，得出操作目标的编译阶段的类型。因为C++是一种静态类型，任何变量都要有一个确定的类型，所以在声明变量的时候，必须要明确地给出类型。但其实编译器是知道这些类型的，有了自动类型推导，即auto关键字，编译器就会自动填上正确的类型（有时推断的不是想要的）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto  i &#x3D; 0;          &#x2F;&#x2F; 自动推导为int类型\nauto  x &#x3D; 1.0;        &#x2F;&#x2F; 自动推导为double类型\n\nauto  str &#x3D; &quot;hello&quot;;  &#x2F;&#x2F; 自动推导为const char [6]类型\n\nstd::map&lt;int, std::string&gt; m &#x3D; &#123;&#123;1,&quot;a&quot;&#125;, &#123;2,&quot;b&quot;&#125;&#125;;  &#x2F;&#x2F; 自动推导不出来\n\nauto  iter &#x3D; m.begin();  &#x2F;&#x2F; 自动推导为map内部的迭代器类型\n\nauto  f &#x3D; bind1st(std::less&lt;int&gt;(), 2);  &#x2F;&#x2F; 自动推导出类型，具体是啥不知道</code></pre>\n\n<ul>\n<li>避免了对类型的硬编码，例如上面的代码中，当把map改为unordered_map的时候，后面的代码不需改变</li>\n</ul>\n</li>\n<li><p>auto</p>\n<ul>\n<li><p>auto的自动推导只在初始化的场合，就是复制初始化或者花括号初始化，且变量右边必须要有一个表达式（在类成员变量初始化的时候，C++不允许使用auto）</p>\n</li>\n<li><p>推导规则</p>\n<ul>\n<li><p>auto 总是推导出“值类型”，绝不会是“引用”</p>\n</li>\n<li><p>auto 可以附加上 const、volatile、*、&amp; 这样的类型修饰符，得到新的类型</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto        x &#x3D; 10L;    &#x2F;&#x2F; auto推导为long，x是long\n\nauto&amp;       x1 &#x3D; x;      &#x2F;&#x2F; auto推导为long，x1是long&amp;\nauto*       x2 &#x3D; &amp;x;    &#x2F;&#x2F; auto推导为long，x2是long*，是值类型而不是引用类型\nconst auto&amp; x3 &#x3D; x;        &#x2F;&#x2F; auto推导为long，x3是const long&amp;\nauto        x4 &#x3D; &amp;x3;    &#x2F;&#x2F; auto推导为const long*，x4是const long*</code></pre></li>\n</ul>\n</li>\n<li><p>使用场景</p>\n<ul>\n<li><p>在变量声明的时候尽量多用auto</p>\n</li>\n<li><p>range-based for中不需要关心容器元素类型，但是为了保证效率，最好使用“const auto&amp;”或者“auto&amp;”</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; v &#x3D; &#123;2,3,5,7,11&#125;;  &#x2F;&#x2F; vector顺序容器\n\nfor(const auto&amp; i : v) &#123;      &#x2F;&#x2F; 常引用方式访问元素，避免拷贝代价\n  cout &lt;&lt; i &lt;&lt; &quot;,&quot;;          &#x2F;&#x2F; 常引用不会改变元素的值\n&#125;\n\nfor(auto&amp; i : v) &#123;          &#x2F;&#x2F; 引用方式访问元素\n  i++;                      &#x2F;&#x2F; 可以改变元素的值\n  cout &lt;&lt; i &lt;&lt; &quot;,&quot;;\n&#125;</code></pre></li>\n<li><p>推导函数返回值</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto get_a_set()              &#x2F;&#x2F; auto作为函数返回值的占位符\n&#123;\n    std::set&lt;int&gt; s &#x3D; &#123;1,2,3&#125;;\n    return s;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>decltype</p>\n<ul>\n<li><p>auto只能用于初始化，表达式推导一般使用decltype。decltype 的形式很像函数，后面的圆括号里就是可用于计算类型的表达式（和 sizeof 有点类似），其他方面就和 auto 一样了，也能加上 const、*、&amp; 来修饰。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int x &#x3D; 0;          &#x2F;&#x2F; 整型变量\n\ndecltype(x)     x1;      &#x2F;&#x2F; 推导为int，x1是int\ndecltype(x)&amp;    x2 &#x3D; x;    &#x2F;&#x2F; 推导为int，x2是int&amp;，引用必须赋值\ndecltype(x)*    x3;      &#x2F;&#x2F; 推导为int，x3是int*\ndecltype(&amp;x)    x4;      &#x2F;&#x2F; 推导为int*，x4是int*\ndecltype(&amp;x)*   x5;      &#x2F;&#x2F; 推导为int*，x5是int**\ndecltype(x2)    x6 &#x3D; x2;  &#x2F;&#x2F; 推导为int&amp;，x6是int&amp;，引用必须赋值，推导出了引用类型</code></pre></li>\n<li><p>decltype 不仅能够推导出值类型，还能够推导出引用类型，也就是表达式的“原始类型”</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using int_ptr &#x3D; decltype(&amp;x);    &#x2F;&#x2F; int *\nusing int_ref &#x3D; decltype(x)&amp;;    &#x2F;&#x2F; int &amp;</code></pre></li>\n<li><p>C++14 就又增加了一个“decltype(auto)”的形式，既可以精确推导类型，又能像 auto 一样方便使用</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int x &#x3D; 0;            &#x2F;&#x2F; 整型变量\n\ndecltype(auto)     x1 &#x3D; (x);  &#x2F;&#x2F; 推导为int&amp;，因为(expr)是引用类型\ndecltype(auto)     x2 &#x3D; &amp;x;   &#x2F;&#x2F; 推导为int*\ndecltype(auto)     x3 &#x3D; x1;   &#x2F;&#x2F; 推导为int&amp;</code></pre></li>\n<li><p>使用场景</p>\n<ul>\n<li><p>侧重于编译阶段的类型计算，常用在泛型编程里，获取各种类型</p>\n</li>\n<li><p>定义函数指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; UNIX信号函数的原型，看着就让人晕，你能手写出函数指针吗？\nvoid (*signal(int signo, void (*func)(int)))(int)\n\n&#x2F;&#x2F; 使用decltype可以轻松得到函数指针类型\nusing sig_func_ptr_t &#x3D; decltype(&amp;signal) ;</code></pre></li>\n<li><p>定义类的成员变量、成员函数上，变通地实现auto的功能</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoClass final\n&#123;\npublic:\n    using set_type      &#x3D; std::set&lt;int&gt;;  &#x2F;&#x2F; 集合类型别名\nprivate:\n    set_type      m_set;                   &#x2F;&#x2F; 使用别名定义成员变量\n\n    &#x2F;&#x2F; 使用decltype计算表达式的类型，定义别名\n    using iter_type &#x3D; decltype(m_set.begin());\n\n    iter_type     m_pos;                   &#x2F;&#x2F; 类型别名定义成员变量\n&#125;;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-常量（const、volatile、mutable）\"><a href=\"#3-常量（const、volatile、mutable）\" class=\"headerlink\" title=\"3.常量（const、volatile、mutable）\"></a>3.常量（const、volatile、mutable）</h3><ol>\n<li><p>const</p>\n<ul>\n<li><p>定义程序要用到的数字、字符串常量、代替宏定义，用于表示常量。与宏定义的本质区别是，在运行阶段才会出现，而宏定义在编译阶段就出现了。可以称作是只读变量</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const int MAX_LEN       &#x3D; 1024;\nconst std::string NAME  &#x3D; &quot;metroid&quot;;</code></pre></li>\n<li><p>因为const是只读<strong>变量</strong>，所以可以通过指针得到地址来更改，但是编译器对于const修饰的常数，会做各种优化，所以需要加volatile关键字，才能更改。volatile作用见下</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 需要加上volatile修饰，运行时才能看到效果\nconst volatile int MAX_LEN  &#x3D; 1024;\n\nauto ptr &#x3D; (int*)(&amp;MAX_LEN);\n*ptr &#x3D; 2048;\ncout &lt;&lt; MAX_LEN &lt;&lt; endl;      &#x2F;&#x2F; 输出2048</code></pre></li>\n<li><p>常量引用：const&amp;被称为万能引用，即它可以引用任何类型（不管是值、指针、左引用还是右引用），而且他还会跟变量附加上const特性，这样变量就成了常量，只能读、禁止写。所以可以拿它做入口参数，既能保证效率又能保证安全</p>\n</li>\n<li><p>常量指针</p>\n<ul>\n<li><p>const放在声明的最左边，表示指向常量的指针，即指针指向一个只读变量，不允许修改</p>\n</li>\n<li><p>const在*的右边，表示指针不能被修改，而指向的变量可以被修改</p>\n</li>\n<li><p>根据*在const的左右的不同，口诀：<strong>左定值右定向const修饰不变量</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">string name &#x3D; &quot;uncharted&quot;;\nconst string* ps1 &#x3D; &amp;name; &#x2F;&#x2F; 指向常量\n*ps1 &#x3D; &quot;spiderman&quot;;        &#x2F;&#x2F; 错误，不允许修改\n\n\nstring* const ps2 &#x3D; &amp;name;  &#x2F;&#x2F; 指向变量，但指针本身不能被修改\n*ps2 &#x3D; &quot;spiderman&quot;;        &#x2F;&#x2F; 正确，允许修改</code></pre></li>\n</ul>\n</li>\n<li><p>类中</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoClass final\n&#123;\n  private:\n  const long  MAX_SIZE &#x3D; 256;    &#x2F;&#x2F; const成员变量\n  int         m_value;           &#x2F;&#x2F; 成员变量\n  public:\n  &#x2F;&#x2F; const成员函数，表示这个函数是一个常量，即函数执行过程中不会修改对象（成员变量）的状态\n  int get_value() const        \n  &#123;\n    return m_value;\n  &#125;\n&#125;;</code></pre>\n\n<ul>\n<li>对于常量指针和常量引用修饰的对象是只读的，那么对他的任何操作也应该是只读的，所以编译器会检查const相关代码，如果成员函数不是const，就不允许调用</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/Users/dajunnnnnn/Desktop/image-20220827083734098-20220828173204455-20220921163542353-20221123125856276.png\"></p>\n</li>\n<li><p>volatile</p>\n<ul>\n<li>在C++中表示变量的值可能会以难以察觉的方式被修改，所以要禁止编译器做任何形式的优化，每次使用时都去老老实实地取值。例如上述代码在加了volatile修饰之后，就表示它是不稳定，编译器再生成二进制机器码的时候，就不会做那些有可能有副作用的优化，而是每次都去内存取值</li>\n<li>用const标记变量可以让编译器做更好的优化，而用volatile会禁止编译器做优化，所以应该少用volatile</li>\n</ul>\n</li>\n<li><p>mutable</p>\n<ul>\n<li><p>mutable类似于volatile，但是volatile可以用来修饰任何变量，而mutable却只能修饰类里面的成员变量，表示变量即使是在const对象里也是可以修改的。</p>\n</li>\n<li><p>主要是为了给const对象打一个补丁，因为封装的特性，const内部的一些对象本身就不被外部所知，此时变与不变不会改变外界看到的对象的常量性，所以给成员变量加上mutable可以使得其解除const的限制，让任何成员含糊都可以操作它</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class DemoClass final\n&#123;\nprivate:\n    mutable mutex_type  m_mutex;    &#x2F;&#x2F; mutable成员变量\npublic:\n    void save_data() const          &#x2F;&#x2F; const成员函数\n    &#123;\n        &#x2F;&#x2F; do someting with m_mutex\n    &#125;\n&#125;;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-智能指针（smart-ptr）\"><a href=\"#4-智能指针（smart-ptr）\" class=\"headerlink\" title=\"4.智能指针（smart_ptr）\"></a>4.智能指针（smart_ptr）</h3><ol>\n<li><p>概念：</p>\n<ul>\n<li>在现代C++中，裸指针的使用应该变为智能指针的使用。指针的概念源自C语言，它的存在是C/C++高效的根源，但是也是无数麻烦（访问无效数据、指针越界、内存泄漏）的根源。Java和Go针对此情况有垃圾回收机制，C++只有构造/析构函数和RAII惯用法</li>\n<li>可以应用代理模式，把裸指针包装起来，在构造函数里初始化，在析构函数里释放。这样当对象失效销毁时，C++ 就会自动调用析构函数，完成内存释放、资源回收等清理工作。智能指针就是代替你来干这些“脏活累活”的。它完全实践了 RAII，包装了裸指针，而且因为重载了 * 和 -&gt; 操作符，用起来和原始指针一模一样。</li>\n</ul>\n</li>\n<li><p>unique_ptr</p>\n<ul>\n<li><p>名字叫指针， 但是实际上它并不是指针，而是一个对象。但是不应该对它调用delete，它会自动管理初始化时的指针，在离开作用域时析构释放内存。他没有定义加减运算，所以不能随意移动指针地址。在使用之前需要声明并初始化，未初始化就相当于空指针</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">unique_ptr&lt;int&gt; ptr3;                &#x2F;&#x2F; 未初始化智能指针\n*ptr3 &#x3D; 42 ;                         &#x2F;&#x2F; 错误！操作了空指针\n\n&#x2F;&#x2F;可以调用工厂函数 make_unique()，强制创建智能指针的时候必须初始化，需要C++14\nauto ptr3 &#x3D; make_unique&lt;int&gt;(42);               &#x2F;&#x2F; 工厂函数创建智能指针\nassert(ptr3 &amp;&amp; *ptr3 &#x3D;&#x3D; 42);\n\nauto ptr4 &#x3D; make_unique&lt;string&gt;(&quot;god of war&quot;);  &#x2F;&#x2F; 工厂函数创建智能指针\nassert(!ptr4-&gt;empty());</code></pre></li>\n<li><p>所有权：正如它的名字，表示指针的所有权是“唯一”的，不允许共享，任何时候只能有一个“人”持有它。unique_ptr 应用了 C++ 的“转移”（move）语义，同时禁止了拷贝赋值，所以，在向另一个 unique_ptr 赋值的时候，要特别留意，必须用 std::move() 函数显式地声明所有权转移。赋值操作之后，指针的所有权就被转走了，原来的 unique_ptr 变成了空指针，新的 unique_ptr 接替了管理权，保证所有权的唯一性</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto ptr1 &#x3D; make_unique&lt;int&gt;(42);    &#x2F;&#x2F; 工厂函数创建智能指针\nassert(ptr1 &amp;&amp; *ptr1 &#x3D;&#x3D; 42);         &#x2F;&#x2F; 此时智能指针有效\n\nauto ptr2 &#x3D; std::move(ptr1);         &#x2F;&#x2F; 使用move()转移所有权\nassert(!ptr1 &amp;&amp; ptr2);               &#x2F;&#x2F; ptr1变成了空指针</code></pre></li>\n</ul>\n</li>\n<li><p>shared_ptr</p>\n<ul>\n<li><p>shared_ptr 具有完整的“值语义”（即可以拷贝赋值），所以，它可以在任何场合替代原始指针，而不用再担心资源回收的问题，比如用于容器存储指针、用于函数安全返回动态创建的对象，等等。但是这一切是有代价的，shared_ptr的执行效率不如unique_ptr</p>\n</li>\n<li><p>销毁操作：对象的析构函数不应该有复杂、严重阻塞的操作，一旦shared_ptr在某个不确定时间点析构释放资源，就会阻塞整个进程或者线程，“整个世界都会静止不动”</p>\n</li>\n<li><p>循环引用：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Node final\n&#123;\npublic:\n    using this_type     &#x3D; Node;\n    using shared_type   &#x3D; std::shared_ptr&lt;this_type&gt;;\npublic:\n    shared_type     next;      &#x2F;&#x2F; 使用智能指针来指向下一个节点\n&#125;;\n\nauto n1 &#x3D; make_shared&lt;Node&gt;();   &#x2F;&#x2F; 工厂函数创建智能指针\nauto n2 &#x3D; make_shared&lt;Node&gt;();   &#x2F;&#x2F; 工厂函数创建智能指针d\n\nassert(n1.use_count() &#x3D;&#x3D; 1);    &#x2F;&#x2F; 引用计数为1\nassert(n2.use_count() &#x3D;&#x3D; 1);\n\nn1-&gt;next &#x3D; n2;                 &#x2F;&#x2F; 两个节点互指，形成了循环引用\nn2-&gt;next &#x3D; n1;\n\nassert(n1.use_count() &#x3D;&#x3D; 2);    &#x2F;&#x2F; 引用计数为2\nassert(n2.use_count() &#x3D;&#x3D; 2);    &#x2F;&#x2F; 无法减到0，无法销毁，导致内存泄漏</code></pre></li>\n<li><p>weak_ptr：它专门为打破循环引用而设计，只观察指针，不会增加引用计数（弱引用），但在需要的时候，可以调用成员函数 lock()，获取 shared_ptr（强引用）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Node final\n&#123;\npublic:\n    using this_type     &#x3D; Node;\n\n    &#x2F;&#x2F; 注意这里，别名改用weak_ptr\n    using shared_type   &#x3D; std::weak_ptr&lt;this_type&gt;;\npublic:\n    shared_type     next;    &#x2F;&#x2F; 因为用了别名，所以代码不需要改动\n&#125;;\n\nauto n1 &#x3D; make_shared&lt;Node&gt;();  &#x2F;&#x2F; 工厂函数创建智能指针\nauto n2 &#x3D; make_shared&lt;Node&gt;();  &#x2F;&#x2F; 工厂函数创建智能指针\n\nn1-&gt;next &#x3D; n2;             &#x2F;&#x2F; 两个节点互指，形成了循环引用\nn2-&gt;next &#x3D; n1;\n\nassert(n1.use_count() &#x3D;&#x3D; 1);    &#x2F;&#x2F; 因为使用了weak_ptr，引用计数为1\nassert(n2.use_count() &#x3D;&#x3D; 1);   &#x2F;&#x2F; 打破循环引用，不会导致内存泄漏\n\nif (!n1-&gt;next.expired()) &#123;     &#x2F;&#x2F; 检查指针是否有效\n    auto ptr &#x3D; n1-&gt;next.lock();  &#x2F;&#x2F; lock()获取shared_ptr\n    assert(ptr &#x3D;&#x3D; n2);\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-异常（exception）\"><a href=\"#5-异常（exception）\" class=\"headerlink\" title=\"5.异常（exception）\"></a>5.异常（exception）</h3><ol>\n<li><p>异常知识</p>\n<ol>\n<li><p>异常类型：</p>\n<ol>\n<li>C++ 语言本身以及标准库中的函数抛出的异常，都是 exception 类或其子类的异常。也就是说，抛出异常时，会创建一个 exception 类或其子类的对象。</li>\n<li>可以将 catch 看做一个没有返回值的函数，当异常发生后 catch 会被调用，并且会接收实参（异常数据），但是catch 和真正的函数调用相比，多了一个在运行阶段将实参和形参匹配的过程，匹配成功的话就“调用”当前的 catch，否则就忽略当前的 catch。</li>\n<li>catch 在匹配异常类型的过程中，也会进行类型转换，但是这种转换受到了更多的限制，仅能进行「向上转型」、「const 转换」和「数组或函数指针转换」，其他的都不能应用于 catch。</li>\n</ol>\n</li>\n<li><p>异常的特点：</p>\n<ul>\n<li><strong>异常的处理流程是完全独立的：</strong>throw 抛出异常后就可以不用管了，错误处理代码都集中在专门的 catch 块里。这样就彻底分离了业务逻辑与错误逻辑，看起来更清楚。</li>\n<li><strong>异常是绝对不能被忽略的，必须被处理：</strong>如果你有意或者无意不写 catch 捕获异常，那么它会一直向上传播出去，直至找到一个能够处理的 catch 块。如果实在没有，那就会导致程序立即停止运行</li>\n<li><strong>异常可以用在错误码无法使用的场合：</strong>因为C++比 C 语言多了构造 / 析构函数、操作符重载等新特性，有的函数根本就没有返回值，或者返回值无法表示错误，而全局的 errno 实在是“太不优雅”了，与 C++ 的理念不符，所以也必须使用异常来报告错误。</li>\n</ul>\n</li>\n<li><p>throw 用作异常规范</p>\n<ol>\n<li>异常必须显式地抛出，才能被检测和捕获到；如果没有显式的抛出，即使有异常也检测不到。在 C++ 中，我们使用 throw 关键字来显式地抛出异常，它的用法为：<code>throw exceptionData;</code>，exceptionData 是“异常数据”的意思，它可以包含任意的信息，完全有程序员决定。exceptionData 可以是 int、float、bool 等基本类型，也可以是<a href=\"http://c.biancheng.net/c/80/\">指针</a>、数组、字符串、结构体、类等聚合类型</li>\n<li>throw 关键字除了可以用在函数体中抛出异常，还可以用在函数头和函数体之间，指明当前函数能够抛出的异常类型，这称为异常规范（Exception specification），有些教程也称为异常指示符或异常列表。请看下面的例子：<code>double func (char param) throw (int);</code>，这条语句声明了一个名为 func 的函数，它的返回值类型为 double，有一个 char 类型的参数，并且只能抛出 int 类型的异常。如果抛出其他类型的异常，try 将无法捕获，只能终止程序。（异常规范的初衷实现起来有点困难，所以大家达成的一致意见是，最好不要使用异常规范。）</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>异常的用法的使用方式</p>\n<ul>\n<li><p>用法：用 try 把可能发生异常的代码“包”起来，然后编写 catch 块捕获异常并处理，而且支持多个catch块来捕获不同的异常，再分别处理</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">try\n&#123;\n  int n &#x3D; read_data(fd, ...);    &#x2F;&#x2F; 读取数据，可能抛出异常\n  \n  ...                         &#x2F;&#x2F; do some right thing\n&#125;\ncatch(exception &amp;e)   &#x2F;&#x2F;使用引用，是为了提高效率。如果不使用引用，就要经历一次对象拷贝（要调用拷贝构造函数）的过程。\n&#123;\n    ...                       &#x2F;&#x2F; 集中处理各种错误情况\n&#125;\n&#x2F;&#x2F;C++语言本身或者标准库抛出的异常都是exception的子类，称为标准异常\nclass exception&#123;\npublic:\n    exception () throw();  &#x2F;&#x2F;构造函数\n    exception (const exception&amp;) throw();  &#x2F;&#x2F;拷贝构造函数\n    exception&amp; operator&#x3D; (const exception&amp;) throw();  &#x2F;&#x2F;运算符重载\n    virtual ~exception() throw();  &#x2F;&#x2F;虚析构函数\n    virtual const char* what() const throw();  &#x2F;&#x2F;虚函数\n&#125;</code></pre></li>\n<li><p>异常类型体系</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220827102054460-20220921163542426-20221123125856427.png\" alt=\"image-20220827102054460\"></p>\n</li>\n<li><p>示例一</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class my_exception : public std::runtime_error\n&#123;\npublic:\n    using this_type     &#x3D; my_exception;        &#x2F;&#x2F; 给自己起个别名\n    using super_type    &#x3D; std::runtime_error;  &#x2F;&#x2F; 给父类也起个别名\npublic:\n    my_exception(const char* msg):            &#x2F;&#x2F; 构造函数\n        super_type(msg)                      &#x2F;&#x2F; 别名也可以用于构造\n    &#123;&#125;  \n\n    my_exception() &#x3D; default;                &#x2F;&#x2F; 默认构造函数\n   ~my_exception() &#x3D; default;                &#x2F;&#x2F; 默认析构函数\nprivate:\n    int code &#x3D; 0;                            &#x2F;&#x2F; 其他的内部私有数据\n&#125;;\n\n&#x2F;&#x2F;抛出异常的时候，最好不要直接用throw，而是要封装成一个函数，\n&#x2F;&#x2F;类似于不用new、delete关键字，通过引入一个“中间层”来获得更多的可读性、安全性和灵活性。\n[[noreturn]]                      &#x2F;&#x2F; 属性标签\nvoid raise(const char* msg)      &#x2F;&#x2F; 函数封装throw，没有返回值\n&#123;\n    throw my_exception(msg);     &#x2F;&#x2F; 抛出异常，也可以有更多的逻辑\n&#125;\n\n&#x2F;&#x2F;写 catch 块就像是写一个标准函数，所以入口参数应当使用“const &amp;”的形式，避免对象拷贝的代价\ntry\n&#123;\n    raise(&quot;error occured&quot;);     &#x2F;&#x2F; 函数封装throw，抛出异常\n&#125;\ncatch(const exception&amp; e)      &#x2F;&#x2F; const &amp;捕获异常，可以用基类\n&#123;\n    cout &lt;&lt; e.what() &lt;&lt; endl;  &#x2F;&#x2F; what()是exception的虚函数\n&#125;</code></pre></li>\n<li><p>示例二</p>\n<ul>\n<li>Array 类实现了动态数组，它的主要思路是：在创建对象时预先分配出一定长度的内存（通过 malloc() 分配），内存不够用时就再扩展内存（通过 realloc() 重新分配）。Array 数组只能在尾部一个一个地插入（通过 push() 插入）或删除（通过 pop() 删除）元素。</li>\n<li>我们通过重载过的<code>[ ]</code>运算符来访问数组元素，如果下标过小或过大，就会抛出异常（第53行代码）；在抛出异常的同时，我们还记录了当前数组的长度和要访问的下标。</li>\n<li>在使用 pop() 删除数组元素时，如果当前数组为空，也会抛出错误。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\nusing namespace std;\n&#x2F;&#x2F;自定义的异常类型\nclass OutOfRange&#123;\npublic:\n    OutOfRange(): m_flag(1)&#123; &#125;;\n    OutOfRange(int len, int index): m_len(len), m_index(index), m_flag(2)&#123; &#125;\npublic:\n    void what() const;  &#x2F;&#x2F;获取具体的错误信息\nprivate:\n    int m_flag;  &#x2F;&#x2F;不同的flag表示不同的错误\n    int m_len;  &#x2F;&#x2F;当前数组的长度\n    int m_index;  &#x2F;&#x2F;当前使用的数组下标\n&#125;;\nvoid OutOfRange::what() const &#123;\n    if(m_flag &#x3D;&#x3D; 1)&#123;\n        cout&lt;&lt;&quot;Error: empty array, no elements to pop.&quot;&lt;&lt;endl;\n    &#125;else if(m_flag &#x3D;&#x3D; 2)&#123;\n        cout&lt;&lt;&quot;Error: out of range( array length &quot;&lt;&lt;m_len&lt;&lt;&quot;, access index &quot;&lt;&lt;m_index&lt;&lt;&quot; )&quot;&lt;&lt;endl;\n    &#125;else&#123;\n        cout&lt;&lt;&quot;Unknown exception.&quot;&lt;&lt;endl;\n    &#125;\n&#125;\n&#x2F;&#x2F;实现动态数组\nclass Array&#123;\npublic:\n    Array();\n    ~Array()&#123; free(m_p); &#125;;\npublic:\n    int operator[](int i) const;  &#x2F;&#x2F;获取数组元素\n    int push(int ele);  &#x2F;&#x2F;在末尾插入数组元素\n    int pop();  &#x2F;&#x2F;在末尾删除数组元素\n    int length() const&#123; return m_len; &#125;;  &#x2F;&#x2F;获取数组长度\nprivate:\n    int m_len;  &#x2F;&#x2F;数组长度\n    int m_capacity;  &#x2F;&#x2F;当前的内存能容纳多少个元素\n    int *m_p;  &#x2F;&#x2F;内存指针\nprivate:\n    static const int m_stepSize &#x3D; 50;  &#x2F;&#x2F;每次扩容的步长\n&#125;;\nArray::Array()&#123;\n    m_p &#x3D; (int*)malloc( sizeof(int) * m_stepSize );\n    m_capacity &#x3D; m_stepSize;\n    m_len &#x3D; 0;\n&#125;\nint Array::operator[](int index) const &#123;\n    if( index&lt;0 || index&gt;&#x3D;m_len )&#123;  &#x2F;&#x2F;判断是否越界\n        throw OutOfRange(m_len, index);  &#x2F;&#x2F;抛出异常（创建一个匿名对象）\n    &#125;\n    return *(m_p + index);\n&#125;\nint Array::push(int ele)&#123;\n    if(m_len &gt;&#x3D; m_capacity)&#123;  &#x2F;&#x2F;如果容量不足就扩容\n        m_capacity +&#x3D; m_stepSize;\n        m_p &#x3D; (int*)realloc( m_p, sizeof(int) * m_capacity );  &#x2F;&#x2F;扩容\n    &#125;\n    *(m_p + m_len) &#x3D; ele;\n    m_len++;\n    return m_len-1;\n&#125;\nint Array::pop()&#123;\n    if(m_len &#x3D;&#x3D; 0)&#123;\n         throw OutOfRange();  &#x2F;&#x2F;抛出异常（创建一个匿名对象）\n    &#125;\n    m_len--;\n    return *(m_p + m_len);\n&#125;\n&#x2F;&#x2F;打印数组元素\nvoid printArray(Array &amp;arr)&#123;\n    int len &#x3D; arr.length();\n    &#x2F;&#x2F;判断数组是否为空\n    if(len &#x3D;&#x3D; 0)&#123;\n        cout&lt;&lt;&quot;Empty array! No elements to print.&quot;&lt;&lt;endl;\n        return;\n    &#125;\n    for(int i&#x3D;0; i&lt;len; i++)&#123;\n        if(i &#x3D;&#x3D; len-1)&#123;\n            cout&lt;&lt;arr[i]&lt;&lt;endl;\n        &#125;else&#123;\n            cout&lt;&lt;arr[i]&lt;&lt;&quot;, &quot;;\n        &#125;\n    &#125;\n&#125;\nint main()&#123;\n    Array nums;\n    &#x2F;&#x2F;向数组中添加十个元素\n    for(int i&#x3D;0; i&lt;10; i++)&#123;\n        nums.push(i);\n    &#125;\n    printArray(nums);\n    &#x2F;&#x2F;尝试访问第20个元素\n    try&#123;\n        cout&lt;&lt;nums[20]&lt;&lt;endl;\n    &#125;catch(OutOfRange &amp;e)&#123;\n        e.what();\n    &#125;\n    &#x2F;&#x2F;尝试弹出20个元素\n    try&#123;\n        for(int i&#x3D;0; i&lt;20; i++)&#123;\n            nums.pop();\n        &#125;\n    &#125;catch(OutOfRange &amp;e)&#123;\n        e.what();\n    &#125;\n    printArray(nums);\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n&#x2F;&#x2F;Error: out of range( array length 10, access index 20 )\n&#x2F;&#x2F;Error: empty array, no elements to pop.\n&#x2F;&#x2F;Empty array! No elements to print.</code></pre></li>\n</ul>\n</li>\n<li><p>注意事项：</p>\n<ul>\n<li><p>要仔细分析程序中可能发生的各种错误情况，按严重程度划分出等级。</p>\n<ul>\n<li>对于正常的返回值，或者不太严重、可以重试 / 恢复的错误，我建议你不使用异常，把它们归到正常的流程里。（比如说字符串未找到（不是错误）、数据格式不对（轻微错误）、数据库正忙（可重试错误））</li>\n<li>剩下的那些中级、高级错误也不是都必须用异常，你还要再做分析，尽量降低引入异常的成本。</li>\n</ul>\n</li>\n<li><p>使用异常的判断准则</p>\n<ul>\n<li>不允许被忽略的错误</li>\n<li>极少数情况下才会发生的错误</li>\n<li>严重影响正常流程，很难恢复到正常状态的错误</li>\n<li>无法本地处理，必须“穿透”调用栈，传递到上层才能被处理的错误</li>\n</ul>\n</li>\n<li><p>noexcept</p>\n<ul>\n<li><p>noexcept 专门用来修饰函数，告诉编译器：这个函数不会抛出异常。编译器看到 noexcept，就得到了一个“保证”，就可以对函数做优化，不去加那些栈展开的额外代码，消除异常处理的成本</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void func_noexcept() noexcept            &#x2F;&#x2F; 声明绝不会抛出异常\n&#123;\n    cout &lt;&lt; &quot;noexcept&quot; &lt;&lt; endl;\n&#125;</code></pre></li>\n<li><p>noexcept 只是做出了一个“不可靠的承诺”，不是“强保证”，编译器无法彻底检查它的行为，标记为 noexcept 的函数也有可能抛出异常</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void func_maybe_noexcept() noexcept          &#x2F;&#x2F; 声明绝不会抛出异常\n&#123;\n    throw &quot;Oh My God&quot;;                    &#x2F;&#x2F; 但也可以抛出异常\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-函数式编程（lambda）\"><a href=\"#6-函数式编程（lambda）\" class=\"headerlink\" title=\"6.函数式编程（lambda）\"></a>6.函数式编程（lambda）</h3><ol>\n<li><p>C++函数的特殊性</p>\n<ul>\n<li><p>函数的目的是封装执行的细节，简化程序的复杂度，但因为它有入口参数，有返回值，形式上和数学里的函数很像，所以就被称为“函数”</p>\n</li>\n<li><p>在语法层面上，C/C++里的函数是比较特别的，虽然存在函数类型，但不存在对应类型的变量，需要用指针去简洁操作</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void my_square(int x)           &#x2F;&#x2F; 定义一个函数\n&#123;\n    cout &lt;&lt; x*x &lt;&lt; endl;       &#x2F;&#x2F; 函数的具体内容\n&#125;\n\nauto pfunc &#x3D; &amp;my_square;       &#x2F;&#x2F; 只能用指针去操作函数，指针不是函数\n(*pfunc)(3);                    &#x2F;&#x2F; 可以用*访问函数\npfunc(3);                       &#x2F;&#x2F; 也可以直接调用函数指针</code></pre></li>\n<li><p>用法上，所有的函数都是全局的，没有生命周期的。而且函数都是平级的，不能在函数中在定义函数</p>\n</li>\n</ul>\n</li>\n<li><p>lambda表达式</p>\n<ul>\n<li><p>示例：lambda表达式是一个变量，可以随时在调用点定义函数，而且可以将多个小的lambda表达式组合成一个复杂的大lambda表达式</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto func &#x3D; [](int x)          &#x2F;&#x2F; 定义一个lambda表达式\n&#123;   \n    cout &lt;&lt; x*x &lt;&lt; endl;      &#x2F;&#x2F; lambda表达式的具体内容\n&#125;;  \n\nfunc(3);                      &#x2F;&#x2F; 调用lambda表达式</code></pre></li>\n</ul>\n</li>\n<li><p>注意事项</p>\n<ul>\n<li><p>语法形式</p>\n<ul>\n<li><p>通过lambda引出符号[]，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto f1 &#x3D; []()&#123;&#125;;      &#x2F;&#x2F; 相当于空函数，什么也不做</code></pre></li>\n<li><p>良好的缩进格式</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto f2 &#x3D; []()                 &#x2F;&#x2F; 定义一个lambda表达式，必须使用auto，或匿名使用\n&#123;\n    cout &lt;&lt; &quot;lambda f2&quot; &lt;&lt; endl;\n\n    auto f3 &#x3D; [](int x)         &#x2F;&#x2F; 嵌套定义lambda表达式\n    &#123;\n        return x*x;\n    &#125;;&#x2F;&#x2F; lambda f3              &#x2F;&#x2F; 使用注释显式说明表达式结束\n\n    cout &lt;&lt; f3(10) &lt;&lt; endl;\n&#125;;  &#x2F;&#x2F; lambda f2               &#x2F;&#x2F; 使用注释显式说明表达式结束\n\n&#x2F;&#x2F;匿名使用\nvector&lt;int&gt; v &#x3D; &#123;3, 1, 8, 5, 0&#125;;     &#x2F;&#x2F; 标准容器\n\ncout &lt;&lt; *find_if(begin(v), end(v),   &#x2F;&#x2F; 标准库里的查找算法\n            [](int x)                &#x2F;&#x2F; 匿名lambda表达式，不需要auto赋值\n            &#123;\n                return x &gt;&#x3D; 5;        &#x2F;&#x2F; 用做算法的谓词判断条件 \n            &#125;                        &#x2F;&#x2F; lambda表达式结束\n        )\n     &lt;&lt; endl;                        &#x2F;&#x2F; 语句执行完，lambda表达式就不存在了</code></pre></li>\n</ul>\n</li>\n<li><p>变量捕获规则：外部变量可以理解为lambda表达式定义前所有出现的变量</p>\n<ul>\n<li><p>“[=]”表示按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改</p>\n</li>\n<li><p>“[&amp;]”是按引用捕获所有外部变量，内部以引用的方式使用，可以修改</p>\n</li>\n<li><p>可以在“[]”里明确写出外部变量名，指定按值或者按引用捕获</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int x &#x3D; 33;               &#x2F;&#x2F; 一个外部变量\n\nauto f1 &#x3D; [&#x3D;]()           &#x2F;&#x2F; lambda表达式，用“&#x3D;”按值捕获\n&#123;\n    &#x2F;&#x2F;x +&#x3D; 10;            &#x2F;&#x2F; x只读，不允许修改\n&#125;;\n\nauto f2 &#x3D; [&amp;]()         &#x2F;&#x2F; lambda表达式，用“&amp;”按引用捕获\n&#123;\n    x +&#x3D; 10;            &#x2F;&#x2F; x是引用，可以修改\n&#125;;\n\nauto f3 &#x3D; [&#x3D;, &amp;x]()       &#x2F;&#x2F; lambda表达式，用“&amp;”按引用捕获x，其他的按值捕获\n&#123;\n    x +&#x3D; 20;              &#x2F;&#x2F; x是引用，可以修改\n&#125;;</code></pre></li>\n</ul>\n</li>\n<li><p>泛型：在 C++14 里，lambda 表达式可以实现“泛型化”，相当于简化了的模板函数，主要利用了auto</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto f &#x3D; [](const auto&amp; x)        &#x2F;&#x2F; 参数使用auto声明，泛型化\n&#123;\n    return x + x;\n&#125;;\n\ncout &lt;&lt; f(3) &lt;&lt; endl;             &#x2F;&#x2F; 参数类型是int\ncout &lt;&lt; f(0.618) &lt;&lt; endl;         &#x2F;&#x2F; 参数类型是double\n\nstring str &#x3D; &quot;matrix&quot;;\ncout &lt;&lt; f(str) &lt;&lt; endl;          &#x2F;&#x2F; 参数类型是string</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-面向对象\"><a href=\"#2-面向对象\" class=\"headerlink\" title=\"2.面向对象\"></a>2.面向对象</h2><h3 id=\"1-类和对象\"><a href=\"#1-类和对象\" class=\"headerlink\" title=\"1.类和对象\"></a>1.类和对象</h3><ol>\n<li><p>面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。</p>\n</li>\n<li><p>类的定义：类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Student&#123;\npublic:\n    &#x2F;&#x2F;成员变量\n    char *name;\n    int age;\n    float score;\n\n    &#x2F;&#x2F;成员函数\n    void say()&#123;\n        cout&lt;&lt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl;\n    &#125;\n    &#x2F;&#x2F;注意在类定义的最后有一个分号;，它是类定义的一部分，表示类定义结束了，不能省略\n&#125;;\n\nStudent stu;  &#x2F;&#x2F;创建对象，class 关键字可要可不要\nstu.name &#x3D; &quot;abc&quot;;&#x2F;&#x2F;访问类的成员\n\n&#x2F;&#x2F;使用对象指针\n&#x2F;&#x2F;因为是在栈上分配内存，所以需要使用&amp;获取它的地址\nStudent stu;\nStudent *pStu &#x3D; &amp;stu;\n&#x2F;&#x2F;在堆上创建对象\nStudent *pStu &#x3D; new Student;\n&#x2F;&#x2F;有了对象指针后，可以通过箭头-&gt;来访问对象的成员变量和成员函数\npStu-&gt;name &#x3D; &quot;def&quot;;\n</code></pre></li>\n<li><p>成员函数：可以在类体外定义成员函数，但是类体中定义的成员函数会自动成为内联函数。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Student&#123;\npublic:\n    char *name;\n    int age;\n    float score;\n    void say();  &#x2F;&#x2F;内联函数声明，可以增加 inline 关键字，但编译器会忽略\n&#125;;\n&#x2F;&#x2F;函数定义，这样，say() 就会变成内联函数。\n&#x2F;&#x2F;虽然 C++ 支持将内联函数定义在类的外部，但建议将函数定义在类的内部，不建议像下面这么写\ninline void Student::say()&#123;\n    cout&lt;&lt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;可以将函数定义放在类体外面，非内联函数\nvoid Student::sayHello()&#123;\n    cout&lt;&lt;&quot;Hello &quot;&lt;&lt;name&lt;&lt;endl;\n&#125;</code></pre></li>\n<li><p>访问权限</p>\n<ol>\n<li>C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是你能不能使用该类中的成员。==C++ 中的 public、private、protected 只能修饰类的成员，不能修饰类==<ol>\n<li>在类的内部（定义类的代码内部），无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。</li>\n<li>在类的外部（定义类的代码之外），只能通过对象访问成员，并且通过对象只能访问 public 属性的成员，不能访问 private、protected 属性的成员。</li>\n</ol>\n</li>\n<li>成员变量大都以<code>m_</code>开头，这是约定成俗的写法，不是语法规定的内容。以<code>m_</code>开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。</li>\n<li>声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private 部分，也可以先出现 public 部分。如果既不写 private 也不写 public，就默认为 private。</li>\n</ol>\n</li>\n<li><p>构造函数：名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配。（调用没有参数的构造函数也可以省略括号）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nclass Student&#123;\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\npublic:\n    &#x2F;&#x2F;声明构造函数\n    Student(char *name, int age, float score);\n&#125;;\n&#x2F;&#x2F;定义构造函数\nStudent::Student()&#123;\n    m_name &#x3D; NULL;\n    m_age &#x3D; 0;\n    m_score &#x3D; 0.0;\n&#125;\n&#x2F;&#x2F;重载构造函数\nStudent::Student(char *name, int age, float score)&#123;\n    m_name &#x3D; name;\n    m_age &#x3D; age;\n    m_score &#x3D; score;\n&#125;\n&#x2F;&#x2F;采用初始化列表，使得代码更加简洁，使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便\n&#x2F;&#x2F;相当于函数体内部的m_name &#x3D; name; m_age &#x3D; age; m_score &#x3D; score;\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age)&#123;\n    &#x2F;&#x2F; 初始化列表可以用于全部成员变量，也可以只用于部分成员变量\n    m_score &#x3D; score;\n    &#x2F;&#x2F;TODO:\n&#125;\n&#x2F;&#x2F; 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关\n</code></pre></li>\n<li><p>C++析构函数：是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个<code>~</code>符号。new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nclass VLA&#123;\npublic:\n    VLA(int len);  &#x2F;&#x2F;构造函数\n    ~VLA();  &#x2F;&#x2F;析构函数\npublic:\n    void input();  &#x2F;&#x2F;从控制台输入数组元素\n    void show();  &#x2F;&#x2F;显示数组元素\nprivate:\n    int *at(int i);  &#x2F;&#x2F;获取第i个元素的指针\nprivate:\n    const int m_len;  &#x2F;&#x2F;数组长度\n    int *m_arr; &#x2F;&#x2F;数组指针\n    int *m_p;  &#x2F;&#x2F;指向数组第i个元素的指针\n&#125;;\nVLA::VLA(int len): m_len(len)&#123;  &#x2F;&#x2F;使用初始化列表来给 m_len 赋值\n    if(len &gt; 0)&#123; m_arr &#x3D; new int[len];  &#x2F;*分配内存*&#x2F; &#125;\n    else&#123; m_arr &#x3D; NULL; &#125;\n&#125;\nVLA::~VLA()&#123;\n    delete[] m_arr;  &#x2F;&#x2F;释放内存\n&#125;\nint main()&#123;\n    &#x2F;&#x2F;创建一个有n个元素的数组（对象）\n    int n;\n    cout&lt;&lt;&quot;Input array length: &quot;;\n    cin&gt;&gt;n;\n    VLA *parr &#x3D; new VLA(n);\n    &#x2F;&#x2F;删除数组（对象）\n    delete parr;\n    return 0;\n&#125;</code></pre></li>\n<li><p>this指针：是 C++中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。this 实际上是成员函数的一个形参，在调用成员函数时将当前对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</p>\n<ul>\n<li>this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。</li>\n<li>this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。</li>\n<li>只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用（后续会讲到 static 成员）。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Student::setname(char *name)&#123;\n    this-&gt;name &#x3D; name;\n&#125;</code></pre></li>\n<li><p>static</p>\n<ol>\n<li><p>static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为静态变量分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了这一静态变量，也会影响到其他对象。static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。</p>\n</li>\n<li><p>static 成员变量必须在类声明的外部初始化，具体形式为：<code>type class::name = value;</code>，被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化。static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。</p>\n</li>\n<li><p>static成员函数只能访问静态成员，静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p>\n</li>\n<li><p>静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p>\n</li>\n</ol>\n</li>\n<li><p>const</p>\n<ol>\n<li><p>const 成员变量的用法和普通 const 变量的用法相似，只需要在声明时加上 const 关键字。初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;初始化 const 成员变量的唯一方法就是使用初始化列表\nclass VLA&#123;\nprivate:\n    const int m_len;\n    int *m_arr;\npublic:\n    VLA(int len);\n&#125;;\n&#x2F;&#x2F;必须使用初始化列表来初始化 m_len\nVLA::VLA(int len): m_len(len)&#123;\n    m_arr &#x3D; new int[len];\n&#125;</code></pre></li>\n<li><p>const成员函数：const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以<code>get</code>开头，后跟成员变量的名字，所以通常将它们称为 get 函数。常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字，请看下面的例子：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Student&#123;\npublic:\n    Student(char *name, int age, float score);\n    void show();\n    &#x2F;&#x2F;声明常成员函数\n    char *getname() const;\n    int getage() const;\n    float getscore() const;\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\nvoid Student::show()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;m_score&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;定义常成员函数\n&#x2F;&#x2F;需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字,如果只在一个地方加 const 会导致声明和定义处的函数原型冲突\nchar * Student::getname() const&#123;\n    return m_name;\n&#125;</code></pre></li>\n<li><p>在C++中，const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const  class  object(params);\nclass const object(params);\nconst class *p &#x3D; new class(params);\nclass const *p &#x3D; new class(params);</code></pre></li>\n</ol>\n</li>\n<li><p>firend</p>\n<ol>\n<li><p>在C++中，借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。</p>\n</li>\n<li><p>在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。 </p>\n</li>\n<li><p>一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员</p>\n<ol>\n<li><p>将非成员函数声明为友元函数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nclass Student&#123;\npublic:\n    Student(char *name, int age, float score);\npublic:\n    friend void show(Student *pstu);  &#x2F;&#x2F;将show()声明为友元函数\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\n&#x2F;&#x2F;非成员函数\nvoid show(Student *pstu)&#123;\n    &#x2F;&#x2F;注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象，如直接访问m_name\n    cout&lt;&lt;pstu-&gt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;pstu-&gt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;pstu-&gt;m_score&lt;&lt;endl;\n&#125;\nint main()&#123;\n    Student stu(&quot;小明&quot;, 15, 90.6);\n    show(&amp;stu);  &#x2F;&#x2F;调用友元函数\n    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);\n    show(pstu);  &#x2F;&#x2F;调用友元函数\n    return 0;\n&#125;</code></pre></li>\n<li><p>将其他类的成员函数声明为友元函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;提前声明Address类\n&#x2F;&#x2F;如果不提前声明，编译器会报错，提示&#39;Address&#39; has not been declared\nclass Address;  \n&#x2F;&#x2F;声明Student类\nclass Student&#123;\npublic:\n    Student(char *name, int age, float score);\npublic:\n    void show(Address *addr);\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\n&#x2F;&#x2F;声明Address类\nclass Address&#123;\nprivate:\n    char *m_province;  &#x2F;&#x2F;省份\n    char *m_city;  &#x2F;&#x2F;城市\n    char *m_district;  &#x2F;&#x2F;区（市区）\npublic:\n    Address(char *province, char *city, char *district);\n    &#x2F;&#x2F;将Student类中的成员函数show()声明为友元函数\n    friend void Student::show(Address *addr);\n&#125;;\n&#x2F;&#x2F;实现Student类\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\nvoid Student::show(Address *addr)&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;\n    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;实现Address类\nAddress::Address(char *province, char *city, char *district)&#123;\n    m_province &#x3D; province;\n    m_city &#x3D; city;\n    m_district &#x3D; district;\n&#125;\nint main()&#123;\n    Student stu(&quot;小明&quot;, 16, 95.5f);\n    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);\n    stu.show(&amp;addr);\n   \n    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);\n    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);\n    pstu -&gt; show(paddr);\n    return 0;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>友元类：不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。除非有必要，一般不建议把整个类声明为友元类，而只将某些成员函数声明为友元函数，这样更安全一些。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nclass Address;  &#x2F;&#x2F;提前声明Address类\n&#x2F;&#x2F;声明Student类\nclass Student&#123;\npublic:\n    Student(char *name, int age, float score);\npublic:\n    void show(Address *addr);\nprivate:\n    char *m_name;\n    int m_age;\n    float m_score;\n&#125;;\n&#x2F;&#x2F;声明Address类\nclass Address&#123;\npublic:\n    Address(char *province, char *city, char *district);\npublic:\n    &#x2F;&#x2F;将Student类声明为Address类的友元类\n    friend class Student;\nprivate:\n    char *m_province;  &#x2F;&#x2F;省份\n    char *m_city;  &#x2F;&#x2F;城市\n    char *m_district;  &#x2F;&#x2F;区（市区）\n&#125;;\n&#x2F;&#x2F;实现Student类\nStudent::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score)&#123; &#125;\nvoid Student::show(Address *addr)&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是 &quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是 &quot;&lt;&lt;m_score&lt;&lt;endl;\n    cout&lt;&lt;&quot;家庭住址：&quot;&lt;&lt;addr-&gt;m_province&lt;&lt;&quot;省&quot;&lt;&lt;addr-&gt;m_city&lt;&lt;&quot;市&quot;&lt;&lt;addr-&gt;m_district&lt;&lt;&quot;区&quot;&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;实现Address类\nAddress::Address(char *province, char *city, char *district)&#123;\n    m_province &#x3D; province;\n    m_city &#x3D; city;\n    m_district &#x3D; district;\n&#125;\nint main()&#123;\n    Student stu(&quot;小明&quot;, 16, 95.5f);\n    Address addr(&quot;陕西&quot;, &quot;西安&quot;, &quot;雁塔&quot;);\n    stu.show(&amp;addr);\n   \n    Student *pstu &#x3D; new Student(&quot;李磊&quot;, 16, 80.5);\n    Address *paddr &#x3D; new Address(&quot;河北&quot;, &quot;衡水&quot;, &quot;桃城&quot;);\n    pstu -&gt; show(paddr);\n    return 0;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-引用\"><a href=\"#2-引用\" class=\"headerlink\" title=\"2.引用\"></a>2.引用</h3><ol>\n<li><p>参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。对于像 char、bool、int、float 等基本类型的数据，占用的内存少，对它们进行内存拷贝非常快速。而数组、结构体、对象是一系列数据的集合，占用的内存大，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。在C语言中，一般使用指针，但在C++还可以使用引用。</p>\n</li>\n<li><p>引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。引用类似于 Windows 中的快捷方式，一个可执行程序可以有多个快捷方式，通过这些快捷方式和可执行程序本身都能够运行程序；引用还类似于人的绰号（笔名），使用绰号（笔名）和本名都能表示一个人。引用的定义方式类似于指针，只是用<code>&amp;</code>取代了<code>*</code>，语法格式为：<code>type &amp;name = data;</code>。</p>\n</li>\n<li><p>引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。</p>\n</li>\n<li><p>引用使用方式</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nint main() &#123;\n    int a &#x3D; 99;\n    int &amp;r &#x3D; a;\n    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; endl;&#x2F;&#x2F;99,99\n    cout &lt;&lt; &amp;a &lt;&lt; &quot;, &quot; &lt;&lt; &amp;r &lt;&lt; endl;&#x2F;&#x2F;0x28ff44, 0x28ff44\n    r &#x3D; 47;\n    cout &lt;&lt; a &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; endl;&#x2F;&#x2F;47.47\n    return 0;\n&#125;</code></pre></li>\n<li><p>引用作为函数参数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nvoid swap1(int a, int b);\nvoid swap2(int *p1, int *p2);\nvoid swap3(int &amp;r1, int &amp;r2);\nint main() &#123;\n    int num1, num2;\n    cout &lt;&lt; &quot;Input two integers: &quot;;\n    cin &gt;&gt; num1 &gt;&gt; num2;\n    swap1(num1, num2);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    cout &lt;&lt; &quot;Input two integers: &quot;;\n    cin &gt;&gt; num1 &gt;&gt; num2;\n    swap2(&amp;num1, &amp;num2);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    cout &lt;&lt; &quot;Input two integers: &quot;;\n    cin &gt;&gt; num1 &gt;&gt; num2;\n    swap3(num1, num2);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;直接传递参数内容\nvoid swap1(int a, int b) &#123;\n    int temp &#x3D; a;\n    a &#x3D; b;\n    b &#x3D; temp;\n&#125;\n&#x2F;&#x2F;传递指针\nvoid swap2(int *p1, int *p2) &#123;\n    int temp &#x3D; *p1;\n    *p1 &#x3D; *p2;\n    *p2 &#x3D; temp;\n&#125;\n&#x2F;&#x2F;按引用传参\nvoid swap3(int &amp;r1, int &amp;r2) &#123;\n    int temp &#x3D; r1;\n    r1 &#x3D; r2;\n    r2 &#x3D; temp;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;Input two integers: 12 34↙\n&#x2F;&#x2F;12 34\n&#x2F;&#x2F;Input two integers: 88 99↙\n&#x2F;&#x2F;99 88\n&#x2F;&#x2F;Input two integers: 100 200↙\n&#x2F;&#x2F;200 100</code></pre></li>\n<li><p>引用作为函数返回值</p>\n<ul>\n<li>在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nint &amp;plus10(int &amp;r) &#123;\n    r +&#x3D; 10;\n    return r;\n&#125;\nint main() &#123;\n    int num1 &#x3D; 10;\n    int num2 &#x3D; plus10(num1);\n    cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;20 20\n</code></pre></li>\n</ol>\n<h3 id=\"3-继承和派生\"><a href=\"#3-继承和派生\" class=\"headerlink\" title=\"3.继承和派生\"></a>3.继承和派生</h3><ol>\n<li><p>继承</p>\n<ol>\n<li><p>术语：被继承的类称为父类或基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。</p>\n</li>\n<li><p>三种继承方式：继承方式限定了基类成员在派生类中的访问权限，包括 public（公有的）、private（私有的）和 protected（受保护的）。此项是可选项，如果不写，默认为 private（成员变量和成员函数默认也是 private）。</p>\n<ol>\n<li>public继承方式<ul>\n<li>基类中所有 public 成员在派生类中为 public 属性；</li>\n<li>基类中所有 protected 成员在派生类中为 protected 属性；</li>\n<li>基类中所有 private 成员在派生类中不能使用。</li>\n</ul>\n</li>\n<li>protected继承方式<ul>\n<li>基类中的所有 public 成员在派生类中为 protected 属性；</li>\n<li>基类中的所有 protected 成员在派生类中为 protected 属性；</li>\n<li>基类中的所有 private 成员在派生类中不能使用。</li>\n</ul>\n</li>\n<li>private继承方式<ul>\n<li>基类中的所有 public 成员在派生类中均为 private 属性；</li>\n<li>基类中的所有 protected 成员在派生类中均为 private 属性；</li>\n<li>基类中的所有 private 成员在派生类中不能使用。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>private成员：我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它只是在派生类中不可见，导致无法使用罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。在派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问。</p>\n</li>\n<li><p>继承实现代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类People\nclass People&#123;\npublic:\n    void setname(char *name);\n    void setage(int age);\n    void sethobby(char *hobby);\n    char *gethobby();\nprotected:\n    char *m_name;\n    int m_age;\nprivate:\n    char *m_hobby;\n&#125;;\nvoid People::setname(char *name)&#123; m_name &#x3D; name; &#125;\nvoid People::setage(int age)&#123; m_age &#x3D; age; &#125;\nvoid People::sethobby(char *hobby)&#123; m_hobby &#x3D; hobby; &#125;\nchar *People::gethobby()&#123; return m_hobby; &#125;\n&#x2F;&#x2F;派生类Student\nclass Student: public People&#123;\npublic:\n    void setscore(float score);\nprotected:\n    float m_score;\n&#125;;\nvoid Student::setscore(float score)&#123; m_score &#x3D; score; &#125;\n&#x2F;&#x2F;派生类Pupil\nclass Pupil: public Student&#123;\npublic:\n    void setranking(int ranking);\n    void display();\nprivate:\n    int m_ranking;\n&#125;;\nvoid Pupil::setranking(int ranking)&#123; m_ranking &#x3D; ranking; &#125;\nvoid Pupil::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，考试成绩为&quot;&lt;&lt;m_score&lt;&lt;&quot;分，班级排名第&quot;&lt;&lt;m_ranking&lt;&lt;&quot;，TA喜欢&quot;&lt;&lt;gethobby()&lt;&lt;&quot;。&quot;&lt;&lt;endl;\n&#125;\nint main()&#123;\n    Pupil pup;\n    pup.setname(&quot;小明&quot;);\n    pup.setage(15);\n    pup.setscore(92.5f);\n    pup.setranking(4);\n    pup.sethobby(&quot;乒乓球&quot;);\n    pup.display();\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果\n&#x2F;&#x2F;小明的年龄是15，考试成绩为92.5分，班级排名第4，TA喜欢乒乓球。</code></pre></li>\n<li><p>改变访问权限：使用 using 关键字可以改变基类成员在派生类中的访问权限，例如将 public 改为 private、将 protected 改为 public。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类People\nclass People &#123;\npublic:\n    void show();\nprotected:\n    char *m_name;\n    int m_age;\n&#125;;\nvoid People::show() &#123;\n    cout &lt;&lt; m_name &lt;&lt; &quot;的年龄是&quot; &lt;&lt; m_age &lt;&lt; endl;\n&#125;\n&#x2F;&#x2F;派生类Student\nclass Student : public People &#123;\npublic:\n    void learning();\npublic:\n    using People::m_name;  &#x2F;&#x2F;将protected改为public\n    using People::m_age;  &#x2F;&#x2F;将protected改为public\n    float m_score;\nprivate:\n    using People::show;  &#x2F;&#x2F;将public改为private\n&#125;;\nvoid Student::learning() &#123;\n    cout &lt;&lt; &quot;我是&quot; &lt;&lt; m_name &lt;&lt; &quot;，今年&quot; &lt;&lt; m_age &lt;&lt; &quot;岁，这次考了&quot; &lt;&lt; m_score &lt;&lt; &quot;分！&quot; &lt;&lt; endl;\n&#125;\nint main() &#123;\n    Student stu;\n    stu.m_name &#x3D; &quot;小明&quot;;\n    stu.m_age &#x3D; 16;\n    stu.m_score &#x3D; 99.5f;\n    &#x2F;&#x2F;因为 show() 函数是 private 属性的，所以代码第 36 行会报错\n    stu.show();  &#x2F;&#x2F;compile error\n    stu.learning();\n    return 0;\n&#125;</code></pre></li>\n<li><p>C++继承时的名字遮蔽问题</p>\n<ol>\n<li>如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会遮蔽从基类继承过来的成员。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。</li>\n<li>基类成员和派生类成员的名字一样时会造成遮蔽，这句话对于成员变量很好理解，对于成员函数要引起注意，不管函数的参数如何，只要名字一样就会造成遮蔽。换句话说，基类成员函数和派生类成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，不管它们的参数是否一样。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>基类和派生类的构造函数和析构函数</p>\n<ol>\n<li><p>类的构造函数不能被继承，因为名字不一样，所以继承了也不能成为派生类的构造函数。在派生类中，继承过来的成员变量的初始化工作也要由派生类的构造函数完成，因为会有private属性的成员变量，所以通常在派生类中的构造函数中调用基类的构造函数。而且，会先调用基类构造函数，再调用派生类构造函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;People(name, age)就是调用基类的构造函数\nStudent::Student(char *name, int age, float score): People(name, age), m_score(score)&#123; &#125;\nvoid Student::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;m_age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;m_score&lt;&lt;&quot;。&quot;&lt;&lt;endl;\n&#125;</code></pre></li>\n<li><p>事实上，通过派生类创建对象时必须要调用基类的构造函数，这是语法规定。换句话说，定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么编译失败。</p>\n</li>\n<li><p>和构造函数类似，析构函数也不能被继承。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。</p>\n</li>\n</ol>\n</li>\n<li><p>多继承</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类\nclass BaseA&#123;\npublic:\n    BaseA(int a, int b);\n    ~BaseA();\npublic:\n    void show();\nprotected:\n    int m_a;\n    int m_b;\n&#125;;\nBaseA::BaseA(int a, int b): m_a(a), m_b(b)&#123;\n    cout&lt;&lt;&quot;BaseA constructor&quot;&lt;&lt;endl;\n&#125;\nBaseA::~BaseA()&#123;\n    cout&lt;&lt;&quot;BaseA destructor&quot;&lt;&lt;endl;\n&#125;\nvoid BaseA::show()&#123;\n    cout&lt;&lt;&quot;m_a &#x3D; &quot;&lt;&lt;m_a&lt;&lt;endl;\n    cout&lt;&lt;&quot;m_b &#x3D; &quot;&lt;&lt;m_b&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;基类\nclass BaseB&#123;\npublic:\n    BaseB(int c, int d);\n    ~BaseB();\n    void show();\nprotected:\n    int m_c;\n    int m_d;\n&#125;;\nBaseB::BaseB(int c, int d): m_c(c), m_d(d)&#123;\n    cout&lt;&lt;&quot;BaseB constructor&quot;&lt;&lt;endl;\n&#125;\nBaseB::~BaseB()&#123;\n    cout&lt;&lt;&quot;BaseB destructor&quot;&lt;&lt;endl;\n&#125;\nvoid BaseB::show()&#123;\n    cout&lt;&lt;&quot;m_c &#x3D; &quot;&lt;&lt;m_c&lt;&lt;endl;\n    cout&lt;&lt;&quot;m_d &#x3D; &quot;&lt;&lt;m_d&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;派生类\nclass Derived: public BaseA, public BaseB&#123;\npublic:\n    Derived(int a, int b, int c, int d, int e);\n    ~Derived();\npublic:\n    void display();\nprivate:\n    int m_e;\n&#125;;\nDerived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e)&#123;\n    cout&lt;&lt;&quot;Derived constructor&quot;&lt;&lt;endl;\n&#125;\nDerived::~Derived()&#123;\n    cout&lt;&lt;&quot;Derived destructor&quot;&lt;&lt;endl;\n&#125;\nvoid Derived::display()&#123;\n    &#x2F;&#x2F;当两个或多个基类中有同名的成员时，如果直接访问该成员，就会产生命名冲突，\n    &#x2F;&#x2F;编译器不知道使用哪个基类的成员。这个时候需要在成员名字前面加上\n    &#x2F;&#x2F;类名和域解析符::，以显式地指明到底使用哪个类的成员，消除二义性。\n    BaseA::show();  &#x2F;&#x2F;调用BaseA类的show()函数\n    BaseB::show();  &#x2F;&#x2F;调用BaseB类的show()函数\n    cout&lt;&lt;&quot;m_e &#x3D; &quot;&lt;&lt;m_e&lt;&lt;endl;\n&#125;\nint main()&#123;\n    Derived obj(1, 2, 3, 4, 5);\n    obj.display();\n    return 0;\n&#125;</code></pre></li>\n<li><p>虚继承</p>\n<ol>\n<li>为了解决多继承时的命名冲突和冗余数据问题，C++提出了虚继承，使得在派生类中只保留一份间接基类的成员，在继承方式前面加上 virtual 关键字就是虚继承</li>\n<li>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</li>\n<li>在虚继承中，虚基类是由最终的派生类初始化的，换句话说，最终派生类的构造函数必须要调用虚基类的构造函数。对最终的派生类来说，虚基类是间接基类，而不是直接基类。这跟普通继承不同，在普通继承中，派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。</li>\n</ol>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;间接基类A\nclass A&#123;\nprotected:\n    int m_a;\n&#125;;\n&#x2F;&#x2F;直接基类B\nclass B: virtual public A&#123;  &#x2F;&#x2F;虚继承\nprotected:\n    int m_b;\n&#125;;\n&#x2F;&#x2F;直接基类C\nclass C: virtual public A&#123;  &#x2F;&#x2F;虚继承\nprotected:\n    int m_c;\n&#125;;\n&#x2F;&#x2F;派生类D\nclass D: public B, public C&#123;\npublic:\n    void seta(int a)&#123; m_a &#x3D; a; &#125;  &#x2F;&#x2F;正确\n    void setb(int b)&#123; m_b &#x3D; b; &#125;  &#x2F;&#x2F;正确\n    void setc(int c)&#123; m_c &#x3D; c; &#125;  &#x2F;&#x2F;正确\n    void setd(int d)&#123; m_d &#x3D; d; &#125;  &#x2F;&#x2F;正确\nprivate:\n    int m_d;\n&#125;;\nint main()&#123;\n    D d;\n    return 0;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"4-多态与虚函数\"><a href=\"#4-多态与虚函数\" class=\"headerlink\" title=\"4.多态与虚函数\"></a>4.多态与虚函数</h3><ol>\n<li><p>向上转型：包括三种情况：通过<code>a=b</code>，将派生类b的派生属性忽略掉，将基类属性的值赋值给a，成员函数不受影响</p>\n<ul>\n<li>派生类对象赋值给基类对象</li>\n<li>派生类指针赋值给基类指针：编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。</li>\n<li>派生类引用赋值给基类引用：引用和指针相同，因为引用和指针并没有本质上的区别，引用仅仅是对指针进行了简单封装</li>\n</ul>\n</li>\n<li><p>因为通过基类指针只能访问派生类的成员变量，但是不能访问派生类的成员函数。为了消除这种尴尬，让基类指针能够访问派生类的成员函数，C++ 增加了<strong>虚函数（Virtual Function）</strong>。使用虚函数非常简单，只需要在函数声明前面增加 virtual 关键字。<code>virtual void display();</code></p>\n<ul>\n<li><strong>什么时候声明虚函数</strong>：首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。</li>\n</ul>\n</li>\n<li><p>有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为<strong>多态（Polymorphism）</strong>。</p>\n</li>\n<li><p>多态实现</p>\n<ul>\n<li>必须存在继承关系；</li>\n<li>继承关系中必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）。</li>\n<li>存在基类的指针，通过该指针调用虚函数。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;基类People\nclass People&#123;\npublic:\n    People(char *name, int age);\n    virtual void display();  &#x2F;&#x2F;声明为虚函数\nprotected:\n    char *m_name;\n    int m_age;\n&#125;;\nPeople::People(char *name, int age): m_name(name), m_age(age)&#123;&#125;\nvoid People::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是个无业游民。&quot;&lt;&lt;endl;\n&#125;\n&#x2F;&#x2F;派生类Teacher\nclass Teacher: public People&#123;\npublic:\n    Teacher(char *name, int age, int salary);\n    virtual void display();  &#x2F;&#x2F;声明为虚函数\nprivate:\n    int m_salary;\n&#125;;\nTeacher::Teacher(char *name, int age, int salary): People(name, age), m_salary(salary)&#123;&#125;\nvoid Teacher::display()&#123;\n    cout&lt;&lt;m_name&lt;&lt;&quot;今年&quot;&lt;&lt;m_age&lt;&lt;&quot;岁了，是一名教师，每月有&quot;&lt;&lt;m_salary&lt;&lt;&quot;元的收入。&quot;&lt;&lt;endl;\n&#125;\nint main()&#123;\n    People *p &#x3D; new People(&quot;王志刚&quot;, 23);\n    p -&gt; display();\n    p &#x3D; new Teacher(&quot;赵宏佳&quot;, 45, 8200);\n    p -&gt; display();\n    return 0;\n&#125;</code></pre></li>\n<li><p>纯虚函数和抽象类</p>\n<ol>\n<li>在C++中，可以将虚函数声明为纯虚函数，语法格式为：<code>virtual 返回值类型 函数名 (函数参数) = 0;</code>，纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上<code>=0</code>，表明此函数为纯虚函数。<ul>\n<li>一个纯虚函数就可以使类成为抽象基类，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。</li>\n<li>只有类中的虚函数才能被声明为纯虚函数，普通成员函数和顶层函数均不能声明为纯虚函数。</li>\n</ul>\n</li>\n<li>包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。</li>\n<li>抽象类实现</li>\n</ol>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\n&#x2F;&#x2F;线\nclass Line&#123;\npublic:\n    Line(float len);\n    virtual float area() &#x3D; 0;\n    virtual float volume() &#x3D; 0;\nprotected:\n    float m_len;\n&#125;;\nLine::Line(float len): m_len(len)&#123; &#125;\n&#x2F;&#x2F;矩形\nclass Rec: public Line&#123;\npublic:\n    Rec(float len, float width);\n    float area();\nprotected:\n    float m_width;\n&#125;;\nRec::Rec(float len, float width): Line(len), m_width(width)&#123; &#125;\nfloat Rec::area()&#123; return m_len * m_width; &#125;\n&#x2F;&#x2F;长方体\nclass Cuboid: public Rec&#123;\npublic:\n    Cuboid(float len, float width, float height);\n    float area();\n    float volume();\nprotected:\n    float m_height;\n&#125;;\nCuboid::Cuboid(float len, float width, float height): Rec(len, width), m_height(height)&#123; &#125;\nfloat Cuboid::area()&#123; return 2 * ( m_len*m_width + m_len*m_height + m_width*m_height); &#125;\nfloat Cuboid::volume()&#123; return m_len * m_width * m_height; &#125;\n&#x2F;&#x2F;正方体\nclass Cube: public Cuboid&#123;\npublic:\n    Cube(float len);\n    float area();\n    float volume();\n&#125;;\nCube::Cube(float len): Cuboid(len, len, len)&#123; &#125;\nfloat Cube::area()&#123; return 6 * m_len * m_len; &#125;\nfloat Cube::volume()&#123; return m_len * m_len * m_len; &#125;\nint main()&#123;\n    Line *p &#x3D; new Cuboid(10, 20, 30);\n    cout&lt;&lt;&quot;The area of Cuboid is &quot;&lt;&lt;p-&gt;area()&lt;&lt;endl;\n    cout&lt;&lt;&quot;The volume of Cuboid is &quot;&lt;&lt;p-&gt;volume()&lt;&lt;endl;\n  \n    p &#x3D; new Cube(15);\n    cout&lt;&lt;&quot;The area of Cube is &quot;&lt;&lt;p-&gt;area()&lt;&lt;endl;\n    cout&lt;&lt;&quot;The volume of Cube is &quot;&lt;&lt;p-&gt;volume()&lt;&lt;endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;The area of Cuboid is 2200\n&#x2F;&#x2F;The volume of Cuboid is 6000\n&#x2F;&#x2F;The area of Cube is 1350\n&#x2F;&#x2F;The volume of Cube is 3375</code></pre></li>\n<li><p>typeid运算符：获取类型信息，是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。类型信息对于编程语言非常重要，它描述了数据的各种属性：</p>\n<ul>\n<li>对于基本类型（int、float 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。</li>\n<li>对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\nusing namespace std;\nclass Base&#123; &#125;;\nstruct STU&#123; &#125;;\n&#x2F;&#x2F;typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，\n&#x2F;&#x2F;并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取。\n&#x2F;&#x2F;name() 用来返回类型的名称。\n&#x2F;&#x2F;raw_name() 用来返回名字编码（Name Mangling）算法产生的新名称。\n&#x2F;&#x2F;hash_code() 用来返回当前类型对应的 hash 值。\nint main()&#123;\n    &#x2F;&#x2F;获取一个普通变量的类型信息\n    int n &#x3D; 100;\n    const type_info &amp;nInfo &#x3D; typeid(n);\n    cout&lt;&lt;nInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;nInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;nInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个字面量的类型信息\n    const type_info &amp;dInfo &#x3D; typeid(25.65);\n    cout&lt;&lt;dInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;dInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;dInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个对象的类型信息\n    Base obj;\n    const type_info &amp;objInfo &#x3D; typeid(obj);\n    cout&lt;&lt;objInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;objInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;objInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个类的类型信息\n    const type_info &amp;baseInfo &#x3D; typeid(Base);\n    cout&lt;&lt;baseInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;baseInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;baseInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个结构体的类型信息\n    const type_info &amp;stuInfo &#x3D; typeid(struct STU);\n    cout&lt;&lt;stuInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;stuInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;stuInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个普通类型的类型信息\n    const type_info &amp;charInfo &#x3D; typeid(char);\n    cout&lt;&lt;charInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;charInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;charInfo.hash_code()&lt;&lt;endl;\n    &#x2F;&#x2F;获取一个表达式的类型信息\n    const type_info &amp;expInfo &#x3D; typeid(20 * 45 &#x2F; 4.5);\n    cout&lt;&lt;expInfo.name()&lt;&lt;&quot; | &quot;&lt;&lt;expInfo.raw_name()&lt;&lt;&quot; | &quot;&lt;&lt;expInfo.hash_code()&lt;&lt;endl;\n    return 0;\n&#125;\n&#x2F;**\n运行结果：\nint | .H | 529034928\ndouble | .N | 667332678\nclass Base | .?AVBase@@ | 1035034353\nclass Base | .?AVBase@@ | 1035034353\nstruct STU | .?AUSTU@@ | 734635517\nchar | .D | 4140304029\ndouble | .N | 667332678\n*&#x2F;</code></pre></li>\n<li></li>\n</ol>\n<h3 id=\"5-运算符重载\"><a href=\"#5-运算符重载\" class=\"headerlink\" title=\"5.运算符重载\"></a>5.运算符重载</h3><ol>\n<li><p>运算符重载基础及其注意事项</p>\n<ul>\n<li>并不是所有的运算符都可以重载。能够重载的运算符包括：<br>+ - * / % ^ &amp; | ~ ! = &lt; &gt; += -= *= /= %= ^= &amp;= |=  &lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ – , -&gt;* -&gt; () []  new new[] delete delete[]</li>\n<li>重载不能改变运算符的优先级和结合性。</li>\n<li>重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变。</li>\n<li>运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。</li>\n<li>运算符重载函数既可以作为类的成员函数，也可以作为全局函数。</li>\n<li>箭头运算符<code>-&gt;</code>、下标运算符<code>[ ]</code>、函数调用运算符<code>( )</code>、赋值运算符<code>=</code>只能以成员函数的形式重载。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n&#x2F;&#x2F;复数类\nclass Complex&#123;\npublic:  &#x2F;&#x2F;构造函数\n    Complex(double real &#x3D; 0.0, double imag &#x3D; 0.0): m_real(real), m_imag(imag)&#123; &#125;\npublic:  &#x2F;&#x2F;运算符重载\n    &#x2F;&#x2F;以全局函数的形式重载\n    friend Complex operator+(const Complex &amp;c1, const Complex &amp;c2);\n    friend Complex operator-(const Complex &amp;c1, const Complex &amp;c2);\n    friend Complex operator*(const Complex &amp;c1, const Complex &amp;c2);\n    friend Complex operator&#x2F;(const Complex &amp;c1, const Complex &amp;c2);\n    friend bool operator&#x3D;&#x3D;(const Complex &amp;c1, const Complex &amp;c2);\n    friend bool operator!&#x3D;(const Complex &amp;c1, const Complex &amp;c2);\n    friend istream &amp; operator&gt;&gt;(istream &amp; in, complex &amp; A);\n    friend ostream &amp; operator&lt;&lt;(ostream &amp; out, complex &amp; A);\n    &#x2F;&#x2F;以成员函数的形式重载\n    Complex &amp; operator+&#x3D;(const Complex &amp;c);\n    Complex &amp; operator-&#x3D;(const Complex &amp;c);\n    Complex &amp; operator*&#x3D;(const Complex &amp;c);\n    Complex &amp; operator&#x2F;&#x3D;(const Complex &amp;c);\npublic:  &#x2F;&#x2F;成员函数\n    double real() const&#123; return m_real; &#125;\n    double imag() const&#123; return m_imag; &#125;\nprivate:\n    double m_real;  &#x2F;&#x2F;实部\n    double m_imag;  &#x2F;&#x2F;虚部\n&#125;;\n&#x2F;&#x2F;重载+运算符\nComplex operator+(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; c1.m_real + c2.m_real;\n    c.m_imag &#x3D; c1.m_imag + c2.m_imag;\n    return c;\n&#125;\n&#x2F;&#x2F;重载-运算符\nComplex operator-(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; c1.m_real - c2.m_real;\n    c.m_imag &#x3D; c1.m_imag - c2.m_imag;\n    return c;\n&#125;\n&#x2F;&#x2F;重载*运算符  (a+bi) * (c+di) &#x3D; (ac-bd) + (bc+ad)i\nComplex operator*(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; c1.m_real * c2.m_real - c1.m_imag * c2.m_imag;\n    c.m_imag &#x3D; c1.m_imag * c2.m_real + c1.m_real * c2.m_imag;\n    return c;\n&#125;\n&#x2F;&#x2F;重载&#x2F;运算符  (a+bi) &#x2F; (c+di) &#x3D; [(ac+bd) &#x2F; (c²+d²)] + [(bc-ad) &#x2F; (c²+d²)]i\nComplex operator&#x2F;(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    Complex c;\n    c.m_real &#x3D; (c1.m_real*c2.m_real + c1.m_imag*c2.m_imag) &#x2F; (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    c.m_imag &#x3D; (c1.m_imag*c2.m_real - c1.m_real*c2.m_imag) &#x2F; (pow(c2.m_real, 2) + pow(c2.m_imag, 2));\n    return c;\n&#125;\n&#x2F;&#x2F;重载&#x3D;&#x3D;运算符\nbool operator&#x3D;&#x3D;(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    if( c1.m_real &#x3D;&#x3D; c2.m_real &amp;&amp; c1.m_imag &#x3D;&#x3D; c2.m_imag )&#123;\n        return true;\n    &#125;else&#123;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;重载!&#x3D;运算符\nbool operator!&#x3D;(const Complex &amp;c1, const Complex &amp;c2)&#123;\n    if( c1.m_real !&#x3D; c2.m_real || c1.m_imag !&#x3D; c2.m_imag )&#123;\n        return true;\n    &#125;else&#123;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;重载+&#x3D;运算符\nComplex &amp; Complex::operator+&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real +&#x3D; c.m_real;\n    this-&gt;m_imag +&#x3D; c.m_imag;\n    return *this;\n&#125;\n&#x2F;&#x2F;重载-&#x3D;运算符\nComplex &amp; Complex::operator-&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real -&#x3D; c.m_real;\n    this-&gt;m_imag -&#x3D; c.m_imag;\n    return *this;\n&#125;\n&#x2F;&#x2F;重载*&#x3D;运算符\nComplex &amp; Complex::operator*&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real &#x3D; this-&gt;m_real * c.m_real - this-&gt;m_imag * c.m_imag;\n    this-&gt;m_imag &#x3D; this-&gt;m_imag * c.m_real + this-&gt;m_real * c.m_imag;\n    return *this;\n&#125;\n&#x2F;&#x2F;重载&#x2F;&#x3D;运算符\nComplex &amp; Complex::operator&#x2F;&#x3D;(const Complex &amp;c)&#123;\n    this-&gt;m_real &#x3D; (this-&gt;m_real*c.m_real + this-&gt;m_imag*c.m_imag) &#x2F; (pow(c.m_real, 2) + pow(c.m_imag, 2));\n    this-&gt;m_imag &#x3D; (this-&gt;m_imag*c.m_real - this-&gt;m_real*c.m_imag) &#x2F; (pow(c.m_real, 2) + pow(c.m_imag, 2));\n    return *this;\n&#125;\n&#x2F;&#x2F;重载输入运算符\nistream &amp; operator&gt;&gt;(istream &amp; in, complex &amp; A)&#123;\n    in &gt;&gt; A.m_real &gt;&gt; A.m_imag;\n    return in;\n&#125;\n&#x2F;&#x2F;重载输出运算符\nostream &amp; operator&lt;&lt;(ostream &amp; out, complex &amp; A)&#123;\n    out &lt;&lt; A.m_real &lt;&lt;&quot; + &quot;&lt;&lt; A.m_imag &lt;&lt;&quot; i &quot;;;\n    return out;\n&#125;\nint main()&#123;\n    Complex c1(25, 35);\n    Complex c2(10, 20);\n    Complex c3(1, 2);\n    Complex c4(4, 9);\n    Complex c5(34, 6);\n    Complex c6(80, 90);\n   \n    Complex c7 &#x3D; c1 + c2;\n    Complex c8 &#x3D; c1 - c2;\n    Complex c9 &#x3D; c1 * c2;\n    Complex c10 &#x3D; c1 &#x2F; c2;\n    cout&lt;&lt;&quot;c7 &#x3D; &quot;&lt;&lt;c7.real()&lt;&lt;&quot; + &quot;&lt;&lt;c7.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c8 &#x3D; &quot;&lt;&lt;c8.real()&lt;&lt;&quot; + &quot;&lt;&lt;c8.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c9 &#x3D; &quot;&lt;&lt;c9.real()&lt;&lt;&quot; + &quot;&lt;&lt;c9.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c10 &#x3D; &quot;&lt;&lt;c10.real()&lt;&lt;&quot; + &quot;&lt;&lt;c10.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n   \n    c3 +&#x3D; c1;\n    c4 -&#x3D; c2;\n    c5 *&#x3D; c2;\n    c6 &#x2F;&#x3D; c2;\n    cout&lt;&lt;&quot;c3 &#x3D; &quot;&lt;&lt;c3.real()&lt;&lt;&quot; + &quot;&lt;&lt;c3.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c4 &#x3D; &quot;&lt;&lt;c4.real()&lt;&lt;&quot; + &quot;&lt;&lt;c4.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c5 &#x3D; &quot;&lt;&lt;c5.real()&lt;&lt;&quot; + &quot;&lt;&lt;c5.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n    cout&lt;&lt;&quot;c6 &#x3D; &quot;&lt;&lt;c6.real()&lt;&lt;&quot; + &quot;&lt;&lt;c6.imag()&lt;&lt;&quot;i&quot;&lt;&lt;endl;\n   \n    if(c1 &#x3D;&#x3D; c2)&#123;\n        cout&lt;&lt;&quot;c1 &#x3D;&#x3D; c2&quot;&lt;&lt;endl;\n    &#125;\n    if(c1 !&#x3D; c2)&#123;\n        cout&lt;&lt;&quot;c1 !&#x3D; c2&quot;&lt;&lt;endl;\n    &#125;\n   \n    return 0;\n&#125;</code></pre></li>\n<li><p>重载[]</p>\n</li>\n<li><p>重载++和–</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n&#x2F;&#x2F;秒表类\nclass stopwatch&#123;\npublic:\n    stopwatch(): m_min(0), m_sec(0)&#123; &#125;\npublic:\n    void setzero()&#123; m_min &#x3D; 0; m_sec &#x3D; 0; &#125;\n    stopwatch run();  &#x2F;&#x2F; 运行\n    stopwatch operator++();  &#x2F;&#x2F;++i，前置形式\n    stopwatch operator++(int);  &#x2F;&#x2F;i++，后置形式\n    friend ostream &amp; operator&lt;&lt;( ostream &amp;, const stopwatch &amp;);\nprivate:\n    int m_min;  &#x2F;&#x2F;分钟\n    int m_sec;  &#x2F;&#x2F;秒钟\n&#125;;\nstopwatch stopwatch::run()&#123;\n    ++m_sec;\n    if(m_sec &#x3D;&#x3D; 60)&#123;\n        m_min++;\n        m_sec &#x3D; 0;\n    &#125;\n    return *this;\n&#125;\nstopwatch stopwatch::operator++()&#123;\n    return run();\n&#125;\nstopwatch stopwatch::operator++(int n)&#123;\n    stopwatch s &#x3D; *this;\n    run();\n    return s;\n&#125;\nostream &amp;operator&lt;&lt;( ostream &amp; out, const stopwatch &amp; s)&#123;\n    out&lt;&lt;setfill(&#39;0&#39;)&lt;&lt;setw(2)&lt;&lt;s.m_min&lt;&lt;&quot;:&quot;&lt;&lt;setw(2)&lt;&lt;s.m_sec;\n    return out;\n&#125;\nint main()&#123;\n    stopwatch s1, s2;\n    s1 &#x3D; s2++;\n    cout &lt;&lt; &quot;s1: &quot;&lt;&lt; s1 &lt;&lt;endl;\n    cout &lt;&lt; &quot;s2: &quot;&lt;&lt; s2 &lt;&lt;endl;\n    s1.setzero();\n    s2.setzero();\n    s1 &#x3D; ++s2;\n    cout &lt;&lt; &quot;s1: &quot;&lt;&lt; s1 &lt;&lt;endl;\n    cout &lt;&lt; &quot;s2: &quot;&lt;&lt; s2 &lt;&lt;endl;\n    return 0;\n&#125;\n&#x2F;&#x2F;运行结果：\n&#x2F;&#x2F;s1: 00:00\n&#x2F;&#x2F;s2: 00:01\n&#x2F;&#x2F;s1: 00:01\n&#x2F;&#x2F;s2: 00:01</code></pre></li>\n<li><p>重载new和delete</p>\n<ol>\n<li><p>以成员函数的形式重载 new 运算符：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void * className::operator new( size_t size )&#123;\n  &#x2F;&#x2F;TODO:\n&#125;</code></pre></li>\n<li><p>以全局函数的形式重载 new 运算符：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void * operator new( size_t size )&#123;\n  &#x2F;&#x2F;TODO:\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>重载()</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nclass Complex\n&#123;\n    double real, imag;\npublic:\n    Complex(double r &#x3D; 0, double i &#x3D; 0) :real(r), imag(i) &#123;&#125;;\n    operator double() &#123; return real; &#125;  &#x2F;&#x2F;重载强制类型转换运算符 double\n&#125;;\nint main()\n&#123;\n    Complex c(1.2, 3.4);\n    cout &lt;&lt; (double)c &lt;&lt; endl;  &#x2F;&#x2F;输出 1.2\n    double n &#x3D; 2 + c;  &#x2F;&#x2F;等价于 double n &#x3D; 2 + c. operator double()\n    cout &lt;&lt; n;  &#x2F;&#x2F;输出 3.2\n&#125;</code></pre></li>\n<li><p>重载=</p>\n</li>\n</ol>\n<h3 id=\"6-面向对象进阶\"><a href=\"#6-面向对象进阶\" class=\"headerlink\" title=\"6.面向对象进阶\"></a>6.面向对象进阶</h3><ol>\n<li><p>拷贝构造函数</p>\n</li>\n<li><p>深拷贝和浅拷贝</p>\n</li>\n<li><p>转换构造函数</p>\n</li>\n<li><p>类型转换函数</p>\n</li>\n<li><p>四种类型转换运算符</p>\n</li>\n<li><ol>\n<li><ul>\n<li>- </li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"3-标准库\"><a href=\"#3-标准库\" class=\"headerlink\" title=\"3.标准库\"></a>3.标准库</h2><h3 id=\"1-Strings-lib\"><a href=\"#1-Strings-lib\" class=\"headerlink\" title=\"1.Strings lib\"></a>1.Strings lib</h3><ol>\n<li><p>基础知识</p>\n<ul>\n<li><p>string不是一个真正的类型，而是模版类basic_string的特化形式，是一个typedef</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using string &#x3D; std::basic_string&lt;char&gt;;  &#x2F;&#x2F; string其实是一个类型别名</code></pre></li>\n<li><p>Unicode：通过一种编码方式统一处理人类语言文字，使用32位（4字节）来容纳所有汉字。但是C++的字符串中的字符是跟随C的定义，是char类型，都是单字节的无法表示Unicode。为了解决这个问题，C++98 定义了 wchar_t； C++11，为了适配 UTF-16、UTF-32，又多了 char16_t、char32_t。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using wstring &#x3D; std::basic_string&lt;wchar_t&gt;;\nusing u16string &#x3D; std::basic_string&lt;char16_t&gt;;\nusing u32string &#x3D; std::basic_string&lt;char32_t&gt;;</code></pre></li>\n</ul>\n</li>\n<li><p>string</p>\n<ul>\n<li><p>string是一个功能比较齐全的字符串类，可以提取子串、比较大小、检查长度、搜索字符等。还有size（）、begin（）、end（）、push_back（）等类似容器的操作。虽然有容器的方法，但是应该把每个字符串都看作是一个不可变的实体</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\nint main()&#123;\n  &#x2F;&#x2F;string str &#x3D; &quot;abc&quot;;\n\t&#x2F;&#x2F;assert(str.length() &#x3D;&#x3D; 3); \n  &#x2F;&#x2F;assert(str &lt; &quot;xyz&quot;);\n  &#x2F;&#x2F;assert(str.substr(0, 1) &#x3D;&#x3D; &quot;a&quot;);\n  &#x2F;&#x2F;assert(str[1] &#x3D;&#x3D; &#39;b&#39;);\n  &#x2F;&#x2F;assert(str.find(&quot;1&quot;) &#x3D;&#x3D; string::npos);\n  &#x2F;&#x2F;assert(str + &quot;d&quot; &#x3D;&#x3D; &quot;abcd&quot;);\n  &#x2F;&#x2F;初始化方法\n  string s1;\n  string s2 &#x3D; &quot;c plus plus&quot;;\n  string s3 &#x3D; s2;\n  string s4 (5, &#39;s&#39;);\n  return 0;\n  &#x2F;&#x2F;转换为C风格的字符串，打开文件时需要\n  &#x2F;&#x2F;c_str()，该函数能够将 string 字符串转换为C风格的字符串\n  &#x2F;&#x2F;并返回该字符串的 const 指针（const char*）\n  string path &#x3D; &quot;D:\\\\demo.txt&quot;;\n  FILE *fp &#x3D; fopen(path.c_str(), &quot;rt&quot;);\n  &#x2F;&#x2F;访问字符串中的字符\n  string s &#x3D; &quot;1234567890&quot;;\n  for(int i&#x3D;0,len&#x3D;s.length(); i&lt;len; i++)&#123;\n    cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;\n  &#125;\n  &#x2F;&#x2F;字符串的拼接\n  string s1 &#x3D; &quot;first &quot;;\n  string s2 &#x3D; &quot;second &quot;;\n  char ch &#x3D; &#39;@&#39;;\n  string s3 &#x3D; s1 + s2;\n  string s4 &#x3D; s1 + ch;\n\n  &#x2F;&#x2F;C++ 提供的 string 类包含了若干实用的成员函数：\n\n  &#x2F;&#x2F;pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。\n  string&amp; insert (size_t pos, const string&amp; str);\n\n  &#x2F;&#x2F;pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len &#x3D; str.length - pos）。\n  string&amp; erase (size_t pos &#x3D; 0, size_t len &#x3D; npos);\n\n  &#x2F;&#x2F;pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。\n  string substr (size_t pos &#x3D; 0, size_t len &#x3D; npos) const;\n\n  &#x2F;&#x2F;第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。\n  size_t find (const string&amp; str, size_t pos &#x3D; 0) const;\n  size_t find (const char* s, size_t pos &#x3D; 0) const;\n  &#x2F;&#x2F;rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 rfind() 函数则最多查找到第二个参数处，如果到了第二个参数所指定的下标还没有找到子字符串，则返回一个无穷大值4294967295。\n  &#x2F;&#x2F;find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。\n&#125;</code></pre></li>\n<li><p>使用技巧</p>\n<ul>\n<li><p>字面量后缀：C++14 为方便使用字符串，新增了一个字面量的后缀“s”，明确地表示它是 string 字符串类型，而不是 C 字符串，这就可以利用 auto 来自动类型推导，而且在其他用到字符串的地方，也可以省去声明临时字符串变量的麻烦，效率也会更高</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using namespace std::literals::string_literals;  &#x2F;&#x2F;必须打开名字空间\n\nauto str &#x3D; &quot;std string&quot;s;      &#x2F;&#x2F; 后缀s，表示是标准字符串，直接类型推导\n\nassert(&quot;time&quot;s.size() &#x3D;&#x3D; 4);   &#x2F;&#x2F; 标准字符串可以直接调用成员函数</code></pre></li>\n<li><p>原始字符串：C++11 为字面量增加了一个“原始字符串”（Raw string literal）的新表示形式，比原来的引号多了一个大写字母 R 和一对圆括号，就像下面这样。主要用于不想转义的情况</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto str &#x3D; R&quot;(nier:automata)&quot;;    &#x2F;&#x2F; 原始字符串：nier:automata\n\nauto str1 &#x3D; R&quot;(char&quot;&quot;&#39;&#39;)&quot;;    &#x2F;&#x2F; 原样输出：char&quot;&quot;&#39;&#39;\nauto str2 &#x3D; R&quot;(\\r\\n\\t\\&quot;)&quot;;    &#x2F;&#x2F; 原样输出：\\r\\n\\t\\&quot;\nauto str3 &#x3D; R&quot;(\\\\\\$)&quot;;        &#x2F;&#x2F; 原样输出：\\\\\\$\nauto str4 &#x3D; &quot;\\\\\\\\\\\\$&quot;;         &#x2F;&#x2F; 转义后输出：\\\\\\$\n\n&#x2F;&#x2F;在圆括号的两边加上最多16个字符的特别界定符（delimiter），保证不与字符串内容发生冲突\nauto str5 &#x3D; R&quot;&#x3D;&#x3D;(R&quot;(xxx)&quot;)&#x3D;&#x3D;&quot;;&#x2F;&#x2F; 原样输出：R&quot;(xxx)&quot;</code></pre></li>\n<li><p>字符串转换函数：在处理字符串的时候，我们还会经常遇到与数字互相转换的事情，以前只能用 C 函数 atoi()、atol()，它们的参数是 C 字符串而不是 string，用起来就比较麻烦，于是，C++11 就增加了几个新的转换函数：</p>\n<ul>\n<li><p>stoi()、stol()、stoll() 等把字符串转换成整数</p>\n</li>\n<li><p>stof()、stod() 等把字符串转换成浮点数</p>\n</li>\n<li><p>to_string() 把整数、浮点数转换成字符串。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">assert(stoi(&quot;42&quot;) &#x3D;&#x3D; 42);          &#x2F;&#x2F; 字符串转整数\nassert(stol(&quot;253&quot;) &#x3D;&#x3D; 253L);       &#x2F;&#x2F; 字符串转长整数\nassert(stod(&quot;2.0&quot;) &#x3D;&#x3D; 2.0);       &#x2F;&#x2F; 字符串转浮点数\n\nassert(to_string(1984) &#x3D;&#x3D; &quot;1984&quot;);       &#x2F;&#x2F; 整数转字符串</code></pre></li>\n</ul>\n</li>\n<li><p>字符串视图类：因为C++拷贝复制的成本太高，所以在 C++17 里有一个string_view，它是一个字符串的视图，成本很低，内部只保存一个指针和长度，无论是拷贝，还是修改，都非常廉价。在C++11中实现简化版本</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class my_string_view final        &#x2F;&#x2F; 简单的字符串视图类，示范实现\n&#123;\npublic:\n    using this_type &#x3D; my_string_view;     &#x2F;&#x2F; 各种内部类型定义\n    using string_type &#x3D; std::string;\n    using string_ref_type &#x3D; const std::string&amp;;\n\n    using char_ptr_type &#x3D; const char*;\n    using size_type &#x3D; size_t;\nprivate:\n    char_ptr_type ptr &#x3D; nullptr;     &#x2F;&#x2F; 字符串指针\n    size_type len &#x3D; 0;               &#x2F;&#x2F; 字符串长度\npublic:\n    my_string_view() &#x3D; default;\n   ~my_string_view() &#x3D; default;\n\n    my_string_view(string_ref_type str) noexcept\n        : ptr(str.data()), len(str.length())\n    &#123;&#125;\npublic:\n    char_ptr_type data() const     &#x2F;&#x2F; 常函数，返回字符串指针\n    &#123;\n        return ptr;\n    &#125;\n\n    size_type size() const        &#x2F;&#x2F; 常函数，返回字符串长度\n    &#123;\n        return len;\n    &#125;\n&#125;;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>正则表达式</p>\n<ul>\n<li><p>string只解决了文本的表示和存储问题，对它进行大小写转换、判断前缀后缀、模式匹配查找等更复杂的操作，标准算法因为工作对象是容器，所以不起作用，由于大部分算法都无法直接套用在字符串上，所以C++11引入了正则表达式库regex，可以利用它强大能力，来操作文本、字符串</p>\n</li>\n<li><p>类与算法</p>\n<ul>\n<li>C++ 正则表达式主要有两个类<ul>\n<li>regex：表示一个正则表达式，是 basic_regex 的特化形式</li>\n<li>smatch：表示正则表达式的匹配结果，是 match_results 的特化形式</li>\n</ul>\n</li>\n<li>C++ 正则匹配有三个算法，注意它们都是“只读”的，不会变动原字符串<ul>\n<li>regex_match()：完全匹配一个字符串</li>\n<li>regex_search()：在字符串里查找一个正则匹配</li>\n<li>regex_replace()：正则查找再做替换。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用：用regex定义好一个表达式，然后再调用匹配算法，就可以立刻得到结果，而且最好要用原始字符串</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto make_regex &#x3D; [](const auto&amp; txt)    &#x2F;&#x2F; 生产正则表达式\n&#123;\n    return std::regex(txt);\n&#125;;\n\nauto make_match &#x3D; []()                  &#x2F;&#x2F; 生产正则匹配结果\n&#123;\n    return std::smatch();\n&#125;;\n\nauto str &#x3D; &quot;neir:automata&quot;s;          &#x2F;&#x2F; 待匹配的字符串\nauto reg &#x3D; \n    make_regex(R&quot;(^(\\w+)\\:(\\w+)$)&quot;);  &#x2F;&#x2F; 原始字符串定义正则表达式\nauto what &#x3D; make_match();             &#x2F;&#x2F; 准备获取匹配的结果\n\nassert(regex_match(str, what, reg));  &#x2F;&#x2F; 正则匹配\n\nfor(const auto&amp; x : what) &#123;          &#x2F;&#x2F; for遍历匹配的子表达式\n    cout &lt;&lt; x &lt;&lt; &#39;,&#39;;\n&#125;\n\n\nauto str &#x3D; &quot;god of war&quot;s;             &#x2F;&#x2F; 待匹配的字符串\n\nauto reg  &#x3D; \n  make_regex(R&quot;((\\w+)\\s(\\w+))&quot;);    &#x2F;&#x2F; 原始字符串定义正则表达式\nauto what &#x3D; make_match();          &#x2F;&#x2F; 准备获取匹配的结果\n\nauto found &#x3D; regex_search(          &#x2F;&#x2F; 正则查找，和匹配类似\n                str, what, reg);\n\nassert(found);                        &#x2F;&#x2F; 断言找到匹配\nassert(!what.empty());                &#x2F;&#x2F; 断言有匹配结果\nassert(what[1] &#x3D;&#x3D; &quot;god&quot;);              &#x2F;&#x2F; 看第一个子表达式\nassert(what[2] &#x3D;&#x3D; &quot;of&quot;);              &#x2F;&#x2F; 看第二个子表达式\n\nauto new_str &#x3D; regex_replace(      &#x2F;&#x2F; 正则替换，返回新字符串\n    str,                           &#x2F;&#x2F; 原字符串不改动\n    make_regex(R&quot;(\\w+$)&quot;),         &#x2F;&#x2F; 就地生成正则表达式对象\n    &quot;peace&quot;                        &#x2F;&#x2F; 需要指定替换的文字\n);\n\ncout &lt;&lt; new_str &lt;&lt; endl;          &#x2F;&#x2F; 输出god of peace</code></pre></li>\n</ul>\n</li>\n</ol>\n<p>   ==Regex==</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>功能：校验数据的有效性、查找符合要求的文本、对文本进行切割和替换等操作</p></blockquote>\n<h6 id=\"1-元字符\"><a href=\"#1-元字符\" class=\"headerlink\" title=\"1.元字符\"></a>1.元字符</h6><ol>\n<li>概念：元字符就是指那些在正则表达式中具有特殊意义的专用字符，是构成正则表达式的基本元件，</li>\n<li>元字符的分类与记忆技巧<ol>\n<li>特殊单字符<ul>\n<li><code>.</code>：表示换行以外的任意单个字符</li>\n<li><code>\\d</code>：任意数字；<code>\\D</code>任意非数字</li>\n<li><code>\\w</code>：任意字母数字下划线；<code>\\W</code>任意非字母数字下划线</li>\n<li><code>\\s</code>：任意空白符；<code>\\S</code>任意非空白符</li>\n</ul>\n</li>\n<li>空白符<ul>\n<li><code>\\r</code>：回车符</li>\n<li><code>\\n</code>：换行符（每行文本结束位置默认的换行：Windows 里是 \\r\\n，在 Linux 和 MacOS 中是 \\n）</li>\n<li><code>\\f</code>：换页符</li>\n<li><code>\\t</code>：制表符</li>\n<li><code>\\v</code>：垂直制表符</li>\n<li><code>\\s</code>：任意空白符（常用）</li>\n</ul>\n</li>\n<li>范围<ul>\n<li><code>|</code>：或，如ab|bc代表能匹配上ab，也能匹配上bc，满足其中任意一个就行</li>\n<li><code>[...]</code>：多选一，括号中任意单个元素</li>\n<li><code>[a-z]</code>：匹配a到z之间任意单个元素（按ASCII表，包含a，z）</li>\n<li><code>[^...]</code>：取反，不能是括号中的任意单个元素</li>\n</ul>\n</li>\n<li>量词<ul>\n<li><code>*</code>：0到多次</li>\n<li><code>+</code>：1到多次</li>\n<li><code>?</code>：0到1次，如colou?r，可以是color也可以是colour</li>\n<li><code>&#123;m&#125;</code>：出现m次</li>\n<li><code>&#123;m,&#125;</code>：出现至少m次</li>\n<li><code>&#123;m,n&#125;</code>：出现m到n次</li>\n</ul>\n</li>\n<li>断言</li>\n</ol>\n</li>\n</ol>\n<h6 id=\"2-量词与贪婪\"><a href=\"#2-量词与贪婪\" class=\"headerlink\" title=\"2.量词与贪婪\"></a>2.量词与贪婪</h6><ol>\n<li><p>贪婪匹配：表示次数的量词默认是贪婪的，即尽可能最大长度去匹配</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r&#39;a*&#39;, &#39;aaabb&#39;) # 贪婪模式\n[&#39;aaa&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</code></pre>\n\n<ul>\n<li><p>示例一</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220830231356178-20221123125856516.png\" alt=\"image-20220830231356178\" style=\"zoom: 50%;\" /></li>\n<li><p>示例二</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220830231308427-20221123125856579.png\" alt=\"image-20220830231308427\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>非贪婪匹配：在量词后面加上<code>?</code>，就变成非贪婪模式，尽可能进行最短匹配</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r&#39;a*?&#39;, &#39;aaabb&#39;) # 非贪婪模式\n[&#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;a&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;]</code></pre>\n\n<ul>\n<li><p>示例一</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220830231424527-20221123125856688.png\" alt=\"image-20220830231424527\" style=\"zoom:50%;\" /></li>\n<li><p>示例二</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220830231318857-20221123125856813.png\" alt=\"image-20220830231318857\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>独占模式：</p>\n<ul>\n<li><p>不管是贪婪模式还是非贪婪模式，都需要回溯才能完成相应的功能。但是独占模式不需要发生回溯，类似于贪婪模式，但是匹配失败时直接结束，不回溯。在某些环境下独占模式性能更好</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"># 注意：需要先安装 regex 模块，pip install regex\n#go和python都不支持独占模式，即量词后加上+\n\n&gt;&gt;&gt; import regex\n&gt;&gt;&gt; regex.findall(r&#39;xy&#123;1,3&#125;z&#39;, &#39;xyyz&#39;)  # 贪婪模式\n[&#39;xyyz&#39;]\n&gt;&gt;&gt; regex.findall(r&#39;xy&#123;1,3&#125;+z&#39;, &#39;xyyz&#39;) # 独占模式\n[&#39;xyyz&#39;]\n&gt;&gt;&gt; regex.findall(r&#39;xy&#123;1,2&#125;+yz&#39;, &#39;xyyz&#39;) # 独占模式\n[]</code></pre></li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h6 id=\"3-分组与引用\"><a href=\"#3-分组与引用\" class=\"headerlink\" title=\"3.分组与引用\"></a>3.分组与引用</h6><ol>\n<li><p>问题：大多数正则实现中，多分支选择都是左边的优先，比如</p>\n<ul>\n<li><code>北京|北京市</code>会把所有北京市匹配成北京市</li>\n<li><code>北京市|北京</code>可以查找北京和北京市</li>\n<li><code>北京市?</code>可以匹配北京和北京市，类似匹配15个数组和18个数字可以用<code>\\d&#123;15&#125;(\\d&#123;3&#125;)?</code></li>\n</ul>\n</li>\n<li><p>分组编号</p>\n<ul>\n<li><p>分组与编号：括号在正则中可以用于分组，被括号括起来的部分“子表达式”会被保存成一个子组，第几个括号就是第几个分组</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831140743124-20221123125856905.png\" alt=\"image-20220831140743124\" style=\"zoom:50%;\" /></li>\n<li><p>不保存子组：在括号里面的会保存成子组，如果后续不想复用、不想保存，通过在括号里面使用<code>?:</code>，不保存子组，可以提高正则性能</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831141207511-20221123125857100.png\" alt=\"image-20220831141207511\" style=\"zoom:50%;\" /></li>\n<li><p>括号嵌套：在括号嵌套的情况下，求某个括号内容是第几个分组可以通过数左括号的方式，左括号是第几个，就可以确定是第几个分组</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831141435440-20221123125857211.png\" alt=\"image-20220831141435440\" style=\"zoom:50%;\" /></li>\n<li><p>命名分组：比默认的数字编号更加容易辨识，命名分组的格式为<code>(?P&lt;分组名&gt;正则)</code>，示例如下（注意不是所有语言都支持）</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">url(r&#39;^profile&#x2F;(?P&lt;username&gt;\\w+)&#x2F;$&#39;, view_func)</code></pre></li>\n</ul>\n</li>\n<li><p>分组引用：通过<code>\\number</code>的方式来对分组进行引用</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831142051676-20221123125857386.png\" alt=\"image-20220831142051676\"></p>\n<ul>\n<li><p>查找：查找重复出现的部分</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831143013475-20221123125857556.png\" alt=\"image-20220831143013475\" style=\"zoom:50%;\" /></li>\n<li><p>替换：对原有内容格式进行改写</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831143029008-20221123125857798.png\" alt=\"image-20220831143029008\" style=\"zoom:50%;\" /></li>\n<li><p>Python3实现</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&gt;&gt;&gt; import re\n&gt;&gt;&gt; test_str &#x3D; &quot;2020-05-10 20:23:05&quot;\n&gt;&gt;&gt; regex &#x3D; r&quot;((\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)) ((\\d&#123;2&#125;):(\\d&#123;2&#125;):(\\d&#123;2&#125;))&quot;\n&gt;&gt;&gt; subst &#x3D; r&quot;日期\\1 时间\\5   \\2年\\3月\\4日 \\6时\\7分\\8秒&quot;\n&gt;&gt;&gt; re.sub(regex, subst, test_str) #sub函数用于正则的替换\n&#39;日期2020-05-10 时间20:23:05   2020年05月10日 20时23分05秒&#39;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h6 id=\"4-匹配模式\"><a href=\"#4-匹配模式\" class=\"headerlink\" title=\"4.匹配模式\"></a>4.匹配模式</h6><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>正则中一些改变元字符匹配行为的方式，比如匹配时不区分英文字母大小写，通过把模式修饰符<code>(?模式标识)</code>放在整个正则前面时，就表示整个正则表达式都是不区分大小写的</p></blockquote>\n<ul>\n<li><p>不区分大小写模式（Case-Insensitive）</p>\n<ul>\n<li><p>正常方法：查找cat，不关心大小写：<code>[Cc][Aa][Tt]</code></p>\n</li>\n<li><p>新方法：</p>\n<ul>\n<li><code>(?i)cat</code>：查找一个cat，不关心大小写</li>\n<li><code>(?i)(cat) \\1</code>：可以匹配两个连续出现的cat，两次cat可以不同</li>\n<li><code>((?i)cat) \\1</code>：可以匹配两个连续出现的cat，两次cat必须相同</li>\n<li><code>((?i)cat) cat</code>：匹配第一个cat是不区分大小写的，第二个cat区分大小写且必须是小写</li>\n</ul>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.findall(r&quot;cat&quot;, &quot;CAT Cat cat&quot;, re.IGNORECASE)\n[&#39;CAT&#39;, &#39;Cat&#39;, &#39;cat&#39;]</code></pre></li>\n</ul>\n</li>\n<li><p>点号通配模式（Dot All）</p>\n<ul>\n<li>正常<code>.</code>只能匹配出换行符外的任意字符，相匹配上包括换行的任意字符，需要通过<code>(?s)</code>来使用</li>\n<li>示例：<code>(?s).+</code>可以匹配上整个文本的所有字符</li>\n</ul>\n</li>\n<li><p>多行模式（Multiline）</p>\n<ul>\n<li><p>通常情况下，<code>^</code>匹配整个字符串的开头，<code>$</code>匹配整个字符串的结尾，多行匹配就是改变这两个符号的匹配行为</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831151233525-20221123125857925.png\" alt=\"image-20220831151233525\" style=\"zoom:50%;\" /></li>\n<li><p><strong>通过使用<code>(?m)</code>来使得<code>^</code>和<code>$</code>能匹配上每行的开头和结尾</strong></p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831151414331-20221123125858139.png\" alt=\"image-20220831151414331\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>注释模式（comment）</p>\n<ul>\n<li><p>在实际工作中，正则会很复杂，可以在一些关键地方加上注释，使得代码易于理解。通过<code>(?#comment)</code>来使用注释模式</p>\n<ul>\n<li><p>示例一</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831151659094-20221123125858274.png\" alt=\"image-20220831151659094\" style=\"zoom:50%;\" /></li>\n<li><p>示例二</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#在 x 模式下，所有的换行和空格都会被忽略，可以通过把空格放入字符组中，或将空格转义来解决\nregex &#x3D; r&#39;&#39;&#39;(?mx)\n^          # 开头\n(\\d&#123;4&#125;)    # 年\n[ ]        # 空格\n(\\d&#123;2&#125;)    # 月\n$          # 结尾\n&#39;&#39;&#39;\n\nre.findall(regex, &#39;2020 06\\n2020 07&#39;)\n# 输出结果 [(&#39;2020&#39;, &#39;06&#39;), (&#39;2020&#39;, &#39;07&#39;)]</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h6 id=\"5-断言\"><a href=\"#5-断言\" class=\"headerlink\" title=\"5.断言\"></a>5.断言</h6><ol>\n<li><p>概念：对匹配到的文本位置有要求，比如查找tom，但其他单词如tomorrow也包含了tom</p>\n</li>\n<li><p>断言：只用于匹配位置，而不是文本内容本身</p>\n<ul>\n<li><p>单词边界（Word Boundary）</p>\n<ul>\n<li><p>示例：将tom替换为jerry，文本：tom asked me if I would go fishing with him tomorrow.</p>\n<ul>\n<li><p>直接替换会把tomorrow也替换为jerryorrow</p>\n</li>\n<li><p>使用<code>\\b</code>来表示单词的边界</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831160544694-20221123125858394.png\" alt=\"image-20220831160544694\" style=\"zoom:50%;\" /></li>\n<li><p>python代码</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&gt;&gt;&gt; import re\n&gt;&gt;&gt; test_str &#x3D; &quot;tom asked me if I would go fishing with him tomorrow.&quot;\n&gt;&gt;&gt; re.sub(r&#39;\\btom\\b&#39;, &#39;jerry&#39;, test_str)\n&#39;jerry asked me if I would go fishing with him tomorrow.&#39;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>行的开始/结束</p>\n<ul>\n<li><p>和单词的边界类似，在正则中还有文本每行的开始和结束，如果我们要求匹配的内容要出现在一行文本开头或结尾，就可以使用<code>^</code>和<code>$</code>来进行位置界定</p>\n</li>\n<li><p>应用</p>\n<ul>\n<li><p>日志起始行判断：在收集日志的时候，通常可以指定日志行的开始规则，比如以时间开头，那些不是以时间开头的可能就是打印的堆栈信息</p>\n</li>\n<li><p>输入数据校验</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">&gt;&gt;&gt; import re\n&gt;&gt;&gt; re.search(&#39;\\d&#123;6&#125;&#39;, &quot;1234567&quot;) is not None\nTrue    &lt;-- 能匹配上 (包含6位数字)\n&gt;&gt;&gt; re.search(&#39;^\\d&#123;6&#125;&#39;, &quot;1234567&quot;) is not None\nTrue    &lt;-- 能匹配上 (以6位数字开头)\n&gt;&gt;&gt; re.search(&#39;\\d&#123;6&#125;$&#39;, &quot;1234567&quot;) is not None\nTrue    &lt;-- 能匹配上 (以6位数字结尾)\n&gt;&gt;&gt; re.search(&#39;^\\d&#123;6&#125;$&#39;, &quot;1234567&quot;) is not None\nFalse   &lt;-- 不能匹配上 (只能是6位数字)\n&gt;&gt;&gt; re.search(&#39;^\\d&#123;6&#125;$&#39;, &quot;123456&quot;) is not None\nTrue    &lt;-- 能匹配上 (只能是6位数字)</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>环视（Look Around）</p>\n<ul>\n<li><p>环视就是要求匹配部分的前面或后面要满足（或不满足）某种规则，规则助记：左尖括号代表看左边，没有尖括号是看右边，感叹号是非的意思</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831162808738-20221123125858542.png\" alt=\"image-20220831162808738\"></p>\n</li>\n<li><p>示例</p>\n<ul>\n<li>匹配邮编，<code>(?&lt;!\\d)\\d&#123;6&#125;(?!\\d)</code>可以匹配左右都不是数字的6位数</li>\n<li>单词边界用环视表示：<code>\\b\\w+\\b</code>也可以写成<code> (?&lt;!\\w)\\w+(?!\\w)</code></li>\n</ul>\n</li>\n<li><p>注意事项：环视中虽然也有括号，但不会保存成子组。保存成子组的一般是匹配到的文本内容，后续用于替换等操作，而环视是表示对文本左右环境的要求，即环视只匹配位置，不匹配文本内容。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h6 id=\"6-应用\"><a href=\"#6-应用\" class=\"headerlink\" title=\"6.应用\"></a>6.应用</h6><ol>\n<li><p>正则中的Unicode</p>\n<ul>\n<li><p>在编程语言中使用正则的时候，一定要使用Unicode编码</p>\n</li>\n<li><p>要查看语言对字符组的支持程度，比如\\d 表示数字，\\w 表示大小写字母、下划线、数字，\\s 表示空白符号等</p>\n</li>\n<li><p>Unicode属性：如<code>\\p&#123;Han&#125;+</code>可以查找连续出现的中文</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831194359055-20221123125858674.png\" alt=\"image-20220831194359055\"></p>\n</li>\n</ul>\n</li>\n<li><p>编辑器</p>\n<ul>\n<li>光标移动和文本选择：shift+option+左右箭头</li>\n<li>多焦点编辑：选中一个文本，然后通过菜单栏的find all找到所有相同的文本，同时进行相同的操作</li>\n<li>竖向编辑：shift+option</li>\n<li>使用正则：内容提取、内容替换、内容验证、内容切割</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831202526451-20221123125859200.png\" alt=\"image-20220831202526451\" style=\"zoom:50%;\" /></li>\n<li><p>在编程语言中</p>\n<ul>\n<li><p>校验文本内容</p>\n<ul>\n<li><p>python中，正则的包名是re，验证文本可以使用re.match或re.search的方法，这两个方法的区别在于，re.match 是从开头匹配的，re.search 是从文本中找子串</p>\n</li>\n<li><p>go中，正则相关的包是 regexp，示例如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n   &quot;fmt&quot;\n   &quot;regexp&quot;\n)\n\nfunc main() &#123;\n   re :&#x3D; regexp.MustCompile(&#96;\\A\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;\\z&#96;)\n   &#x2F;&#x2F; 输出 true\n   fmt.Println(re.MatchString(&quot;2020-06-01&quot;))\n&#125;</code></pre></li>\n<li><p>JavaScript中，可以直接在浏览器使用Console来使用</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 方法1\n&#x2F;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&#x2F;.test(&quot;2020-06-01&quot;)  &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 方法2\nvar regex &#x3D; &#x2F;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&#x2F;\n&quot;2020-06-01&quot;.search(regex) &#x3D;&#x3D; 0  &#x2F;&#x2F; true\n\n&#x2F;&#x2F; 方法3\nvar regex &#x3D; new RegExp(&#x2F;^\\d&#123;4&#125;-\\d&#123;2&#125;-\\d&#123;2&#125;$&#x2F;)\nregex.test(&quot;2020-01-01&quot;) &#x2F;&#x2F; tru</code></pre></li>\n<li><p>Java中，正则相关的类在 java.util.regex 中，其中最常用的是 Pattern 和 Matcher， Pattern 是正则表达式对象，Matcher 是匹配到的结果对象，Pattern 和 字符串对象关联，可以得到一个 Matcher</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">fimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass Main &#123;\n  public static void main(String[] args) &#123;\n    &#x2F;&#x2F;方法1，可以不加 \\A 和 \\z\n    System.out.println(Pattern.matches(&quot;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;&quot;, &quot;2020-06-01&quot;)); &#x2F;&#x2F; true\n\n    &#x2F;&#x2F;方法2，可以不加 \\A 和 \\z\n    System.out.println(&quot;2020-06-01&quot;.matches(&quot;\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;&quot;)); &#x2F;&#x2F; true\n    \n    &#x2F;&#x2F;方法3，必须加上 \\A 和 \\z\n    Pattern pattern &#x3D; Pattern.compile(&quot;\\\\A\\\\d&#123;4&#125;-\\\\d&#123;2&#125;-\\\\d&#123;2&#125;\\\\z&quot;);\n    System.out.println(pattern.matcher(&quot;2020-06-01&quot;).find()); &#x2F;&#x2F; true\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>提取文本内容</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831204838476-20221123125859375.png\" alt=\"image-20220831204838476\"></p>\n</li>\n<li><p>替换文本内容</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831204856247-20221123125859593.png\" alt=\"image-20220831204856247\"></p>\n</li>\n<li><p>切割文本内容</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220831204910485-20221123125859699.png\" alt=\"image-20220831204910485\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h6 id=\"7-优化建议\"><a href=\"#7-优化建议\" class=\"headerlink\" title=\"7.优化建议\"></a>7.优化建议</h6><ol>\n<li>测试性能的方法：可以使用 ipython 来测试正则的性能</li>\n<li>提前编译好正则：编程语言中一般都有“编译”方法，可以使用这个方法提前将正则处理好，这样不用在每次使用的时候去反复构造自动机，从而可以提高正则匹配的性能。</li>\n<li>尽量准确表示匹配范围：比如我们要匹配引号里面的内容，除了写成 <code>“.+?”</code>之外，我们可以写成 <code>“[^&quot;]+”</code>。使用<code>[^&quot;]</code>要比使用点号好很多，虽然使用的是贪婪模式，但它不会出现点号将引号匹配上，再吐出的问题</li>\n<li>提取出公共部分：(abcd|abxy)这样的表达式，可以优化成ab(cd|xy)，因为 NFA 以正则为主导，会导致字符串中的某些部分重复匹配多次，影响效率</li>\n<li>出现可能性大的放左边：由于正则是从左到右看的，把出现概率大的放左边，域名中 .com 的使用是比 .net 多的，所以我们可以写成<code>\\.(?:com|net)\\b</code>，而不是<code>\\.(?:net|com)\\b</code></li>\n<li>只在必要时才使用子组：在正则中，括号可以用于归组，但如果某部分后续不会再用到，就不需要保存成子组。通常的做法是，在写好正则后，把不需要保存子组的括号中加上 ?: 来表示只用于归组。如果保存成子组，正则引擎必须做一些额外工作来保存匹配到的内容，因为后面可能会用到，这会降低正则的匹配性能</li>\n<li>警惕嵌套的子组重复：如果一个组里面包含重复，接着这个组整体也可以重复，比如<code>(.*)*</code>这个正则，匹配的次数会呈指数级增长，所以尽量不要写这样的正则</li>\n<li>避免不同分支重复匹配：在多选分支选择中，要避免不同分支出现相同范围的情况，例如正则是使用 <code>.*ab</code> 去匹配一个比较长的字符串就更糟糕了，因为<code>.*</code>会吃掉整个字符串（不考虑换行，假设文本中没有换行），然后，你会发现正则中还有 ab 没匹配到内容，只能将<code>.*</code>匹配上的字符串吐出一个字符，再尝试，还不行，再吐出一个，不断尝试。</li>\n</ol>\n<h3 id=\"2-Containers-lib\"><a href=\"#2-Containers-lib\" class=\"headerlink\" title=\"2.Containers lib\"></a>2.Containers lib</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220827145109902-20220921163542560-20221123125900073.png\" alt=\"image-20220827145109902\"></p>\n<ol>\n<li><p>容器的通用特性</p>\n<ul>\n<li><p>容器采用的是值语义，容器里存储的是元素的拷贝、副本，而不是引用。所以操作容器的一大块成本就是值的拷贝，一个解决办法是实现转移构造和转移赋值函数，再加入容器的时候使用std::move()来转移，减少元素复制成本</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">Point p;                        &#x2F;&#x2F; 一个拷贝成本很高的对象\n\nv.push_back(p);                &#x2F;&#x2F; 存储对象，拷贝构造，成本很高\nv.push_back(std::move(p));    &#x2F;&#x2F; 定义转移构造后就可以转移存储，降低成本</code></pre></li>\n<li><p>也可以使用 C++11 为容器新增加的 emplace 操作函数，它可以“就地”构造元素，免去了构造后再拷贝、转移的成本，不但高效，而且用起来也很方便</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">v.emplace_back(...);            &#x2F;&#x2F; 直接在容器里构造元素，不需要拷贝或者转移</code></pre></li>\n</ul>\n</li>\n<li><p>容器的具体特性</p>\n<ul>\n<li><p>顺序容器（5种）</p>\n<ul>\n<li><p>连续存储的数组：array（静态数组）、vector（动态数组）、deque（双端队列，动态增长）</p>\n</li>\n<li><p>指针结构的链表：list（双向链表，向前/后遍历）、forward_list（单向链表，只能向前遍历）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220827143738312-20220921163542716-20221123125900478.png\" alt=\"image-20220827143738312\"></p>\n</li>\n</ul>\n</li>\n<li><p>有序容器（4种）</p>\n<ul>\n<li><p>主要有set、multiset、map、multimap，multi前缀代表可以容纳重复的key</p>\n</li>\n<li><p>有序</p>\n<ul>\n<li><p>插入容器的元素按某种规则自动排序</p>\n</li>\n<li><p>通过制定key的比较函数，来判断顺序，这个函数默认是less，表示小于关系</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template&lt;\n    class T                          &#x2F;&#x2F; 模板参数只有一个元素类型\n&gt; class vector;                      &#x2F;&#x2F; vector\n\ntemplate&lt;\n    class Key,                      &#x2F;&#x2F; 模板参数是key类型，即元素类型\n    class Compare &#x3D; std::less&lt;Key&gt;  &#x2F;&#x2F; 比较函数\n&gt; class set;                        &#x2F;&#x2F; 集合\n\ntemplate&lt;\n    class Key,                      &#x2F;&#x2F; 第一个模板参数是key类型\n    class T,                        &#x2F;&#x2F; 第二个模板参数是元素类型\n    class Compare &#x3D; std::less&lt;Key&gt;  &#x2F;&#x2F; 比较函数\n&gt; class map;                        &#x2F;&#x2F; 关联数组</code></pre></li>\n<li><p>类型没有默认的比较函数，就需要重载&lt;，或者自定义模版参数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">bool operator&lt;(const Point&amp; a, const Point&amp; b)\n&#123;\n    return a.x &lt; b.x;            &#x2F;&#x2F; 自定义比较运算\n&#125;\n\nset&lt;Point&gt; s;                    &#x2F;&#x2F; 现在就可以正确地放入有序容器\ns.emplace(7);\ns.emplace(3);\n\n\nset&lt;int&gt; s &#x3D; &#123;7, 3, 9&#125;;           &#x2F;&#x2F; 定义集合并初始化3个元素\n\nfor(auto&amp; x : s) &#123;                &#x2F;&#x2F; 范围循环输出元素\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;              &#x2F;&#x2F; 从小到大排序，3,7,9\n&#125;   \n\nauto comp &#x3D; [](auto a, auto b)  &#x2F;&#x2F; 定义一个lambda，用来比较大小\n&#123;   \n    return a &gt; b;                &#x2F;&#x2F; 定义大于关系\n&#125;;  \n\nset&lt;int, decltype(comp)&gt; gs(comp)  &#x2F;&#x2F; 使用decltype得到lambda的类型\n\nstd::copy(begin(s), end(s),          &#x2F;&#x2F; 拷贝算法，拷贝数据\n          inserter(gs, gs.end()));  &#x2F;&#x2F; 使用插入迭代器\n\nfor(auto&amp; x : gs) &#123;                &#x2F;&#x2F; 范围循环输出元素\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;                &#x2F;&#x2F; 从大到小排序，9,7,3\n&#125;  </code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>无序容器（4种）</p>\n<ul>\n<li>主要有unordered_set、unordered_multiset、unordered_map、unordered_multima，与有序容器区别在于内部数据结构不是红黑树而是哈希表</li>\n<li>无序容器虽不要求顺序，但是对key要求严苛。要求 key 具备两个条件，一是可以计算 hash 值，二是能够执行相等比较操作。</li>\n<li>如果只想要单纯的集合、字典，没有排序需求，就应该用无序容器，没有比较排序的成本，它的速度就会非常快</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-Algorithm-lib\"><a href=\"#3-Algorithm-lib\" class=\"headerlink\" title=\"3.Algorithm lib\"></a>3.Algorithm lib</h3><ol>\n<li><p>C++里的算法是工作在容器上的一些泛型函数，会对容器内的元素实施各种操作，比如remove（移除某个特定值）；sort（快速排序）；binary_search（执行二分查找）；make_heap（构造一个堆结构）。但是算法本质上都是for或者while循环，通过循环循环遍历来逐个处理容器里的元素。算法+lambda表达式，就可以初步体验函数式编程的感觉</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto n &#x3D; std::count_if(      &#x2F;&#x2F; count_if算法计算元素的数量\n    begin(v), end(v),       &#x2F;&#x2F; begin()、end()获取容器的范围\n    [](auto x) &#123;            &#x2F;&#x2F; 定义一个lambda表达式\n        return x &gt; 2;       &#x2F;&#x2F; 判断条件\n    &#125;\n);                          &#x2F;&#x2F; 大函数里面套了三个小函数</code></pre></li>\n<li><p>迭代器：</p>\n<ul>\n<li><p>算法只能通过迭代器取间接访问容器以及元素，算法的能力是有迭代器决定的。通过这种间接的方式，可以分离数据和操作，算法可以不关心容器的内部结构，以一致的方式去操作元素。</p>\n</li>\n<li><p>C++里的迭代器有多种：输入迭代器、输出迭代器、双向迭代器、随机访问迭代器等。容器一般都会提供提供begin、end成员函数，调用它们就可以得到表示两个端点的迭代器</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; v &#x3D; &#123;1,2,3,4,5&#125;;    &#x2F;&#x2F; vector容器\n\nauto iter1 &#x3D; v.begin();        &#x2F;&#x2F; 成员函数获取迭代器，自动类型推导\nauto iter2 &#x3D; v.end();\n\n&#x2F;&#x2F;建议使用全局函数\nauto iter3 &#x3D; std::begin(v);   &#x2F;&#x2F; 全局函数获取迭代器，自动类型推导\nauto iter4 &#x3D; std::end(v);</code></pre></li>\n<li><p>迭代器常用操作</p>\n<ul>\n<li>distance()，计算两个迭代器之间的距离</li>\n<li>advance()，前进或者后退 N 步</li>\n<li>next()/prev()，计算迭代器前后的某个位置。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>常用算法：</p>\n<ul>\n<li><p>手写循环的替代品：for_each，主要是遍历容器元素和操纵容器元素</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; v &#x3D; &#123;3,5,1,7,10&#125;;   &#x2F;&#x2F; vector容器\n\nfor(const auto&amp; x : v) &#123;        &#x2F;&#x2F; range for循环\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n&#125;\n\nauto print &#x3D; [](const auto&amp; x)  &#x2F;&#x2F; 定义一个lambda表达式\n&#123;\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n&#125;;\nfor_each(cbegin(v), cend(v), print);&#x2F;&#x2F; for_each算法\n\nfor_each(                      &#x2F;&#x2F; for_each算法，内部定义lambda表达式\n    cbegin(v), cend(v),        &#x2F;&#x2F; 获取常量迭代器\n    [](const auto&amp; x)          &#x2F;&#x2F; 匿名lambda表达式\n    &#123;\n        cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n    &#125;\n);</code></pre></li>\n<li><p>排序算法</p>\n<ul>\n<li><p>快排（sort）</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto print &#x3D; [](const auto&amp; x)  &#x2F;&#x2F; lambda表达式输出元素\n&#123;\n    cout &lt;&lt; x &lt;&lt; &quot;,&quot;;\n&#125;;\n\nstd::sort(begin(v), end(v));         &#x2F;&#x2F; 快速排序\nfor_each(cbegin(v), cend(v), print); &#x2F;&#x2F; for_each算法</code></pre></li>\n<li><p>要求排序后仍然保持元素的相对顺序，应该用 stable_sort，它是稳定的</p>\n</li>\n<li><p>选出前几名（TopN），应该用 partial_sort</p>\n</li>\n<li><p>选出前几名，但不要求再排出名次（BestN），应该用 nth_element</p>\n</li>\n<li><p>中位数（Median）、百分位数（Percentile），还是用 nth_element</p>\n</li>\n<li><p>按照某种规则把元素划分成两组，用 partition</p>\n</li>\n<li><p>第一名和最后一名，用 minmax_element</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; top3\nstd::partial_sort(\n    begin(v), next(begin(v), 3), end(v));  &#x2F;&#x2F; 取前3名\n\n&#x2F;&#x2F; best3\nstd::nth_element(\n    begin(v), next(begin(v), 3), end(v));  &#x2F;&#x2F; 最好的3个\n\n&#x2F;&#x2F; Median\nauto mid_iter &#x3D;                            &#x2F;&#x2F; 中位数的位置\n    next(begin(v), v.size()&#x2F;2);\nstd::nth_element( begin(v), mid_iter, end(v));&#x2F;&#x2F; 排序得到中位数\ncout &lt;&lt; &quot;median is &quot; &lt;&lt; *mid_iter &lt;&lt; endl;\n    \n&#x2F;&#x2F; partition\nauto pos &#x3D; std::partition(                &#x2F;&#x2F; 找出所有大于9的数\n    begin(v), end(v),\n    [](const auto&amp; x)                    &#x2F;&#x2F; 定义一个lambda表达式\n    &#123;\n        return x &gt; 9;\n    &#125;\n); \nfor_each(begin(v), pos, print);         &#x2F;&#x2F; 输出分组后的数据  \n\n&#x2F;&#x2F; min&#x2F;max\nauto value &#x3D; std::minmax_element(        &#x2F;&#x2F;找出第一名和倒数第一\n    cbegin(v), cend(v)\n);</code></pre></li>\n</ul>\n</li>\n<li><p>查找算法</p>\n<ul>\n<li><p>binary_search，二分查找，缺点是只返回一个bool值</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; v &#x3D; &#123;3,5,1,7,10,99,42&#125;;  &#x2F;&#x2F; vector容器\nstd::sort(begin(v), end(v));        &#x2F;&#x2F; 快速排序\n\nauto found &#x3D; binary_search(         &#x2F;&#x2F; 二分查找，只能确定元素在不在\n    cbegin(v), cend(v), 7\n); </code></pre></li>\n<li><p>在已序容器上执行二分查找，要用到一个名字比较怪的算法：lower_bound，它返回第一个“大于或等于”值的位置</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">decltype(cend(v)) pos;            &#x2F;&#x2F; 声明一个迭代器，使用decltype\n\npos &#x3D; std::lower_bound(          &#x2F;&#x2F; 找到第一个&gt;&#x3D;7的位置\n    cbegin(v), cend(v), 7\n);  \nfound &#x3D; (pos !&#x3D; cend(v)) &amp;&amp; (*pos &#x3D;&#x3D; 7); &#x2F;&#x2F; 可能找不到，所以必须要判断\nassert(found);                          &#x2F;&#x2F; 7在容器里\n\npos &#x3D; std::lower_bound(               &#x2F;&#x2F; 找到第一个&gt;&#x3D;9的位置\n    cbegin(v), cend(v), 9\n);  \nfound &#x3D; (pos !&#x3D; cend(v)) &amp;&amp; (*pos &#x3D;&#x3D; 9); &#x2F;&#x2F; 可能找不到，所以必须要判断\nassert(!found);                          &#x2F;&#x2F; 9不在容器里c</code></pre></li>\n<li><p>upper_bound，返回的是第一个“大于”值的元素。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">pos &#x3D; std::upper_bound(             &#x2F;&#x2F; 找到第一个&gt;9的位置\n    cbegin(v), cend(v), 9\n);</code></pre></li>\n<li><p>find：与binary_search不同，返回值是迭代器</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">multiset&lt;int&gt; s &#x3D; &#123;3,5,1,7,7,7,10,99,42&#125;;  &#x2F;&#x2F; multiset，允许重复\n\nauto pos &#x3D; s.find(7);                      &#x2F;&#x2F; 二分查找，返回迭代器\nassert(pos !&#x3D; s.end());                   &#x2F;&#x2F; 与end()比较才能知道是否找到\n\nauto lower_pos &#x3D; s.lower_bound(7);       &#x2F;&#x2F; 获取区间的左端点\nauto upper_pos &#x3D; s.upper_bound(7);       &#x2F;&#x2F; 获取区间的右端点\n\nfor_each(                                &#x2F;&#x2F; for_each算法\n    lower_pos, upper_pos, print          &#x2F;&#x2F; 输出7,7,7\n);</code></pre></li>\n<li><p>其他算法</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; v &#x3D; &#123;1,9,11,3,5,7&#125;;  &#x2F;&#x2F; vector容器\n\ndecltype(v.end()) pos;          &#x2F;&#x2F; 声明一个迭代器，使用decltype\n\npos &#x3D; std::find(                 &#x2F;&#x2F; 查找算法，找到第一个出现的位置\n    begin(v), end(v), 3\n);  \nassert(pos !&#x3D; end(v));         &#x2F;&#x2F; 与end()比较才能知道是否找到\n\npos &#x3D; std::find_if(            &#x2F;&#x2F; 查找算法，用lambda判断条件\n    begin(v), end(v),\n    [](auto x) &#123;              &#x2F;&#x2F; 定义一个lambda表达式\n        return x % 2 &#x3D;&#x3D; 0;    &#x2F;&#x2F; 判断是否偶数\n    &#125;\n);  \nassert(pos &#x3D;&#x3D; end(v));        &#x2F;&#x2F; 与end()比较才能知道是否找到\n\narray&lt;int, 2&gt; arr &#x3D; &#123;3,5&#125;;    &#x2F;&#x2F; array容器\npos &#x3D; std::find_first_of(      &#x2F;&#x2F; 查找一个子区间\n    begin(v), end(v),\n    begin(arr), end(arr)\n);  \nassert(pos !&#x3D; end(v));       &#x2F;&#x2F; 与end()比较才能知道是否找到</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-Concurrency-lib\"><a href=\"#4-Concurrency-lib\" class=\"headerlink\" title=\"4.Concurrency lib\"></a>4.Concurrency lib</h3><ol>\n<li><p>线程和多线程，在C++里，线程就是一个能独立运行的函数，比如一个lambda函数。读而不写就不会有数据竞争，所以尽可能让操作都是只读的</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto f &#x3D; []()                &#x2F;&#x2F; 定义一个lambda表达式\n&#123;\n    cout &lt;&lt; &quot;tid&#x3D;&quot; &lt;&lt;\n        this_thread::get_id() &lt;&lt; endl;\n&#125;;\n\nthread t(f);                &#x2F;&#x2F; 启动一个线程，运行函数f</code></pre></li>\n<li><p>多线程开发实践</p>\n<ul>\n<li><p>仅调用一次：用于控制仅初始化一次数据，声明一个once_flag类型的变量，最好是静态的、全局的，作为初始化的标志然后调用专门的call_once函数来传递这个标志，和初始化函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">static std::once_flag flag;        &#x2F;&#x2F; 全局的初始化标志\n\nauto f &#x3D; []()                &#x2F;&#x2F; 在线程里运行的lambda表达式\n&#123;   \n    std::call_once(flag,      &#x2F;&#x2F; 仅一次调用，注意要传flag\n        []()&#123;                &#x2F;&#x2F; 匿名lambda，初始化函数，只会执行一次\n            cout &lt;&lt; &quot;only once&quot; &lt;&lt; endl;\n        &#125;                  &#x2F;&#x2F; 匿名lambda结束\n    );                     &#x2F;&#x2F; 在线程里运行的lambda表达式结束\n&#125;;\n\nthread t1(f);            &#x2F;&#x2F; 启动两个线程，运行函数f\nthread t2(f);</code></pre></li>\n<li><p>线程局部存储：读写全局（或局部静态）变量是另一个比较常见的数据竞争场景，但是有时候并不一定是必须共享的，应该是线程局部存储的，通过thread_local实现，它是一个和extern、static同级的变量存储说明</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">thread_local int n &#x3D; 0;        &#x2F;&#x2F; 线程局部存储变量，如果是static就会被加两次\n\nauto f &#x3D; [&amp;](int x)           &#x2F;&#x2F; 在线程里运行的lambda表达式，捕获引用\n&#123;   \n    n +&#x3D; x;                   &#x2F;&#x2F; 使用线程局部变量，互不影响\n    cout &lt;&lt; n;                &#x2F;&#x2F; 输出，验证结果\n&#125;;  \n\nthread t1(f, 10);           &#x2F;&#x2F; 启动两个线程，运行函数f\nthread t2(f, 20);</code></pre></li>\n<li><p>原子变量：</p>\n<ul>\n<li><p>对于非独占、必须共享的数据，通过互斥量或原子化来解决。目前C++只能让一些最基本的类型原子化，比如atomic_int、atomic_long，他们都是atomic的特化形式，包装了原始的类型，具有相同的结构。原子变量禁用了拷贝构造函数，所以在初始化的时候不能用“=”的赋值形式，只能用圆括号或者花括号。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using atomic_bool &#x3D; std::atomic&lt;bool&gt;;    &#x2F;&#x2F; 原子化的bool\nusing atomic_int  &#x3D; std::atomic&lt;int&gt;;      &#x2F;&#x2F; 原子化的int\nusing atomic_long &#x3D; std::atomic&lt;long&gt;;    &#x2F;&#x2F; 原子化的long\n\n\natomic_int  x &#123;0&#125;;          &#x2F;&#x2F; 初始化，不能用&#x3D;\natomic_long y &#123;1000L&#125;;      &#x2F;&#x2F; 初始化，只能用圆括号或者花括号\n\nassert(++x &#x3D;&#x3D; 1);           &#x2F;&#x2F; 自增运算\n\ny +&#x3D; 200;                   &#x2F;&#x2F; 加法运算\nassert(y &lt; 2000);           &#x2F;&#x2F; 比较运算 </code></pre></li>\n<li><p>除了模拟整数运算，原子变量还有一些特殊的原子操作，比如 store、load、fetch_add、fetch_sub、exchange、compare_exchange_weak/compare_exchange_strong，最后一组就是著名的 CAS（Compare And Swap）操作。</p>\n</li>\n<li><p>而另一个同样著名的 TAS（Test And Set）操作，则需要用到一个特殊的原子类型 atomic_flag。它不是简单的 bool 特化（atomic），没有 store、load 的操作，只用来实现 TAS，保证绝对无锁。</p>\n</li>\n</ul>\n</li>\n<li><p>线程对象：</p>\n<ul>\n<li><p>C++ 标准库里有专门的线程类 thread，使用它就可以简单地创建线程，在名字空间 std::this_thread 里，还有 yield()、get_id()、sleep_for()、sleep_until() 等几个方便的管理函数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">static atomic_flag flag &#123;false&#125;;    &#x2F;&#x2F; 原子化的标志量\nstatic atomic_int  n;               &#x2F;&#x2F; 原子化的int\n\nauto f &#x3D; [&amp;]()              &#x2F;&#x2F; 在线程里运行的lambda表达式，捕获引用\n&#123;\n    auto value &#x3D; flag.test_and_set();  &#x2F;&#x2F; TAS检查原子标志量\n\n    if (value) &#123;\n        cout &lt;&lt; &quot;flag has been set.&quot; &lt;&lt; endl;\n    &#125; else &#123;\n        cout &lt;&lt; &quot;set flag by &quot; &lt;&lt;\n            this_thread::get_id() &lt;&lt; endl;  &#x2F;&#x2F; 输出线程id\n    &#125;\n\n    n +&#x3D; 100;                    &#x2F;&#x2F; 原子变量加法运算\n\n    this_thread::sleep_for(      &#x2F;&#x2F; 线程睡眠\n        n.load() * 10ms);        &#x2F;&#x2F; 使用时间字面量\n    cout &lt;&lt; n &lt;&lt; endl;\n&#125;;                        &#x2F;&#x2F; 在线程里运行的lambda表达式结束\n\nthread t1(f);                &#x2F;&#x2F; 启动两个线程，运行函数f\nthread t2(f);\n\nt1.join();                   &#x2F;&#x2F; 等待线程结束    \nt2.join();</code></pre></li>\n<li><p>async：异步运行一个任务，隐含的动作是启动一个线程去执行，但不绝对保证立即启动（也可以在第一个参数传递 std::launch::async，要求立即启动线程）。大多数 thread 能做的事情也可以用 async() 来实现，但不会看到明显的线程（如果你不显式获取 async() 的返回值（即 future 对象），它就会同步阻塞直至任务完成（由于临时对象的析构函数））</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto task &#x3D; [](auto x)                  &#x2F;&#x2F; 在线程里运行的lambda表达式\n&#123;\n    this_thread::sleep_for( x * 1ms);  &#x2F;&#x2F; 线程睡眠\n    cout &lt;&lt; &quot;sleep for &quot; &lt;&lt; x &lt;&lt; endl;\n    return x;\n&#125;;\n\nauto f &#x3D; std::async(task, 10);         &#x2F;&#x2F; 启动一个异步任务\nf.wait();                              &#x2F;&#x2F; 等待任务完成\n\nassert(f.valid());                    &#x2F;&#x2F; 确实已经完成了任务\ncout &lt;&lt; f.get() &lt;&lt; endl;              &#x2F;&#x2F; 获取任务的执行结果\n\n\nstd::async(task, ...);            &#x2F;&#x2F; 没有显式获取future，被同步阻塞\nauto f &#x3D; std::async(task, ...);   &#x2F;&#x2F; 只有上一个任务完成后才能被执行</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-General-util-lib\"><a href=\"#5-General-util-lib\" class=\"headerlink\" title=\"5.General util lib\"></a>5.General util lib</h3><ol>\n<li><p>optional（C++17）</p>\n<ul>\n<li><p>原先C++函数只能返回一个值，而且必须是可用的，但是有时候如果执行不成功，就不一定能够返回有意义的值，比如内存空间不足，创建对象失败、模式字符串不存在等等，这个时候函数的返回值就回事无效的。往往使用-1、抛出异常等方法</p>\n</li>\n<li><p>此时需要一种简单的、轻量级的概念，能够表示任何的无效值，即模版类optional。optional可以近似地看做是只能容纳一个元素的特殊容器，而这样的容器就会有是否持有元素的两种状态，即空和非空，恰好对应无效和有效。optional对象默认是空的，也就是处于无效状态，给它赋值后因为有了元素，就变成了有效状态。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">optional&lt;int&gt; op;             &#x2F;&#x2F; 持有int的optional对象\nassert(!op.has_value());         &#x2F;&#x2F; 默认是无效值\n\t\t\t\t\t\t\t\t\t\t\t\t\t\nop &#x3D; 10;                 &#x2F;&#x2F; 赋值，持有有效值\nif (op.has_value()) &#123;          &#x2F;&#x2F; 判断是否有效\n  cout &lt;&lt; &quot;value is valid&quot; &lt;&lt; endl;\n&#125; \n\n\noptional op &#123;&quot;zelda&quot;&#125;; &#x2F;&#x2F; 持有string的optional对象\nassert(op); &#x2F;&#x2F; 可以像指针一样bool判断\nassert(!op-&gt;empty() &amp;&amp; *op &#x3D;&#x3D; &quot;zelda&quot;); &#x2F;&#x2F; 使用*&#x2F;-&gt;访问内部的值\n\nop.reset(); &#x2F;&#x2F; 清空内部的值\nassert(!op); &#x2F;&#x2F; 此时是无效值\n\n&#x2F;&#x2F;即使不提供初始化参数，它也必定会用“零值”创建出一个有效值的 optional 对象\nauto op1 &#x3D; make_optional&lt;int&gt;();    &#x2F;&#x2F; 使用默认值构造有效值\nauto op2 &#x3D; make_optional&lt;string&gt;();    &#x2F;&#x2F; 使用默认值构造有效值\n\nassert(op1 &amp;&amp; op2);           &#x2F;&#x2F; make_optional总是有效的\nassert(op1 &#x3D;&#x3D; 0);             &#x2F;&#x2F; 值是默认的0\nassert(op2-&gt;empty());          &#x2F;&#x2F; 值是空字符串\n\nauto op3 &#x3D; make_optional&lt;string&gt;(&quot;hi&quot;);      &#x2F;&#x2F; 带参数创建optional\nauto op4 &#x3D; make_optional&lt;vector&lt;int&gt;&gt;(&#123;1,2,3&#125;);  &#x2F;&#x2F; 带参数创建optional\n\nassert(op3-&gt;size() &#x3D;&#x3D; 2);\nassert(op4-&gt;at(0) &#x3D;&#x3D; 1);</code></pre></li>\n<li><p>使用示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto safe_sqrt &#x3D; [](double x) &#123;      &#x2F;&#x2F; lambda表达式开平方\n  optional&lt;double&gt; v;         &#x2F;&#x2F; 默认是无效值\n\n  if (x &lt; 0) &#123;            &#x2F;&#x2F; 负数无法求平方根\n    return v;             &#x2F;&#x2F; 返回无效值\n  &#125;\n\n  v  &#x3D; ::sqrt(x);           &#x2F;&#x2F; 正数平方根有效\n  return v;               &#x2F;&#x2F; 返回有效值\n&#125;;\n\nassert(!safe_sqrt(-1));         &#x2F;&#x2F; 负数无法求平方根\nassert(safe_sqrt(9).value() &#x3D;&#x3D; 3);     &#x2F;&#x2F; 正数平方根有效\n\n&#x2F;&#x2F;当它内部持有的是 bool 类型的时候，由于它本身可以转型成 bool，但含义是值的有效性，而并非内部的 bool 真假\noptional&lt;bool&gt; op &#123;false&#125;;         &#x2F;&#x2F; 持有bool的optional对象\n\nif (op) &#123;                &#x2F;&#x2F; 错误用法，实际上判断的是有效性\n    cout &lt;&lt; &quot;misuse&quot; &lt;&lt; endl;\n&#125;\n\nif (op &amp;&amp; op.value()) &#123;          &#x2F;&#x2F; 正确用法，有效后再检查值\n    cout &lt;&lt; &quot; right &quot; &lt;&lt; endl;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>variant（C++17）</p>\n<ul>\n<li><p>类似一个智能union，能够聚合任意类型，没有任何限制，使用起来又和union几乎一样方便。如果以容器的视角来看，就像是只容纳一个元素的异质容器，里面存放的具体类型是不确定的，想知道是哪种元素必须调用index函数，它会返回当前元素在模版参数列表里的索引</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">variant&lt;int, float, double&gt; v;       &#x2F;&#x2F; 可以容纳三种不同的整数\n\nv &#x3D; 42;                 &#x2F;&#x2F; 直接赋值为int\nassert(v.index() &#x3D;&#x3D; 0);         &#x2F;&#x2F; 索引号是0\n\nv &#x3D; 3.14f;                 &#x2F;&#x2F; 直接赋值为float\nassert(v.index() &#x3D;&#x3D; 1);         &#x2F;&#x2F; 索引号是1\n\nv &#x3D; 2.718;                 &#x2F;&#x2F; 直接赋值为double\nassert(v.index() &#x3D;&#x3D; 2);         &#x2F;&#x2F; 索引号是2</code></pre></li>\n<li><p>因为 variant 需要存储任意类型，内部结构比较复杂，所以 variant 不能像 union 那样用成员变量的形式来访问内部的值，必须要用外部的函数 get() 来获取值。get() 是一个比较特别的模板函数，调用时必须在函数名后加上模板的尖括号，里面的模板参数可以是类型名或者是索引号</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">v &#x3D; 42;               &#x2F;&#x2F; 赋值为int\nassert(get&lt;0&gt;(v) &#x3D;&#x3D; 42);       &#x2F;&#x2F; 取第0号的值，即int\n\nv &#x3D; 2.718;               &#x2F;&#x2F; 赋值为double\nauto x &#x3D; get&lt;double&gt;(v);       &#x2F;&#x2F; 取double的值，即第2号\n\nget&lt;int&gt;(v);             &#x2F;&#x2F; 当前是double，所以出错，抛出异常</code></pre></li>\n<li><p>get() 访问了不存在的值就会出错，C++ 会以抛出异常的方式来告知调用者。不过抛出异常的方式不太友好，try-catch 处理起来比较麻烦，所以我们还可以用另一个模板函数 get_if()，它以指针的方式返回 variant 内部的值，如果不存在就是 nullptr，这样用起来就比较轻松了：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">auto p &#x3D; get_if&lt;int&gt;(&amp;v);       &#x2F;&#x2F; 取int的值，不存在就是空指针\nassert(p &#x3D;&#x3D; nullptr);</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-Memory-lib\"><a href=\"#6-Memory-lib\" class=\"headerlink\" title=\"6.Memory  lib\"></a>6.Memory  lib</h3><h2 id=\"4-开源库\"><a href=\"#4-开源库\" class=\"headerlink\" title=\"4.开源库\"></a>4.开源库</h2><h3 id=\"1-序列化\"><a href=\"#1-序列化\" class=\"headerlink\" title=\"1.序列化\"></a>1.序列化</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>序列化，就是把内存里“活的对象”转换成静止的字节序列，便于存储和网络传输；而反序列化则是反向操作，从静止的字节序列重新构建出内存里可用的对象</p></blockquote>\n<ol>\n<li><p>JSON</p>\n<ul>\n<li><p>起源于最流行的脚本语言JavaScript，在Web领域应用广泛</p>\n</li>\n<li><p><a href=\"https://github.com/nlohmann/json\">https://github.com/nlohmann/json</a></p>\n</li>\n<li><p>使用</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using json_t &#x3D; nlohmann::json;\n\njson_t j;                                   &#x2F;&#x2F; JSON对象\n\nj[&quot;age&quot;] &#x3D; 23;                              &#x2F;&#x2F; &quot;age&quot;:23\nj[&quot;name&quot;] &#x3D; &quot;spiderman&quot;;                    &#x2F;&#x2F; &quot;name&quot;:&quot;spiderman&quot;\nj[&quot;gear&quot;][&quot;suits&quot;] &#x3D; &quot;2099&quot;;                &#x2F;&#x2F; &quot;gear&quot;:&#123;&quot;suits&quot;:&quot;2099&quot;&#125;\nj[&quot;jobs&quot;] &#x3D; &#123;&quot;superhero&quot;&#125;;                  &#x2F;&#x2F; &quot;jobs&quot;:[&quot;superhero&quot;]  \n\nvector&lt;int&gt; v &#x3D; &#123;1,2,3&#125;;                   &#x2F;&#x2F; vector容器\nj[&quot;numbers&quot;] &#x3D; v;                          &#x2F;&#x2F; &quot;numbers&quot;:[1,2,3]\n\nmap&lt;string, int&gt; m &#x3D;                       &#x2F;&#x2F; map容器\n    &#123;&#123;&quot;one&quot;,1&#125;, &#123;&quot;two&quot;, 2&#125;&#125;;               &#x2F;&#x2F; 初始化列表 \nj[&quot;kv&quot;] &#x3D; m;                               &#x2F;&#x2F; &quot;kv&quot;:&#123;&quot;one&quot;:1,&quot;two&quot;:2&#125;\n\n&#x2F;&#x2F;序列化\ncout &lt;&lt; j.dump() &lt;&lt; endl;         &#x2F;&#x2F; 序列化，无缩进\ncout &lt;&lt; j.dump(2) &lt;&lt; endl;        &#x2F;&#x2F; 序列化，有缩进，2个空格\n\n&#x2F;&#x2F;反序列化\nstring str &#x3D; R&quot;(&#123;                \n    &quot;name&quot;: &quot;peter&quot;,\n    &quot;age&quot; : 23,\n    &quot;married&quot; : true\n&#125;)&quot;;\t\t\t\t\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; JSON文本，原始字符串\n\nauto j &#x3D; json_t::parse(str);    &#x2F;&#x2F; 从字符串反序列化\nassert(j[&quot;age&quot;] &#x3D;&#x3D; 23);        &#x2F;&#x2F; 验证序列化是否正确\nassert(j[&quot;name&quot;] &#x3D;&#x3D; &quot;peter&quot;);\n\n&#x2F;&#x2F;使用异常来处理可能发生的错误\nauto txt &#x3D; &quot;bad:data&quot;s;        &#x2F;&#x2F; 不是正确的JSON数据\n\ntry                             &#x2F;&#x2F; try保护代码\n&#123;\n    auto j &#x3D; json_t::parse(txt);&#x2F;&#x2F; 从字符串反序列化\n&#125;\ncatch(std::exception&amp; e)        &#x2F;&#x2F; 捕获异常\n&#123;\n    cout &lt;&lt; e.what() &lt;&lt; endl;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>MessagePack</p>\n<ul>\n<li>一种轻量级的数据交换格式，比JSON更小巧，处理起来更快，不是纯文本的而是二进制的</li>\n</ul>\n</li>\n<li><p>ProtoBuffer</p>\n<ul>\n<li><p>简称PB，由Google出品，PB 也是一种二进制的数据格式，但毕竟是工业级产品，所以没有 JSON 和 MessagePack 那么“轻”，相关的东西比较多，要安装一个预处理器和开发库，编译时还要链接动态库（-lprotobuf）：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">apt-get install protobuf-compiler\napt-get install libprotobuf-dev\n\ng++ protobuf.cpp -std&#x3D;c++14 -lprotobuf -o a.out</code></pre></li>\n<li><p>PB 的另一个特点是数据有“模式”（schema），必须要先写一个 IDL（Interface Description Language）文件，在里面定义好数据结构，只有预先定义了的数据结构，才能被序列化和反序列化。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">syntax &#x3D; &quot;proto2&quot;;                    &#x2F;&#x2F; 使用第2版\n\npackage sample;                        &#x2F;&#x2F; 定义名字空间\n\nmessage Vendor                        &#x2F;&#x2F; 定义消息\n&#123;\n    required uint32     id      &#x3D; 1;  &#x2F;&#x2F; required表示必须字段\n    required string     name    &#x3D; 2;  &#x2F;&#x2F; 有int32&#x2F;string等基本类型\n    required bool       valid   &#x3D; 3;  &#x2F;&#x2F; 需要指定字段的序号，序列化时用\n    optional string     tel     &#x3D; 4;  &#x2F;&#x2F; optional字段可以没有\n&#125;</code></pre></li>\n<li><p>有了接口定义文件，需要再用 protoc 工具生成对应的 C++ 源码，然后把源码文件加入自己的项目中，就可以使用了：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">protoc --cpp_out&#x3D;. sample.proto       &#x2F;&#x2F; 生成C++代码</code></pre></li>\n<li><p>重要接口</p>\n<ul>\n<li>字段名会生成对应的 has/set 函数，检查是否存在和设置值</li>\n<li>IsInitialized() 检查数据是否完整（required 字段必须有值）</li>\n<li>DebugString() 输出数据的可读字符串描述</li>\n<li>ByteSize() 返回序列化数据的长度</li>\n<li>SerializeToString() 从对象序列化到字符串</li>\n<li>ParseFromString() 从字符串反序列化到对象</li>\n<li>SerializeToArray()/ParseFromArray() 序列化的目标是字节数组</li>\n</ul>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">using vendor_t &#x3D; sample::Vendor;        &#x2F;&#x2F; 类型别名\n\nvendor_t v;                             &#x2F;&#x2F; 声明一个PB对象\nassert(!v.IsInitialized());            &#x2F;&#x2F; required等字段未初始化\n\nv.set_id(1);                            &#x2F;&#x2F; 设置每个字段的值    \nv.set_name(&quot;sony&quot;);\nv.set_valid(true);\n\nassert(v.IsInitialized());             &#x2F;&#x2F; required等字段都设置了，数据完整\nassert(v.has_id() &amp;&amp; v.id() &#x3D;&#x3D; 1); \nassert(v.has_name() &amp;&amp; v.name() &#x3D;&#x3D; &quot;sony&quot;);\nassert(v.has_valid() &amp;&amp; v.valid());\n\ncout &lt;&lt; v.DebugString() &lt;&lt; endl;       &#x2F;&#x2F; 输出调试字符串\n\nstring enc;\nv.SerializeToString(&amp;enc);              &#x2F;&#x2F; 序列化到字符串 \n\nvendor_t v2; \nassert(!v2.IsInitialized());\nv2.ParseFromString(enc);               &#x2F;&#x2F; 反序列化</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-网络通信\"><a href=\"#2-网络通信\" class=\"headerlink\" title=\"2.网络通信\"></a>2.网络通信</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>原生的Socket API非常底层，要考虑很多细节，比如 TIME_WAIT、CLOSE_WAIT、REUSEADDR 等，如果再加上异步就更复杂了</p></blockquote>\n<ol>\n<li><p>libcurl：原子curl项目，高移植、功能丰富的通信库，用户包括Apple、Facebook、Google、Netflix</p>\n<ul>\n<li><p>纯C语言写的，兼容性、可移植性非常好。支持很多协议，但最常用的是HTTP协议</p>\n</li>\n<li><p>libcurl 的接口可以粗略地分成两大类：easy 系列和 multi 系列。其中，easy 系列是同步调用，比较简单；multi 系列是异步的多线程调用，比较复杂。通常情况下，我们用 easy 系列就足够了</p>\n</li>\n<li><p>使用 libcurl 收发 HTTP 数据的基本步骤有 4 个：</p>\n<ul>\n<li><p>使用 curl_easy_init() 创建一个句柄，类型是 CURL*。但我们完全没有必要关心句柄的类型，直接用 auto 推导就行</p>\n</li>\n<li><p>使用 curl_easy_setopt() 设置请求的各种参数，比如请求方法、URL、header/body 数据、超时、回调函数等（最关键的操作）</p>\n</li>\n<li><p>使用 curl_easy_perform() 发送数据，返回的数据会由回调函数处理</p>\n</li>\n<li><p>使用 curl_easy_cleanup() 清理句柄相关的资源，结束会话</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;curl&#x2F;curl.h&gt;               &#x2F;&#x2F; 包含头文件\n\nauto curl &#x3D; curl_easy_init();        &#x2F;&#x2F; 创建CURL句柄\nassert(curl);\n\ncurl_easy_setopt(curl, CURLOPT_URL, &quot;http:&#x2F;&#x2F;nginx.org&quot;); &#x2F;&#x2F; 设置请求URI\n\nauto res &#x3D; curl_easy_perform(curl);   &#x2F;&#x2F; 发送数据\nif (res !&#x3D; CURLE_OK) &#123;                &#x2F;&#x2F; 检查是否执行成功\n    cout &lt;&lt; curl_easy_strerror(res) &lt;&lt; endl;\n&#125;\n\ncurl_easy_cleanup(curl);             &#x2F;&#x2F; 清理句柄相关的资源</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>cpr：更现代、更通用的通信库</p>\n<ul>\n<li><p>cpr是对libcurl的一个C++11封装</p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">const auto url &#x3D; &quot;http:&#x2F;&#x2F;openresty.org&quot;s;  &#x2F;&#x2F; 访问的URL\n\nauto res1 &#x3D; cpr::Head(                    &#x2F;&#x2F; 发送HEAD请求\n            cpr::Url&#123;url&#125;                 &#x2F;&#x2F; 传递URL\n);\n\nauto res2 &#x3D; cpr::Get(                     &#x2F;&#x2F; 发送GET请求\n            cpr::Url&#123;url&#125;,               &#x2F;&#x2F; 传递URL\n            cpr::Parameters&#123;             &#x2F;&#x2F; 传递URL参数\n                &#123;&quot;a&quot;, &quot;1&quot;&#125;, &#123;&quot;b&quot;, &quot;2&quot;&#125;&#125;\n);\n\nauto res3 &#x3D; cpr::Post(                  &#x2F;&#x2F; 发送POST请求\n            cpr::Url&#123;url&#125;,             &#x2F;&#x2F; 传递URL\n            cpr::Header&#123;                &#x2F;&#x2F; 定制请求头字段\n              &#123;&quot;x&quot;, &quot;xxx&quot;&#125;,&#123;&quot;expect&quot;,&quot;&quot;&#125;&#125;,\n            cpr::Body&#123;&quot;post data&quot;&#125;,    &#x2F;&#x2F; 传递body数据\n            cpr::Timeout&#123;200ms&#125;       &#x2F;&#x2F; 超时时间\n);</code></pre></li>\n</ul>\n</li>\n<li><p>ZMQ：高效、快速、多功能的通信库</p>\n<ul>\n<li>libcurl和cpr处理的都是HTTP协议，需要更底层更灵活的网络通信工具。ZeroMQ（Zero Message Queue）不仅是一个单纯的网络通信库，更像是一个高级的异步并发框架</li>\n<li>定义了5种工作模式<ul>\n<li>原生模式（RAW），没有消息队列功能，相当于底层 Socket 的简单封装</li>\n<li>结对模式（PAIR），两个端点一对一通信</li>\n<li>请求响应模式（REQ-REP），也是两个端点一对一通信，但请求必须有响应</li>\n<li>发布订阅模式（PUB-SUB），一对多通信，一个端点发布消息，多个端点接收处理</li>\n<li>管道模式（PUSH-PULL），或者叫流水线，可以一对多，也可以多对一</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-I-O及文件操作\"><a href=\"#3-I-O及文件操作\" class=\"headerlink\" title=\"3.I/O及文件操作\"></a>3.I/O及文件操作</h3><ol>\n<li><p>输入输出流</p>\n<ol>\n<li><p>cin</p>\n</li>\n<li><p>cout、cerr、clog</p>\n<ul>\n<li>cout支持重定向到文件</li>\n<li>cerr不设缓冲区，否则需要\\n和endl刷新缓冲区</li>\n</ul>\n</li>\n<li><p>无论是使用 cout 输出普通数据，用 cout.put() 输出指定字符，还是用 cout.write() 输出指定字符串，数据都会先放到输出流缓冲区，待缓冲区刷新，数据才会输出到指定位置（屏幕或者文件中）。值得一提的是，当数据暂存于输出流缓冲区中时，我们仍可以对其进行修改。ostream 类中提供有 tellp() 和 seekp() 成员方法，借助它们就可以修改位于输出流缓冲区中的数据。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n    double a &#x3D; 1.23;\n    &#x2F;&#x2F;设定后续输出的浮点数的精度为 4\n    cout.precision(4);\n    cout &lt;&lt;&quot;precision: &quot;&lt;&lt; a &lt;&lt; endl;\n    &#x2F;&#x2F;设定后续以科学计数法的方式输出浮点数\n    cout.setf(ios::scientific);\n    cout &lt;&lt;&quot;scientific：&quot;&lt;&lt; a &lt;&lt; endl;\n    return 0;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>文件操作</p>\n<ol>\n<li><p>文件的打开</p>\n<ol>\n<li><p><code>void open(const char* szFileName, int mode)</code>,第一个参数是指向文件名的指针，第二个参数是文件的打开模式标记。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main() &#123;\n    const char *url &#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;;\n    &#x2F;&#x2F;创建一个 fstream 类对象\n    fstream fs;\n    &#x2F;&#x2F;将 test.txt 文件和 fs 文件流关联\n    fs.open(&quot;test.txt&quot;, ios::out);\n    &#x2F;&#x2F;向test.txt文件中写入 url 字符串\n    fs.write(url, 30);\n    fs.close();\n    return 0;\n&#125;</code></pre></li>\n<li><p>文件打开模式标记</p>\n</li>\n</ol>\n</li>\n<li><p>文件的关闭close()</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    const char *url&#x3D;&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;cplus&#x2F;&quot;;\n    ofstream outFile(&quot;url.txt&quot;, ios::out);\n    &#x2F;&#x2F;向 url.txt 文件中写入字符串\n    outFile.write(url, 30);\n    &#x2F;&#x2F;关闭已打开的文件\n    outFile.close();\n    return 0;\n&#125;</code></pre></li>\n<li><p>文件的读写</p>\n<ol>\n<li><p>&gt;&gt;和&lt;&lt;读写文本文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    int x,sum&#x3D;0;\n    ifstream srcFile(&quot;in.txt&quot;, ios::in); &#x2F;&#x2F;以文本模式打开in.txt备读\n    if (!srcFile) &#123; &#x2F;&#x2F;打开失败\n        cout &lt;&lt; &quot;error opening source file.&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    ofstream destFile(&quot;out.txt&quot;, ios::out); &#x2F;&#x2F;以文本模式打开out.txt备写\n    if (!destFile) &#123;\n        srcFile.close(); &#x2F;&#x2F;程序结束前不能忘记关闭以前打开过的文件\n        cout &lt;&lt; &quot;error opening destination file.&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    &#x2F;&#x2F;可以像用cin那样用ifstream对象\n    while (srcFile &gt;&gt; x) &#123;\n        sum +&#x3D; x;\n        &#x2F;&#x2F;可以像 cout 那样使用 ofstream 对象\n        destFile &lt;&lt; x &lt;&lt; &quot; &quot;;\n    &#125;\n    cout &lt;&lt; &quot;sum：&quot; &lt;&lt; sum &lt;&lt; endl;\n    destFile.close();\n    srcFile.close();\n    return 0;\n&#125;</code></pre></li>\n<li><p>read()和write()读写二进制文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nclass CStudent\n&#123;\npublic:\n    char szName[20];\n    int age;\n&#125;;\nint main()\n&#123;\n    &#x2F;&#x2F;读\n    CStudent s;\n    ofstream outFile(&quot;students.dat&quot;, ios::out | ios::binary);\n    while (cin &gt;&gt; s.szName &gt;&gt; s.age)\n        outFile.write((char*)&amp;s, sizeof(s));\n    outFile.close();\n    &#x2F;&#x2F;return 0;\n    &#x2F;&#x2F;写\n    CStudent s;       \n    ifstream inFile(&quot;students.dat&quot;,ios::in|ios::binary); &#x2F;&#x2F;二进制读方式打开\n    if(!inFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt;endl;\n        return 0;\n    &#125;\n    while(inFile.read((char *)&amp;s, sizeof(s))) &#123; &#x2F;&#x2F;一直读到文件结束\n        cout &lt;&lt; s.szName &lt;&lt; &quot; &quot; &lt;&lt; s.age &lt;&lt; endl;   \n    &#125;\n    inFile.close();\n    return 0;\n&#125;</code></pre></li>\n<li><p>get()和put()读写文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    char c;\n    &#x2F;&#x2F;以二进制形式打开文件\n    ofstream outFile(&quot;out.txt&quot;, ios::out | ios::binary);\n    if (!outFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while (cin &gt;&gt; c) &#123;\n        &#x2F;&#x2F;将字符 c 写入 out.txt 文件\n        outFile.put(c);\n    &#125;\n    outFile.close();\n    return 0;\n&#125;\n</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    char c;\n    &#x2F;&#x2F;以二进制形式打开文件\n    ifstream inFile(&quot;out.txt&quot;, ios::out | ios::binary);\n    if (!inFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    while ( (c&#x3D;inFile.get())&amp;&amp;c!&#x3D;EOF )   &#x2F;&#x2F;或者 while(inFile.get(c))，对应第二种语法格式\n    &#123;\n        cout &lt;&lt; c ;\n    &#125;\n    inFile.close();\n    return 0;\n&#125;</code></pre></li>\n<li><p>getline()从文件读取一行字符串</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;fstream&gt;\nusing namespace std;\nint main()\n&#123;\n    char c[40];\n    ifstream inFile(&quot;in.txt&quot;, ios::in | ios::binary);\n    if (!inFile) &#123;\n        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;\n        return 0;\n    &#125;\n    &#x2F;&#x2F;连续以行为单位，读取 in.txt 文件中的数据\n    while (inFile.getline(c, 40)) &#123;\n        cout &lt;&lt; c &lt;&lt; endl;\n    &#125;\n    inFile.close();\n    return 0;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-性能分析\"><a href=\"#4-性能分析\" class=\"headerlink\" title=\"4.性能分析\"></a>4.性能分析</h3><ol>\n<li><p>系统级工具</p>\n<ul>\n<li><p>top：无论开发什么样的应用程序， top 命令能够简单直观地看到 CPU、内存等关键的性能指标。如果某个指标有问题，就要深入进程内部查看是哪些操作的原因</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/6a44808ccc8b1df7bef0a51c888ce2a8-20220827203451660-20220828173205574-20220921163542811-20221123125900569.png\" alt=\"img\"></p>\n</li>\n<li><p>pstack：可以打印出进程的调用栈信息，有点像是给正在运行的进程拍了个快照，能看到某个时刻的进程里调用的函数和关系，对进程的运行有个初步的印象</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/6c115ce03d6b4803960277468cf91b9c-20220828173205684-20220921163543015-20221123125900727.png\" alt=\"img\"></p>\n</li>\n<li><p>strace：pstack 显示的只是进程的一个“静态截面”，信息量还是有点少，而 strace 可以显示出进程的正在运行的系统调用，实时查看进程与系统内核交换了哪些信息</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/b747d0d977c7f420507ec9e9d84e6ff0-20220828173205742-20220921163543172-20221123125900800.png\" alt=\"img\"></p>\n</li>\n<li><p>perf：可以说是 pstack 和 strace 的“高级版”，它按照固定的频率去“采样”，相当于连续执行多次的 pstack，然后再统计函数的调用次数，算出百分比。只要采样的频率足够大，把这些“瞬时截面”组合在一起，就可以得到进程运行时的可信数据，比较全面地描述出 CPU 使用情况。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/5543dec44c23d23b583bc937213e7c15-20220828173205873-20220921163543382-20221123125901079.png\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>源码级工具：Google Performance Tools</p>\n<ul>\n<li>在源码里“埋点”，直接写特别的性能分析代码，有目的地对系统的某个模块做精细化分析，拿到更准确、更详细的数据。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-其他开源库概览\"><a href=\"#5-其他开源库概览\" class=\"headerlink\" title=\"5.其他开源库概览\"></a>5.其他开源库概览</h3><ol>\n<li></li>\n</ol>\n<h2 id=\"5-实战\"><a href=\"#5-实战\" class=\"headerlink\" title=\"5.实战\"></a>5.实战</h2><h3 id=\"1-C-primer\"><a href=\"#1-C-primer\" class=\"headerlink\" title=\"1.C++primer\"></a>1.C++primer</h3><h3 id=\"2-Effective-C\"><a href=\"#2-Effective-C\" class=\"headerlink\" title=\"2.Effective C++\"></a>2.Effective C++</h3><h4 id=\"1-Effective-C\"><a href=\"#1-Effective-C\" class=\"headerlink\" title=\"1.Effective C++\"></a>1.Effective C++</h4><ol>\n<li>视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL）</li>\n<li>宁可以编译器替换预处理器（尽量以 <code>const</code>、<code>enum</code>、<code>inline</code> 替换 <code>#define</code>）</li>\n<li>尽可能使用 const</li>\n<li>确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高）</li>\n<li>了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数）</li>\n<li>若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现）</li>\n<li>为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数）</li>\n<li>别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理）</li>\n<li>绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class）</li>\n<li>令 <code>operator=</code> 返回一个 <code>reference to *this</code> （用于连锁赋值）</li>\n<li>在 <code>operator=</code> 中处理 “自我赋值”</li>\n<li>赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数）</li>\n<li>以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII））</li>\n<li>在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr））</li>\n<li>在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便）</li>\n<li>成对使用 new 和 delete 时要采取相同形式（<code>new</code> 中使用 <code>[]</code> 则 <code>delete []</code>，<code>new</code> 中不使用 <code>[]</code> 则 <code>delete</code>）</li>\n<li>以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏）</li>\n<li>让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任）</li>\n<li>设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。</li>\n<li>宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象）</li>\n<li>必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。）</li>\n<li>将成员变量声明为 private（为了封装、一致性、对其读写精确控制等）</li>\n<li>宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性）</li>\n<li>若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数</li>\n<li>考虑写一个不抛异常的 swap 函数</li>\n<li>尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率）</li>\n<li>尽量少做转型动作（旧式：<code>(T)expression</code>、<code>T(expression)</code>；新式：<code>const_cast&lt;T&gt;(expression)</code>、<code>dynamic_cast&lt;T&gt;(expression)</code>、<code>reinterpret_cast&lt;T&gt;(expression)</code>、<code>static_cast&lt;T&gt;(expression)</code>、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型）</li>\n<li>避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性）</li>\n<li>为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型）</li>\n<li>透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级）</li>\n<li>将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件）</li>\n<li>确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象）</li>\n<li>避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日）</li>\n<li>区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承）</li>\n<li>考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 <code>tr1::function</code> 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数）</li>\n<li>绝不重新定义继承而来的 non-virtual 函数</li>\n<li>绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound）</li>\n<li>通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出））</li>\n<li>明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承）</li>\n<li>明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本）</li>\n<li>了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期）</li>\n<li>了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符）</li>\n<li>学习处理模板化基类内的名称（可在 derived class templates 内通过 <code>this-&gt;</code> 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成）</li>\n<li>将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码）</li>\n<li>运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符）</li>\n<li>需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”）</li>\n<li>请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if…else 测试）</li>\n<li>认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码）</li>\n<li>了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常）</li>\n<li>了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为）</li>\n<li>编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”）</li>\n<li>写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本）</li>\n<li>不要轻忽编译器的警告</li>\n<li>让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件）</li>\n<li>让自己熟悉 Boost（准标准库）</li>\n</ol>\n<h4 id=\"2-More-Effective-c\"><a href=\"#2-More-Effective-c\" class=\"headerlink\" title=\"2.More Effective c++\"></a>2.More Effective c++</h4><ol>\n<li>仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers）</li>\n<li>最好使用 C++ 转型操作符（<code>static_cast</code>、<code>const_cast</code>、<code>dynamic_cast</code>、<code>reinterpret_cast</code>）</li>\n<li>绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用）</li>\n<li>非必要不提供 default constructor（避免对象中的字段被无意义地初始化）</li>\n<li>对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为）</li>\n<li>区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础）</li>\n<li>千万不要重载 <code>&amp;&amp;</code>，<code>||</code> 和 <code>,</code> 操作符（<code>&amp;&amp;</code> 与 <code>||</code> 的重载会用 “函数调用语义” 取代 “骤死式语义”；<code>,</code> 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估）</li>\n<li>了解各种不同意义的 new 和 delete（<code>new operator</code>、<code>operator new</code>、<code>placement new</code>、<code>operator new[]</code>；<code>delete operator</code>、<code>operator delete</code>、<code>destructor</code>、<code>operator delete[]</code>）</li>\n<li>利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏）</li>\n<li>在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try…catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题）</li>\n<li>禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情）</li>\n<li>了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数）</li>\n<li>以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数）</li>\n<li>明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions）</li>\n<li>了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions）</li>\n<li>谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码）</li>\n<li>考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作）</li>\n<li>分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）</li>\n</ol>\n<h3 id=\"3-C-20\"><a href=\"#3-C-20\" class=\"headerlink\" title=\"3.C++20\"></a>3.C++20</h3><h4 id=\"1-C-20实践入门\"><a href=\"#1-C-20实践入门\" class=\"headerlink\" title=\"1.C++20实践入门\"></a>1.C++20实践入门</h4><h4 id=\"2-C-20高级编程\"><a href=\"#2-C-20高级编程\" class=\"headerlink\" title=\"2.C++20高级编程\"></a>2.C++20高级编程</h4><h1 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h1><h2 id=\"Theory\"><a href=\"#Theory\" class=\"headerlink\" title=\"Theory\"></a>Theory</h2><h3 id=\"1-概述-1\"><a href=\"#1-概述-1\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h3><ul>\n<li>OS定义：控制软硬件、调度和资源分配、提供接口和环境（命令接口和程序接口、库函数和系统调用）</li>\n<li>OS特征：并发、共享、虚拟、保护（前俩最基本、并发与并行）</li>\n<li>甘特图：纵程序、横时间，画资源</li>\n<li>OS发展：多道批处理、分时、实时</li>\n<li>OS运行环境：用户态与核心态、中断和异常、中断处理过程、访管指令（陷入指令）</li>\n<li>通道和中断的作用：实现I/O与CPU并行</li>\n<li>现代操作系统的两个基本特征是共享性和并发性</li>\n<li>作业由程序、数据、作业说明书组成</li>\n<li>文件按组织形式分类：普通、目录、特殊</li>\n<li>文件包括两部分：文件和文件说明</li>\n<li>CPU输出数据的速度远远高于打印机的打印速度，为了缓解这一矛盾，可采用??缓冲技术??</li>\n<li>OS为用户提供了两种接口：操作级接口（命令接口）：为用户提供各种命令；程序级接口（系统调用）：为用户程序一级提供有关服务</li>\n<li>资源有序分配法破坏了产生死锁的必要条件中的环路等待</li>\n<li>临界资源是一次只能为一个进程使用的资源；临界区是指访问临界资源的那段代码</li>\n<li>在单个CPU系统中，CPU和线程是并行操作的</li>\n<li>访问磁盘时间由三部分组成：寻道时间+延迟时间+传输时间</li>\n<li>在处理机调度中，内外存调度实际上是进程的挂起与激活</li>\n</ul>\n<h3 id=\"2-进程管理\"><a href=\"#2-进程管理\" class=\"headerlink\" title=\"2.进程管理\"></a>2.进程管理</h3><h4 id=\"七状态模型\"><a href=\"#七状态模型\" class=\"headerlink\" title=\"七状态模型\"></a>七状态模型</h4><ul>\n<li>进程=PCB+程序段+数据段（所有系统调用都操作 PCB）</li>\n<li>线程=TCB+堆栈+寄存器</li>\n<li>创建、就绪、运行、阻塞、终止、就绪挂起、阻塞挂起</li>\n<li>运行态到阻塞态：是一种特殊的、由用户态调用操作系统内核过程的形式（主动）</li>\n<li>阻塞态到就绪态：被动行为</li>\n<li>进程调度、进程切换、处理及模式切换P33</li>\n<li>进程作为CPU以外的sys资源分配的基本单位，线程作为处理机调度的基本单位，共享进程资源</li>\n<li>线程实现：用户级线程、内核级线程；多线程模型：多对一、一对一、多对多</li>\n<li>父进程创建子进程与主程序调用子程序（并行/串行）；多线程与多任务（针对进程/针对OS）</li>\n</ul>\n<h4 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"==进程通信==\"></a>==进程通信==</h4><ul>\n<li>共享存储：生-消模型、互斥访问共享存储区、“布袋”</li>\n<li>消息传递：以Message为基本单位，使用OS发送、接受原语，直接通信（邮差）、间接通信（邮箱）</li>\n<li>管道通信：半双工通信（单向）、固定大小、数据一次性、读空才写写满才读、pipe文件</li>\n</ul>\n<h4 id=\"软硬件实现临界互斥的方法\"><a href=\"#软硬件实现临界互斥的方法\" class=\"headerlink\" title=\"软硬件实现临界互斥的方法\"></a>软硬件实现临界互斥的方法</h4><ul>\n<li>单标志法：turn、违空闲让进</li>\n<li>双标志先检查：flag[2]、违忙则等待</li>\n<li>双标志后检查：flag[2]、违有限等待</li>\n<li>皮特森算法：1+3、违让权等待</li>\n<li>中断屏蔽、TSL（test and set）、swap</li>\n</ul>\n<h4 id=\"进程同步（阻塞-上锁）\"><a href=\"#进程同步（阻塞-上锁）\" class=\"headerlink\" title=\"进程同步（阻塞+上锁）\"></a>进程同步（阻塞+上锁）</h4><ul>\n<li>基础知识<br>同步：某个行为要用到某种资源在前面P一下；某个行为能产生某种资源在后面V一下（协调工作次序）<br>互斥：P、V操作夹紧使用互斥资源的行为，尽量保证最少的代码（互斥访问临界资源）<br>P、V：P在信号量有数时才减1，否则阻塞<br>临界资源：一次只允许一个进程访问的可共享的资源（不能修改的代码不属于临界资源）</li>\n<li>前驱关系：前V后P</li>\n<li>生产者-消费者：两对同步or一对同步，当有全局变量时如修改则要PV一下</li>\n<li>读者-写者：可多个进程同时访问，用count计数，第一个P一下，最后一个V一下，在访问count时要互斥访问，属于共享资源。（读写公平多用一组pv同步）</li>\n<li>哲学家进餐：需要同时取多个资源，为防止死锁，取前P全取完V</li>\n<li>吸烟者问题：一个生产者多个消费者，注意怎么唤醒、怎么阻塞</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">semaphore mutex &#x3D; 1;\nsemaphore empty &#x3D; n;\nsemaphore full &#x3D; 0;\nproduce ()&#123;\n    while (1)&#123;\n        produce an item in nextp;\n        P(empty);\n        P(mutex);\n        Add nextp to buffet;\n        V(mutex);\n        V(full);\n    &#125;\n&#125;\nconsumer ()&#123;\n    while (1)&#123;\n        P(full);\n        P(mutex);\n        remove an item from buffet;\n        V(mutex);\n        V(empty);\n        consume the item;\n    &#125;\n&#125;\n\nsemaphore plate &#x3D; 1,apple &#x3D; 0,orange &#x3D; 0;\nDad()&#123;\n    while (1)&#123;    \n        P(plate);\n        V(apple);\n    &#125;\n&#125;\nMom()&#123;\n    while (1)&#123;\n         P(plate);\n         V(orange);\n    &#125;\n&#125;\nSon()&#123;\n    while (1)&#123;\n        P(orange);\n        P(plate);\n    &#125;\n&#125;\nDaughter()&#123;\n    while (1)&#123;\n        P(apple);\n        P(plate);\n    &#125;\n&#125;\n\nint count &#x3D; 0;\nsemaphore mutex &#x3D; 1&#x2F;&#x2F;count互斥\nsemaphore rw &#x3D; 1&#x2F;&#x2F;读写互斥\nWriter()&#123;\n    while (1)&#123;\n        &#x2F;&#x2F;P(w);写进程优先 \n        P(rw);\n        Writing;\n        V(rw);\n        &#x2F;&#x2F;V(w);写进程优先\n    &#125;\n&#125;\nReader ()&#123;\n    while (1)&#123;\n        &#x2F;&#x2F;P(w);\n        P(mutex);\n        if(count &#x3D;&#x3D; 0)\n            P(rw);\n        count++;\n        V(mutex);\n        &#x2F;&#x2F;V(w);不加到最后，加到这就足够了\n        Reading;\n        P(mutex);\n        count—-;\n        if(count &#x3D;&#x3D; 0)\n            V(rw);\n        V(mutex);\n    &#125;\n&#125;\n\nsemaphore chopstick[5]&#x3D;&#123;1,1,1,1,1&#125;\nsemaphore mutex &#x3D; 1;\nPi()&#123;\n    do&#123;\n        P(mutex);&#x2F;&#x2F;互斥取筷子,一次取完两根\n        P(chopstick[i]);\n        P(chopstick[(i+1)%5];\n        V(mutex);\n        Eat;\n        V(chopstick[i]);\n        V(chopstick[(i+1)%5];\n        Think;\n    &#125;while(1);\n&#125;\n\nint random;\nsemaphore offer1 &#x3D; 0,offer2 &#x3D; 0,offer3 &#x3D; 0;\nsemaphore finish &#x3D; 0;&#x2F;&#x2F;表示抽烟是否完成，是一种前驱关系，同步关系，完成后才能放新的\nProcess p1()&#123;\n    while (1)&#123;\n        random&#x3D;任意一个整数随机数;\n        random&#x3D;random%3;\n        if(random &#x3D;&#x3D; 0)\n            V(offer1);\n        else if(random &#x3D;&#x3D; 1)\n            V(offer2);\n        else \n            V(offer3);\n        任意两种材料放在桌子上；\n        P(finish);\n    &#125;\n&#125;\nProcess pi()&#123;\n    while (1)&#123;\n        P(offeri);\n        取走；\n        V(finish);\n    &#125;\n&#125;\n\nint waiting &#x3D; 0,chairs &#x3D; n;\nsemaphore customers &#x3D; 0,barbers &#x3D; 0,mutex &#x3D; 1;\nbarber ()&#123;\n    while (1)&#123;\n        P(customers);\n        P(mutex);\n        waiting &#x3D; waiting - 1;\n        V(mutex);\n        V(barbers);\n        Cut_hair();\n&#125;\ncustomer ()&#123;\n    P(mutex);\n    if(waiting &lt; chairs)&#123;\n        waiting &#x3D; waiting + 1;\n        V(customers);\n        V(mutex);\n        P(barbers);\n        Get_haircut();\n    &#125;\n    else\n        V(mutex);\n&#125;</code></pre>\n\n<h4 id=\"进程调度\"><a href=\"#进程调度\" class=\"headerlink\" title=\"进程调度\"></a>进程调度</h4><ul>\n<li>高级调度（作业-&gt;进程）、中级调度（外存&lt;-&gt;内存）、低级调度（三态转化）</li>\n<li>不能调度（处理中断、临界区、屏蔽中断）；剥夺与非剥夺调度（早期批处理）【在进程处于临界区时，只要不破坏临界区资源使用规则就不影响处理机调度】</li>\n<li>评估：CPU利用率（忙碌时间/总时间）、系统吞吐量（完成作业数/总时间）、平均周转时间（提交到完成/n=（等待+执行）/n）、带权周转时间（作业周转时间/实际运行时间，越小越好必然大于1）、等待时间（等处理机状态）、响应时间（提交请求到首次响应）</li>\n<li>先来先服务（FCFS）：选最早</li>\n<li>短作业/进程优先（SJF/SPF）：选最短（平均等待时间、平均周转时间最少）</li>\n<li>优先级调度：选优先级最高（净：sys&gt;users、交互&gt;非交互、I/O&gt;CPU）</li>\n<li>高相应比优先（HRRN）：响应比最高<br>（等待时间+需服务时间）/需服务时间</li>\n<li>时间片轮转（RR）：分时OS、绝对可抢占</li>\n<li>多级反馈队列：1+3+5、“UNIX”、优先级高到低、时间片小到大（上无才执行下）</li>\n</ul>\n<h4 id=\"死锁（独占资源分配不当）\"><a href=\"#死锁（独占资源分配不当）\" class=\"headerlink\" title=\"==死锁（独占资源分配不当）==\"></a>==死锁（独占资源分配不当）==</h4><ul>\n<li>死锁定义：多个进程因竞争资源而造成的一种僵局（互相等待）若无外力作用，这些进程都将无法向前推进</li>\n<li>产生原因：竞争资源、进程推进非法</li>\n<li>预防死锁：破坏互斥（资源共享使用）、破坏不剥夺、破坏请求和保持（预先静态分配）、破坏循环等待（顺序资源分配）（必要条件）</li>\n<li>避免死锁：安全状态（不一定是死锁状态）、银行家算法（必须知道将来的资源请求）、安全性算法</li>\n<li>检测死锁：利用死锁定理化简资源分配图（圆圈代表进程，框代表一类资源，一个圆代表一个该类资源，进程到资源为请求边，资源到进程为分配边）把圈都变成孤点</li>\n<li>解除死锁：资源剥夺、撤销进程、进程回退</li>\n<li>死锁检测：银行家算法<ul>\n<li>Max、Allocation、Need</li>\n<li>Work、Need、Allocation、W+A（分配一个写一行，一行一行写）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-内存管理\"><a href=\"#3-内存管理\" class=\"headerlink\" title=\"3.内存管理\"></a>3.内存管理</h3><h4 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h4><ol>\n<li>程序的编译、链接和装入</li>\n</ol>\n<ul>\n<li>编译成若干0-n，链接成一个0-m，装入将逻辑地址转换为物理地址（地址重定位）</li>\n<li>静态链接、装入时动态链接、运行时动态链接</li>\n<li>绝对装入、可重定位装入、运行时动态装入（动态重定位、只装入一部分可以提供比内存大的地址空间）</li>\n</ul>\n<ol start=\"2\">\n<li>内存保护</li>\n</ol>\n<ul>\n<li>上下限寄存器</li>\n<li>重定位寄存器和界地址寄存器：逻辑&lt;界地址，物理=逻辑+重定位</li>\n</ul>\n<ol start=\"3\">\n<li>覆盖与交换</li>\n</ol>\n<ul>\n<li>覆盖：一个程序内，用虚拟内存替代</li>\n<li>交换：中级调度，现在还在用</li>\n</ul>\n<h4 id=\"内存分派方式\"><a href=\"#内存分派方式\" class=\"headerlink\" title=\"==内存分派方式==\"></a>==内存分派方式==</h4><ol>\n<li>连续分配方式</li>\n</ol>\n<ul>\n<li>单一连续分配：单用户单任务OS、有内无外</li>\n<li>固定分区分配：一个分区一到作业、分区说明表（始址+大小+状态）、有内无外</li>\n<li>动态分区分配：（紧凑）（有外无内）</li>\n<li>首次适应：(First Fit)地址递增，第一个能装进去的（最好、最快）</li>\n<li>最佳适应：(Best Fit)容量递增，有很多外部碎片！！！</li>\n<li>最坏适应：(Worst Fit)容量递减，很快无大连续快</li>\n<li>邻近适应：(Next Fit)又称循环首次适应，从上一次结束开始不从头找</li>\n</ul>\n<ol start=\"2\">\n<li>非连续分配方式</li>\n</ol>\n<ul>\n<li>存储密度低于连续分配方式，但少了很多页内碎片</li>\n<li>运行时是否把所有作业都装入内存（基本分页/请求分页）</li>\n<li>地址结构决定了虚拟内存的寻址空间有多大</li>\n</ul>\n<h4 id=\"基本分页存储管理方式（透明）（有内部碎片）\"><a href=\"#基本分页存储管理方式（透明）（有内部碎片）\" class=\"headerlink\" title=\"基本分页存储管理方式（透明）（有内部碎片）\"></a>基本分页存储管理方式（透明）（有内部碎片）</h4><ul>\n<li>进程（页）-&gt;内存（页框）-&gt;外存（块）</li>\n<li>页表（页号+物理块号）-&gt;页面-&gt;地址结构（页号+页内偏移量）</li>\n<li>地址变换机构+逻辑地址到物理地址转换过程（页表寄存器=页表始址+页表长度）</li>\n<li>快表（高速缓冲存储器，非内存）：少访问一次内存，有一次访问数据</li>\n<li>两级页表：减少了内存占用空间，只有一个顶级页表</li>\n</ul>\n<h4 id=\"基本分段存储管理方式（不透明）（有外部碎片）\"><a href=\"#基本分段存储管理方式（不透明）（有外部碎片）\" class=\"headerlink\" title=\"基本分段存储管理方式（不透明）（有外部碎片）\"></a>基本分段存储管理方式（不透明）（有外部碎片）</h4><ul>\n<li>段内连续，段间不连续，地址空间是二维的（段的始址+段内偏移量）</li>\n<li>段表项：段号+段长+本段在主存的始址</li>\n<li>段表内位置要查一次，找到段的位置，段内偏移量又要查一次，真正的物理地址（段表寄存器=段表始址+段表长度）</li>\n</ul>\n<h4 id=\"段页式管理方式\"><a href=\"#段页式管理方式\" class=\"headerlink\" title=\"段页式管理方式\"></a>段页式管理方式</h4><ul>\n<li>段号+页号+页内偏移量</li>\n<li>一个进程一个段表，一个分段一个页表</li>\n<li>段表项=段号+页表长度+页表始址；页表项=页号+块号；段表寄存器=段表长度+段表始址</li>\n<li>首先通过段表查到页表始址-&gt;通过页表查到页帧号-&gt;物理地址（段号查段表、页号查页表、最后加偏移量）</li>\n<li>二维的原因：与页式管理不同，段式管理不能通过给出一个整数便确定对应的物理地址，因为每段的长度是不固定的，无法通过整数除法得出段号，无法通过取余得出段内偏移，所以段号和段内偏移一定要显示给出，因此分段管理的地址空间是二维的。</li>\n</ul>\n<p>==页表项的大小有页表数量决定，2²⁰个页表需要20/8上取整，及3B，但一般都取4B（1B有8位）==</p>\n<p>==前面的操作是为了同时将多个进程保存在内存中，后面的操作是为了让一个进程的尽量少的一部分装入内存==</p>\n<h4 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h4><ul>\n<li>基于局部性原理（时间、空间）：容量小于等于内外存之和，也小于等于计算机地址位数能容纳的最大容量</li>\n<li>实现方式：请求分页、请求分段、请求段页式</li>\n<li>需支持：内存+外存、页表机制、中断机构、地址变换机构</li>\n<li>页表机制：页号、物理块号、状态位P、访问字段A（访问次数）、修改位M、外存地址</li>\n<li>中断机构：指令执行期间处理中断（内中断）、一条指令执行期间可产生多次缺页中断</li>\n<li>地址变换机构：检索快表、（未找到）去内存中找页表、（在内存）根据物理地址访问内存、（没在内存）缺页中断去外存找</li>\n<li>虚拟内存&lt;=内存容量和外存容量之和&amp;&amp;虚拟内存&lt;=计算机地址结构所能容纳的最大容量</li>\n</ul>\n<h4 id=\"页面置换\"><a href=\"#页面置换\" class=\"headerlink\" title=\"页面置换\"></a>页面置换</h4><ul>\n<li>OPT：向后找（无法实现）</li>\n<li>FIFO：队列实现（Belady异常【3210 3243 2104】、性能差）</li>\n<li>LRU：（最近最久未用）向前看（性能好、堆栈开销大）</li>\n<li>CLOCK：（NRU：Not Recently Used，最近未用）首次装入内存该帧使用位置为1；当要替换时扫描缓冲区，如果是1则改成0，如果是0则换出并指向下一帧。（当某一帧被替换时，指针被设置成指向缓冲区的下一帧）</li>\n<li>改进CLOCK：（使用位，修改位）扫描第一次：找（0，0）不做修改；扫描第二次：找（0，1）并且将（1，x）-&gt;（0，x），再次从头开始找（0，0）。首选没变化的页面00-&gt;01-&gt;10-&gt;11（换完后将指针后移）</li>\n<li>发生缺页的次数！=页面置换的次数</li>\n</ul>\n<h4 id=\"其它\"><a href=\"#其它\" class=\"headerlink\" title=\"其它\"></a>其它</h4><ul>\n<li>驻留集大小：（分配几个物理页框）固定分配局部置换（自给自足）、可变分配全局置换（要就给）、可变分配局部置换（非常想要才给，否则自给自足，多了还往回拿）</li>\n<li>何时、何处调入页面：预调页策略（一次调入若干相邻，首次调时用）、请求调页策略；文件区/对换区：对换区大则都在对换区换，对换区不大只在对换区换修改过的；UNIX：未运行过的在文件区，运行过的在对换区</li>\n<li>抖动：一个进程在换页上用的时间多于执行时间</li>\n<li>工作集：某段时间间隔内，进程要访问的页面集合（不重复），分配的物理块数要大于工作集的大小</li>\n<li>工作集模型：工作集内的页面调入驻留集，工作集外的页面调出驻留集，空闲块多则调入进程，空闲块少则暂停进程</li>\n</ul>\n<h3 id=\"4-文件管理\"><a href=\"#4-文件管理\" class=\"headerlink\" title=\"4.文件管理\"></a>4.文件管理</h3><h4 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h4><ul>\n<li>以磁盘为载体存储在计算机上的信息集合，文件=数据+FCB+访问权限</li>\n<li>系统运行时，资源分配和调度的基本单位：进程；用户输入、输出中，以文件为基本单位</li>\n<li>文件结构：数据项&lt;记录&lt;文件（记录式文件、流式文件）</li>\n<li>文件的唯一标签：标识符（名字有重名）</li>\n</ul>\n<h4 id=\"文件相关操作\"><a href=\"#文件相关操作\" class=\"headerlink\" title=\"文件相关操作\"></a>文件相关操作</h4><ul>\n<li>创建（找到空间+创建目录条目）、读、写、截断（删除内容不删除文件）、文件重定位（寻址）、删除（删文件）</li>\n<li>打开与关闭：打开文件表（省略搜索环节）、打开计数器（打开文件的进程数）、在open调用完成后，OS对该文件的任何操作都不再需要文件名，而只需要open调用返回的指针、close后：写回外存、释放内存、删除文件打开条目、释放FCB</li>\n</ul>\n<h4 id=\"文件逻辑结构（用户角度）\"><a href=\"#文件逻辑结构（用户角度）\" class=\"headerlink\" title=\"文件逻辑结构（用户角度）\"></a>文件逻辑结构（用户角度）</h4><ul>\n<li>无结构文件（流式文件）</li>\n<li>有结构文件（记录式文件）：顺序文件（串结构、顺序结构）、索引文件（索引表、记录变长记录文件）、索引顺序文件（每组第一条记录为索引项）、直接文件或散列文件</li>\n<li>有结构文件是为了方便查找</li>\n</ul>\n<h4 id=\"文件目录结构\"><a href=\"#文件目录结构\" class=\"headerlink\" title=\"文件目录结构\"></a>文件目录结构</h4><ul>\n<li>文件控制块（FCB），一个FCB就是一个文件目录项，FCB必须有序存放，FCB有序集合即为目录</li>\n<li>索引节点：=FCB-精简版目录项，存放在磁盘上，文件被打开时复制到内存中的索引节点</li>\n<li>目录结构：单级目录、两级目录（主文件目录（user1、user2…）+用户文件目录）、多级目录（树形目录、绝对路径、相对路径、分隔符/、当前工作目录.）、无环图目录（增加一些指向同一节点的有向边）</li>\n</ul>\n<h4 id=\"文件共享与保护（目录-gt-文件）\"><a href=\"#文件共享与保护（目录-gt-文件）\" class=\"headerlink\" title=\"文件共享与保护（目录-&gt;文件）\"></a>文件共享与保护（目录-&gt;文件）</h4><ul>\n<li>硬链接：设置指针指向索引节点的共享方式（链接计数count）原count+1，一个文件的count统一变化</li>\n<li>软连接：基于符号链实现文件共享（与共享文件同名的LINK型文件，只包含共享文件的路径名，类似于快捷方式，指针指向快捷方式）直接复制原count，删文件count不变</li>\n<li>文件保护：口令保护、加密保护、访问控制（访问控制表ACL：用户名+读+写+执行）<pre><code>A        B        C\n</code></pre>\nuser1 r        rw         w<br>user2 e         -           -</li>\n</ul>\n<h4 id=\"文件系统层次结构\"><a href=\"#文件系统层次结构\" class=\"headerlink\" title=\"文件系统层次结构\"></a>文件系统层次结构</h4><ul>\n<li>用户调用接口：根据系统调用，转入相应的模块</li>\n<li>文件目录结构：根据文件路径找到相应FCB或索引节点、目录项</li>\n<li>存取控制验证模块：权限比较，文件保护相关功能</li>\n<li>逻辑文件系统与文件信息缓冲区：把用户读写的逻辑记录转换成逻辑块号</li>\n<li>物理文件系统：将逻辑块号转成物理块号</li>\n<li>其它：辅助分配模块、设备管理模块</li>\n</ul>\n<h4 id=\"目录实现\"><a href=\"#目录实现\" class=\"headerlink\" title=\"目录实现\"></a>目录实现</h4><ul>\n<li>线形列表：线性查找，文件名+数据块指针，查找慢</li>\n<li>哈希表：散列查找，根据文件名得到hash值，hash表长固定且hash函数对表长有依赖</li>\n</ul>\n<h4 id=\"文件物理结构（文件实现）\"><a href=\"#文件物理结构（文件实现）\" class=\"headerlink\" title=\"文件物理结构（文件实现）\"></a>文件物理结构（文件实现）</h4><h4 id=\"文件分配方式（非空闲块）\"><a href=\"#文件分配方式（非空闲块）\" class=\"headerlink\" title=\"文件分配方式（非空闲块）\"></a>文件分配方式（非空闲块）</h4><ul>\n<li>连续：目录项（文件名+起始块号+长度）寻道数和寻道时间最小</li>\n<li>链接（串联）：文件分配表（显）（目录项：文件名+起始块号；FAT表：盘块号+下一盘块指针）、盘块内指针（隐）（文件名+起始块指针+结尾块指针）【注】FAT表启动时就会被读入内存，因此查找FAT表的过程是在内存中进行的。</li>\n<li>索引：（支持直接访问）当文件过大时有三种分配方式：链接（一个连一个）、多层（一个连n个）、混合索引（一级索引、二级索引…）</li>\n</ul>\n<h4 id=\"存储空间管理（空闲块）\"><a href=\"#存储空间管理（空闲块）\" class=\"headerlink\" title=\"存储空间管理（空闲块）\"></a>存储空间管理（空闲块）</h4><ul>\n<li>空闲表：类似于内存的动态分配，第一个空闲盘块号+空闲盘块数</li>\n<li>空闲链表：空闲盘块链/空闲盘区链</li>\n<li>位示图：0空闲、1已分配（找0，算物理地址，改1，插入数据）</li>\n<li>成组链接：见下</li>\n</ul>\n<h4 id=\"成组链接\"><a href=\"#成组链接\" class=\"headerlink\" title=\"成组链接\"></a>成组链接</h4><ul>\n<li>超级块（下一组空闲盘块数+若干空闲块号）复制到超级快，或从超级快拿走</li>\n<li>第一个空闲块指向下一组的类似超级块，其余指向空闲块，倒数第二个分组超级快的第一个空闲块数为-1</li>\n<li>从下往上分配块，从上往下归还块，最后一个块被占用不为空闲，可用块数=总块数-1</li>\n</ul>\n<h4 id=\"磁盘\"><a href=\"#磁盘\" class=\"headerlink\" title=\"磁盘\"></a>磁盘</h4><ul>\n<li>地址：柱面号·盘面号·扇区号（或块号）【根据柱面移动磁头找到磁道、根据盘面决定启动哪个磁头，根据扇区号旋转盘面找到数据块】</li>\n<li>磁道为同心圆，存储能力受限于最内道的最大记录密度</li>\n<li>一次磁盘读写操作的时间：寻道时间（移道时间*n+启动磁臂时间）+延迟时间（磁头定位到扇区的时间）+传输时间（从磁盘读出或向磁盘写入的时间）</li>\n<li>磁盘初始化：低级格式化（物理分区，分扇区）、逻辑格式化（创建文件系统）</li>\n<li>引导块：初始化程序（自举程序），在ROM中（只读存储器，只能读不能写）</li>\n<li>数据传输速率：数据传输量（KB）/所用时间（s）【注】表示存储容量、文件大小时K等于1024，表示传输速率时K等于1000，所以得*1024/1000进行转换</li>\n</ul>\n<h4 id=\"磁盘调度算法\"><a href=\"#磁盘调度算法\" class=\"headerlink\" title=\"磁盘调度算法\"></a>磁盘调度算法</h4><ul>\n<li>FCFS：根据进程请求访问磁盘的先后顺序，公平</li>\n<li>SSTF：找离当前最接近的（饥饿）</li>\n<li>SCAN（LOOK）：（又称电梯调度算法）两侧都扫描，走到头往回走，到头or不到头</li>\n<li>C-SCAN（C-LOOK）：只能单侧，访问到头快速返回至始端，解决两端不平衡的问题<br>【注】look不走到头，scan走到头；带C只能一个方向扫描，不带C扫描完回头反向扫描</li>\n</ul>\n<h3 id=\"5-输入输出管理（I-O）\"><a href=\"#5-输入输出管理（I-O）\" class=\"headerlink\" title=\"5.输入输出管理（I/O）\"></a>5.输入输出管理（I/O）</h3><h4 id=\"I-O控制方式（外设与内存间传输方式）（城中D道）\"><a href=\"#I-O控制方式（外设与内存间传输方式）（城中D道）\" class=\"headerlink\" title=\"I/O控制方式（外设与内存间传输方式）（城中D道）\"></a>I/O控制方式（外设与内存间传输方式）（城中D道）</h4><ul>\n<li>程序直接控制：对读入的每个字进行循环检查，CPU与I/O串行，CPU利用率极低</li>\n<li>中断驱动方式：读一个字中断一次，I/O操作开始前和完成后需要CPU</li>\n<li>DMA方式（直接存储器存储）：（读一个数据块中断一次）在I/O设备和内存之间开辟直接的数据通路，传连续的数据块到内存，全传完才需CPU干预（命令寄存器、内存地址寄存器、数据寄存器、数据计数器）</li>\n<li>通道方式：弱鸡版的CPU（硬件），第一组数据块中断一次，通过执行CPU发来的通道程序（内存中的任务清单）完成对应I/O任务</li>\n<li>助记：每隔一段时间看看衣服好没；完成一件衣服打电话告知；雇一位秘书，交代好一切，每做100件报告一次；秘书决定衣服放在哪，什么时候报告。（一个DMA秘书只能负责一位裁缝，一个通道秘书可与多个裁缝沟通）</li>\n</ul>\n<h4 id=\"I-O子系统层次结构\"><a href=\"#I-O子系统层次结构\" class=\"headerlink\" title=\"I/O子系统层次结构\"></a>I/O子系统层次结构</h4><ul>\n<li>用户层I/O软件：必须通过一组系统调用来获取操作系统服务（各种库函数）</li>\n<li>设备独立性软件：（又称系统调用处理层、设备无关性）为了实现设备独立性引入：逻辑设备&amp;物理设备、设备独立性软件。功能：执行所有设备的公有操作（维护逻辑设备表：将逻辑设备名映射为物理设备名），向用户层提供统一的接口（例如：read、write命令）</li>\n<li>设备驱动程序：一类设备一个驱动程序</li>\n<li>中断处理程序：用于保存中断进程的CPU环境，转入相应中断进程（放在底层的原因：由于中断处理与硬件紧密相关，对用户而言应尽量屏蔽，因此放在OS的底层，其它部分尽可能少的与之联系）</li>\n<li>硬件：I/O设备=机械部件+电子部件（适配器）</li>\n</ul>\n<h4 id=\"设备控制器\"><a href=\"#设备控制器\" class=\"headerlink\" title=\"设备控制器\"></a>设备控制器</h4><ul>\n<li>接受和识别CPU或通道发来的命令（控制寄存器）</li>\n<li>实现数据交换（数据寄存器）</li>\n<li>发现和记录设备及自身的状态信息（状态寄存器）</li>\n<li>设备地址识别（为了区分各个寄存器）</li>\n</ul>\n<h4 id=\"I-O子系统概述\"><a href=\"#I-O子系统概述\" class=\"headerlink\" title=\"I/O子系统概述\"></a>I/O子系统概述</h4><ul>\n<li>I/O调度：确定一个好的顺序来使进程之间公平的共享设备访问，减少I/O完成所需要的平均等待时间（磁盘调度算法）</li>\n<li>高速缓冲与缓冲区：逻辑上属于磁盘，物理上则是驻留在内存中的盘块。缓冲区非空不能冲入数据，缓冲区充满才能读。</li>\n</ul>\n<h4 id=\"缓冲区\"><a href=\"#缓冲区\" class=\"headerlink\" title=\"缓冲区\"></a>缓冲区</h4><p>技巧：假设一种初始状态，然后计算下一次到达相同状态的所需时间，就是处理一块数据所需时间</p>\n<ul>\n<li>单缓冲：工作区满、缓冲区是空的</li>\n<li>双缓冲：工作区空、一个缓冲区满、另一个缓冲区是空的</li>\n<li>循环缓冲：类似于循环队列</li>\n<li>缓冲池：输入缓冲队列、输出缓冲队列、收容输入、提取输入、收容输出、提取输出</li>\n<li>设备分配与回收：设备控制表（一个设备及其属性）、控制器控制表（控制器：解析上层命令，与设备控制表一一对应）、通道控制表（一个通道管多个控制器，为了与内存交换数据）、系统设备表（一个系统一张，标示所有物理设备）</li>\n<li>设备分配策略：静态（一次性）、动态（系统调用向系统提出请求）、安全分配方式（发出I/O请求就进入阻塞态）、不安全分配方式</li>\n</ul>\n<h4 id=\"SPOOLing技术\"><a href=\"#SPOOLing技术\" class=\"headerlink\" title=\"SPOOLing技术\"></a>SPOOLing技术</h4><ul>\n<li>用输入输出进程模拟外围控制机，来进行输入输出操作</li>\n<li>输入输出井在磁盘中、输入输出缓冲区在内存中<br>-输入输出先放到磁盘输入输出井中，待I/O设备空闲再输入输出</li>\n</ul>\n<h3 id=\"6-Bash\"><a href=\"#6-Bash\" class=\"headerlink\" title=\"6.Bash\"></a>6.Bash</h3><h4 id=\"1-理论\"><a href=\"#1-理论\" class=\"headerlink\" title=\"1.理论\"></a>1.理论</h4><ol>\n<li><p>系统启动过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220824135151534.png\" alt=\"image-20220824135151534\"></p>\n<ul>\n<li>计算机打开电源后，首先是BIOS开机自检，通常由硬盘启动，操作系统接管硬件后，读入/boot目录下的内核文件。运行init进程，是所有进程的祖先进程，init程序会读取配置文件etc/inittab，然后运行守护进程（daemon，开机启动程序）。启动哪些程序主要依赖运行级别（runlevel）的不同，一共有七个运行级别（停机状态默认为0、单用户工作状态为1、正常关闭并重启为6）</li>\n<li>在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本</li>\n<li>rc执行完毕后，返回init，此时基本系统环境已经设置好了，各种守护进程也启动了。init接下来会打开6个终端，以便用户登录系统。相应程序会显示一个文本登陆界面，就是经常能看到的登陆界面，输入用户名和密码后，就通过login程序验证身份</li>\n</ul>\n</li>\n<li><p>系统关机</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ sync #将数据同步到硬盘中\n$ shutdown #关机指令，可以通过man shutdown查询帮助文档\n$ shutdown -h now #立刻关机\n$ reboot #重启，等同于 shutdown -r now\n$ halt #关闭系统 等同于shutdown -h now 和 poweroff</code></pre></li>\n<li><p>系统目录结构</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220824141054765.png\" alt=\"image-20220824141054765\"></p>\n<ul>\n<li><p><strong>/bin</strong>：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>\n</li>\n<li><p><strong>/boot：</strong>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>\n</li>\n<li><p><strong>/dev ：</strong>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>\n</li>\n<li><p><strong>/etc：</strong>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>\n</li>\n<li><p><strong>/home</strong>：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>\n</li>\n<li><p><strong>/lib</strong>：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>\n</li>\n<li><p><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>\n</li>\n<li><p><strong>/media</strong>：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>\n</li>\n<li><p><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>\n</li>\n<li><p><strong>/opt</strong>：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>\n</li>\n<li><p><strong>/proc</strong>：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all</code></pre></li>\n<li><p><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</p>\n</li>\n<li><p><strong>/sbin</strong>：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>\n</li>\n<li><p><strong>/selinux</strong>：这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>\n</li>\n<li><p><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</p>\n</li>\n<li><p><strong>/sys</strong>：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>\n</li>\n<li><p><strong>/tmp</strong>：tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>\n</li>\n<li><p><strong>/usr</strong>：usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>\n</li>\n<li><p><strong>/usr/bin：</strong>系统用户使用的应用程序。</p>\n</li>\n<li><p><strong>/usr/sbin：</strong>超级用户使用的比较高级的管理程序和系统守护程序。</p>\n</li>\n<li><p><strong>/usr/src：</strong>内核源代码默认的放置目录。</p>\n</li>\n<li><p><strong>/var</strong>：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>\n</li>\n<li><p><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-基础\"><a href=\"#2-基础\" class=\"headerlink\" title=\"2.基础\"></a>2.基础</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>快捷键：Tab：补全命令或文件名;Ctrl+C：中断正在运行的程序;Ctrl+D：结束键盘输入。通过man 命令来查看各个命令的使用文档。网络管理、软件包安装、进程管理、磁盘管理、内存管理</p></blockquote>\n<p><a href=\"https://camo.githubusercontent.com/28c5c5f1ab12883e605d3ec0dc6e2c765f94aa371b56c533e59ca322089c9a3e/68747470733a2f2f6d6163726f2d2d2d6f7373322e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f38383535626236343564386563633335633830616138396364653564313665352e6a7067\"><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/68747470733a2f2f6d6163726f2d2d2d6f7373322e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f696d672f38383535626236343564386563633335633830616138396364653564313665352e6a7067.jpeg\" alt=\"img\"></a></p>\n<h5 id=\"1-text-manipulation-tools\"><a href=\"#1-text-manipulation-tools\" class=\"headerlink\" title=\"1.text manipulation tools\"></a>1.text manipulation tools</h5><ol>\n<li><p>文件管理：</p>\n<ul>\n<li><p>ls（list files）：列出目录及文件名</p>\n<ul>\n<li>-a：列出所有文件，包括以.开头的隐藏文件</li>\n<li>-l：长数据串列出，包含文件的属性与权限等数据</li>\n<li>-t：按照时间顺序显示</li>\n</ul>\n</li>\n<li><p>cd（change directory）：切换目录，添加相对路径或绝对路径</p>\n<ul>\n<li><code>cd ~</code>：返回自己的家目录</li>\n<li><code>cd ..</code>：返回上一级目录</li>\n</ul>\n</li>\n<li><p>pwd（print work directory）：显示当前目录，加上<code>-P</code>可以显示出确实的路径，而非链接（link）路径</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#因为sbin -&gt; usr&#x2F;sbin，是一个链接\nparallels@ubuntu-linux-20-04-desktop:&#x2F;sbin$ pwd\n&#x2F;sbin\nparallels@ubuntu-linux-20-04-desktop:&#x2F;sbin$ pwd -P\n&#x2F;usr&#x2F;sbin</code></pre></li>\n<li><p>mkdir（make directory）：创建一个新目录</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mkdir [-mp] 目录名称\n# -m ：配置文件的权限,直接配置，不需要看默认权限 (umask) 的脸色\nmkdir -p test1&#x2F;test2&#x2F;test3&#x2F;test4 #自行创建多层目录\n# -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\nmkdir -m 711 test2 #创建权限为 rwx--x--x 的目录</code></pre></li>\n<li><p>rmdir（remove dictionary）：删除一个空目录</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">rmdir [-p] 目录名称\n#-p ：从该目录起，一次删除多级空目录</code></pre></li>\n<li><p>cp（copy file）：复制文件或目录</p>\n<ul>\n<li><p>语法</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">cp [-adfilprsu] 来源档(source) 目标档(destination)\ncp [options] source1 source2 source3 .... directory</code></pre></li>\n<li><p>参数</p>\n<ul>\n<li><strong>-a：</strong>相当于 -pdr 的意思，参考下列说明；(常用)<ul>\n<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>\n<li><strong>-d：</strong>若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；</li>\n<li><strong>-r：</strong>递归持续复制，用于目录的复制行为；(常用)</li>\n</ul>\n</li>\n<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>\n</ul>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc\ncp ~&#x2F;.bashrc &#x2F;tmp&#x2F;bashrc </code></pre></li>\n</ul>\n</li>\n<li><p>rm（remove file）：删除文件或目录</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">rm [-fir] 文件或目录\n#f为忽略不存在的文件，不出现警告信息；i为互动模式，删除前询问；r为递归删除，常用在目录的删除</code></pre></li>\n<li><p>mv（move file）：移动文件与目录，或修改文件与目录的名称</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">mv [-fiu] source destination\n#f为不询问覆盖、i为询问覆盖、u为update，目标文件已经存在时切source比较新，才会升级\nmv [options] source1 source2 source3 .... directory\nmv bashrc mvtest #将bashrc文件移到mvtest目录下\nmv mvtest mvtest2 #将mvtest目录名称改为mvtest2</code></pre></li>\n<li><p>touch(建立新文件)</p>\n</li>\n<li><p>通配符</p>\n<ul>\n<li><code>*</code>：匹配任何字符串</li>\n<li><code>?</code>：匹配1个字符串</li>\n<li><code>[xyz]</code>：匹配xyz任意一个字符</li>\n<li><code>[a-z]</code>：匹配一个范围</li>\n<li><code>[!xyz]或[^xyz]</code>：不匹配</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文件属性</p>\n<ol>\n<li><p>权限管理</p>\n<ol>\n<li><p>查看文件属性：使用<code>ll</code>或<code>ls -l</code>命令</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220824143955191.png\" alt=\"image-20220824143955191\"></p>\n</li>\n<li><p>chown：修改所属用户与组（change own）</p>\n<ul>\n<li><p>语法</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">chown [-R] 属主名 文件名\nchown [-R] 属主名: 属组名 文件名</code></pre></li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ chown bin install.log #将install.log的拥有者改为bin这个账号\n$ chown root:root install.log #将install.log的拥有者与群组改回为root</code></pre></li>\n</ul>\n</li>\n<li><p>chmod：修改权限常用常用命令（change mode）</p>\n<ul>\n<li><p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>\n</li>\n<li><p>目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># -R进行递归的持续变更（连同文件夹下的文件），xyz即权限数字的加和，r：4、w：2、x：1\n$ chmod [-R] xyz 文件或目录\n$ chmod 777 .bashrc #将.bashrc这个文件的所有权限都设定启用\n$ chmod a-x test1 #拿掉全部人的可执行权限</code></pre></li>\n</ul>\n</li>\n</ol>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220824142550815.png\" alt=\"image-20220824142550815\" style=\"zoom:25%;\" /></li>\n<li><p>用户管理</p>\n<ol>\n<li>常用命令<ul>\n<li>useradd：创建用户</li>\n<li>userdel：删除用户</li>\n<li>passwd：修改用户密码</li>\n<li>usermod：修改用户属性</li>\n<li>chage：修改用户属性</li>\n<li>groupadd：新建用户组</li>\n<li>groupdel：删除用户组</li>\n</ul>\n</li>\n<li>用户切换<ul>\n<li>su：切换用户</li>\n<li>sudo：以其他用户身份执行命令</li>\n</ul>\n</li>\n<li>用户配置文件<ul>\n<li>/etc/passwd：用户配置文件</li>\n<li>/etc/shadow：用户密码相关配置文件</li>\n<li>/etc/group：用户组配置文件</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>文档编辑：</p>\n<ul>\n<li><p>cat 由第一行开始显示文件内容，可选参数如下</p>\n<ul>\n<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；<ul>\n<li>-v ：列出一些看不出来的特殊字符</li>\n<li>-E ：将结尾的断行字节 $ 显示出来；</li>\n<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>\n</ul>\n</li>\n<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>\n<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>\n</ul>\n</li>\n<li><p>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</p>\n</li>\n<li><p>nl  显示的时候，顺道输出行号！</p>\n<ul>\n<li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>\n<li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>\n<li>-w ：行号栏位的占用的位数。</li>\n</ul>\n</li>\n<li><p>more 一页一页的显示文件内容，在 more 这个程序的运行过程中，有以下几个按键可以按</p>\n<ul>\n<li>空白键 (space)：代表向下翻一页；</li>\n<li>Enter     ：代表向下翻『一行』；</li>\n<li>/字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>\n<li>:f      ：立刻显示出档名以及目前显示的行数；</li>\n<li>q       ：代表立刻离开 more ，不再显示该文件内容。</li>\n<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>\n</ul>\n</li>\n<li><p>less 与 more 类似，但是比 more 更好的是，他可以往前翻页，less运行时可以输入的命令有：</p>\n<ul>\n<li>空白键  ：向下翻动一页；</li>\n<li>[pagedown]：向下翻动一页；</li>\n<li>[pageup] ：向上翻动一页；</li>\n<li>/字串   ：向下搜寻『字串』的功能；</li>\n<li>?字串   ：向上搜寻『字串』的功能；</li>\n<li>n     ：重复前一个搜寻 (与 / 或 ? 有关！)</li>\n<li>N     ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li>\n<li>q     ：离开 less 这个程序；</li>\n</ul>\n</li>\n<li><p>head 只看头几行</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">head [-n number] 文件 # n后面接数字，代表显示几行的意思</code></pre></li>\n<li><p>tail 只看尾巴几行，默认显示最后10行</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tail [-n number] 文件 # n后面接数字，代表显示几行的意思</code></pre></li>\n<li><p>wc：统计文件的字节数、单词数、行数</p>\n</li>\n</ul>\n</li>\n<li><p>Linux文本三剑客</p>\n<ol>\n<li>grep：文本搜索工具</li>\n<li>awk：文本和数据进行处理的编程语言，可以让用户自定义函数或正则表达式对文本进行高效管理</li>\n<li>sed：批量编辑文本文件</li>\n</ol>\n</li>\n<li><p>其他</p>\n<ul>\n<li><p>压缩与打包：</p>\n<ul>\n<li><p>最早Linux备份介质是磁带，使用命令tar；可以将打包后的磁带文件进行压缩存储，压缩命令是gzip和bzip2。所以经常出现的扩展名是<code>.tar.gz</code>、<code>.tar.bz2</code>、<code>.tgz</code></p>\n</li>\n<li><p>打包：tar</p>\n<ul>\n<li>c：打包</li>\n<li>x：解包</li>\n<li>f：指定操作类型为文件</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tar cf &#x2F;tmp&#x2F;etc-backup.tar &#x2F;etc #打包etc中的文件</code></pre></li>\n<li><p>压缩和解压缩</p>\n<ul>\n<li><p>单独使用gzip、bzip2命令</p>\n</li>\n<li><p>通过tar命令压缩</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tar czf &#x2F;tmp&#x2F;etc-backup.tar.gz &#x2F;etc #打包并通过gzip压缩etc中的文件\ntar cjf &#x2F;tmp&#x2F;etc-backup.tar.bz2 &#x2F;etc #打包并通过bzip2压缩etc中的文件，压缩比例高</code></pre></li>\n<li><p>解压缩</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">tar xf &#x2F;tmp&#x2F;etc-backup.tar -C &#x2F;root \ntar zxf &#x2F;tmp&#x2F;etc-backup.tar.gz -C &#x2F;root #.tar.gz可缩写为tgz\ntar jxf &#x2F;tmp&#x2F;etc-backup.tar.bz2 -C &#x2F;root #.tar.bz2可缩写为tbz2</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>sort：对文件内容进行排序</p>\n</li>\n<li><p>uniq：去除文件中的重复内容行</p>\n</li>\n<li><p>cut：按列提取文件内容</p>\n</li>\n<li><p>fmt：编排文本文件</p>\n</li>\n<li><p>tr：字符转换指令，用来删除一行中的字符，或者对字符进行替换。</p>\n</li>\n<li><p>od：以字符或者十六进制的形式显示二进制文件</p>\n</li>\n<li><p>find：文件搜索，可以使用文件的属性和权限进行搜索。</p>\n</li>\n<li><p>echo：用于在终端设备上输出指定字符串或变量提取后值的命令，能够给用户一些简单的提醒信息</p>\n</li>\n<li><p>ls链接：</p>\n<ol>\n<li><p>实体链接：在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>\n</li>\n<li><p>符号链接：符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>\n<p>当源文件被删除了，链接文件就打不开了。</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">## ln [-sf] source_filename dist_filename\n-s ：默认是实体链接，加 -s 为符号链接\n-f ：如果目标文件存在时，先删除目标文件</code></pre></li>\n<li><p>管道命令：管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。在命令之间使用 | 分隔各个管道命令。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ls -al &#x2F;etc | less</code></pre></li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"2-process-monitoring\"><a href=\"#2-process-monitoring\" class=\"headerlink\" title=\"2.process monitoring\"></a>2.process monitoring</h5><ol>\n<li><p>进程状态</p>\n<table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>R</td>\n<td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中。</td>\n</tr>\n<tr>\n<td>D</td>\n<td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞。</td>\n</tr>\n<tr>\n<td>S</td>\n<td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成。</td>\n</tr>\n<tr>\n<td>Z</td>\n<td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息。</td>\n</tr>\n<tr>\n<td>T</td>\n<td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪。</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>进程查看</p>\n<ul>\n<li><p>ps：查看某个时间点的进程信息，示例如下：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">##查看自己的进程\nps -l\n##查看系统所有进程\nps aux\n##查看特定的进程\nps aux | grep threadx</code></pre></li>\n<li><p>pstree：查看进程树。</p>\n</li>\n<li><p>top：实时显示进程信息。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">##两秒钟刷新一次\ntop -d 2</code></pre></li>\n</ul>\n</li>\n<li><p>进程控制</p>\n<ul>\n<li>nice</li>\n<li></li>\n</ul>\n</li>\n<li><p>lsof：查看文件的进程信息</p>\n</li>\n<li><p>iostat：监视系统输入输出设备和CPU的使用情况</p>\n</li>\n<li><p>sar：系统运行状态统计</p>\n</li>\n<li><p>vmstat：显示虚拟内存状态</p>\n</li>\n<li><p>strace：跟踪系统调用</p>\n</li>\n<li><p>systemtap</p>\n</li>\n<li><p>df（disk free）：列出文件系统的整体磁盘使用量</p>\n<ul>\n<li><p>语法</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ df [-ahikHTm] [目录或文件名]</code></pre></li>\n<li><p>选项</p>\n<ul>\n<li>-a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；</li>\n<li>-k ：以 KBytes 的容量显示各文件系统；</li>\n<li>-m ：以 MBytes 的容量显示各文件系统；</li>\n<li>-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；</li>\n<li>-H ：以 M=1000K 取代 M=1024K 的进位方式；</li>\n<li>-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；</li>\n<li>-i ：不用硬盘容量，而以 inode 的数量来显示</li>\n</ul>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">parallels@ubuntu-linux-20-04-desktop:~$ df -h\nFilesystem      Size  Used Avail Use% Mounted on\nudev            1.9G     0  1.9G   0% &#x2F;dev\ntmpfs           392M  1.4M  391M   1% &#x2F;run\n&#x2F;dev&#x2F;sda2        63G  7.3G   52G  13% &#x2F;\n#...省略若干行...</code></pre></li>\n</ul>\n</li>\n<li><p>kill：杀死进程</p>\n</li>\n</ol>\n<h5 id=\"3-network\"><a href=\"#3-network\" class=\"headerlink\" title=\"3.network\"></a>3.network</h5><ol>\n<li><p>nmap：网络探测和安全审核工具</p>\n</li>\n<li><p>tcpdump：监听网络流量</p>\n</li>\n<li><p>ping：测试主机间网络联通性</p>\n</li>\n<li><p>mtr：网络诊断</p>\n</li>\n<li><p>traceroute：追踪数据包在网络上传输时的全部路径</p>\n</li>\n<li><p>dig：查询域名DNS信息</p>\n</li>\n<li><p>iptables：防火墙策略管理工具</p>\n</li>\n<li><p>netstat：查看占用端口的进程</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">##查看特定端口的进程\nnetstat -anp | grep port</code></pre></li>\n<li><p>curl：文件传输工具</p>\n</li>\n<li><p>wget：下载网络文件</p>\n</li>\n<li><p>ssh：安全的远程连接服务器</p>\n</li>\n</ol>\n<h4 id=\"3-进阶\"><a href=\"#3-进阶\" class=\"headerlink\" title=\"3.进阶\"></a>3.进阶</h4><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/9ee6c1c5d88b0468af1a3280865a6b7a.webp\" alt=\"9ee6c1c5d88b0468af1a3280865a6b7a\"></p>\n<h5 id=\"1-Bash-scripting\"><a href=\"#1-Bash-scripting\" class=\"headerlink\" title=\"1.Bash scripting\"></a>1.Bash scripting</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>shell的一种，通过shell可以请求内核提供服务</p></blockquote>\n<ol>\n<li><p>变量操作</p>\n<ol>\n<li><p>对一个变量赋值直接使用 =。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ x&#x3D;abc</code></pre></li>\n<li><p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>\n</li>\n<li><p>输出变量使用 echo 命令。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ echo $x\n$ echo $&#123;x&#125;</code></pre></li>\n<li><p>变量内容如果有空格，必须使用双引号或者单引号。</p>\n<ul>\n<li>双引号内的特殊字符可以保留原本特性，例如 x=”lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8；</li>\n<li>单引号内的特殊字符就是特殊字符本身，例如 x=’lang is $LANG’，则 x 的值为 lang is $LANG。</li>\n</ul>\n</li>\n<li><p>变量的声明：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ declare [-aixr] variable\n-a ： 定义为数组类型\n-i ： 定义为整数类型\n-x ： 定义为环境变量\n-r ： 定义为 readonly 类型\n$ array[1]&#x3D;a\n$ array[2]&#x3D;b\n$ echo $&#123;array[1]&#125;</code></pre></li>\n<li><p>数据流重定向（使用文件代替标准输入、标准输出和标准错误输出）</p>\n<ol>\n<li>有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</li>\n<li>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</li>\n<li>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>代码</th>\n<th>运算符</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标准输入 (stdin)</td>\n<td>0</td>\n<td>&lt; 或 &lt;&lt;</td>\n</tr>\n<tr>\n<td>标准输出 (stdout)</td>\n<td>1</td>\n<td>&gt; 或 &gt;&gt;</td>\n</tr>\n<tr>\n<td>标准错误输出 (stderr)</td>\n<td>2</td>\n<td>2&gt; 或 2&gt;&gt;</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-vim\"><a href=\"#2-vim\" class=\"headerlink\" title=\"2.vim\"></a>2.vim</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>从vi发展来的一个文本编辑器，具有代码补全、编译、错误跳转等方便编程的功能</p></blockquote>\n<ol>\n<li><p>VIM三个模式：</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220824161953910.png\" alt=\"image-20220824161953910\" style=\"zoom: 33%;\" />\n\n<ol>\n<li><p>命令模式（Command mode）：Vim的默认模式，可以用于移动游标查看内容，～代表没有任何东西</p>\n</li>\n<li><p>编辑模式（Insert mode）：命令模式下按下 “i” 按键之后进入，可以对文本进行编辑，ESC键可返回命令模式</p>\n</li>\n<li><p>底线命令模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作，命令以回车结束运行</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>:w</td>\n<td>写入磁盘</td>\n</tr>\n<tr>\n<td>:w!</td>\n<td>当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>\n</tr>\n<tr>\n<td>:q</td>\n<td>离开</td>\n</tr>\n<tr>\n<td>:q!</td>\n<td>强制离开不保存</td>\n</tr>\n<tr>\n<td>:wq</td>\n<td>写入磁盘后离开</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n<li><p>vi/vim按键说明</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220824161147278.png\" alt=\"image-20220824161147278\"></p>\n<p>1. </p>\n</li>\n<li></li>\n</ol>\n<h5 id=\"3-compiling-apps\"><a href=\"#3-compiling-apps\" class=\"headerlink\" title=\"3.compiling apps\"></a>3.compiling apps</h5><h2 id=\"POSIX\"><a href=\"#POSIX\" class=\"headerlink\" title=\"POSIX\"></a>POSIX</h2><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/ffb6847b94cb0fd086095ac263ac4ff0.jpg\" alt=\"img\"></p>\n<h3 id=\"1-网络通信\"><a href=\"#1-网络通信\" class=\"headerlink\" title=\"1.网络通信\"></a>1.网络通信</h3><h3 id=\"2-进程间通信\"><a href=\"#2-进程间通信\" class=\"headerlink\" title=\"2.进程间通信\"></a>2.进程间通信</h3><h3 id=\"3-进程管理\"><a href=\"#3-进程管理\" class=\"headerlink\" title=\"3.进程管理\"></a>3.进程管理</h3><h3 id=\"4-内存管理\"><a href=\"#4-内存管理\" class=\"headerlink\" title=\"4.内存管理\"></a>4.内存管理</h3><h3 id=\"5-文件管理\"><a href=\"#5-文件管理\" class=\"headerlink\" title=\"5.文件管理\"></a>5.文件管理</h3><h2 id=\"Linux-Internal\"><a href=\"#Linux-Internal\" class=\"headerlink\" title=\"Linux Internal\"></a>Linux Internal</h2><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bcf70b988e59522de732bc1b01b45a5b.jpeg\" alt=\"img\"></p>\n<h3 id=\"1-Linux操作系统综述\"><a href=\"#1-Linux操作系统综述\" class=\"headerlink\" title=\"1.Linux操作系统综述\"></a>1.Linux操作系统综述</h3><h4 id=\"1-外包公司的类比\"><a href=\"#1-外包公司的类比\" class=\"headerlink\" title=\"1.外包公司的类比\"></a>1.外包公司的类比</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。将自己的角色切换成这家软件外包公司的老板，设身处地地去理解操作系统是如何协调各种资源，帮客户做成事情的。</p></blockquote>\n<ol>\n<li>公司发展的几个阶段<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/80a4502300dfa51c8520001c013cee5d.jpeg\" alt=\"img\"><ol>\n<li>初创期：这个老板基于开放的营商环境（x86 体系结构），创办一家外包公司（系统的启动）。因为一开始没有其他员工，老板需要亲自接项目（实模式）。</li>\n<li>发展期：公司慢慢做大，项目越接越多（保护模式、多进程），为了管理各个外包项目，建立了项目管理体系（进程管理）、会议室管理体系（内存管理）、文档资料管理系统（文件系统）、售前售后体系（输入输出设备管理）。</li>\n<li>壮大期：公司越来越牛，开始促进内部项目的合作（进程间通信）和外部公司合作（网络通信）。</li>\n<li>集团化：公司的业务越来越多，会成立多家子公司（虚拟化），或者鼓励内部创业（容器化），这个时候公司就变成了集团。大管家的调度能力不再局限于一家公司，而是集团公司（Linux 集群），从而成功上市（从单机操作系统到数据中心操作系统）。</li>\n</ol>\n</li>\n<li>外包公司职能部门与Linux内核系统对应关系：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/e15954f1371a4c782f028202dce1f84a.jpeg\" alt=\"img\"></li>\n<li>操作系统内核体系结构图<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/e15954f1371a4c782f028202dce1f84a-16552136580378.jpeg\" alt=\"img\"></li>\n</ol>\n<h4 id=\"2-Linux常用命令\"><a href=\"#2-Linux常用命令\" class=\"headerlink\" title=\"2.Linux常用命令\"></a>2.Linux常用命令</h4><h4 id=\"3-Linux常见系统调用\"><a href=\"#3-Linux常见系统调用\" class=\"headerlink\" title=\"3.Linux常见系统调用\"></a>3.Linux常见系统调用</h4><p>==站在系统调用的角度，层层深入下去，就能从某个系统调用的场景出发，了解内核中各个模块的实现机制。==</p>\n<h3 id=\"2-系统初始化\"><a href=\"#2-系统初始化\" class=\"headerlink\" title=\"2.系统初始化\"></a>2.系统初始化</h3><h4 id=\"1-X86架构\"><a href=\"#1-X86架构\" class=\"headerlink\" title=\"1.X86架构\"></a>1.X86架构<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/e2e92f2239fe9b4c024d300046536d76.jpeg\" alt=\"img\"></h4><ol>\n<li><strong>通用寄存器：</strong>AX、BX、CX、DX、SP、BP、SI、DI，其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL，其中 H 就是 High（高位），L 就是 Low（低位）</li>\n<li><strong>IP寄存器：</strong>指令指针寄存器，指向代码段中吓一跳指令的位置</li>\n<li><strong>段寄存器：</strong>CS（代码段寄存器）、DS（数据段寄存器）、SS（栈寄存器）、ES</li>\n<li><strong>实模式（Real Pattern）：</strong>通过CS、DS找到内存中的代码和数据，起始地址 *16+ 偏移量，段寄存器存放起始地址（16位的），通用寄存器和IP寄存器存放的是偏移量（16位的）</li>\n<li><strong>保护模式（Protected Pattern）：</strong>在32位中，段寄存器不在存起始地址，段的起始地址放在内存的某个地方，这个地方是一个表格，表格中一项一项是段描述符（Segment Descriptor），这里面才是真正的段的起始地址，而段寄存器里面保存的是这个表格中的哪一项，成为选择子（Selector）</li>\n</ol>\n<h4 id=\"2-从BIOS到bootloader\"><a href=\"#2-从BIOS到bootloader\" class=\"headerlink\" title=\"2.从BIOS到bootloader\"></a>2.从BIOS到bootloader<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/0a29c1d3e1a53b2523d2dcab3a59886b.jpeg\" alt=\"img\"></h4><ol>\n<li>BIOS：<ol>\n<li>放在主板上的ROM（只读存储器），全称为基本输入输出系统，电脑刚加电时，第一条指令指向ROM中，BIOS开始初始化工作。</li>\n<li>检查硬件、建议中断向量表和中断服务程序、在显示器上显示一些字符</li>\n</ol>\n</li>\n<li>bootloader（通过Grub2工具，全称为Grand Unified Bootloader Version 2）<ol>\n<li>可以通过<code>grub2-mkconfig -o /boot/grub2/grub.cfg</code> 来配置系统启动的选项，这里面的选项会在系统启动的时候，成为一个列表，让用户选择从哪个系统启动。</li>\n<li>使用<code>grub2-install /dev/sda</code>可以将启动程序安装到相应的位置<ol>\n<li>安装boot.img到启动盘的第一个扇区，通常称为MBR（主引导记录）</li>\n<li>boot.img加载grub2的另一个镜像core.img，core.img 由 diskboot.img、lzma_decompress.img、kernel.img 和一系列的模块组成</li>\n<li>首先加载进来diskboot.img，它负责将core.img的其他部分加载进来，先是解压缩程序lzma_decompress.img，因为kernel.img是压缩过的，再往下是kernel.img（grub的内核）</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>从实模式切换到保护模式<ol>\n<li>lzma_decompress.img调用real_to_prot，切换到保护模式<ol>\n<li>启用分段：在内存里建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了</li>\n<li>启动分页：能够管理的内存变大了，就需要将内存分成相等大小的块</li>\n<li>打开地址线：打开第21跟地址线Gate A20</li>\n</ol>\n</li>\n<li>kernel.img 对应的代码是 startup.S 以及一堆 c 文件，<ol>\n<li>在 startup.S 中会调用 grub_main，这是 grub kernel 的主函数。在这个函数里面，grub_load_config() 开始解析（上面写的那个 grub.conf 文件里的配置信息）。</li>\n<li>如果是正常启动，grub_main 最后会调用 grub_command_execute (“normal”, 0, 0)，最终会调用 grub_normal_execute() 函数。在这个函数里面，grub_show_menu() 会显示出让你选择的那个操作系统的列表。</li>\n<li>选定了某个操作系统后，为了启动它，就要开始调用 grub_menu_execute_entry() ，开始解析并执行选择的那一项，解析完后grub_command_execute (“boot”, 0, 0) 才开始真正地启动内核</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-内核初始化\"><a href=\"#3-内核初始化\" class=\"headerlink\" title=\"3.内核初始化\"></a>3.内核初始化<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/758c283cf7633465d24ab3ef778328cd.jpeg\" alt=\"img\"></h4><ol>\n<li><p>各个职能部门的创建</p>\n<ol>\n<li><strong>项目管理部门：</strong>有一行指令<code>set_task_stack_end_magic(&amp;init_task)</code>，这里面有一个参数 <code>init_task</code>，它的定义是 <code>struct task_struct init_task = INIT_TASK(init_task)</code>，它是系统创建的第一个进程，称为0号进程，是进程列表（Process List）的第一个</li>\n<li><strong>办事大厅：</strong>对应的函数是<code>trap_init()</code>，里面设置了很多中断门（Interrupt Gate），用于处理各种中断。其中有一个 <code>set_system_intr_gate(IA32_SYSCALL_VECTOR , entry_INT80_32)</code>，这是系统调用的中断门。系统调用也是通过发送中断的方式进行的。</li>\n<li><strong>会议室系统：</strong>对应的<code>mm_init()</code>就是用来初始化内存管理模块，项目需要项目管理进行调度，需要执行一定的调度策略。<code>sched_init()</code>就是用于初始化调度模块。</li>\n<li><strong>档案管理：</strong><code>vfs_caches_init()</code> 会用来初始化基于内存的文件系统 <code>rootfs</code>。在这个函数里面，会调用<code> mnt_init()-&gt;init_rootfs()</code>。这里面有一行代码，<code>register_filesystem(&amp;rootfs_fs_type)</code>。在 VFS 虚拟文件系统里面注册了一种类型，我们定义为 <code>struct file_system_type rootfs_fs_type</code>。</li>\n<li>最后，<code>start_kernel() </code>调用的是<code>rest_init()</code>，用来做其他方面的初始化</li>\n</ol>\n</li>\n<li><p>用户态祖先进程的创建（1号进程）</p>\n<ol>\n<li><p><code>rest_init</code> 的第一大工作是，用 <code>kernel_thread(kernel_init, NULL, CLONE_FS)</code> 创建第二个进程，这个是 1 号进程。</p>\n</li>\n<li><p>用户态代码访问核心资源的流程：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行。</p>\n</li>\n<li><p>从内核态到用户态：</p>\n<ol>\n<li><p>kernel_thread 的参数是一个函数 kernel_init，也就是这个进程会运行这个函数。在 kernel_init 里面，会调用 kernel_init_freeable()，里面有这样的代码：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;ramdisk是根文件系统，运行ramdisk上的&#x2F;init后就是用户态了\nif (!ramdisk_execute_command)\n    ramdisk_execute_command &#x3D; &quot;&#x2F;init&quot;;</code></pre></li>\n<li><p>kernel_init里面有这样的代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">  if (ramdisk_execute_command) &#123;\n    ret &#x3D; run_init_process(ramdisk_execute_command);\n......\n  &#125;\n......\n  if (!try_to_run_init_process(&quot;&#x2F;sbin&#x2F;init&quot;) ||\n      !try_to_run_init_process(&quot;&#x2F;etc&#x2F;init&quot;) ||\n      !try_to_run_init_process(&quot;&#x2F;bin&#x2F;init&quot;) ||\n      !try_to_run_init_process(&quot;&#x2F;bin&#x2F;sh&quot;))\n    return 0;\n</code></pre></li>\n<li><p>run_init_process 函数里面调用的是 do_execve，是一个系统调用的实现，它会尝试运行 ramdisk 的“/init”，或者普通文件系统上的“/sbin/init”，“/etc/init”，“/bin/init”、“/bin/sh”。不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static int run_init_process(const char *init_filename)\n&#123;\n  argv_init[0] &#x3D; init_filename;\n  return do_execve(getname_kernel(init_filename),\n    (const char __user *const __user *)argv_init,\n    (const char __user *const __user *)envp_init);\n&#125;</code></pre></li>\n<li><p>综上，1号进程运行的是一个文件，</p>\n</li>\n</ol>\n</li>\n<li><p>从内核态到用户态</p>\n<ol>\n<li><p><code>run_init_process</code>会调用：do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler，这里面会调用这段内容：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int search_binary_handler(struct linux_binprm *bprm)\n&#123;\n  ......\n  struct linux_binfmt *fmt;\n  ......\n  retval &#x3D; fmt-&gt;load_binary(bprm);\n  ......\n&#125;\n</code></pre></li>\n<li><p>也就是说，我要运行一个程序，需要加载这个二进制文件，这就是我们常说的项目执行计划书。它是ELF格式的（Executable and Linkable Format，可执行与可链接格式），底层先调用 load_elf_binary，最后调用 start_thread</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void\nstart_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)\n&#123;\nset_user_gs(regs, 0);\nregs-&gt;fs  &#x3D; 0;\n&#x2F;&#x2F;将寄存器设置为用户的\nregs-&gt;ds  &#x3D; __USER_DS;\nregs-&gt;es  &#x3D; __USER_DS;\nregs-&gt;ss  &#x3D; __USER_DS;\nregs-&gt;cs  &#x3D; __USER_CS;\n&#x2F;&#x2F;下一条指令从用户态开始运行\nregs-&gt;ip  &#x3D; new_ip;\nregs-&gt;sp  &#x3D; new_sp;\nregs-&gt;flags  &#x3D; X86_EFLAGS_IF;\n&#x2F;&#x2F;用于从系统调用中返回\nforce_iret();\n&#125;\nEXPORT_SYMBOL_GPL(start_thread);</code></pre></li>\n</ol>\n</li>\n<li><p>ramdisk的作用</p>\n</li>\n</ol>\n</li>\n<li><p>内核态祖先进程的创建（2号进程）</p>\n<ol>\n<li><code>rest_init</code> 第二大事情就是第三个进程，就是 2 号进程。</li>\n<li><code>kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)</code> 又一次使用 <code>kernel_thread</code> 函数创建进程，这里的函数 <code>kthreadd</code>，负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-系统调用（办事大厅）\"><a href=\"#4-系统调用（办事大厅）\" class=\"headerlink\" title=\"4.系统调用（办事大厅）\"></a>4.系统调用（办事大厅）<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/868db3f559ad08659ddc74db07a9a0a5.jpg\" alt=\"img\"></h4><ol>\n<li><p>glibc对系统调用的封装</p>\n<ol>\n<li>有个文件syscalls.list，里面列着所有glibc的函数对应的系统调用。</li>\n<li>有一个脚本 make-syscall.sh，可以根据syscalls.list配置文件，对于每一个封装好的系统调用，生成一个文件，这个文件里面定义了一些宏</li>\n<li>还有一个文件 syscall-template.S，使用上面这个宏，定义了这个系统调用的调用方式。</li>\n<li>对于任何一个系统调用，会调用DO_CALL，这也是个宏，且32位和64位不同</li>\n</ol>\n</li>\n<li><p>64位系统调用过程</p>\n<ol>\n<li><p>将系统调用名称转换为系统调用号，放到寄存器rax，将请求参数存放到寄存器里面，然后执行syscall指令</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;* The Linux&#x2F;x86-64 kernel expects the system call parameters in\n   registers according to the following table:\n    syscall number  rax\n    arg 1    rdi\n    arg 2    rsi\n    arg 3    rdx\n    arg 4    r10\n    arg 5    r8\n    arg 6    r9\n......\n*&#x2F;\n#define DO_CALL(syscall_name, args)                \\\n  lea SYS_ify (syscall_name), %rax;                \\\n  syscall</code></pre></li>\n<li><p>syscall指令使用了特殊模块寄存器（Model Specific Registers），在系统初始化的时候，trap_init除了初始化中断模式，还会调用cpu_init-&gt;syscall_init。这里面有这样的代码：<code>wrmsrl(MSR_LSTAR, (unsigned long)entry_SYSCALL_64);</code>，remsr和wrmsr是用来读写特殊模块寄存器的，MSR_LSTAR就是这样一个特殊寄存器，当syscall指令调用时，会从这个寄存器里拿出函数地址来调用，也就是调用<code>entry_SYSCALL_64</code>。</p>\n<pre class=\"line-numbers language-assembly\" data-language=\"assembly\"><code class=\"language-assembly\">ENTRY(entry_SYSCALL_64)\n        &#x2F;* Construct struct pt_regs on stack *&#x2F;\n        pushq   $__USER_DS                      &#x2F;* pt_regs-&gt;ss *&#x2F;\n        pushq   PER_CPU_VAR(rsp_scratch)        &#x2F;* pt_regs-&gt;sp *&#x2F;\n        pushq   %r11                            &#x2F;* pt_regs-&gt;flags *&#x2F;\n        pushq   $__USER_CS                      &#x2F;* pt_regs-&gt;cs *&#x2F;\n        pushq   %rcx                            &#x2F;* pt_regs-&gt;ip *&#x2F;\n        pushq   %rax                            &#x2F;* pt_regs-&gt;orig_ax *&#x2F;\n        pushq   %rdi                            &#x2F;* pt_regs-&gt;di *&#x2F;\n        pushq   %rsi                            &#x2F;* pt_regs-&gt;si *&#x2F;\n        pushq   %rdx                            &#x2F;* pt_regs-&gt;dx *&#x2F;\n        pushq   %rcx                            &#x2F;* pt_regs-&gt;cx *&#x2F;\n        pushq   $-ENOSYS                        &#x2F;* pt_regs-&gt;ax *&#x2F;\n        pushq   %r8                             &#x2F;* pt_regs-&gt;r8 *&#x2F;\n        pushq   %r9                             &#x2F;* pt_regs-&gt;r9 *&#x2F;\n        pushq   %r10                            &#x2F;* pt_regs-&gt;r10 *&#x2F;\n        pushq   %r11                            &#x2F;* pt_regs-&gt;r11 *&#x2F;\n        sub     $(6*8), %rsp                    &#x2F;* pt_regs-&gt;bp, bx, r12-15 not saved *&#x2F;\n        movq    PER_CPU_VAR(current_task), %r11\n        testl   $_TIF_WORK_SYSCALL_ENTRY|_TIF_ALLWORK_MASK, TASK_TI_flags(%r11)\n        jnz     entry_SYSCALL64_slow_path\n......\nentry_SYSCALL64_slow_path:\n        &#x2F;* IRQs are off. *&#x2F;\n        SAVE_EXTRA_REGS\n        movq    %rsp, %rdi\n        call    do_syscall_64           &#x2F;* returns with IRQs disabled *&#x2F;\nreturn_from_SYSCALL_64:\n  RESTORE_EXTRA_REGS\n  TRACE_IRQS_IRETQ\n  movq  RCX(%rsp), %rcx\n  movq  RIP(%rsp), %r11\n    movq  R11(%rsp), %r11\n......\nsyscall_return_via_sysret:\n  &#x2F;* rcx and r11 are already restored (see code above) *&#x2F;\n  RESTORE_C_REGS_EXCEPT_RCX_R11\n  movq  RSP(%rsp), %rsp\n  USERGS_SYSRET64</code></pre></li>\n<li><p>这里先后保存了很多寄存器到pt_regs结构里面，然后调用<code>entry_SYSCALL64_slow_path-&gt;do_syscall_64 </code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__visible void do_syscall_64(struct pt_regs *regs)\n&#123;\n        struct thread_info *ti &#x3D; current_thread_info();\n        unsigned long nr &#x3D; regs-&gt;orig_ax;\n......\n        if (likely((nr &amp; __SYSCALL_MASK) &lt; NR_syscalls)) &#123;\n                regs-&gt;ax &#x3D; sys_call_table[nr &amp; __SYSCALL_MASK](\n                        regs-&gt;di, regs-&gt;si, regs-&gt;dx,\n                        regs-&gt;r10, regs-&gt;r8, regs-&gt;r9);\n        &#125;\n        syscall_return_slowpath(regs);\n&#125;</code></pre></li>\n<li><p>在 do_syscall_64 里面，从 rax 里面拿出系统调用号，然后根据系统调用号，在系统调用表 sys_call_table 中找到相应的函数进行调用，并将寄存器中保存的参数取出来，作为函数参数。</p>\n</li>\n<li><p>64 位的系统调用返回的时候，执行的是 <code>USERGS_SYSRET64</code>，返回用户态的指令变成了<code>sysretq</code></p>\n</li>\n</ol>\n</li>\n<li><p>系统调用表</p>\n<ol>\n<li>系统调用的声明一般在include/linux/syscalls.h 文件中</li>\n<li>真正的系统调用的实现在一个.c文件里，.c文件里包含宏定义，把宏展开，和声明的是一样的</li>\n<li>在编译的过程中，需要根据 syscall_32.tbl 和 syscall_64.tbl 生成自己的 unistd_32.h 和 unistd_64.h。生成方式在 arch/x86/entry/syscalls/Makefile 中。这里面会使用两个脚本，其中第一个脚本 arch/x86/entry/syscalls/syscallhdr.sh，会在文件中生成 #define __NR_open；第二个脚本 arch/x86/entry/syscalls/syscalltbl.sh，会在文件中生成 __SYSCALL(__NR_open, sys_open)。这样，unistd_32.h 和 unistd_64.h 是对应的系统调用号和系统调用实现函数之间的对应关系。<ol>\n<li>在文件 arch/x86/entry/syscall_32.c，定义了这样一个表，里面 include 了这个头文件，从而所有的 sys_ 系统调用都在这个表里面了。</li>\n<li>在文件 arch/x86/entry/syscall_64.c，定义了这样一个表，里面 include 了这个头文件，这样所有的 sys_ 系统调用就都在这个表里面了。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-进程管理-1\"><a href=\"#3-进程管理-1\" class=\"headerlink\" title=\"3.进程管理\"></a>3.进程管理</h3><h4 id=\"1-进程\"><a href=\"#1-进程\" class=\"headerlink\" title=\"1.进程\"></a>1.进程<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dbd8785da6c3ce3fe1abb7bb5934b7a9.jpeg\" alt=\"img\"></h4><ol>\n<li><p>用系统调用创建进程</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;、#include &lt;sys&#x2F;types.h&gt;、#include &lt;unistd.h&gt;\nextern int create_process (char* program, char** arg_list);\nint create_process (char* program, char** arg_list)\n&#123;\n    pid_t child_pid;\n    child_pid &#x3D; fork ();\n    if (child_pid !&#x3D; 0)\n        return child_pid;\n    else &#123;\n        execvp (program, arg_list);\n        abort ();\n    &#125;\n&#125;</code></pre></li>\n<li><p>Linux下面的二进制程序的格式：ELF（Executeable and Linkable Format，可执行与可链接格式），根据编译的结果不同有以下几种格式<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/85320245cd80ce61e69c8391958240de.jpeg\" alt=\"img\"></p>\n<ol>\n<li><p>可重定位文件（Relocatable File），定义为<code>struct elf32_hdr </code>和<code> struct elf64_hdr</code>，里面的一个个节（Section）如下：</p>\n<ul>\n<li>.text：放编译好的二进制可执行代码</li>\n<li>.rodata：只读数据，例如字符串常量、const 的变量</li>\n<li>.data：已经初始化好的全局变量</li>\n<li>.bss：未初始化全局变量，运行时会置 0</li>\n<li>.symtab：符号表，记录的则是函数和变量</li>\n<li>.strtab：字符串表、字符串常量和变量名</li>\n<li>.rel.text, .rel.data ：与重定位有关</li>\n<li>Section Header Table：保存其它所有节（section）的元数据</li>\n</ul>\n</li>\n<li><p>可执行文件：这个格式和.o 文件大致相似，里面的section同上，只不过这些 section 是多个.o 文件合并过的。定义为 <code>struct elf32_phdr</code> 和 <code>struct elf64_phdr</code>并且被<code>Section Header Table</code>描述。（许多.o文件可通过ar命令归档为.a静态链接文件，使用时找到内部的.o文件并与新.o文件链接成可执行文件）</p>\n<ul>\n<li>ELF Header</li>\n<li>Segment Header Table</li>\n<li>代码段：<code>.text</code>、<code>.rodata</code></li>\n<li>数据段：<code>.data</code>、<code>.bss</code></li>\n<li>不加载到内存：<code>.symtab</code>、<code>.strtab</code>、<code>Section Header Table</code></li>\n</ul>\n</li>\n<li><p>共享对象文件（Shard Object），即动态链接库（Shard Libraries）</p>\n<ol>\n<li>创建：当一个动态链接库被链接到一个程序文件中的时候，最后的程序文件并不包括动态链接库中的代码，仅包括对动态链接库的引用和名称。</li>\n<li>运行：当运行这个程序的时候，首先寻找动态链接库（默认在/lib 和 /usr/lib 文件夹下寻找），然后加载它。</li>\n<li>ELF 文件中还多了两个 section，<code>.plt</code>过程链接表（Procedure Linkage Table，PLT）、<code>.got.plt</code>全局偏移量表（Global Offset Table，GOT）原理如下：<ol>\n<li>因为时运行时才去找，编译时不知道代码位置，所以就在 PLT 里面建立一项 PLT[x]。里面有一些代码可以在运行时找真正的create_process 函数。</li>\n<li>代码调用GOT创建的GOT[y]，它是运行时 create_process 函数在内存中真正的地址。</li>\n<li>GOT最初依靠调用链PLT[0]-&gt;GOT[2]-&gt;<code>ld-linux.so</code>，最后加载内存中的函数地址放到GOT[y]中。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>运行程序文件称为进程</p>\n<ol>\n<li><p>内核用下面的数据结构来定义加载二进制文件的方法：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct linux_binfmt &#123;\n    struct list_head lh;\n    struct module *module;\n    int (*load_binary)(struct linux_binprm *);\n    int (*load_shlib)(struct file *);\n    int (*core_dump)(struct coredump_params *cprm);\n    unsigned long min_coredump;     &#x2F;* minimal dump size *&#x2F;\n&#125; __randomize_layout;</code></pre></li>\n<li><p>对于ELF文件格式，有对应的实现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static struct linux_binfmt elf_format &#x3D; &#123;\n    .module         &#x3D; THIS_MODULE,\n    &#x2F;&#x2F;调用链：exec系统调用-&gt;do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler\n    .load_binary    &#x3D; load_elf_binary,\n    .load_shlib     &#x3D; load_elf_library,\n    .core_dump      &#x3D; elf_core_dump,\n    .min_coredump   &#x3D; ELF_EXEC_PAGESIZE,\n&#125;;</code></pre></li>\n</ol>\n</li>\n<li><p>进程树</p>\n<ol>\n<li><p>通过<code>ps -ef</code>命令查看当前系统启动的进程，会发现有三类进程</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[root@deployer ~]# ps -ef\nUID        PID  PPID  C STIME TTY          TIME CMD\nroot         1     0  0  2018 ?        00:00:29 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd --system --deserialize 21\nroot         2     0  0  2018 ?        00:00:00 [kthreadd]\nroot         3     2  0  2018 ?        00:00:00 [ksoftirqd&#x2F;0]\nroot         5     2  0  2018 ?        00:00:00 [kworker&#x2F;0:0H]\nroot         9     2  0  2018 ?        00:00:40 [rcu_sched]\n......\nroot       337     2  0  2018 ?        00:00:01 [kworker&#x2F;3:1H]\nroot       380     1  0  2018 ?        00:00:00 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-udevd\nroot       415     1  0  2018 ?        00:00:01 &#x2F;sbin&#x2F;auditd\nroot       498     1  0  2018 ?        00:00:03 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;systemd-logind\n......\nroot       852     1  0  2018 ?        00:06:25 &#x2F;usr&#x2F;sbin&#x2F;rsyslogd -n\nroot      2580     1  0  2018 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;sshd -D\nroot     29058     2  0 Jan03 ?        00:00:01 [kworker&#x2F;1:2]\nroot     29672     2  0 Jan04 ?        00:00:09 [kworker&#x2F;2:1]\nroot     30467     1  0 Jan06 ?        00:00:00 &#x2F;usr&#x2F;sbin&#x2F;crond -n\nroot     31574     2  0 Jan08 ?        00:00:01 [kworker&#x2F;u128:2]\n......\nroot     32792  2580  0 Jan10 ?        00:00:00 sshd: root@pts&#x2F;0\nroot     32794 32792  0 Jan10 pts&#x2F;0    00:00:00 -bash\nroot     32901 32794  0 00:01 pts&#x2F;0    00:00:00 ps -ef</code></pre>\n\n\n\n<ol>\n<li>PID 1 的进程就是 init 进程 systemd，PID 2 的进程是内核线程 kthreadd，这两个在内核启动的时候都见过。其中用户态的不带中括号，内核态的带中括号。</li>\n<li>带中括号的内核态的进程，祖先都是 2 号进程。而用户态的进程，祖先都是 1 号进程。tty 那一列，是问号的，说明不是前台启动的，一般都是后台的服务。</li>\n<li>pts 的父进程是 sshd，bash 的父进程是 pts，ps -ef 这个命令的父进程是 bash。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-线程\"><a href=\"#2-线程\" class=\"headerlink\" title=\"2.线程\"></a>2.线程<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/02a774d7c0f83bb69fec4662622d6d58.png\" alt=\"img\"></h4><ol>\n<li><p>线程创建<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/e38c28b0972581d009ef16f1ebdee2bd.jpg\" alt=\"img\"></p>\n</li>\n<li><p>线程数据<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/e7b06dcf431f388170ab0a79677ee43f.jpg\" alt=\"img\"></p>\n<ol>\n<li><p>线程栈上的本地数据：每个线程有自己的线程栈，可用<code>pthread_attr_setstacksize</code>修改栈大小</p>\n</li>\n<li><p>线程共享的全局数据：利用互斥来保证安全</p>\n</li>\n<li><p>线程私有数据：</p>\n<ol>\n<li><p>创建：key 一旦被创建，所有线程都可以访问它，但各线程可根据自己的需要往 key 中填入不同的值，这就相当于提供了一个同名而不同值的全局变量。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int pthread_key_create(pthread_key_t *key, void (*destructor)(void*))</code></pre></li>\n<li><p>value值操作</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;设置key对应的value\nint pthread_setspecific(pthread_key_t key, const void *value)；\n&#x2F;&#x2F;获取key对应的value\nvoid *pthread_getspecific(pthread_key_t key)    </code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>数据的保护</p>\n<ol>\n<li><p>举例一：转账</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;#include &lt;pthread.h&gt;、#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;\n#define NUM_OF_TASKS 5\n\nint money_of_tom &#x3D; 100;\nint money_of_jerry &#x3D; 100;\npthread_mutex_t g_money_lock;\n\nvoid *transfer(void *notused)\n&#123;\n    pthread_t tid &#x3D; pthread_self();\n    printf(&quot;Thread %u is transfering money!\\n&quot;, (unsigned int)tid);\n    pthread_mutex_lock(&amp;g_money_lock);\n    sleep(rand()%10);\n    money_of_tom+&#x3D;10;\n    sleep(rand()%10);\n    money_of_jerry-&#x3D;10;\n    pthread_mutex_unlock(&amp;g_money_lock);\n    printf(&quot;Thread %u finish transfering money!\\n&quot;, (unsigned int)tid);\n    pthread_exit((void *)0);\n&#125;\n\nint main(int argc, char *argv[])\n&#123;\n    pthread_t threads[NUM_OF_TASKS];\n    int rc;\n    int t;\n    pthread_mutex_init(&amp;g_money_lock, NULL);\n\n    for(t&#x3D;0;t&lt;NUM_OF_TASKS;t++)&#123;\n        rc &#x3D; pthread_create(&amp;threads[t], NULL, transfer, NULL);\n        if (rc)&#123;\n            printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc);\n            exit(-1);\n        &#125;\n    &#125;\n\n    for(t&#x3D;0;t&lt;100;t++)&#123;\n        pthread_mutex_lock(&amp;g_money_lock);\n        printf(&quot;money_of_tom + money_of_jerry &#x3D; %d\\n&quot;, money_of_tom + money_of_jerry);\n        pthread_mutex_unlock(&amp;g_money_lock);\n    &#125;\n\n    pthread_mutex_destroy(&amp;g_money_lock);\n    pthread_exit(NULL);\n&#125;</code></pre></li>\n<li><p>举例二：三个员工等活干</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;#include &lt;pthread.h&gt;、#include &lt;stdio.h&gt;、#include &lt;stdlib.h&gt;\n#define NUM_OF_TASKS 3\n#define MAX_TASK_QUEUE 11\n\nchar tasklist[MAX_TASK_QUEUE]&#x3D;&quot;ABCDEFGHIJ&quot;;\nint head &#x3D; 0;\nint tail &#x3D; 0;\nint quit &#x3D; 0;\n\npthread_mutex_t g_task_lock;\npthread_cond_t g_task_cv;\n\nvoid *coder(void *notused)\n&#123;\n    pthread_t tid &#x3D; pthread_self();\n\n    while(!quit)&#123;\n\n        pthread_mutex_lock(&amp;g_task_lock);\n        while(tail &#x3D;&#x3D; head)&#123;\n            if(quit)&#123;\n                pthread_mutex_unlock(&amp;g_task_lock);\n                pthread_exit((void *)0);\n            &#125;\n            printf(&quot;No task now! Thread %u is waiting!\\n&quot;, (unsigned int)tid);\n            pthread_cond_wait(&amp;g_task_cv, &amp;g_task_lock);\n            printf(&quot;Have task now! Thread %u is grabing the task !\\n&quot;, (unsigned int)tid);\n        &#125;\n        char task &#x3D; tasklist[head++];\n        pthread_mutex_unlock(&amp;g_task_lock);\n        printf(&quot;Thread %u has a task %c now!\\n&quot;, (unsigned int)tid, task);\n        sleep(5);\n        printf(&quot;Thread %u finish the task %c!\\n&quot;, (unsigned int)tid, task);\n    &#125;\n\n    pthread_exit((void *)0);\n&#125;\n\nint main(int argc, char *argv[])\n&#123;\n    pthread_t threads[NUM_OF_TASKS];\n    int rc;\n    int t;\n\n    pthread_mutex_init(&amp;g_task_lock, NULL);\n    pthread_cond_init(&amp;g_task_cv, NULL);\n\n    for(t&#x3D;0;t&lt;NUM_OF_TASKS;t++)&#123;\n        rc &#x3D; pthread_create(&amp;threads[t], NULL, coder, NULL);\n        if (rc)&#123;\n            printf(&quot;ERROR; return code from pthread_create() is %d\\n&quot;, rc);\n            exit(-1);\n        &#125;\n    &#125;\n\n    sleep(5);\n\n    for(t&#x3D;1;t&lt;&#x3D;4;t++)&#123;\n        pthread_mutex_lock(&amp;g_task_lock);\n        tail+&#x3D;t;\n        printf(&quot;I am Boss, I assigned %d tasks, I notify all coders!\\n&quot;, t);\n        pthread_cond_broadcast(&amp;g_task_cv);\n        pthread_mutex_unlock(&amp;g_task_lock);\n        sleep(20);\n    &#125;\n\n    pthread_mutex_lock(&amp;g_task_lock);\n    quit &#x3D; 1;\n    pthread_cond_broadcast(&amp;g_task_cv);\n    pthread_mutex_unlock(&amp;g_task_lock);\n\n    pthread_mutex_destroy(&amp;g_task_lock);\n    pthread_cond_destroy(&amp;g_task_cv);\n    pthread_exit(NULL);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-进程数据结构\"><a href=\"#3-进程数据结构\" class=\"headerlink\" title=\"3.进程数据结构\"></a>3.进程数据结构<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/1c91956b52574b62a4418a7c6993d8bc.jpeg\" alt=\"img\"></h4><ol>\n<li><p><strong>Task：</strong>Linux里面，无论是进程还是线程，都统一叫任务（Task），由统一的结构<code>task_struct</code>进行管理，并组织成一个链表<code>struct list_head tasks;</code></p>\n</li>\n<li><p><strong>任务ID：</strong></p>\n<ol>\n<li>用于简化任务展示（ps指令）和向一组任务发指令（kill指令），</li>\n<li>pid 是 process id，tgid 是 thread group ID<ol>\n<li>任何一个进程，如果只有主线程，那 pid 是自己，tgid 是自己，group_leader 指向的还是自己。</li>\n<li>如果一个进程创建了其他线程，线程有自己的 pid，tgid 就是进程的主线程的 pid，group_leader 指向的就是进程的主线程。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><strong>信号处理：</strong></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;里面有 struct sigpending shared_pending（线程组共享的）\nstruct signal_struct    *signal;\n&#x2F;&#x2F;信号正在等待被处理\nstruct sighand_struct    *sighand;\n&#x2F;&#x2F;信号被&#x2F;阻塞暂不处理\nsigset_t      blocked;\nsigset_t      real_blocked;\nsigset_t      saved_sigmask;\n&#x2F;&#x2F;信号等待被处理（本任务的）\nstruct sigpending    pending;\n&#x2F;&#x2F;信号处理默认用用户态的函数栈，下面三个字段用于开辟新的栈专门用于信号处理\nunsigned long      sas_ss_sp;\nsize_t        sas_ss_size;\nunsigned int      sas_ss_flags;</code></pre></li>\n<li><p><strong>任务状态：</strong></p>\n<ol>\n<li><p>state（状态）可以取的值定义在include/linux/sched.h 头文件中，通过bitset的方式设置的，当前是什么状态，哪一位就置1</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;* Used in tsk-&gt;state: *&#x2F;\n#define TASK_RUNNING                    0\n#define TASK_INTERRUPTIBLE              1\n#define TASK_UNINTERRUPTIBLE            2\n&#x2F;&#x2F;在进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 或者 SIGTTOU 信号之后进入该状态\n#define __TASK_STOPPED                  4\n&#x2F;&#x2F;TASK_TRACED 表示进程被 debugger 等进程监视，进程执行被调试程序所停止。\n#define __TASK_TRACED                   8\n\n&#x2F;* Used in tsk-&gt;exit_state: *&#x2F;\n#define EXIT_DEAD                       16\n&#x2F;&#x2F;一旦一个进程要结束，先进入的是 EXIT_ZOMBIE 状态，\n&#x2F;&#x2F;但是这个时候它的父进程还没有使用 wait() 等系统调用来获知它的终止信息\n#define EXIT_ZOMBIE                     32\n#define EXIT_TRACE                      (EXIT_ZOMBIE | EXIT_DEAD)\n\n&#x2F;* Used in tsk-&gt;state again: *&#x2F;\n&#x2F;&#x2F;进程的最终状态\n#define TASK_DEAD                       64\n#define TASK_WAKEKILL                   128\n#define TASK_WAKING                     256\n#define TASK_PARKED                     512\n#define TASK_NOLOAD                     1024\n#define TASK_NEW                        2048\n#define TASK_STATE_MAX                  4096</code></pre></li>\n<li><p>状态转移图<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/e2fa348c67ce41ef730048ff9ca4c988.jpeg\" alt=\"img\"></p>\n<ol>\n<li><strong>TASK_RUNNING：</strong> 并不是进程正在运行，而是进程处于准备运行的状态。</li>\n<li>睡眠状态<ol>\n<li><strong>TASK_INTERRUPTIBLE：</strong>可中断的睡眠状态。虽然在睡眠等待 I/O 完成，但这时一个信号到来，进程还是要被唤醒。</li>\n<li><strong>TASK_UNINTERRUPTIBLE：</strong>不可中断的睡眠状态。不可被信号唤醒，只能死等 I/O 操作完成。一旦 I/O 操作因为特殊原因不能完成，这个时候，谁也叫不醒这个进程了。</li>\n<li><strong>TASK_KILLABLE：</strong>可以终止的新睡眠状态。进程处于这种状态中，它的运行原理类似 TASK_UNINTERRUPTIBLE，只不过可以响应致命信号。</li>\n</ol>\n</li>\n<li><strong>TASK_STOPPED：</strong> 在进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 、SIGTTOU 信号后进入该状态。</li>\n</ol>\n</li>\n<li><p><strong>flags字段：</strong></p>\n<ol>\n<li>PF_EXITING 表示正在退出。当有这个 flag 的时候，在函数 find_alive_thread 中，找活着的线程，遇到有这个 flag 的，就直接跳过。</li>\n<li>PF_VCPU 表示进程运行在虚拟 CPU 上。在函数 account_system_time 中，统计进程的系统运行时间，如果有这个 flag，就调用 account_guest_time，按照客户机的时间进行统计。</li>\n<li>PF_FORKNOEXEC 表示 fork 完了，还没有 exec。在 _do_fork 函数里面调用 copy_process，这个时候把 flag 设置为 PF_FORKNOEXEC。当 exec 中调用了 load_elf_binary 的时候，又把这个 flag 去掉。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>运行统计信息</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">u64        utime;&#x2F;&#x2F;用户态消耗的CPU时间\nu64        stime;&#x2F;&#x2F;内核态消耗的CPU时间\nunsigned long      nvcsw;&#x2F;&#x2F;自愿(voluntary)上下文切换计数\nunsigned long      nivcsw;&#x2F;&#x2F;非自愿(involuntary)上下文切换计数\nu64        start_time;&#x2F;&#x2F;进程启动时间，不包含睡眠时间\nu64        real_start_time;&#x2F;&#x2F;进程启动时间，包含睡眠时间</code></pre></li>\n<li><p>进程亲缘关系</p>\n<ol>\n<li>parent 指向其父进程。当它终止时，必须向它的父进程发送信号。children 表示链表的头部。链表中的所有元素都是它的子进程。sibling 用于把当前进程插入到兄弟链表中。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/92711107d8dcdf2c19e8fe4ee3965304.jpeg\" alt=\"img\"></li>\n</ol>\n</li>\n<li><p>进程权限</p>\n<ol>\n<li><p><strong>用户组：</strong>real_cred 就是说明谁能操作我这个进程，而 cred 就是说明我这个进程能够操作谁，cred的定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct cred &#123;\n    &#x2F;&#x2F;一般谁启动的进程，就是谁的ID，往往不比较这两个\n    kuid_t          uid;            &#x2F;* real UID of the task *&#x2F;\n    kgid_t          gid;            &#x2F;* real GID of the task *&#x2F;\n    \n    kuid_t          suid;           &#x2F;* saved UID of the task *&#x2F;\n    kgid_t          sgid;           &#x2F;* saved GID of the task *&#x2F;\n    &#x2F;&#x2F;当这个进程要操作消息队列、共享内存、信号量等对象的时候，\n    &#x2F;&#x2F;其实就是在比较这个用户和组是否有权限。\n    kuid_t          euid;           &#x2F;* effective UID of the task *&#x2F;\n    kgid_t          egid;           &#x2F;* effective GID of the task *&#x2F;\n\t&#x2F;&#x2F;对文件操作会审核的权限\n    kuid_t          fsuid;          &#x2F;* UID for VFS ops *&#x2F;\n    kgid_t          fsgid;          &#x2F;* GID for VFS ops *&#x2F;\n    &#x2F;&#x2F;......\n    kernel_cap_t    cap_inheritable; &#x2F;* caps our children can inherit *&#x2F;\n    kernel_cap_t    cap_permitted;  &#x2F;* caps we&#39;re permitted *&#x2F;\n    kernel_cap_t    cap_effective;  &#x2F;* caps we can actually use *&#x2F;\n    kernel_cap_t    cap_bset;       &#x2F;* capability bounding set *&#x2F;\n    kernel_cap_t    cap_ambient;    &#x2F;* Ambient capability set *&#x2F;\n    ......\n&#125; __randomize_layout;</code></pre>\n\n\n\n<ul>\n<li>一般说来，fsuid、euid，和 uid 是一样的，fsgid、egid，和 gid 也是一样的。因为谁启动的进程，就应该审核启动的用户到底有没有这个权限。\\</li>\n<li>特殊情况<code>chmod u+s program </code>命令，给文件设置set-user-ID的标识位，这样非文件所有者启动文件时，只有uid为启动者，其余euid和fsuid都仍为文件所有者</li>\n</ul>\n</li>\n<li><p><strong>capabilities机制：</strong>用来平衡root权限过大和用户权限过小的问题，<code>capabilities.h</code>可以找到定义的权限</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define CAP_CHOWN            0\n#define CAP_KILL             5\n#define CAP_NET_BIND_SERVICE 10\n#define CAP_NET_RAW          13\n#define CAP_SYS_MODULE       16\n#define CAP_SYS_RAWIO        17\n#define CAP_SYS_BOOT         22\n#define CAP_SYS_TIME         25\n#define CAP_AUDIT_READ          37\n#define CAP_LAST_CAP         CAP_AUDIT_READ</code></pre>\n\n<ul>\n<li>cap_permitted 表示进程能够使用的权限。但是真正起作用的是 cap_effective。cap_permitted 中可以包含 cap_effective 中没有的权限。一个进程可以在必要的时候，放弃自己的某些权限，这样更加安全。假设自己因为代码漏洞被攻破了，但是如果啥也干不了，就没办法进一步突破。</li>\n<li>cap_bset，也就是 capability bounding set，是系统中所有进程允许保留的权限。如果这个集合中不存在某个权限，那么系统中的所有进程都没有这个权限。即使以超级用户权限执行的进程，也是一样的。这样有很多好处。例如，系统启动以后，将加载内核模块的权限去掉，那所有进程都不能加载内核模块。这样，即便这台机器被攻破，也做不了太多有害的事情。</li>\n<li>cap_ambient 是比较新加入内核的，就是为了解决 cap_inheritable 鸡肋的状况，也就是，非 root 用户进程使用 exec 执行一个程序的时候，如何保留权限的问题。当执行 exec 的时候，cap_ambient 会被添加到 cap_permitted 中，同时设置到 cap_effective 中。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>用户态和内核态</p>\n<ol>\n<li><p>用户态函数栈和内核态函数栈<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/82ba663aad4f6bd946d48424196e515c.jpeg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct thread_info    thread_info;\n&#x2F;&#x2F;内核栈\nvoid  *stack;</code></pre></li>\n<li><p>通过<code>task_struct</code>找内核栈</p>\n<ol>\n<li><p>如果有一个 task_struct 的 stack 指针在手，可以通过下面的函数找到这个线程内核栈</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static inline void *task_stack_page(const struct task_struct *task)&#123;\n    return task-&gt;stack;\n&#125;</code></pre></li>\n<li><p>从 task_struct 如何得到相应的 pt_regs：先从 task_struct 找到内核栈的开始位置。然后这个位置加上 THREAD_SIZE 就到了最后的位置，然后转换为 struct pt_regs，再减一，就相当于减少了一个 pt_regs 的位置，就到了这个结构的首地址。（TOP_OF_KERNEL_STACK_PADDING在32位机上是8，其它是0，因为用户态到内核态权限改变会压栈保存SS、ESP寄存器，共占8个byte）</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define task_pt_regs(task) \\\n(&#123;                  \\\n  unsigned long __ptr &#x3D; (unsigned long)task_stack_page(task);  \\\n  __ptr +&#x3D; THREAD_SIZE - TOP_OF_KERNEL_STACK_PADDING;    \\\n  ((struct pt_regs *)__ptr) - 1;          \\\n&#125;)</code></pre></li>\n</ol>\n</li>\n<li><p>通过内核栈找<code>task_struct</code></p>\n<ol>\n<li><p>就机制：thread_info结构中的task指向task_struct，用current_thread_info()-&gt;task来获取task_struct</p>\n</li>\n<li><p>新的机制里面，每个 CPU 运行的 task_struct 不通过 thread_info 获取了，而是直接放在 Per CPU 变量里面了。多核情况下，CPU 是同时运行的，但是它们共同使用其他的硬件资源的时候，我们需要解决多个 CPU 之间的同步问题。Per CPU 变量就是为每个 CPU 构造一个变量的副本，这样多个 CPU 各自操作自己的副本，互不干涉。比如，当前进程的变量 current_task 就被声明为 Per CPU 变量。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-进程调度\"><a href=\"#4-进程调度\" class=\"headerlink\" title=\"4.进程调度\"></a>4.进程调度<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/10381dbafe0f78d80beb87560a9506af.jpeg\" alt=\"img\"></h4><ol>\n<li><p>用于进程调度的字段：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;是否在运行队列上\nint        on_rq;\n&#x2F;&#x2F;优先级，实时进程（0~99）、普通进程（100~139）\nint        prio;\nint        static_prio;\nint        normal_prio;\nunsigned int      rt_priority;\n&#x2F;&#x2F;调度器类：包裹调度策略的执行逻辑\nconst struct sched_class  *sched_class;\n&#x2F;&#x2F;调度实体\nstruct sched_entity    se;&#x2F;&#x2F;完全公平调度实体\nstruct sched_rt_entity    rt;&#x2F;&#x2F;实时调度实体\nstruct sched_dl_entity    dl;&#x2F;&#x2F;deadline调度实体\n&#x2F;&#x2F;调度策略（6种）\nunsigned int      policy;\n&#x2F;&#x2F;可以使用哪些CPU\nint        nr_cpus_allowed;\ncpumask_t      cpus_allowed;\nstruct sched_info    sched_info;</code></pre></li>\n<li><p>调度策略：</p>\n<ol>\n<li><p>实时调度策略：</p>\n<ol>\n<li>SCHED_FIFO： 先来先服务，高优先级的进程可以抢占低优先级的进程，而相同优先级的进程，遵循先来先得。</li>\n<li>SCHED_RR ：采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，而高优先级的任务也是可以抢占低优先级的任务。</li>\n<li>SCHED_DEADLINE：是按照任务的 deadline 进行调度的。当产生一个调度点的时候，DL 调度器总是选择其 deadline 距离当前时间点最近的那个任务，并调度它执行。</li>\n</ol>\n</li>\n<li><p>普通调度策略：</p>\n<ol>\n<li>SCHED_NORMAL：普通的进程</li>\n<li>SCHED_BATCH：是后台进程，几乎不需要和前端进行交互。这类项目可以默默执行，不要影响需要交互的进程，可以降低它的优先级。</li>\n<li>SCHED_IDLE：特别空闲的时候才跑的进程</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>调度类有以下几种实现：</p>\n<ol>\n<li>stop_sched_class 优先级最高的任务会使用这种策略，会中断所有其他线程，且不会被其他任务打断；</li>\n<li>dl_sched_class 就对应上面的 deadline 调度策略；</li>\n<li>rt_sched_class 就对应 RR 算法或者 FIFO 算法的调度策略，具体调度策略由进程的 task_struct-&gt;policy 指定；</li>\n<li>fair_sched_class 就是普通进程的调度策略；CFS 调度算法（ Completely Fair Scheduling，叫完全公平调度），相当于 N 个口袋，优先级高的袋子大，优先级低的袋子小。这样球就不能按照个数分配了，要按照比例来，大口袋的放了一半和小口袋放了一半，里面的球数目虽然差很多，也认为是公平的</li>\n<li>idle_sched_class 就是空闲进程的调度策略。</li>\n</ol>\n</li>\n<li><p>调度队列与调度实体</p>\n<ol>\n<li><p>CFS 调度算法通过<strong>红黑树</strong>来对 vruntime 进行排序，找出最小的那个。</p>\n</li>\n<li><p>进程根据自己是实时的，还是普通的类型，通过这个成员变量，将自己挂在某一个数据结构里面，和其他的进程排序，等待被调度。例如：如果这个进程是个普通进程，则通过 sched_entity，将自己挂在这棵红黑树上。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct sched_entity &#123;\n  struct load_weight    load;\n  struct rb_node      run_node;\n  struct list_head    group_node;\n  unsigned int      on_rq;\n  u64        exec_start;\n  u64        sum_exec_runtime;\n  u64        vruntime;\n  u64        prev_sum_exec_runtime;\n  u64        nr_migrations;\n  struct sched_statistics    statistics;\n&#x2F;&#x2F;......\n&#125;;</code></pre></li>\n<li><p>红黑树存放的位置：每个 CPU 都有自己的 <code>struct rq</code> 结构，其用于描述在此 CPU 上所运行的所有进程，其包括一个实时进程队列 rt_rq 和一个 CFS 运行队列 cfs_rq，在调度时，调度器首先会先去实时进程队列找是否有实时进程需要运行，如果没有才会去 CFS 运行队列找是否有进程需要运行。cfs_rq里存着红黑树的根节点。对于普通进程公平队列 cfs_rq，定义如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;* CFS-related fields in a runqueue *&#x2F;\nstruct cfs_rq &#123;\n  struct load_weight load;\n  unsigned int nr_running, h_nr_running;\n  u64 exec_clock;\n  u64 min_vruntime;\n#ifndef CONFIG_64BIT\n  u64 min_vruntime_copy;\n#endif\n  struct rb_root tasks_timeline;\n  struct rb_node *rb_leftmost;\n  struct sched_entity *curr, *next, *last, *skip;\n&#x2F;&#x2F;......\n&#125;;</code></pre></li>\n</ol>\n</li>\n<li><p>调度类如何工作</p>\n<ol>\n<li><p>调度类，这个结构定义了很多种方法，用于在队列上操作任务</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct sched_class &#123;\n    &#x2F;&#x2F;指向下一个调度类\n    const struct sched_class *next;\n\t&#x2F;&#x2F;向就绪队列中添加一个进程，当某个进程进入可运行状态时，调用这个函数\n    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);\n    &#x2F;&#x2F;将一个进程从就绪队列中删除\n    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);\n    void (*yield_task) (struct rq *rq);\n    bool (*yield_to_task) (struct rq *rq, struct task_struct *p, bool preempt);\n\n    void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);\n\t&#x2F;&#x2F;选择接下来要运行的进程\n    struct task_struct * (*pick_next_task) (struct rq *rq,\n                                            struct task_struct *prev,\n                                            struct rq_flags *rf);\n    &#x2F;&#x2F;用另一个进程代替当前运行的进程\n    void (*put_prev_task) (struct rq *rq, struct task_struct *p);\n\t&#x2F;&#x2F;用于修改调度策略\n    void (*set_curr_task) (struct rq *rq);\n    &#x2F;&#x2F;每次周期性时钟到的时候，这个函数被调用，可能触发调度\n    void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);\n    void (*task_fork) (struct task_struct *p);\n    void (*task_dead) (struct task_struct *p);\n\n    void (*switched_from) (struct rq *this_rq, struct task_struct *task);\n    void (*switched_to) (struct rq *this_rq, struct task_struct *task);\n    void (*prio_changed) (struct rq *this_rq, struct task_struct *task, int oldprio);\n    unsigned int (*get_rr_interval) (struct rq *rq,struct task_struct *task);\n    void (*update_curr) (struct rq *rq)\n&#125;</code></pre></li>\n<li><p>调度类都放在一个链表上，调度的时候是从优先级最高的调度类到优先级低的调度类，沿着上面的顺序，依次调用每个调度类的方法。对于每种调度类，有自己的具体实现。对于同样的 pick_next_task 选取下一个要运行的任务这个动作，不同的调度类有自己的实现，并且会操作不同的队列。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static struct task_struct *\n    pick_next_task_rt(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n&#123;\n    struct task_struct *p;\n    struct rt_rq *rt_rq &#x3D; &amp;rq-&gt;rt;\n    &#x2F;&#x2F;......\n&#125;\n\nstatic struct task_struct *\n    pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n&#123;\n    struct cfs_rq *cfs_rq &#x3D; &amp;rq-&gt;cfs;\n    struct sched_entity *se;\n    struct task_struct *p;\n    &#x2F;&#x2F;......\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>主动调度：schedule 函数调用，主要逻辑是在 __schedule 函数中实现的<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/93588d71abd7f007397979f0ba7def7f.png\" alt=\"img\"></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">asmlinkage __visible void __sched schedule(void)&#123;\n    struct task_struct *tsk &#x3D; current;\n\n    sched_submit_work(tsk);\n    do &#123;\n        preempt_disable();\n        __schedule(false);\n        sched_preempt_enable_no_resched();\n    &#125; while (need_resched());\n&#125;\n\n&#x2F;&#x2F;上面这段代码的主要逻辑是在 __schedule 函数中实现的。\nstatic void __sched notrace __schedule(bool preempt)&#123;\n    struct task_struct *prev, *next;\n    unsigned long *switch_count;\n    struct rq_flags rf;\n    struct rq *rq;\n    int cpu;\n\n    &#x2F;&#x2F;首先，在当前的 CPU 上，取出任务队列 rq。\n    cpu &#x3D; smp_processor_id();\n    rq &#x3D; cpu_rq(cpu);\n    &#x2F;&#x2F;prev 指向这个 CPU 的任务队列上面正在运行的那个进程 curr\n    prev &#x3D; rq-&gt;curr;\n    &#x2F;&#x2F;其次，获取下一个任务，next 指向下一个任务，这就是继任\n    next &#x3D; pick_next_task(rq, prev, &amp;rf);\n    clear_tsk_need_resched(prev);\n    clear_preempt_need_resched();\n    &#x2F;&#x2F;最，后当选出的继任者和前任不同，就要进行上下文切换，继任者进程正式进入运行。\n    if (likely(prev !&#x3D; next)) &#123;\n        rq-&gt;nr_switches++;\n        rq-&gt;curr &#x3D; next;\n        ++*switch_count;\n        &#x2F;&#x2F;上下文切换，主要干两件事，一是切换进程空间，也即虚拟内存；二是切换寄存器和 CPU 上下文。\n        rq &#x3D; context_switch(rq, prev, next, &amp;rf);</code></pre>\n\n\n\n<ol>\n<li><p><code>pick_next_task</code>依次调用调度类，因为大部分进程是普通进程，所以调用的是<code>fair_sched_class.pick_next_task</code>，即调用的是<code>pick_next_task_fair</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static struct task_struct *\n    pick_next_task_fair(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n&#123;\n    struct cfs_rq *cfs_rq &#x3D; &amp;rq-&gt;cfs;\n    struct sched_entity *se;\n    struct task_struct *p;\n    int new_tasks;\n    &#x2F;&#x2F;取出相应的队列cfc_rq（红黑树），并取出正在运行的任务curr\n    struct sched_entity *curr &#x3D; cfs_rq-&gt;curr;\n    if (curr) &#123;\n        if (curr-&gt;on_rq)\n            &#x2F;&#x2F;处于就绪状态，调用updata_curr更新vruntime\n            update_curr(cfs_rq);\n        else\n            curr &#x3D; NULL;\n    &#125;\n    &#x2F;&#x2F;从红黑树cfc_rq里面取最左边的一个节点\n    se &#x3D; pick_next_entity(cfs_rq, curr);\n    &#x2F;&#x2F;得到下一个调度实体对应的task_struct\n    p &#x3D; task_of(se);\n    &#x2F;&#x2F;如果发现继任和前任不一样，就说明有一个更需要运行的进程，就需要更新红黑树\n    &#x2F;&#x2F;前面继任的vruntime更新过了，put_prev_entity 放回红黑树，会找到相应的位置，\n    &#x2F;&#x2F;然后 set_next_entity 将继任者设为当前任务\n    if (prev !&#x3D; p) &#123;\n        struct sched_entity *pse &#x3D; &amp;prev-&gt;se;\n        put_prev_entity(cfs_rq, pse);\n        set_next_entity(cfs_rq, se);\n    &#125;\n    return p\n&#125;</code></pre></li>\n<li><p><code>context_switch</code>上下文切换：切换进程空间（虚拟内存）、切换寄存器和CPU上下文</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static __always_inline struct rq *\n    context_switch(struct rq *rq, struct task_struct *prev,\n                   struct task_struct *next, struct rq_flags *rf)\n&#123;\n    &#x2F;&#x2F;内存切换，用户栈也切换了\n    struct mm_struct *mm, *oldmm;\n    mm &#x3D; next-&gt;mm;\n    oldmm &#x3D; prev-&gt;active_mm;\n    switch_mm_irqs_off(oldmm, mm, next);\n    &#x2F;&#x2F;寄存器和栈的切换\n    switch_to(prev, next, prev);\n    &#x2F;&#x2F;编译器指令，用于保证switch_to和finish_task_switch的执行顺序，\n    &#x2F;&#x2F;不会因为编译优化而改变\n    barrier();\n    &#x2F;&#x2F;下面这句会从进程A切换到进程B，指令指针寄存器不变，因为进程的调度都最终会调用\n    &#x2F;&#x2F;到 __schedule 函数\n    return finish_task_switch(prev);\n&#125;</code></pre>\n\n<ol>\n<li><p><code>switch_to</code>调用<code>__switch_to_asm</code>（主要用于栈顶指针的切换），有32位和64位两种实现，但最后都返回了<code>__switch_to</code>这个函数，以64位为例：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">__visible __notrace_funcgraph struct task_struct *\n    __switch_to(struct task_struct *prev_p, struct task_struct *next_p)\n&#123;\n    struct thread_struct *prev &#x3D; &amp;prev_p-&gt;thread;\n    struct thread_struct *next &#x3D; &amp;next_p-&gt;thread;\n    int cpu &#x3D; smp_processor_id();\n    &#x2F;&#x2F;通过硬件方式（TSS结构）进行进程切换的模式每一个 CPU 关联一个 TSS，然后将\n    &#x2F;&#x2F;TR（任务寄存器）指向这个 TSS，然后在操作系统的运行过程中，TR 就不切换了\n    &#x2F;&#x2F;永远指向这个 TSS，真正参与进程切换的只有栈顶寄存器等少部分寄存器\n    struct tss_struct *tss &#x3D; &amp;per_cpu(cpu_tss, cpu);\n    load_TLS(next, cpu);\n    this_cpu_write(current_task, next_p);\n    &#x2F;* Reload esp0 and ss1.  This changes current_thread_info(). *&#x2F;\n    load_sp0(tss, next);\n    return prev_p;\n&#125;</code></pre></li>\n<li><p>所谓的进程切换，就是将某个进程的 thread_struct 里面的寄存器的值，写入到 CPU 的 TR 指向的 tss_struct，对于 CPU 来讲，这就算是完成了切换。</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>抢占式调度</p>\n<ol>\n<li>场景一：一个进程执行时间太长了，是时候切换到另一个进程了<ol>\n<li>在计算机里面有一个时钟，会过一段时间触发一次时钟中断，通知操作系统，时间又过去一个时钟周期，时钟中断处理函数会调用 <code>scheduler_tick()</code>。这个函数先取出当前 CPU 的运行队列，然后得到这个队列上当前正在运行中的进程的 task_struct，然后调用这个 task_struct 的调度类的 task_tick 函数</li>\n<li><code>task_tick</code>函数中有<code>check_preempt_tick</code>函数，用来检查是否是时候被抢占了</li>\n<li>当发现当前进程应该被抢占，不能直接把它踢下来，而是把它标记为应该被抢占。因为一定要等待正在运行的进程调用 __schedule 才行，所以这里只能先标记一下。标记一个进程应该被抢占，都是调用 <code>resched_curr</code>，它会调用 <code>set_tsk_need_resched</code>，标记进程应该被抢占，但是此时此刻，并不真的抢占，而是打上一个标签 <code>TIF_NEED_RESCHED</code>。</li>\n</ol>\n</li>\n<li>场景二：当一个进程被唤醒的时候<ol>\n<li>当被唤醒的进程优先级高于 CPU 上的当前进程，就会触发抢占。<code>try_to_wake_up()</code>调用 <code>ttwu_queue</code> 将这个唤醒的任务添加到队列当中。<code>ttwu_queue</code> 再调用 <code>ttwu_do_activate</code> 激活这个任务。<code>ttwu_do_activate</code> 调用 <code>ttwu_do_wakeup</code>。这里面调用了 <code>check_preempt_curr</code>检查是否应该发生抢占。如果应该发生抢占，也不是直接踢走当前进程，而是将当前进程标记为应该被抢占。</li>\n</ol>\n</li>\n<li>抢占的时机（调用 __schedule，见前图）<ol>\n<li>用户态的抢占时机<ol>\n<li>从系统调用中返回的那个时刻，是一个被抢占的时机</li>\n<li>从中断中返回的那个时刻，也是一个被抢占的时机</li>\n</ol>\n</li>\n<li>内核态的抢占时机<ol>\n<li>对内核态的执行中，被抢占的时机一般发生在 preempt_enable() 中。在内核态的执行中，有的操作是不能被中断的，所以在进行这些操作之前，总是先调用 preempt_disable() 关闭抢占，当再次打开的时候，就是一次内核态代码被抢占的机会。</li>\n<li>在内核态也会遇到中断的情况，当中断返回的时候，返回的仍然是内核态。这个时候也是一个执行抢占的时机</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-进程创建\"><a href=\"#5-进程创建\" class=\"headerlink\" title=\"5.进程创建\"></a>5.进程创建<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/9d9c5779436da40cabf8e8599eb85558-16559772021513.jpeg\" alt=\"img\"></h4><ol>\n<li><p>fork系统调用会在 sys_call_table 中找到相应的系统调用 sys_fork，根据 SYSCALL_DEFINE0 这个宏定义，定义了sys_fork，sys_fork 会调用 _do_fork，下面这段代码是_do_fork的定义和实现：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">SYSCALL_DEFINE0(fork)\n&#123;\n    return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);\n&#125;\n\nlong _do_fork(unsigned long clone_flags,unsigned long stack_start,unsigned long stack_size,\n              int __user *parent_tidptr,int __user *child_tidptr,unsigned long tls)&#123;\n    struct task_struct *p;\n    int trace &#x3D; 0;\n    long nr;\n    &#x2F;&#x2F;复制结构\n    p &#x3D; copy_process(clone_flags, stack_start, stack_size,\n                     child_tidptr, NULL, trace, tls, NUMA_NO_NODE);\n\n    if (!IS_ERR(p)) &#123;\n        struct pid *pid;\n        pid &#x3D; get_task_pid(p, PIDTYPE_PID);\n        nr &#x3D; pid_vnr(pid);\n        \n        if (clone_flags &amp; CLONE_PARENT_SETTID)\n            put_user(nr, parent_tidptr);\n\t\t&#x2F;&#x2F;唤醒新进程\n        wake_up_new_task(p);\n        \n        put_pid(pid);\n    &#125; \n&#125;</code></pre></li>\n<li><h5 id=\"fork-的第一件大事：复制结构copy-process\"><a href=\"#fork-的第一件大事：复制结构copy-process\" class=\"headerlink\" title=\"fork 的第一件大事：复制结构copy_process\"></a>fork 的第一件大事：复制结构<code>copy_process</code></h5><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static __latent_entropy struct task_struct *copy_process(\n    unsigned long clone_flags,\n    unsigned long stack_start,\n    unsigned long stack_size,\n    int __user *child_tidptr,\n    struct pid *pid,\n    int trace,\n    unsigned long tls,\n    int node)\n&#123;\n    int retval;\n    struct task_struct *p;\n    &#x2F;&#x2F;复制task_struct并创建内核栈\n    p &#x3D; dup_task_struct(current, node);\n    &#x2F;&#x2F;处理权限相关\n    retval &#x3D; copy_creds(p, clone_flags);\n    &#x2F;&#x2F;重新设置进程运行的统计量\n    p-&gt;utime &#x3D; p-&gt;stime &#x3D; p-&gt;gtime &#x3D; 0;\n    p-&gt;start_time &#x3D; ktime_get_ns();\n    p-&gt;real_start_time &#x3D; ktime_get_boot_ns();\n    &#x2F;&#x2F;设置调度相关的变量\n    retval &#x3D; sched_fork(clone_flags, p);\n    &#x2F;&#x2F;初始化与文件和文件系统相关的变量\n    retval &#x3D; copy_files(clone_flags, p);\n    retval &#x3D; copy_fs(clone_flags, p);\n    &#x2F;&#x2F;初始化与信号相关的变量\n    init_sigpending(&amp;p-&gt;pending);\n    retval &#x3D; copy_sighand(clone_flags, p);\n    retval &#x3D; copy_signal(clone_flags, p);\n    &#x2F;&#x2F;复制进程内存空间\n    retval &#x3D; copy_mm(clone_flags, p);\n    &#x2F;&#x2F;分配 pid，设置 tid，group_leader，并且建立进程之间的亲缘关系。\n    INIT_LIST_HEAD(&amp;p-&gt;children); \n    INIT_LIST_HEAD(&amp;p-&gt;sibling);\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li><p>fork 的第二件大事：唤醒新进程<code>wake_up_new_task</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void wake_up_new_task(struct task_struct *p)\n&#123;\n    struct rq_flags rf;\n    struct rq *rq;\n    &#x2F;&#x2F;将进程的状态设置为 TASK_RUNNING\n    p-&gt;state &#x3D; TASK_RUNNING;\n\t&#x2F;&#x2F;根据调度方法不同，调用不同类（enqueue_task、enqueue_task_fair），唤醒对应进程\n    activate_task(rq, p, ENQUEUE_NOCLOCK);\n    p-&gt;on_rq &#x3D; TASK_ON_RQ_QUEUED;\n    trace_sched_wakeup_new(p);\n    &#x2F;&#x2F;看是否能够抢占当前进程，调用check_preempt_wakeup，这和函数里的wakeup_preempt_entity \n    &#x2F;&#x2F;将父进程和子进程 PK 一次，看是不是要抢占，如果要则调用 resched_curr 标记父进程为 TIF_NEED_RESCHED\n    check_preempt_curr(rq, p, WF_FORK);\n    &#x2F;&#x2F;......\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"6-线程创建\"><a href=\"#6-线程创建\" class=\"headerlink\" title=\"6.线程创建\"></a>6.线程创建<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/14635b1613d04df9f217c3508ae8524b.jpeg\" alt=\"img\"></h4><ol>\n<li><p>用户态创建线程<code>pthread_create.c</code>，调用<code>create_thread</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int __pthread_create_2_1 (pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)&#123;\n\t&#x2F;&#x2F;处理线程的属性参数\n    const struct pthread_attr *iattr &#x3D; (struct pthread_attr *) attr;\n    struct pthread_attr default_attr;\n    if (iattr &#x3D;&#x3D; NULL)&#123;&#x2F;&#x2F;如果没有传入线程属性，就取默认值\n        iattr &#x3D; &amp;default_attr;\n    &#125;\n    &#x2F;&#x2F;维护一个task_struct 结构\n    struct pthread *pd &#x3D; NULL;\n    &#x2F;&#x2F;创建线程栈\n    int err &#x3D; ALLOCATE_STACK (iattr, &amp;pd);\n    &#x2F;&#x2F;确定用户态程序从哪里开始运行\n    &#x2F;&#x2F;start_routine 就是给线程的函数，start_routine，start_routine 的参数 arg，\n    &#x2F;&#x2F;以及调度策略都要赋值给 pthread。\n    pd-&gt;start_routine &#x3D; start_routine;\n    pd-&gt;arg &#x3D; arg;\n    pd-&gt;schedpolicy &#x3D; self-&gt;schedpolicy;\n    pd-&gt;schedparam &#x3D; self-&gt;schedparam;\n    &#x2F;* Pass the descriptor to the caller.  *&#x2F; \n    *newthread &#x3D; (pthread_t) pd;\n    &#x2F;&#x2F; __nptl_nthreads 加一，说明又多了一个线程。\n    atomic_increment (&amp;__nptl_nthreads);\n    &#x2F;&#x2F;真正创建线程\n    retval &#x3D; create_thread (pd, iattr, &amp;stopped_start, STACK_VARIABLES_ARGS, &amp;thread_ran);\n&#125;\n\nstatic int\n    create_thread (struct pthread *pd, const struct pthread_attr *attr,\n                   bool *stopped_start, STACK_VARIABLES_PARMS, bool *thread_ran)\n&#123;\n    const int clone_flags &#x3D; (CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SYSVSEM | CLONE_SIGHAND | CLONE_THREAD | CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | 0);\n    &#x2F;&#x2F;ARCH_CLONE，其实调用的是 __clone\n    &#x2F;&#x2F;当系统调用返回到用户态的时候，用户态的栈应该是线程的栈，栈顶指针应该指向线程的栈，指令指针应该指向\n    &#x2F;&#x2F;线程将要执行的那个函数。所以这些都需要我们自己做，将线程要执行的函数的参数和指令的\t位置都压到栈里面\n    ARCH_CLONE (&amp;start_thread, STACK_VARIABLES_ARGS, clone_flags, pd, &amp;pd-&gt;tid, tp, &amp;pd-&gt;tid)；\n        &#x2F;* It&#39;s started now, so if we fail below, we&#39;ll have to cancel it and let it clean itself up.  *&#x2F;\n        *thread_ran &#x3D; true;\n&#125;\n\n</code></pre></li>\n<li><p>接下来我们就要进入内核了。创建线程的话，调用的是系统调用 clone，在 copy_process 函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。内核里面对于 clone 系统调用的定义是这样的：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n     int __user *, parent_tidptr,\n     int __user *, child_tidptr,\n     unsigned long, tls)\n&#123;\n  return _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);\n&#125;</code></pre></li>\n<li><p>用户态执行线程：根据 __clone 的第一个参数，回到用户态也不是直接运行我们指定的那个函数，而是一个通用的 start_thread，这是所有线程在用户态的统一入口。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define START_THREAD_DEFN \\\n  static int __attribute__ ((noreturn)) start_thread (void *arg)\n\nSTART_THREAD_DEFN\n&#123;\n    struct pthread *pd &#x3D; START_THREAD_SELF;\n    &#x2F;* Run the code the user provided.  *&#x2F;\n    THREAD_SETMEM (pd, result, pd-&gt;start_routine (pd-&gt;arg));\n    &#x2F;* Call destructors for the thread_local TLS variables.  *&#x2F;\n    &#x2F;* Run the destructor for the thread-local data.  *&#x2F;\n    __nptl_deallocate_tsd ();\n    if (__glibc_unlikely (atomic_decrement_and_test (&amp;__nptl_nthreads)))\n        &#x2F;* This was the last thread.  *&#x2F;\n        exit (0);\n    &#x2F;&#x2F;__free_tcb 用于释放 pthread。\n    __free_tcb (pd);\n    __exit_thread ();\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"4-内存管理-1\"><a href=\"#4-内存管理-1\" class=\"headerlink\" title=\"4.内存管理\"></a>4.内存管理</h3><h4 id=\"1-内存管理\"><a href=\"#1-内存管理\" class=\"headerlink\" title=\"1.内存管理\"></a>1.内存管理</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>内存已经被分成一块一块的，并且编好了地址，通过地址可以定位到物理内存的位置。但是物理地址对于进程不可见，指令操作的地址是操作系统分配的虚拟地址，操作系统会通过一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来，以供互相转换。</p></blockquote>\n<ol>\n<li><p>虚拟地址空间容量：如果是 32 位，有 2^32 = 4G 的内存空间，不管内存是不是真的有 4G。如果是 64 位，在 x86_64 下面，只使用了 48 位，48 位地址长度有256TB 的地址空间。</p>\n</li>\n<li><p>虚拟地址空间划分：内核空间（用来存放内核相关，在低地址）、用户空间（用来存放进程相关，在高地址）</p>\n<ol>\n<li>用户空间地址名称，从低位开始0-&gt;X：<ul>\n<li>Text Segment：存二进制可执行代码</li>\n<li>Data Segment：存静态常量</li>\n<li>BSS Segment：存未初始化的静态常量</li>\n<li>Heap（堆段）：往高地址增长，用来动态分配内存的区域</li>\n<li>Memory Mapping Segment：用来把文件映射到内存，例如将动态链接库（so文件）映射到内存中</li>\n<li>Stack（栈段）：向低地址增长，主线程的函数调用的函数栈</li>\n</ul>\n</li>\n<li>内核空间，从X-&gt;N：<ul>\n<li>用户空间不同进程内容不同，但是一旦调用系统调用，进入内核，看到的都是同一个内核空间，所以要访问公共的数据结构需要锁保护</li>\n<li>内核里面也会有内核的代码，同样有 Text Segment、Data Segment 和 BSS Segment，因为内核代码也是 ELF 格式的</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>如何将虚拟地址映射为物理地址</p>\n<ol>\n<li><p>分段机制：将虚拟空间分成多个段（不同大小）进行保存，虚拟地址由段选择子和段内偏移量组成，段选择子里有段号作为段表的索引，段表中保存着段基地址、段界限、特权等级。物理内存地址=段基地址+段内偏移量</p>\n</li>\n<li><p>Linux的分段（所有段的起始地址为0）：</p>\n<ol>\n<li><p>段表全称段描述符表（segment descriptors），放在全局描述符表GDT（Global Descriptor Table）里面，会有下面的宏来初始化段描述符表里面的表项，一个段表项由段基地址base、段界限limit，和一些其它标识符组成：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define GDT_ENTRY_INIT(flags, base, limit) &#123; &#123; &#123; \\\n    .a &#x3D; ((limit) &amp; 0xffff) | (((base) &amp; 0xffff) &lt;&lt; 16), \\\n    .b &#x3D; (((base) &amp; 0xff0000) &gt;&gt; 16) | (((flags) &amp; 0xf0ff) &lt;&lt; 8) | \\\n      ((limit) &amp; 0xf0000) | ((base) &amp; 0xff000000), \\\n  &#125; &#125; &#125;</code></pre></li>\n<li><p>对于64位和32位，都定义了内核代码段、内核数据段、用户代码段、用户数据段</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">DEFINE_PER_CPU_PAGE_ALIGNED(struct gdt_page, gdt_page) &#x3D; &#123; .gdt &#x3D; &#123;\n#ifdef CONFIG_X86_64\n  [GDT_ENTRY_KERNEL32_CS]    &#x3D; GDT_ENTRY_INIT(0xc09b, 0, 0xfffff),\n  [GDT_ENTRY_KERNEL_CS]    &#x3D; GDT_ENTRY_INIT(0xa09b, 0, 0xfffff),\n  [GDT_ENTRY_KERNEL_DS]    &#x3D; GDT_ENTRY_INIT(0xc093, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER32_CS]  &#x3D; GDT_ENTRY_INIT(0xc0fb, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_DS]  &#x3D; GDT_ENTRY_INIT(0xc0f3, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_CS]  &#x3D; GDT_ENTRY_INIT(0xa0fb, 0, 0xfffff),\n#else\n  [GDT_ENTRY_KERNEL_CS]    &#x3D; GDT_ENTRY_INIT(0xc09a, 0, 0xfffff),\n  [GDT_ENTRY_KERNEL_DS]    &#x3D; GDT_ENTRY_INIT(0xc092, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_CS]  &#x3D; GDT_ENTRY_INIT(0xc0fa, 0, 0xfffff),\n  [GDT_ENTRY_DEFAULT_USER_DS]  &#x3D; GDT_ENTRY_INIT(0xc0f2, 0, 0xfffff),\n......\n#endif\n&#125; &#125;;\nEXPORT_PER_CPU_SYMBOL_GPL(gdt_page);</code></pre></li>\n<li><p>还会定义四个段选择子，指向上面的段描述符表项。（内核初始化时，启动第一个用户态进程，就将这四个值赋值给段寄存器）：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#define __KERNEL_CS      (GDT_ENTRY_KERNEL_CS*8)\n#define __KERNEL_DS      (GDT_ENTRY_KERNEL_DS*8)\n#define __USER_DS      (GDT_ENTRY_DEFAULT_USER_DS*8 + 3)\n#define __USER_CS      (GDT_ENTRY_DEFAULT_USER_CS*8 + 3)</code></pre></li>\n</ol>\n</li>\n<li><p>Linux的分页（Paging）：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/abbcafe962d93fac976aa26b7fcb7440.jpg\" alt=\"img\"></p>\n<ol>\n<li>把物理内存都分成了大小相同的页（4KB），在硬盘和内存间进行换入、换出操作</li>\n<li>虚拟地址分为两部分，页号和页内偏移，页号作为页表的索引，页表包含物理页每页所在物理内存的基地址。这个基地址与页内偏移的组合就形成了物理内存地址。</li>\n<li>由于页表项太多，并且要求是连续的，所以将页表再分页：<ul>\n<li>对于32位系统：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220702220644898.png\" alt=\"image-20220702220644898\"></li>\n<li>对于64位系统：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/42eff3e7574ac8ce2501210e25cd2c0b.jpg\" alt=\"img\"></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-进程空间管理\"><a href=\"#2-进程空间管理\" class=\"headerlink\" title=\"2.进程空间管理\"></a>2.进程空间管理</h4><ol>\n<li><p>用户态和内核态的划分</p>\n<ol>\n<li><code>task_struct</code>中有一个 <code>struct mm_struct *mm</code>用来管理内存，在其中有一个<code>task_size</code>成员变量，用来定义用户地址空间和内核地址空间的分界线。<ol>\n<li>对于32位系统，用户态虚拟地址空间是3G，内核态是1G</li>\n<li>对于64位系统，虚拟地址只使用了48位，用户态用户态用了低地址的128T，内核态用了高地址的128T，中间的空隙用来进行隔离</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>用户态布局<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/7af58012466c7d006511a7e16143314c.jpeg\" alt=\"img\"></p>\n<ol>\n<li><p>在<code>struct mm_struct *mm</code>里面，通过变量定义了如代码、全局变量、堆、栈、内存映射区等区域的统计信息和位置</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F; 表示虚拟地址空间中用于内存映射的起始地址 一般情况下，这个空间是从高地址到低地址\n&#x2F;&#x2F;增长的。 malloc 申请一大块内存的时候，就是通过 mmap 在这里映射一块区域到物理内存。\n&#x2F;&#x2F;加载动态链接库 so 文件，也是在这个区域里面，映射一块区域到 so 文件\nunsigned long mmap_base; \nunsigned long total_vm;    &#x2F;* Total pages mapped ,物理内存不够时有些页可以换出*&#x2F;\nunsigned long locked_vm;  &#x2F;* 被锁定不能换出*&#x2F;\nunsigned long pinned_vm;  &#x2F;*不能换出，不能移动 *&#x2F;\nunsigned long data_vm;    &#x2F;* 存放数据的页的数目 *&#x2F;\nunsigned long exec_vm;    &#x2F;* 存放可执行文件的页的数目 *&#x2F;\nunsigned long stack_vm;    &#x2F;* 栈所占的页的数目*&#x2F;\n&#x2F;&#x2F;start_code, end_code 表示可执行代码的开始和结束位置\n&#x2F;&#x2F;start_data, end_data 表示已初始化数据的开始位置和结束位置\nunsigned long start_code, end_code, start_data, end_data;\n&#x2F;&#x2F;start_brk 堆的起始位置, brk 堆当前的结束位置（malloc）, start_stack 栈的起始位置\nunsigned long start_brk, brk, start_stack;\n&#x2F;&#x2F;arg_start, arg_end  参数列表的位置,env_start, env_end环境变量的位置位于栈中最高地址\nunsigned long arg_start, arg_end, env_start, env_end;\n\n\n&#x2F;&#x2F;用来描述上面区域的属性，是一个单链表，用于将这些区域串起来，另外还有一个红黑树，\n&#x2F;&#x2F;为了快速查找内存。在进程调度的时候用的也是红黑树（查找和删除都很快），代码见下\nstruct vm_area_struct *mmap; &#x2F;* list of VMAs *&#x2F;\nstruct rb_root mm_rb;\n\nstruct vm_area_struct &#123;\n    &#x2F;*vm_start ，vm_end 制定了该区域在用户空间中的起始和结束地址*&#x2F;\n    unsigned long vm_start;    &#x2F;* Our start address within vm_mm. *&#x2F;\n    unsigned long vm_end;    &#x2F;* The first byte after our end address within vm_mm. *&#x2F;\n    &#x2F;* *vm_next, *vm_prev 将这个区域串在链表上*&#x2F;\n    struct vm_area_struct *vm_next, *vm_prev;\n\t&#x2F;* vm_rb将这个区域放在红黑树上*&#x2F;\n    struct rb_node vm_rb;\n    struct mm_struct *vm_mm;  &#x2F;* The address space we belong to. *&#x2F;\n    struct list_head anon_vma_chain; &#x2F;* Serialized by mmap_sem &amp;* page_table_lock *&#x2F;\n    struct anon_vma *anon_vma;  &#x2F;* 映射到物理内存的虚拟内存区域，也称匿名映射*&#x2F;\n    &#x2F;* 对这个内存区域可以做的操作的定义*&#x2F;\n    const struct vm_operations_struct *vm_ops;\n    struct file * vm_file;    &#x2F;* 映射到文件就需要vm_file指定被映射的文件 *&#x2F;\n    void * vm_private_data;    &#x2F;* was vm_pte (shared mem) *&#x2F;\n&#125; __randomize_layout;</code></pre></li>\n<li><p><code>vm_area_struct</code>如何映射到<code>mm_struct</code>的内存区域，这个事情是在 <code>load_elf_binary</code> 里面实现的。加载内核的是它，启动第一个用户态进程 init 的是它，fork 完了以后，调用 exec 运行一个二进制程序的也是它。当 exec 运行一个二进制程序的时候，除了解析 ELF 的格式之外，另外一个重要的事情就是建立内存映射。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static int load_elf_binary(struct linux_binprm *bprm)\n&#123;\n    &#x2F;&#x2F;设置内存映射区mmap_base\n    setup_new_exec(bprm);\n    &#x2F;&#x2F;设置栈的vm_area_struct，这里面设置了 mm-&gt;arg_start 是指向栈底的，\n    &#x2F;&#x2F;current-&gt;mm-&gt;start_stack 就是栈底\n    retval &#x3D; setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),\n                             executable_stack);\n    &#x2F;&#x2F;将 ELF 文件中的代码部分映射到内存中来\n    error &#x3D; elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,\n                    elf_prot, elf_flags, total_size);\n    &#x2F;&#x2F;设置了堆的 vm_area_struct，这里面设置了 ：\n    &#x2F;&#x2F;current-&gt;mm-&gt;start_brk &#x3D; current-&gt;mm-&gt;brk，也即堆里面还是空的\n    retval &#x3D; set_brk(elf_bss, elf_brk, bss_prot);\n    &#x2F;&#x2F;将依赖的 so 映射到内存中的内存映射区域\n    elf_entry &#x3D; load_elf_interp(&amp;loc-&gt;interp_elf_ex,\n                                interpreter,\n                                &amp;interp_map_addr,\n                                load_bias, interp_elf_phdata);\n    &#x2F;&#x2F;......\n    current-&gt;mm-&gt;end_code &#x3D; end_code;\n    current-&gt;mm-&gt;start_code &#x3D; start_code;\n    current-&gt;mm-&gt;start_data &#x3D; start_data;\n    current-&gt;mm-&gt;end_data &#x3D; end_data;\n    current-&gt;mm-&gt;start_stack &#x3D; bprm-&gt;p;\n    &#x2F;&#x2F;......\n&#125;</code></pre></li>\n<li><p>修改以上布局的时机：</p>\n<ol>\n<li>函数调用：涉及函数栈的改变，主要是改变栈顶指针</li>\n<li>通过malloc申请一个堆内的空间，底层要么执行brk，要么执行mmap<ol>\n<li>brk系统调用的入口是<code>sys_brk</code>，此函数的参数brk是新的堆顶位置，而当前的<code>mm-&gt;brk</code>是原来堆顶的位置。首先按照页对齐地址看是否在一个页里，如果在就直接设置<code>mm-&gt;brk</code>为新的brk，如果不在同一页，则根据堆顶大小判断是释放内存（<code>do_munmap</code>）还是扩大内存（<code>fina_vma</code>，内存不够返回或者调用<code>do_brk</code>分配内存）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>内核态的布局</p>\n<ol>\n<li>32位<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/83a6511faf802014fbc2c02afc397a04.jpg\" alt=\"img\"><ol>\n<li>直接映射区：空间连续，地址减去3G就是物理内存的位置，即在物理内存的开始的 896M 的空间，会被直接映射到 3G 至 3G+896M 的虚拟地址</li>\n<li>在系统启动的时候，物理内存的前 1M 已经被占用了，从 1M 开始加载内核代码段，然后就是内核的全局变量、BSS 等，也是 ELF 里面涵盖的。这样内核的代码段，全局变量，BSS 也就会被映射到 3G 后的虚拟地址空间里面。具体的物理内存布局可以查看 /proc/iomem</li>\n<li>在内核运行的过程中，如果碰到系统调用创建进程，会创建 task_struct 这样的实例，内核的进程管理代码会将实例创建在 3G 至 3G+896M 的虚拟空间中</li>\n<li>如果电脑内存小于3G，那么内核能使用的虚拟内存地址，只剩下1G减去896M的空间，于是将剩下的虚拟内存地址分成如下几个部分：<ol>\n<li>VMALLOC_START 到 VMALLOC_END 之间称为内核动态映射空间，也即内核想像用户态进程一样 malloc 申请内存，在内核里面可以使用 vmalloc。内存过小时，剩下的物理地址就靠这一段的虚拟地址进行映射</li>\n<li>PKMAP_BASE 到 FIXADDR_START 的空间称为持久内核映射。使用 alloc_pages() 函数的时候，在物理内存的高端内存得到 struct page 结构，可以调用 kmap 将其映射到这个区域。</li>\n<li>FIXADDR_START 到 FIXADDR_TOP(0xFFFF F000) 的空间，称为固定映射区域，主要用于满足特殊需求。</li>\n<li>在最后一个区域可以通过 kmap_atomic 实现临时内核映射。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>64位<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/7eaf620768c62ff53e5ea2b11b4940f6.jpg\" alt=\"img\"><ol>\n<li>从 0xffff800000000000 开始就是内核的部分，只不过一开始有 8T 的空档区域。</li>\n<li>从 __PAGE_OFFSET_BASE(0xffff880000000000) 开始的 64T 的虚拟地址空间是直接映射区域，也就是减去 PAGE_OFFSET 就是物理地址。</li>\n<li>从 VMALLOC_START（0xffffc90000000000）开始到 VMALLOC_END（0xffffe90000000000）的 32T 的空间是给 vmalloc 的。</li>\n<li>从 VMEMMAP_START（0xffffea0000000000）开始的 1T 空间用于存放物理页面的描述结构 struct page 的。</li>\n<li>从 __START_KERNEL_map（0xffffffff80000000）开始的 512M 用于存放内核代码段、全局变量、BSS 等。这里对应到物理内存开始的位置，减去 __START_KERNEL_map 就能得到物理内存的地址。这里和直接映射区有点像，但是不矛盾，因为直接映射区之前有 8T 的空当区域，早就过了内核代码在物理内存中加载的位置。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-物理内存管理\"><a href=\"#3-物理内存管理\" class=\"headerlink\" title=\"3.物理内存管理\"></a>3.物理内存管理</h4><ol>\n<li><p>物理内存的组织方式</p>\n<ol>\n<li>平坦内存模型（Flat Memory Model）：连续的一页一页组成，每个页大小相同，对于任何一个地址，只要直接除一下每页的大小，就很容易算出在哪一页</li>\n<li>SMP（Symmetric multiprocessing 对称多处理器）：通过总线连接多个CPU和多个内存条组成的一大片内存，但是总线会成为瓶颈</li>\n<li>NUMA（Non-uniform memory acess 非一致内存访问）：每个CPU都有自己的本地内存，CPU访问本地内存不用过总线，每个CPU和内存在一起称为NUMA节点，这个时候就需要非连续内存模型</li>\n</ol>\n</li>\n<li><p>NUMA节点：用<code>typedef struct pglist_data pg_data_t</code>来表示NUMA节点，有以下成员变量：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct pglist_data &#123;\n    &#x2F;&#x2F;每一个节点分成一个个区域 zone，放在数组 node_zones 里面。大小为 MAX_NR_ZONES\n    struct zone node_zones[MAX_NR_ZONES];\n    &#x2F;&#x2F;备用节点和它的内存区域的情况，NUMA自己的内存不够可以去其他节点进行分配\n    struct zonelist node_zonelists[MAX_ZONELISTS];\n    int nr_zones;\n    &#x2F;&#x2F;这个节点的 struct page 数组，用于描述这个节点里面的所有的页\n    struct page *node_mem_map;\n    &#x2F;&#x2F; 是这个节点的起始页号\n    unsigned long node_start_pfn;\n    &#x2F;&#x2F;是真正可用的物理页面的数目\n    unsigned long node_present_pages; &#x2F;* total number of physical pages *&#x2F;\n    &#x2F;&#x2F;个节点中包含不连续的物理内存地址的页面数\n    unsigned long node_spanned_pages; &#x2F;* total size of physical page range, including holes *&#x2F;\n    &#x2F;&#x2F;每一个节点都有自己的 ID\n    int node_id;\n    &#x2F;&#x2F;......\n&#125; pg_data_t;\n\n&#x2F;&#x2F;区域enum的类型\nenum zone_type &#123;\n    #ifdef CONFIG_ZONE_DMA\n    \t&#x2F;&#x2F;DMA，直接内存存取内存，用于DMA机制\n    \tZONE_DMA,\n    #endif\n    #ifdef CONFIG_ZONE_DMA32\n    \t&#x2F;&#x2F;对于64位OS有两块DMA内存\n   \t\tZONE_DMA32,\n    #endif\n    \t&#x2F;&#x2F;直接映射区，从物理内存到虚拟内存的内核区域，通过加上一个常量直接映射\n    \tZONE_NORMAL,\n    #ifdef CONFIG_HIGHMEM\n    \t&#x2F;&#x2F;高端内存区，对于32位系统来说超过896M的地方，64位没有\n    \tZONE_HIGHMEM,\n    #endif\n    \t&#x2F;&#x2F;可移动区域，通过将物理内存划分为可移动分配区域和不可移动分配区域来避免内存碎片\n    \tZONE_MOVABLE,\n    \t&#x2F;&#x2F;当前节点的区域数量\n    \t__MAX_NR_ZONES\n&#125;;</code></pre></li>\n<li><p>区域：节点分成了区域，用zone表示区域</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct zone &#123;\n    \n    struct pglist_data  *zone_pgdat;\n    &#x2F;&#x2F;用于区分冷热页，如果一个页被加载到 CPU 高速缓存里面，这就是一个热页（Hot Page），\n    &#x2F;&#x2F;CPU 读起来速度会快很多，如果没有就是冷页（Cold Page）\n    struct per_cpu_pageset __percpu *pageset;\n\n\t&#x2F;&#x2F;表示属于这个zone的第一个页\n    unsigned long    zone_start_pfn;\n\n    &#x2F;&#x2F;present_pages &#x3D; spanned_pages - absent_pages(pages in holes);真实存在的page数目\n    unsigned long    managed_pages;\n    &#x2F;&#x2F;spanned_pages &#x3D; zone_end_pfn - zone_start_pfn;中间会出现物理空洞\n    unsigned long    spanned_pages;\n    &#x2F;&#x2F;managed_pages &#x3D; present_pages - reserved_pages;本zone被伙伴系统管理的所有page数目\n    unsigned long    present_pages;\n\n    const char    *name;\n    \n    &#x2F;* free areas of different sizes *&#x2F;\n    &#x2F;&#x2F;页分配，伙伴系统，MAX_ORDER为11\n    struct free_area  free_area[MAX_ORDER];\n\n    &#x2F;* zone flags, see below *&#x2F;\n    unsigned long    flags;\n\n    &#x2F;* Primarily protects free_area *&#x2F;\n    spinlock_t    lock;\n    &#x2F;&#x2F;......\n&#125; ____cacheline_internodealigned_in_</code></pre></li>\n<li><p>页及页的分配</p>\n<ol>\n<li><p>页：</p>\n<ul>\n<li>第一种模式，要用就用一整页。这一整页的内存，或者直接和虚拟地址空间建立映射关系，称为匿名页（Anonymous Page）。或者用于关联一个文件，然后再和虚拟地址空间建立映射关系，这样的文件，我们称为内存映射文件（Memory-mapped File）。</li>\n<li>第二种模式，仅需分配小块内存。例如分配一个 task_struct 结构，只需要分配小块的内存，去存储这个进程描述结构的对象。 slab allocator 技术，用于分配称为 slab 的一小块内存。它的基本原理是从内存管理模块申请一整块页，然后划分成多个小块的存储池，用复杂的队列来维护这些小块的状态（状态包括：被分配了 / 被放回池子 / 应该被回收）。</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">struct page &#123;\n    unsigned long flags;\n    union &#123;\n        &#x2F;&#x2F;用于内存映射，如果是匿名页最低位为1，如果是映射文件最低为为0\n        struct address_space *mapping;  \n        &#x2F;&#x2F;模式二，已经分配了正在使用的slab的第一个对象\n        void *s_mem;      &#x2F;* slab first object *&#x2F;\n        atomic_t compound_mapcount;  &#x2F;* first tail page *&#x2F;\n    &#125;;\n    union &#123;\n        &#x2F;&#x2F;模式一，映射区的偏移量\n        pgoff_t index;    &#x2F;* Our offset within mapping. *&#x2F;\n        &#x2F;&#x2F;模式二，池子中的空闲对象\n        void *freelist;    &#x2F;* sl[aou]b first free object *&#x2F;\n    &#125;;\n    union &#123;\n        unsigned counters;\n        struct &#123;\n            union &#123;\n                &#x2F;&#x2F;模式一，每个进程都有自己的页表，这里指有多少个页表项指向了这个页\n                atomic_t _mapcount;\n                unsigned int active;    &#x2F;* SLAB *&#x2F;\n                struct &#123;      &#x2F;* SLUB *&#x2F;\n                    unsigned inuse:16;\n                    unsigned objects:15;\n                    unsigned frozen:1;\n                &#125;;\n                int units;      &#x2F;* SLOB *&#x2F;\n            &#125;;\n            atomic_t _refcount;\n        &#125;;\n    &#125;;\n    union &#123;\n        &#x2F;&#x2F;模式一，表示这一页应该在一个链表上，例如这个页面被换出，就在换出页的链表中\n        struct list_head lru;  &#x2F;* Pageout list   *&#x2F;\n        struct dev_pagemap *pgmap; \n        struct &#123;    &#x2F;* slub per cpu partial pages *&#x2F;\n            struct page *next;  &#x2F;* Next partial slab *&#x2F;\n            int pages;  &#x2F;* Nr of partial slabs left *&#x2F;\n            int pobjects;  &#x2F;* Approximate # of objects *&#x2F;\n        &#125;;\n        &#x2F;&#x2F;模式二，需要释放的列表\n        struct rcu_head rcu_head;\n        struct &#123;\n            unsigned long compound_head; &#x2F;* If bit zero is set *&#x2F;\n            unsigned int compound_dtor;\n            unsigned int compound_order;\n        &#125;;\n    &#125;;\n    union &#123;\n        unsigned long private;\n        struct kmem_cache *slab_cache;  &#x2F;* SL[AU]B: Pointer to slab *&#x2F;\n    &#125;;\n   &#x2F;&#x2F; ......\n&#125;</code></pre></li>\n<li><p>页的分配</p>\n<ol>\n<li><p>伙伴系统（Buddy System）：分配比较大的内存，例如页级别的。把所有的空闲页分组为 11 个页块链表，每个块链表分别包含很多个大小的页块，有 1、2、4、8、16、32、64、128、256、512 和 1024 个连续页的页块。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/2738c0c98d2ed31cbbe1fdcba01142cf.jpeg\" alt=\"img\"></p>\n</li>\n<li><p>分配：先找合适的，没有则分裂大的</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">static inline struct page *\n    alloc_pages(gfp_t gfp_mask, unsigned int order)\n&#123;\n    return alloc_pages_current(gfp_mask, order);\n&#125;\n&#x2F;**\n *   alloc_pages_current - Allocate pages.\n *  gfp表示希望在哪个区域中分配这个内存\n *  @gfp:\n *    %GFP_USER   用于分配一个页映射到用户进程的虚拟地址空间\n *        %GFP_KERNEL 用于内核中分配页，主要分配ZONE_NORMAL\n *        %GFP_HIGHMEM 主要分配高端区域的内存\n *        %GFP_FS     don&#39;t call back into a file system.\n *        %GFP_ATOMIC don&#39;t sleep.\n *  @order: 表示分配2的order次方个页\n *&#x2F;\nstruct page *alloc_pages_current(gfp_t gfp, unsigned order)\n&#123;\n    struct mempolicy *pol &#x3D; &amp;default_policy;\n    struct page *page;\n    &#x2F;&#x2F;核心方法，在一个循环中先看当前节点的zone，如果找不到空闲页，则再看备用节点\n    &#x2F;&#x2F;的zone。每一个zone都有伙伴系统维护的各种大小的队列\n    page &#x3D; __alloc_pages_nodemask(gfp, order,\n                                  policy_node(gfp, pol, numa_node_id()),\n                                  policy_nodemask(gfp, pol));\n    &#x2F;&#x2F;......\n    return page;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>小内存的分配（slub分配器）：将从伙伴系统申请的大内存切成小内存，分配给其它系统</p>\n<ol>\n<li>在创建进程复制一个<code>task_struct</code>时，调用了<code>kmem_cache_alloc_node</code>函数，在<code>task_struct</code>的缓存区域<code>task_struct_cachep</code>分配了一块内存</li>\n<li>在系统初始化的时候，<code>task_struct</code>对象被分配了名字为<code>task_struct</code>的缓存，缓存区每一块的大小正好等于<code>task_struct</code>的大小，每次创建<code>task_struct</code>的时候，<code>kmem_cache_alloc_node</code>现在缓存里找内存来分配。当一个进程结束，<code>task_struct</code> 也不用直接被销毁，而是放回到缓存中，这就是 <code>kmem_cache_free</code> 的作用。</li>\n<li>在分配缓存块的时候，要分两种路径，fast path 和 slow path，也就是快速通道和普通通道。其中 kmem_cache_cpu 就是快速通道，kmem_cache_node 是普通通道。每次分配的时候，要先从 kmem_cache_cpu 进行分配。如果 kmem_cache_cpu 里面没有空闲的块，那就到 kmem_cache_node 中进行分配；如果还是没有空闲的块，才去伙伴系统分配新的页。</li>\n</ol>\n</li>\n<li><p>页面换出</p>\n<ol>\n<li><p>分配内存时没有地方了，试图回收一下。申请一个页面的时候，会调用 <code>get_page_from_freelist</code>，接下来的调用链为 <code>get_page_from_freelist-&gt;node_reclaim-&gt;__node_reclaim-&gt;shrink_node</code>，通过这个调用链可以看出，页面换出也是以内存节点为单位的</p>\n</li>\n<li><p>内存管理系统主动去做的：<code>kswapd</code>，在系统初始化的时候就被创建。这样它会进入一个无限循环，直到系统停止。在这个循环中，如果内存使用没有那么紧张，那就不需要他；如果内存紧张了，就需要去检查一下内存，看看是否需要换出一些内存页</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;*\n * The background pageout daemon, started as a kernel thread\n * from the init process.\n *\n * This basically trickles out pages so that we have _some_\n * free memory available even if there is no other activity\n * that frees anything up. This is needed for things like routing\n * etc, where we otherwise might have all activity going on in\n * asynchronous contexts that cannot page things out.\n *\n * If there are applications that are active memory-allocators\n * (most normal use), this basically shouldn&#39;t matter.\n *&#x2F;\nstatic int kswapd(void *p)\n&#123;\n    unsigned int alloc_order, reclaim_order;\n    unsigned int classzone_idx &#x3D; MAX_NR_ZONES - 1;\n    pg_data_t *pgdat &#x3D; (pg_data_t*)p;\n    struct task_struct *tsk &#x3D; current;\n\n\n    for ( ; ; ) &#123;\n        &#x2F;&#x2F;......\n        kswapd_try_to_sleep(pgdat, alloc_order, reclaim_order,\n                            classzone_idx);\n        &#x2F;&#x2F;这里的调用链是 balance_pgdat-&gt;kswapd_shrink_node-&gt;shrink_node，\n        &#x2F;&#x2F;是以内存节点为单位的，最后也是调用 shrink_node\n        reclaim_order &#x3D; balance_pgdat(pgdat, alloc_order, classzone_idx);\n        &#x2F;&#x2F;shrink_node会调用shrink_node_memcg，这里有一个循环处理页面的lru列表\n    &#125;\n&#125;\n</code></pre></li>\n<li><p>内存页总共分两类，一类是匿名页，和虚拟地址空间进行关联；一类是内存映射，不但和虚拟地址空间关联，还和文件管理关联。它们每一类都有两个列表，一个是 active，一个是 inactive。顾名思义，active 就是比较活跃的，inactive 就是不怎么活跃的。这两个里面的页会变化，过一段时间，活跃的可能变为不活跃，不活跃的可能变为活跃。如果要换出内存，那就是从不活跃的列表中找出最不活跃的，换出到硬盘上。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-用户态内存映射\"><a href=\"#4-用户态内存映射\" class=\"headerlink\" title=\"4.用户态内存映射\"></a>4.用户态内存映射</h4><ol>\n<li><p>mmap原理</p>\n<ol>\n<li><p>用途：申请一大块内存、文件映射到进程的虚拟内存空间</p>\n</li>\n<li><p>映射到文件：mmap收到一个文件描述符，通过描述符获得struct file，然后依次调用<code>sys_mmap_pgoff-&gt;do_mmap_pgoff-&gt;do_mmap</code>，在这之中有两个主要操作：</p>\n<ul>\n<li><p>调用<code>get_unmapped_area</code>来找到一个没有映射的区域，无论是匿名映射还是映射到文件，最后都会调用<code>mm_struct</code>里面的<code>get_unmapped_area</code></p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;匿名映射\nunsigned long\n    get_unmapped_area(struct file *file, unsigned long addr, unsigned long len,\n                      unsigned long pgoff, unsigned long flags)\n&#123;\n    unsigned long (*get_area)(struct file *, unsigned long,\n                              unsigned long, unsigned long, unsigned long);\n    get_area &#x3D; current-&gt;mm-&gt;get_unmapped_area;\n    if (file) &#123;\n        if (file-&gt;f_op-&gt;get_unmapped_area)\n            get_area &#x3D; file-&gt;f_op-&gt;get_unmapped_area;\n    &#125; \n&#125;\n&#x2F;&#x2F;映射到文件\nconst struct file_operations ext4_file_operations &#x3D; &#123;\n    .mmap           &#x3D; ext4_file_mmap\n        .get_unmapped_area &#x3D; thp_get_unmapped_area,\n&#125;;\nunsigned long __thp_get_unmapped_area(struct file *filp, unsigned long len,\n                                      loff_t off, unsigned long flags, unsigned long size)\n&#123;\n    unsigned long addr;\n    loff_t off_end &#x3D; off + len;\n    loff_t off_align &#x3D; round_up(off, size);\n    unsigned long len_pad;\n    len_pad &#x3D; len + size;\n    &#x2F;&#x2F;......\n    addr &#x3D; current-&gt;mm-&gt;get_unmapped_area(filp, 0, len_pad,\n                                          off &gt;&gt; PAGE_SHIFT, flags);\n    addr +&#x3D; (off - addr) &amp; (size - 1);\n    return addr;\n&#125;</code></pre></li>\n<li><p>调用<code>mmap_region</code>来映射这个虚拟内存区域，</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">unsigned long mmap_region(struct file *file, unsigned long addr,\n                          unsigned long len, vm_flags_t vm_flags, unsigned long pgoff,\n                          struct list_head *uf)\n&#123;\n    struct mm_struct *mm &#x3D; current-&gt;mm;\n    struct vm_area_struct *vma, *prev;\n    struct rb_node **rb_link, *rb_parent;\n\n&#x2F;&#x2F;之前已经找到虚拟内存区域的其哪一个vm_area_struct，这里看是否可以和它合并到一起\n    vma &#x3D; vma_merge(mm, prev, addr, addr + len, vm_flags,\n                    NULL, file, pgoff, NULL, NULL_VM_UFFD_CTX);\n    if (vma)\n        goto out;\n    \n    &#x2F;&#x2F;不能合并时，调用下面的函数，在Slub里面创建一个新的vm_area_struct对象，\n    &#x2F;&#x2F;设置起始和结束位置，将它加入队列\n    vma &#x3D; kmem_cache_zalloc(vm_area_cachep, GFP_KERNEL);\n    if (!vma) &#123;\n        error &#x3D; -ENOMEM;\n        goto unacct_error;\n    &#125;\n\n    vma-&gt;vm_mm &#x3D; mm;\n    vma-&gt;vm_start &#x3D; addr;\n    vma-&gt;vm_end &#x3D; addr + len;\n    vma-&gt;vm_flags &#x3D; vm_flags;\n    vma-&gt;vm_page_prot &#x3D; vm_get_page_prot(vm_flags);\n    vma-&gt;vm_pgoff &#x3D; pgoff;\n    INIT_LIST_HEAD(&amp;vma-&gt;anon_vma_chain);\n\n    if (file) &#123;\n        vma-&gt;vm_file &#x3D; get_file(file);\n        &#x2F;&#x2F;映射到文件\n        error &#x3D; call_mmap(file, vma);\n        addr &#x3D; vma-&gt;vm_start;\n        vm_flags &#x3D; vma-&gt;vm_flags;\n    &#125; \n    &#x2F;&#x2F;将创建的vm_area_struct挂在了mm_struct里面的红黑树上，建立了内存到文件的映射\n    &#x2F;&#x2F;对于文件会有一个struct file，它有个成员指向struct address_space结构，这里面有棵名为i_mmap的红黑树，vm_area_struct就挂在这个树上\n    &#x2F;&#x2F;__vma_link_file建立文件到内存的映射\n    vma_link(mm, vma, prev, rb_link, rb_parent);\n    return addr;\n    &#x2F;&#x2F;.....\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>用户态缺页异常</p>\n</li>\n</ol>\n<h4 id=\"5-内核态内存映射\"><a href=\"#5-内核态内存映射\" class=\"headerlink\" title=\"5.内核态内存映射\"></a>5.内核态内存映射</h4><ol>\n<li>内核页表</li>\n<li>vmalloc&amp;kmap_atomic原理</li>\n<li>内核态缺页异常</li>\n</ol>\n<h3 id=\"5-文件系统\"><a href=\"#5-文件系统\" class=\"headerlink\" title=\"5.文件系统\"></a>5.文件系统</h3><ol>\n<li><p>xfs文件系统：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>XFS是一个日志型的文件系统，能在断电以及操作系统崩溃的情况下保证数据的一致性。XFS将空间分为若干个分配组，每个分配组大小相等（最后一个可能不等）。分配组包含有超级块、inode管理和剩余空间管理等，所以分配组可以认为是一个单独的文件系统。正是分配组这样的设计，使得XFS拥有了并行IO的能力。在单个分区上使用XFS体现不了这种并行IO能力，但是如果文件系统跨越多个物理硬件比如ceph，并行IO将大大提高吞吐量利用率。</p></blockquote>\n<ol>\n<li>超级块（superblock）：xfs_sb_t，包括了分配组和文件系统的全部元数据信息<ol>\n<li>xfs_db查看超级块内容，执行xfs_db -r /dev/xxx(xxx为XFS所在的分区)，输入sb再输入p即可，如下图所示（鉴于篇幅未尽列出输出）</li>\n<li>blocksize块大小一般4kb，dblocks一个分配组还有的块数目，agcount整个文件含有的分配组数目，sectsize扇区大小，一般为512B，inodesize inode节点大小，一般为512B，icount整个文件系统目前已经分配的inode数目，ifree整个文件系统空闲的inode数目</li>\n</ol>\n</li>\n<li>空闲块信息（AG free block info）：xfs_agf_t，主要描述两个空闲空间B+树和剩余空间信息<ol>\n<li>xfs_db输入agf可查看空闲块信息</li>\n<li>空闲块信息包含了两颗空闲空间B+树，分别以block序号和block数目为关键字，满足两种不同的需求。</li>\n</ol>\n</li>\n<li>inode信息：xfs_agi_t<ol>\n<li>inode B+树信息：主要描述inode B+树的根block、已构造的inode个数以及空闲个数</li>\n<li>Inode信息：每一个文件或目录都对应一个inode，用于描述文件的基本信息，除了目录或链接，inode不携带文件数据。</li>\n</ol>\n</li>\n<li>内部空闲列表：xfs_agfl_t</li>\n</ol>\n<p>==inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。==</p>\n</li>\n<li></li>\n</ol>\n<h3 id=\"6-输入输出系统\"><a href=\"#6-输入输出系统\" class=\"headerlink\" title=\"6.输入输出系统\"></a>6.输入输出系统</h3><h3 id=\"7-进程间通信\"><a href=\"#7-进程间通信\" class=\"headerlink\" title=\"7.进程间通信\"></a>7.进程间通信</h3><h3 id=\"8-网络系统\"><a href=\"#8-网络系统\" class=\"headerlink\" title=\"8.网络系统\"></a>8.网络系统</h3><h3 id=\"9-虚拟化\"><a href=\"#9-虚拟化\" class=\"headerlink\" title=\"9.虚拟化\"></a>9.虚拟化</h3><h3 id=\"10-容器化\"><a href=\"#10-容器化\" class=\"headerlink\" title=\"10.容器化\"></a>10.容器化</h3><h1 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h1><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/79adec391c62b8cf90c210804b704daa.jpg\" alt=\"79adec391c62b8cf90c210804b704daa\"></p>\n<h2 id=\"1-网络协议综述\"><a href=\"#1-网络协议综述\" class=\"headerlink\" title=\"1.网络协议综述\"></a>1.网络协议综述</h2><h3 id=\"1-网络协议及网络分层\"><a href=\"#1-网络协议及网络分层\" class=\"headerlink\" title=\"1.网络协议及网络分层\"></a>1.网络协议及网络分层</h3><ol>\n<li><p>协议三要素：语法+语义+顺序，通过网络协议可以是一大片机器相互协作，共同完成一件事</p>\n</li>\n<li><p>网络协议示例（下单过程）：浏览器输入URL，其通过DNS或HTTPDNS来查找IP地址，应用层通过添加HTTP头封装（HTTP头结构），传输层选择UDP或TCP协议来封装（源和目的端口号），网络层使用IP协议封装（源IP和目的IP），通过链路层的MAC协议和DHCP分配的默认网关IP封装，通过ARP协议决定发到哪个默认网关，网关一般都是路由器，通过路由表知道到某个IP地址应该怎么走，而路由协议常用的有OSPF和BGP，在到达之后，往往最初接待这个请求的是Tomcat，负责统筹处理请求，告诉各自线程处理请求，另外需要通过RPC调用来告诉相关进程，待处理完之后，回复一个HTTPS的包。</p>\n</li>\n<li><p>网络分层：</p>\n<ol>\n<li><p>原因：复杂的程序都要分层，这是程序设计的要求</p>\n</li>\n<li><p>程序如何工作的：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/5c00f6e610f533d17fb4ad7decacc776.jpg\" alt=\"img\"></p>\n<ul>\n<li>process_layer2：摘掉二层的头，看一看应该根据头里面的内容做什么操作，如果MAC相同则转发到下一层来处理</li>\n<li>process_layer3：摘掉三层的头，通过看IP地址是不是自己的，决定到底是发给自己的，还是希望转发出去的</li>\n<li>process_tcp：查看四层的头，看是发起、应答、还是正常数据包，来决定是发起或应答一个回复包，还是将数据包交给上层处理（根据端口号）</li>\n<li>process_http：处理发送给浏览器的，解析HTML，显示出页面</li>\n</ul>\n</li>\n<li><p>层与层之间的关系</p>\n<ol>\n<li><p>套娃的关系，每一层都补充一部分，在网络上的包都是完整的，可以有下层没有上层，但不可以有上层没有下层，所以在TCP三次握手的时候，TCP每发一次消息，下面的IP层和MAC层也一直在忙碌</p>\n</li>\n<li><p>所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已</p>\n</li>\n<li><p>链路层的==ARP==协议完成IP地址和MAC地址的转换，==IP==用于在网络中找到目的主机，==DHCP==用于自动分配IP地址，==NAT==用于将内部IP地址转换为外部IP地址并实现防火墙功能，==ICMP==用于与其他主机或路由器的IP层之间交换差错信息（Ping，Traceroute），==TCP==用于保证可靠性传输，==DNS==用于把域名解析为IP地址，==HTTP==用于传输网页内容</p>\n</li>\n<li><p>五层模型</p>\n<ul>\n<li><p>应用层(Application Layer)<br>协议：FTP (文件传输)，SMTP (邮件)，HTTP (万维网)，DNS</p>\n</li>\n<li><p>传输层(Transport Layer)（报文）<br>功能：可靠传输/不可靠传输，差错处理，流量控制，复用分用<br>协议：TCP（报文段）、UDP（用户数据报）</p>\n</li>\n<li><p>网络层(Network Layer)（分组/数据报）<br>功能：路由选择（最佳路径），流量控制，差错控制，拥塞控制</p>\n<p>协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF</p>\n</li>\n<li><p>数据链路层(Data Link Layer)（帧）<br>功能：成帧（定义帧的开始和结束），差错控制（帧错+位错），流量控制，访问接入控制（控制对信道的访问，CSMA/CD 表示载波监听多点接入 / 碰撞检测），物理寻址，信道复用技术(1. 频分复用，2. 时分复用，3. 统计时分复用，4.波分复用，5.码分复用)<br>协议：SDLC、HDLC、PPP、STP、Ethernet</p>\n</li>\n<li><p>物理层(physical Layer)<br>功能：定义接口特性，定义传输模式（单工、半双工、双工），定义传输速率，比特同步，比特编码<br>协议：Rj45、802.3<br>设备：中继器：转发器、集线器（Hub）：多端口中继器，双绞线、同轴电缆、光纤、无线传输介质。</p>\n</li>\n</ul>\n</li>\n<li><p>OSI七层模型</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/v2-bd9524fab91608122dc1f44633ba080d_1440w.jpg\" alt=\"img\"></p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-设备\"><a href=\"#2-设备\" class=\"headerlink\" title=\"2.设备\"></a>2.设备</h3><ol>\n<li><p>交换机本质上是高性能的网桥，</p>\n</li>\n<li><p>网桥和交换机用于连接多个物理的链路层网络</p>\n</li>\n<li><p>网桥使用==生成树协议（STP）或快速生成树协议（RSTP）==来找到网络拓扑结构中的一个生成树</p>\n</li>\n<li><p>单机模式</p>\n</li>\n<li><p>网线连接：将两个主机连起来</p>\n</li>\n<li><p>中继器（Repeater）：解决网线不够长和距离太大数据会开始丢失的问题</p>\n</li>\n<li><p>集线器（Hub）：解决中继器接口不够的问题，是一种多口中继器</p>\n</li>\n<li><p>网桥（Bridge）：解决冲突域隔离，不同接口之间的数据不会相互冲突</p>\n</li>\n<li><p>交换机（Switch）：相比于网桥接口数量更密集、高速转发、VLAN隔离，能够记录MAC表</p>\n</li>\n<li><p>路由器（Router）：基于IP寻址，采用路由表实现数据转发，用于连接不同类型局域网</p>\n</li>\n<li><p>无线AP（Access Point）：带有无线功能的交换机/路由器</p>\n</li>\n<li><p>防火墙（Firewall）：用于对网络进行安全访问限制，一般用在互联网边缘，可看错待由安全功能的路由器</p>\n</li>\n<li><p>流量控制：因为网络太拥挤，主要有负载均衡器、链路优化、上网行为管理</p>\n</li>\n</ol>\n<h3 id=\"3-Web-页面请求过程\"><a href=\"#3-Web-页面请求过程\" class=\"headerlink\" title=\"3.Web 页面请求过程\"></a>3.Web 页面请求过程</h3><h4 id=\"1-DHCP-配置主机信息\"><a href=\"#1-DHCP-配置主机信息\" class=\"headerlink\" title=\"1. DHCP 配置主机信息\"></a>1. DHCP 配置主机信息</h4><ul>\n<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>\n<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>\n<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>\n<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF，将广播到与交换机连接的所有设备。</li>\n<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>\n<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>\n<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>\n</ul>\n<h4 id=\"2-ARP-解析-MAC-地址\"><a href=\"#2-ARP-解析-MAC-地址\" class=\"headerlink\" title=\"2. ARP 解析 MAC 地址\"></a>2. ARP 解析 MAC 地址</h4><ul>\n<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>\n<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>\n<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>\n<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>\n<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>\n<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>\n<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>\n</ul>\n<h4 id=\"3-DNS-解析域名\"><a href=\"#3-DNS-解析域名\" class=\"headerlink\" title=\"3. DNS 解析域名\"></a>3. DNS 解析域名</h4><ul>\n<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>\n<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>\n<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>\n<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>\n<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>\n</ul>\n<h4 id=\"4-HTTP-请求页面\"><a href=\"#4-HTTP-请求页面\" class=\"headerlink\" title=\"4. HTTP 请求页面\"></a>4. HTTP 请求页面</h4><ul>\n<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>\n<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>\n<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>\n<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>\n<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>\n<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>\n</ul>\n<h2 id=\"2-底层网络知识详解\"><a href=\"#2-底层网络知识详解\" class=\"headerlink\" title=\"2.底层网络知识详解\"></a>2.底层网络知识详解</h2><h3 id=\"1-数据链路层\"><a href=\"#1-数据链路层\" class=\"headerlink\" title=\"1.数据链路层\"></a>1.数据链路层</h3><h4 id=\"1-物理层\"><a href=\"#1-物理层\" class=\"headerlink\" title=\"1.物理层\"></a>1.物理层</h4><ol>\n<li>寝室内组网，通过将网线水晶头的1-3、2-6交叉接，可以将两台主机构成一个局域网，即LAN。如果是三台机器，则需要一个集线器（Hub）</li>\n</ol>\n<h4 id=\"2-MAC\"><a href=\"#2-MAC\" class=\"headerlink\" title=\"2.MAC\"></a>2.MAC</h4><ul>\n<li><p>Hub是广播模式，发出的包每个电脑都能收到，这样会出现多路访问堵车的问题，所以需要一个交换机（Bridge），将MAC头拿下来，检查目标MAC地址，然后根据策略（通过学习得到转发表）转发数据包</p>\n</li>\n<li><p>MAC全称为Medium Access Control，即媒体访问控制，即控制在往媒体上发数据的时候，谁先发，谁后发的问题，即多路访问控制，主要有：信道划分、轮流协议、随机接入协议</p>\n</li>\n<li><p>MAC地址：包括目的MAC地址和源MAC地址，然后是类型，大部分都是IP数据包，然后IP里面包含TCP、UDP、HTTP等，最后是CRC循环冗余检验，通过XOR异或算法来检错</p>\n<ul>\n<li><p>已知MAC地址，数据包在链路上广播，MAC的网卡才能发现这个包是给它的，然后将包收进来，查看IP，然后查看TCP的端口号，发送给对应进程处理，将返回信息在逐层封装</p>\n</li>\n<li><p>没有MAC地址，需要利用ARP协议，利用已知的IP地址，求MAC地址。通过发送广播包来询问</p>\n</li>\n</ul>\n</li>\n<li><p>MAC帧格式</p>\n<ul>\n<li>类型字段用于确定协议类型：<ol>\n<li>IPv4为0x0800</li>\n<li>IPv6为0x86DD</li>\n</ol>\n</li>\n<li>FCS为帧校验序列：为待检查的消息追加n为0，除以一个n+1位的生成多项式，将余数取反放到FCS中</li>\n<li>链路层MTU为1500字节</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220403094148164-16546936989542.png\" alt=\"image-20220403094148164\"></p>\n</li>\n</ul>\n<h3 id=\"2-网络层\"><a href=\"#2-网络层\" class=\"headerlink\" title=\"2.网络层\"></a>2.网络层</h3><h4 id=\"1-查看IP地址\"><a href=\"#1-查看IP地址\" class=\"headerlink\" title=\"1.查看IP地址\"></a>1.查看IP地址</h4><ol>\n<li><p>ifconfig、ip addr</p>\n<ul>\n<li>scope：如果是global，则此张网卡是可以对外开放的，可以接受各个地方的包；对于lo来说事host，说明这张网卡仅仅可以供本机相互通信</li>\n<li>lo全称是loopback，又称环回接口，往往会被分配到127.0.0.1这个地址，用于本机通信，经过内核处理后直接返回，不会再任何网络中出现。</li>\n<li>MAC地址：在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为 MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。因为MAC没有定位功能，所以需要IP地址来寻路</li>\n<li>网络设备的状态标识（net_device flags）：例如&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; ，UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。MTU1500 是指最大传输单元 MTU 为 1500，这是以太网的默认值。</li>\n<li>排队规则（qdisc pfifo_fast）：qdisc 全称是 queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。</li>\n</ul>\n</li>\n<li><p>IP地址分类</p>\n<ol>\n<li><p>分类方式一：D类组播地址用于VXLAN协议</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/fa9a00346b8a83a84f4c00de948a5b5e.jpg\" alt=\"img\"></p>\n</li>\n<li><p>分类方式二：无类型域间选路（CIDR）：将32位地址分为两部分，前面是网络号，后面是主机号，例如：。伴随着CIDR出现的有广播地址、子网掩码、网络号（子网掩码和IP地址按位算AND）</p>\n</li>\n<li><p>共有IP和私有IP：共有IP统一分配需要购买</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/df90239efec6e35880b9abe55089ffa9.jpg\" alt=\"img\"></p>\n</li>\n</ol>\n</li>\n<li><p>IP数据报格式（==‘’一种八片首饰‘’==）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38356330356662312d353534362d346335302d393232312d3231663233316364633863352e6a7067.jpeg\" alt=\"img\"></p>\n<ul>\n<li><p><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</p>\n</li>\n<li><p><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p>\n</li>\n<li><p><strong>区分服务</strong> : 是一个框架和一组标准，用于支持RFC2474,RFC2475,RFC3260上不同类型的服务（即不只是尽力而为的服务，而是更好的服务）</p>\n</li>\n<li><p><strong>总长度</strong> : 包括首部长度和数据部分长度，以字节为单位。</p>\n</li>\n<li><p><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</p>\n</li>\n<li><p><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP（6）、UDP（17） 等。</p>\n</li>\n<li><p><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p>\n</li>\n<li><p><strong>标识</strong> : 避免数据报分片的混淆，在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p>\n</li>\n<li><p><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67.png\" alt=\"img\" style=\"zoom:50%;\" /></li>\n<li><p><strong>选项字段</strong>：很多选项已经被淘汰，只有一部分被留下来放在了IPv6的扩展头部中，</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-IP获取\"><a href=\"#2-IP获取\" class=\"headerlink\" title=\"2.IP获取\"></a>2.IP获取</h4><ol>\n<li><p>DHCP协议：</p>\n<ol>\n<li><p>消息格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220403114714701.png\" alt=\"image-20220403114714701\"></p>\n</li>\n<li><p>DHCP 工作过程如下：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220403160550757.png\" alt=\"image-20220403160550757\"></p>\n<ol>\n<li>客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/90b4d41ee38e891031705d987d5d8481.jpg\" alt=\"img\"></li>\n<li>DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/a52c8c87b925b52059febe9dfcd6be6b.jpg\" alt=\"img\"></li>\n<li>如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/cdbcaad24e1a4d24dd724e38f6f043fa.jpg\" alt=\"img\"></li>\n<li>DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/cca8b0baa4749bb359e453b1b482e1a9.jpg\" alt=\"img\"></li>\n</ol>\n<p>==助记==</p>\n<ol>\n<li>手动配置IP相当于自己买房装修，DHCP协议相当于租房</li>\n<li>新到一个城市要先找中介（DHCP服务器）租个房（IP）-Discover</li>\n<li>中介（DHCP）会带你看房，可能会有多个中介带你看多个房-Offer</li>\n<li>你看上其中一个房，愿意租下来-Request</li>\n<li>中介说没问题，咱们签合同，租约达成-Ack</li>\n<li>租约达成要广播，防止中介之间跳单</li>\n<li>租约快到之前，记得续租</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>PXE（预启动执行环境）的工作过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bbc2b660bba0ad00b5d1179db158498e.jpg\" alt=\"img\"></p>\n</li>\n<li><p>ARP</p>\n<ul>\n<li><p>帧格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/1f7cfe6046c5df606cfbb6bb6c7f899b-20220829204619089.jpg\" alt=\"1f7cfe6046c5df606cfbb6bb6c7f899b\"></p>\n<ul>\n<li><p>硬件类型：1，协议类型：0x0800，硬件地址长度：6，协议地址长度：4</p>\n</li>\n<li><p>op字段：ARP请求（值为1），ARP应答（2），RARP请求（3），RARP应答（4）</p>\n</li>\n<li><p>在Linux查看ARP缓存：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$arp -a</code></pre></li>\n</ul>\n</li>\n<li><p>ARP协议原理</p>\n<ul>\n<li>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</li>\n<li>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</li>\n<li>以主机A（192.168.38.10）向主机B（192.168.38.11）发送数据为例。<ul>\n<li>当发送数据时，主机A会在自己的ARP缓存表中寻找是否有目标IP地址。如果找到就知道目标MAC地址为（00-BB-00-62-C2-02），直接把目标MAC地址写入帧里面发送就可。</li>\n<li>如果在ARP缓存表中没有找到相对应的IP地址，主机A就会在网络上发送一个广播（ARP request），目标MAC地址是“FF.FF.FF.FF.FF.FF”，这表示向同一网段内的所有主机发出这样的询问：“192.168.38.11的MAC地址是什么？”</li>\n<li>网络上其他主机并不响应ARP询问，只有主机B接收到这个帧时，才向主机A做出这样的回应（ARP response）：“192.168.38.11的MAC地址是00-BB-00-62-C2-02”，此回应以单播方式。这样，主机A就知道主机B的MAC地址，它就可以向主机B发送信息。同时它还更新自己的ARP高速缓存（ARP cache），下次再向主机B发送信息时，直接从ARP缓存表里查找就可。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-拓扑结构\"><a href=\"#3-拓扑结构\" class=\"headerlink\" title=\"3.拓扑结构\"></a>3.拓扑结构</h4><ol>\n<li><p>交换机数量增多，就形成了一个稍微复杂的拓扑结构。拓扑结构最常见的问题就是环路问题，这就需要使用生成树算法STP（Spanning Tree Protocol）</p>\n<ul>\n<li>概念：Root Bridge（根交换机，即树根）、Designated Bridges（指定交换机，即树枝非叶子）、Bridge Protocol Data Units（网桥协议数据单元，比喻为相互比较实力的协议）、Priority Vector（优先级向量，比喻为实力）</li>\n<li>工作过程：<ul>\n<li>所有节点将自己初始化为Root Bridge，每个网桥都初始化有一个ID，具有优先级，人工分配。</li>\n<li>互相发送BPDU来比实力，有四种不同情形，最终得出一个树</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解决广播问题和安全问题</p>\n<ol>\n<li><p>物理隔离：公司的每个部门有单独的交换机，配置单独的子网，部门间的沟通通过路由器</p>\n</li>\n<li><p>虚拟隔离：通过VLAN，即虚拟局域网，只需要在二层的头上加一个TAG，里面有一个VLAN ID，一共12位，最多可以划分4096个用户。交换机之间通过Trunk口连接</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/ba720f6988558f95c381f4deaab11660.jpg\" alt=\"img\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-ICMP协议与ping\"><a href=\"#4-ICMP协议与ping\" class=\"headerlink\" title=\"4.ICMP协议与ping\"></a>4.ICMP协议与ping</h4><ol>\n<li><p>ping是基于ICMP协议的，全称为Internet Control Message Protocol，即互联网控制报文协议主要有以下几种类型：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/201589bb205c5b00ad42e0081aa46fe2.jpg\" alt=\"img\"></p>\n<ul>\n<li>查询报文类型：一种主动请求并且获得主动应答的ICMP协议，在网络抓包时，称为ICMP ECHO REQUEST和CMP ECHO REPLY，比原生ICMP多个标识符和序号字段</li>\n<li>差错报文类型：主要有终点不可达（3）、源抑制（4）、超时（11）、重定向（5）等</li>\n</ul>\n</li>\n<li><p>ping的发送和接收过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/57a77fb89bc4a5653842276c70c0d621.jpg\" alt=\"img\"></p>\n</li>\n<li><p>Traceroute</p>\n<ul>\n<li>作用一：故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</li>\n<li>作用二：故意设置不分片，从而确定路径的 MTU</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-网关和路由协议\"><a href=\"#5-网关和路由协议\" class=\"headerlink\" title=\"5.网关和路由协议\"></a>5.网关和路由协议</h4><ol>\n<li><p>在一个机构内，会给每个主机分配一个具体的内部IP（如192.168.1.x/10.10.x.x），只有通过网卡或者路由器，再配置好网关（Gateway）和IP，就可以连接上外网，才能访问外网。访问时如果是同一网段，则直接访问，如果是外部网段，则需要发给网关（往往是路由器，三层转发设备，可以查看MAC头和IP头，然后根据内容和路由算法决定如何转发）。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/825e54560a6de08a32e4cab4e0f59f65.jpg\" alt=\"img\"></p>\n</li>\n<li><p>路由方式：MAC地址在局域网内才有效，所以MAC地址只要过网关，就必定会改变；不改变IP地址的网关，称为转发网关，改变IP地址的网关，称为NAT（Network Address Translation）网关。MAC地址用在局域网内，IP地址用在全局。</p>\n<ul>\n<li><p>欧洲十国游型：每到一个新的局域网，MAC都要变，但是IP地址不变，IP地址一直是源IP和目的IP，MAC是当前MAC和吓一跳MAC地址</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/1d604f88456096a73e40437d8f9e458c.jpg\" alt=\"img\"></p>\n</li>\n<li><p>玄奘西行型：局域网的IP冲突了，源IP和目的IP相同，在局域网内各管各的，这就需要在网关上将局域网IP转换为公网IP，目的IP也要改成对应的公网IP。IP的更改发生在NAT网关，其配置了局域网IP与公网IP的映射表。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/35fb548bbaa7d77012ab46151bfbe63b.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>路由协议</p>\n<ol>\n<li><p>配置路由</p>\n<ol>\n<li><p>路由表：决定如何转发流量，通常称为路由表，主要包含以下三项信息，目的网络、出口设备、下一跳网关。可以通过route命令和ip route命令进行查询或者配置。例如，我们设置<code> ip routew add 10.176.48.0/20 via 10.173.32.1 dev eth0</code>，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。</p>\n</li>\n<li><p>策略路由配置示例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ip rule add from 192.168.1.0&#x2F;24 table 10 \n$ ip rule add from 192.168.2.0&#x2F;24 table 20\n#表示从 192.168.1.10&#x2F;24 这个网段来的，使用 table 10 中的路由表，\n#而从 192.168.2.0&#x2F;24 网段来的，使用 table20 的路由表\n$ ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2\n#下一跳有两个地方，分别是 100.100.100.1 和 200.200.200.1，权重分别为 1 比 2。</code></pre></li>\n</ol>\n</li>\n<li><p>动态路由算法：如何在网络拓扑中找到两个节点的最短路径，主要有Bellman-Ford和Dijkstra算法</p>\n<ol>\n<li>距离矢量路由算法（distance vector routing）：基于Bellman-Ford算法，算法思想是每个路由器都保存一个路由表，从哪出和距离，每个路由器都保存全局信息，每过一段时间将已知信息告知邻居。存在两个问题<ul>\n<li>好消息（新加入路由器）传的块，坏消息（下线的路由器）传的慢</li>\n<li>每次发送的时候，要发送整个全局路由表</li>\n</ul>\n</li>\n<li>链路状态路由算法（link state routing），基于Dijkstra算法，算法思想是当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径</li>\n</ol>\n</li>\n<li><p>动态路由协议</p>\n<ol>\n<li>基于链路状态路由算法的OSPF（Open Shortest Path First，开放式最短路径优先）：主要用于数据中心内部，又称内部网关协议（Interior Gateway Protocol IGP）。内部网关协议的重点就是找到最短路径，可以在多个路径中进行负载均衡，常被称为等价路由。常配合接入层的负载均衡LVS</li>\n<li>基于距离矢量路由算法的BGP（Border Gateway Protocol，外网路由协议）：因为每个数据中心都有自己的Policy，所以有些路可以走，有些不可以走。这一个个数据中心称为自治系统AS（Autonomous System），通过边界路由器与外面世界建立联系。BGP有两类：<ul>\n<li>eBGP：边界路由器之间使用eBGP广播路由</li>\n<li>iBGP：使得内部路由器能够找到到达外网目的地的最好的边界路由器</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-NAT与防火墙\"><a href=\"#6-NAT与防火墙\" class=\"headerlink\" title=\"6.NAT与防火墙\"></a>6.NAT与防火墙</h4><h5 id=\"1-防火墙\"><a href=\"#1-防火墙\" class=\"headerlink\" title=\"1.防火墙\"></a>1.防火墙</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>控制互联网中网络流量的流向</p></blockquote>\n<ol>\n<li>包过滤防火墙：一般配置为丢弃或转发数据包头中符和特定标准的数据包，这些标准称为过滤器<ol>\n<li>无状态的防火墙：单独处理每一个数据报的信息</li>\n<li>有状态的防火墙：通过关联已经或者即将到达的数据包来推断流或者数据报的信息，即可以构成一个IP数据报的IP分片</li>\n</ol>\n</li>\n<li>代理防火墙：本质上是运行一个或多个应用层网关的主机，该主机拥有多个互联网接口，能够在应用层中继两个连接/关联之间的特定类型的流量，一种常见配置为在”外“接口配置一个全局路由的IP地址，为”内“接口分配一个私有IP地址。<ol>\n<li>HTTP防火墙：缓存网页减少网页延迟，增加黑名单来组织用户访问某些网站<ol>\n<li>隧道代理服务器：本质上执行相反的功能，以避免用户被内容过滤器封阻</li>\n</ol>\n</li>\n<li>SOCKS防火墙：比HTTP代理访问使用更广泛，可用于Web之外的其他服务</li>\n</ol>\n</li>\n<li>Linux中==iptables==使用一个称为NetFilter的网络过滤功能来构建</li>\n</ol>\n<h5 id=\"2-NAT\"><a href=\"#2-NAT\" class=\"headerlink\" title=\"2.NAT\"></a>2.NAT</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了应对IPv4地址数量枯竭</p></blockquote>\n<ol>\n<li><p>允许多个范围内中的同一地址可以复用。专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP，内部原理就是重写通过路由器的数据包的识别信息</p>\n</li>\n<li><p>一共有三个IPv4地址范围作为私有地址范围使用（常作为DHCP地址池）</p>\n<ol>\n<li>10.0.0.0/8</li>\n<li>172.16.0.0/12</li>\n<li>192.168.0.0/16</li>\n</ol>\n</li>\n<li><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p>\n</li>\n<li><p>NAT的转换行为和过滤行为有三种</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/B749FC1395C583197925739199E52ECB.jpeg\" alt=\"B749FC1395C583197925739199E52ECB\"></p>\n</li>\n</ol>\n<h5 id=\"3-NAT和TCP-P214\"><a href=\"#3-NAT和TCP-P214\" class=\"headerlink\" title=\"3.NAT和TCP P214\"></a>3.NAT和TCP P214</h5><p>​    TCP连接建立时，将源IP地址改成NAT的外接口地址，并创建内部状态来记住此连接，通过会话计时器和探测数据包来确定是否删除一个内部状态，待处理的棘手问题为：如何处理多个NAT内部的主机上运行的对等应用</p>\n<h3 id=\"3-传输层\"><a href=\"#3-传输层\" class=\"headerlink\" title=\"3.传输层\"></a>3.传输层</h3><h4 id=\"1-UDP\"><a href=\"#1-UDP\" class=\"headerlink\" title=\"1.UDP\"></a>1.UDP</h4><ol>\n<li><p>UDP包头</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/2c9a109f3be308dea901004a5a3b4c84.jpg\" alt=\"img\"></p>\n<ul>\n<li>IP头里有一个8位协议，来指明是TCP还是UDP。从数据中解析出对应的头，内核就按照端口号来将传输层包中的端口号来传送给正在监听此端口号的应用程序</li>\n</ul>\n</li>\n<li><p>协议原理</p>\n<p>- </p>\n</li>\n<li><p>使用场景</p>\n<ul>\n<li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</li>\n<li>不需要一对一沟通，建立连接，而是可以广播的应用</li>\n<li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</li>\n<li>基于UDP的协议：DHCP、HTTP3、云网络中的VXLAN、操作系统镜像的下载使用的 TFTP</li>\n<li>一些新兴改进<ul>\n<li>QUIC是Google提出的一种基于UDP改进的通信协议，在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制。主要用在网页和APP的访问</li>\n<li>直播协议多使用RTMP，丢包时会影响直播效果，所以很多直播应用都基于UDP实现了视频传输协议</li>\n<li>实时游戏领域，在异步IO机制引入之前，常采用自定义UDP来解决对海量客户端连接的策略</li>\n<li>物联网领域终端资源少，维护TCP协议代价太大，而且物联网对实时性要求也很高。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li>\n<li>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-TCP\"><a href=\"#2-TCP\" class=\"headerlink\" title=\"2.TCP\"></a>2.TCP</h4><ol>\n<li><p>包头</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/642947c94d6682a042ad981bfba39fbf.jpg\" alt=\"img\"></p>\n<ul>\n<li>序号：给包编号，用来解决乱序问题</li>\n<li>确认序号：发出去的包应该有确认，来确定是否已经收到相应包</li>\n<li>状态位：<ul>\n<li>SYN：发起一个连接</li>\n<li>ACK：回复</li>\n<li>RST：重新连接</li>\n<li>FIN：结束连接</li>\n</ul>\n</li>\n<li>窗口大小：TCP要做流浪控制，通信双方动态约定一个窗口，保证双方都在高效处理数据</li>\n<li></li>\n</ul>\n</li>\n<li><p>协议原理</p>\n<ol>\n<li><p>三次握手</p>\n<ul>\n<li><p>原理</p>\n<ul>\n<li><p>状态变化时序图：一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220829215700543.png\" alt=\"image-20220829215700543\" style=\"zoom:50%;\" /></li>\n<li></li>\n</ul>\n</li>\n<li><p>相关问题</p>\n<ul>\n<li>握手次数：一次的话，请求方不知道响应方是否已经成功接受请求；两次的话，接收方不知道发送方是否成功接受相应；三次的话，刚好双方都知晓；四次以及更多的话，已经没有特殊的意义了，所以再多的数据包都不能保证真的可靠，后续通过数据包和探活包来解决相关问题</li>\n<li>TCP包的序号问题：为了防止连接之间数据包序号的相互影响，所以序号是随时间变化的，通过数据包的序号，双方都可以知道应收的包和应发的包都是哪个</li>\n<li>为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>四次挥手</p>\n<ul>\n<li><p>原理</p>\n<ul>\n<li><p>状态变化时序图</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220829215944764.png\" alt=\"image-20220829215944764\" style=\"zoom:50%;\" />\n\n<ul>\n<li>FIN_WAIT_2：如果此时右端机器直接关机，那么TCP协议里并没有对这个状态的处理，但是在Linux中可以调整tcp_fin_timeout这个参数，设置一个超时时间</li>\n<li>等待2MSL：MSL是报文最大生存时间，虽然序号是重新生成的，但是为了防止左端提前结束后收到右端之前连接的数据包，所以需要等待2MSL时间。时间截止后，对于右端旧连接发送的数据包，左端将会直接发送RST，这样右端就知道左端已退出</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>相关问题</p>\n</li>\n</ul>\n</li>\n<li><p>滑动窗口</p>\n<ul>\n<li><p>顺序问题    </p>\n<ul>\n<li><p>为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为累计确认或者累计应答（cumulative acknowledgment）</p>\n</li>\n<li><p>根据处理的情况可以将发送端的包分为四个部分</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220829223244412.png\" alt=\"image-20220829223244412\" style=\"zoom:50%;\" />\n\n<ul>\n<li>第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的</li>\n<li>第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉</li>\n<li>第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的</li>\n<li>第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。（区分三和四是为了流量控制）</li>\n</ul>\n</li>\n<li><p>根据处理的情况可以将接受端的包分为三个部分</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220829223357053.png\" alt=\"image-20220829223357053\" style=\"zoom:50%;\" />\n\n<ul>\n<li>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的</li>\n<li>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量</li>\n<li>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>流量控制</p>\n<ul>\n<li>在对包的确认中，同时会携带一个窗口的大小。当发送方窗口已经全发送过了，但是接受端还没接收，此时每接受到一个应答，窗口大小就减一，直到为0</li>\n</ul>\n</li>\n<li><p>丢包问题</p>\n<ul>\n<li>超时重传：对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。超时时间依靠自适应重传算法（Adaptive Retransmission Algorithm）</li>\n<li>超时间隔加倍：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</li>\n<li>快速重传机制：当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段</li>\n<li>SACK：这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拥塞窗口</p>\n<ul>\n<li><p>包丢失</p>\n</li>\n<li><p>超时重传</p>\n<ul>\n<li><p>慢启动拥塞避免</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220829230125933.png\" alt=\"image-20220829230125933\"></p>\n</li>\n<li><p>快重传快恢复</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220829230205768.png\" alt=\"image-20220829230205768\"></p>\n</li>\n<li><p>BRR拥塞算法</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他问题</p>\n<ul>\n<li><p>TCP状态机</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220829221127997.png\" alt=\"image-20220829221127997\"></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>其它</p>\n</li>\n</ol>\n<h4 id=\"3-Socket\"><a href=\"#3-Socket\" class=\"headerlink\" title=\"3.Socket\"></a>3.Socket</h4><ol>\n<li><p>参数设置</p>\n<ul>\n<li>指定到底是 IPv4 还是 IPv6，分别对应设置为 AF_INET 和 AF_INET6</li>\n<li>指定到底是 TCP 还是 UDP，TCP 协议是基于数据流的，所以设置为 SOCK_STREAM，而 UDP 是基于数据报的，因而设置为 SOCK_DGRAM</li>\n</ul>\n</li>\n<li><p>基于 TCP 协议的 Socket 程序函数调用过程</p>\n<ul>\n<li><p>函数调用过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/87c8ae36ae1b42653565008fc47aceea-20220829230546970.jpg\"></p>\n</li>\n<li><p>数据结构</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/604f4cb37576990b3f836cb5d7527b13.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>基于 UDP 协议的 Socket 程序函数调用过程</p>\n<ul>\n<li><p>函数调用过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/6bbe12c264f5e76a81523eb8787f3931.jpg\" alt=\"img\"></p>\n</li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-应用层\"><a href=\"#4-应用层\" class=\"headerlink\" title=\"4.应用层\"></a>4.应用层</h3><h4 id=\"1-HTTP-1-1\"><a href=\"#1-HTTP-1-1\" class=\"headerlink\" title=\"1.HTTP/1.1\"></a>1.HTTP/1.1</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>a stateless application-level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information system.</p></blockquote>\n<h5 id=\"1-协议的通用规则\"><a href=\"#1-协议的通用规则\" class=\"headerlink\" title=\"1.协议的通用规则\"></a>1.协议的通用规则</h5><ol>\n<li><p>协议格式：ABNF（扩充巴克斯范式）操作符号</p>\n<ul>\n<li><p>空白字符：用来分隔定义中的各个元素，<code>method SP request-target SP HTTP-version CRLF</code></p>\n</li>\n<li><p>选择 <code>/</code>:表示多个规则都是可供选择的规则，<code>start-line = request-line / status-line</code></p>\n</li>\n<li><p>值范围 <code>%c##-##</code> ：<code>OCTAL=“0”/“1”/“2”/“3”/“4”/“5”/“6”/“7”</code>与<code>OCTAL=%x30-37</code>等价</p>\n</li>\n<li><p>序列组合<code> ()</code>:将规则组合起来，视为单个元素</p>\n</li>\n<li><p>不定量重复 <code>m*n</code>:</p>\n<ul>\n<li><code>*</code> 元素表示零个或更多元素：<code>*( header-field CRLF )</code></li>\n<li><code>1*</code> 元素表示一个或更多元素，<code>2*4</code> 元素表示两个至四个元素</li>\n</ul>\n</li>\n<li><p>可选序列<code> []</code>：<code>[ message-body ]</code></p>\n</li>\n<li><p>核心规则：</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220830205111283.png\" alt=\"image-20220830205111283\" style=\"zoom: 67%;\" /></li>\n</ul>\n</li>\n<li><p>URI</p>\n<ul>\n<li><p>URL：[RFC1738]，Uniform Resource Locator，表示资源的位置，Internet上描述信息资源的字符串</p>\n</li>\n<li><p>URN：[RFC2141]，Uniform Resource Name，例如磁力链接</p>\n</li>\n<li><p>URI：[RFC1630]，[RFC3986]，Uniform Resource Identifier，URL是URI的一种实现</p>\n<ul>\n<li><p>组成：schema、user information、host、port、path、query、fragment</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220830211437670.png\" alt=\"image-20220830211437670\"></p>\n</li>\n<li><p>格式：URI = scheme “:” hier-part [ “?” query ] [ “#” fragment ]</p>\n<ul>\n<li>scheme=ALPHA*(ALPHA/DIGIT/“+”/“-“/“.”)<ul>\n<li>例如：http, https, ftp,mailto,rtsp,file,telnet</li>\n</ul>\n</li>\n<li>query=*(pchar/“/“/“?”)</li>\n<li>fragment=*(pchar/“/“/“?”)</li>\n<li>hier-part = “//“ authority path-abempty / path-absolute / path-rootless / path-empty<ul>\n<li>authority = [ userinfo “@” ] host [ “:” port ]<ul>\n<li>userinfo = *( unreserved / pct-encoded / sub-delims / “:” )<ul>\n<li>unreserved = ALPHA / DIGIT / “-“ / “.” / “_” / “~” <ul>\n<li>ALPHA: %41-%5A and %61-%7A</li>\n<li>DIGIT: %30-%39</li>\n<li>-:%2D        .:%2E.        _:%5F</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>host = IP-literal / IPv4address / reg-name</li>\n<li>port = *DIGIT</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>path = path-abempty/ path-absolute/ path-noscheme / path-rootless / path-empty <ul>\n<li>path-abempty = *( “/” segment )，以/开头的路径或者空路径</li>\n<li>path-absolute = “/” [ segment-nz *( “/” segment ) ]，以/开头的路径，但不能以//开头</li>\n<li>path-noscheme = segment-nz-nc *( “/” segment )，以非:号开头的路径</li>\n<li>path-rootless = segment-nz *( “/” segment )，相对path-noscheme，增加允许以:号开头的路径</li>\n<li>path-empty = 0&lt;pchar&gt;，空路径</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>方法与响应码概览</p>\n<ul>\n<li>方法[RFC7231]<ul>\n<li>GET：主要的获取信息方法，大量性能优化都针对该方法，幂等方法</li>\n<li>POST：常用语提交HTML FORM表单，新增资源等</li>\n<li>PUT：更新资源，带条件时是幂等方法</li>\n<li>DELETE：删除资源，幂等方法</li>\n<li>其它：HEAD、CONNECT、OPTIONS、TRACE、PROPFIND、PROPPATCH、MKCOL、COPY、MOVE、LOCK、UNLOCK</li>\n</ul>\n</li>\n<li>响应码[RFC6585]、[RFC7231]<ul>\n<li>1xx：请求已经收到，需要进一步处理才完成</li>\n<li>200：请求响应成功</li>\n<li>3xx：请求重定向（去新地方找），[RFC2068]规定不能超过五次，防止死循环</li>\n<li>4xx：找不到资源,资源不存在</li>\n<li>5xx：服务器代码错，例如502网关错误</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"2-连接与消息的路由\"><a href=\"#2-连接与消息的路由\" class=\"headerlink\" title=\"2.连接与消息的路由\"></a>2.连接与消息的路由</h5><ol>\n<li><p>连接</p>\n<ul>\n<li><p>HTTP连接的常见流程：解析出<strong>主机名</strong>、通过DNS查询主机名的<strong>IP</strong>、浏览器获得端口号（<strong>80</strong>）、浏览器发起到IP端口80的<strong>连接</strong>、浏览器向服务器发送一条<strong>请求报文</strong>、浏览器从服务器读取<strong>响应报文</strong>、<strong>关闭连接</strong></p>\n</li>\n<li><p>从编程的角度</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904151649870.png\" alt=\"image-20220904151649870\" style=\"zoom:50%;\" /></li>\n<li><p>短连接与长连接</p>\n<ul>\n<li>Connection头部（Connection仅对当前连接有效，不是整条链路）<ul>\n<li>Keep-Alive：长连接，HTTP/1.1默认支持</li>\n<li>Close：短连接</li>\n<li>不转发Connection列出的头部，该头部仅与当前连接有关</li>\n</ul>\n</li>\n<li>Proxy-Connection：陈旧的代理服务器不识别该头部，退化为短连接；新版本的代理服务器理解该头部，与客户建立长连接，然后与服务器使用Connection替代Proxy-Connection</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>连接相关头部</p>\n<ol>\n<li>用于连接消息<ul>\n<li><strong>Host头部</strong> [RFC7230]section5.4<ul>\n<li>ABNF：Host = uri-host [ “:” port]</li>\n<li>示例：<a href=\"http://www.baidu.com、localhost:8080/\">www.baidu.com、localhost:8080</a></li>\n<li>HTTP/1.1规范要求，不传递Host头部、超过一个Host头部，无效头部都会返回400错误码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>用于代理服务器转发消息<ul>\n<li><strong>Max-Forwards头部</strong><ul>\n<li>ABNF：Max-Forwards = 1*DIGIT</li>\n<li>限制Proxy代理服务器的最大转发次数，仅对TRACE/OPTIONS方法有效</li>\n</ul>\n</li>\n<li><strong>Via头部</strong><ul>\n<li>ABNF：Via = 1#( received-protocol RWS received-by [ RWS comment ] )<ul>\n<li>received-protocol = [ protocol-name “/“ ] protocol-version</li>\n<li>received-by = ( uri-host [ “:” port ] ) / pseudonym</li>\n<li>pseudonym = token</li>\n</ul>\n</li>\n<li>指明经过的代理服务器名称及版本</li>\n</ul>\n</li>\n<li><strong>Cache-Contro头部</strong>l:no-transform：禁止代理服务器修改响应包体</li>\n</ul>\n</li>\n<li>用于请求/响应上下文的头部<ol>\n<li>请求的上下文<ul>\n<li>User-Agent<ul>\n<li>ABNF：User-Agent = product *( RWS ( product / comment ) )<ul>\n<li>product = token [“/“ product-version]</li>\n<li>RWS=1*(SP/HTAB)</li>\n</ul>\n</li>\n<li>示例：<ul>\n<li>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Referer<ul>\n<li>浏览器对来自某一页面的请求自动添加的头部，用于统计分析、缓存优化、防盗链等功能</li>\n<li>示例：Referer: <a href=\"https://cn.bing.com/\">https://cn.bing.com/</a></li>\n<li>Refer不会被添加的场景<ul>\n<li>来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI</li>\n<li>当前请求页面采用的是 http 协议，而来源页面采用的是 https 协议</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>From：主要用于网络爬虫，告诉服务器如何通过邮件联系到爬虫的负责人</li>\n</ul>\n</li>\n<li>响应的上下文<ul>\n<li>Server<ul>\n<li>ABNF：Server = product *( RWS ( product / comment ) )<ul>\n<li>product = token [“/“ product-version]</li>\n</ul>\n</li>\n<li>服务器上所用软件的信息，用于帮助客户端定位问题或统计数据</li>\n<li>示例： nginx/1.23.1、BWS/1.1</li>\n</ul>\n</li>\n<li>Allow<ul>\n<li>ABNF：Allow = #method</li>\n<li>告诉客户端，服务器上该URI对应的资源允许哪些方法的执行</li>\n<li>示例：Allow: GET, HEAD, PUT</li>\n</ul>\n</li>\n<li>Accept-Ranges<ul>\n<li>告诉客户端服务器上该资源是否允许range请求</li>\n<li>示例<ul>\n<li>Accept-Ranges: bytes</li>\n<li>Accept-Ranges: none</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"3-内容协商与传输\"><a href=\"#3-内容协商与传输\" class=\"headerlink\" title=\"3.内容协商与传输\"></a>3.内容协商与传输</h5><ol>\n<li><p>内容协商</p>\n<ul>\n<li><p>每个URI指向的资源可以是任何事物，可以有多种不同的表述，例如一份文档可以有不同语言的翻译、不同的媒体格式、可以针对不同的浏览器提供不同的压缩编码等</p>\n</li>\n<li><p>内容协商的两种方式</p>\n<ul>\n<li><p>Proactive 主动式内容协商：指由客户端先在请求头部中提出需要的表述形式，而服务器根据这些请求头部提供特定的 representation 表述</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904162549702.png\" alt=\"image-20220904162549702\" style=\"zoom: 33%;\" /></li>\n<li><p>Reactive 响应式内容协商：指服务器返回 300 Multiple Choices 或者 406 Not Acceptable，由客户端 选择一种表述 URI 使用</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904162606656.png\" alt=\"image-20220904162606656\" style=\"zoom: 50%;\" /></li>\n</ul>\n</li>\n<li><p>常见的协商要素</p>\n<ul>\n<li>媒体资源的 MIME 类型及质量因子q（内容的质量、可接受类型的优先级）<ul>\n<li>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9</li>\n</ul>\n</li>\n<li>字符编码：由于 UTF-8 格式广为使用， Accept-Charset 已被废弃</li>\n<li>内容编码：主要指压缩算法<ul>\n<li>Accept-Encoding: gzip, deflate, br</li>\n</ul>\n</li>\n<li>表述语言<ul>\n<li>Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7</li>\n</ul>\n</li>\n<li>国际化与本地化<ul>\n<li>internationalization(i18n)：指设计软件时，在不同的国家、地区可以不做逻辑实现层面的修改便能够以不同的语言显示</li>\n<li>localization(l10n)：指内容协商时，根据请求中的语言及区域信息，选择特定的语言作为资源表述</li>\n</ul>\n</li>\n<li>资源表述的元数据头部<ul>\n<li>媒体类型、编码：content-type: text/html; charset=utf-8</li>\n<li>内容编码：content-encoding: gzip</li>\n<li>语言：Content-Language: de-DE, en-CA</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>包体</p>\n<ol>\n<li><p>概念：实际承载的消息内容</p>\n</li>\n<li><p>两种传输HTTP包体的方式</p>\n<ul>\n<li><p>定长包体：发送HTTP消息时已能够确定包体的全部长度，接受端处理更简单</p>\n<ul>\n<li>使用Content-Length头部明确指明包体长度，单位是10进制，且必须与实际传输的包体长度一致</li>\n</ul>\n</li>\n<li><p>不定长包体：发送HTTP消息时不能够确定包体的全部长度，基于长连接持续推送动态内容</p>\n<ul>\n<li><p>使用 Transfer-Encoding 头部指明使用 Chunk 传输方式，并忽略 Content-Length 头部</p>\n</li>\n<li><p>ABNF：transfer-coding = “chunked” / “compress” / “deflate” / “gzip” / transfer-extension</p>\n</li>\n<li><p>chunk传输方式（分块传输编码）：Transfer-Encoding:chunked</p>\n<ul>\n<li><p>chunked-body = *chunk  last-chunk  trailer-part  CRLF（0-n个chunk）</p>\n<ul>\n<li><p>chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF</p>\n<ul>\n<li>chunk-size = 1*HEXDIG:注意这里是 16 进制而不是10进制</li>\n<li>chunk-data = 1*OCTET</li>\n</ul>\n</li>\n<li><p>last-chunk = 1*(“0”) [ chunk-ext ] CRLF</p>\n</li>\n<li><p>trailer-part = *( header-field CRLF )</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Trailer头部的传输（不是所有服务器都支持）</p>\n<ul>\n<li>TE 头部:客户端在请求在声明是否接收 Trailer 头部<ul>\n<li>TE: trailers</li>\n</ul>\n</li>\n<li>Trailer 头部:服务器告知接下来 chunk 包体后会传输哪些 Trailer 头部<ul>\n<li>Trailer: Date</li>\n</ul>\n</li>\n<li>以下头部不允许出现在 Trailer 的值中:<ul>\n<li>用于信息分帧的首部 (例如 Transfer-Encoding 和 Content-Length)</li>\n<li>用于路由用途的首部 (例如 Host)</li>\n<li>请求修饰首部 (例如控制类和条件类的，如 Cache-Control，Max-For wards，或者 TE)</li>\n<li>身份验证首部 (例如 Authorization 或者 Set-Cookie)</li>\n<li>Content-Encoding, Content-Type, Content-Range，以及 Trailer 自身</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他</p>\n<ol>\n<li>MIME( Multipurpose Internet Mail Extensions )格式<ul>\n<li>content := “Content-Type” “:” type “/“ subtype *(“;” parameter)<ul>\n<li>type := discrete-type / composite-type<ul>\n<li>discrete-type := “text” / “image” / “audio” / “video” / “application” / extension-token</li>\n<li>composite-type := “message” / “multipart” / extension-token</li>\n<li>extension-token := ietf-token / x-token</li>\n</ul>\n</li>\n<li>subtype := extension-token / iana-token</li>\n<li>parameter := attribute “=” value</li>\n</ul>\n</li>\n<li>大小写不敏感，但通常是小写</li>\n<li>例如: Content-type: text/plain; charset=”us-ascii“</li>\n</ul>\n</li>\n<li>Content-Disposition头部[RFC6266]<ul>\n<li>disposition-type = “inline” | “attachment” | disp-ext-type<ul>\n<li>inline:指定包体是以 inline 内联的方式，作为页面的一部分展示</li>\n<li>attachment:指定浏览器将包体以附件的方式下载<ul>\n<li>例如: Content-Disposition: attachment</li>\n<li>例如: Content-Disposition: attachment; filename=“filename.jpg”</li>\n</ul>\n</li>\n<li>在 multipart/form-data 类型应答中，可以用于子消息体部分<ul>\n<li>如 Content-Disposition: form-data; name=”fieldName”; filename=”filename.jpg”</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Range[RFC7233]<ul>\n<li>允许服务器基于客户端的请求只发送响应包体的一部分给到客户端，而客户端 自动将多个片断的包体组合成完整的体积更大的包体</li>\n<li>服务器通过 Accept-Range 头部表示是否支持 Range 请求</li>\n<li>通过Range头部传递请求范围，如:Range: bytes=0-499</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Form表单</p>\n<ol>\n<li><p>FORM表常用控件：Text Input Controls:文本输入控件、Checkboxes Controls:复选框控件、Radio Box Controls :单选按钮控件、Select Box Controls:下拉列表控件、File Select boxes:选取文件控件、Clickable Buttons:可点击的按钮控件、Submit and Reset Button:提交或者重置按钮控件</p>\n</li>\n<li><p>FORM表单提交请求时的关键属性</p>\n<ul>\n<li><p>action:提交时发起 HTTP 请求的 URI</p>\n</li>\n<li><p>method:提交时发起 HTTP 请求的 http 方法</p>\n<ul>\n<li>GET:通过 URI，将表单数据以 URI 参数的方式提交，不安全但高效</li>\n<li>POST:将表单数据放在请求包体中提交，安全但不高效</li>\n</ul>\n</li>\n<li><p>enctype:在 POST 方法下，对表单内容在请求包体中的编码方式</p>\n<ul>\n<li><p>application/x-www-form-urlencoded</p>\n<ul>\n<li>数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值，字符以 URL 编码方式编码</li>\n</ul>\n</li>\n<li><p>multipart/form-data</p>\n<ul>\n<li><p>boundary 分隔符</p>\n</li>\n<li><p>每部分表述皆有HTTP头部描述子包体，例如 Content-Type</p>\n</li>\n<li><p>last boundary 结尾</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>multipart[RFC1521]、[RFC822]：一个包体中多个资源表述</p>\n<ul>\n<li><p>Content-type 头部指明这是一个多表述包体</p>\n<ul>\n<li>Content-type: multipart/form-data;</li>\n<li>boundary=—-WebKitFormBoundar yRRJKeWfHPGrS4LKe</li>\n</ul>\n</li>\n<li><p>Boundary 分隔符的格式</p>\n<ul>\n<li>boundary := 0*69&lt;bchars&gt; bcharsnospace<ul>\n<li>bchars := bcharsnospace / “ “</li>\n<li>bcharsnospace:=DIGIT/ALPHA/“‘“/“(“/“)”/“+”/“_”/“,”/“-“/“.”/“/“/“:” / “=” / “?”</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>包体格式：multipart-body = preamble 1*encapsulation close-delimiter epilogue</p>\n<ul>\n<li><p>preamble := discard-text</p>\n</li>\n<li><p>epilogue := discard-text</p>\n<ul>\n<li>discard-text := *(*text CRLF)</li>\n</ul>\n</li>\n<li><p>每部分包体格式:encapsulation = delimiter body-part CRLF</p>\n<ul>\n<li><p>delimiter = “–” boundary CRLF</p>\n</li>\n<li><p>body-part = fields *( CRLF *text )</p>\n<ul>\n<li><p>field = field-name “:” [ field-value ] CRLF</p>\n<ul>\n<li><p>content-disposition: form-data; name=”xxxxx“</p>\n</li>\n<li><p>content-type 头部指明该部分包体的类型</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>close-delimiter = “–” boundary “–” CRLF</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"4-cookie的设计与问题\"><a href=\"#4-cookie的设计与问题\" class=\"headerlink\" title=\"4.cookie的设计与问题\"></a>4.cookie的设计与问题</h5><ol>\n<li><p>Cookie的格式与约束</p>\n<ul>\n<li>HTTP State Management Mechanism[RFC6265]，保存在客户端，由浏览器维护、表示应用状态的HTTP头部<ul>\n<li>存放在内存或磁盘中</li>\n<li>服务端生成Cookie在响应中通过Set-Cookie头部告知客户端，允许多 个 Set-Cookie 头部传递多个值</li>\n<li>客户端得到Cookie后，后续请求都会自动将Cookie头部携带至请求中</li>\n</ul>\n</li>\n<li>ABNF<ul>\n<li>cookie-header = “Cookie:” OWS cookie-string OWS（可以存放多个名值name/value对）<ul>\n<li>cookie-string = cookie-pair *( “;” SP cookie-pair )<ul>\n<li>cookie-pair = cookie-name “=” cookie-value</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>set-cookie-header = “Set-Cookie:” SP set-cookie-string（只有一个名值对，但可以包含多个头部）<ul>\n<li>set-cookie-string = cookie-pair *( “;” SP cookie-av )<ul>\n<li>cookie-pair = cookie-name “=” cookie-value</li>\n<li>cookie-av:描述 cookie-pair 的可选属性，cookie-av = expires-av / max-age-av / domain-av / path-av / secure-av / httponly-av / extension-av</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>浏览器使用Cookie的要求：每条 Cookie 的长度(包括 name、value 以及描述的属性等总长度)至多要达到 4KB ；每个域名下至少支持 50 个 Cookie；至少要支持 3000 个 Cookie</li>\n<li>Cookie缺点：需要附加在每个HTTP请求中，无形增加了流量；明文传递有安全性问题；大小有限制对复杂请求来说不够用</li>\n</ul>\n</li>\n<li><p>Session的工作原理</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904200516604.png\" alt=\"image-20220904200516604\"></p>\n</li>\n<li><p>同源策略</p>\n<ul>\n<li><p>如果两个 URL 的 protocol、port (en-US)(如果有指定的话) 和 host都相同的话，则这两个 URL 是同源</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">URL</th>\n<th align=\"left\">结果</th>\n<th align=\"left\">原因</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>http://store.company.com/dir2/other.html</code></td>\n<td align=\"left\">同源</td>\n<td align=\"left\">只有路径不同</td>\n</tr>\n<tr>\n<td align=\"left\"><code>http://store.company.com/dir/inner/another.html</code></td>\n<td align=\"left\">同源</td>\n<td align=\"left\">只有路径不同</td>\n</tr>\n<tr>\n<td align=\"left\"><code>https://store.company.com/secure.html</code></td>\n<td align=\"left\">失败</td>\n<td align=\"left\">协议不同</td>\n</tr>\n<tr>\n<td align=\"left\"><code>http://store.company.com:81/dir/etc.html</code></td>\n<td align=\"left\">失败</td>\n<td align=\"left\">端口不同 (  默认端口是 80)</td>\n</tr>\n<tr>\n<td align=\"left\"><code>http://news.company.com/dir/other.html</code></td>\n<td align=\"left\">失败</td>\n<td align=\"left\">主机不同</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>作用：</p>\n<ul>\n<li>没有同源策略下的Cookie，只能保证用户请求来自同一浏览器，不能确保是用户自愿发出的</li>\n<li>站点B的脚本就可以随修改A的DOM结构</li>\n<li>限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互</li>\n</ul>\n</li>\n<li><p>平衡点</p>\n<ul>\n<li>可用性:HTML 的创作者决定跨域请求是否对本站点安全<ul>\n<li> <code>&lt;script&gt;&lt;img&gt;&lt;iframe&gt;&lt;link&gt;&lt;video&gt;&lt;audio&gt;</code>带有 src 属性可以跨域访问</li>\n<li> 允许跨域写操作:例如表单提交或者重定向请求（CSRF安全性问题）</li>\n</ul>\n</li>\n<li>安全性:浏览器需要防止站点 A 的脚本向站点 B 发起危险动作<ul>\n<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>\n<li>DOM 无法获得(防止跨域脚本篡改 DOM 结构)</li>\n<li>AJAX 请求不能发送</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>跨域访问（CORS，Cross-Origin Resource Sharing）</p>\n<ul>\n<li><p>浏览器同源策略下的跨域访问解决方案：如果站点 A 允许站点 B 的脚本访问其资源，必须在 HTTP 响应中显式的告知浏览器，站点 B 是被允许的</p>\n<ul>\n<li>访问站点 A 的请求，浏览器应告知该请求来自站点 B</li>\n<li>站点 A 的响应中，应明确哪些跨域请求是被允许的</li>\n</ul>\n</li>\n<li><p>简单请求的跨域访问</p>\n<ul>\n<li><p>简单请求</p>\n<ul>\n<li>GET/HEAD/POST 方法之一</li>\n<li>仅能使用 CORS 安全的头部:Accept、Accept-Language、Content-Language、Content-Type</li>\n<li>Content-Type 值只能是: text/plain、multipart/form-data、application/x-www-form-urlencoded 三者其中之一</li>\n</ul>\n</li>\n<li><p>策略</p>\n<ul>\n<li>请求中携带 Origin 头部告知来自哪个域</li>\n<li>响应中携带 Access-Control-Allow-Origin 头部表示允许哪些域</li>\n<li>浏览器放行</li>\n</ul>\n</li>\n<li><p>简单请求以外的其他请求：访问资源前，需要先发起 prefilght 预检请求(方法为 OPTIONS)询问何种请求是被允许的</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904201803134.png\" alt=\"image-20220904201803134\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>条件请求</p>\n<ul>\n<li>概念<ul>\n<li>目的：有客户端携带条件判断信息，而服务器预执行条件验证过程成功后，再返回资源的表述</li>\n<li>应用场景：使缓存的更新更有效率、断点续传时对之前内容的验证、当多个客户端并行修改同一资源时，防止某一客户端的更新被错误丢弃</li>\n</ul>\n</li>\n<li>条件请求头部<ul>\n<li>If-Match = “*“ / 1#entity-tag</li>\n<li>If-None-Match = “*” / 1#entity-tag</li>\n<li>If-Modified-Since = HTTP-date</li>\n<li>If-Unmodified-Since = HTTP-date</li>\n<li>If-Range = entity-tag / HTTP-date</li>\n</ul>\n</li>\n<li>验证器 validator：根据客户端请求中携带的相关头部，以及服务器资源的信息，执行两端的资源验证<ul>\n<li>强验证器:服务器上的资源表述只要有变动(例如版本更新或者元数据更 新)，那么以旧的验证头部访问一定会导致验证不过</li>\n<li>弱验证器:服务器上资源变动时，允许一定程度上仍然可以验证通过(例如一小段时间内仍然允许缓存有效)</li>\n<li>验证器响应头部<ul>\n<li>Etag 响应头部， 给出当前资源表述的标签，ETag = entity-tag<ul>\n<li>entity-tag = [ weak ] opaque-tag<ul>\n<li>weak = %x57.2F</li>\n<li>opaque-tag = DQUOTE *etagc DQUOTE etagc = %x21 / %x23-7E / obs-text</li>\n</ul>\n</li>\n<li>例如：<ul>\n<li>强验证器 ETag: “xyzzy”</li>\n<li>弱验证器 ETag: W/“xyzzy”</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Last-Modified 响应头部：Last-Modified = HTTP-date<ul>\n<li>表示对应资源表述的上次修改时间</li>\n<li>对比 Date 头部: Date = HTTP-date<ul>\n<li>表示响应包体生成的时间</li>\n<li>Last-Modified 不能晚于 Date 的值</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"5-缓存的控制\"><a href=\"#5-缓存的控制\" class=\"headerlink\" title=\"5.缓存的控制\"></a>5.缓存的控制</h5><ol>\n<li><p>缓存的原理</p>\n<ul>\n<li><p>为当前请求复用前请求的响应</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904211623643.png\" alt=\"image-20220904211623643\" style=\"zoom:50%;\" /></li>\n<li><p>缓存实现示意图</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904211658580.png\" alt=\"image-20220904211658580\" style=\"zoom: 33%;\" /></li>\n</ul>\n</li>\n<li><p>缓存新鲜度的四种计算方式</p>\n<ul>\n<li><p>判断缓存是否过期：response_is_fresh = (freshness_lifetime &gt; current_age)</p>\n<ul>\n<li>freshness_lifetime:按优先级，取以下响应头部的值（s-maxage &gt; max-age &gt; Expires &gt; 预估过期时间）<ul>\n<li>预估过期时间：[RFC7234]</li>\n</ul>\n</li>\n<li>current_age：current_age = corrected_initial_age + resident_time;<ul>\n<li>resident_time = now - response_time(接收到响应的时间);</li>\n<li>corrected_initial_age = max(apparent_age, corrected_age_value);<ul>\n<li>corrected_age_value = age_value + response_delay;<ul>\n<li>response_delay = response_time - request_time(发起请求的时间);</li>\n</ul>\n</li>\n<li>apparent_age = max(0, response_time - date_value);</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>示例</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904212112071.png\" alt=\"image-20220904212112071\"></p>\n</li>\n</ul>\n</li>\n<li><p>Cache-Control头部</p>\n<ul>\n<li><p>头部格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904212211063.png\" alt=\"image-20220904212211063\"></p>\n</li>\n<li><p>Cache-Control的值</p>\n<ul>\n<li>max-age:告诉服务器，客户端不会接受 Age 超出 max-age 秒的缓存</li>\n<li>max-stale:告诉服务器，即使缓存不再新鲜，但陈旧秒数没有超出 max-stale 时，客户端仍打算使用。若 max-stale 后没有值，则表示无论过期多久客户端都可使用</li>\n<li>min-fresh:告诉服务器，Age 至少经过 min-fresh 秒后缓存才可使用</li>\n<li>no-cache:告诉服务器，不能直接使用已有缓存作为响应返回，除非带着缓存条件到上游服务端得到 304 验证返回码才可使用现有缓存</li>\n<li>no-store:告诉各代理服务器不要对该请求的响应缓存(实际有不少不遵守该规定的代理服务 器)</li>\n<li>no-transform:告诉代理服务器不要修改消息包体的内容</li>\n<li>only-if-cached:告诉服务器仅能返回缓存的响应，否则若没有缓存则返回 504 错误码</li>\n<li>must-revalidate:告诉客户端一旦缓存过期，必须向服务器验证后才可使用</li>\n<li>proxy-revalidate:与 must-revalidate 类似，但它仅对代理服务器的共享缓存有效</li>\n<li>no-cache:告诉客户端不能直接使用缓存的响应，使用前必须在源服务器验证 得到 304 返回码。如果 no-cache 后指定头部，则若客户端的后续请求及响应 中不含有这些头则可直接使用缓存</li>\n<li>max-age:告诉客户端缓存 Age 超出 max-age 秒后则缓存过期</li>\n<li>s-maxage:与 max-age 相似，但仅针对共享缓存，且优先级高于 max-age 和 Expires</li>\n<li>public:表示无论私有缓存或者共享缓存，皆可将该响应缓存</li>\n<li>private:表示该响应不能被代理服务器作为共享缓存使用。若 private 后指定头部，则在告诉代理服务器不能缓存指定的头部，但可缓存其他部分</li>\n<li>no-store:告诉所有下游节点不能对响应进行缓存</li>\n<li>no-transform:告诉代理服务器不能修改消息包体的内容</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>什么样的响应才会被缓存</p>\n<ul>\n<li>请求方法可以被缓存理解(不只于 GET 方法)</li>\n<li>响应码可以被缓存理解(404、206 也可以被缓存)</li>\n<li>响应与请求的头部没有指明 no-store</li>\n<li>响应中至少应含有以下头部中的 1 个或者多个:<ul>\n<li>Expires、max-age、s-maxage、public</li>\n<li>当响应中没有明确指示过期时间的头部时，如果响应码非常明确，也可以缓存</li>\n</ul>\n</li>\n<li>如果缓存在代理服务器上<ul>\n<li>不含有 private</li>\n<li>不含有 Authorization</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>多种重定向跳转方式的差异</p>\n<ul>\n<li><p>重定向流程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220904212533811.png\" alt=\"image-20220904212533811\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-WebSocket\"><a href=\"#2-WebSocket\" class=\"headerlink\" title=\"2.WebSocket\"></a>2.WebSocket</h4><h4 id=\"3-HTTP-2-0\"><a href=\"#3-HTTP-2-0\" class=\"headerlink\" title=\"3.HTTP/2.0\"></a>3.HTTP/2.0</h4><h5 id=\"1-TLS-SSL\"><a href=\"#1-TLS-SSL\" class=\"headerlink\" title=\"1.TLS/SSL\"></a>1.TLS/SSL</h5><h5 id=\"2-HTTPS\"><a href=\"#2-HTTPS\" class=\"headerlink\" title=\"2.HTTPS\"></a>2.HTTPS</h5><ol>\n<li><p>对称加密：我们在谍战剧里面经常看到这样的场景，就是特工破译的密码会有个密码本，截获无线电台，通过密码本就能将原文破解出来</p>\n</li>\n<li><p>非对称加密：非对称加密的私钥放在外卖网站这里，不会在互联网上传输，这样就能保证这个私钥的私密性，对应私钥的公钥，是可以在互联网上传播的，只要外卖网站把这个公钥给你，你就可以愉快地互通了</p>\n</li>\n<li><p>数字证书：</p>\n<ol>\n<li><p>你怎么鉴别别人给你的公钥是对的？这个时候就需要权威部门的介入了，而由权威部门颁发的就是证书</p>\n</li>\n<li><p>证书里面有什么？有公钥，有证书的所有者，还有证书的发布机构和证书的有效期</p>\n</li>\n<li><p>证书的生成</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">openssl req -key cliu8siteprivate.key -new -out cliu8sitecertificate.req</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-流媒体协议\"><a href=\"#4-流媒体协议\" class=\"headerlink\" title=\"4.流媒体协议\"></a>4.流媒体协议</h4><ol>\n<li><p>概念</p>\n<ul>\n<li>名词系列<ul>\n<li>名词系列一：AVI、MPEG、RMVB、MP4、MOV、FLV、WebM、WMV、ASF、MKV</li>\n<li>名词系列二：H.261、 H.262、H.263、<strong>H.264</strong>、H.265</li>\n<li>名词系列三：MPEG-1、MPEG-2、MPEG-4、MPEG-7</li>\n</ul>\n</li>\n<li>视频：就是一张一张的图片，当播放的足够快，比如每秒60帧（FPS），人眼就看不出来是一张张独立的图片。每一张图片都是由像素组成的，如3456*2234；每个像素由RGB组成，每个8位，共24位（三原色），每秒视频可以计算为：60*3456*2234*24 = 11117813760Bits = 1389726720 Bytes = 1.29GB</li>\n<li>压缩：因为视频的图像相邻像素强相关、相邻帧相似、人们视觉不够敏感、可用霍夫曼编码差异化编码，所以可以用压缩算法对视频进行压缩。编码过程大致包括帧内预测、帧间预测、变换、量化（降低图像质量）、熵编码（变长编码）几方面。视频编码主要有两大流派<ul>\n<li>流派一：ITU（International Telecommunications Union）的 VCEG（Video Coding Experts Group），名词系列二，就是这个组织制定的标准</li>\n<li>流派二：ISO（International Standards Organization）的 MPEG（Moving Picture Experts Group），名词系列三，就是这个组织制定的标准</li>\n<li>重点：ITU-T（国际电信联盟电信标准化部门，ITU Telecommunication Standardization Sector）与 MPEG 联合制定了 H.264/MPEG-4 AVC</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>直播产生的过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220901213220981.png\" alt=\"image-20220901213220981\"></p>\n<ul>\n<li><p>编码：将视频序列分成三种帧（I关键帧、P前向预测编码帧、B双向预测内插编码帧），压缩后帧的序列可以通过IBBP的间隔出现（通过时序进行编码）。一个视频拆分成一系列的帧，每一帧拆分成一系列的片，每一片都放在一个NALU（网络提取单元）里面，NALU之间都是通过特殊的起始标识符分隔，在每一个I帧的第一片里面，要插入单独保存的SPS（图像序列的所有信息）和PPS（图像的所有分片信息）的NALU，最终形成一个长长的NALU序列</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220901215659783.png\" alt=\"image-20220901215659783\" style=\"zoom: 33%;\" /></li>\n<li><p>推流：首先通过RTMP协议将编码得到的二进制的流打包成网络包进行传送，RTMP基于TCP连接并且还要建立RTMP连接用于同步信息（握手时版本号、时间戳；握手后Chunk块大小、窗口大小）。传输数据的时候创建一个流Stream，通过Stream来推流，即将NALU放在Message里面发送（RTMP Packet），并且不是以Message为单位的，而是把Message拆分成Chunk发送，而且是串行发送</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220901215616827.png\" alt=\"image-20220901215616827\" style=\"zoom: 33%;\" /></li>\n<li><p>流处理、分发：观众可以通过RTMP协议从流媒体服务器上拉取，但因服务器压力过大，所以需要分发网络。分发网络分为中心和边缘两层，边缘层服务器部署在全国各地及横跨各大运营商里，和用户距离很近。中心层是流媒体服务集群，负责内容的转发。</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220901215947139.png\" alt=\"image-20220901215947139\" style=\"zoom: 50%;\" /></li>\n<li><p>拉流：先读到的是H.264的解码参数，例如SPS和PPS，然后对收到的NALU组成的以一个个帧，进行解码，交给播放器播放，一个绚丽多彩的视频画面就出来了</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220901220107817.png\" alt=\"image-20220901220107817\" style=\"zoom: 33%;\" /></li>\n<li><p>解码：即通过上述过程的逆过程，将一串串看不懂的二进制，再转变成一帧帧生动的图片，在客户端播放出来</p>\n</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h4 id=\"5-P2P协议\"><a href=\"#5-P2P协议\" class=\"headerlink\" title=\"5.P2P协议\"></a>5.P2P协议</h4><ol>\n<li><p>FTP的两种工作模式</p>\n<ul>\n<li>主动模式（PORT）：客户端随机打开一个大于 1024 的端口 N，向服务器的命令端口 21 发起连接，同时开放 N+1 端口监听，并向服务器发出 “port N+1” 命令，由服务器从自己的数据端口 20，主动连接到客户端指定的数据端口 N+1</li>\n<li>被动模式（PASV）：客户端打开两个任意的本地端口 N（大于 1024）和 N+1。第一个端口连接服务器的 21 端口，提交 PASV 命令。然后，服务器会开启一个任意的端口 P（大于 1024），返回“227 entering passive mode”消息，里面有 FTP 服务器开放的用来进行数据传输的端口。客户端收到消息取得端口号之后，会通过 N+1 号端口连接服务器的端口 P，然后在两个端口之间进行数据传输</li>\n</ul>\n</li>\n<li><p>P2P（peer-to-peer）：资源开始并不集中地储存在某些设备上，而是分散地存储在多台设备（peer）上，可以缓解单一服务器的带宽压力。例如软件BitTorrent，种子（.torrent）文件。P2P主要分为两类，基于tracker和基于分布式哈希算法。有一种著名的去中心网络协议，<strong>Kademlia协议</strong>，具体如下</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902155828691.png\" alt=\"image-20220902155828691\" style=\"zoom: 50%;\" />\n\n<ul>\n<li>任何一个BitTorrent启动后，有两个角色。peer，用来上传和下载文件；DHT node，通过这个角色，这个节点加入了一个DHT网络；每个DHT node都应该知道某些文件是保存在哪些节点上，也就是文件索引</li>\n<li>如果一个文件计算出一个哈希值，DHT node的ID是和哈希值相同长度的串，则和这个哈希值一样的或是很接近的那些DHT node，就有责任知道从哪里下载这个文件</li>\n<li>DHT网络特别像一个社交网络，每个node都保存了一些其他node的联系方式，也就是朋友圈，节点之间回相互通信，添加或删除朋友圈，这样ID之间的距离就不是物理位置的距离，而是社交网络中的社交距离</li>\n<li>一个新的DHT node上线，只要联系上DHT网络中的一个节点，就加入这个网络</li>\n<li>新DHT node节点通过计算文件哈希，可以知道某个node应该有这个文件保存在哪里的知识，于是去万能的朋友圈去问，朋友如果不知道，朋友再去自己的朋友圈问，很快就能找到</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h3 id=\"5-数据中心\"><a href=\"#5-数据中心\" class=\"headerlink\" title=\"5.数据中心\"></a>5.数据中心</h3><h4 id=\"1-DNS\"><a href=\"#1-DNS\" class=\"headerlink\" title=\"1.DNS\"></a>1.DNS</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>将域名映射为IPv4地址</p></blockquote>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220403163615403.png\" alt=\"image-20220403163615403\"></p>\n<ol>\n<li><p>DNS</p>\n<ul>\n<li><p>因为DNS服务器访问量巨大，所以一定要设置成高可用、高并发和分布式的，因而使用了树状结构。并且为了减少每次查找地址簿（根据名称查具体IP地址）的时间，每个运营商都有本地域名服务器做缓存。</p>\n</li>\n<li><p>DNS解析流程：本地DNS通过DHCP配置，是由客户端的网络服务商（ISP）自动分配，通常在网络服务商的某个机房。本地DNS会缓存一张域名与之对应 IP 地址的大表格，如果找到域名对应IP，则直接返回，否则访问根域名服务器，由根域名服务器和其他几个层级的服务器通过递归回溯的方式，最终由对应权威服务器提供IP</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902163554896.png\" alt=\"image-20220902163554896\" style=\"zoom: 25%;\" /></li>\n<li><p>负载均衡</p>\n<ul>\n<li><p>内部负载均衡：某个应用访问另一个应用时，如果配置了另一个应用的IP地址，那么这个访问就是一对一的，可以部署多个应用来保证可用性。实现方法为，将应用配置成为域名，在域名解析的时候可以配置策略，每次返回的IP不同，就可以实现负载均衡了</p>\n</li>\n<li><p>全局负载均衡：为了保证应用高可用，往往会部署在多个机房，每个地方都会有自己的 IP 地址。当用户访问某个域名的时候，这个 IP 地址可以轮询访问多个数据中心。如果一个数据中心因为某种原因挂了，只要在 DNS 服务器里面，将这个数据中心对应的 IP 地址删除，就可以实现一定的高可用</p>\n</li>\n<li><p>示例：通过DNS访问数据中心中对象存储上的静态资源</p>\n<ul>\n<li>yourcompany.com的DNS服务器，通过配置CNAME的方式，给请求起一个别名，然后告诉本地DNS服务器，让他请求GSLB解析这个域名，GSLB可以在解析的过程中实现负载均衡</li>\n<li>Layer 2 GSLB有可能返回6个Region的IP地址，客户端可以随机货轮询选择一个Region进行访问</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902165222990.png\" alt=\"image-20220902165222990\" style=\"zoom: 50%;\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>传统DNS问题</p>\n<ul>\n<li>域名缓存问题：<ul>\n<li>因为本地有缓存的问题，不是每一个请求都回去访问权威DNS服务器，而是访问过一次就把结果缓存到自己本地，这就使得其他客户端访问此缓存的时候，会出现失效的问题</li>\n<li>有的运营商会把一些静态页面缓存到本地运营商的服务器内，这样用户请求的时候，就不用跨运营商进行访问，既加快速度，有减少运营商之间流量计算的成本。在域名解析的时候，不会将用户导向真正的网站，而是指向这个缓存的服务器。这就会出现访问到老页面的问题</li>\n<li>负载均衡失效：本地的缓存，往往使得全局负载均衡失败，因为上次进行缓存的时候，缓存中的地址不一定是这次访问离客户最近的地方，如果把这个地址返回给客户，那肯定就会绕远路</li>\n</ul>\n</li>\n<li>域名转发：本地域名解析服务，不是每次都要去权威 DNS 服务器查找，有了请求之后，直接转发给其他运营商去做解析，这样就会使得返回的地址离用户很远</li>\n<li>出口NAT：很多机房的出口会配置NAT，使得从这个网关出去的包，都换成新的 IP 地址，对于访问没有任何问题，但是一旦一旦做了网络地址的转换，权威的 DNS 服务器，就没办法通过这个地址，来判断客户到底是来自哪个运营商，而且极有可能因为转换过后的地址，误判运营商，导致跨运营商的访问</li>\n<li>域名更新：本地 DNS 服务器是由不同地区、不同运营商独立部署的。对域名解析缓存的处理上，实现策略也有区别，有的会偷懒，忽略域名解析结果的 TTL 时间限制，在权威 DNS 服务器解析变更的时候，解析结果在全网生效的周期非常漫长。在跨机房负载均衡和容灾中，一个机房出现问题，如果权威DNS的更新比较慢，就会有用户出现访问异常的问题</li>\n<li>解析延迟：DNS 的查询过程需要递归遍历多个 DNS 服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时</li>\n</ul>\n</li>\n<li><p>HTTPDNS</p>\n<ul>\n<li><p>概念：不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。当客户端需要DNS解析的时候，直接通过HTTP协议请求这个服务器集群，得到就近的地址。这就需要绕过默认的DNS，常用在手机应用，需要手机端嵌入支持HttpDNS的客户端 SDK</p>\n</li>\n<li><p>工作模式</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902173658315.png\" alt=\"image-20220902173658315\" style=\"zoom: 33%;\" />\n\n<ul>\n<li>在客户端的 SDK 里动态请求服务端，获取 HttpDNS 服务器的 IP 列表，缓存到本地。随着不断地解析域名，SDK 也会在本地缓存 DNS 域名解析的结果</li>\n<li>当手机应用要访问一个地址的时候，首先看是否有本地的缓存，如果有就直接返回。这个缓存和本地 DNS 的缓存不一样的是，这个是手机应用自己决定缓存机制</li>\n<li>如果本地没有，就需要请求 HttpDNS 的服务器，在本地 HttpDNS 服务器的 IP 列表中，选择一个发出 HTTP 的请求，会返回一个要访问的网站的 IP 列表</li>\n<li>手机客户端自然知道手机在哪个运营商、哪个地址。由于是直接的 HTTP 通信，HttpDNS 服务器能够准确知道这些信息，因而可以做精准的全局负载均衡</li>\n</ul>\n</li>\n<li><p>缓存设计</p>\n<ul>\n<li><p>HttpDNS将解析速度和更新速度都掌握在自己手里，一方面，解析的过程，不需要本地 DNS 服务递归的调用一大圈，一个 HTTP 的请求直接搞定，要实时更新的时候，马上就能起作用；另一方面为了提高解析速度，本地也有缓存，缓存是在客户端 SDK 维护的，过期时间、更新时间，都可以自己控制</p>\n</li>\n<li><p>缓存设计模式</p>\n<ul>\n<li>客户端：手机客户端</li>\n<li>缓存：DNS缓存</li>\n<li>数据源：HttpDNS服务器</li>\n</ul>\n</li>\n<li><p>解析可以同步进行，也就是直接调用HttpDNS的接口，返回最新的记录，更新缓存；也可以异步进行，添加一个解析任务到后台，由后台任务调用HttpDNS的接口</p>\n<ul>\n<li><p>同步更新对应到应用架构中缓存的Cache-Aside机制</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902174641930.png\" alt=\"image-20220902174641930\" style=\"zoom: 25%;\" /></li>\n<li><p>异步更新的优点是可以预加载，合并多个HttpDNS，减少HttpDNS压力；缺点是当前请求拿到过期数据的时候会需要冒风险直接使用或再次请求。对应到应用架构中缓存的 Refresh-Ahead 机制</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902174849042.png\" alt=\"image-20220902174849042\" style=\"zoom:25%;\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>调度设计</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902175235700.png\" alt=\"image-20220902175235700\" style=\"zoom:50%;\" />\n\n<ul>\n<li>由于客户端嵌入了 SDK，因而就不会因为本地 DNS 的各种缓存、转发、NAT，让权威 DNS 服务器误会客户端所在的位置和运营商，而可以拿到第一手资料</li>\n<li>在客户端，可以知道手机是哪个国家、哪个运营商、哪个省，甚至哪个市，HttpDNS 服务端可以根据这些信息，选择最佳的服务节点访问。如果有多个节点，还会考虑错误率、请求时间、服务器压力、网络状况等，进行综合选择，而非仅仅考虑地理位置。当有一个节点宕机或者性能下降的时候，可以尽快进行切换</li>\n<li>在服务端，应用可以通过调用 HttpDNS 的管理接口，配置不同服务质量的优先级、权重。HttpDNS 会根据这些策略综合地理位置和线路状况算出一个排序，优先访问当前那些优质的、时延低的 IP 地址</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-CDN\"><a href=\"#2-CDN\" class=\"headerlink\" title=\"2.CDN\"></a>2.CDN</h4><ol>\n<li><p>CDN分发系统架构：全球各地的用于缓存数据的数据中心称为边缘节点，由于边缘节点无法缓存全局信息，所以需要有区域节点及中心节点，来缓存更多的数据，增加缓存的命中率，如果都未命中，则会源网站访问</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902191647281.png\" alt=\"image-20220902191647281\" style=\"zoom:50%;\" /></li>\n<li><p>客户端访问边缘节点：</p>\n<ul>\n<li>没有CDN的时候，通过DNS来查询IP地址。有了CDN后，在权威DNS服务器上，会设置一个CNAME别名，指向另一个域名，返回给本地DNS服务器。</li>\n<li>本地DNS服务器继续解析这个新域名，这次会CDN的权威DNS服务器，在这个服务器上，还是会设置一个CNAME，指向另外一个域名，也即 CDN 网络的全局负载均衡器。</li>\n<li>接下来，本地 DNS 服务器去请求 CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，依据包括IP、运营商、URL中的内容、服务器当前负载，返回该服务器IP地址</li>\n<li>本地 DNS 服务器缓存这个 IP 地址，然后将 IP 返回给客户端，客户端去访问这个边缘节点，下载资源</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902191736899.png\" alt=\"image-20220902191736899\" style=\"zoom:50%;\" /></li>\n<li><p>CDN缓存的内容</p>\n<ul>\n<li>静态CDN<ul>\n<li>静态页面、图片：通过拉取的方式，当发现未命中的时候，再去上一级进行拉取</li>\n<li>流媒体（RTMP）：预先缓存流数据，通过推送的模式，将热点数据主动推送到边缘节点，通过HTTP头部中的referer字段、时间戳防盗链（与CDN厂商约定一个加密字符串）解决防盗链问题</li>\n</ul>\n</li>\n<li>动态CDN<ul>\n<li>一种为生鲜超市模式，也即边缘计算的模式。既然数据是动态生成的，所以数据的逻辑计算和存储，也相应的放在边缘的节点。其中定时从源数据那里同步存储的数据，然后在边缘进行计算得到结果。就像对生鲜的烹饪是动态的，没办法事先做好缓存，因而将生鲜超市放在你家旁边，既能够送货上门，也能够现场烹饪，也是边缘计算的一种体现</li>\n<li>另一种是冷链运输模式，也即路径优化的模式。数据不是在边缘计算生成的，而是在源站生成的，但是数据的下发则可以通过 CDN 的网络，对路径进行优化。因为 CDN 节点较多，能够找到离源站很近的边缘节点，也能找到离用户很近的边缘节点。中间的链路完全由 CDN 来规划，选择一个更加可靠的路径，使用类似专线的方式进行访问。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-数据中心\"><a href=\"#3-数据中心\" class=\"headerlink\" title=\"3.数据中心\"></a>3.数据中心</h4><ol>\n<li><p>核心交换机</p>\n<ul>\n<li><p>设备：网关、机架（Rack）、边界路由器（Broder Router）+BGP协议、接入层/TOR（Top Of Rack）交换机、汇聚层（Aggregation Layer）交换机、</p>\n</li>\n<li><p>LACP（Link Aggregation Control Protocol）协议：所有服务器和交换机都需要支持，可以将多个网卡合称为一个网卡，多个网线聚合成一个网线，在网线之间可以进行负载均衡，也可以为了高可用做准备</p>\n</li>\n<li><p>可用区（Available Zone，又称Point Of Delivery）：交换机通过堆叠技术，多个物理交换机形成一个逻辑的交换机。汇聚层将大量的计算节点相互连接在一起，形成一个集群，在这个机群里，服务之间通过二层互通。当节点数目再多的时候，需要将多个可用区连在一起，连接多个可用区的交换机称为核心交换机</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902202625203.png\" alt=\"image-20220902202625203\" style=\"zoom:50%;\" /></li>\n<li><p>环路问题：解决方法一为，不同的可用区在不同的二层网络，需要分配不同的网段，此时二层不在一个广播域里，所以不会出现环路。三层可以有环路，只需要通过路由协议选择最佳的路径就可以</p>\n</li>\n<li><p>大二层：核心交换机也变为二层设备，通过引入 TRILL（Transparent Interconnection of Lots of Link），即多链接透明互联协议。它的基本思想是，二层环有问题，三层环没有问题，那就把三层的路由能力模拟在二层实现。通过链路状态协议运作，学习拓扑+MAC路由</p>\n</li>\n</ul>\n</li>\n<li><p>边界路由器：在核心交换上面，往往会挂一些安全设备，例如入侵检测、DDoS 防护等等。这是整个数据中心的屏障，防止来自外来的攻击。核心交换机上往往还有负载均衡器。因为流量从上到下传输，故称为南北流量</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902203732667.png\" alt=\"image-20220902203732667\" style=\"zoom:50%;\" /></li>\n<li><p>随着云和大数据的发展，节点之间的交互越来越多，例如大数据计算经常要在不同的节点将数据拷贝来拷贝去，这样需要经过交换机，节点之间的交互越来越多，例如大数据计算经常要在不同的节点将数据拷贝来拷贝去，这样需要经过交换机。东西流量相对于南北流量越来越重要，因而演化为叶脊网络结构。</p>\n<ul>\n<li><p>叶子交换机（leaf），直接连接物理服务器。L2/L3 网络的分界点在叶子交换机上，叶子交换机之上是三层网络</p>\n</li>\n<li><p>脊交换机（spine switch），相当于核心交换机。叶脊之间通过 ECMP 动态选择多条路径。脊交换机现在只是为叶子交换机提供一个弹性的 L3 路由网络。南北流量可以不用直接从脊交换机发出，而是通过与 leaf 交换机并行的交换机，再接到边界路由器出去</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220902203956108.png\" alt=\"image-20220902203956108\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-VPN\"><a href=\"#4-VPN\" class=\"headerlink\" title=\"4.VPN\"></a>4.VPN</h4><ol>\n<li><p>VPN通过隧道技术在公众网络上仿真一条点到点的专线，是通过利用一种协议来传输另外一种协议的技术。三种协议：乘客协议、隧道协议和承载协议</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220402101623071.png\" alt=\"image-20220402101623071\"></p>\n<ol>\n<li>VPN相当于自驾海南游，如何通过琼州海峡呢？这里用到轮渡，就是隧道协议</li>\n<li>在广州这边开车是有“协议”的，例如靠右行驶、红灯停绿灯行，这就相当于“被封装”的乘客协议。当然在海南那面，开车也是同样的协议</li>\n<li>在海上坐船航行，也有协议，例如要看灯塔、要按航道航行等。这是外层的承载协议</li>\n<li>车如何从广州到海南呢？要遵循开车的协议，将车开上轮渡，所有通过轮渡的车都关在船舱里面，按照既定的规则排列好，这就是隧道协议。</li>\n<li>在大海上，车是关在船舱里面的，就像在隧道里面一样，这时内部的乘客协议，也即驾驶协议没啥用处，只需要船遵从外层的承接协议，到达海南就可以了。</li>\n<li>到达之后，外部承接协议的任务就结束了，打开船舱，将车开出来，就相当于取下承接协议和隧道协议的头。接下来，在海南怎么开车，还是内部的乘客协议起作用</li>\n</ol>\n</li>\n<li><p>IPsec VPN</p>\n<ol>\n<li><p>IPsec VPN 的协议簇</p>\n<ul>\n<li>协议<ul>\n<li>AH（Authentication Header）协议：只能进行数据摘要 ，不能实现数据加密</li>\n<li>ESP（Encapsulating Security Payload）协议：能够进行数据加密和数据摘要</li>\n</ul>\n</li>\n<li>算法<ul>\n<li>加密算法（Encryption Algorithms）</li>\n<li>摘要算法（Hashing Algorithms）</li>\n</ul>\n</li>\n<li>组件<ul>\n<li>IKE（Internet Key Exchange）组件：用于VPN的双方要进行对称密钥的交换</li>\n<li>SA（Security Association）组件：VPN的双方要对连接进行维护</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>建立过程</p>\n<ul>\n<li><p>阶段一：建立IKE自己的SA。这个SA用来维护一个通过身份认证和安全保护的通道，为阶段二提供服务。这个阶段通过DH（Diffie-Hellman）算法计算出一个对称密钥K，即为对称密钥。对称密钥从未在通道上传输过，只传输了生成密钥的材料</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220903084752354.png\" alt=\"image-20220903084752354\" style=\"zoom:50%;\" /></li>\n<li><p>阶段二：建立IPsec SA。这个SA里，双方会生成一个随机的对称密钥M（有过期时间），由K加密传给对方，然后使用M进行双方接下来通信的数据，IPsec SA 里面有以下内容：</p>\n<ul>\n<li>SPI（Security Parameter Index），用于标识不同的连接</li>\n<li>双方商量好的加密算法、哈希算法和封装模式</li>\n<li>生存周期，超过这个周期，就需要重新生成一个 IPsec SA，重新生成对称密钥</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>传输数据</p>\n<ul>\n<li><p>通过ESP对IP进行加密（可通过对称密钥解密）并封装，外层再包裹一个IP头。下图左侧为原始IP，右侧为包裹后的IP</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220903085720633.png\" alt=\"image-20220903085720633\"></p>\n</li>\n<li><p>有了 IPsec VPN 之后，客户端发送的明文的 IP 包，都会被加上 ESP 头和 IP 头，在公网上传输，由于加密，可以保证不被窃取，到了对端后，去掉 ESP 的头，进行解密</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220903091016443.png\" alt=\"image-20220903091016443\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>MPLS-VPN：综合和 IP 转发模式和 ATM 的标签转发模式的优势，性能较好，但是需要从运营商购买</p>\n</li>\n</ol>\n<h4 id=\"5-移动网络\"><a href=\"#5-移动网络\" class=\"headerlink\" title=\"5.移动网络\"></a>5.移动网络</h4><ol>\n<li><p>移动网络的发展历程从 2G 到 3G，再到 4G，逐渐从打电话的功能为主，向上网的功能为主转变</p>\n</li>\n<li><p>请记住 4G 网络的结构，有 eNodeB、MME、SGW、PGW 等，分控制面协议和数据面协议，你可以对照着结构，试着说出手机上网的流程，架构及上网流程如下：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220903102726174.png\" alt=\"image-20220903102726174\"></p>\n<ul>\n<li><p>手机开机以后，在附近寻找基站 eNodeB，找到后给 eNodeB 发送 Attach Request，说“我来啦，我要上网”</p>\n</li>\n<li><p>eNodeB 将请求发给 MME，说“有个手机要上网”，eNodeB朝前对接无线网络，朝后对接核心网络</p>\n<ul>\n<li>eNodeB使用SCTP协议，有以下特点：多宿主（网卡）、将一个联合（多个接口）分成多个流、四次握手（方式SYN攻击）、消息分帧（类似UDP）、断开连接是三次挥手（没有半关闭状态）</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220903104322121.png\" alt=\"image-20220903104322121\"></p>\n</li>\n<li><p>MME 去请求手机，一是认证，二是鉴权，还会请求 HSS 看看有没有钱，看看是在哪里上网（控制平面）</p>\n</li>\n<li><p>当 MME 通过了手机的认证之后，开始分配隧道，先告诉 SGW，说要创建一个会话（Create Session）。在这里面，会给 SGW 分配一个隧道 ID t1，并且请求 SGW 给自己也分配一个隧道 ID</p>\n</li>\n<li><p>SGW 转头向 PGW 请求建立一个会话，为 PGW 的控制面分配一个隧道 ID t2，也给 PGW 的数据面分配一个隧道 ID t3，并且请求 PGW 给自己的控制面和数据面分配隧道 ID</p>\n</li>\n<li><p>PGW 回复 SGW 说“创建会话成功”，使用自己的控制面隧道 ID t2，回复里面携带着给 SGW 控制面分配的隧道 ID t4 和控制面的隧道 ID t5，至此 SGW 和 PGW 直接的隧道建设完成。双方请求对方，都要带着对方给自己分配的隧道 ID，从而标志是这个手机的请求</p>\n</li>\n<li><p>接下来 SGW 回复 MME 说“创建会话成功”，使用自己的隧道 ID t1 访问 MME，回复里面有给 MME 分配隧道 ID t6，也有 SGW 给 eNodeB 分配的隧道 ID t7</p>\n</li>\n<li><p>当 MME 发现后面的隧道都建设成功之后，就告诉 eNodeB，“后面的隧道已经建设完毕，SGW 给你分配的隧道 ID 是 t7，你可以开始连上来了，但是你也要给 SGW 分配一个隧道 ID”</p>\n</li>\n<li><p>eNodeB 告诉 MME 自己给 SGW 分配一个隧道，ID 为 t8</p>\n</li>\n<li><p>MME 将 eNodeB 给 SGW 分配的隧道 ID t8 告知 SGW，从而前面的隧道也建设完毕。（数据平面）</p>\n<ul>\n<li>数据面的协议都是通过 GTP-U，如图所示</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220903104821994.png\" alt=\"image-20220903104821994\"></p>\n</li>\n</ul>\n</li>\n<li><p>即便你在国外的运营商下上网，也是要通过国内运营商控制的，因而也上不了脸书</p>\n<ul>\n<li>如果你在巴塞罗那，一下飞机，手机开机，周围搜寻到的肯定是巴塞罗那的 eNodeB。通过 MME 去查询国内运营商的 HSS，看你是否合法，是否还有钱。如果允许上网，你的手机和巴塞罗那的 SGW 会建立一个隧道，然后巴塞罗那的 SGW 和国内运营商的 PGW 建立一个隧道，然后通过国内运营商的 PGW 上网</li>\n<li>因此，判断你是否能上网的是国内运营商的 HSS，控制你上网策略的是国内运营商的 PCRF，给手机分配的 IP 地址也是国内运营商的 PGW 负责的，给手机分配的 IP 地址也是国内运营商里统计的。运营商由于是在 PGW 里面统计的，这样你的上网流量全部通过国内运营商即可，只不过巴塞罗那运营商也要和国内运营商进行流量结算</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-热门技术中的应用\"><a href=\"#3-热门技术中的应用\" class=\"headerlink\" title=\"3.热门技术中的应用\"></a>3.热门技术中的应用</h2><h3 id=\"1-云计算中的网络\"><a href=\"#1-云计算中的网络\" class=\"headerlink\" title=\"1.云计算中的网络\"></a>1.云计算中的网络</h3><h4 id=\"1-云中网络\"><a href=\"#1-云中网络\" class=\"headerlink\" title=\"1.云中网络\"></a>1.云中网络</h4><ol>\n<li><p>为了解决物理设备维护费用高、扩展性不足的问题，发明了虚拟机，并基于它产生了云计算技术。在个人PC可以使用虚拟化软件；在数据中心可以使用qemu-kvm技术，来在物理机上通过软件虚拟出若干小机器</p>\n</li>\n<li><p>虚拟网卡的原理：以qemu-kvm技术为例，通过Linux上的一种TUN/TAP技术来实现</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905215324426.png\" alt=\"image-20220905215324426\" style=\"zoom:50%;\" />\n\n<ul>\n<li>虚拟机软件通过打开一个称为 TUN/TAP 的 Char Dev（字符设备文件），打开了这个字符设备文件之后，在物理机上就能看到一张虚拟TAP网卡</li>\n<li>网络包会到虚拟网卡，将网络包转换成为文件流，写入字符设备，就像写一个文件一样。内核中 TUN/TAP 字符设备驱动会收到这个写入的文件流，交给 TUN/TAP 的虚拟网卡驱动。这个驱动将文件流再次转成网络包，交给 TCP/IP 协议栈，最终从虚拟 TAP 网卡发出来，成为标准的网络包</li>\n</ul>\n</li>\n<li><p>虚拟网卡连接到云中：主要有共享（多个网卡共享出口）、隔离（网卡之间无影响）、互通（网卡之间能ping通）、灵活（灵活配置）几方面问题</p>\n<ul>\n<li><p>共享与互通问题</p>\n<ul>\n<li><p>host-only：Linux上通过<code>brctl addbr br0</code>命令创建虚拟的网桥，然后将两个虚拟网卡连接到虚拟网桥上<code>brctl addif br0 tap0</code>，两个虚拟网卡就在相同的子网网段，两个虚拟机可以互相通信</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905215407805.png\" alt=\"image-20220905215407805\" style=\"zoom: 50%;\" /></li>\n<li><p>桥接网络：宿主机多了几张网卡，也就是虚拟交换机，其将多个虚拟机连接在一起，而且物理网卡也连接到这个虚拟交换机，也就是两个虚拟机和物理机是同一网段的。在数据中心只不过将上面的br0再连接到物理网卡上</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905220054989.png\" alt=\"image-20220905220054989\" style=\"zoom:50%;\" /></li>\n<li><p>NAT：上面的不适合虚拟机很多的场景，会有广播的问题。可以通过NAT模式</p>\n<ul>\n<li>在这种方式下，登录到虚拟机里面查看 IP 地址，会发现虚拟机的网络是虚拟机的，物理机的网络是物理机的，两个不相同。虚拟机要想访问物理机的时候，需要将地址 NAT 成为物理机的地址</li>\n<li>还会在笔记本电脑里内置一个 DHCP 服务器，为笔记本电脑上的虚拟机动态分配 IP 地址。也可以手动为每台虚拟机配置IP地址</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905220516865.png\" alt=\"image-20220905220516865\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>隔离问题</p>\n<ul>\n<li>单物理机：brctl 创建的网桥也是支持 VLAN 功能的，可以设置两个虚拟机的 tag，这样在虚拟网桥上，两个虚拟机是不互通的</li>\n<li>跨物理机互通并实现VLAN的隔离：通过vconfig命令，基于物理网卡 eth0 创建带 VLAN 的虚拟网卡，所有从这个虚拟网卡出去的包，都带这个 VLAN，跨物理机的互通和隔离就可以通过这个网卡来实现<ul>\n<li>一个物理机内部因为网桥不同，不能相互通信；出了网桥因为VLAN不同，包也不会被转发到另一个网桥上；出了物理机，会携带VLAN ID，到达另一物理机，包只会被转发给相同VLAN的网卡和网桥</li>\n</ul>\n</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905221151556.png\" alt=\"image-20220905221151556\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-软件定义网络\"><a href=\"#2-软件定义网络\" class=\"headerlink\" title=\"2.软件定义网络\"></a>2.软件定义网络</h4><ol>\n<li><p>软件定义网络（SDN）：一种新型网络创新架构，网络虚拟化的一种实现方式。其核心技术OpenFlow通过将网络设备的控制面与数据面分离开来，从而实现了网络流量的灵活控制，有以下三个特点</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905222926002.png\" alt=\"image-20220905222926002\" style=\"zoom:50%;\" />\n\n<ul>\n<li>控制与转发分离：转发平面就是一个个虚拟或者物理的网络设备，控制平面就是统一的控制中心</li>\n<li>控制平面与转发平面之间的开放接口：控制器向上提供接口（北向接口），被应用层调用；控制器向下调用接口（南向接口），来控制网络设备</li>\n<li>逻辑上的集中控制：逻辑上集中的控制平面可以控制多个转发面设备，也就是控制整个物理网络，因而可以获得全局的网络状态视图，并根据该全局网络状态视图实现对网络的优化控制</li>\n</ul>\n</li>\n<li><p>OpenFlow &amp; OpenvSwitch</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905223316107.png\" alt=\"image-20220905223316107\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>OpenFlow 是 SDN 控制器和网络设备之间互通的南向接口协议，OpenvSwitch 用于创建软件的虚拟交换机，支持 OpenFlow 协议，全都被统一的SDN管理器管理</p>\n</li>\n<li><p>SDN 控制器是如何通过 OpenFlow 协议控制网络：OpenSwitch里面有一个FLow Table规则，任何通过这个交换机的包，都会经过这些规则进行处理，从而接受、转发、放弃。这些规则包括从哪个端口进来，网络包头里面有什么等。满足了条件的网络包，就要执行一个动作，对这个网络包进行处理。可以修改包头里的内容，可以跳到任何一个表格，可以转发到某个网口出去，也可以丢弃</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905224634553.png\" alt=\"image-20220905224634553\"></p>\n<ul>\n<li><p>可以做的处理包括</p>\n<ul>\n<li>对于物理层<ul>\n<li>匹配规则包括从哪个口进来</li>\n<li>执行动作包括从哪个口出去</li>\n</ul>\n</li>\n<li>对于 MAC 层<ul>\n<li>匹配规则包括：源 MAC 地址是多少？（dl_src），目标 MAC 是多少？（dl_dst），所属 vlan 是多少？（dl_vlan）</li>\n<li>执行动作包括：修改源 MAC（mod_dl_src），修改目标 MAC（mod_dl_dst），修改 VLAN（mod_vlan_vid），删除 VLAN（strip_vlan），MAC 地址学习（learn）</li>\n</ul>\n</li>\n<li>对于网络层<ul>\n<li>匹配规则包括：源 IP 地址是多少？(nw_src)，目标 IP 是多少？（nw_dst）。执行动作包括：修改源 IP 地址（mod_nw_src），修改目标 IP 地址（mod_nw_dst）</li>\n<li>对于传输层：匹配规则包括：源端口是多少？（tp_src），目标端口是多少？（tp_dst）。执行动作包括：修改源端口（mod_tp_src），修改目标端口（mod_tp_dst）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建虚拟机</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ovs-vsctl add-br br0</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>示例</p>\n<ul>\n<li>示例一：用 OpenvSwitch 实现 VLAN 的功能<ul>\n<li>在 OpenvSwitch 中端口 port 分两种<ul>\n<li>access port：可以配置tag，类似于VLAN ID</li>\n<li>trunk port：不配置任何tag，配置trunks参数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>示例二：用 OpenvSwitch 模拟网卡绑定，连接交换机<ul>\n<li>在 OpenvSwitch 里面，有个 bond_mode，可以设置为以下三个值<ul>\n<li>active-backup：一个连接是 active，其他的是 backup，只有当 active 失效的时候，backup 才顶上</li>\n<li>balance-slb：流量按照源 MAC 和 output VLAN 进行负载均衡</li>\n<li>balance-tcp：必须在支持 LACP 协议的情况下才可以，可根据 L2、L3、L4 进行负载均衡（L2、L3、L4 指的是网络协议 2、3、4 层）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>示例三：在云计算中使用 OpenvSwitch<ul>\n<li>首先，由于 OpenvSwitch 本身就是支持 VLAN 的，这样所有的虚拟机都可以放在一个网桥 br0 上，通过不同的用户配置不同的 tag，就能够实现隔离</li>\n<li>另外，还可以创建一个虚拟交换机 br1，将物理网络和虚拟网络进行隔离。物理网络有物理网络的 VLAN 规划，虚拟机在一台物理机上，所有的 VLAN 都可以从 1 开始。由于一台物理机上的虚拟机肯定不会超过 4096 个，所以 VLAN 在一台物理机上如果从 1 开始，肯定够用了</li>\n<li>如果物理机之间的通信和隔离还是通过 VLAN 的话，需要将虚拟机的 VLAN 和物理环境的 VLAN 对应起来，但为了灵活性，不一定一致，这样可以实现分别管理物理机的网络和虚拟机的网络</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-云中的网络安全\"><a href=\"#3-云中的网络安全\" class=\"headerlink\" title=\"3.云中的网络安全\"></a>3.云中的网络安全</h4><ol>\n<li><p>对于云上的虚拟机，最好是只开放需要的端口，而将其他的端口一概关闭，这样就可以集中安全措施语这唯一的入口了。常常采用<strong>ACL</strong>（Access Control List 访问控制列表）来控制IP和端口，配置好后，就只有指定的IP段能够访问指定的开放接口，在云平台上，这些规则的集合称为<strong>安全组</strong></p>\n</li>\n<li><p>内核模块ip_tables</p>\n<ul>\n<li><p>一个网络包进入一台机器的处理流程，拿下MAC和IP后，将进行路由判断，路由判断前的节点叫PREROUTING、发给上面的传输层的节点叫INPUT、转发出去的节点叫FORWARD、上层返回处理结果的节点称为OUTPUT、最后一个节点是POSTROUTING</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906200509789.png\" alt=\"image-20220906200509789\" style=\"zoom:50%;\" /></li>\n<li><p>Netfilter框架：Linux内核中的一个框架，可以在上述5个节点中插入hook函数，对数据包进行干预，例如交回协议栈就是ACCEPT、过滤掉不在传输就是DROP、发送给某个用户态进程处理就是QUEUE</p>\n</li>\n<li><p>内核ip_tables：</p>\n<ul>\n<li><p>Netfilter框架的一个实现，可以在上述5个节点埋下函数，按功能可以分为四大类：连接跟踪（conntrack）、数据包的过滤（filter）、网络地址转换（nat）和数据包的修改（mangle），其中连接跟踪是基础功能，被其他功能所依赖</p>\n</li>\n<li><p>用户端程序iptables，用命令行来干预内核的规则。内核的功能对应 iptables 的命令行来讲，就是表和链的概念，iptables的表分为四种（raw、mangel、nat、filter），raw不常用略去，并且分别对应五条链中的若干条</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906201614443.png\" alt=\"image-20220906201614443\"></p>\n<ul>\n<li>filter 表处理过滤功能，主要包含三个链：INPUT 链：过滤所有目标地址是本机的数据包；FORWARD 链：过滤所有路过本机的数据包；OUTPUT 链：过滤所有由本机产生的数据包</li>\n<li>nat 表主要是处理网络地址转换，可以进行 Snat（改变数据包的源地址）、Dnat（改变数据包的目标地址），包含三个链：PREROUTING 链：可以在数据包到达防火墙时改变目标地址；OUTPUT 链：可以改变本地产生的数据包的目标地址；POSTROUTING 链：在数据包离开防火墙时改变数据包的源地址</li>\n<li>mangle 表主要是修改数据包，包含：PREROUTING 链；INPUT 链；FORWARD 链；OUTPUT 链；POSTROUTING 链。</li>\n</ul>\n</li>\n<li><p>iptables 的表和链加入到上面的过程图中，就形成了下面的图和过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906202139019.png\" alt=\"image-20220906202139019\"></p>\n<ul>\n<li>数据包进入的时候，先进 mangle 表的 PREROUTING 链。在这里可以根据需要，改变数据包头内容之后，进入 nat 表的 PREROUTING 链，在这里可以根据需要做 Dnat，也就是目标地址转换。</li>\n<li>进入路由判断，要判断是进入本地的还是转发的。<ul>\n<li>如果是进入本地的，就进入 INPUT 链，之后按条件过滤限制进入。之后进入本机，再进入 OUTPUT 链，按条件过滤限制出去，离开本地。</li>\n<li>如果是转发就进入 FORWARD 链，根据条件过滤限制转发。之后进入 POSTROUTING 链，这里可以做 Snat，离开网络接口。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>在云中实现一定的安全策略</p>\n<ul>\n<li><p>可以通过iptables的配置来实现一些安全策略</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ iptables -t filter -A INPUT -s 0.0.0.0&#x2F;0.0.0.0 -d X.X.X.X -j DROP\n$ iptables -I INPUT -s 0.0.0.0&#x2F;0.0.0.0 -d X.X.X.X -p tcp --dport 22 -j ACCEPT\n$ iptables -A INPUT -s 0.0.0.0&#x2F;0.0.0.0 -d X.X.X.X -p tcp --dport 80 -j ACCEPT</code></pre></li>\n<li><p>安全组：云平台上允许一个或多个虚拟机属于某个安全组，而属于不同安全组的虚拟机之间的访问以及外网访问虚拟机，都需要安全组进行过滤，安全组的规则（iptables配置）会自动下发到每个在安全组里的虚拟机上</p>\n<ul>\n<li>安全组A允许任意 IP 地址 0.0.0.0/0 访问 8080 端口，但是对于 ssh 的 22 端口，仅仅允许管理员网段 203.0.113.0/24 访问</li>\n<li>安全组 B 里面，仅仅允许来自安全组 A 的机器访问 3306 端口，但是对于 ssh 的 22 端口，同样允许管理员网段 203.0.113.0/24 访问</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906203345386.png\" alt=\"image-20220906203345386\"></p>\n</li>\n<li><p>Netfilter的链接跟踪功能（conntrack）：所有虚拟机共享一个机房网和公网IP地址，解决返回的数据包怎么转发到对应的私有IP所在的虚拟机。通过在conntrack表里记录TCP连接和私网IP的对应关系</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">源地址转换 (Snat)： $ iptables -t nat -A -s 私网 IP -j Snat --to-source 外网 IP\n目的地址转换 (Dnat)：$ iptables -t nat -A -PREROUTING -d 外网 IP -j Dnat --to-destination 私网 IP</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-云中的网络QoS\"><a href=\"#4-云中的网络QoS\" class=\"headerlink\" title=\"4.云中的网络QoS\"></a>4.云中的网络QoS</h4><ol>\n<li><p>QoS（Quality of Service）：云平台上的一种流量控制技术，对于控制一台机器的网络的QoS，分为两个方向，入方向和出方向，只能通过Shaping控制出方向，进入方向无法控制，只能通过Policy将包丢弃</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906205817586.png\" alt=\"image-20220906205817586\" style=\"zoom: 50%;\" /></li>\n<li><p>控制网络的QoS：在 Linux 下，可以通过 TC （流量控制工具）控制网络的 QoS，主要就是通过队列的方式</p>\n<ul>\n<li><p>无类别排队规则</p>\n<ul>\n<li><p>无类别排队规则（Classless Queuing Disciplines）：如ip addr返回的pfifo_fast，是一种不把网络包分类的技术，pfifo_fast 分为三个先入先出的队列，称为三个 Band。根据网络包里面 TOS，看这个包到底应该进入哪个队列。TOS 总共四位，每一位表示的意思不同，总共十六种类型</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906210554612.png\" alt=\"image-20220906210554612\" style=\"zoom:50%;\" /></li>\n<li><p>随机公平队列（Stochastic Fair Queuing）：会建立若干FIFO队列，TCP Session会计算hash值，通过hash值分配到某个队列，队列另一端，通过轮询从各队列取网络包并发送，防止一个Session占据所有流量</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906210618402.png\" alt=\"image-20220906210618402\"></p>\n</li>\n<li><p>令牌桶规则（TBF，Token Bucket Filte）：所有的网络包排成队列进行发送，但不是到了队头就能发送，而是需要拿到令牌才能发送。令牌根据设定的速度生成，所以即便队列很长，也是按照一定的速度进行发送的</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906210746916.png\" alt=\"image-20220906210746916\"></p>\n</li>\n</ul>\n</li>\n<li><p>基于类别的队列规则</p>\n<ul>\n<li><p>分层令牌桶规则（HTB， Hierarchical Token Bucket）：HTB往往是一棵树，特点是同一个 root class 下的子类可以相互借流量</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ tc qdisc add dev eth0 root handle 1: htb default 12\n$ tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps\n$ tc class add dev eth0 parent 1:1 classid 1:10 htb rate 30kbps ceil 100kbps\n$ tc class add dev eth0 parent 1:1 classid 1:11 htb rate 10kbps ceil 100kbps\n$ tc class add dev eth0 parent 1:1 classid 1:12 htb rate 60kbps ceil 100kbps\n$ tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5\n$ tc qdisc add dev eth0 parent 1:11 handle 30: pfifo limit 5\n$ tc qdisc add dev eth0 parent 1:12 handle 40: sfq perturb 10</code></pre>\n\n\n\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220906211458384.png\" alt=\"image-20220906211458384\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何控制QoS</p>\n<ul>\n<li><p>对于进入的流量，可以设置策略Ingress policy</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ovs-vsctl set Interface tap0 ingress_policing_rate&#x3D;100000\novs-vsctl set Interface tap0 ingress_policing_burst&#x3D;10000</code></pre></li>\n<li><p>对于发出的流量，可以设置QoS规则Egress shaping，支持 HTB</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-云中网络的隔离GRE、VXLAN\"><a href=\"#5-云中网络的隔离GRE、VXLAN\" class=\"headerlink\" title=\"5.云中网络的隔离GRE、VXLAN\"></a>5.云中网络的隔离GRE、VXLAN</h4><h3 id=\"2-容器技术中的网络\"><a href=\"#2-容器技术中的网络\" class=\"headerlink\" title=\"2.容器技术中的网络\"></a>2.容器技术中的网络</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>云计算解决了基础资源层的弹性伸缩，但没有解决PaaS层应用随基础资源层弹性伸缩而带来的批量、快速部署问题，于是，容器应运而生</p></blockquote>\n<h4 id=\"1-容器网络\"><a href=\"#1-容器网络\" class=\"headerlink\" title=\"1.容器网络\"></a>1.容器网络</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>主要依靠两种技术：看起来隔离的技术namespace、用起来隔离的技术cgroup</p></blockquote>\n<ol>\n<li>namespace<ul>\n<li>类似于面向对象编程语言的命名空间，每个namespace中的应用看到的是不同的IP地址、用户空间、进程号等。网络的namespace有ip netns命令操作，可以创建、删除、查询namespace</li>\n<li></li>\n</ul>\n</li>\n<li><h2 id=\"cgroup：虽然整台机器有很多的CPU、内存，但是一个应用只能用其中的一部分\"><a href=\"#cgroup：虽然整台机器有很多的CPU、内存，但是一个应用只能用其中的一部分\" class=\"headerlink\" title=\"cgroup：虽然整台机器有很多的CPU、内存，但是一个应用只能用其中的一部分\"></a>cgroup：虽然整台机器有很多的CPU、内存，但是一个应用只能用其中的一部分</h2></li>\n<li></li>\n</ol>\n<h4 id=\"2-容器网络之Flannel\"><a href=\"#2-容器网络之Flannel\" class=\"headerlink\" title=\"2.容器网络之Flannel\"></a>2.容器网络之Flannel</h4><h4 id=\"3-容器网络之Callco\"><a href=\"#3-容器网络之Callco\" class=\"headerlink\" title=\"3.容器网络之Callco\"></a>3.容器网络之Callco</h4><h3 id=\"3-微服务相关协议\"><a href=\"#3-微服务相关协议\" class=\"headerlink\" title=\"3.微服务相关协议\"></a>3.微服务相关协议</h3><h4 id=\"1-RPC协议综述\"><a href=\"#1-RPC协议综述\" class=\"headerlink\" title=\"1.RPC协议综述\"></a>1.RPC协议综述</h4><ol>\n<li><p>定义：Bruce Jay Nelson 写了一篇论文Implementing Remote Procedure Calls，定义了RPC的调用标准，后面所有RPC框架都是基于此标准，架构如下</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909195002217.png\" alt=\"image-20220909195002217\"></p>\n</li>\n<li><p>NFS为例</p>\n<ul>\n<li><p>NFS（Network File System）就是网络文件系统。要使 NFS 成功运行，要启动两个服务端，一个是 mountd，用来挂载文件路径；一个是 nfsd，用来读写文件。NFS 可以在本地 mount 一个远程的目录到本地的一个目录，从而本地的用户在这个目录里面写入、读出任何文件的时候，其实操作的是远程另一台机器上的文件（XDR是一个标准的数据压缩格式，可以表示基本的数据类型，也可以表示结构体）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909195912465.png\" alt=\"image-20220909195912465\"></p>\n</li>\n<li><p>协议约定问题（约定各种格式）</p>\n<ul>\n<li><p>RPC调用过程中，所有数据类型都要封装成特定的格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909200134412.png\" alt=\"image-20220909200134412\"></p>\n</li>\n<li><p>RPC调用和结果返回有严格的格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909195950053.png\" alt=\"image-20220909195950053\"></p>\n</li>\n<li><p>在客户端和服务端实现 RPC 的时候，首先要定义一个双方都认可的程序、版本、方法、参数等</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909200239865.png\" alt=\"image-20220909200239865\"></p>\n</li>\n</ul>\n</li>\n<li><p>传输问题：</p>\n<ul>\n<li><p>通过ONE RPC的的类库来实现，对于每一个客户端，都会创建一个传输管理层，而每一次RPC调用，都会是一个任务，在传输管理层，可以看到队列机制、拥塞窗口机制</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909201414822.png\" alt=\"image-20220909201414822\"></p>\n</li>\n<li><p>状态转换图</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909201558310.png\" alt=\"image-20220909201558310\"></p>\n</li>\n</ul>\n</li>\n<li><p>服务发现问题：在ONE RPC中，通过portmapper实现，portmapper会启动在一个众所周知的端口上，PRC程序是用户自己写的，会监听在一个随机端口上，但是RPC程序启动的时候会向portmapper注册，客户端要访问RPC服务端这个服务的时候，首先查询portmapper，获取RPC程序的随机端口，然后向这个端口建立连接，开始RPC调用</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220909202101111.png\" alt=\"image-20220909202101111\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-基于XML的SOAP协议\"><a href=\"#2-基于XML的SOAP协议\" class=\"headerlink\" title=\"2.基于XML的SOAP协议\"></a>2.基于XML的SOAP协议</h4><ol>\n<li></li>\n</ol>\n<h4 id=\"3-基于JSON的RESTful接口协议\"><a href=\"#3-基于JSON的RESTful接口协议\" class=\"headerlink\" title=\"3.基于JSON的RESTful接口协议\"></a>3.基于JSON的RESTful接口协议</h4><h4 id=\"4-二进制类RPC协议\"><a href=\"#4-二进制类RPC协议\" class=\"headerlink\" title=\"4.二进制类RPC协议\"></a>4.二进制类RPC协议</h4><h4 id=\"5-跨语言类RPC协议\"><a href=\"#5-跨语言类RPC协议\" class=\"headerlink\" title=\"5.跨语言类RPC协议\"></a>5.跨语言类RPC协议</h4><h1 id=\"Kubernetes\"><a href=\"#Kubernetes\" class=\"headerlink\" title=\"Kubernetes\"></a>Kubernetes</h1><h2 id=\"1-Docker\"><a href=\"#1-Docker\" class=\"headerlink\" title=\"1.Docker\"></a>1.Docker</h2><h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h3><ol>\n<li><p>docker 架构（通过docker run hello-world可以展示详细工作流程）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/c8116066bdbf295a7c9fc25b87755dfe-20221027082916785.jpg\" alt=\"img\"></p>\n<ul>\n<li>命令行工具docker实际上是一个client，他会与Docker Engine里的后台服务Docker daemon通信，镜像存储在远端的Registry里，客户端不能直接访问镜像仓库</li>\n<li>Docker client可以通过build、pull、run等命令向Docker daemon发送请求，而Docker daemon则负责从远端拉去镜像、在本地存储镜像、从镜像生成容器、管理容器等功能</li>\n<li>容器化的应用：指应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行。镜像就是静态的应用容器，容器就是动态的应用镜像</li>\n</ul>\n</li>\n<li><p>隔离怎么实现的</p>\n<ul>\n<li>其实奥秘就在于 Linux 操作系统内核之中，为资源隔离提供了三种技术：namespace、cgroup、chroot，虽然这三种技术的初衷并不是为了实现容器，但它们三个结合在一起就会发生奇妙的“化学反应”</li>\n<li>namespace 是 2002 年从 Linux 2.4.19 开始出现的，和编程语言里的 namespace 有点类似，它可以创建出独立的文件系统、主机名、进程号、网络等资源空间，相当于给进程盖了一间小板房，这样就实现了系统全局资源和进程局部资源的隔离</li>\n<li>cgroup 是 2008 年从 Linux 2.6.24 开始出现的，它的全称是 Linux Control Group，用来实现对进程的 CPU、内存等资源的优先级和配额限制，相当于给进程的小板房加了一个天花板</li>\n<li>chroot 的历史则要比前面的 namespace、cgroup 要古老得多，早在 1979 年的 UNIX V7 就已经出现了，它可以更改进程的根目录，也就是限制访问文件系统，相当于给进程的小板房铺上了地砖</li>\n</ul>\n</li>\n<li><p>镜像的内部机制</p>\n<ul>\n<li><p>分层（Layer）：容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫“Union FS 联合文件系统”的技术把它们合并在一起，就形成了容器最终看到的文件系统</p>\n<ul>\n<li>如果某两层有文件同名，则只能看到上层的文件，下层的就被屏蔽了，可以使用<code>docker inspect nginx:alpine</code>来查看镜像的分层信息（RootFS部分）</li>\n<li>在拉取镜像的时候，只会拉取缺少的层；在删除镜像的时候，只会删除没有未被共享的层</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/c750a7795ff4787c6639dd42bf0a473f.png\" alt=\"img\"></p>\n</li>\n<li><p>容器与外部互联互通</p>\n<ul>\n<li><p>文件</p>\n<ul>\n<li><code>docker cp+源路径+目标路径</code> 命令可以在容器和主机之间互相拷贝文件，适合简单的数据交换，其中目标路径需要用容器名/ID来指明是那个容器的路径，示例：<code>docker cp a.txt 062:/tmp</code></li>\n<li><code>docker run -v </code>命令可以让容器和主机共享本地目录，免去了拷贝操作，提升工作效率，示例：<code>docker run -d --rm -v /tmp:/tmp redis</code>，格式为<code>宿主机路径: 容器内路径</code>，把本机的/tmp路径挂载道容器里的/tmp目录，常用于不同环境运行相同文件</li>\n</ul>\n</li>\n<li><p>网络</p>\n<ul>\n<li><p>网络分类</p>\n<ul>\n<li>host 网络模式让容器与主机共享网络栈，效率高但容易导致端口冲突，<code>docker run -d --rm --net=host nginx:alpine</code></li>\n<li>bridge 网络模式实现了一个虚拟网桥，容器和主机都在一个私有网段内互联互通，默认使用此模式</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221027103403516.png\" alt=\"image-20221027103403516\" style=\"zoom: 25%;\" /></li>\n<li><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息</p>\n</li>\n<li><p>新建网络：<code>docker network create -d bridge test-net</code></p>\n<ul>\n<li>-d：指定Docker网络类型，可以是bridge、overlay（用于Swarm）</li>\n</ul>\n</li>\n<li><p>连接容器</p>\n<ul>\n<li><p>运行一个容器并连接到新建的 test-net 网络:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -itd --name test1 --network test-net ubuntu &#x2F;bin&#x2F;bash</code></pre></li>\n<li><p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -itd --name test2 --network test-net ubuntu &#x2F;bin&#x2F;bash</code></pre></li>\n<li><p>test1和test2可以互相ping通，二者建立了互联关系，如果有多个容器，推荐使用Docker Compose</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>网络端口映射：<code>docker run -p </code>命令可以把主机的端口号映射到容器的内部端口号，解决了潜在的端口冲突</p>\n<ul>\n<li><p>-P：是容器内部端口<strong>随机</strong>映射到主机的端口</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py\n33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</code></pre></li>\n<li><p>-p：是容器内部端口绑定到<strong>指定</strong>的主机端口，还可以附加绑定网络地址</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py\n6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a</code></pre></li>\n</ul>\n</li>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-常用操作\"><a href=\"#2-常用操作\" class=\"headerlink\" title=\"2.常用操作\"></a>2.常用操作</h3><ol>\n<li><p>安装docker服务</p>\n<ul>\n<li>安装docker：<code>sudo apt install -y docker.io</code></li>\n<li>启动docker服务：<code>sudo service docker start</code></li>\n<li>当前用户加入docker组：<code>sudo usermod -aG docker $&#123;USER&#125;</code>，<ul>\n<li>因为操作 Docker 必须要有 root 权限，而直接使用 root 用户不够安全</li>\n<li>Docker官方推荐将当前用户加入 Docker 用户组</li>\n<li>执行完成之后，还需要退出系统（命令 exit ），再重新登录一次，这样才能让修改用户组的命令 usermod 生效</li>\n</ul>\n</li>\n<li>验证docker是否安装成功：<code>docker version</code>和<code>docker info</code></li>\n</ul>\n</li>\n<li><p>docker使用</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/27364161a8d3c1f960a91e07b5094419.jpg\" alt=\"img\"></p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/c8cd008e91aaff2cd91e0392b0079085.jpg\" alt=\"img\"></p>\n<ul>\n<li><p>查看镜像/容器：</p>\n<ul>\n<li><p>查看运行的容器：<code>docker ps</code></p>\n<ul>\n<li>CONTAINER ID: 容器 ID；IMAGE: 使用的镜像；COMMAND**:** 启动容器时运行的命令；CREATED: 容器的创建时间</li>\n<li>STATUS: 容器状态，主要有7种状态：created（已创建）、restarting（重启中）、running 或 Up（运行中）、removing（迁移中）、paused（暂停）、exited（停止）、dead（死亡）</li>\n<li>PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）；NAMES: 自动分配的容器名称</li>\n</ul>\n</li>\n<li><p>查看运行完毕的容器：<code>docker ps -a</code></p>\n</li>\n<li><p>查看已存储镜像的信息：<code>docker images</code></p>\n<ul>\n<li>REPOSITORY：表示镜像的仓库源，通过REPOSITORY:TAG来定义不同的镜像；TAG<strong>：</strong>镜像的标签，同一仓库可以有多个TAG，代表这个仓库的不同个版本；IMAGE ID：镜像ID；CREATED<strong>：</strong>镜像创建时间；SIZE<strong>：</strong>镜像大小</li>\n</ul>\n</li>\n<li><p>可以通过<code>docker logs 容器ID</code>来查看容器内的标准输出</p>\n</li>\n<li><p>查找镜像：<code>docker search 镜像名</code></p>\n<ul>\n<li>NAME: 镜像仓库源的名称；DESCRIPTION：镜像的描述；OFFICIAL: 是否 docker 官方发布；stars: 类似 Github 里面的 star；AUTOMATED: 自动构建</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拉取镜像：<code>docker pull busybox</code></p>\n<ul>\n<li>获取一个打包了的busybox应用的镜像，里面固化了busybox程序和它所需的完整运行环境</li>\n<li>镜像的完整名字由两个部分组成：<code>名字:标签</code>，标签（tag）是为了区分不同版本的应用而做的额外标记，可以是任意字符串，默认标签是<code>latest</code></li>\n</ul>\n</li>\n<li><p>启动镜像：<code>docer run+参数+镜像名/ID+运行命令</code>（通过<code>docker run --help</code>来查看帮助信息）</p>\n<ul>\n<li>启动并执行echo输出字符串：<code>docker run busybox echo hello world</code>，提取镜像里的各种信息，运用namespace、cgroup、chroot技术创造出隔离环境，然后运行busybox的echo命令，输出字符串</li>\n<li>启动镜像，离开当前操作系统，进入新系统：<code>docker run -it arm64v8/ubuntu /bin/bash</code>，<code>-it</code>表示开启一个交互式操作的Shell，可以直接进入容器内部，通过exit命令或者Crtl+D退出<ul>\n<li>-t: 在新容器内指定一个伪终端或终端</li>\n<li>-i: 允许对容器内的标准输入 (STDIN) 进行交互</li>\n</ul>\n</li>\n<li>后台运行：<code>docker run -d --name red_srv redis</code>，<code>-d</code>表示让容器在后台运行，用于启动服务器程序；<code>--name</code>可以为容器起一个名字，否则会分配一个随机的名字</li>\n<li>可以通过IMAGE ID进行短路操作，仅使用前几位就可定位到对应容器</li>\n<li><code>docker run -d --rm redis</code>：<code>--rm</code>参数告诉Docker不保存容器，再运行完毕后就自动清除</li>\n</ul>\n</li>\n<li><p>删除镜像：<code>docker rmi redis</code></p>\n<ul>\n<li><code>docker rm ID</code>：只会删除容器，不会删除镜像 </li>\n</ul>\n</li>\n<li><p>停止容器：<code>docker stop CONTAINER ID</code></p>\n<ul>\n<li>只能通过<code>docker ps -a</code>查看已停止运行的容器，通过<code>docker start ID</code>再次启动运行</li>\n</ul>\n</li>\n<li><p>运行的容器中在执行另一程序：<code>docker exec -it red_srv sh</code>，登陆进入Redis容器，方便查看服务的运行状态和日志。效果同docker run，但因为容器已存在，所以不会创建新容器</p>\n<ul>\n<li>进入容器：通过<code>docker exec -it 容器ID /bin/bash</code>来进入后台运行的容器，并且推出时不会导致容器终止，<code>docker attach 容器ID</code>会在退出时终止容器</li>\n</ul>\n</li>\n<li><p>导出和导入容器</p>\n<ul>\n<li>导出本地某个容器：<code>docker export 容器ID &gt; ubuntu.tar</code></li>\n<li>从容器快照文件中再导入为镜像：<code>cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建容器</p>\n<ul>\n<li><p>Dockerfile：一个纯文本，里面记录了一些列的构建指令，比如选择基础镜像、拷贝文件、执行脚本等，每个指令都会生成一个Layer，而Docker顺序执行这个文件的所有步骤，最终会创建出一个新的镜像出来</p>\n</li>\n<li><p>Dockerfile内部指令（不区分大小写，一条指令生成一个镜像）</p>\n<ul>\n<li><code>FROM</code>：所有Dockerfile都要从它开始，表示选择构建使用的基础镜像，相当于打地基，如果关注镜像的安全和大小，一般选择Alpine；如果关注运行的稳定性，则可以选择Ubuntu、CentOS、Debian</li>\n<li><code>CMD</code>：制定docker run启动容器时默认运行的命令</li>\n<li><code>COPY</code>：需要把开发测试产生的一一些源码、配置等文件打包进镜像里，拷贝的源文件必须是构建上下文路径，不能随意指定文件，也就是说，必须把这些文件放在一个专门的目录，然后再docker build里指定构建上下文到这个目录才行</li>\n<li><code>RUN</code>：执行任意的Shell命令，实现任意的镜像构建步骤，所有RUN指令会在每行的末尾使用续行符<code>\\</code>，命令之间也会用<code>&amp;&amp;</code>来连接，这样保证在逻辑上是一行（可以把这些Shell集中到一个脚本文件，然后用COPY命令拷贝进去在用RUN来执行）</li>\n<li><code>ARG</code>：用于创建变量，创建的变量只在镜像构建过程中可见，容器运行时不可见</li>\n<li><code>ENV</code>：用于创建变量，创建的变量不仅能够在构建镜像的过程中使用，在容器运行时也能够以环境变量的形式被应用程序使用</li>\n<li><code>EXPOSE</code>：用来声明容器对外服务的端口号，对现在基于Node.js、Tomcat、Nginx、Go等开发的微服务系统来说非常有用</li>\n</ul>\n</li>\n<li><p>构建镜像：<code>docker build -f Dockerfile.busybox .</code>，-f指定Dockerfile文件名，后面必须跟一个文件路径，叫做构建上下文（build‘s context），这里只是一个简单的点号，表示当前路径</p>\n<ul>\n<li><p>新的镜像暂时没有名字（<code>&lt;none&gt;</code>），可以直接使用ID来查看或运行，可以通过<code>-t</code>参数来指定镜像的标签（tag），名字需要符合规范，用:分割名字和标签</p>\n</li>\n<li><p>构建上下文：docker客户端只是把构建上下文目录打包上传，这样服务器才能获得本地的这些文件，就是指定了要打包进镜像的一些依赖文件</p>\n</li>\n<li><p>为了避免目录中某些不必要文件（例如 readme/.git/.svn 等）拷贝进镜像，可以在构建上下文目录里再建立一个 .dockerignore 文件，语法与 .gitignore 类似，排除那些不需要的文件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat Dockerfile #每一指令都会在镜像上创建一个新的层，每一指令的前缀都必须是大写\nFROM    centos:6.7 #指定使用哪个镜像源\nMAINTAINER      Fisher &quot;fisher@sudops.com&quot;\n#RUN 指令告诉docker 在镜像内执行命令，安装了什么\nRUN     &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd\nRUN     useradd runoob\nRUN     &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswd\nRUN     &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\\&quot;en_US.UTF-8\\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;local\nEXPOSE  22\nEXPOSE  80\nCMD     &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre></li>\n</ul>\n</li>\n<li><p>更新已有镜像并提交：-m提交的描述信息、-a镜像作者、e218edb10161容器ID、runoob/ubuntu:v2镜像名。可以使用dockr images来查看新镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker commit -m&#x3D;&quot;has update&quot; -a&#x3D;&quot;runoob&quot; e218edb10161 runoob&#x2F;ubuntu:v2\nsha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</code></pre></li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-实践\"><a href=\"#3-实践\" class=\"headerlink\" title=\"3.实践\"></a>3.实践</h3><h4 id=\"1-Docker容器引擎\"><a href=\"#1-Docker容器引擎\" class=\"headerlink\" title=\"1.Docker容器引擎\"></a>1.<a href=\"https://segmentfault.com/a/1190000019462392\">Docker容器引擎</a></h4><h5 id=\"1-Docker出现的背景\"><a href=\"#1-Docker出现的背景\" class=\"headerlink\" title=\"1. Docker出现的背景\"></a>1. Docker出现的背景</h5><p>　　在平常的研发和项目场景中，以下情况普遍存在：</p>\n<ul>\n<li><strong>个人开发环境</strong><br>为了做大数据相关项目，需要安装一套CDH集群，常见的做法是在自己电脑里搭建3台与CDH版本对应的虚拟机，把CDH集群装起来后，考虑到以后很有可能还要使用一个干净的CDH集群，为了避免以后重复安装环境，通常会对整套CDH集群做一个备份，这样电脑里就有6个虚拟机镜像了。另外，后面在学习其他技术时，比如学习Ambari大数据集群，那么为了不破坏已有的虚拟机环境，又要重新搭建3台虚拟机，本机磁盘很快被一大堆的虚拟机镜像占满。</li>\n<li><strong>公司内部开发环境</strong><br>公司里往往会以小团队的方式来做项目，一般由运维部门从他们管理的服务器资源中分配出虚拟机供团队内部开发测试使用。比如做一个与机器学习相关的项目：<ul>\n<li>小明在运维部门分配的虚拟机上搭建了一套Ambari集群，拿来跑大数据相关业务</li>\n<li>小刚用python3写了一个机器学习算法，放到虚拟机上运行发现虚拟机里是python2，算法不兼容，于是把虚拟机里的python版本升级了，算法跑通了，但Ambari用到python的部分功能可能就报错了</li>\n<li>小李开发了应用，放到虚拟机上启动tomcat，发现虚拟机里的是OpenJDK，导致tomcat起不来，于是又安装了一个JDK，这时候可能Ambari里的Java代码可能就报错了</li>\n<li>小赵想利用服务器资源做性能测试，发现虚拟机严重削减了性能，最终还是要直接找物理机来跑测试，破坏了物理机原来的环境</li>\n<li>做完项目后，这些虚拟机上安装的东西往往变得没用了，下个项目组来还是得新申请虚拟机重新部署软件</li>\n</ul>\n</li>\n<li><strong>开发/测试/现场环境</strong><br>研发人员在开发环境里写好了代码做好测试后，提交给测试部门，测试人员在测试环境跑起来发现有BUG，研发人员说在开发环境没这个BUG，和测试人员多次扯皮解决BUG后发布版本，发到现场在生产环境部署后，又发现有BUG，这下轮到工程人员和测试人员扯皮。有时候为了兼容特殊的现场环境，还需要对代码进行定制化修改，拉出分支，这样导致了每次到现场升级都是一场噩梦</li>\n<li><strong>升级或迁移项目</strong><br>在每次发版本要升级到现场时，如果现场起了多个tomcat应用，那么需要对每个tomcat都先停掉，替换war包，然后再起起来，轮流着做，不仅繁琐而且很容易出错，如果遇到升级后出现严重BUG，还要手工做回退。另外，如果项目想上云，那么在云上部署后要重新进行一轮测试，如果后面考虑还云厂商，可能相同的测试还要再进行一次（比如更换了数据存储组件），费时费力。</li>\n</ul>\n<p>　　总结以上列举的所有场景，他们存在的一个共同的问题是：没有一种既能够屏蔽操作系统差异，又能够以不降低性能的方式来运行应用的技术，来解决环境依赖的问题。Docker应运而生。</p>\n<h5 id=\"2-Docker是什么\"><a href=\"#2-Docker是什么\" class=\"headerlink\" title=\"2. Docker是什么\"></a>2. Docker是什么</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPbL.png\" alt=\"clipboard.png\"></p>\n<p>　　Docker是一种应用容器引擎。首先说一下何为容器，Linux系统提供了<code>Namespace</code>和<code>CGroup</code>技术实现环境隔离和资源控制，其中Namespace是Linux提供的一种内核级别环境隔离的方法，能使一个进程和该进程创建的子进程的运行空间都与Linux的超级父进程相隔离，注意Namespace只能实现运行空间的隔离，物理资源还是所有进程共用的，为了实现资源隔离，Linux系统提供了CGroup技术来控制一个进程组群可使用的资源（如CPU、内存、磁盘IO等），把这两种技术结合起来，就能构造一个用户空间独立且限定了资源的对象，这样的对象称为容器。<code>Linux Container</code>是Linux系统提供的容器化技术，简称<code>LXC</code>，它结合Namespace和CGroup技术为用户提供了更易用的接口来实现容器化。LXC仅为一种轻量级的容器化技术，它仅能对部分资源进行限制，无法做到诸如网络限制、磁盘空间占用限制等。dotCloud公司结合LXC和<code>以下列出的技术</code>实现了Docker容器引擎，相比于LXC，Docker具备更加全面的资源控制能力，是一种应用级别的容器引擎。</p>\n<ul>\n<li><strong>Chroot：</strong>该技术能在container里构造完整的Linux文件系统；</li>\n<li><strong>Veth：</strong>该技术能够在主机上虚拟出一张网卡与container里的eth0网卡进行桥接，实现容器与主机、容器之间的网络通信；</li>\n<li><strong>UnionFS：</strong>联合文件系统，Docker利用该技术“Copy on Write”的特点实现容器的快速启动和极少的资源占用，后面会专门介绍该文件系统；</li>\n<li><strong>Iptables/netfilter：</strong>通过这两个技术实现控制container网络访问策略；</li>\n<li><strong>TC：</strong>该技术主要用来做流量隔离，限制带宽；</li>\n<li><strong>Quota：</strong>该技术用来限制磁盘读写空间的大小；</li>\n<li><strong>Setrlimit：</strong>该技术用来限制container中打开的进程数，限制打开的文件个数等</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>也正是因为Docker依赖Linux内核的这些技术，至少使用3.8或更高版本的内核才能运行Docker容器，官方建议使用3.10以上的内核版本。</p></blockquote>\n<h5 id=\"3-与传统虚拟化技术的区别\"><a href=\"#3-与传统虚拟化技术的区别\" class=\"headerlink\" title=\"3. 与传统虚拟化技术的区别\"></a>3. 与传统虚拟化技术的区别</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPbM.png\" alt=\"clipboard.png\"></p>\n<p>　　传统的虚拟化技术在虚拟机（VM）和硬件之间加了一个软件层Hypervisor，或者叫做虚拟机管理程序。Hypervisor的运行方式分为两类：</p>\n<ul>\n<li>直接运行在物理硬件之上。如基于内核的KVM虚拟机，这种虚拟化需要CPU支持虚拟化技术；</li>\n<li>运行在另一个操作系统。如VMWare和VitrualBox等虚拟机。</li>\n</ul>\n<p>　　因为运行在虚拟机上的操作系统是通过Hypervisor来最终分享硬件，所以虚拟机Guest OS发出的指令都需要被Hypervisor捕获，然后翻译为物理硬件或宿主机操作系统能够识别的指令。VMWare和VirtualBox等虚拟机在性能方面远不如裸机，但基于硬件虚拟机的KVM约能发挥裸机80%的性能。这种虚拟化的优点是不同虚拟机之间实现了完全隔离，安全性很高，并且能够在一台物理机上运行多种内核的操作系统（如Linux和Window），但每个虚拟机都很笨重，占用资源多而且启动很慢。</p>\n<p>　　Docker引擎运行在操作系统上，是基于内核的LXC、Chroot等技术实现容器的环境隔离和资源控制，在容器启动后，容器里的进程直接与内核交互，无需经过Docker引擎中转，因此几乎没有性能损耗，能发挥出裸机的全部性能。但由于Docker是基于Linux内核技术实现容器化的，因此使得容器内运行的应用只能运行在Linux内核的操作系统上。目前在Window上安装的docker引擎其实是利用了Window自带的Hyper-V虚拟化工具自动创建了一个Linux系统，容器内的操作实际上是间接使用这个虚拟系统实现的。</p>\n<h5 id=\"4-Docker基本概念\"><a href=\"#4-Docker基本概念\" class=\"headerlink\" title=\"4. Docker基本概念\"></a>4. Docker基本概念</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPbO.png\" alt=\"clipboard.png\"></p>\n<p>　　Docker主要有如下几个概念：</p>\n<ul>\n<li><strong>引擎：</strong>创建和管理容器的工具，通过读取镜像来生成容器，并负责从仓库拉取镜像或提交镜像到仓库中；</li>\n<li><strong>镜像：</strong>类似于虚拟机镜像，一般由一个基本操作系统环境和多个应用程序打包而成，是创建容器的模板；</li>\n<li><strong>容器：</strong>可看作一个简易版的Linxu系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子；</li>\n<li><strong>仓库：</strong>集中存放镜像文件的场所，分为公共仓库和私有仓库，目前最大的公共仓库是官方提供的Docker Hub，此外国内的阿里云、腾讯云等也提供了公共仓库；</li>\n<li><strong>宿主机：</strong>运行引擎的操作系统所在服务器。</li>\n</ul>\n<h5 id=\"5-Docker与虚拟机、Git、JVM的类比\"><a href=\"#5-Docker与虚拟机、Git、JVM的类比\" class=\"headerlink\" title=\"5. Docker与虚拟机、Git、JVM的类比\"></a>5. Docker与虚拟机、Git、JVM的类比</h5><p>　　为了让大家对Docker有更直观的认识，下面分别进行三组类比：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPbP.png\" alt=\"clipboard.png\"></p>\n<p>　　上图中Docker的镜像仓库类似于传统虚拟机的镜像仓库或存放镜像的本地文件系统，Docker引擎启动容器来运行Spark集群（容器内包含基础的Linux操作系统环境），类比于虚拟机软件启动多个虚拟机，在虚拟机内分别运行Spark进程，两者区别在于Docker容器内的应用在使用物理资源时，直接与内核打交道，无需经过Docker引擎。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPbQ.png\" alt=\"clipboard.png\"></p>\n<p>　　Docker的仓库思想与Git是相同的。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPbR.png\" alt=\"clipboard.png\"></p>\n<p>　　Docker的口号是“Build，Ship，and Run Any App，Anywhere”，也就是可以基于Docker构建、装载和运行应用程序，一次构建到处运行。Java的口号是“Write Once,Run Anywhere”，即一次编写到处运行。Java是基于JVM适配操作系统的特点来屏蔽系统的差异，Docker则是利用内核版本兼容性的特点来实现一次构建导出运行，只要Linux系统的内核是3.8或更高的版本，就都能把容器跑起来。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当然，正如Java中如果应用代码使用了JDK10的新特性，基于JDK8就无法运行一样，如果容器内的应用使用了4.18版本的内核特性，那么在CentOS7（内核版本为3.10）启动容器时，虽然容器能够启动，但里面应用的功能是无法正常运行的，除非把宿主机的操作系统内核升级到4.18版本。</p></blockquote>\n<h5 id=\"6-Docker镜像文件系统\"><a href=\"#6-Docker镜像文件系统\" class=\"headerlink\" title=\"6. Docker镜像文件系统\"></a>6. Docker镜像文件系统</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPbZ.png\" alt=\"clipboard.png\"></p>\n<p>　　Docker镜像采用分层存储格式，每个镜像可依赖其他镜像进行构建，每一层的镜像可被多个镜像引用，上图的镜像依赖关系，K8S镜像其实是CentOS+GCC+GO+K8S这四个软件结合的镜像。这种分层结构能充分共享镜像层，能大大减少镜像仓库占用的空间，而对用户而言，他们所看到的容器，其实是Docker利用UnionFS（联合文件系统）把相关镜像层的目录“联合”到同一个挂载点呈现出来的一个整体，这里需要简单介绍一个UnionFS是什么：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>UnionFS可以把多个物理位置独立的目录（也叫分支）内容联合挂载到同一个目录下，UnionFS允许控制这些目录的读写权限，此外对于只读的文件和目录，它具有“Copy on Write（写实复制）”的特点，即如果对一个只读的文件进行修改，在修改前会先把文件复制一份到可写层（可能是磁盘里的一个目录），所有的修改操作其实都是对这个文件副本进行修改，原来的只读文件并不会变化。其中一个使用UnionFS的例子是：Knoppix，一个用于Linux演示、光盘教学和商业产品演示的Linux发行版，它就是把一个CD/DVD和一个存在在可读写设备（例如U盘）联合挂载，这样在演示过程中任何对CD/DVD上文件的改动都会在被应用在U盘上，不改变原来的CD/DVD上的内容。</p></blockquote>\n<p>　　UnionFS有很多种，其中Docker中常用的是AUFS，这是UnionFS的升级版，除此之外还有DeviceMapper、Overlay2、ZFS和 VFS等。Docker镜像的每一层默认存放在<code>/var/lib/docker/aufs/diff</code>目录中，当用户启动一个容器时，Docker引擎首先在<code>/var/lib/docker/aufs/diff</code>中新建一个可读写层目录，然后使用UnionFS把该可读写层目录和指定镜像的各层目录联合挂载到<code>/var/lib/docker/aufs/mnt</code>里的一个目录中（其中指定镜像的各层目录都以只读方式挂载），通过LXC等技术进行环境隔离和资源控制，使容器里的应用仅依赖mnt目录中对应的挂载目录和文件运行起来。</p>\n<p>　　利用UnionFS写实复制的特点，在启动一个容器时， Docker引擎实际上只是增加了一个可写层和构造了一个Linux容器，这两者都几乎不消耗系统资源，因此Docker容器能够做到秒级启动，一台服务器上能够启动上千个Docker容器，而传统虚拟机在一台服务器上启动几十个就已经非常吃力了，而且虚拟机启动很慢，这是Docker相比于传统虚拟机的两个巨大的优势。</p>\n<p>　　当应用只是直接调用了内核功能来运作的情况下，应用本身就能直接作为最底层的层来构建镜像，但因为容器本身会隔绝环境，因此容器内部是无法访问宿主机里文件的（除非指定了某些目录或文件映射到容器内），这种情况下应用代码就只能使用内核的功能。但是Linux内核仅提供了进程管理、内存管理、文件系统管理等一些基础且底层的管理功能，在实际的场景中，几乎所有软件都是基于操作系统来开发的，因此往往都需要依赖操作系统的软件和运行库等，如果这些应用的下一层直接是内核，那么应用将无法运行。所以实际上应用镜像往往底层都是基于一个操作系统镜像来补足运行依赖的。</p>\n<p>　　Docker中的操作系统镜像，与平常安装系统时用的ISO镜像不同。ISO镜像里包含了操作系统内核及该发行版系统包含的所有目录和软件，而Docker中的操作系统镜像，不包含系统内核，仅包含系统必备的一些目录（如/etc /proc等）和常用的软件和运行库等，可把操作系统镜像看作内核之上的一个应用，一个封装了内核功能，并为用户编写的应用提供运行环境的工具。应用基于这样的镜像构建，就能够利用上相应操作系统的各种软件的功能和运行库，此外，由于应用是基于操作系统镜像来构建的，就算换到另外的服务器，只要操作系统镜像中被应用使用到的功能能适配宿主机的内核，应用就能正常运行，这就是一次构建到处运行的原因。</p>\n<p>　　下图形象的表现出了镜像和容器的关系：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPb5.png\" alt=\"clipboard.png\"></p>\n<p>　　上图中Apache应用基于emacs镜像构建，emacs基于Debian系统镜像构建，在启动为容器时，在Apache镜像层之上构造了一个可写层，对容器本身的修改操作都在可写层中进行。Debian是该镜像的基础镜像（Base Image），它提供了内核Kernel的更高级的封装。同时其他的镜像也是基于同一个内核来构建的（以下的BusyBox是一个精简版的操作系统镜像）：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPb6.png\" alt=\"clipboard.png\"></p>\n<p>　　这时候就会有一个问题，应用基于操作系统镜像来构建，那如果操作系统镜像本身就很占空间，岂不是镜像的分发不方便，而且镜像仓库占用的空间也会很大。有人已经考虑到这一点，针对不同的场景分别构造了不同的操作系统镜像，下面介绍几种最常用的系统镜像。</p>\n<h5 id=\"7-Docker基础操作系统\"><a href=\"#7-Docker基础操作系统\" class=\"headerlink\" title=\"7. Docker基础操作系统\"></a>7. Docker基础操作系统</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPcb.png\" alt=\"clipboard.png\"></p>\n<p>　　以上系统镜像分别适用于不同的场景：</p>\n<ul>\n<li><strong>BusyBox：</strong>一个极简版的Linux系统，集成了100多种常用Linux命令，大小不到2MB，被称为“Linux系统的瑞士军刀”，适用于简单测试场景；</li>\n<li><strong>Alpine：</strong>一个面向安全的轻型Linux发行版系统，比BusyBox功能更完善，大小不到5MB，是官网推荐的基础镜像，由于其包含了足够的基础功能和体积较小，在生产环境中最常用；</li>\n<li><strong>Debian/Ubuntu：</strong> Debian系列操作系统，功能完善，大小约170MB，适合研发环境；</li>\n<li><strong>CentOS/Fedora：</strong>都是基于Redhat的Linux发行版，企业级服务器常用操作系统，稳定性高，大小约200MB，适合生产环境使用。</li>\n</ul>\n<h5 id=\"8-Docker持久化存储\"><a href=\"#8-Docker持久化存储\" class=\"headerlink\" title=\"8. Docker持久化存储\"></a>8. Docker持久化存储</h5><p>　　根据前面介绍的容器UnionFS写实复制的特点，可知在容器里增加、删除或修改文件，其实都是对可写层里的文件副本进行了操作。在容器关闭后，该可写层也会被删除，对容器的所有修改都会失效，因此需要解决容器内文件持久化的问题。Docker提供了两种方案来实现：</p>\n<ul>\n<li>把宿主机文件系统里的目录映射到容器内的目录，<code>如下图所示</code>。如此一来，容器内在该目录里创建的所有文件，都存储到宿主机的对应目录中，在关闭容器后，宿主机的目录依然存在，再次启动容器时还能读取到之前创建的文件，因此实现了容器的文件持久化。当然同时要明白，如果是对镜像自带文件进行了修改，由于镜像是只读的，该修改操作无法在关闭容器时保存下来，除非在修改了文件后构建一个新的镜像。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPcg.png\" alt=\"clipboard.png\"></p>\n<ul>\n<li>把多台宿主机的磁盘目录通过网络联合为共享存储，然后把共享存储中的特定目录映射给特定的容器，<code>如下图所示</code>。这样容器在重启时，还是能读取到关闭前创建的文件。生产环境中常用NFS作为共享存储方案。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPch.png\" alt=\"clipboard.png\"></p>\n<h5 id=\"9-Docker镜像制作方法\"><a href=\"#9-Docker镜像制作方法\" class=\"headerlink\" title=\"9. Docker镜像制作方法\"></a>9. Docker镜像制作方法</h5><p>　　镜像制作方法有两种：</p>\n<ul>\n<li><strong>通过正在运行的容器生成新镜像</strong></li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPci.png\" alt=\"clipboard.png\"></p>\n<p>　　当一个容器在运行时，在里面所有的修改都会体现在容器的可写层，Docker提供了commit命令，可以把正在运行的容器，叠加上可写层的修改内容，生成一个新镜像。如上图所示，在容器里新安装Spark组件的，如果关闭容器，Spark组件会随着可写层的消失而消失，如果在关闭容器之前使用commit命令生成新镜像，那么使用新镜像启动为容器时，容器里就会包含Spark组件。</p>\n<p>　　这种方式比较简单，但无法直观的设置环境变量、监听端口等内容，适合在简单使用的场景运用。</p>\n<ul>\n<li><strong>通过Dockerfile文件来生成新镜像</strong></li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbtPcj.png\" alt=\"clipboard.png\"></p>\n<p>　　Dockerfile是一个定义了镜像创建步骤的文件，Docker引擎通过build命令读取Dockerfile，按定义的步骤来一步步构造镜像。在研发和实施环境中，通过Dockerfile 创建容器是主流做法。下面是一个Dockerfile的例子：</p>\n<pre class=\"line-numbers language-docker\" data-language=\"docker\"><code class=\"language-docker\">FROM ubuntu&#x2F;14.04                                # 基础镜像\nMAINTAINER guest                                 # 制作者签名\nRUN apt-get install openssh-server -y            # 安装ssh服务\nRUN mkdir &#x2F;var&#x2F;run&#x2F;sshd                          # 创建目录\nRUN useradd -s &#x2F;bin&#x2F;bash -m -d &#x2F;home&#x2F;guest guest # 创建用户\nRUN echo ‘guest:123456’| chpasswd                # 修改用户密码\nENV RUNNABLE_USER_DIR &#x2F;home&#x2F;guest                # 设置环境变量\nEXPOSE 22                                        # 容器内默认开启的端口\nCMD [&quot;&#x2F;usr&#x2F;sbin&#x2F;sshd -D&quot;]                        # 启动容器时自动启动ssh服务</code></pre>\n\n<p>　　Docker引擎可以根据以上Dockerfile定义的步骤，构造出一个带有ssh服务的Ubuntu镜像。</p>\n<h5 id=\"10-Docker的使用场景\"><a href=\"#10-Docker的使用场景\" class=\"headerlink\" title=\"10. Docker的使用场景\"></a>10. Docker的使用场景</h5><p>　　Docker作为一种轻量级的虚拟化方案，应用场景十分丰富，下面收集了一些常见的场景：</p>\n<ul>\n<li><strong>作为轻量级虚拟机使用</strong><br>可以使用Ubuntu等系统镜像创建容器，当作虚拟机来使用，相比于传统虚拟机，启动速度更快，资源占用更少，单机可以启动大量的操作系统容器，方便进行各种测试；</li>\n<li><strong>作为云主机使用</strong><br>结合Kubernetes这样的容器管理系统，可以在大量服务器上动态分配和管理容器，在公司内部，甚至可以取代VMWare这样的虚拟机管理平台，使用Docker容器作为云主机使用；</li>\n<li><strong>应用服务打包</strong><br>在Web应用服务开发场景，可以把Java运行环境、Tomcat服务器打包为一个基础镜像，在修改了代码包后加入到基础镜像来构建一个新的镜像，能很方便的升级服务和控制版本；</li>\n<li><strong>容器云平台CaaS</strong><br>Docker的出现，使得很多云平台供应商开始提供容器云的服务，简称容器即服务CaaS，以下对比一下IaaS、PaaS和SaaS：<ul>\n<li><strong>IaaS（基础设施即服务）：</strong>提供虚拟机或者其他基础资源作为服务提供给用户。用户可以从供应商那里获得虚拟机或者存储等资源来装载相关的应用，同时这些基础设施的繁琐的管理工作将由IaaS供应商来处理。其主要的用户是企业的系统管理员和运维人员；</li>\n<li><strong>PaaS（平台即服务）：</strong>把开发平台作为服务提供给用户。用户可以在一个包括SDK，文档和测试环境等在内的开发平台上非常方便地编写应用，而且不论是在部署，或者在运行的时候，用户都无需为服务器、操作系统、网络和存储等资源的管理操心，这些繁琐的工作都由PaaS供应商负责处理。其主要的用户是企业开发人员。</li>\n<li><strong>SaaS（软件即服务）：</strong>将应用作为服务提供给客户。用户只要接上网络，并通过浏览器，就能直接使用在云端上运行的应用，而不需要顾虑类似安装等琐事，并且免去初期高昂的软硬件投入。SaaS主要面对的是普通的用户。</li>\n<li><strong>CaaS（容器即服务）：</strong>完成IaaS和PaaS两个层级的功能。相对于传统的IaaS和PaaS服务，CaaS对底层的支持比PaaS更灵活，而对上层应用的操控又比IaaS更容易。同时因为Docker是比VM更细粒度的虚拟化服务，所以能够对计算资源做到更高效的利用。CaaS可以部署在任何物理机，虚拟机或IaaS云之上。</li>\n</ul>\n</li>\n<li><strong>持续集成和持续部署</strong><br>互联网行业提倡敏捷开发，持续集成部署CI/CD便是最典型的开发模式。使用Docker容器云平台，就能实现从代码编写完成推送到Git/SVN后，自动触发后端CaaS平台将代码下载、编译并构建成测试Docker镜像，再替换测试环境容器服务，自动在Jenkins或者Hudson中运行单元/集成测试，测试通过后，马上就能自动将新版本镜像更新到线上，完成服务升级。整个过程全自动化，一气呵成，最大程度地简化了运维，而且保证线上、线下环境完全一致，而且线上服务版本与Git/SVN发布分支也实现统一。</li>\n<li><strong>解决微服务架构的实施难题</strong><br>基于Spring Cloud这样的微服务框架，能够实现微服务的管理，但微服务本身还是需要运行在操作系统上。一个采用微服务架构开发的应用中，微服务的个数往往很多，这就导致了一台服务器上往往需要启动多个微服务来提高资源的利用率，而微服务本身可能就只能兼容部分操作系统，这就导致了就算有大量的服务器资源（操作系统可能不一样），但由于微服务本身与操作系统可能相关，就不能做到让微服务在任意服务器上运行，这就带来了资源的浪费和运维的困难。利用Docker容器的环境隔离能力，让微服务运行在容器内，就能够解决以上所说的问题。</li>\n<li><strong>执行临时任务</strong><br>有时候用户只是想执行一次性的任务，但如果用传统虚拟机的方式就要搭建环境，执行完任务后还要释放资源，比较麻烦。使用Docker容器就可以构建临时的运行环境，执行完任务后关闭容器即可，方便快捷。</li>\n<li><strong>多租户环境</strong><br>利用Docker的环境隔离能力，可以为不同的租户提供独占的容器，实现简单而且成本较低。</li>\n</ul>\n<h5 id=\"11-总结\"><a href=\"#11-总结\" class=\"headerlink\" title=\"11. 总结\"></a>11. 总结</h5><p>　　Docker的技术并不神秘，只是整合了前人积累的各种成果实现的应用级的容器化技术，它利用各种Linux发行版中使用了版本兼容的内核容器化技术，来实现镜像一次构建到处运行的效果，并且利用了容器内的基础操作系统镜像层，屏蔽了实际运行环境的操作系统差异，使用户在开发应用程序时，只需确保在选定的操作系统和内核版本上能正确运行即可，几乎不需要关心实际的运行环境的系统差异，大大提高效率和兼容性。但随着容器运行得越来越多，容器管理将会称为另一个运维的难题，这时候就需要引入Kubernetes、Mesos或Swarm这些容器管理系统，后面有机会再介绍这些技术。</p>\n<h2 id=\"2-基础-1\"><a href=\"#2-基础-1\" class=\"headerlink\" title=\"2.基础\"></a>2.基础</h2><h3 id=\"1-初级\"><a href=\"#1-初级\" class=\"headerlink\" title=\"1.初级\"></a>1.初级</h3><h4 id=\"1-集群搭建\"><a href=\"#1-集群搭建\" class=\"headerlink\" title=\"1.集群搭建\"></a>1.集群搭建</h4><ol>\n<li><p>基本概念</p>\n<ul>\n<li><p>容器编排（Container Orchestration）：在容器之上的管理，主要有服务发现、负载均衡、状态监控、健康检查、扩容缩容、应用迁移、高可用等</p>\n</li>\n<li><p>Kubernetes：</p>\n<ul>\n<li><p>前身是Google内部用C++实现的Borg，支撑整个公司运转的集群应用管理系统，在切换到Omega的时候，将Borg用Go重写并开源，即Kubernetes</p>\n</li>\n<li><p>Kubernetes是一个生产级别的容器编排平台和集群管理系统，不仅能够创建、调度容器，还能够监控、管理服务器，提供了一个可弹性运行分布式系统的框架：</p>\n<ul>\n<li><p>服务发现和负载均衡：使用DNS或IP地址来暴漏容器，并提供负载均衡来分配流量</p>\n</li>\n<li><p>存储编排：允许自动挂载用户选择的存储系统，如本地存储、公共云提供商等</p>\n</li>\n<li><p>自动部署和回滚：可以使用 Kubernetes 描述已部署容器的所需状态， 它可以以受控的速率将实际状态更改为期望状态。 例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。</p>\n</li>\n<li><p>自动完成装箱计算：允许指定每个容器所需CPU和内存（RAM）</p>\n</li>\n<li><p>自我恢复：将重新启动失败的容器、替换容器、杀死不响应用户定义的运行状况检查的容器， 并且在准备好服务之前不将其通告给客户端</p>\n</li>\n<li><p>密钥与配置管理：可以存储和管理敏感信息</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Minikube：用于在单机快速搭建Kubernetes环境</p>\n</li>\n</ul>\n</li>\n<li><p>集群搭建：</p>\n<ul>\n<li><p>下载安装Minikube，用来管理k8s集群环境</p>\n</li>\n<li><p>下载安装kubectl，用来操作实际的k8s功能</p>\n</li>\n<li><p>启动验证minikube环境：</p>\n<ul>\n<li><code>minikube start --kubernetes-version=v1.23.3</code></li>\n<li>minikube自带的kubectl有限制，添加别名在.bashrc：<code>alias kubectl=&quot;minikube kubectl --&quot;</code></li>\n<li>运行Nginx示例：<code>kubectl run ngx --image=nginx:alpine</code></li>\n<li>查看pod：<code>kubectl get pod</code></li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221027110722321.png\" alt=\"image-20221027110722321\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-架构\"><a href=\"#2-架构\" class=\"headerlink\" title=\"2.架构\"></a>2.架构</h4><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221027111725613.png\" alt=\"image-20221027111725613\"></p>\n<ol>\n<li><p>基础概念</p>\n<ul>\n<li>外部有一个kubectl：k8s客户端工具，用来操作Kubernetes，位于集群之外，理论上不属于集群。可以使用<code>kubectl get node</code>来查看k8s的节点状态</li>\n<li>可以通过<code>kubectl get pod -n kube-system</code>来查看控制面组件的状态</li>\n<li>通过<code>minikube ssh</code>登录到节点后，通过<code>docker ps |grep kube-proxy</code>查看kube-proxy、通过<code>ps -ef|grep kubelet</code>来查看kubelet</li>\n</ul>\n</li>\n<li><p>控制平面组件（Control Plane Components）：为集群做出全局决策，可以在集群中的任何节点上运行，但为了简单起见通常在同一个未运行用户容器的计算机上启动所有控制平面组件</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/330e03a66f636657c0d8695397c508c6.webp\" alt=\"330e03a66f636657c0d8695397c508c6\"></p>\n<ul>\n<li><strong>kube-apiserver：</strong>API服务器是整个k8s系统的唯一入口，用于公开K8s的一系列RESTful API，并且加上了验证、授权等功能，负责处理接受请求的工作，是K8s控制平面的前端。K8s API服务器的主要实现是<code>kube-apiserver</code>，可以运行<code>kube-apiserver</code>的多个实例，并在这些实例之间平衡流量<ul>\n<li>K8s API可以让用户查询和操纵K8s API中对象的状态，例如Pod、Namespace、ConfigMap和Event。大部分操作都可以通过kubectl命令行接口或类似kubeadm这类命令行工具（背后也是调用API）来执行，也可以使用REST调用来访问这些API</li>\n</ul>\n</li>\n<li><strong>etcd：</strong>是兼顾一致性和高可用性的分布式键值数据库，用来持久化存储系统里的各种资源对象和状态，可以作为保存K8s所有集群数据的后台数据库。其只与apiserver有联系，所以任何其他组件想要读写 etcd 里的数据都必须经过 apiserver</li>\n<li><strong>kube-scheduler：</strong>负责监视新创建的、未指定运行节点（node）的Pods，并选择节点来让Pod在上面运行。（调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。）</li>\n<li><strong>kube-controller-manager：</strong>负责运行控制器进程，用于维护容器和节点等资源的状态，实现故障检测、服务迁移、应用伸缩等功能。每个控制器都是一个单独的进程，但是为了降低复杂性，都被编译到同一个可执行文件，并在同一个进程中运行。主要有以下控制器：<ul>\n<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>\n<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>\n<li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li>\n<li>服务帐户和令牌控制器（Service Account &amp; Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li>\n</ul>\n</li>\n<li><strong>cloud-controller-manager：</strong>允许将用户集群连接到云提供商的API之上，并将与该云平台交互的组件同用户的集群交互的组件分离开来。下面的控制器都包含堆云平台驱动的依赖：<ul>\n<li>节点控制器（Node Controller）：用于在节点终止响应后检查云提供商以确定节点是否已被删除</li>\n<li>路由控制器（Route Controller）：用于在底层云基础架构中设置路由</li>\n<li>服务控制器（Service Controller）：用于创建、更新和删除云提供商负载均衡器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Node组件：Node的数量非常多，构成一个资源池，Kubernetes就在这个池里分配资源、调度应用，通过池化资源来简化管理（只有kube-proxy被容器化了）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/87bab507ce8381325e85570f3bc1d935.webp\" alt=\"87bab507ce8381325e85570f3bc1d935\"></p>\n<ul>\n<li><strong>kubelet：</strong><ul>\n<li>在集群中每个节点（node）上运行，是Node的代理，负责管理Node相关的绝大部分操作，保证容器（containers）都运行在Pod中</li>\n<li>Node上只有它能够与apiserver通信，实现状态报告、命令下发、起停容器等功能</li>\n<li>kubelet 接收一组通过各类机制提供给它的 PodSpecs， 确保这些 PodSpecs 中描述的容器处于运行状态且健康。 kubelet 不会管理不是由 Kubernetes 创建的容器</li>\n</ul>\n</li>\n<li><strong>kube-proxy：</strong><ul>\n<li>是集群中每个节点（node）上运行的网络代理，实现K8s服务（Service）的一部分</li>\n<li>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信</li>\n<li>如果操作系统提供了可用的数据包过滤层，则 kube-proxy 会通过它来实现网络规则。 否则，kube-proxy 仅做流量转发</li>\n</ul>\n</li>\n<li><strong>Container Runtime：</strong>在Kubectl的指挥下创建容器，管理Pod的生命周期，如Docker</li>\n</ul>\n</li>\n<li><p>插件（Addons）</p>\n<ul>\n<li><strong>DNS：</strong>集群 DNS 是一个 DNS 服务器，和环境中的其他 DNS 服务器一起工作，它为 Kubernetes 服务提供 DNS 记录。Kubernetes 启动的容器自动将此 DNS 服务器包含在其 DNS 搜索列表中。</li>\n<li><strong>Web界面：</strong>使用户可以管理集群中运行的应用程序以及集群本身，并进行故障排除</li>\n<li><strong>容器资源监控：</strong>将关于容器的一些常见的时间序列度量值保存到一个集中的数据库中，并提供浏览这些数据的界面</li>\n<li><strong>集群层面日志：</strong>负责将容器的日志数据保存到一个集中的日志存储中，提供搜索和浏览接口</li>\n</ul>\n</li>\n<li><p>工作流程</p>\n<ul>\n<li>每个 Node 上的 kubelet 会定期向 apiserver 上报节点状态，apiserver 再存到 etcd 里</li>\n<li>每个 Node 上的 kube-proxy 实现了 TCP/UDP 反向代理，让容器对外提供稳定的服务</li>\n<li>scheduler 通过 apiserver 得到当前的节点状态，调度 Pod，然后 apiserver 下发命令给某个 Node 的 kubelet，kubelet 调用 container-runtime 启动容器</li>\n<li>controller-manager 也通过 apiserver 得到实时的节点状态，监控可能的异常情况，再使用相应的手段去调节恢复</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-YAML\"><a href=\"#3-YAML\" class=\"headerlink\" title=\"3.YAML\"></a>3.YAML</h4><ol>\n<li><p>声明式和命令式</p>\n<ul>\n<li>命令式：例如Docker命令和Dockerfile、大多数编程语言，特点是交互性强，注重顺序和过程</li>\n<li>声明式：不关心具体的过程，更注重结果，不需要教计算机做什么，而是告诉它一个目标状态，它自己就会想办法去完成任务，更加自动化、智能化程度更高</li>\n<li>区别：以打车为例，一路上给司机指路的就是命令式，只告诉司机目的地的是声明式</li>\n</ul>\n</li>\n<li><p>YAML</p>\n<ul>\n<li><p><a href=\"https://yaml.org/%E5%AE%98%E7%BD%91%E6%9C%89%E5%AF%B9%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E7%9A%84%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D%EF%BC%8CYAML%E5%BC%8FJSON%E7%9A%84%E8%B6%85%E9%9B%86%EF%BC%8C%E6%94%AF%E6%8C%81%E6%95%B4%E6%95%B0%E3%80%81%E6%B5%AE%E7%82%B9%E6%95%B0%E3%80%81%E5%B8%83%E5%B0%94%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%AD%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%BD%86%E6%98%AFYAML%E8%AF%AD%E6%B3%95%E6%9B%B4%E7%AE%80%E5%8D%95%EF%BC%8C%E5%BD%A2%E5%BC%8F%E6%9B%B4%E7%B4%A7%E5%87%91%EF%BC%8C%E4%BE%8B%E5%A6%82%EF%BC%9A\">https://yaml.org/官网有对语言规范的完整介绍，YAML式JSON的超集，支持整数、浮点数、布尔、字符串、数组和对象等数据类型，但是YAML语法更简单，形式更紧凑，例如：</a></p>\n<ul>\n<li><p>使用空白与缩进表示层次（有点类似 Python），可以不使用花括号和方括号</p>\n</li>\n<li><p>可以使用 # 书写注释，比起 JSON 是很大的改进</p>\n</li>\n<li><p>对象（字典）的格式与 JSON 基本相同，但 Key 不需要使用双引号</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># YAML对象(字典)\nKubernetes:\n  master: 1\n  worker: 3</code></pre></li>\n<li><p>数组（列表）是使用 - 开头的清单形式（有点类似 MarkDown）</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># YAML数组(列表)\nOS:\n  - linux\n  - macOS\n  - Windows</code></pre></li>\n<li><p>表示对象的 : 和表示数组的 - 后面都必须要有空格</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># 复杂的例子，组合数组和对象\nKubernetes:\n  master:\n    - apiserver: running\n    - etcd: running\n  node:\n    - kubelet: running\n    - kube-proxy: down\n    - container-runtime: [docker, containerd, cri-o]</code></pre></li>\n<li><p>可以使用 — 在一个文件里分隔多个 YAML 对象</p>\n</li>\n<li><p>其它：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/d4f3d4cc27a8a4a70d4898b41efebf04.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>如何编写YAML：</p>\n<ul>\n<li><p>所有API对象的字段都可以在官方文档中找到<a href=\"https://kubernetes.io/docs/reference/kubernetes-api/\">https://kubernetes.io/docs/reference/kubernetes-api/</a></p>\n</li>\n<li><p>技巧：</p>\n<ul>\n<li><p>命令<code>kubectl api-resources</code>会显示出资源对象相应的 API 版本和类型，比如 Pod 的版本是“v1”，Ingress 的版本是“networking.k8s.io/v1”，照着它写绝对不会错</p>\n</li>\n<li><p>命令<code>kubectl explain</code>相当于是Kubernetes自带的API文档，会给出对象字段的详细说明，这样就不必去网上查找了。比如想要看Pod里的字段该怎么写，就可以这样：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl explain pod\nkubectl explain pod.metadata\nkubectl explain pod.spec\nkubectl explain pod.spec.containers</code></pre></li>\n<li><p>文档样板：kubectl 的两个特殊参数 –dry-run=client 和 -o yaml，前者是空运行，后者是生成 YAML 格式，结合起来使用就会让 kubectl 不会有实际的创建动作，而只生成 YAML 文件</p>\n<ul>\n<li><p>例如，想要生成一个 Pod 的 YAML 样板示例，可以在 kubectl run 后面加上这两个参数：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl run ngx --image&#x3D;nginx:alpine --dry-run&#x3D;client -o yaml</code></pre></li>\n<li><p>就会生成一个绝对正确的 YAML 文件：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  creationTimestamp: null\n  labels:\n    run: ngx\n  name: ngx\nspec:\n  containers:\n  - image: nginx:alpine\n    name: ngx\n    resources: &#123;&#125;\n  dnsPolicy: ClusterFirst\n  restartPolicy: Always\nstatus: &#123;&#125;</code></pre></li>\n<li><p>然后通过查阅对象的说明文档，添加或删除字段来定制这个YAML</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>API对象</p>\n<ul>\n<li><p>API对象概念：</p>\n<ul>\n<li>k8s总结了Google多年的经验，在理论层面抽象出了很多概念，用来描述系统的管理运维工作，这些概念叫做API对象</li>\n<li>API对象源自apiserver，因为apiserver是kubernetes系统的唯一入口，外部用户和内部组件都必须和它通信，因为采用了HTTP协议的URL资源理念，API风格也用RESTful的GET/POST/DELETE等，所以，这些概念很自然地就被称为是“API 对象”了</li>\n<li>通过<code>kubectl api-resources</code>来看当前kubernetes版本支持的所有对象，在使用kubectl的时候，可以加上一个参数 –v=9，它会详细的命令执行过程，清楚地看到发出的HTTP请求</li>\n</ul>\n</li>\n<li><p>如何描述API对象</p>\n<ul>\n<li><p>header：被kubectl用于生成HTTP请求发给apiserver</p>\n<ul>\n<li><p>apiVersion：表示操作这种资源的API版本号</p>\n</li>\n<li><p>kind：表示资源对象的类型，比如Pod、Node、Job、Service</p>\n</li>\n<li><p>metadata：表示资源的一些元信息，也就是用来标记对象、方便k8s管理的一些信息</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: ngx-pod #给pod起名字\n  labels: #给pod贴一些标签\n    env: demo\n    owner: chrono</code></pre></li>\n</ul>\n</li>\n<li><p>body：与对象特定相关，每种对象有不同的规格定义，在YAML表现为sprc字段，表示对对象的期望状态（desired status）</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spec:\n  containers:\n  - image: nginx:alpine\n    name: ngx\n    ports:\n    - containerPort: 80</code></pre></li>\n</ul>\n</li>\n<li><p>创建/删除对象：</p>\n<ul>\n<li>k8s收到这份声明式的数据，再根据HTTP请求里POST/DELETE等方法，就会自动操作这个资源对象</li>\n<li>K8s对象是目标性记录，一旦创建对象，K8s系统将不断工作以确保对象存在</li>\n<li>通过创建对象，就是在告知K8s系统，集群工作负载状态看起来应该是什么样子的，这就是K8s集群所谓的期望状态（Desired State）</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f ngx-pod.yml\nkubectl delete -f ngx-pod.yml</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-Pod\"><a href=\"#4-Pod\" class=\"headerlink\" title=\"4.Pod\"></a>4.Pod</h4><ol>\n<li><p>Pod：</p>\n<ul>\n<li><p>为了解决这样多应用联合运行的问题，同时还要不破坏容器的隔离，就需要在容器外面再建立一个收纳仓，让多个容器既保持相对独立，又能够小范围共享网络、存储等资源，而且永远是“绑在一起”的状态</p>\n</li>\n<li><p>Pod是可以在K8s中创建和管理的最小的可部署的计算单元，Pod是一组（一个或多个）容器，这些容器共享存储、网络、怎样运行这些容器的声明。Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行</p>\n</li>\n<li><p>Pod 被设计成支持形成内聚服务单元的多个协作过程（形式为容器）。 Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。 容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身</p>\n</li>\n<li><p>以Pod为中心的k8s资源对象关系图，所有k8s资源都直接或间接地附在Pod之上，所有k8s功能都必须通过Pod来实现</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/b5a7003788cb6f2b1c5c4f6873a8b5cf.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n<li><p>如何使用YAML描述Pod</p>\n<ul>\n<li><p>因为 Pod 也是 API 对象，所以它也必然具有 apiVersion（v1）、kind（Pod）、metadata、spec 这四个基本组成部分</p>\n</li>\n<li><p>metadata里有name和labels这两个字段</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: busy-pod\n  labels:\n    owner: chrono\n    env: demo\n    region: north\n    tier: back</code></pre></li>\n<li><p>spec字段需要管理、维护Pod这个k8s基本调度单元，里面有多个字段，以containers为例</p>\n<ul>\n<li>算法</li>\n</ul>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spec:\n  containers:\n  - image: busybox:latest\n    name: busy\n    imagePullPolicy: IfNotPresent #拉取策略\n    env: #环境变量\n      - name: os \n        value: &quot;ubuntu&quot;\n      - name: debug\n        value: &quot;on&quot;\n    command:\n      - &#x2F;bin&#x2F;echo\n    args:\n      - &quot;$(os), $(debug)&quot;</code></pre></li>\n</ul>\n</li>\n<li><p>如何使用kubectl操作Pod</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f busy-pod.yml #创建pod\nkubectl delete -f busy-pod.yml #删除pod\nkubectl delete pod busy-pod #pod的name被指定为busy-pod\nkubectl logs busy-pod #查看默认后台运行的pod的标准输出信息\nkubectl get pod #可以查看pod列表和运行状态\nkubectl describe pod busy-pod #查看详细状态，用于调试排错</code></pre></li>\n</ol>\n<h4 id=\"5-Job-CronJob\"><a href=\"#5-Job-CronJob\" class=\"headerlink\" title=\"5.Job/CronJob\"></a>5.Job/CronJob</h4><ol>\n<li><p>概念</p>\n<ul>\n<li>面向对象的思想：因为k8s中的pod已经是一个相对完善的对象，专门负责管理容器，根据单一职责原则，就不会再为它扩充功能，而是要保持它的独立性。容器之外的功能就需要定义其它对象，然后根据组合优于继承原则，将pod作为它的一个成员组合进去</li>\n<li>Job和CronJob组合了Pod，实现了对离线业务的处理，并且满足面向对象原则：<ul>\n<li>离线业务：离线业务相对于在线业务（Nginx、MySQL、Redis），不服务与外部用户，只对内部用户有意义，比如日志分析、数据建模、视频转码等</li>\n<li>业务特性：离线业务的特点是必定会退出，不会无期限地运行下去，所以它的调度策略也就与“在线业务”存在很大的不同，需要考虑运行超时、状态检查、失败重试、获取计算结果等管理事项</li>\n<li>面向对象原则：离线业务的业务特性和容器管理没有必然的联系，所以如果用pod来实现就会违反单一职责原则，所以把这部分功能分到另一个对象上实现，并让这个对象去控制pod的运行</li>\n</ul>\n</li>\n<li>Job和CronJob的使用场景<ul>\n<li>“离线业务”也可以分为两种。一种是“临时任务”，跑完就完事了，下次有需求了说一声再重新安排；另一种是“定时任务”，可以按时按点周期运行，不需要过多干预</li>\n<li>对应到 Kubernetes 里，“临时任务”就是 API 对象 Job，“定时任务”就是 API 对象 CronJob，使用这两个对象你就能够在 Kubernetes 里调度管理任意的离线业务了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何使用YAML描述Job</p>\n<ul>\n<li><p>apiVersion是batch/v1，kind是Job，metadata里有name标记名字，可以用labels添加任意的标签</p>\n</li>\n<li><p>spec中的template字段：在Job对象里应用了组合模式，template字段定义了一个应用模版，里面嵌入了一个pod，这样Job就可以从这个模版来创建出pod</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221027204230223.png\" alt=\"image-20221027204230223\" style=\"zoom:50%;\" /></li>\n<li><p>而这个 Pod 因为受 Job 的管理控制，不直接和 apiserver 打交道，也就没必要重复 apiVersion 等“头字段”，只需要定义好关键的 spec，描述清楚容器相关的信息就可以了，可以说是一个“无头”的 Pod 对象</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: batch&#x2F;v1\nkind: Job\nmetadata:\n  name: echo-job\n\nspec:\n  template:\n    spec:\n      restartPolicy: OnFailure\n      containers:\n      - image: busybox\n        name: echo-job\n        imagePullPolicy: IfNotPresent\n        command: [&quot;&#x2F;bin&#x2F;echo&quot;]\n        args: [&quot;hello&quot;, &quot;world&quot;]</code></pre></li>\n<li><p>spec其他重要字段：用来控制模版里的pod对象，与template同级</p>\n<ul>\n<li>activeDeadlineSeconds，设置 Pod 运行的超时时间</li>\n<li>backoffLimit，设置 Pod 的失败重试次数</li>\n<li>completions，Job 完成需要运行多少个 Pod，默认是 1 个</li>\n<li>parallelism，它与 completions 相关，表示允许并发运行的 Pod 数量，避免过多占用资源。</li>\n</ul>\n</li>\n<li><p>使用YAML生成CronJob对象</p>\n<ul>\n<li><p>样板</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: batch&#x2F;v1\nkind: CronJob\nmetadata:\n  name: echo-cj\n\nspec:\n  schedule: &#39;*&#x2F;1 * * * *&#39; #用来定义任务周期运行的规则，使用标准的Cron语法\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          restartPolicy: OnFailure\n          containers:\n          - image: busybox\n            name: echo-cj\n            imagePullPolicy: IfNotPresent\n            command: [&quot;&#x2F;bin&#x2F;echo&quot;]\n            args: [&quot;hello&quot;, &quot;world&quot;]</code></pre></li>\n<li><p>嵌套层次</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221027205801496.png\" alt=\"image-20221027205801496\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>如何在k8s中操作Job</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl apply -f job.yml #运行简单的离线作业\nkubectl get job #查看job状态\nkubectl get pod #查看pod状态</code></pre></li>\n</ol>\n<h4 id=\"6-ConfigMap-Secret\"><a href=\"#6-ConfigMap-Secret\" class=\"headerlink\" title=\"6.ConfigMap/Secret\"></a>6.ConfigMap/Secret</h4><ol>\n<li><p>基础概念</p>\n<ul>\n<li>配置文件：把运行时需要的一些参数从代码中分离出来，让我们在实际运行的时候能更方便的调整优化</li>\n<li>配置信息分类<ul>\n<li>一类是明文配置，也就是不保密，可以任意查询修改，比如服务端口、运行参数、文件路径等等</li>\n<li>另一类则是机密配置，由于涉及敏感信息需要保密，不能随便查看，比如密码、密钥、证书等等</li>\n</ul>\n</li>\n<li>这两类配置信息本质上都是字符串，只是由于安全性的原因，在存放和使用方面有些差异，所以 Kubernetes 也就定义了两个 API 对象，ConfigMap 用来保存明文配置，Secret 用来保存秘密配置</li>\n</ul>\n</li>\n<li><p>ConfigMap</p>\n<ul>\n<li><p>样板文件：因为是存储配置文件，是静态的字符串而不是容器，就不需要spec字段来说明运行时的规格</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">#kubectl create cm info --from-literal&#x3D;k&#x3D;v --dry-run&#x3D;client -o yaml\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: info\n\ndata:\n  count: &#39;10&#39;\n  debug: &#39;on&#39;\n  path: &#39;&#x2F;etc&#x2F;systemd&#39;\n  greeting: |\n    say hello to kubernetes.</code></pre></li>\n</ul>\n</li>\n<li><p>Secret</p>\n<ul>\n<li><p>k8s里Secret对象又细分出跟多类，比如：</p>\n<ul>\n<li>访问私有镜像仓库的认证信息</li>\n<li>身份识别的凭证信息</li>\n<li>HTTPS 通信的证书和私钥</li>\n<li>一般的机密信息（格式由用户自行解释）</li>\n</ul>\n</li>\n<li><p>样板代码：<code>kubectl create secret generic user --from-literal=name=root --dry-run=client -o yaml</code></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: v1\nkind: Secret\nmetadata:\n  name: user\n\ndata: #通过Base64编码进行加密\n  name: cm9vdA&#x3D;&#x3D; # root \n  pwd: MTIzNDU2 # 123456 \n  db: bXlzcWw&#x3D; # mysql</code></pre></li>\n</ul>\n</li>\n<li><p>如何以环境变量的方式使用 ConfigMap/Secret</p>\n<ul>\n<li><p>Pod 与 ConfigMap、Secret 的“松耦合”关系，使用keyRef字段间接应用对象，同一段配置信息就可以在不同的对象之间共享</p>\n</li>\n<li><p>“valueFrom”字段指定了环境变量值的来源，可以是“configMapKeyRef”或者“secretKeyRef”，然后你要再进一步指定应用的 ConfigMap/Secret 的“name”和它里面的“key”，要当心的是这个“name”字段是 API 对象的名字，而不是 Key-Value 的名字</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221027215901948.png\" alt=\"image-20221027215901948\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>如何以 Volume 的方式使用 ConfigMap/Secret</p>\n<ul>\n<li><p>Kubernetes 为 Pod 定义了一个“Volume”的概念，可以翻译成是“存储卷”。如果把 Pod 理解成是一个虚拟机，那么 Volume 就相当于是虚拟机里的磁盘</p>\n</li>\n<li><p>可以为 Pod“挂载（mount）”多个 Volume，里面存放供 Pod 访问的数据，这种方式有点类似 docker run -v，虽然用法复杂了一些，但功能也相应强大一些</p>\n</li>\n<li><p>在 Pod 里挂载 Volume 很容易，只需要在“spec”里增加一个“volumes”字段，然后再定义卷的名字和引用的 ConfigMap/Secret 就可以了。要注意的是 Volume 属于 Pod，不属于容器，所以它和字段“containers”是同级的，都属于“spec”</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221027220957001.png\" alt=\"image-20221027220957001\" style=\"zoom:50%;\" /></li>\n<li><p>这种方式的好处在于：以 Volume 的概念统一抽象了所有的存储，不仅现在支持 ConfigMap/Secret，以后还能够支持临时卷、持久卷、动态卷、快照卷等许多形式的存储，扩展性非常好</p>\n</li>\n<li><p>环境变量用法简单，更适合存放简短的字符串，而 Volume 更适合存放大数据量的配置文件，在 Pod 里加载成文件后让应用直接读取使用</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-中级\"><a href=\"#2-中级\" class=\"headerlink\" title=\"2.中级\"></a>2.中级</h3><h4 id=\"1-Kubeadm\"><a href=\"#1-Kubeadm\" class=\"headerlink\" title=\"1.Kubeadm\"></a>1.Kubeadm</h4><ol>\n<li>定义：简化集群环境部署Kubernetes，并且让这个集群接近生产级质量</li>\n<li><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2></li>\n<li>安装kubeadm<ul>\n<li>安装</li>\n<li>部署master</li>\n<li>部署worker</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-Deployment\"><a href=\"#2-Deployment\" class=\"headerlink\" title=\"2.Deployment\"></a>2.Deployment</h4><ol>\n<li><p>基础</p>\n<ul>\n<li><p>用途：专门用来部署应用程序的，能够让应用永不宕机，多用来发布无状态的应用。与Job/CronJob类似，通过组合的方式管理Pod</p>\n</li>\n<li><p>Dockfile文件</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">#export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n#kubectl create deploy ngx-dep --image&#x3D;nginx:alpine $out\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  labels:\n    app: ngx-dep\n  name: ngx-dep\n  \nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: ngx-dep\n      \n  template:\n    metadata:\n      labels:\n        app: ngx-dep\n    spec:\n      containers:\n      - image: nginx:alpine\n        name: nginx</code></pre></li>\n</ul>\n</li>\n<li><p>关键字段</p>\n<ul>\n<li>replicas：（真正维护多副本的控制器为RepliaSet）<ul>\n<li>代表副本数量，也就是指定要在k8s集群中运行多少个Pod实例，初始化时为0，根据YAML文件里的Pod模版，逐个创建出要求数量的Pod</li>\n<li>接下来k8s持续监控Pod的运行状态，万一有 Pod 发生意外消失了，数量不满足“期望状态”，它就会通过 apiserver、scheduler 等核心组件去选择新的节点，创建出新的 Pod，直至数量与“期望状态”一致</li>\n</ul>\n</li>\n<li>selector：<ul>\n<li>作用是筛选出要被Deployment管理的Pod对象，下属字段“matchLabels”定义了 Pod 对象应该携带的 label，它必须和“template”里 Pod 定义的“labels”完全相同，否则校验不通过</li>\n<li>因为在线业务和离线业务的应用场景差异很大。离线业务中的Pod是一次性的，至于这个业务有关，但是在线业务中Pod会被其他API对象引用来管理，比如负责负载均衡的Service对象</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进阶</p>\n<ul>\n<li><p>如何描述Deployment和Pod的组合关系：通过在 API 对象的“metadata”元信息里加各种标签（labels），我们就可以使用类似关系数据库里查询语句的方式，筛选出具有特定标识的那些对象。通过标签这种设计，Kubernetes 就解除了 Deployment 和模板里 Pod 的强绑定，把组合关系变成了“弱引用”</p>\n</li>\n<li><p>操作</p>\n<ul>\n<li><p>如何使用kubectl操作Deployment</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl apply -f deploy.yml #创建对象\n$ kubectl get deploy #查看Deployment的状态\n#READY 表示运行的 Pod 数量，前面的数字是当前数量，后面的数字是期望数量，所以“2&#x2F;2”的意思就是要求有两个 Pod 运行，现在已经启动了两个 Pod\n#UP-TO-DATE 指的是当前已经更新到最新状态的 Pod 数量。因为如果要部署的 Pod 数量很多或者 Pod 启动比较慢，Deployment 完全生效需要一个过程，UP-TO-DATE 就表示现在有多少个 Pod 已经完成了部署，达成了模板里的“期望状态”\n#AVAILABLE 要比 READY、UP-TO-DATE 更进一步，不仅要求已经运行，还必须是健康状态，能够正常对外提供服务，它才是我们最关心的 Deployment 指标</code></pre></li>\n<li><p>通过<code>kubectl get pod</code>命令来看看 Pod 的状态，其中被Deploymentguan管理的Pod自动带上了名字，命名规则是Deployment的名字+Pod模版的Hash值</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221101170226997.png\" alt=\"image-20221101170226997\"></p>\n</li>\n</ul>\n</li>\n<li><p>特性：</p>\n<ul>\n<li>永不宕机：通过<code>kubedctl delete pod &lt;podName&gt;</code>删除一个Pod之后，该Pod消失后，Deployment会又创建出一个新的Pod</li>\n<li>弹性伸缩：例如<code>kubectl scale --replicas=5 deploy ngx-dep</code>可以把Nginx应用扩容到5个，但这是临时的措施，如果想要长时间保持另一个Pod数量，需要改动YAML文件，重新创建对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-Daemonset\"><a href=\"#3-Daemonset\" class=\"headerlink\" title=\"3.Daemonset\"></a>3.Daemonset</h4><ol>\n<li><p>基础</p>\n<ul>\n<li>What：DaemonSet会在k8s集群的每个节点上都运行一个Pod，好像Linux系统里的守护进程（Daemon）</li>\n<li>Why：<ul>\n<li>因为Deployment不关心Pod会在集群的哪些节点上运行，只关心Pod的个数，这对大多数业务都没问题，比如Nginx、MySQL，他们不需要知道集群、节点的细节信息，在那个节点运行都一样</li>\n<li>但是有一些业务不完全独立于系统运行，而是与主机存在绑定关系，必须依附于节点才能产生价值，如下，所以需要DaemonSet来为每个节点守护一个Pod<ul>\n<li>网络应用（如 kube-proxy）：必须每个节点运行一个 Pod，否则节点就无法加入Kubernetes网络</li>\n<li>监控应用（如 Prometheus），必须每个节点都有一个 Pod 用来监控节点的状态，实时上报信息</li>\n<li>日志应用（如 Fluentd），必须每个节点上运行一个 Pod，才能够搜集容器运行时产生的日志数据</li>\n<li>安全应用，同样的，每个节点都要有一个 Pod 来执行安全审计、入侵检查、漏洞扫描等工作。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实践</p>\n<ul>\n<li><p>YAML文件：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">#k8s不提供自动创建DaemonSet YAML样板的功能，当根据官网示例有如下样板文件\n#方法二：用kubectl create先创建出一个Deployment对象，然后把kind改成DaemonSet，再删除 spec.replicas\n\t\t\t\t# export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n\t\t\t\t# change &quot;kind&quot; to DaemonSetkubectl create deploy redis-ds --image&#x3D;redis:5-alpine $out\napiVersion: apps&#x2F;v1\nkind: DaemonSet\nmetadata:\n  name: redis-ds\n  labels:\n    app: redis-ds\n\nspec:\n  selector:\n    matchLabels:\n      name: redis-ds\n\n  template:\n    metadata:\n      labels:\n        name: redis-ds\n    spec:\n      containers:\n      - image: redis:5-alpine\n        name: redis\n        ports:\n        - containerPort: 6379</code></pre></li>\n<li><p>没有replicas字段：与Deployment不同，DaemonSet不会在集群里创建多个Pod副本，而是要在每个节点只创建一个Pod实例。也就是说，DaemonSet 仅仅是在 Pod 的部署调度策略上和 Deployment 不同，其他的都是相同的，可以把 DaemonSet 看做是 Deployment 的一个特例</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221101172935228.png\" alt=\"image-20221101172935228\"></p>\n</li>\n<li><p>使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl apply -f ds.yml #创建对象\n$ kubectl get ds #查看状态 \n$ kubecrl get pod -o wide #查看pod\n#master被排除了，只在每一个worker节点运行了一个Pod实例</code></pre></li>\n</ul>\n</li>\n<li><p>进阶</p>\n<ul>\n<li><p>污点（taint）：用于给节点贴标签，为了区分labels字段，改成了taint</p>\n</li>\n<li><p>容忍度（toleration）：Pod能够容忍污点，不是DaemonSet独有的概念，而是从属于Pod，所以也可用在Job/CronJob、Deployment</p>\n</li>\n<li><p>污点和容忍度是一个相对的过程，Pod会根据自己对污点和容忍度来选择合适的目标，k8s会在创建集群的时候自动给节点Node加上一些污点，方便Pod的调度和部署，可以用<code>kubectl describe node</code>来查看：</p>\n<ul>\n<li>Master 节点默认有一个 taint，名字是 node-role.kubernetes.io/master，它的效果是 NoSchedule，也就是说这个污点会拒绝 Pod 调度到本节点上运行，而 Worker 节点的 taint 字段则是空的</li>\n<li>这正是 Master 和 Worker 在 Pod 调度策略上的区别所在，通常来说 Pod 都不能容忍任何“污点”，所以加上了 taint 属性的 Master 节点也就会无缘 Pod 了</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl describe node master\n\nName:     master\nRoles:    control-plane,master\n...\nTaints:   node-role.kubernetes.io&#x2F;master:NoSchedule\n...\n\n$ kubectl describe node worker\n\nName:     worker\nRoles:    &lt;none&gt;\n...\nTaints:   &lt;none&gt;\n...</code></pre></li>\n<li><p>如何让 DaemonSet 在 Master 节点上运行：</p>\n<ul>\n<li><p>第一种方法是去掉 Master 节点上的 taint，让 Master 变得和 Worker 一样“纯洁无瑕”，DaemonSet 自然就不需要再区分 Master/Worker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl taint node master node-role.kubernetes.io&#x2F;master:NoSchedule-</code></pre></li>\n<li><p>第二种方法：为 Pod 添加字段 tolerations，让它能够容忍某些污点，就可以在任意的节点上运行了</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">tolerations:\n- key: node-role.kubernetes.io&#x2F;master\n  effect: NoSchedule\n  operator: Exists</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-Service\"><a href=\"#4-Service\" class=\"headerlink\" title=\"4.Service\"></a>4.Service</h4><ol>\n<li><p>基础</p>\n<ul>\n<li>What：Service是集群内部的负载均衡机制，用来解决服务发现的问题，与Pod一样属于k8s的核心对象</li>\n<li>Why：<ul>\n<li>因为k8s集群里的Pod的生命周期是短暂的，在运行过程中会多次发生Pod的销毁和重建，这种动态稳定是的后台微服务Pod的IP地址总变，这样客户端就无法访问了</li>\n<li>已有的方法是LVS、Nginx等，通过一个前端与后端之间的中间层，来屏蔽后端的变化，为前端提供一个稳定的服务</li>\n<li>但 LVS、Nginx 毕竟不是云原生技术，所以 Kubernetes 就按照这个思路，定义了新的 API 对象：Service。Kubernetes 会给它分配一个静态 IP 地址，然后它再去自动管理、维护后面动态变化的 Pod 集合，当客户端访问 Service，它就根据某种策略，把流量转发给后面的某个 Pod</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>实践</p>\n<ul>\n<li><p>YAML</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n# kubectl expose deploy ngx-dep --port&#x3D;80 --target-port&#x3D;80 $out\n# 使用 kubectl expose 指令时还需要用参数--port和--target-port分别指定映射端口和容器端口# 而 Service 自己的 IP 地址和后端 Pod 的 IP 地址可以自动生成\napiVersion: v1\nkind: Service\nmetadata:\n  name: ngx-svc\n  \nspec:\n  selector:\n    app: ngx-dep\n    \n  ports:\n  - port: 80 #外部端口\n    targetPort: 80 #内部端口\n    protocol: TCP #使用的协议</code></pre></li>\n<li><p>Kubernetes 为 Service 对象自动分配了一个 IP 地址“10.96.240.115”，这个地址段是独立于 Pod 地址段的。而且 Service 对象的 IP 地址还有一个特点，它是一个“虚地址”，不存在实体，只能用来转发流量</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">kubectl describe svc ngx-svc #查看Service代理了那些后端的Pod</code></pre></li>\n<li><p>负载均衡</p>\n<ul>\n<li><p>测试负载均衡</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#进入到集群的内部网段\n$ kubectl exec -it ngx-dep-6796688696-r2j6t -- sh\n#再用curl工具来访问service，如curl 10.96.240.115</code></pre></li>\n<li><p>针对删除重建的节点，Service会通过controller-manager实时监控Pod的变化情况，并立即更新它代理的IP地址</p>\n</li>\n<li><p>service的ip地址是虚拟的，只用于转发流量，不能ping通</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>进阶</p>\n<ul>\n<li><p>Service工作原理：Service 使用了 iptables 技术，每个节点上的 kube-proxy 组件自动维护 iptables 规则，客户不再关心 Pod 的具体地址，只要访问 Service 的固定 IP 地址，Service 就会根据 iptables 规则转发请求给它管理的多个 Pod，是典型的负载均衡架构</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221101200728535.png\" alt=\"image-20221101200728535\" style=\"zoom:50%;\" /></li>\n<li><p>service和它引用的Pod的关系</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221101201523654.png\" alt=\"image-20221101201523654\" style=\"zoom:50%;\" /></li>\n<li><p>以域名的方式使用</p>\n<ul>\n<li><p>命名空间（namespace）：用来在集群里实现对API对象的隔离和分组，使用<code>kubectl get ns</code>查看</p>\n<ul>\n<li>Kubernetes 有一个默认的名字空间，叫“default”，如果不显式指定，API 对象都会在这个“default”名字空间里。而其他的名字空间都有各自的用途，比如“kube-system”就包含了 apiserver、etcd 等核心组件的 Pod</li>\n<li>因为 DNS 是一种层次结构，为了避免太多的域名导致冲突，Kubernetes 就把名字空间作为域名的一部分，减少了重名的可能性，Service 对象的域名完全形式是“对象. 名字空间.svc.cluster.local”，但很多时候也可以省略后面的部分，直接写“对象. 名字空间”甚至“对象名”就足够了，默认会使用对象所在的名字空间（比如这里就是 default）</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221101203947401.png\" alt=\"image-20221101203947401\"></p>\n</li>\n</ul>\n</li>\n<li><p>如何让Service对外暴露服务</p>\n<ul>\n<li><p>type关键字：表示 Service 是哪种类型的负载均衡，默认是ClusterIP，即对集群内部Pod的负载均衡。除了“ClusterIP”，Service 还支持其他三种类型，分别是“ExternalName”“LoadBalancer”“NodePort”，“ExternalName”“LoadBalancer”一般由云服务商提供</p>\n</li>\n<li><p>NodePort类型</p>\n<ul>\n<li>使用：在使用命令 kubectl expose 的时候加上参数 –type=NodePort，或者在 YAML 里添加字段 type:NodePort</li>\n<li>Service除了会对后端的 Pod 做负载均衡之外，还会在集群里的每个节点上创建一个独立的端口，用这个端口对外提供服务，这也正是“NodePort”这个名字的由来</li>\n<li>这个端口号属于节点，外部能够直接访问，可以不用登陆集群节点或者进入Pod内部，直接在集群外使用任意一个节点的 IP 地址，就能够访问 Service 和它代理的后端服务了</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221101204816868.png\" alt=\"image-20221101204816868\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"5-Ingress\"><a href=\"#5-Ingress\" class=\"headerlink\" title=\"5.Ingress\"></a>5.Ingress</h4><ol>\n<li><p>基础</p>\n<ul>\n<li><p>在service的基础上提出了Ingress的概念，用于流量的管理，与它关联的还有Ingress Controller、Ingress Class等对象</p>\n</li>\n<li><p>service是一个由kube-proxy控制的四层负载均衡，即在TCP/IP协议栈上转发流量；而Ingress是在七层的HTTP/HTTPS协议上来做负载均衡，并且还作为流量的总入口，统管集群的进出口数据，即扇入扇出流量</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221102193817435.png\" alt=\"image-20221102193817435\" style=\"zoom:50%;\" /></li>\n<li><p>Ingress Controller：与Service和kube-proxy类似，Ingress也只是一些HTTP路有规则的集合，需要Ingress Controller来读取、应用Ingress规则、处理调度流量。常见的Ingress Controller有k8s Ingress Controller、Nginx Ingress Controller、Kong Ingress Controller等</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221102194344762.png\" alt=\"image-20221102194344762\" style=\"zoom:50%;\" /></li>\n<li><p>IngressClass：由于项目内不同的Ingress Controller、过多的Ingress规则、多个Ingress没有逻辑分组方式等问题k8s提出了Ingress Class的概念，他在Ingress和Ingress Controller的中间作为流量规则和控制器的协调人</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221102194713862.png\" alt=\"image-20221102194713862\" style=\"zoom: 50%;\" /></li>\n</ul>\n</li>\n<li><p>实践</p>\n<ul>\n<li><p>YAML（Ingress）</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># 创建样板文件\n# export out&#x3D;&quot;--dry-run&#x3D;client -o yaml&quot;\n# kubectl create ing ngx-ing --rule&#x3D;&quot;ngx.test&#x2F;&#x3D;ngx-svc:80&quot; --class&#x3D;ngx-ink $out\n# --class指定Ingress从属的Ingress Class对象，--rule指定路由规则，也就是说是访问 HTTP 路径就转发到对应的 Service 对象，再由 Service 对象转发给后端的 Pod\n\napiVersion: networking.k8s.io&#x2F;v1\nkind: Ingress\nmetadata:\n  name: ngx-ing\n  \nspec:\n\n  ingressClassName: ngx-ink\n  \n  rules:\n  - host: ngx.test\n    http:\n      paths:\n      - path: &#x2F;\n        pathType: Exact\n        backend:\n          service:\n            name: ngx-svc\n            port:\n              number: 80</code></pre></li>\n<li><p>YAML（Ingress Class）</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">apiVersion: networking.k8s.io&#x2F;v1\nkind: IngressClass\nmetadata:\n  name: ngx-ink\n\nspec:\n  controller: nginx.org&#x2F;ingress-controller</code></pre></li>\n<li><p>使用</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl apply -f ingress.yml #两个yaml写到一起，创建这两个对象\n$ kubectl get ingressclass #查看对象状态\n$ kubectl get ing #查看对象状态\n$ kubectl describe ing ngx-ing #查看更详细的Ingress信息</code></pre></li>\n<li><p>在k8s中使用Ingress Controller</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#以Nginx Ingress Controller为例，下面4个YAML是用来做试验安装Nginx Ingress Controller的\n$ kubectl apply -f common&#x2F;ns-and-sa.yaml\n$ kubectl apply -f rbac&#x2F;rbac.yaml\n$ kubectl apply -f common&#x2F;nginx-config.yaml\n$ kubectl apply -f common&#x2F;default-server-secret.yaml</code></pre>\n\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"># 部署Ingress Controller的Deployment\napiVersion: apps&#x2F;v1\nkind: Deployment\nmetadata:\n  name: ngx-kic-dep\n  namespace: nginx-ingress\n\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: ngx-kic-dep\n\n  template:\n    metadata:\n      labels:\n        app: ngx-kic-dep\n    ...\n    spec:\n      containers:\n      - image: nginx&#x2F;nginx-ingress:2.2-alpine\n        ...\n        args:\n          - -ingress-class&#x3D;ngx-ink</code></pre>\n\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl apply -f kic.yml\n# Ingress Controller位于名字空间“nginx-ingress”，所以查看状态需要用“-n”参数显式指定\n$ kubectl get deploy -n nginx-ingress\n$ kubectl get pod -n nginx-ingress\n# 因为 Ingress Controller 本身也是一个 Pod，想要向外提供服务还是要依赖于 Service 对象。所以你至少还要再为它定义一个 Service，使用 NodePort 或者 LoadBalancer 暴露端口，才能真正把集群的内外流量打通\n$ \n# 下面这条命令就把本地的 8080 端口映射到了 Ingress Controller Pod 的 80 端口\n$ kubectl port-forward -n nginx-ingress ngx-kic-dep-8859b7b86-cplgp 8080:80 &amp;</code></pre></li>\n</ul>\n</li>\n<li><p>进阶</p>\n<ul>\n<li><p>关系图</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bb7a911e10c103fb839e01438e184914.jpg\" alt=\"img\"></p>\n</li>\n<li></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-高级\"><a href=\"#3-高级\" class=\"headerlink\" title=\"3.高级\"></a>3.高级</h3><h4 id=\"1-PersistentVolume\"><a href=\"#1-PersistentVolume\" class=\"headerlink\" title=\"1.PersistentVolume\"></a>1.PersistentVolume</h4><h4 id=\"2-persistentVolume-NFS\"><a href=\"#2-persistentVolume-NFS\" class=\"headerlink\" title=\"2.persistentVolume+NFS\"></a>2.persistentVolume+NFS</h4><h4 id=\"3-StatefulSet\"><a href=\"#3-StatefulSet\" class=\"headerlink\" title=\"3.StatefulSet\"></a>3.StatefulSet</h4><h4 id=\"4-滚动更新\"><a href=\"#4-滚动更新\" class=\"headerlink\" title=\"4.滚动更新\"></a>4.滚动更新</h4><h4 id=\"5-应用保障\"><a href=\"#5-应用保障\" class=\"headerlink\" title=\"5.应用保障\"></a>5.应用保障</h4><h4 id=\"6-集群管理\"><a href=\"#6-集群管理\" class=\"headerlink\" title=\"6.集群管理\"></a>6.集群管理</h4><h4 id=\"7-系统监控\"><a href=\"#7-系统监控\" class=\"headerlink\" title=\"7.系统监控\"></a>7.系统监控</h4><h4 id=\"8-网络通信\"><a href=\"#8-网络通信\" class=\"headerlink\" title=\"8.网络通信\"></a>8.网络通信</h4><h2 id=\"3-进阶-1\"><a href=\"#3-进阶-1\" class=\"headerlink\" title=\"3.进阶\"></a>3.进阶</h2><h3 id=\"1-容器编排与作业管理\"><a href=\"#1-容器编排与作业管理\" class=\"headerlink\" title=\"1.容器编排与作业管理\"></a>1.容器编排与作业管理</h3><h3 id=\"2-持久化存储\"><a href=\"#2-持久化存储\" class=\"headerlink\" title=\"2.持久化存储\"></a>2.持久化存储</h3><h3 id=\"3-容器网络\"><a href=\"#3-容器网络\" class=\"headerlink\" title=\"3.容器网络\"></a>3.容器网络</h3><h3 id=\"4-作业调度与资源管理\"><a href=\"#4-作业调度与资源管理\" class=\"headerlink\" title=\"4.作业调度与资源管理\"></a>4.作业调度与资源管理</h3><h3 id=\"5-容器运行时\"><a href=\"#5-容器运行时\" class=\"headerlink\" title=\"5.容器运行时\"></a>5.容器运行时</h3><h3 id=\"6-容器监控与日志\"><a href=\"#6-容器监控与日志\" class=\"headerlink\" title=\"6.容器监控与日志\"></a>6.容器监控与日志</h3><h1 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h1><h2 id=\"1-概念-1\"><a href=\"#1-概念-1\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h2><h3 id=\"1-Indexes\"><a href=\"#1-Indexes\" class=\"headerlink\" title=\"1.Indexes\"></a>1.Indexes</h3><h4 id=\"MySQL-索引\"><a href=\"#MySQL-索引\" class=\"headerlink\" title=\"MySQL 索引\"></a>MySQL 索引</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p></blockquote>\n<ol>\n<li><p>B+Tree 索引：</p>\n<ol>\n<li><p>是大多数 MySQL 存储引擎的默认索引类型，因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。可以指定多个列作为索引列，多个索引列共同组成键。适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>\n</li>\n<li><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。</p>\n<ol>\n<li>主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</li>\n</ol>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220522112559973-16546925905091.png\" alt=\"image-20220522112559973\" style=\"zoom:50%;\" />\n\n<ol>\n<li>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</li>\n</ol>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220522112625508-16546925905105.png\" alt=\"image-20220522112625508\" style=\"zoom:50%;\" /></li>\n</ol>\n</li>\n<li><p>哈希索引</p>\n<ol>\n<li><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>\n<ul>\n<li><p>无法用于排序与分组；</p>\n</li>\n<li><p>只支持精确查找，无法用于部分查找和范围查找。</p>\n</li>\n</ul>\n</li>\n<li><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>\n</li>\n</ol>\n</li>\n<li><p>全文索引</p>\n<ol>\n<li>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。（InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引）</li>\n</ol>\n</li>\n<li><p>空间数据索引：MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。必须使用 GIS 相关的函数来维护数据。</p>\n</li>\n</ol>\n<h4 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h4><ol>\n<li><p>独立的列：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。例如下面的查询不能使用 actor_id 列的索引：<code>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</code></p>\n</li>\n<li><p>多列索引：在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT film_id, actor_ id FROM sakila.film_actor\nWHERE actor_id &#x3D; 1 AND film_id &#x3D; 1;</code></pre></li>\n<li><p>索引列的顺序：让选择性最强的索引列放在前面。索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT COUNT(DISTINCT staff_id)&#x2F;COUNT(*) AS staff_id_selectivity,\nCOUNT(DISTINCT customer_id)&#x2F;COUNT(*) AS customer_id_selectivity,\nCOUNT(*)\nFROM payment;\n   staff_id_selectivity: 0.0001\ncustomer_id_selectivity: 0.0373\n               COUNT(*): 16049</code></pre></li>\n<li><p>前缀索引：对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。前缀长度的选取需要根据索引选择性来确定。</p>\n</li>\n<li><p>覆盖索引：索引包含所有需要查询的字段的值。具有以下优点：</p>\n<ul>\n<li><p>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</p>\n</li>\n<li><p>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</p>\n</li>\n<li><p>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"索引的优点\"><a href=\"#索引的优点\" class=\"headerlink\" title=\"索引的优点\"></a>索引的优点</h4><ul>\n<li>大大减少了服务器需要扫描的数据行数。</li>\n<li>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</li>\n<li>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</li>\n</ul>\n<h4 id=\"索引的使用条件\"><a href=\"#索引的使用条件\" class=\"headerlink\" title=\"索引的使用条件\"></a>索引的使用条件</h4><ul>\n<li>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</li>\n<li>对于中到大型的表，索引就非常有效；</li>\n<li>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</li>\n</ul>\n<h3 id=\"2-查询性能优化\"><a href=\"#2-查询性能优化\" class=\"headerlink\" title=\"2.查询性能优化\"></a>2.查询性能优化</h3><h4 id=\"使用-Explain-进行分析\"><a href=\"#使用-Explain-进行分析\" class=\"headerlink\" title=\"使用 Explain 进行分析\"></a>使用 Explain 进行分析</h4><ol>\n<li><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。比较重要的字段有：</p>\n<ul>\n<li><p>select_type : 查询类型，有简单查询、联合查询、子查询等</p>\n</li>\n<li><p>key : 使用的索引</p>\n</li>\n<li><p>rows : 扫描的行数</p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"优化数据访问\"><a href=\"#优化数据访问\" class=\"headerlink\" title=\"优化数据访问\"></a>优化数据访问</h4><ol>\n<li><p>减少请求的数据量</p>\n<ul>\n<li><p>只返回必要的列：最好不要使用 SELECT * 语句。</p>\n</li>\n<li><p>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</p>\n</li>\n<li><p>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</p>\n</li>\n</ul>\n</li>\n<li><p>减少服务器端扫描的行数：最有效的方式是使用索引来覆盖查询。</p>\n</li>\n</ol>\n<h4 id=\"重构查询方式\"><a href=\"#重构查询方式\" class=\"headerlink\" title=\"重构查询方式\"></a>重构查询方式</h4><ol>\n<li><p>切分大查询：一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH);\nrows_affected &#x3D; 0\ndo &#123;\n    rows_affected &#x3D; do_query(\n    &quot;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)\n&#125; while rows_affected &gt; 0</code></pre></li>\n<li><p>分解大连接查询：将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>\n<ul>\n<li><p>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</p>\n</li>\n<li><p>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</p>\n</li>\n<li><p>减少锁竞争；</p>\n</li>\n<li><p>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</p>\n</li>\n<li><p>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT * FROM tag\nJOIN tag_post ON tag_post.tag_id&#x3D;tag.id\nJOIN post ON tag_post.post_id&#x3D;post.id\nWHERE tag.tag&#x3D;&#39;mysql&#39;;\nSELECT * FROM tag WHERE tag&#x3D;&#39;mysql&#39;;\nSELECT * FROM tag_post WHERE tag_id&#x3D;1234;\nSELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</code></pre></li>\n</ol>\n<h3 id=\"3-存储引擎\"><a href=\"#3-存储引擎\" class=\"headerlink\" title=\"3.存储引擎\"></a>3.存储引擎</h3><h4 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h4><ol>\n<li>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</li>\n<li>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</li>\n<li>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</li>\n<li>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</li>\n<li>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</li>\n</ol>\n<h4 id=\"MyISAM\"><a href=\"#MyISAM\" class=\"headerlink\" title=\"MyISAM\"></a>MyISAM</h4><ol>\n<li>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</li>\n<li>提供了大量的特性，包括压缩表、空间数据索引等。</li>\n<li>不支持事务。</li>\n<li>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</li>\n<li>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</li>\n<li>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</li>\n</ol>\n<h4 id=\"比较\"><a href=\"#比较\" class=\"headerlink\" title=\"比较\"></a>比较</h4><ol>\n<li>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</li>\n<li>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</li>\n<li>外键：InnoDB 支持外键。备份：InnoDB 支持在线热备份。</li>\n<li>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</li>\n<li>其它特性：MyISAM 支持压缩表和空间数据索引。</li>\n</ol>\n<h3 id=\"4-数据类型\"><a href=\"#4-数据类型\" class=\"headerlink\" title=\"4.数据类型\"></a>4.数据类型</h3><h4 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h4><ol>\n<li>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</li>\n<li>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</li>\n</ol>\n<h4 id=\"浮点数\"><a href=\"#浮点数\" class=\"headerlink\" title=\"浮点数\"></a>浮点数</h4><ol>\n<li>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</li>\n<li>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</li>\n</ol>\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><ol>\n<li>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</li>\n<li>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</li>\n<li>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</li>\n</ol>\n<h4 id=\"时间和日期\"><a href=\"#时间和日期\" class=\"headerlink\" title=\"时间和日期\"></a>时间和日期</h4><ol>\n<li>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。<ol>\n<li>DATETIME：能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。它与时区无关。默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</li>\n<li>TIMESTAMP：和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</li>\n<li>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-Sharding\"><a href=\"#5-Sharding\" class=\"headerlink\" title=\"5.Sharding\"></a>5.Sharding</h3><h4 id=\"水平切分\"><a href=\"#水平切分\" class=\"headerlink\" title=\"水平切分\"></a>水平切分</h4><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220522114008460-16546925905103.png\" alt=\"image-20220522114008460\" style=\"zoom:50%;\" />\n\n<ol>\n<li>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</li>\n</ol>\n<h4 id=\"垂直切分\"><a href=\"#垂直切分\" class=\"headerlink\" title=\"垂直切分\"></a>垂直切分</h4><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220522114042976-16546925905092.png\" alt=\"image-20220522114042976\" style=\"zoom:50%;\" />\n\n<ol>\n<li>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</li>\n<li>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</li>\n</ol>\n<h4 id=\"Sharding-策略\"><a href=\"#Sharding-策略\" class=\"headerlink\" title=\"Sharding 策略\"></a>Sharding 策略</h4><ul>\n<li>哈希取模：hash(key) % N；</li>\n<li>范围：可以是 ID 范围也可以是时间范围；</li>\n<li>映射表：使用单独的一个数据库来存储映射关系。</li>\n</ul>\n<h4 id=\"Sharding-存在的问题\"><a href=\"#Sharding-存在的问题\" class=\"headerlink\" title=\"Sharding 存在的问题\"></a>Sharding 存在的问题</h4><ol>\n<li><p>事务问题：使用分布式事务来解决，比如 XA 接口。</p>\n</li>\n<li><p>连接：可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p>\n</li>\n<li><p>ID 唯一性</p>\n<ul>\n<li><p>使用全局唯一 ID（GUID）</p>\n</li>\n<li><p>为每个分片指定一个 ID 范围</p>\n</li>\n<li><p>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-Replication\"><a href=\"#6-Replication\" class=\"headerlink\" title=\"6.Replication\"></a>6.Replication</h3><h4 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h4><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>\n<ul>\n<li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>\n<li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>\n<li><strong>SQL 线程</strong> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220522114228936-16546925905104.png\" alt=\"image-20220522114228936\" style=\"zoom:50%;\" />\n\n\n\n<h4 id=\"读写分离\"><a href=\"#读写分离\" class=\"headerlink\" title=\"读写分离\"></a>读写分离</h4><ol>\n<li><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>\n</li>\n<li><p>读写分离能提高性能的原因在于：</p>\n<ul>\n<li><p>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</p>\n</li>\n<li><p>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</p>\n</li>\n<li><p>增加冗余，提高可用性。</p>\n</li>\n</ul>\n</li>\n<li><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>\n</li>\n</ol>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220522114208662-16546925905106.png\" alt=\"image-20220522114208662\" style=\"zoom:50%;\" />\n\n<h3 id=\"7-Transactions\"><a href=\"#7-Transactions\" class=\"headerlink\" title=\"7.Transactions\"></a>7.Transactions</h3><ol>\n<li>ACID</li>\n<li></li>\n</ol>\n<h3 id=\"8-database-normalization\"><a href=\"#8-database-normalization\" class=\"headerlink\" title=\"8.database normalization\"></a>8.database normalization</h3><ol>\n<li>1NF</li>\n<li>2NF</li>\n<li>3NF</li>\n<li>BCNF</li>\n<li>其他<ol>\n<li>第四范式、第五范式、第六范式</li>\n<li>Dk范式</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-SQL语法\"><a href=\"#2-SQL语法\" class=\"headerlink\" title=\"2.SQL语法\"></a>2.SQL语法</h2><h3 id=\"1-基础\"><a href=\"#1-基础\" class=\"headerlink\" title=\"1.基础\"></a>1.基础</h3><ol>\n<li>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</li>\n<li>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</li>\n<li>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</li>\n<li>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</li>\n<li>SQL 支持以下三种注释：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">## 注释\nSELECT *\nFROM mytable; -- 注释\n&#x2F;* 注释1\n   注释2 *&#x2F;</code></pre>\n\n<ol start=\"6\">\n<li>数据库创建与使用：</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE DATABASE test;\nUSE test;</code></pre>\n\n<h3 id=\"2-创建表\"><a href=\"#2-创建表\" class=\"headerlink\" title=\"2.创建表\"></a>2.创建表</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE mytable (\n  # int 类型，不为空，自增\n  id INT NOT NULL AUTO_INCREMENT,\n  # int 类型，不可为空，默认值为 1，不为空\n  col1 INT NOT NULL DEFAULT 1,\n  # 变长字符串类型，最长为 45 个字符，可以为空\n  col2 VARCHAR(45) NULL,\n  # 日期类型，可为空\n  col3 DATE NULL,\n  # 设置主键为 id\n  PRIMARY KEY (&#96;id&#96;));</code></pre>\n\n<h3 id=\"3-修改表\"><a href=\"#3-修改表\" class=\"headerlink\" title=\"3.修改表\"></a>3.修改表</h3><ul>\n<li>添加列</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">ALTER TABLE mytable\nADD col CHAR(20);</code></pre>\n\n<ul>\n<li>删除列</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">ALTER TABLE mytable\nDROP COLUMN col;</code></pre>\n\n<ul>\n<li>删除表</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">DROP TABLE mytable;</code></pre>\n\n<h3 id=\"4-插入\"><a href=\"#4-插入\" class=\"headerlink\" title=\"4.插入\"></a>4.插入</h3><ul>\n<li>普通插入</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">INSERT INTO mytable(col1, col2)\nVALUES(val1, val2);</code></pre>\n\n<ul>\n<li>插入检索出来的数据</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">INSERT INTO mytable1(col1, col2)\nSELECT col1, col2\nFROM mytable2;</code></pre>\n\n<ul>\n<li>将一个表的内容插入到一个新表</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE newtable AS\nSELECT * FROM mytable;</code></pre>\n\n<h3 id=\"5-更新\"><a href=\"#5-更新\" class=\"headerlink\" title=\"5.更新\"></a>5.更新</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">UPDATE mytable\nSET col &#x3D; val\nWHERE id &#x3D; 1;</code></pre>\n\n<h3 id=\"6-删除\"><a href=\"#6-删除\" class=\"headerlink\" title=\"6.删除\"></a>6.删除</h3><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">DELETE FROM mytable\nWHERE id &#x3D; 1;</code></pre>\n\n<ul>\n<li><strong>TRUNCATE TABLE</strong> 可以清空表，也就是删除所有行。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">TRUNCATE TABLE mytable;</code></pre>\n\n<p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p>\n<h3 id=\"7-查询\"><a href=\"#7-查询\" class=\"headerlink\" title=\"7.查询\"></a>7.查询</h3><ul>\n<li>DISTINCT：相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT DISTINCT col1, col2\nFROM mytable;</code></pre>\n\n<ul>\n<li>LIMIT：限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</li>\n</ul>\n<p>返回前 5 行：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable\nLIMIT 5;\nSELECT *\nFROM mytable\nLIMIT 0, 5;</code></pre>\n\n<p>返回第 3 ~ 5 行：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable\nLIMIT 2, 3;</code></pre>\n\n<h3 id=\"8-排序\"><a href=\"#8-排序\" class=\"headerlink\" title=\"8.排序\"></a>8.排序</h3><ul>\n<li><strong>ASC</strong> ：升序（默认）</li>\n<li><strong>DESC</strong> ：降序</li>\n</ul>\n<p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable\nORDER BY col1 DESC, col2 ASC;</code></pre>\n\n<h3 id=\"9-过滤\"><a href=\"#9-过滤\" class=\"headerlink\" title=\"9.过滤\"></a>9.过滤</h3><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable\nWHERE col IS NULL;</code></pre>\n\n<p>下表显示了 WHERE 子句可用的操作符</p>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;&gt; !=</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>&lt;= !&gt;</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;= !&lt;</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在两个值之间</td>\n</tr>\n<tr>\n<td>IS NULL</td>\n<td>为 NULL 值</td>\n</tr>\n</tbody></table>\n<p>应该注意到，NULL 与 0、空字符串都不同。</p>\n<p><strong>AND 和 OR</strong> 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p>\n<p><strong>IN</strong> 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>\n<p><strong>NOT</strong> 操作符用于否定一个条件。</p>\n<h3 id=\"10-通配符\"><a href=\"#10-通配符\" class=\"headerlink\" title=\"10.通配符\"></a>10.通配符</h3><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>\n<ul>\n<li><strong>%</strong> 匹配 &gt;=0 个任意字符；</li>\n<li><strong>_</strong> 匹配 ==1 个任意字符；</li>\n<li><strong>[ ]</strong> 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。</li>\n</ul>\n<p>使用 Like 来进行通配符匹配。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable\nWHERE col LIKE &#39;[^AB]%&#39;; -- 不以 A 和 B 开头的任意文本</code></pre>\n\n<p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>\n<h3 id=\"11-计算字段\"><a href=\"#11-计算字段\" class=\"headerlink\" title=\"11.计算字段\"></a>11.计算字段</h3><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>\n<p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT col1 * col2 AS alias\nFROM mytable;</code></pre>\n\n<p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT CONCAT(TRIM(col1), &#39;(&#39;, TRIM(col2), &#39;)&#39;) AS concat_col\nFROM mytable;</code></pre>\n\n<h3 id=\"12-函数\"><a href=\"#12-函数\" class=\"headerlink\" title=\"12.函数\"></a>12.函数</h3><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>\n<h4 id=\"汇总\"><a href=\"#汇总\" class=\"headerlink\" title=\"汇总\"></a>汇总</h4><table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AVG()</td>\n<td>返回某列的平均值</td>\n</tr>\n<tr>\n<td>COUNT()</td>\n<td>返回某列的行数</td>\n</tr>\n<tr>\n<td>MAX()</td>\n<td>返回某列的最大值</td>\n</tr>\n<tr>\n<td>MIN()</td>\n<td>返回某列的最小值</td>\n</tr>\n<tr>\n<td>SUM()</td>\n<td>返回某列值之和</td>\n</tr>\n</tbody></table>\n<p>AVG() 会忽略 NULL 行。</p>\n<p>使用 DISTINCT 可以汇总不同的值。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT AVG(DISTINCT col1) AS avg_col\nFROM mytable;</code></pre>\n\n<h4 id=\"文本处理\"><a href=\"#文本处理\" class=\"headerlink\" title=\"文本处理\"></a>文本处理</h4><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LEFT()</td>\n<td>左边的字符</td>\n</tr>\n<tr>\n<td>RIGHT()</td>\n<td>右边的字符</td>\n</tr>\n<tr>\n<td>LOWER()</td>\n<td>转换为小写字符</td>\n</tr>\n<tr>\n<td>UPPER()</td>\n<td>转换为大写字符</td>\n</tr>\n<tr>\n<td>LTRIM()</td>\n<td>去除左边的空格</td>\n</tr>\n<tr>\n<td>RTRIM()</td>\n<td>去除右边的空格</td>\n</tr>\n<tr>\n<td>LENGTH()</td>\n<td>长度</td>\n</tr>\n<tr>\n<td>SOUNDEX()</td>\n<td>转换为语音值</td>\n</tr>\n</tbody></table>\n<p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable\nWHERE SOUNDEX(col1) &#x3D; SOUNDEX(&#39;apple&#39;)</code></pre>\n\n<h4 id=\"日期和时间处理\"><a href=\"#日期和时间处理\" class=\"headerlink\" title=\"日期和时间处理\"></a>日期和时间处理</h4><ul>\n<li>日期格式：YYYY-MM-DD</li>\n<li>时间格式：HH:<zero-width space>MM:SS</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>函 数</th>\n<th>说 明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ADDDATE()</td>\n<td>增加一个日期（天、周等）</td>\n</tr>\n<tr>\n<td>ADDTIME()</td>\n<td>增加一个时间（时、分等）</td>\n</tr>\n<tr>\n<td>CURDATE()</td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td>CURTIME()</td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td>DATE()</td>\n<td>返回日期时间的日期部分</td>\n</tr>\n<tr>\n<td>DATEDIFF()</td>\n<td>计算两个日期之差</td>\n</tr>\n<tr>\n<td>DATE_ADD()</td>\n<td>高度灵活的日期运算函数</td>\n</tr>\n<tr>\n<td>DATE_FORMAT()</td>\n<td>返回一个格式化的日期或时间串</td>\n</tr>\n<tr>\n<td>DAY()</td>\n<td>返回一个日期的天数部分</td>\n</tr>\n<tr>\n<td>DAYOFWEEK()</td>\n<td>对于一个日期，返回对应的星期几</td>\n</tr>\n<tr>\n<td>HOUR()</td>\n<td>返回一个时间的小时部分</td>\n</tr>\n<tr>\n<td>MINUTE()</td>\n<td>返回一个时间的分钟部分</td>\n</tr>\n<tr>\n<td>MONTH()</td>\n<td>返回一个日期的月份部分</td>\n</tr>\n<tr>\n<td>NOW()</td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td>SECOND()</td>\n<td>返回一个时间的秒部分</td>\n</tr>\n<tr>\n<td>TIME()</td>\n<td>返回一个日期时间的时间部分</td>\n</tr>\n<tr>\n<td>YEAR()</td>\n<td>返回一个日期的年份部分</td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; SELECT NOW();\n2018-4-14 20:25:11</code></pre>\n\n<h4 id=\"数值处理\"><a href=\"#数值处理\" class=\"headerlink\" title=\"数值处理\"></a>数值处理</h4><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIN()</td>\n<td>正弦</td>\n</tr>\n<tr>\n<td>COS()</td>\n<td>余弦</td>\n</tr>\n<tr>\n<td>TAN()</td>\n<td>正切</td>\n</tr>\n<tr>\n<td>ABS()</td>\n<td>绝对值</td>\n</tr>\n<tr>\n<td>SQRT()</td>\n<td>平方根</td>\n</tr>\n<tr>\n<td>MOD()</td>\n<td>余数</td>\n</tr>\n<tr>\n<td>EXP()</td>\n<td>指数</td>\n</tr>\n<tr>\n<td>PI()</td>\n<td>圆周率</td>\n</tr>\n<tr>\n<td>RAND()</td>\n<td>随机数</td>\n</tr>\n</tbody></table>\n<h3 id=\"13-分组\"><a href=\"#13-分组\" class=\"headerlink\" title=\"13.分组\"></a>13.分组</h3><p>把具有相同的数据值的行放在同一组中。</p>\n<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>\n<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT col, COUNT(*) AS num\nFROM mytable\nGROUP BY col;</code></pre>\n\n<p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT col, COUNT(*) AS num\nFROM mytable\nGROUP BY col\nORDER BY num;</code></pre>\n\n<p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT col, COUNT(*) AS num\nFROM mytable\nWHERE col &gt; 2\nGROUP BY col\nHAVING num &gt;&#x3D; 2;</code></pre>\n\n<p>分组规定：</p>\n<ul>\n<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>\n<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>\n<li>NULL 的行会单独分为一组；</li>\n<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>\n</ul>\n<h3 id=\"14-子查询\"><a href=\"#14-子查询\" class=\"headerlink\" title=\"14.子查询\"></a>14.子查询</h3><p>子查询中只能返回一个字段的数据。</p>\n<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable1\nWHERE col1 IN (SELECT col2\n               FROM mytable2);</code></pre>\n\n<p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT cust_name, (SELECT COUNT(*)\n                   FROM Orders\n                   WHERE Orders.cust_id &#x3D; Customers.cust_id)\n                   AS orders_num\nFROM Customers\nORDER BY cust_name;</code></pre>\n\n<h3 id=\"15-连接\"><a href=\"#15-连接\" class=\"headerlink\" title=\"15.连接\"></a>15.连接</h3><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>\n<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>\n<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>\n<h4 id=\"内连接\"><a href=\"#内连接\" class=\"headerlink\" title=\"内连接\"></a>内连接</h4><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT A.value, B.value\nFROM tablea AS A INNER JOIN tableb AS B\nON A.key &#x3D; B.key;</code></pre>\n\n<p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT A.value, B.value\nFROM tablea AS A, tableb AS B\nWHERE A.key &#x3D; B.key;</code></pre>\n\n<h4 id=\"自连接\"><a href=\"#自连接\" class=\"headerlink\" title=\"自连接\"></a>自连接</h4><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>\n<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>\n<p>子查询版本</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT name\nFROM employee\nWHERE department &#x3D; (\n      SELECT department\n      FROM employee\n      WHERE name &#x3D; &quot;Jim&quot;);</code></pre>\n\n<p>自连接版本</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT e1.name\nFROM employee AS e1 INNER JOIN employee AS e2\nON e1.department &#x3D; e2.department\n      AND e2.name &#x3D; &quot;Jim&quot;;</code></pre>\n\n<h4 id=\"自然连接\"><a href=\"#自然连接\" class=\"headerlink\" title=\"自然连接\"></a>自然连接</h4><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>\n<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT A.value, B.value\nFROM tablea AS A NATURAL JOIN tableb AS B;</code></pre>\n\n<h4 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h4><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>\n<p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT Customers.cust_id, Customer.cust_name, Orders.order_id\nFROM Customers LEFT OUTER JOIN Orders\nON Customers.cust_id &#x3D; Orders.cust_id;</code></pre>\n\n<p>customers 表：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>a</td>\n</tr>\n<tr>\n<td>2</td>\n<td>b</td>\n</tr>\n<tr>\n<td>3</td>\n<td>c</td>\n</tr>\n</tbody></table>\n<p>orders 表：</p>\n<table>\n<thead>\n<tr>\n<th>order_id</th>\n<th>cust_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2</td>\n<td>1</td>\n</tr>\n<tr>\n<td>3</td>\n<td>3</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3</td>\n</tr>\n</tbody></table>\n<p>结果：</p>\n<table>\n<thead>\n<tr>\n<th>cust_id</th>\n<th>cust_name</th>\n<th>order_id</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>a</td>\n<td>1</td>\n</tr>\n<tr>\n<td>1</td>\n<td>a</td>\n<td>2</td>\n</tr>\n<tr>\n<td>3</td>\n<td>c</td>\n<td>3</td>\n</tr>\n<tr>\n<td>3</td>\n<td>c</td>\n<td>4</td>\n</tr>\n<tr>\n<td>2</td>\n<td>b</td>\n<td>Null</td>\n</tr>\n</tbody></table>\n<h3 id=\"16-组合查询\"><a href=\"#16-组合查询\" class=\"headerlink\" title=\"16.组合查询\"></a>16.组合查询</h3><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>\n<p>每个查询必须包含相同的列、表达式和聚集函数。</p>\n<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>\n<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT col\nFROM mytable\nWHERE col &#x3D; 1\nUNION\nSELECT col\nFROM mytable\nWHERE col &#x3D;2;</code></pre>\n\n<h3 id=\"17-视图\"><a href=\"#17-视图\" class=\"headerlink\" title=\"17.视图\"></a>17.视图</h3><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>\n<p>对视图的操作和对普通表的操作一样。</p>\n<p>视图具有如下好处：</p>\n<ul>\n<li>简化复杂的 SQL 操作，比如复杂的连接；</li>\n<li>只使用实际表的一部分数据；</li>\n<li>通过只给用户访问视图的权限，保证数据的安全性；</li>\n<li>更改数据格式和表示。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE VIEW myview AS\nSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col\nFROM mytable\nWHERE col5 &#x3D; val;</code></pre>\n\n<h3 id=\"18-存储过程\"><a href=\"#18-存储过程\" class=\"headerlink\" title=\"18.存储过程\"></a>18.存储过程</h3><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>\n<p>使用存储过程的好处：</p>\n<ul>\n<li>代码封装，保证了一定的安全性；</li>\n<li>代码复用；</li>\n<li>由于是预先编译，因此具有很高的性能。</li>\n</ul>\n<p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p>\n<p>包含 in、out 和 inout 三种参数。</p>\n<p>给变量赋值都需要用 select into 语句。</p>\n<p>每次只能给一个变量赋值，不支持集合的操作。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">delimiter &#x2F;&#x2F;\n\ncreate procedure myprocedure( out ret int )\n    begin\n        declare y int;\n        select sum(col1)\n        from mytable\n        into y;\n        select y*y into ret;\n    end &#x2F;&#x2F;\n\ndelimiter ;\ncall myprocedure(@ret);\nselect @ret;</code></pre>\n\n<h3 id=\"19-游标\"><a href=\"#19-游标\" class=\"headerlink\" title=\"19.游标\"></a>19.游标</h3><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>\n<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>\n<p>使用游标的四个步骤：</p>\n<ol>\n<li>声明游标，这个过程没有实际检索出数据；</li>\n<li>打开游标；</li>\n<li>取出数据；</li>\n<li>关闭游标；</li>\n</ol>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">delimiter &#x2F;&#x2F;\ncreate procedure myprocedure(out ret int)\n    begin\n        declare done boolean default 0;\n\n        declare mycursor cursor for\n        select col1 from mytable;\n        # 定义了一个 continue handler，当 sqlstate &#39;02000&#39; 这个条件出现时，会执行 set done &#x3D; 1\n        declare continue handler for sqlstate &#39;02000&#39; set done &#x3D; 1;\n\n        open mycursor;\n\n        repeat\n            fetch mycursor into ret;\n            select ret;\n        until done end repeat;\n\n        close mycursor;\n    end &#x2F;&#x2F;\n delimiter ;</code></pre>\n\n<h3 id=\"20-触发器\"><a href=\"#20-触发器\" class=\"headerlink\" title=\"20.触发器\"></a>20.触发器</h3><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>\n<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>\n<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TRIGGER mytrigger AFTER INSERT ON mytable\nFOR EACH ROW SELECT NEW.col into @result;\n\nSELECT @result; -- 获取结果</code></pre>\n\n<p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>\n<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>\n<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>\n<h3 id=\"21-事务管理\"><a href=\"#21-事务管理\" class=\"headerlink\" title=\"21.事务管理\"></a>21.事务管理</h3><p>基本术语：</p>\n<ul>\n<li>事务（transaction）指一组 SQL 语句；</li>\n<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>\n<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>\n<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li>\n</ul>\n<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>\n<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>\n<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>\n<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">START TRANSACTION\n&#x2F;&#x2F; ...\nSAVEPOINT delete1\n&#x2F;&#x2F; ...\nROLLBACK TO delete1\n&#x2F;&#x2F; ...\nCOMMIT</code></pre>\n\n<h3 id=\"22-字符集\"><a href=\"#22-字符集\" class=\"headerlink\" title=\"22.字符集\"></a>22.字符集</h3><p>基本术语：</p>\n<ul>\n<li>字符集为字母和符号的集合；</li>\n<li>编码为某个字符集成员的内部表示；</li>\n<li>校对字符指定如何比较，主要用于排序和分组。</li>\n</ul>\n<p>除了给表指定字符集和校对外，也可以给列指定：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE mytable\n(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )\nDEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;</code></pre>\n\n<p>可以在排序、分组时指定校对：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SELECT *\nFROM mytable\nORDER BY col COLLATE latin1_general_ci;</code></pre>\n\n<h3 id=\"23-权限管理\"><a href=\"#23-权限管理\" class=\"headerlink\" title=\"23.权限管理\"></a>23.权限管理</h3><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">USE mysql;\nSELECT user FROM user;</code></pre>\n\n<p><strong>创建账户</strong></p>\n<p>新创建的账户没有任何权限。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE USER myuser IDENTIFIED BY &#39;mypassword&#39;;</code></pre>\n\n<p><strong>修改账户名</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">RENAME USER myuser TO newuser;</code></pre>\n\n<p><strong>删除账户</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">DROP USER myuser;</code></pre>\n\n<p><strong>查看权限</strong></p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SHOW GRANTS FOR myuser;</code></pre>\n\n<p><strong>授予权限</strong></p>\n<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">GRANT SELECT, INSERT ON mydatabase.* TO myuser;</code></pre>\n\n<p><strong>删除权限</strong></p>\n<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>\n<ul>\n<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>\n<li>整个数据库，使用 ON database.*；</li>\n<li>特定的表，使用 ON database.table；</li>\n<li>特定的列；</li>\n<li>特定的存储过程。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;</code></pre>\n\n<p><strong>更改密码</strong></p>\n<p>必须使用 Password() 函数进行加密。</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">SET PASSWROD FOR myuser &#x3D; Password(&#39;new_password&#39;);</code></pre>\n\n<h2 id=\"3-MySQL实战45讲\"><a href=\"#3-MySQL实战45讲\" class=\"headerlink\" title=\"3.MySQL实战45讲\"></a>3.MySQL实战45讲</h2><h3 id=\"1-基础架构\"><a href=\"#1-基础架构\" class=\"headerlink\" title=\"1.基础架构\"></a>1.基础架构</h3><ol>\n<li><p>MySQL分为Server层和存储引擎层</p>\n<ul>\n<li><p>Server 层：包括连接器、查询缓存、分析器、优化器、执行器等。所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能（存储过程、触发器、视图）都在这一层实现</p>\n</li>\n<li><p>存储引擎层：负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5.5 版本开始成为了默认存储引擎</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221009200020384-20221011155920254.png\" style=\"zoom: 33%;\" /></li>\n</ul>\n</li>\n<li><p>连接器</p>\n<ul>\n<li>负责跟客户端建立连接、获取权限、维持和管理连接。连接命令为<code>mysql -h$ip -P$port -u$user -p</code></li>\n<li>连接命令中的mysql是客户端工具，用来跟服务端建立连接，在完成TCP握手后（一般客户端和数据库在不同服务器上），连接器开始认证身份。如果密码通过则会读出对应权限（连接时用户权限被管理员修改也不生效）。连接完成后可以使用<code>show processlist</code>来查看，在<code>wait_timeout</code>（8h）后连接自动断开</li>\n<li>长连接与短连接：长连接会造成MySQL占用内存过多，被系统强行杀掉，异常重启的情况。可以定期断开长连接，或执行<code>mysql_reset_connection</code>来重新初始化连接资源（5.7以上版本）</li>\n</ul>\n</li>\n<li><p><del>查询缓存（8.0后删除）</del>：MySQL拿到一个查询请求后，会先到查询缓存，看之间是不是执行过这条语句，语句和执行结果以key-value对的形式被直接缓存在内存中。一般不建议使用查询缓存：查询缓存的失效非常频繁，因为只要对一个表更新，则表上所有的查询缓存都会被清空。按需使用，可以将<code>query_cache_type</code>设置成<code>DEMAND</code>，默认不使用查询缓存，可以通过<code>select SQL_CACHE * from T where ID=10；</code>的方式显示指定</p>\n</li>\n<li><p>分析器：</p>\n<ul>\n<li>词法分析：识别出输入的SQL语句里的字符串都分别是什么，代表什么</li>\n<li>语法分析：根据词法分析结果，通过语法规则判断SQL语句是否满足MySQL语法（指定出错首位置），并且检查表、列等是否存在</li>\n</ul>\n</li>\n<li><p>优化器：在表里有多个索引的时候，决定使用哪个索引；或者在一个SQL语句有多表关联（join）的时候，决定各个表的连接顺序</p>\n</li>\n<li><p>执行器：执行的时候，先判断对此表是否有执行权限（如果命中查询缓存，则在返回时进行权限验证，查询也会在优化器之前调用precheck验证权限）。如果有权限，则打开表继续执行，会根据表的引擎定义去使用这个引擎提供的接口，日志中通过<code>rows_examined</code>字段记录语句执行过程中扫描了多少行</p>\n</li>\n</ol>\n<h3 id=\"2-日志系统\"><a href=\"#2-日志系统\" class=\"headerlink\" title=\"2.日志系统\"></a>2.日志系统</h3><ol>\n<li><p>执行流程：连接器连接数据库、清空表上的查询缓存、分析器通过词法和语法解析知道这是一条更新语句，优化器决定要使用哪个索引，然后执行器具体执行</p>\n</li>\n<li><p>redo log（重做日志，InooDB引擎特有）</p>\n<ul>\n<li><p>每次更新都写进磁盘，IO成本、查询成本都很高，所以引入WAL技术（Write-Ahead Logging），即先写日志、再写磁盘</p>\n<ul>\n<li><p>具体来说当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在系统空闲的时候，将这个操作记录更新到磁盘里面</p>\n</li>\n<li><p>InnoDB 的 redo log 是固定大小的。比如可以配置为一组 4 个文件，每个文件的大小是 1GB，组织成如下结构，write pos即入当前记录位置，边写边后移，checkpoint记录要擦除的位置，边擦除边后移，擦除前更新数据文件，write pos和checkpoint之间的是还空着的部分，可以用来记录新操作</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221009203302189.png\" alt=\"image-20221009203302189\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>Crash-safe：异常重启不丢失记录</p>\n</li>\n</ul>\n</li>\n<li><p>binlog（归档日志，Server层）</p>\n<ol>\n<li>binlog和redo log对比<ul>\n<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>\n<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</li>\n<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>\n<li>持久化<ul>\n<li>innodb_flush_log_at_trx_commit参数设置成 1 ，表示每次事务的 redo log都直接持久化到磁盘</li>\n<li>sync_binlog参数设置成 1 ，表示每次事务的 binlog 都持久化到磁盘</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>举例<code>update T set c=c+1 where ID=2;</code>（redo log的两阶段提交）<ul>\n<li>执行器先找引擎取ID=2这一行。因ID是主键，引擎直接用树搜索找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回</li>\n<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据</li>\n<li>写入redo log：引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <strong>prepare 状态</strong>。然后告知执行器执行完成了，随时可以提交事务</li>\n<li>写binlog：执行器生成这个操作的 binlog，并把 binlog 写入磁盘，binlog会记录所有的逻辑操作</li>\n<li>提交事务：执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交<strong>commit状态</strong></li>\n</ul>\n</li>\n<li>如何恢复数据：找到最近的一次全量备份，从备份的时间点开始，将备份的binlog依次取出来，重放到出问题的时刻。当异常重启的时候，就需要redo log来保证不丢失记录</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-事务\"><a href=\"#3-事务\" class=\"headerlink\" title=\"3.事务\"></a>3.事务</h3><h4 id=\"1-事务隔离\"><a href=\"#1-事务隔离\" class=\"headerlink\" title=\"1.事务隔离\"></a>1.事务隔离</h4><ol>\n<li><p>隔离性与隔离级别</p>\n<ol>\n<li>隔离性（Isolation）：当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了隔离级别的概念</li>\n<li>隔离的越严格，效率就会越低。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）：<ul>\n<li>读未提交：一个事务还没提交时，它做的变更就能被别的事务看到</li>\n<li>读提交：一个事务提交之后，它做的变更才会被其他事务看到。将参数 <code>transaction-isolation</code> 的值设置成 <code>READ-COMMITTED</code></li>\n<li>可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的</li>\n<li>串行化：对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li>\n</ul>\n</li>\n<li>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。<ul>\n<li>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图</li>\n<li>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的</li>\n<li>“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念</li>\n<li>“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>事务隔离的实现（MyISAM引擎不支持事务，InnoDB支持事务）</p>\n<ul>\n<li>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值</li>\n<li>多版本并发控制（MVCC）：对于某条记录的查询，不同时刻启动的事务会有不同的read-view，即同一条记录在系统中可以存在多个版本</li>\n<li>回滚日志删除时间：当系统里没有比这个回滚日志更早的read-view的时候，所以不建议使用长事务，会导致回滚记录的保存从而占用存储空间</li>\n</ul>\n</li>\n<li><p>事务的启动方式</p>\n<ul>\n<li><p>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback，commit work and chain 提交事务并自动启动下一个事务</p>\n</li>\n<li><p>set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。（建议总是<code>set autocommit=1</code>）</p>\n</li>\n<li><p>可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select * from information_schema.innodb_trx \nwhere TIME_TO_SEC(timediff(now(),trx_started))&gt;60;</code></pre></li>\n</ol>\n<h4 id=\"2-事务到底是隔离的还是不隔离的\"><a href=\"#2-事务到底是隔离的还是不隔离的\" class=\"headerlink\" title=\"2.事务到底是隔离的还是不隔离的\"></a>2.事务到底是隔离的还是不隔离的</h4><ol>\n<li><p>事务启动</p>\n<ul>\n<li>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动</li>\n<li>如果想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令</li>\n<li>没有显示使用begin/commit，但是autocommit=1时，一条语句就是一个事务</li>\n</ul>\n</li>\n<li><p>视图</p>\n<ul>\n<li>概念一 view：它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样</li>\n<li>概念二 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view：用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现</li>\n</ul>\n</li>\n<li><p>MVCC中的快照（秒级创建快照）</p>\n<ul>\n<li><p>通过事务的Transaction id来记录同一数据的不同状态，并且将Transaction id赋给状态的row trx_id，来区分不同状态。不同状态不是物理上真实存在的，而是通过undo log和最新状态来综合算出来的。因此在事务启动的时候会记录启动时间，并根据此时间来确定其他事务是否可见，并向上追溯不可见事务直到可见</p>\n</li>\n<li><p>实现：InnoDB为每个事务构造一个数组，用来保存这个事务启动瞬间，当前正在活跃（启动但未提交）的所有事务ID。数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）</p>\n</li>\n<li><p>一致性视图：将所有的row trx_id分成了三种不同的情况</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221011191106200.png\" alt=\"image-20221011191106200\"></p>\n<ul>\n<li>如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；</li>\n<li>如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；</li>\n<li>如果落在黄色部分，那就包括两种情况<ul>\n<li>a. 若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；</li>\n<li>b. 若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>当前读：更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。事务更新数据的时候，只能用当前读。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-索引\"><a href=\"#4-索引\" class=\"headerlink\" title=\"4.索引\"></a>4.索引</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了提高数据查询的效率，类似于书的目录</p></blockquote>\n<h4 id=\"1-索引基础\"><a href=\"#1-索引基础\" class=\"headerlink\" title=\"1.索引基础\"></a>1.索引基础</h4><ol>\n<li>常见模型：从数据模型可推测数据库使用场景<ul>\n<li>哈希表：key-value存储结构，增加新数据的速度很快，但做区间查询的速度是很慢的，只适用于等值查询</li>\n<li>有序数组：在等值查询和范围查询场景中的性能高，但维护成本高，插入需要移动大量元素</li>\n<li>搜索树：平衡二叉搜索树、N叉搜索树，因为索引还要写到磁盘，所以使用B+树，减少I/O次数</li>\n<li>跳表</li>\n<li>LSM树</li>\n</ul>\n</li>\n<li>InnoDB的索引模型<ul>\n<li>索引组织表：在InnoDB中，表都是按照主键顺序以索引的形式存放的，这种方式称为～，又因为InnoDB使用了B+树索引模型，所以数据都存储在B+树中，每一个索引在InnoDB里面对应一棵B+树</li>\n<li>根据叶子界定啊的内容，索引类型分为：<ul>\n<li>主键索引：主键索引的叶子节点存的是整行数据，InnoDB中也被称为聚簇索引（clustered index）</li>\n<li>非主键索引：非主键索引的叶子节点内容是主键的值，InnoDB中也被称为二级索引（secondary index），需要在主键索引中再多搜索一次，称为回表，所以应该尽量使用主键查询</li>\n</ul>\n</li>\n<li>索引维护<ul>\n<li>主要指相应B+树的插入和删除</li>\n<li>自增主键：指自增列上定义的主键，建表语句为： <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code>。每插入一条新记录，会将对应值自增，采用追加操作不涉及到挪动其他记录，也不会触发叶子节点的分裂<ul>\n<li>业务逻辑相关主键没法保证顺序插入数据，写数据成本高</li>\n<li>选取字节数小的当作主键，否则索引所占用的空间过大，如不选身份证号而选自增主键</li>\n</ul>\n</li>\n<li>使用业务字段直接做主键：只有一个索引，且该索引必须是唯一索引，即典型的KV场景，可以使用业务字段做主键，没有其他索引就不用关注叶子结点大小的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>==覆盖索引==<ul>\n<li>从<code>select * from T where k between 3 and 5</code>改为<code>select ID from T where k between 3 and 5</code>，不需要回到主键索引树（回表），直接就可以给出查询结果，称为覆盖索引</li>\n<li>覆盖索引可以减少树的搜索次数，显著提高查询性能，所以使用覆盖索引是一个常用的性能优化手段</li>\n<li>举例：当需要高频请求根据身份证号查询姓名时，建立（身份证号，姓名）联合索引就可以不需要回表查整行记录，减少语句的执行时间</li>\n</ul>\n</li>\n<li>==最左前缀原则==<ul>\n<li>单独为不频繁的请求建立索引会很浪费，通过B+树这种结构，可以利用索引的“最左前缀”来定位记录，即查询以张开头的名字用<code>张%</code></li>\n<li>最左前缀可以是联合索引的最左N个字段，<strong>也可以是字符串索引的最左M个字符</strong>。所以在建立联合索引的时候，就需要考虑索引内的字段顺序，为了索引的复用能力更强，减少需要维护的索引个数</li>\n<li>如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。例如已经有了（a，b）这个联合索引就不需要再单独在a上建立索引，但是需要给b再建立一个索引</li>\n</ul>\n</li>\n<li>==索引下推(index condition pushdown)==<ul>\n<li>MySQL5.6引入的索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</li>\n<li>即在（a，b）索引下找a，b同时满足某些条件的结果，如果没有索引下推，则需要找出a满足条件的行，再回表看b是否满足；如果要是有索引优化，则会在所以内部判断并跳过那些b不满足条件的行</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-选普通索引还是唯一索引\"><a href=\"#2-选普通索引还是唯一索引\" class=\"headerlink\" title=\"2.选普通索引还是唯一索引\"></a>2.选普通索引还是唯一索引</h4><ol>\n<li><strong>查询过程：</strong><ul>\n<li>对于普通索引和唯一索引来说，都需要从B+树的跟节点开始找，当找到第一个符合的记录后，唯一索引会直接返回，而普通索引会继续遍历直到第一个不复合的记录</li>\n<li>因为InnoDB的数据是按数据页来读写的，所以每次读取都会以页（16KB）为单位，将其整体读入内存，所以两个索引性能差距很小，选哪个都行</li>\n</ul>\n</li>\n<li><strong>change buffer：</strong><ul>\n<li>change buffer：当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性<ul>\n<li>持久化：change buffer是可持久化的数据，change buffer在内存中有拷贝，也会被写入到磁盘上</li>\n<li>merge：将change buffer中的操作应用到原数据页，得到最新结果的过程称为merge。访问时会merge、后台定期merge、数据库正常关闭也会执行merge</li>\n</ul>\n</li>\n<li>change buffer的大小可以通过参数<code>innodb_change_buffer_max_size</code>来动态设置 。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%</li>\n<li>change buffer和redo log：redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗</li>\n</ul>\n</li>\n<li><strong>更新过程：</strong><ul>\n<li>要更新的目标页在内存中时：性能没有太大差别</li>\n<li>要更新的目标页不在内存中时：唯一索引的更新不能使用change buffer，只有普通索引可以使用，因为唯一索引需要判断操作是否违反唯一性约束，这就需要读数据页到内存</li>\n<li>普通索引的更新因为有change buffer的存在，性能会有提升，所以写多读少的业务change buffer的效果最好，例如账单类、日志类的系统     </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-为什么有时候选错索引\"><a href=\"#3-为什么有时候选错索引\" class=\"headerlink\" title=\"3.为什么有时候选错索引\"></a>3.为什么有时候选错索引</h4><ol>\n<li>问题：数据库已有10万行记录并在a上由索引，在下面操作的情况下，sessionB的查询变慢，查询选错索引<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/1e5ba1c2934d3b2c0d96b210a27e1a1e.png\" alt=\"img\"></li>\n<li>优化器的逻辑：<ul>\n<li>优化器选择索引的目的：找到一个最优的执行方案，并用最小的代价去执行语句。在数据库里面，扫描行数是影响执行代价的因素之一，扫描的行数越少，意味着访问磁盘数据的次数越少，消耗的CPU资源越少</li>\n<li>基数：MySQL在开始执行语句之前会根据统计信息估算记录数，这个统计信息就是索引的“区分度”。显然，一个索引上不同的值越多（不同值个数称为基数cardinality），这个索引的区分度就越好<ul>\n<li>可以通过<code>show index from tablename;</code> 来看一个索引的基数（估计值），通过<code>analyze table tablename:</code>来重新统计索引信息（==可解决统计错误问题==）</li>\n<li>基数估计方法：InnoDB默认选择N个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数。当变更的行数超过1/M的时候，会自动触发重新做一次索引统计，MySQL中有两种存储索引统计的方式，通过设置参数innodb_stats_persistent来选择<ul>\n<li>设置为 on 的时候，表示统计信息会持久化存储。这时，默认的 N 是 20，M 是 10</li>\n<li>设置为 off 的时候，表示统计信息只存储在内存中。这时，默认的 N 是 8，M 是 16</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>扫描行数：<code>explain + SQL语句</code>中的rows，表示预计扫描行数</li>\n</ul>\n</li>\n<li>选错索引的原因：如果选择非主键索引，那么每次从非主键索引上拿到一个值，都要回主键索引上查出整行数据，这个代价优化器也要算进去，但是如果扫描主键索引，则没有额外的代价，解决办法：<ul>\n<li>使用<code>force index</code>强行选择一个索引，但是不够灵活，一般用来解决线上紧急问题</li>\n<li>修改语句，引导MySQL使用期望的索引，让优化器觉得某个索引比另外一个代价大</li>\n<li>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"4-怎么给字符串字段加索引\"><a href=\"#4-怎么给字符串字段加索引\" class=\"headerlink\" title=\"4.怎么给字符串字段加索引\"></a>4.怎么给字符串字段加索引</h4><ol>\n<li><p>问题场景：支持邮箱登陆的系统怎么在邮箱字段上建立索引（否则需要进行全表扫描）</p>\n</li>\n<li><p>前缀索引：</p>\n<ul>\n<li><p>MySQL支持前缀索引，也就是可以定义字符串的一部分作为索，例如：<code>mysql&gt; alter table SUser add index index2(email(6));</code>，只取每个记录的前6个字节创建索引。缺点是会增加额外的记录扫描次数，因为每次从索引找到记录都需要回到主键上来判断，知道这行记录加入结果集</p>\n</li>\n<li><p>定义好长度，才能做到既节省空间，又不用额外太多的查询成本，可以用下面的语句通过索引上有多少个不同的值来判断要使用多长的前缀</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">select \n  count(distinct left(email,4)）as L4,\n  count(distinct left(email,5)）as L5,\n  count(distinct left(email,6)）as L6,\n  count(distinct left(email,7)）as L7,\nfrom SUser;</code></pre></li>\n<li><p>前缀索引对覆盖索引的影响：</p>\n<ul>\n<li><p>如果只需要查询email和主键列，则可以使用覆盖索引，从email索引查到结果就直接返回，</p>\n</li>\n<li><p>如果列更多则用不上覆盖索引对查询性能的优化，因为要到主键索引查询其他列信息</p>\n</li>\n<li><p>使用前缀索引就用不上覆盖索引对查询性能的优化了</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其它方式（例如：身份证号问题）</p>\n<ul>\n<li><p>倒排存储：将身份证号倒过来存储，查询时如下操作<code>mysql&gt; select field_list from t where id_card = reverse(&#39;input_id_card_string&#39;);</code></p>\n</li>\n<li><p>hash字段：可以在表上在创建一个整数字段，来保存身份证的效验码，同时在这个字段上创建索引<code>mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc)</code>，每次插入新记录的时候，都同时用crc32()这个函数，查询时为避免效验码相同，需要判断<code>id_card</code>的值是否精确相同</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; select field_list from t where id_card_crc&#x3D;crc32(&#39;input_id_card_string&#39;) and id_card&#x3D;&#39;input_id_card_string&#39;</code></pre></li>\n<li><p>异同点：</p>\n<ul>\n<li>从占用的额外空间来看，倒序存储方式在主键索引上，不会消耗额外的存储空间，而 hash 字段方法需要增加一个字段。当然，倒序存储方式使用 4 个字节的前缀长度应该是不够的，如果再长一点，这个消耗跟额外这个 hash 字段也差不多抵消了。</li>\n<li>在 CPU 消耗方面，倒序方式每次写和读的时候，都需要额外调用一次 reverse 函数，而 hash 字段的方式需要额外调用一次 crc32() 函数。如果只从这两个函数的计算复杂度来看的话，reverse 函数额外消耗的 CPU 资源会更小些。</li>\n<li>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-加锁\"><a href=\"#5-加锁\" class=\"headerlink\" title=\"5.加锁\"></a>5.加锁</h3><h4 id=\"1-锁基础\"><a href=\"#1-锁基础\" class=\"headerlink\" title=\"1.锁基础\"></a>1.锁基础</h4><ol>\n<li>全局锁<ul>\n<li>对整个数据库实例加锁，命令是<code>Flush tables with read lock</code>，执行后整个数据库将处于只读状态，其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句</li>\n<li>主要用于全库逻辑备份，即把整库每个表都select出来存成文本，会使得数据库停摆或主从延迟</li>\n<li>备份的常用方法：<ul>\n<li>通过在可重复读隔离级别下开启一个事务。官方自带的工具mysqldump使用参数<code>-single-transaction</code>的时候，导数据之前就会启动一个事务，来确保拿到一致性视图，而由于MVCC的支持，这个过程数据是可以正常更新的</li>\n<li>不使用<code>set global readonly = true</code>的方式：readonly的值在某些系统下可能用来判断是主库还是从库、客户端异常时数据库会一直保持readonly状态，是的数据库长期不可写</li>\n<li>FTWRL方式：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>表级锁<ul>\n<li><del>表锁：</del><ul>\n<li>语法为<code>lock tables ... read/write</code>，既可以通过<code>unlock tables</code>主动释放，也可以在客户端断开时自动释放。除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</li>\n<li>举个例子, 如果在某个线程 A 中执行 lock tables t1 read, t2 write; 这个语句，则其他线程写 t1、读写 t2 的语句都会被阻塞。同时，线程 A 在执行 unlock tables 之前，也只能执行读 t1、读写 t2 的操作。连写 t1 都不允许，自然也不能访问其他表</li>\n<li>一般在数据库引擎不支持行锁的时候才会被用到</li>\n</ul>\n</li>\n<li>元数据锁（meta data lock）<ul>\n<li>MDL不需要显示使用，在访问一个表的时候会被自动加上。作用是保证读写的正确性（表结构不变）</li>\n<li>5.5版本引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表结构变更操作的时候，加MDL写锁</li>\n<li>给表加字段会使得表被写锁锁住，没法继续执行查询，安全的加字段的方法：<ul>\n<li>kill掉长事务或者暂停修改操作</li>\n<li>在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃，之后再重试命令</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>行级锁<ul>\n<li>行锁由引擎层自己实现，但并不是所有的引擎都支持（MyISAM不支持），不支持行锁意味着并发控制只能使用表锁，会影响业务并发度</li>\n<li>两阶段锁协议：在InnoDB事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。可以通过在事务中重排语句顺序来减少加锁时间提高并发度，即将最可能造成锁冲突、最可能影响并发度的锁尽量往后放</li>\n<li>死锁和死锁检测：当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。出现死锁有两种策略：<ul>\n<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li>\n<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on。</li>\n<li>解决热点行更新导致的性能问题：关闭死锁检测、控制并发度</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-缓存\"><a href=\"#6-缓存\" class=\"headerlink\" title=\"6.缓存\"></a>6.缓存</h3><h4 id=\"1-基本使用\"><a href=\"#1-基本使用\" class=\"headerlink\" title=\"1.基本使用\"></a>1.基本使用</h4><h4 id=\"2-更新策略\"><a href=\"#2-更新策略\" class=\"headerlink\" title=\"2.更新策略\"></a>2.更新策略</h4><h4 id=\"3-key-value如何设计\"><a href=\"#3-key-value如何设计\" class=\"headerlink\" title=\"3.key/value如何设计\"></a>3.key/value如何设计</h4>","feature":true,"text":"C++1.语言特性1.概述1.生命周期和编程范式 生命周期 编码（Coding）：主要包括定义变量、写逻辑语句、实现各种数据结构、函数、类。需要遵循语言规范、设计文档、代码规范、设计模式。 预处理（Pre-processing）：这个中间阶段主要依靠预处理器（Pre-proces...","link":"","photos":[],"count_time":{"symbolsCount":"309k","symbolsTime":"4:40"},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#C\"><span class=\"toc-text\">C++</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">1.语言特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">1.生命周期和编程范式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BC%96%E7%A0%81%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">2.编码阶段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E9%A2%84%E5%A4%84%E7%90%86%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">3.预处理阶段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">4.编译阶段</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E8%BF%90%E8%A1%8C%E9%98%B6%E6%AE%B5\"><span class=\"toc-text\">5.运行阶段</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%EF%BC%88auto-decitype%EF%BC%89\"><span class=\"toc-text\">2.自动类型推导（auto&#x2F;decitype）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B8%B8%E9%87%8F%EF%BC%88const%E3%80%81volatile%E3%80%81mutable%EF%BC%89\"><span class=\"toc-text\">3.常量（const、volatile、mutable）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88smart-ptr%EF%BC%89\"><span class=\"toc-text\">4.智能指针（smart_ptr）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%BC%82%E5%B8%B8%EF%BC%88exception%EF%BC%89\"><span class=\"toc-text\">5.异常（exception）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88lambda%EF%BC%89\"><span class=\"toc-text\">6.函数式编程（lambda）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">2.面向对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">1.类和对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">2.引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%BB%A7%E6%89%BF%E5%92%8C%E6%B4%BE%E7%94%9F\"><span class=\"toc-text\">3.继承和派生</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%A4%9A%E6%80%81%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">4.多态与虚函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\"><span class=\"toc-text\">5.运算符重载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">6.面向对象进阶</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%A0%87%E5%87%86%E5%BA%93\"><span class=\"toc-text\">3.标准库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Strings-lib\"><span class=\"toc-text\">1.Strings lib</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-%E5%85%83%E5%AD%97%E7%AC%A6\"><span class=\"toc-text\">1.元字符</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E9%87%8F%E8%AF%8D%E4%B8%8E%E8%B4%AA%E5%A9%AA\"><span class=\"toc-text\">2.量词与贪婪</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E7%BB%84%E4%B8%8E%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">3.分组与引用</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#4-%E5%8C%B9%E9%85%8D%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.匹配模式</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#5-%E6%96%AD%E8%A8%80\"><span class=\"toc-text\">5.断言</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#6-%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">6.应用</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#7-%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE\"><span class=\"toc-text\">7.优化建议</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Containers-lib\"><span class=\"toc-text\">2.Containers lib</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Algorithm-lib\"><span class=\"toc-text\">3.Algorithm lib</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Concurrency-lib\"><span class=\"toc-text\">4.Concurrency lib</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-General-util-lib\"><span class=\"toc-text\">5.General util lib</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Memory-lib\"><span class=\"toc-text\">6.Memory  lib</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%BC%80%E6%BA%90%E5%BA%93\"><span class=\"toc-text\">4.开源库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">1.序列化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">2.网络通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-I-O%E5%8F%8A%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.I&#x2F;O及文件操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">4.性能分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%85%B6%E4%BB%96%E5%BC%80%E6%BA%90%E5%BA%93%E6%A6%82%E8%A7%88\"><span class=\"toc-text\">5.其他开源库概览</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">5.实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-C-primer\"><span class=\"toc-text\">1.C++primer</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Effective-C\"><span class=\"toc-text\">2.Effective C++</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Effective-C\"><span class=\"toc-text\">1.Effective C++</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-More-Effective-c\"><span class=\"toc-text\">2.More Effective c++</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-C-20\"><span class=\"toc-text\">3.C++20</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-C-20%E5%AE%9E%E8%B7%B5%E5%85%A5%E9%97%A8\"><span class=\"toc-text\">1.C++20实践入门</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-C-20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">2.C++20高级编程</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux\"><span class=\"toc-text\">Linux</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Theory\"><span class=\"toc-text\">Theory</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0-1\"><span class=\"toc-text\">1.概述</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">2.进程管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%83%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">七状态模型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">&#x3D;&#x3D;进程通信&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E4%B8%B4%E7%95%8C%E4%BA%92%E6%96%A5%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">软硬件实现临界互斥的方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%EF%BC%88%E9%98%BB%E5%A1%9E-%E4%B8%8A%E9%94%81%EF%BC%89\"><span class=\"toc-text\">进程同步（阻塞+上锁）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">进程调度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%BB%E9%94%81%EF%BC%88%E7%8B%AC%E5%8D%A0%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E4%B8%8D%E5%BD%93%EF%BC%89\"><span class=\"toc-text\">&#x3D;&#x3D;死锁（独占资源分配不当）&#x3D;&#x3D;</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">基础知识</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E6%B4%BE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">&#x3D;&#x3D;内存分派方式&#x3D;&#x3D;</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E9%80%8F%E6%98%8E%EF%BC%89%EF%BC%88%E6%9C%89%E5%86%85%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%89\"><span class=\"toc-text\">基本分页存储管理方式（透明）（有内部碎片）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F%EF%BC%88%E4%B8%8D%E9%80%8F%E6%98%8E%EF%BC%89%EF%BC%88%E6%9C%89%E5%A4%96%E9%83%A8%E7%A2%8E%E7%89%87%EF%BC%89\"><span class=\"toc-text\">基本分段存储管理方式（不透明）（有外部碎片）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">段页式管理方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98\"><span class=\"toc-text\">虚拟内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2\"><span class=\"toc-text\">页面置换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B6%E5%AE%83\"><span class=\"toc-text\">其它</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.文件管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">文件相关操作</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%EF%BC%88%E7%94%A8%E6%88%B7%E8%A7%92%E5%BA%A6%EF%BC%89\"><span class=\"toc-text\">文件逻辑结构（用户角度）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">文件目录结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E4%B8%8E%E4%BF%9D%E6%8A%A4%EF%BC%88%E7%9B%AE%E5%BD%95-gt-%E6%96%87%E4%BB%B6%EF%BC%89\"><span class=\"toc-text\">文件共享与保护（目录-&gt;文件）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">文件系统层次结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">目录实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%88%E6%96%87%E4%BB%B6%E5%AE%9E%E7%8E%B0%EF%BC%89\"><span class=\"toc-text\">文件物理结构（文件实现）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E9%9D%9E%E7%A9%BA%E9%97%B2%E5%9D%97%EF%BC%89\"><span class=\"toc-text\">文件分配方式（非空闲块）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%EF%BC%88%E7%A9%BA%E9%97%B2%E5%9D%97%EF%BC%89\"><span class=\"toc-text\">存储空间管理（空闲块）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%88%90%E7%BB%84%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">成组链接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98\"><span class=\"toc-text\">磁盘</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">磁盘调度算法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%AE%A1%E7%90%86%EF%BC%88I-O%EF%BC%89\"><span class=\"toc-text\">5.输入输出管理（I&#x2F;O）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F%EF%BC%88%E5%A4%96%E8%AE%BE%E4%B8%8E%E5%86%85%E5%AD%98%E9%97%B4%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%EF%BC%89%EF%BC%88%E5%9F%8E%E4%B8%ADD%E9%81%93%EF%BC%89\"><span class=\"toc-text\">I&#x2F;O控制方式（外设与内存间传输方式）（城中D道）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#I-O%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">I&#x2F;O子系统层次结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8\"><span class=\"toc-text\">设备控制器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#I-O%E5%AD%90%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">I&#x2F;O子系统概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">缓冲区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SPOOLing%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">SPOOLing技术</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Bash\"><span class=\"toc-text\">6.Bash</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">1.理论</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">2.基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-text-manipulation-tools\"><span class=\"toc-text\">1.text manipulation tools</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-process-monitoring\"><span class=\"toc-text\">2.process monitoring</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-network\"><span class=\"toc-text\">3.network</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E9%98%B6\"><span class=\"toc-text\">3.进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-Bash-scripting\"><span class=\"toc-text\">1.Bash scripting</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-vim\"><span class=\"toc-text\">2.vim</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-compiling-apps\"><span class=\"toc-text\">3.compiling apps</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#POSIX\"><span class=\"toc-text\">POSIX</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">1.网络通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">2.进程间通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.进程管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.内存管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">5.文件管理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Linux-Internal\"><span class=\"toc-text\">Linux Internal</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%BC%E8%BF%B0\"><span class=\"toc-text\">1.Linux操作系统综述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%A4%96%E5%8C%85%E5%85%AC%E5%8F%B8%E7%9A%84%E7%B1%BB%E6%AF%94\"><span class=\"toc-text\">1.外包公司的类比</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">2.Linux常用命令</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Linux%E5%B8%B8%E8%A7%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">3.Linux常见系统调用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">2.系统初始化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-X86%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.X86架构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%BB%8EBIOS%E5%88%B0bootloader\"><span class=\"toc-text\">2.从BIOS到bootloader</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">3.内核初始化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%EF%BC%88%E5%8A%9E%E4%BA%8B%E5%A4%A7%E5%8E%85%EF%BC%89\"><span class=\"toc-text\">4.系统调用（办事大厅）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-1\"><span class=\"toc-text\">3.进程管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">1.进程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">2.线程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E7%A8%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.进程数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">4.进程调度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">5.进程创建</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#fork-%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%B6%E5%A4%A7%E4%BA%8B%EF%BC%9A%E5%A4%8D%E5%88%B6%E7%BB%93%E6%9E%84copy-process\"><span class=\"toc-text\">fork 的第一件大事：复制结构copy_process</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">6.线程创建</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1\"><span class=\"toc-text\">4.内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.内存管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">2.进程空间管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.物理内存管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%94%A8%E6%88%B7%E6%80%81%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">4.用户态内存映射</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%86%85%E6%A0%B8%E6%80%81%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">5.内核态内存映射</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">5.文件系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">6.输入输出系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">7.进程间通信</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">8.网络系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E8%99%9A%E6%8B%9F%E5%8C%96\"><span class=\"toc-text\">9.虚拟化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E5%AE%B9%E5%99%A8%E5%8C%96\"><span class=\"toc-text\">10.容器化</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TCP-IP\"><span class=\"toc-text\">TCP&#x2F;IP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0\"><span class=\"toc-text\">1.网络协议综述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%8F%8A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82\"><span class=\"toc-text\">1.网络协议及网络分层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E5%A4%87\"><span class=\"toc-text\">2.设备</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Web-%E9%A1%B5%E9%9D%A2%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">3.Web 页面请求过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-DHCP-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">1. DHCP 配置主机信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-ARP-%E8%A7%A3%E6%9E%90-MAC-%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">2. ARP 解析 MAC 地址</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-DNS-%E8%A7%A3%E6%9E%90%E5%9F%9F%E5%90%8D\"><span class=\"toc-text\">3. DNS 解析域名</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-HTTP-%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">4. HTTP 请求页面</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%BA%95%E5%B1%82%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">2.底层网络知识详解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82\"><span class=\"toc-text\">1.数据链路层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%89%A9%E7%90%86%E5%B1%82\"><span class=\"toc-text\">1.物理层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-MAC\"><span class=\"toc-text\">2.MAC</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">2.网络层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%9F%A5%E7%9C%8BIP%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">1.查看IP地址</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-IP%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">2.IP获取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">3.拓扑结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-ICMP%E5%8D%8F%E8%AE%AE%E4%B8%8Eping\"><span class=\"toc-text\">4.ICMP协议与ping</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E7%BD%91%E5%85%B3%E5%92%8C%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">5.网关和路由协议</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-NAT%E4%B8%8E%E9%98%B2%E7%81%AB%E5%A2%99\"><span class=\"toc-text\">6.NAT与防火墙</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E9%98%B2%E7%81%AB%E5%A2%99\"><span class=\"toc-text\">1.防火墙</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-NAT\"><span class=\"toc-text\">2.NAT</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-NAT%E5%92%8CTCP-P214\"><span class=\"toc-text\">3.NAT和TCP P214</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BC%A0%E8%BE%93%E5%B1%82\"><span class=\"toc-text\">3.传输层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-UDP\"><span class=\"toc-text\">1.UDP</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-TCP\"><span class=\"toc-text\">2.TCP</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Socket\"><span class=\"toc-text\">3.Socket</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%BA%94%E7%94%A8%E5%B1%82\"><span class=\"toc-text\">4.应用层</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-HTTP-1-1\"><span class=\"toc-text\">1.HTTP&#x2F;1.1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8D%8F%E8%AE%AE%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%84%E5%88%99\"><span class=\"toc-text\">1.协议的通用规则</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%B6%88%E6%81%AF%E7%9A%84%E8%B7%AF%E7%94%B1\"><span class=\"toc-text\">2.连接与消息的路由</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86%E4%B8%8E%E4%BC%A0%E8%BE%93\"><span class=\"toc-text\">3.内容协商与传输</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-cookie%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">4.cookie的设计与问题</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E7%BC%93%E5%AD%98%E7%9A%84%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">5.缓存的控制</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-WebSocket\"><span class=\"toc-text\">2.WebSocket</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-HTTP-2-0\"><span class=\"toc-text\">3.HTTP&#x2F;2.0</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-TLS-SSL\"><span class=\"toc-text\">1.TLS&#x2F;SSL</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-HTTPS\"><span class=\"toc-text\">2.HTTPS</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%B5%81%E5%AA%92%E4%BD%93%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">4.流媒体协议</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-P2P%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">5.P2P协议</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">5.数据中心</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-DNS\"><span class=\"toc-text\">1.DNS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-CDN\"><span class=\"toc-text\">2.CDN</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83\"><span class=\"toc-text\">3.数据中心</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-VPN\"><span class=\"toc-text\">4.VPN</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">5.移动网络</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%83%AD%E9%97%A8%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">3.热门技术中的应用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">1.云计算中的网络</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BA%91%E4%B8%AD%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">1.云中网络</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">2.软件定义网络</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">3.云中的网络安全</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BA%91%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9CQoS\"><span class=\"toc-text\">4.云中的网络QoS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E4%BA%91%E4%B8%AD%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9A%94%E7%A6%BBGRE%E3%80%81VXLAN\"><span class=\"toc-text\">5.云中网络的隔离GRE、VXLAN</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">2.容器技术中的网络</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">1.容器网络</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cgroup%EF%BC%9A%E8%99%BD%E7%84%B6%E6%95%B4%E5%8F%B0%E6%9C%BA%E5%99%A8%E6%9C%89%E5%BE%88%E5%A4%9A%E7%9A%84CPU%E3%80%81%E5%86%85%E5%AD%98%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E5%8F%AA%E8%83%BD%E7%94%A8%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86\"><span class=\"toc-text\">cgroup：虽然整台机器有很多的CPU、内存，但是一个应用只能用其中的一部分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BFlannel\"><span class=\"toc-text\">2.容器网络之Flannel</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E4%B9%8BCallco\"><span class=\"toc-text\">3.容器网络之Callco</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">3.微服务相关协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-RPC%E5%8D%8F%E8%AE%AE%E7%BB%BC%E8%BF%B0\"><span class=\"toc-text\">1.RPC协议综述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E4%BA%8EXML%E7%9A%84SOAP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">2.基于XML的SOAP协议</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%9F%BA%E4%BA%8EJSON%E7%9A%84RESTful%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">3.基于JSON的RESTful接口协议</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%B1%BBRPC%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">4.二进制类RPC协议</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%B1%BBRPC%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">5.跨语言类RPC协议</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Kubernetes\"><span class=\"toc-text\">Kubernetes</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Docker\"><span class=\"toc-text\">1.Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.常用操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">3.实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Docker%E5%AE%B9%E5%99%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">1.Docker容器引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-Docker%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">1. Docker出现的背景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-Docker%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">2. Docker是什么</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%B8%8E%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">3. 与传统虚拟化技术的区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">4. Docker基本概念</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-Docker%E4%B8%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%81Git%E3%80%81JVM%E7%9A%84%E7%B1%BB%E6%AF%94\"><span class=\"toc-text\">5. Docker与虚拟机、Git、JVM的类比</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-Docker%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">6. Docker镜像文件系统</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-Docker%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">7. Docker基础操作系统</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-Docker%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">8. Docker持久化存储</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-Docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">9. Docker镜像制作方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#10-Docker%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">10. Docker的使用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">11. 总结</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E7%A1%80-1\"><span class=\"toc-text\">2.基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%9D%E7%BA%A7\"><span class=\"toc-text\">1.初级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">1.集群搭建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">2.架构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-YAML\"><span class=\"toc-text\">3.YAML</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Pod\"><span class=\"toc-text\">4.Pod</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Job-CronJob\"><span class=\"toc-text\">5.Job&#x2F;CronJob</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-ConfigMap-Secret\"><span class=\"toc-text\">6.ConfigMap&#x2F;Secret</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%B8%AD%E7%BA%A7\"><span class=\"toc-text\">2.中级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Kubeadm\"><span class=\"toc-text\">1.Kubeadm</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\"><span class=\"toc-text\">准备工作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Deployment\"><span class=\"toc-text\">2.Deployment</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Daemonset\"><span class=\"toc-text\">3.Daemonset</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Service\"><span class=\"toc-text\">4.Service</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Ingress\"><span class=\"toc-text\">5.Ingress</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E9%AB%98%E7%BA%A7\"><span class=\"toc-text\">3.高级</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-PersistentVolume\"><span class=\"toc-text\">1.PersistentVolume</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-persistentVolume-NFS\"><span class=\"toc-text\">2.persistentVolume+NFS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-StatefulSet\"><span class=\"toc-text\">3.StatefulSet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">4.滚动更新</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%BA%94%E7%94%A8%E4%BF%9D%E9%9A%9C\"><span class=\"toc-text\">5.应用保障</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">6.集群管理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7\"><span class=\"toc-text\">7.系统监控</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">8.网络通信</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E9%98%B6-1\"><span class=\"toc-text\">3.进阶</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%AE%B9%E5%99%A8%E7%BC%96%E6%8E%92%E4%B8%8E%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.容器编排与作业管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">2.持久化存储</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">3.容器网络</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">4.作业调度与资源管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6\"><span class=\"toc-text\">5.容器运行时</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%AE%B9%E5%99%A8%E7%9B%91%E6%8E%A7%E4%B8%8E%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">6.容器监控与日志</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL\"><span class=\"toc-text\">MySQL</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5-1\"><span class=\"toc-text\">1.概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Indexes\"><span class=\"toc-text\">1.Indexes</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MySQL-%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">MySQL 索引</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">索引优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">索引的优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">索引的使用条件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2.查询性能优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-Explain-%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90\"><span class=\"toc-text\">使用 Explain 进行分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE\"><span class=\"toc-text\">优化数据访问</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">重构查询方式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">3.存储引擎</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#InnoDB\"><span class=\"toc-text\">InnoDB</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MyISAM\"><span class=\"toc-text\">MyISAM</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">比较</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">4.数据类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B4%E5%9E%8B\"><span class=\"toc-text\">整型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%AE%E7%82%B9%E6%95%B0\"><span class=\"toc-text\">浮点数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">字符串</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F\"><span class=\"toc-text\">时间和日期</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Sharding\"><span class=\"toc-text\">5.Sharding</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86\"><span class=\"toc-text\">水平切分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86\"><span class=\"toc-text\">垂直切分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Sharding-%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">Sharding 策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Sharding-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">Sharding 存在的问题</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Replication\"><span class=\"toc-text\">6.Replication</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">主从复制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">读写分离</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-Transactions\"><span class=\"toc-text\">7.Transactions</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-database-normalization\"><span class=\"toc-text\">8.database normalization</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-SQL%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">2.SQL语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">1.基础</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA%E8%A1%A8\"><span class=\"toc-text\">2.创建表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BF%AE%E6%94%B9%E8%A1%A8\"><span class=\"toc-text\">3.修改表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%8F%92%E5%85%A5\"><span class=\"toc-text\">4.插入</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">5.更新</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">6.删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">7.查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">8.排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E8%BF%87%E6%BB%A4\"><span class=\"toc-text\">9.过滤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E9%80%9A%E9%85%8D%E7%AC%A6\"><span class=\"toc-text\">10.通配符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E8%AE%A1%E7%AE%97%E5%AD%97%E6%AE%B5\"><span class=\"toc-text\">11.计算字段</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">12.函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">汇总</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86\"><span class=\"toc-text\">文本处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86\"><span class=\"toc-text\">日期和时间处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%80%BC%E5%A4%84%E7%90%86\"><span class=\"toc-text\">数值处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E5%88%86%E7%BB%84\"><span class=\"toc-text\">13.分组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E5%AD%90%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">14.子查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15-%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">15.连接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%85%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">内连接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">自连接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">自然连接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A4%96%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">外连接</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#16-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">16.组合查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#17-%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">17.视图</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#18-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">18.存储过程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#19-%E6%B8%B8%E6%A0%87\"><span class=\"toc-text\">19.游标</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#20-%E8%A7%A6%E5%8F%91%E5%99%A8\"><span class=\"toc-text\">20.触发器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#21-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">21.事务管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#22-%E5%AD%97%E7%AC%A6%E9%9B%86\"><span class=\"toc-text\">22.字符集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#23-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">23.权限管理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-MySQL%E5%AE%9E%E6%88%9845%E8%AE%B2\"><span class=\"toc-text\">3.MySQL实战45讲</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">1.基础架构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">2.日志系统</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">3.事务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB\"><span class=\"toc-text\">1.事务隔离</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%BA%8B%E5%8A%A1%E5%88%B0%E5%BA%95%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84%E8%BF%98%E6%98%AF%E4%B8%8D%E9%9A%94%E7%A6%BB%E7%9A%84\"><span class=\"toc-text\">2.事务到底是隔离的还是不隔离的</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">4.索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B4%A2%E5%BC%95%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">1.索引基础</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%80%89%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E8%BF%98%E6%98%AF%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">2.选普通索引还是唯一索引</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E6%97%B6%E5%80%99%E9%80%89%E9%94%99%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">3.为什么有时候选错索引</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%80%8E%E4%B9%88%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5%E5%8A%A0%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">4.怎么给字符串字段加索引</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%8A%A0%E9%94%81\"><span class=\"toc-text\">5.加锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%94%81%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">1.锁基础</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">6.缓存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.基本使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">2.更新策略</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-key-value%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">3.key&#x2F;value如何设计</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Note-GWY","uid":"144619318c56e5335eaaf8b275761000","slug":"Note-GWY","date":"2023-04-20T08:48:16.000Z","updated":"2023-04-20T08:48:49.205Z","comments":true,"path":"api/articles/Note-GWY.json","keywords":null,"cover":[],"text":"错题汇总1.言语理解和表达 红P11真3 红P12真1 红P15真1 红P16真1 红P21真1 红P25真题 红P29真1 红P34真6 红P63真1 红P68真 红P71真 2.判断推理 红P141真1 红P142真2 红P149真3 红P153真1 红P154真 红P162...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"28 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Note-Java","uid":"6cc22201d59326eaf451b7fbadccff38","slug":"Note-Java","date":"2023-04-20T08:37:55.000Z","updated":"2023-04-20T08:44:30.318Z","comments":true,"path":"api/articles/Note-Java.json","keywords":null,"cover":[],"text":"Basic Syntax Android、Chromium（OS用C++）、Spring /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home /Library/Java/JavaVirtualMachines/jd...","link":"","photos":[],"count_time":{"symbolsCount":"777k","symbolsTime":"11:46"},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}