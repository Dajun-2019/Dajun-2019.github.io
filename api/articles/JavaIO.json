{"title":"JavaIO","uid":"8970e53c4358273744b2d5e4a88f3fff","slug":"JavaIO","date":"2023-04-13T23:56:57.000Z","updated":"2023-04-15T00:08:04.044Z","comments":true,"path":"api/articles/JavaIO.json","keywords":null,"cover":null,"content":"<h1 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h1><ol>\n<li><p>IO</p>\n<ul>\n<li>明确要操作的数据是数据源还是数据目的+要操作的是字节还是字符</li>\n<li>明确数据存在的具体设备：FileXXX、PipedXXX、CharAtXXX、StringXXX、ByteArrayXXX、Socket</li>\n<li>明确是否需要额外功能：缓存（BufferedXXX）、基本数据类型（DataInputStream、DataOutStream）、对象读写（ObjectInputStream、ObjectOutputStream）、字符流与字符的桥梁（InputStreamReader、OutputStreamWriter）</li>\n</ul>\n</li>\n<li><p>阻塞I/O模型（BIO）：阻塞IO+线程，多线程+read阻塞等待</p>\n<ul>\n<li>利用阻塞模式搭配多线程来实现服务器，因为read()是阻塞函数，所以需要提前创建线程池和大量线程，来等待客户端发来的连接。如果有n个客户端连接服务器，那么服务器需要创建n+1个线程，其中n个线程用于调用read()函数，1个线程用来调用accept()函数接收连接。当线程比较多时，内存资源的消耗就会比较大。</li>\n<li>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间；在客户端连接数量不高时没问题，当面对十万甚至百万连接时会无能为力</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket serverSocket &#x3D; new ServerSocket();\n        serverSocket.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        while (true) &#123;\n            &#x2F;&#x2F; accept()为阻塞函数，直到有连接到来才返回\n            Socket clientSocket &#x3D; serverSocket.accept();\n            &#x2F;&#x2F; 为每个客户端单独创建一个线程处理\n            new Thread(new ClientHandler(clientSocket)).start();\n        &#125;\n    &#125;\n\n    private static class ClientHandler implements Runnable &#123;\n        private Socket socket;\n        public ClientHandler(Socket socket) &#123;\n            this.socket &#x3D; socket;\n        &#125;\n\n        @Override\n        public void run() &#123;\n            byte[] data &#x3D; new byte[1024];\n            while (true) &#123; &#x2F;&#x2F;持续接收客户端发来的数据\n                try &#123;\n                    &#x2F;&#x2F; read()为阻塞函数，直到读取到数据再返回\n                    socket.getInputStream().read(data);\n                    &#x2F;&#x2F; write()为阻塞函数，全部写完成才会返回\n                    socket.getOutputStream().write(data); &#x2F;&#x2F;echo\n                &#125; catch (IOException e) &#123;\n                    &#x2F;&#x2F; log and exit\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>非阻塞I/O模型（NIO）：Selector+非阻塞IO，注册channel（不会一直占用线程） + Selector多路复用（隔一段时间轮询，找能执行的channel）</p>\n<ul>\n<li>非阻塞模型利用非阻塞模式和Selector多路复用器来开发服务器，也叫做多路复用I/O模型。只有实现了SelectableChannel接口的Channel才可以注册到Selector中被监听，比如DatagramChannel、SocketChannel、ServerSocketChannel，FileChannel无法被Selector监听</li>\n<li>在NioEchoServer类中，如果有n可客户端连接服务器，那么就会创建n+1个Channel，其中一个serverChannel用于接受客户端的连接，另外n个clientChannel用于与客户端进行通信。这n+1个Channel均注册到Selector中。Selector会间隔一定时间轮训这n+1个Channel，查找可连接、可读、可写的Channel，然后再进行连接、读取、写入操作</li>\n<li>多路复用I/O模型：只需要一个线程即可，解决了阻塞I/O模型线程开销大的问题。但是如果某些clientChannel耗时比较久，那么其它clientChannel便需要阻塞，使得服务器响应的延迟变高，但可以用过线程池中取线程来处理，而不是所有的clientChannel都在一个线程中处理。跟非阻塞I/O的区别在于不管有没有数据可读，阻塞I/O模型中的每个clientSocket都会一直占用线程。而这里的多线程只会处理经过Selector筛选之后有可读数据的clientChannel，并且处理完之后就释放回线程池，线程的利用率更高</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F; Selector\n        Selector selector &#x3D; Selector.open();\n\n        &#x2F;&#x2F; create serverChannel and register to selector\n        ServerSocketChannel serverChannel &#x3D; ServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        serverChannel.configureBlocking(false);&#x2F;&#x2F;非阻塞\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n        while (true) &#123;\n            int channelCount &#x3D; selector.select(); &#x2F;&#x2F;取来准备好的selector\n            if (channelCount &gt; 0) &#123;\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n                Iterator&lt;SelectionKey&gt; iterator &#x3D; keys.iterator();\n                while (iterator.hasNext()) &#123;\n                    SelectionKey key &#x3D; iterator.next();&#x2F;&#x2F;链表\n                    if (key.isAcceptable()) &#123;\n                        &#x2F;&#x2F; create clientChannel and register to selector\n                        SocketChannel clientChannel &#x3D; serverChannel.accept();\n                        clientChannel.configureBlocking(false);&#x2F;&#x2F;非阻塞\n                        clientChannel.register(selector, SelectionKey.OP_READ);\n                    &#125; else if (key.isReadable()) &#123;\n                        SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();\n                        clientChannel.read(buffer);\n                        buffer.flip(); &#x2F;&#x2F;从&quot;用于读&quot;变为&quot;用于写&quot;\n                        if (buffer.hasRemaining())&#123;&#x2F;&#x2F;也可以注册到selector中\n                            clientChannel.write(buffer); &#x2F;&#x2F;echo\n                        &#125;\n                        buffer.clear(); &#x2F;&#x2F;重复利用\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>异步I/O模型（AIO）：异步IO，通过异步Channel，数据读取完成后会执行回调函数</p>\n<ul>\n<li>通过异步Channel调用accept()、read()、write()函数。当有连接建立、数据读取完成、数据写入完成时，底层会通过线程池执行对应的回调函数。这种服务器的实现方式叫做异步I/O模型</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AioEchoServer &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        AsynchronousServerSocketChannel serverChannel &#x3D; AsynchronousServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        &#x2F;&#x2F; 异步accept()\n        serverChannel.accept(null, new AcceptCompletionHandler(serverChannel));\n        Thread.sleep(Integer.MAX_VALUE);\n    &#125;\n\n    private static class AcceptCompletionHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;\n        private AsynchronousServerSocketChannel serverChannel;\n        public AcceptCompletionHandler(AsynchronousServerSocketChannel serverChannel) &#123;\n            this.serverChannel &#x3D; serverChannel; \n        &#125;\n\n        @Override\n        public void completed(AsynchronousSocketChannel clientChannel, Object attachment) &#123;\n            &#x2F;&#x2F; in order to accept other client&#39;s connections\n            serverChannel.accept(attachment, this);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n            &#x2F;&#x2F; 异步read()\n            clientChannel.read(buffer, buffer, new ReadCompletionHandler(clientChannel)); \n        &#125;\n\n        @Override\n        public void failed(Throwable exc, Object attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n\n    private static class ReadCompletionHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private AsynchronousSocketChannel clientChannel;\n        public ReadCompletionHandler(AsynchronousSocketChannel clientChannel) &#123;\n            this.clientChannel &#x3D; clientChannel;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer buffer) &#123;\n            buffer.flip();\n            &#x2F;&#x2F; 异步write()。回调函数为null，写入完成就不用回调了\n            clientChannel.write(buffer, null, null); &#x2F;&#x2F; echo\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>新技术</p>\n<ul>\n<li>DMA：通过在主板上安装一个叫做DMAC (DMA Controller，DMA控制器)的协处理器(或叫芯片)，协助CPU来完成I/O设备的数据读写工作（现在很多IO设备都自带DMAC）。DMAC替代CPU从设备中读取数据或向设备写入数据，通过中断通知CPU，CPU利用率提高了</li>\n<li>mmap（memory-mapped file，内存映射文件）：提高文件读写性能的有效技术，一般用于文件读写，不适用于网络这种数据未知的I/O设备</li>\n<li>零拷贝：不需要将数据拷贝到应用程序缓冲区，而是直接从内核读缓冲区拷贝到内核写缓冲区，应用程序只需要进行一次系统调用（执行sendfile()），就可以将文件发送到网络</li>\n</ul>\n</li>\n</ol>\n","feature":true,"text":"IO IO 明确要操作的数据是数据源还是数据目的+要操作的是字节还是字符 明确数据存在的具体设备：FileXXX、PipedXXX、CharAtXXX、StringXXX、ByteArrayXXX、Socket 明确是否需要额外功能：缓存（BufferedXXX）、基本数据类型（...","link":"","photos":[],"count_time":{"symbolsCount":"7.3k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IO\"><span class=\"toc-text\">IO</span></a></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java并发","uid":"75ca176d6b382373bec123f05862c849","slug":"Java并发","date":"2023-04-13T23:56:43.000Z","updated":"2023-04-15T00:08:07.854Z","comments":true,"path":"api/articles/Java并发.json","keywords":null,"cover":[],"text":"Java并发1.线程 线程 线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING 线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N） Java使用用户线程模型，上层JVM...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}