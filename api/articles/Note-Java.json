{"title":"Note-Java","uid":"6cc22201d59326eaf451b7fbadccff38","slug":"Note-Java","date":"2023-04-20T08:37:55.000Z","updated":"2023-04-20T08:44:30.318Z","comments":true,"path":"api/articles/Note-Java.json","keywords":null,"cover":[],"content":"<h1 id=\"Basic-Syntax\"><a href=\"#Basic-Syntax\" class=\"headerlink\" title=\"Basic Syntax\"></a>Basic Syntax</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Android、Chromium（OS用C++）、Spring</p>\n<p>/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home</p>\n<p>/Library/Java/JavaVirtualMachines/jdk1.8.0_333.jdk/Contents/Home</p>\n<p>/opt/homebrew/bin:$PATH</p></blockquote>\n<h2 id=\"路线图\"><a href=\"#路线图\" class=\"headerlink\" title=\"路线图\"></a>路线图</h2><h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"1-程序的本质\"><a href=\"#1-程序的本质\" class=\"headerlink\" title=\"1.程序的本质\"></a>1.程序的本质</h3><h4 id=\"1-编程语言类型\"><a href=\"#1-编程语言类型\" class=\"headerlink\" title=\"1.编程语言类型\"></a>1.编程语言类型</h4><ol>\n<li>编译型语言：类似于C++，代码会在编译成机器指令后再被执行，CPU执行机器指令效率高，但因为CPU指令集和OS系统调用的不同，需要根据环境重新编译</li>\n<li>解释型语言：类似于Python，代码在执行过程中，有虚拟机（解释器）逐条编译并执行，因为执行包括编译所以执行耗时长，但因为有虚拟机来帮助适应编译环境，可以执行好</li>\n<li>混合型语言：类似于Java，编译器将<code>.java</code>文件翻译成字节码<code>.class</code>文件，字节码与平台无关但又可快速翻译成机器码，机器码也是解释执行但速度较快。JIT（即时编译）将热点字节码编译成机器码缓存起来，以供反复执行</li>\n</ol>\n<h4 id=\"2-OS、JVM\"><a href=\"#2-OS、JVM\" class=\"headerlink\" title=\"2.OS、JVM\"></a>2.OS、JVM</h4><ol>\n<li><p>OS在程序执行中的作用：用来管理硬件资源和调度程序执行。提供类库（编译好的机器指令）并封装成系统调用供应用程序使用</p>\n</li>\n<li><p>JVM在程序执行中的作用：C++编译之后的代码可以直接执行，而Python和Java代码的执行，需要依赖虚拟机，即编译命令中的python和java。虚拟机可以看作一个编译成机器指令的程序，用户代码相当于这个程序的一个插件，虚拟机将字节码翻译成CPU指令，放到固定的内存位置，再通过修改CPU寄存器中存储的地址的方式，引导CPU执行这块内存中存储的CPU指令。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">#C++\n$ g++ helloworld.cpp -o helloworld\n$ .&#x2F;helloworld\n#Python\n$ python helloworld.py\n#Java\n$ javac helloworld.java\n$ java helloworld</code></pre></li>\n</ol>\n<h4 id=\"3-CPU指令、汇编语言、字节码\"><a href=\"#3-CPU指令、汇编语言、字节码\" class=\"headerlink\" title=\"3.CPU指令、汇编语言、字节码\"></a>3.CPU指令、汇编语言、字节码</h4><ol>\n<li><p>CPU指令 = 操作码 + 地址 + 数据，指明要执行的操作、数据来源、操作结果去向</p>\n</li>\n<li><p>汇编语言：汇编指令与CPU指令一一对应，采用字符而不是二进制数来表示，汇编语言也需要经过汇编成机器码才能被执行，C/C++的编译过程就包括这一步：先编译成汇编代码，在汇编成机器码。主要有两种风格：Intel风格、AT&amp;T风格</p>\n</li>\n<li><p>字节码：</p>\n<ol>\n<li><p>诞生的目的：克服p解释型语言解释执行速度慢的缺点，字节码跟平台无关是为了让Jaca保留跨平台的优点，因此虚拟机必须跟平台有关。</p>\n</li>\n<li><p>字节码的格式：</p>\n<ol>\n<li><p>一堆有固定格式的十六进制格式的二进制码，使用<code>javap</code>工具可以将class文件解析成人类阅读的模式（与<code>javac</code>的功能相反）</p>\n</li>\n<li><p>class文件里包含了很多类的信息，一条字节码指令有操作码和可选的操作数组成，因为操作码长度为一个字节，所以这种指令格式被叫做字节码。而且可以得知，字节码的操作码类型不超过256个（2^8），以为抽象程度高，所以比汇编指令少很多，但逻辑更加复杂。</p>\n</li>\n</ol>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220421211615033-165468719667545-16566865818082.png\" alt=\"image-20220421211615033\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-代码的执行\"><a href=\"#4-代码的执行\" class=\"headerlink\" title=\"4.代码的执行\"></a>4.代码的执行</h4><ol>\n<li><p>依靠CPU中的寄存器+L1、L2、L3三级缓存，存取数据。寄存器的类别有以下几种：</p>\n<ul>\n<li><p>通用寄存器：AX、BX、CX、DX</p>\n</li>\n<li><p>指针寄存器：BP（一个栈桢的栈底地址）、SP（栈顶地址）、SI（源地址寄存器）、DI（目的地址寄存器）、IP（指令指针寄存器）</p>\n</li>\n<li><p>段寄存器：CS（代码段地址寄存器，物理地址=段地址*16+偏移地址(IP)）、DS（数据段地址寄存器，与SI结合）、SS（栈寄存器，与SP结合或与BP结合）</p>\n</li>\n<li><p>指令寄存器：IR（存放当前正在执行的指令用于译码器译码，即一串二进制码）</p>\n</li>\n<li><p>标志寄存器：FR（也叫程序状态寄存器PSW，这个寄存器的每一个二进制位记录一类状态）</p>\n</li>\n</ul>\n</li>\n<li><p>CPU执行指令的流程：</p>\n<ol>\n<li>对于编译型语言，OS会把编译好的机器码，加载到内存中的代码段，将代码中变量等数据放入内存中的数据段，并且设置好各个寄存器的初始值。CPU根据PC寄存器（CS寄存器和IP寄存器的总称）存储的内存地址，从对应的内存单元取出一条CPU指令，放到指令寄存器，然后将IP寄存器的地址递增指向下一个条指令，一条指令执行完成之后，再通过PC寄存器中的地址，取下一条指令继续执行。</li>\n<li>对于解释型或混合型语言，操作系统将虚拟机本身的机器码，加载到内存中的代码段，然后一条一条地被CPU执行。这部分执行的指令对应的功能，就包括把程序员编写的程序解释成机器码这一功能。虚拟机把解释好的机器码放到某段内存中，然后将PC寄存器的地址设置为这段内存的首地址，于是，CPU就被虚拟机引导去执行程序员编写的代码。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-基础结构\"><a href=\"#5-基础结构\" class=\"headerlink\" title=\"5.基础结构\"></a>5.基础结构</h4><ol>\n<li>变量：<ol>\n<li>内存被划分为内存单元，一个内存单元对应一个地址。在机器码中，因为通过内存地址来实现内存中数据的读写的可读性比较差，所以高级语言中用变量作为地址的别名来使用。</li>\n<li>因为变量的作用域（声明周期）的不同，为提高内存利用率被分到不同的区域来存储，主要有栈、堆、常量池<ul>\n<li>栈一般存储函数内的数据，如局部变量，参数，用完即丢</li>\n<li>堆一般存储作用域不局限于函数内的数据，如对象，需要显示的释放</li>\n<li>常量池一般存储常量，常量的生命周期跟程序的生命周期一样，在程序结束之后才会被释放</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>数组：为了减少程序中的变量数量，Java中new出的数组存储在堆上，C语言中既可以申请栈上的内存也可以动态分配堆上的内存</li>\n<li>类型：CPU不知道类型的信息，类型主要是看编译器怎么解读，引入类型的目的是为了方便程序员编写正确的代码，避免错误的复制操作。根据类型是否可以动态变化和类型检查发生的时期可以分为以下两种：<ul>\n<li>动态类型：一个变量的类型是可变的，具体看赋值给他的数据是什么类型的，类型检查发生在运行期。例如：PHP</li>\n<li>静态类型：一个变量的类型是唯一确定的，类型检查发生在编译期。例如Java、Go</li>\n</ul>\n</li>\n<li>运算：常见的运算类型主要有：算术运算、关系运算、赋值运算、逻辑运算、位运算，绝大部分运算在CPU中都有对应的指令。因为不同类型的电路逻辑不同，所以执行的花费也不同，例如：位运算比乘、除法快。</li>\n<li>跳转：程序由顺序、选择、循环三种基本结构构成，其中选择和循环又统称为跳转。不管是<code>if</code>还是<code>for</code>底层都是通过CPU的跳转指令（jge,jle,je,jmp等）来实现的。goto语句因会导致可读性变差，被废弃</li>\n<li>函数：<ol>\n<li>实现代码模块化的一种手段，函数底层实现依赖函数栈，栈中依次保存了，前一个栈帧的栈底地址，参数，局部变量，返回地址（BP指向前一个栈帧的栈底地址，SP保存了栈顶地址）。</li>\n<li>CPU通过callq指令调用函数，callq指令会将当前的rip寄存器中的内容（callq指令的下一条指令的内存地址，即返回地址）存储在栈帧的最顶端，当被调用的函数执行完时，被调用函数的栈帧释放，最后调用retq指令（相当于popq %rip），将返回地址重新赋值给rip，CPU就可以从函数中callq指令的下一条指令继续执行了。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-基本类型\"><a href=\"#2-基本类型\" class=\"headerlink\" title=\"2.基本类型\"></a>2.基本类型</h3><h4 id=\"1-类型转换\"><a href=\"#1-类型转换\" class=\"headerlink\" title=\"1.类型转换\"></a>1.类型转换</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>自动类型转换、强制类型转换、引用类型转换</p></blockquote>\n<ol>\n<li><p>自动类型转换（隐式转换）：从数据范围小的类型向数据范围大的类型转换，触发自动类型转换    </p>\n<ul>\n<li>byte 自动转换为：short、int、long、float、double；</li>\n<li>short自动转换为：        、int、long、float、double；</li>\n<li>char 自动转换为：        、int、long、float、double；（==得到char类型的UTF-16编码==）</li>\n<li>int    自动转换为：                、long、float、double；</li>\n<li>long 自动转换为：                          、float、double；</li>\n<li>float 自动转换为：                                     、double；</li>\n</ul>\n<p>==注意：是否能自动转换的参考是数据范围而不是类型长度（所占字节个数）==</p>\n<ol>\n<li><p>short和char都占2个字节，但不能互相转换：<strong>short是-32768-32767，而char是0-65535，转换跨度大</strong></p>\n</li>\n<li><p>long占用8个字节，但却能转换为4字节的float：<strong>浮点数表示方法特殊，采用科学计数法，long转换为float会损失一些精度，相当于四舍五入，对于本身就无法表示精确值的float来说，这种转换时合理的</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long l &#x3D; 500000000000000l;\nfloat f &#x3D; l;\nSystem.out.println(f);&#x2F;&#x2F;输出4.99999993E14</code></pre></li>\n</ol>\n</li>\n<li><p>强制类型转换（显式转换）：从数据范围大的类型向数据范围小的类型转换，需要强制类型转换。强制类型转换有可能会导致数据据的截断（将高位字节丢弃）或精度的丢失，只有保证数据落在另一个类型可表示的范围内时，这种转换才是有意义的。</p>\n</li>\n<li><p>引用类型的互相转换：仅限于有继承关系的类之间</p>\n<ol>\n<li><p>向上转换（Upcasting）：将对象的类型转换为父类或接口类型，总是被允许的（自动类型转换）</p>\n</li>\n<li><p>向下转换（Downcasting）：将对象的类型转换子类类型，需要显示指明（强制类型转换）。在向下转换时，因为转换为子类之后，有可能会调用子类存在而父类不存在的属性和方法，所以需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ParentC&#123;\n  public int a;\n&#125;\npublic class ChildC extends ParentC&#123;\n  public int b;\n&#125;\npublic class OtherC&#123;\n  public int c;\n&#125;\npublic class Demo&#123;\n  public static void main(String[] args)&#123;\n    ChildC child &#x3D; new ChildC();\n    f(child);&#x2F;&#x2F;向上转换，自动类型转换，总是可以的\n  &#125;\n&#125;\npublic static void f(ParentC obj)&#123;\n  &#x2F;&#x2F;需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已\n  OtherC oc &#x3D; (OtherC)obj;&#x2F;&#x2F;报错\n  ChildC cc &#x3D; (ChildC)obj;&#x2F;&#x2F;OK\n  System.out.println(cc.b);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-float\"><a href=\"#2-float\" class=\"headerlink\" title=\"2.float\"></a>2.float</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>浮点数表示法、BigDecimal</p></blockquote>\n<ol>\n<li><p>科学计数法：</p>\n<ol>\n<li><p>十进制科学计数法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">float f1 &#x3D; 100000000.0f;\nSystem.out.println(&quot;&quot; + f1);&#x2F;&#x2F;输出1.0E8\nfloat f2 &#x3D; 1.3E23f;\nSystem.out.println(&quot;&quot;+f2);&#x2F;&#x2F;输出1.3E23</code></pre></li>\n<li><p>二进制科学计数法：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/l2n0io920ssc-165468719667649-16566865818096.png\" alt=\"6-1.png\" style=\"zoom:33%;\" /></p>\n</li>\n</ol>\n</li>\n<li><p>实数的存储方式：定点数与浮点数，浮点数相关概念如下：</p>\n<ol>\n<li><p>计算机中的浮点数一般分为4字节精度浮点数和8字节浮点数，对应到Java语言中就是float类型和double类型</p>\n</li>\n<li><p>浮点数的二进制格式为：(-1)^s*M*2^E（M的整数位必须是1），例如：-12.375-&gt;-1100.011-&gt;(-1)^1*1.100011*2^3。存储格式如下：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/l2n0in6b0gqi-165468719667651-16566865818098.png\" alt=\"6-3.png\" style=\"zoom:33%;\" /></p>\n<ul>\n<li><p>存储时M的整数位不用存储</p>\n</li>\n<li><p>E的范围是[-126，127]，且为无符号类型，将E统一加127后，再存到指数域</p>\n<ul>\n<li>指数域为0（0000 0000，本应为-127），用来辅助表示浮点数0，即当指数域为0时，从有效数字中读取的二进制位不需要再前面加1</li>\n<li>指数域为255（1111 1111，本应为128），用来辅助表示无穷大或NaN，其中s为0时表示正无穷、s为1时表示负无穷，有效数字域的二进制位不全为0时，表示这是一个无意义数NaN（Not a number）</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Java中Float类中定义3个静态常量来表示正无穷大和NaN\npublic static final float POSITIVE_INFINITY &#x3D; 1.0f&#x2F;0.0f;\npublic static final float NEGATIVE_INFINITY &#x3D; -1.0f&#x2F;0.0f;\npublic static final float NaN &#x3D; 0.0f&#x2F;0.0f;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>表示范围（4字节精度浮点数来举例）：M的最大值是24个1，指数的最大值是127，因此最大值是1.11…1111*2^127，最小值是-1.11…1111*2^127，即3.4E38和-3.4E38</p>\n</li>\n<li><p>精度：当某个实数表示成二进制科学计数法，其有效字位数超过24位时，就会做精度舍弃（非四舍五入），不仅仅小数会有，整数也有精度问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">float f &#x3D; 0.1f;\nSystem.out.printf(&quot;%.11f\\n&quot;,f);&#x2F;&#x2F;0.10000000149\n&#x2F;&#x2F;0.1的二进制表示为：0.001100110011...</code></pre></li>\n<li><p>BigDecimal（浮点数的替代品）</p>\n<ol>\n<li><p>对精度不敏感的系统，用浮点数表示就足够了，对精度比较敏感的金融系统，一般采用BigDecimal来表示实数。传递进BigDecimal中的是字符串，而不是float类型数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BigDecimal bg &#x3D; new BigDecimal(&quot;0.1&quot;);\nSystem.out.pringln(bg.toString());&#x2F;&#x2F;输出0.1\nBigDecimal bg &#x3D; new BigDecimal(0.1f);\nSystem.out.println(bg.toString());&#x2F;&#x2F;输出0.0100000.....因为传入前就不准确</code></pre></li>\n<li><p>BIgDecimal提供了相应的方法进行精确的加减乘除操作，对于无法整除的除法操作，我们需要指明舍入（Rounding）方法</p>\n</li>\n<li><p>浮点数的关系操作（判等、大于、小于等）是比较复杂的，需要引入误差，而BigDecimal有现成的方法可以用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if(Math.abs(f1-f2) &lt; 0.0001)&#123;...&#125;\n&#x2F;&#x2F;ret &#x3D; -1,0,1分别表示小于，等于，大于\nif ret &#x3D; bg1.compareTo(bg2)</code></pre></li>\n</ol>\n</li>\n<li><p>浮点数的精度取舍方法</p>\n<ol>\n<li>四舍五入法：出了0.5入都可以抵消，所以累计误差比较大</li>\n<li>四舍六入五成双（银行家算法）：舍去位的数值小于5时，直接舍去；舍去位的数值大于5时，进位；当舍去位的数值等于5时，根据5前一位数的奇偶来判断，偶数则进位，奇数则舍去</li>\n<li>MySQL会四舍五入，Orcale会直接截断</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-char\"><a href=\"#3-char\" class=\"headerlink\" title=\"3.char\"></a>3.char</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>字符集、字符编码、ASCII、UTF-8、UTF-16</p></blockquote>\n<ol>\n<li><p>字符、字符集和字符编码</p>\n<ol>\n<li>字符（Character）可以理解为书面表达中所可能用到的符号，包括文字、数字、标点、图形符号、控制符号（回车、换行）</li>\n<li>字符集（Character Set）是一组字符的集合，不同语言有不用的字符集，例如GB2312是中文字符集，其中每个字符的编号只是为了方便索引</li>\n<li>字符编码（Character Encoding）是指计算机存储字符编号的格式，一个字符集会对应一种或多种字符编码，比如Unicode字符集对应UTF-8、UTF-16、UTF-32三种不同的字符编码</li>\n</ol>\n</li>\n<li><p>常见字符集和字符编码</p>\n<ol>\n<li><p>ASCII字符集和字符编码：0-31和127为不可显示字符（控制字符），32-126为可显示字符，48为<code>0</code>、65为<code>A</code>、97为<code>a</code></p>\n<ol>\n<li><p>字符串存储可显示字符，通过以下方式存储非可显示字符</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">char c1 &#x3D; &#39;a&#39;;\nchar c2 &#x3D; &#39;\\141&#39;;&#x2F;&#x2F;a的ASCII为97，八进制141\nchar c3 &#x3D; &#39;\\015&#39;;&#x2F;&#x2F;回车\nSystem.out.println(&quot;abc\\015def&quot;);&#x2F;&#x2F;一行打印abc，另一行打印def\nchar c4 &#x3D; &#39;\\n&#39;;&#x2F;&#x2F;回车的转义字符为\\n\nSystem.out.println(&quot;abc\\ndef&quot;);&#x2F;&#x2F;一行打印abc，另一行打印def\nchar c5 &#x3D; 97;&#x2F;&#x2F;a的ASCII码值为97，它存储在计算机中的二进制串，跟数值97的二进制串xaing&#39;tong\nSystem.out.println(c5);&#x2F;&#x2F;打印a</code></pre></li>\n<li><p>char类型数据之间的比较和加减操作，对应的是将字符编码转变为无符号数进行相应操作</p>\n</li>\n</ol>\n</li>\n<li><p>GB*支持中文的字符集和字符编码：GB2312：6000多汉字、GBK、GB18030</p>\n</li>\n<li><p>Unicode字符集和UTF*系列字符编码</p>\n<ol>\n<li><p>总共有100多万个字符，为了让常用字符的编号尽可能小，Unicode字符集将编号分为两部分：</p>\n<ul>\n<li>编号从U+0<del>U+FFFF，并且排除U+800</del>U+DFFF，分配给使用频率最高的字符</li>\n<li>编号从U+10000~U+10FFFF，大约有100多万个编号，分配给剩下的所有字符</li>\n</ul>\n</li>\n<li><p>UTF-32：定长编码，使用4个字节来存储Unicode编号，解码时每次读取四个字节解码为一个字符</p>\n</li>\n<li><p>UTF-16：变长编码，U+0<del>U+FFFF（不包含U+D800</del>U+DFFF）内的编号使用2字节编码，U+10000~U+10FFFF之间的编号采用4字节编码。如何确定取出的2个字节对应的数值是2字节编码还是4字节编码的一部分：</p>\n<ol>\n<li>U+0~U+FFFF之间的Unicode编号，直接存储在2个字节中</li>\n<li>U+10000~U+10FFFF之间的Unicode编号，采用如下特殊编码方式<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/l2qcr4ox0l8g-165468719667653-165668658181010.png\" alt=\"7-1.png\" style=\"zoom:33%;\" /></li>\n</ol>\n</li>\n<li><p>UTF-8：</p>\n<ol>\n<li><p>编码方式：不同字节编码的首字节的前缀不同，但尾随字节的前缀均为10</p>\n<table>\n<thead>\n<tr>\n<th>编码</th>\n<th>范围</th>\n<th>第1个字节</th>\n<th>第2个字节</th>\n<th>第3个字节</th>\n<th>第4个字节</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1字节编码</td>\n<td>0000~007F</td>\n<td>0xxxxxxx</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2字节编码</td>\n<td>0080~07FF</td>\n<td>110xxxxx</td>\n<td>10xxxxxx</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3字节编码</td>\n<td>0800~FFFF</td>\n<td>1110xxxx</td>\n<td>10xxxxxx</td>\n<td>10xxxxxx</td>\n<td></td>\n</tr>\n<tr>\n<td>4字节编码</td>\n<td>10000~10FFFF</td>\n<td>11110xxx</td>\n<td>10xxxxxx</td>\n<td>10xxxxxx</td>\n<td>10xxxxxx</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>上图的xxxxx如何替换为具体的Unicode编号</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/l2qcsv3c0tb8-165468719667654-165668658181011.png\" alt=\"7-2.png\"></p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Java中char的字符编码</p>\n<ol>\n<li><p>C语言出现的早，C++继承C语言的特性，所以C/C++中的char类型占用一个字节长度，只能存储ASCII字符，满足英文系统，通过char数组来存储非ASCII字符，比如中文。</p>\n</li>\n<li><p>因为Java出现较晚，Unicode已经流行，为了让char类型表示更多的字符，Java设计了两个字节长的char类型，存储部分Unicode字符（U+0~U+FFFF之间的），Unicode字符会通过UTF-16编码之后存储到char类型变量中</p>\n</li>\n<li><p>跟ASCII码类似，我们也有3种方法将Unicode字符赋值给char类型变量：</p>\n<ul>\n<li>对于可显示字符，我们可以直接使用字符</li>\n<li>对于所有字符（可显示/不可显示），我们都可以将字符对应的UTF-16编码表示为\\uxxxx的形式赋值给变量，其中xxxx为16进制</li>\n<li>对于所有字符，我们都可以将字符对应的Unicode编号赋值给变量</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">char a &#x3D; &#39;我&#39;;&#x2F;&#x2F;字符本身\nchar b &#x3D; &#39;\\u6211&#39;;&#x2F;&#x2F;UTF-16编码\nchar c &#x3D; 0x6211;&#x2F;&#x2F;Unicode编号\n&#x2F;&#x2F;打印a、b、c都会打印出“我”字\n\n&#x2F;&#x2F;U+10000~U+10FFFF范围内的Unicode字符，Java使用char数组来存储\n&#x2F;&#x2F;某个字符的Unicode编号为U+1F701，UTF-16编码为：D830 DF01\nchar[] chs &#x3D; new char[2];\nchs[0] &#x3D; &quot;\\uD83D&quot;;\nchs[1] &#x3D; &quot;\\uDF01&quot;;\n\nString s &#x3D; &quot;\\uD830\\UDFF01&quot;;\n\nchar[] chs2 &#x3D; Character.tochars(0x1F701);</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-包装类\"><a href=\"#4-包装类\" class=\"headerlink\" title=\"4.包装类\"></a>4.包装类</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>自动装箱、自动拆箱、常量池</p></blockquote>\n<ol>\n<li><p>自动装箱和拆箱：</p>\n<ol>\n<li><p>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（Number是整型和浮点型包装类的父类）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;基本类型转换为包装类\nint i &#x3D; 5;\nInteger iobj1 &#x3D; new Integer(i);&#x2F;&#x2F;少用，无法利用IntegerCache缓存，见常量池\nInteger iobj2 &#x3D; Integer.valueOf(i);\n&#x2F;&#x2F;包装类转换为基本类型\ni &#x3D; iobj1.intValue();\n\n&#x2F;&#x2F;自动装箱，语法糖，底层实现为：Integer iobj &#x3D; Integer。valueOf(12);\nInteger iobj &#x3D; 12;\n&#x2F;&#x2F;自动拆箱，语法糖，底层实现为：int i &#x3D; iobj.intValue();\nint i &#x3D; iobj;</code></pre></li>\n<li><p>原始类型byte, short, char, int, long, float, double, boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean</p>\n</li>\n<li><p>触发自动装箱和拆箱的几种情况：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;将基本类型数据赋值给包装类变量（包括参数传递）时，触发自动装箱\nint i1 &#x3D; 5\nInteger iobj1 &#x3D; 5;&#x2F;&#x2F;1\niobj &#x3D; i1;&#x2F;&#x2F;1\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(i1);&#x2F;&#x2F;1\n&#x2F;&#x2F;将包装类对象赋值给基本类型变量（包括参数传递）时，触发自动拆箱\nInteger iobj2&#x3D; new Integer(6);\nint i2 &#x3D; iobj2;&#x2F;&#x2F;2\n&#x2F;&#x2F;当包装类对象参与算术运算、关系运算（&lt;,&gt;）时，触发自动拆箱操作\nInteger iobj3 &#x3D; iobj1 + iobj2;\nboolean bl &#x3D; (iobj1 &lt; iobj2);\nbl &#x3D; (iobj1 &lt; 2);\n&#x2F;&#x2F;当包装类对象参与关系运算（&#x3D;&#x3D;），且另一方是基本类型数据时，触发自动拆箱操作。\nInteger iobj4 &#x3D; new Integer(123);\nbl &#x3D; (iob4 &#x3D;&#x3D; 123);</code></pre></li>\n</ol>\n</li>\n<li><p>常量池技术</p>\n<ol>\n<li><p>Integer等包装类使用了常量池技术，<code>IntegerCache</code>类（享元模式）中会缓存值为-128到127之间的Integer对象，当我们通过自动装箱，也就是调用valueOf()来创建Integer对象时，如果要创建的Integer对象的值再-128到127之间，会从<code>IntegerCache</code>中直接返回，否则才会真正调用new方法创建，详见Integer类的valueOf()</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer a &#x3D; 12;\nInteger b &#x3D; 12;\nInteger c &#x3D; new Integer(12);&#x2F;&#x2F;新Integer对象，不用常量池，不推荐使用\nSystem.out.println(&quot;a&#x3D;&#x3D;12&quot;+(a&#x3D;&#x3D;12));&#x2F;&#x2F;输出true\nSystem.out.println(&quot;a&#x3D;&#x3D;b&quot;+(a&#x3D;&#x3D;b));&#x2F;&#x2F;输出true，常量池返回相同Integer对象\nSystem.out.println(&quot;a&#x3D;&#x3D;c&quot;+(a&#x3D;&#x3D;c));&#x2F;&#x2F;输出false</code></pre></li>\n<li><p>实际上，JVM也提供了方法，让我们可以自定义缓存的最大值。如下所示，如果通过分析应用程序的JVM内存占用情况，发现-128到255之间的数据占用的内存比较多，就可以用如下方式，将缓存的最大值127调整到255，不过，JDK并没有提供设置最小值的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;方法一：\n-Djava.lang.Integer.IntegerCache.high&#x3D;255\n&#x2F;&#x2F;方法二：\n-XX:AutoBoxCacheMax&#x3D;255</code></pre></li>\n<li><p>基本类型VS包装类</p>\n<ol>\n<li><strong>读写效率方面，基本类型高效</strong>：包装类是引用类型，对象的引用和对象本身是分开存储的；基本类型数据变量对应内存块，直接存储数据本身</li>\n<li><strong>存取效率方面，基本类型占用少</strong>：在64位JVM上开启引用压缩的情况下，一个Integer对象占用16个字节，而一个int类型数据只占用4字节的内存空间</li>\n<li>==在项目开发中==：首选基本类型，毕竟基本类型在性能方面更好。但在映射数据库的Entity、映射接口请求的DTO，在数据库或请求中的字段值为null时，我们需要将其映射为Entity或DTO中的null值。还有，我们在初始化变量时，需要将其设置为没有业务意义的值，如果某个变量的默认值0是有业务意义的值，这个时候，我们需要找一个其他值（例如-1）来初始化变量。这种情况下，就是和使用包装类，因为包装类变量的默认值是null，是没有业务意义的。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-位运算\"><a href=\"#5-位运算\" class=\"headerlink\" title=\"5.位运算\"></a>5.位运算</h4><ol>\n<li><p>补码：原码就是用一位表示符号（1为负），其余为数值，但是其减法运算过于复杂，所以发明了补码。其中整数的补码跟原码相同，而负数的补码为原码取反（符号位不变，数值位按位取反）再+1（-0被用作-128）。对于加减法一律按加法处理，并且截断高位溢出。（补码的补码就是原码）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;溢出示例\nint a &#x3D; 2147483647;&#x2F;&#x2F;0x7fffffff\nint b &#x3D; 1;\nint c &#x3D; a + b;&#x2F;&#x2F;c为-2147483648，因为截断高位\n\n&#x2F;&#x2F;如何避免计算的过程中溢出\npublic int sum(int a,int b)&#123;\n    &#x2F;&#x2F;Integer.MIN_VALUE &#x3D; -2147483648\n\tboolean downOverflow &#x3D; a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; a&lt;Integer.MIN_VALUE-b;\n    &#x2F;&#x2F;Integer.MAX_VALUE &#x3D; 2147483647\n\tboolean upOverflow &#x3D; a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; a&gt;Integer.MAX_VALUE-b;\n    if(downOverflow || upOverflow)&#123;\n        throw new RuntimeException(&quot;Overflow&quot;);\n    &#125;\n    return a+b;\n&#125;</code></pre></li>\n<li><p>自动类型转换：当byte类型的数据赋值给short类型变量时，会触发自动类型转换，其中如果byte类型的数据是正数，则高字节用0补全；如果byte类型的数据是负数，那么高字节用1补全</p>\n</li>\n<li><p>位运算：</p>\n<ol>\n<li><p>常见的位运算有：与（&amp;）、或（|）、异或（^）==同0异1==、取反（!）、移位</p>\n</li>\n<li><p>移位分为算数移位和逻辑移位，两种运算操作的对象也是数据的补码。</p>\n<ul>\n<li><p>逻辑位移不区分符号位，整体往左或往右移动，并且在后面或前面补全0。</p>\n</li>\n<li><p>算数左移跟逻辑左移操作相同，算数右移，正数整体右移之后前面补0，负数整体右移之后前面补1。</p>\n<p>==超出范围的二进制位会被舍弃==</p>\n</li>\n</ul>\n</li>\n<li><p>算术左移相当于乘以2，可以代替乘法提高运算速度，但左移之后如果超过了可以表示的数据范围是，就有可能导致数据从负数变为正数，或从正数变为负数。</p>\n</li>\n<li><p>算术右移相当于除以2，对于正数，不停算术右移，最终值为0。不过，对于负数来说，不停算术右移，永远都不会为0，最终停留在-1不变。</p>\n</li>\n<li><p>Java中：算术右移&gt;&gt;，算术左移&lt;&lt;，逻辑右移&gt;&gt;&gt;</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-String\"><a href=\"#6-String\" class=\"headerlink\" title=\"6.String\"></a>6.String</h4><h5 id=\"1-String的实现原理\"><a href=\"#1-String的实现原理\" class=\"headerlink\" title=\"1.String的实现原理\"></a>1.String的实现原理</h5><p>​    String类的定义：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Public final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence&#123;\n    private final char value[];\n    private int hash;\n&#125;</code></pre>\n\n<ol>\n<li><p>接口：</p>\n<ol>\n<li>Serializable接口用来表示该类的对象可以序列化和反序列化（见IO）</li>\n<li>Comparable接口只有一个compareTo()方法，用来比较两个对象的大小，实现此接口可以自行定义比较方式（见容器）</li>\n<li>CharSequence接口定义了一组操作字符串的方法，比如length()、charAt()、toString()等，StringBuilder、StringBuffer都实现了这个接口</li>\n</ol>\n</li>\n<li><p>属性：</p>\n<ol>\n<li>value数组用来存储字符串，从Java9开始，将其改成了byte类型（见String压缩技术）</li>\n<li>hash属性用来缓存hashcode，防止重复计算（见容器）</li>\n</ol>\n</li>\n<li><p>构造方法：（见String常量池技术）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; &quot;abc&quot;;&#x2F;&#x2F;字面常量赋值\nString s2 &#x3D; new String(&quot;abc&quot;);\nString s3 &#x3D; new String(new char[]&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;);\nString s4 &#x3D; new String(s3);</code></pre></li>\n<li><p>运算符：C++能直接重载运算符，但Java并不支持（重载运算符是函数式编程、并且语法太复杂），但是String类却实现了加法操作<code>String sc = sa + sb;</code>，主要是因为String比较常用，所以延续了基本类型及其包装类的设计，这样使用起来就方便和统一</p>\n</li>\n<li><p>length()：</p>\n<ol>\n<li>返回值：char类型value数组的长度，不管是英文还是中文，均占用一个char的存储空间，例如“a我b你c”的函数返回结果为5</li>\n<li>时间复杂度：O(1)，String类的length()方法直接调用了value数组的length属性，length是JVM在内存中为数组维护的信息，所以时间复杂度为O(1)。（其中length属性记录的是数组的大小而不是其中元素的个数，这里可以用因为String不可变，数组大小和字符串元素个数相同）</li>\n</ol>\n</li>\n<li><p>valueOf()</p>\n<ol>\n<li><p>Java重载了一组valueOf()方法，可以将基本数据类型数据转换为String类型</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static String valueOf(boolean b) &#123;\n        return b ? &quot;true&quot; : &quot;false&quot;;\n    &#125;\n\npublic static String valueOf(char c) &#123;\n    char data[] &#x3D; &#123;c&#125;;\n    return new String(data, true);\n&#125;\n\npublic static String valueOf(int i) &#123;\n    return Integer.toString(i);\n&#125;\n\npublic static String valueOf(long l) &#123;\n    return Long.toString(l);\n&#125;\n\npublic static String valueOf(float f) &#123;\n    return Float.toString(f);\n&#125;\n\npublic static String valueOf(double d) &#123;\n    return Double.toString(d);\n&#125;</code></pre></li>\n<li><p>String重载+运算符，不止可以实现两个String对象相加，而且String对象还可以跟其他任意类型的对象相加，最后结果为String对象于其他对象的toString()函数的返回值相加</p>\n</li>\n</ol>\n</li>\n<li><p>compareTo()</p>\n<ol>\n<li>字符比较大小，是将字符对应的UTF-16解读为16位的无符号数，在进行比较</li>\n<li>字符串比较，从下标0开始，两个字符串中的相同下标位置的字符一一比较，串a小于串b，返回负数</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int compareTo(String anotherString) &#123;\n    int len1 &#x3D; value.length;\n    int len2 &#x3D; anotherString.value.length;\n    int lim &#x3D; Math.min(len1, len2);\n    char v1[] &#x3D; value;\n    char v2[] &#x3D; anotherString.value;\n\n    int k &#x3D; 0;\n    while (k &lt; lim) &#123;\n        char c1 &#x3D; v1[k];\n        char c2 &#x3D; v2[k];\n        if (c1 !&#x3D; c2) &#123;\n            return c1 - c2;\n        &#125;\n        k++;\n    &#125;\n    return len1 - len2;\n&#125;</code></pre></li>\n<li><p>substring()</p>\n<ol>\n<li><code>substring(int beginIndex, int endIndex)</code>方法截取并返回下标在[beginIndex, endIndex)范围内的子串</li>\n<li>在JDK7及其以上版本中，substring()方法会生成新的String对象来存储子串，但如果传入参数正好等于字符串的长度，那么会返回字符串本身，不会创建新对象</li>\n<li>在JDK6及以前的版本，通过substring()方法获取到的子串会共享char数组，并有count和offset属性标志子串的长度和起点</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-String的压缩技术\"><a href=\"#2-String的压缩技术\" class=\"headerlink\" title=\"2.String的压缩技术\"></a>2.String的压缩技术</h5><ol>\n<li>JDK8及之前的版本中，String类底层依赖char类型的数组来存储字符串，char类型存储的是UTF-16编码，一个字符2个字节，存储英文等ASCII码会比较浪费空间，因此JDK9中，Java对String类进行了优化，将char类型数组改为了byte类型</li>\n<li>新增了coder属性，有两个值，一个是LATIN1，所有Unicode编号小于等于127的每个字符用一个字节存储；另一个是UTF-16，和之前一样，一个字符用两个字节存储</li>\n<li>是否使用压缩存储方式，可以通过JVM参数设置</li>\n</ol>\n<h5 id=\"3-String的常量池技术\"><a href=\"#3-String的常量池技术\" class=\"headerlink\" title=\"3.String的常量池技术\"></a>3.String的常量池技术</h5><ol>\n<li><p>String类型跟Integer等包装类类似，使用常量池技术，并且只有使用字符串常量赋值时，才触发，如果字符串常量在常量池中已经创建过，则直接使用已经创建的对象。用new创建的对象不在常量池中</p>\n</li>\n<li><p>出了使用字符串常量赋值外，还可以使用intern()方法，将分配在堆上的String对象，原模原样在常量池中复制一份。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; &quot;abc&quot;;\nString s2 &#x3D; new String(&quot;abc&quot;);\nString s2 &#x3D; s2.intern();\n\nSystem.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;false\nSystem.out.println(s1&#x3D;&#x3D;s3);&#x2F;&#x2F;true\nSystem.out.println(s2&#x3D;&#x3D;s3);&#x2F;&#x2F;false</code></pre></li>\n<li><p>当无法用字符串常量赋值，但又有大量重复字符串时，就可以使用intern()方法复制到常量池中，代码中使用常量池中的String对象，原String对象就被JVM回收掉</p>\n</li>\n</ol>\n<h5 id=\"4-String的不可变性\"><a href=\"#4-String的不可变性\" class=\"headerlink\" title=\"4.String的不可变性\"></a>4.String的不可变性</h5><ol>\n<li>String类是不可变类，不可变的意思是：其对象在创建完成之后，所有的属性都不可以再被修改，包括引用类型变量所引用的对象的属性</li>\n<li>原因：<ol>\n<li>因为String类使用了常量池技术，有可能很多变量会引用同一个String对象。一个引用修改，别的引用也将获得新数据，不符合大部分业务开发需求</li>\n<li>字符串和整型数经常用来作为HashMap的键（key），如果之后数据改变了，此对象在HashMap的存储位置也需要改变，增加了编码的复杂度</li>\n<li>基本类型和包装类都是不可变的，String延续了他们的设计思路</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"5-StringBuilder\"><a href=\"#5-StringBuilder\" class=\"headerlink\" title=\"5.StringBuilder\"></a>5.StringBuilder</h5><ol>\n<li>因为String不可变，用+拼接效率低，每次都需要创建新的String对象，所以Java设计了StringBuilder</li>\n<li>StringBuilder支持修改和动态扩容，可以用append()函数拼接，可以把StringBuilder看作是char类型的ArrayList（ArrayList&lt;Character&gt;）</li>\n<li>在平时开发中，经常用+号连接多个字符串，实际上底层就采用StringBuilder来实现</li>\n</ol>\n<h3 id=\"3-引用类型\"><a href=\"#3-引用类型\" class=\"headerlink\" title=\"3.引用类型\"></a>3.引用类型</h3><h4 id=\"1-Java类型：基本类型-VS-引用类型\"><a href=\"#1-Java类型：基本类型-VS-引用类型\" class=\"headerlink\" title=\"1.Java类型：基本类型 VS 引用类型\"></a>1.Java类型：基本类型 VS 引用类型</h4><ol>\n<li><p>基本类型：整型（byte、short、int、long）、浮点型（float、double）、字符型（char）、布尔型（boolean）<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220425154922829-165468719667546-16566865818083.png\" alt=\"image-20220425154922829\"></p>\n</li>\n<li><p>引用类型：</p>\n<ol>\n<li><p>类、接口:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Group&#123;\n    public int grandNo;\n    public int classNo;\n    public Group(int grandNo, int classNo)&#123;\n        this.grandNo &#x3D; grandNo;\n        this.classNo &#x3D; classNo;\n    &#125;\n&#125;\n\npublic class Studnet&#123;\n    public int id;\n    public int age;\n    public Group group;\n    public Student(int id,int age)&#123;\n        this.id &#x3D; id;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        Student s &#x3D; new Student(1,3);\n        s.group &#x3D; new Group(2,3);\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220425155613179-165468719667647-16566865818084.png\" alt=\"image-20220425155613179\"></p>\n</li>\n<li><p>数组：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Student[][] arr &#x3D; new Student[3][];\n\narr[0] &#x3D; new Student[2];\narr[0][0] &#x3D; new Studnet(2,2);\n\narr[2] &#x3D; new Student[3];\narr[2][1] &#x3D; new Student(4,4);\narr[2][2] &#x3D; new Student(5,5);</code></pre>\n\n\n\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220425154637820-165468719667648-16566865818085.png\" alt=\"image-20220425154637820\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-参数传递：值传递-VS-引用传递\"><a href=\"#2-参数传递：值传递-VS-引用传递\" class=\"headerlink\" title=\"2.参数传递：值传递 VS 引用传递\"></a>2.参数传递：值传递 VS 引用传递</h4><ol>\n<li>基本参数类型：因为基本类型是存在栈上的，所以在函数调用时，调用函数和被调用函数不能取对方栈里的值，作为参数传递的值被重新赋值</li>\n<li>引用参数类型：因为引用类型是通过new创建的，是存储在堆上的，所以传递给被调用参数的是对象，直接更改对象对所有引用都可见，被调用函数只能改对象的属性，不能改变引用变量本身的值（也就是无法使得调用函数内的引用指向新的对象）</li>\n</ol>\n<h4 id=\"3-数据判等：等号-VS-equals-方法\"><a href=\"#3-数据判等：等号-VS-equals-方法\" class=\"headerlink\" title=\"3.数据判等：等号 VS equals()方法\"></a>3.数据判等：等号 VS equals()方法</h4><ol>\n<li><p>基本类型数据判等：直接使用==，即可判定两个变量的值是否相等，也就是判定两个变量对应的内存单元中存储的数据是否相等</p>\n</li>\n<li><p>引用数据类型判等：</p>\n<ol>\n<li><p>==判等：比较变量对应的内存单元中存储的值是否相等，对于引用来说，就是判定两个引用是否指向同一个对象</p>\n</li>\n<li><p>equals判等：如果没有重写Object类的equals方法，那么就跟使用等号判等一样，但重写之后的equals()判定的不再是对象的内存地址是否相等，而是对象的关键属性值是否相等。一般来说，重写equals()方法的同时，也要重写hashcode()方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Student&#123;\n    public int id;\n    public int age;\n    public Student(int id,int age)&#123;\n        this.id &#x3D; id;\n        this.age &#x3D; age;\n    &#125;\n    @Override\n    public boolean equals(Object obj)&#123;\n        if(obj instanceof Student)&#123;\n            Student stu &#x3D; (Student)obj;\n            return this.id &#x3D;&#x3D; stu.id;\n        &#125;\n        return false;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-访问安全：引用-VS-指针\"><a href=\"#4-访问安全：引用-VS-指针\" class=\"headerlink\" title=\"4.访问安全：引用 VS 指针\"></a>4.访问安全：引用 VS 指针</h4><ol>\n<li>Java摒弃C/C++中的指针语法，引入了引用语法，尽管指针和引用存储的都是被指或被引用的内存块的地址，但引用却比指针在使用上安全很多。</li>\n<li>为了方便编写底层的代码，C/C++赋予指针灵活的操作内存的能力，C/C++允许指针越界访问，允许指针做加减运算，允许指针嵌套（指针的指针），甚至允许指针将一块内存重新读为任意类型。因此对程序员编写代码的能力要求很高，稍有不慎就会引入bug，引发安全问题。</li>\n<li>Java语言设计的初衷就是简单易用， 所以权衡安全性和灵活性，Java摒弃了灵活的指针，设计了更加安全的引用，也可以叫做安全指针。引用时有限制的指针，没有了那么多酷炫的操作，Java中的引用只能引用对象或数组，并且不能进行加减运算，而且，强制类型转化也只能发生在有继承关系的类之间。</li>\n</ol>\n<h3 id=\"4-关键字\"><a href=\"#4-关键字\" class=\"headerlink\" title=\"4.关键字\"></a>4.关键字</h3><h4 id=\"1-关键字概览\"><a href=\"#1-关键字概览\" class=\"headerlink\" title=\"1.关键字概览\"></a>1.关键字概览</h4><ul>\n<li><p>访问修饰符：public(跨包)、protected(包内)、private(类内)</p>\n</li>\n<li><p>面向对象相关：import、package、new、class、enum、interface、abstract、implements、extends</p>\n</li>\n<li><p>修饰方法、类、属性和变量：static(静态变量)、final(常量)、super(调用父类方法)、this(调用当前类方法)、native(c代码)、synchronized(加锁)、==transient==、volatile（不可变）、strictfp(strict float point精确浮点)</p>\n</li>\n<li><p>数据类型：void、null、true、false</p>\n<ul>\n<li>整数类型：byte（字节型，8位）、short（短整型，16位）、int（整型，32位，<strong>默认</strong>）、long（长整型，64位，数后跟L标志位），==负数比正数多一个==</li>\n<li>浮点类型：float（单精度，4字节，数后跟f标志位）、double（双精度，8字节，<strong>默认</strong>），==float表示的数据范围比int大，见后==</li>\n<li>字符类型：char（2字节，16位，’\\u0000’ ~ ‘\\uFFFF’），==C/C++用1字节==</li>\n<li>布尔类型：boolean（1字节，true/false），==用8位是为了字节对齐和操作简单==</li>\n</ul>\n</li>\n<li><p>控制语句：if、else、switch、case、default、for、while、do、break、continue、return、instanceof（二元操作符、测试左边对象是否是右边对象的实例）</p>\n</li>\n<li><p>错误处理：try、catch、throw、throws、finally、assert</p>\n</li>\n</ul>\n<h4 id=\"2-语法糖\"><a href=\"#2-语法糖\" class=\"headerlink\" title=\"2.语法糖\"></a>2.语法糖</h4><ul>\n<li><strong>switch支持String与枚举</strong>：int比数、char比ascii码、字符串用hashCode()和equals()、</li>\n<li><strong>泛型和类型擦除</strong></li>\n<li><strong>自动装箱与拆箱</strong>：</li>\n<li><strong>方法变长参数</strong>：String… args用一个数组实现</li>\n<li><strong>枚举</strong>：当我们使用enmu来定义一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类继承Enum类，所以枚举类型不能被继承。</li>\n<li><strong>内部类</strong>：又称为嵌套类，可以把内部类理解为外部类的一个普通成员。</li>\n<li><strong>条件编译</strong>：if的条件是final且为false时，对应代码块不被编译</li>\n<li><strong>断言</strong>：其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行</li>\n<li><strong>数值字面量</strong>：不管是整数还是浮点数，都允许在数字之间插入任意多个下划线，为了方便阅读</li>\n<li><strong>增强for循环</strong>：for-each用了普通的for循环和Iterator迭代器的hasNext()方法</li>\n<li><strong>try-with-resource</strong>：在try()中写资源申请，就不用在finally中判断是否为null在关闭了</li>\n<li><strong>lambda表达式</strong>：只有一个函数的接口叫做函数式接口，可以用Lambda表达式简化</li>\n</ul>\n<h4 id=\"3-final\"><a href=\"#3-final\" class=\"headerlink\" title=\"3.final\"></a>3.final</h4><ol>\n<li><p>final修饰类：final类不可被继承</p>\n</li>\n<li><p>final修饰方法：final方法在子类中不可被重写，子类可以将父类的非final方法声明为final方法，早期会优化为内联函数，现在看情况</p>\n</li>\n<li><p>final修饰变量（常量）：final变量只被赋值一次，之后就不能再修改。final修饰的变量有三类：</p>\n<ol>\n<li>类的成员变量：有两种赋值方式，在成员变量声明时，或在构造函数中</li>\n<li>函数的局部变量：有两种赋值方式，在局部变量声明时，或在使用前赋值一次</li>\n<li>函数的参数：final修饰的变量既可以是基本类型变量，也可以是引用类型变量，对于引用型变量，final关键字只限制引用本身不可变，但引用变量所引用的对象的属性或者数组的s元素是可变的</li>\n</ol>\n</li>\n<li><p>final的应用场景：不可变类，以下展示了如何设计一个不可变类</p>\n<ol>\n<li><p>将类设置为final类，这样类就无法被继承，避免通过如下方式创建可变对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyString extends String&#123;\n    &#x2F;&#x2F;重写toCharArray()方法，让它直接返回value数组，这样就能更改value数组了\n    @Override\n    public char[] toCharArray()&#123;\n        return value;\n    &#125;\n&#125;\nString s &#x3D; new MyString(&quot;abc&quot;);\nchar[] chars &#x3D; s.toCharArray();\nchars[0] &#x3D; &#39;x&#39;;\nSystem.out.println(s);&#x2F;&#x2F;打印xab</code></pre></li>\n<li><p>将类中所有的属性设置为final，在创建对象时设置，之后不再允许修改。当然，如果能保证类中没有方法会改变这个属性的值，也可以不用将其设置为final，例如String类中的hash属性</p>\n</li>\n<li><p>通过方法返回属性，如果是引用类型的（数组或对象，如String类中的value数组），需要返回属性的副本而非本身。否则外部代码可以通过引用，修改返回对象中的属性或数组中元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public char[] toCharArray()&#123;\n    char result[] &#x3D; new char[value.length];&#x2F;&#x2F;副本\n    System.arraycopy(value,0,result,0,value.length);\n    return result;&#x2F;&#x2F;返回副本\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-static\"><a href=\"#4-static\" class=\"headerlink\" title=\"4.static\"></a>4.static</h4><ol>\n<li><p>static变量</p>\n<ol>\n<li><p>static只能修饰类的成员变量（静态变量），静态变量隶属于类，为类的所有对象所共享存储，静态变量跟类的代码一起存储在方法区</p>\n</li>\n<li><p>对于静态变量，既可以通过类来访问，也可以通过对象来访问</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Obj&#123;\n    public static int objCount &#x3D; 0;\n    public Obj()&#123;\n        objCount++;\n    &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        Obj o1 &#x3D; new Obj();\n        Obj o2 &#x3D; new Obj();\n        System.out.println(Obj.objCount);&#x2F;&#x2F;打印2\n        System.out.println(o1.objCount);&#x2F;&#x2F;打印2\n    &#125;\n&#125;</code></pre></li>\n<li><p>static和final一起修饰的变量叫做静态常量，对于一些跟具体对象无关，又不会改变的常量数据，一般使用静态常量来存储。静态常量命名比较特殊，所有字母都大写</p>\n</li>\n</ol>\n</li>\n<li><p>static方法</p>\n<ol>\n<li>静态方法属于类而非对象，所以可以在不创建对象的情况下，调用静态方法。所以很多工具类中的方法都设计为静态方法，比如Math类，Collections类中的方法</li>\n<li>==注意==：静态方法只能访问静态成员变量，以及调用类中的其它静态方法，静态方法不能访问类中的非静态成员变量，也不能调用类中的非静态方法。反过来，类中的非静态方法可以访问类中的静态变量和静态方法。因为对象可以使用类的数据，但类不能使用具体某个对象的数据</li>\n</ol>\n</li>\n<li><p>static代码块：对于某些静态成员变量，如果初始化无法通过一个简单的赋值语句来完成，可以将静态成员变量的初始化逻辑放入static修饰的代码块中，静态代码块是在类加载时执行的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ParserFactory&#123;\n    private static Map&lt;String,Parser&gt; parsers &#x3D; new HashMap&lt;&gt;();\n    static&#123;\n        parsers.put(&quot;json&quot;,new JSONParser());\n        parsers.put(&quot;xml&quot;,new XMLParser());\n        parsers.put(&quot;yaml&quot;,new YAMLParser());\n    &#125;\n    &#x2F;&#x2F;省略其他方法和属性\n&#125;</code></pre></li>\n<li><p>static嵌套类</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>static只能修饰嵌套类，也叫做内部类，内部类在编译成字节码之后，会独立于外部类，生成一个新的class文件，命名方式为：外部类名$内部类名.class，对于匿名内部类，因为内部类没有名字，所以命名方式为：外部类名$[序号].class。其中序号表示此内部类是外部类的第几个匿名内部类</p></blockquote>\n<ol>\n<li><p>普通内部类</p>\n<ol>\n<li><p>例如ArrayList类中定义了一个内部类Itr,负责遍历ArrayList容器中的元素，Itr类独自属于ArrayList类，其他类不会用到它，这样代码的可读性和可维护性好，更加满足封装原则</p>\n</li>\n<li><p>private内部类对除外部类之外的代码不可见，如果想在除了外部类之外的代码中使用内部类，要不将内部类设置为public，要么让内部类实现一个外部的接口，外部代码使用接口来访问内部类的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface I&#123;&#125;\npublic class A&#123;\n    private class B&#123;&#125;\n    private class C implements I&#123;&#125;&#x2F;&#x2F;实现外部接口的内部类\n    public class D&#123;&#125;&#x2F;&#x2F;public修饰的内部类\n    \n    public B getB()&#123;\n        return new B();\n    &#125;\n    public I getC()&#123;\n        return new C();\n    &#125;\n    public D getD()&#123;\n        return new D();\n    &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.B b &#x3D; a.getB();&#x2F;&#x2F;编译报错\n        I c &#x3D; a.getC();\n        A.D d1 &#x3D; a.getD();\n        A.D d2 &#x3D; a.new D();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>静态内部类</p>\n<ol>\n<li><p>静态内部类和普通内部类主要区别有三个：</p>\n<ul>\n<li><p>在访问权限上，内部类跟外部类中的方法具有相同的访问权限。也就是说，静态内部类跟静态方法一样，只能访问外部类的静态变量和静态方法，而普通内部类可以访问外部类的所有变量和所有方法</p>\n</li>\n<li><p>静态内部类可以包含静态变量和静态方法，而普通内部类不行，不过在JDK16中，普通内部类也可以包含静态变量和静态方法了</p>\n</li>\n<li><p>如果要创建普通内部类的对象，需要先创建外部类的对象，而静态内部类的对象可以独立于外部类单独创建</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class A&#123;\n    public class D&#123;&#125;\n    public static class E&#123;&#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.D d &#x3D; a.new D();\n        A.E e &#x3D; new A.E();\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>匿名类</p>\n<ol>\n<li><p>在线程开发中，我们会经常用到匿名内部类，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Thread t &#x3D; new Thread(new Runnable()&#123;\n    @Override\n    public void run()&#123;\n        System.out.println(&quot;hello&quot;)\n    &#125;\n&#125;);\nt.start();</code></pre></li>\n<li><p>匿名内部类跟定义它的外部函数，具有相同的访问权限，如果外部函数是静态函数，那么匿名内部类只能访问外部类的静态成员变量和静态函数；如果外部函数是普通函数，那么访问内部类可以访问外部类的任何成员变量和成员函数，包括private修饰的成员变量和成员函数。除此之外，匿名内部类还可以访问外部函数的final局部变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private static int a &#x3D; 1;\n  private int b &#x3D; 2;\n  private static void f()&#123;&#125;\n  private void g()&#123;&#125;\n  public static void main(String[] args)&#123;\n    final int c &#x3D; 3;\n    int d &#x3D; 4;\n\n    Thread t &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        a+&#x3D;1;s\n        b+&#x3D; 3;&#x2F;&#x2F;编译报错，非静态成员变量\n        int y &#x3D; c+1;\n        int x &#x3D; d+2;&#x2F;&#x2F;编译报错，非final局部变量\n        f();\n        g();&#x2F;&#x2F;编译报错，非静态成员函数\n      &#125;\n    &#125;);\n    t.start();\n    d &#x3D; 3\n  &#125;\n&#125;</code></pre></li>\n<li><p>为什么非final局部变量不能被匿名函数访问：因为外部函数通过类似参数传递的方式，将局部变量传递给匿名内部类来使用，前面讲过，java的参数传递的是值传递。匿名内部类对参数（相当于局部变量的副本）进行修改，不会改变局部变量本身的值。在程序员看来，明明在匿名类中修改了局部变量的值，却没有生效，不符合直觉认知，所以在设计上，只允许匿名内部类访问final修饰的局部变量。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ICallable&#123;\n    void add();\n&#125;\npublic class Demo&#123;\n    public void test()&#123;\n        int a &#x3D; 1;\n        ICallable callback &#x3D; new ICallable()&#123;\n            @Override\n            public void add()&#123;\n                a++;\n                System.out.println(a);&#x2F;&#x2F;打印2\n            &#125;\n        &#125;\n        System.out.println(a);&#x2F;&#x2F;被修改了，但却仍然打印1\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>例题：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220511145110266-165468719667655-165668658181012.png\" alt=\"image-20220511145110266\"> <img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220511145139512-165468719667656-165668658181013.png\" alt=\"image-20220511145139512\"></p>\n</li>\n</ol>\n<h3 id=\"5-类和对象\"><a href=\"#5-类和对象\" class=\"headerlink\" title=\"5.类和对象\"></a>5.类和对象</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> Java对象在内存中的存储结构包含三部分：对象头（Header）、实例数据（Instance）、对其填充（Padding）。可以使用JOL工具来查看对象的内存结构</p></blockquote>\n<h4 id=\"1-对象头\"><a href=\"#1-对象头\" class=\"headerlink\" title=\"1.对象头\"></a>1.对象头</h4><p>​        对象头又包含：标记字、类指针、数组长度（有数组时）</p>\n<ol>\n<li>标记字（Mark Word）：在32位JVM中占4字节长度，其存储对象在运行过程中的一些信息，例如：GC分代年龄（age）、锁标志位（lock）、是否偏向锁（biased_lock）、线程ID（thread）、时间戳（epoch）、哈希值（hashcode）等。其中大部分信息都用于多线程和JVM垃圾回收</li>\n<li>类指针（C++指针）：对象所属的类的信息存储在方法区，为了知道某个对象的类信息，对象头中存储了类指针，指向方法区中的类信息，即对应类信息在方法区中的内存地址</li>\n<li>数组长度：在JVM实现数组时，JVM将数组作为一种特殊的对象来看待，其内存存储结构跟普通对象几乎一样，唯一的区别是数组的对象头中多了数组长度这样一个字段，无论是32位还是64位，此字段都占4字节长度。由此可知Java中可以申请的数组的最大长度位2^32-1</li>\n</ol>\n<h4 id=\"2-实例数据\"><a href=\"#2-实例数据\" class=\"headerlink\" title=\"2.实例数据\"></a>2.实例数据</h4><ol>\n<li><p>实例对象存储的是对象里的非静态成员变量，可以是基本类型，也可以是引用类型，而非对象，所以静态变量并非存储在对象中，在64位JVM中，各个类型的字节长度为：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>字节大小</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>double</td>\n<td>8</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n</tr>\n<tr>\n<td>char</td>\n<td>2</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>1</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>1</td>\n</tr>\n<tr>\n<td>引用</td>\n<td>8</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>在内存，每个属性存储的内存地址，必须是自身字节长度的倍数，比如：long型、int型、char型属性的内存地址必须分别是8、4、2的倍数，如果不是，需要补齐。这样的存储要求叫做“字节对齐”，补齐的方式叫做“字节填充”。</p>\n</li>\n<li><p>对象中的属性并非按照定义的顺序存储，而是依据如下规则：</p>\n<ol>\n<li>先存储父类的属性，在存储子类的属性</li>\n<li>类中的属性默认按照如下先后顺序来存储：double/long、float/int、short/char、byte/boolean、object referece，此顺序受JVM参数-XX:FieldsAllocationStyle影响，不过高版本被废弃默认是这个顺序</li>\n<li>任何属性的存储地址是按照类型的字节长度，进行字节对齐和填充，比如：long类型的属性的存储地址按8字节对齐，不足的补齐，对象整体按照8字节对齐和填充</li>\n<li>父类的属性和子类的属性之间4字节对齐，不足4字节的补齐4字节</li>\n<li>在应用规则4之后，父类的属性和子类的属性之间仍有间隙（子类有8字节属性，所以父类属性和子类属性之间要填充4字节，才能8字节对齐），我们将子类属性按照float/int、short/char、byte/boolean、object referece的顺序，依次拿来填充间隙，直到间隙填充满或无法继续填充为止。同理，如果在对象头和类的属性之间有间隙，我们同样应用此规则进行填充，此规则受JVM参数-XX:CompactFields的影响，默认为true。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-对齐填充\"><a href=\"#3-对齐填充\" class=\"headerlink\" title=\"3.对齐填充\"></a>3.对齐填充</h4><ol>\n<li>进行字节对齐和对齐填充的原因：CPU按照字（Word）为单位从内存中读取数据，对于64位的CPU，字的大小位8字节，也就是说，内存以8字节为单位，切分为很多快，CPU每次读取一块内存</li>\n<li>为了避免CPU缓存的伪共享，程序员会手动进行64字节或128字节对齐，见多线程</li>\n</ol>\n<h4 id=\"4-压缩类指针和引用\"><a href=\"#4-压缩类指针和引用\" class=\"headerlink\" title=\"4.压缩类指针和引用\"></a>4.压缩类指针和引用</h4><ol>\n<li>类指针压缩：<code>-XX:+UseCompressedClassPointers</code>参数打开后，类指针为4字节大小</li>\n<li>引用压缩：<code>-XX:+UseCompressedOops</code>参数打开后，引用为4字节大小</li>\n<li>如何把8字节的地址压缩为4字节，以引用类型为例：<ol>\n<li>4字节可以寻址的内存大小为2^32个字节，即4GB；如果设置的堆大小超过4GB，有些对象的地址就无法在引用类型属性中存储了</li>\n<li>对齐填充中对象是按照8字节对其的，也就是说，对象的首地址是8的倍数，表示成二进制之后，后三位都是0，所以32位二进制可以存储长度为35个二进制的地址，即32GB</li>\n<li>以此类推，通过增加对象对齐的字节数，可以扩大表示范围，可以使用-XX:ObjectAlignmentInBytes参数配置对象的对其长度，参数取值范围为[8，256]，最大可以设置的堆大小为4GB*此参数值</li>\n</ol>\n</li>\n<li>为什么要压缩引用和指针：<ol>\n<li>在编程中，我么会频繁地使用引用类型，在64位JVM中，将其压缩至4字节，可以大大节省存储空间</li>\n<li>Java之所以在有Integer等包装类的情况下，仍然引入int等基本类型，其中一个重要原因就是节省内存，例如：一个int数据占据4字节内存，一个Integer对象，对象头8字节+类指针4字节=12字节，然后加上仅有的int类型属性，总共占据16字节，所以使用基本类型比包装类型节省大量内存空间。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-容器\"><a href=\"#6-容器\" class=\"headerlink\" title=\"6.容器\"></a>6.容器</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221230181735755.png\" alt=\"image-20221230181735755\"></p>\n<h4 id=\"1-JCF\"><a href=\"#1-JCF\" class=\"headerlink\" title=\"1.JCF\"></a>1.JCF</h4><ol>\n<li><p>Java的JCF（Java Collections Framework）类似于C++的STL（Standard Template Library）</p>\n</li>\n<li><p>概览图：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220514092226570-165468719667657-165668658181014.png\" alt=\"image-20220514092226570\"></p>\n</li>\n<li><p>将JCF中的容器分为5类：</p>\n<ol>\n<li>List（列表）：ArrayList、LinkedList、<del>Vector</del>（废弃）</li>\n<li>Stack（栈）：<del>Stack</del>（废弃）</li>\n<li>Queue（队列）：ArrayDeque、LinkedList、PriorityQueue</li>\n<li>Set（集合）：HashSet、LinkedHashSet、TreeSet</li>\n<li>Map（映射）：HashMap、LinkedHashMap、TreeMap、<del>HashTable</del>（废弃）</li>\n</ol>\n</li>\n<li><p>继承与实现关系</p>\n<ol>\n<li>实现相同的接口是为了方便在开发中替换不同的实现类</li>\n<li>继承同样的抽象类是为了避免重复编写代码，通过抽象类来存放这些公共的代码</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-List\"><a href=\"#2-List\" class=\"headerlink\" title=\"2.List\"></a>2.List</h4><ol>\n<li><p>ArrayList：底层依赖可扩容的数组，即可以动态扩容，</p>\n</li>\n<li><p>LinkedList：底层依赖的数据结构为双向链表，并且有头尾指针</p>\n</li>\n<li><p>Vector：Vector是线程安全的ArrayList，模仿的是C++STL中的Vector，为了更符合程序员的开发习惯，JCF将线程安全容器和非线程安全容器分开来设计。在非多线程环境下，使用没加锁的ArrayList替代Vector，性能更高。对于多线程环境，我们可以使用Collections工具类提供的synchronizedList方法，或者使用JUC（java.util.concurrent）提供的CopyOnWriteArrayList。（详见多线程）</p>\n</li>\n<li><p>Stack：Stack同Vector一样，也是JDK1.0d的产物，继承自Vector，不推荐使用，取而代之，我们可以使用Deque双端队列来模拟栈</p>\n</li>\n</ol>\n<h4 id=\"4-Queue\"><a href=\"#4-Queue\" class=\"headerlink\" title=\"4.Queue\"></a>4.Queue</h4><ol>\n<li><p>Deque</p>\n<ol>\n<li>ArrayDeque是基于数组实现的队列</li>\n<li>LinkedList是基于链表实现的队列，LinkedList在实现中实现了Deque接口</li>\n</ol>\n</li>\n<li><p>PriorityQueue</p>\n<ol>\n<li><p>底层依赖堆来实现，默认情况下为小顶堆，最先出队列的为当前队列中的最小值，可以通过<code>Comparator</code>接口的匿名类对象来改变优先级队列的实现方式。</p>\n</li>\n<li><p>堆的构建过程，需要比较节点中数据的大小，所以，添加到优先级队列中的元素，需要能够比较大小，方法有两种：基于<code>Comparable</code>接口和基于<code>Comparator</code>接口，都有时则优先使用<code>comparator</code>，详见<code>siftUp</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;不管是使用Comparable的o1.compareTo(o2)方法，还是使用Comparator的compare(o1，o2)方法\n&#x2F;&#x2F;o1小于o2时都返回负数，o1等于o2时都返回0，o1大于o2时都返回正数\npublic interface Comparable&lt;T&gt;&#123;\n    public int compareTo(T o);\n&#125;\npublic interface Comparator&lt;T&gt;&#123;\n    int compare(T o1,T o2);\n&#125;\n&#x2F;&#x2F;实现comparable接口，表示类是可比较的，写死在类中\npublic class Person1 implements Comparable&lt;Person1&gt;&#123;\n    private int age;\n    private String name;\n\n    public Person1(String name, int age)&#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n    @Override\n    public int compareTo(Person1 o)&#123;\n        return this.age-o.age;\n    &#125;\n&#125;\nPriorityQueue&lt;Person1&gt; p &#x3D; new PriorityQueue&lt;&gt;();\n&#x2F;&#x2F;使用comparator灵活定义优先级，是一种比较器工具，后续可更改\npublic final class Person2&#123;\n    private int age;\n    private String name;\n\n    public Person2(String name, int age)&#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n&#x2F;&#x2F;匿名类对象\nPriorityQueue&lt;Person2&gt; p &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;Person2&gt;()&#123;\n    @Override\n    public int compare(Person2 o1, Person2 o2)\n    &#123;\n        if(o1 &#x3D;&#x3D; null || o2 &#x3D;&#x3D; null)\n            return 0;\n        return o1.getAge()-o2.getAge();\n    &#125;\n&#125;);</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-Set\"><a href=\"#5-Set\" class=\"headerlink\" title=\"5.Set\"></a>5.Set</h4><ol>\n<li><p>Set容器跟List容器都可以用来存储一组数据，不同的地方在于：List容器中有下标的概念，不同下标对应的位置可以存储相同的数据，而Set容器没有下标的概念，不允许存储相同的数据</p>\n</li>\n<li><p>Set容器包括HashSet、LinkedHashSet、TreeSet，从代码实现上来说，这三个类底层分别是依赖HashMap、LinkedHashMap、TreeMap。例如：往HashSet中存储对象obj，底层将obj作为key，一个空的Object对象作为value，一并存储到HashMap中，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;\n    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable\n&#123;\n    &#x2F;&#x2F;数据存储在这个Map中\n    private transient NavigableMap&lt;E,Object&gt; m;\n    &#x2F;&#x2F;存储在Map中的默认value值\n    private static final Object PRESENT &#x3D; new Object();\n    \n    public TreeSet() &#123;\n        this(new TreeMap&lt;E,Object&gt;());\n    &#125;\n    \n    public boolean contains(Object o) &#123;\n        return m.containsKey(o);\n    &#125;\n\n    public boolean add(E e) &#123;\n        return m.put(e, PRESENT)&#x3D;&#x3D;null;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"6-Map\"><a href=\"#6-Map\" class=\"headerlink\" title=\"6.Map\"></a>6.Map</h4><ol>\n<li>Map容器包括HashMap、LinkedHashMap和TreeMap，跟Set容器类似，Map容器也不存储重复的键，其中HashMap和LinkedHashMap的底层原理见后两节</li>\n<li>TreeMap<ol>\n<li>TreeMap是基于红黑树来实现的，TreeMap基于键值对的键来构建红黑树，值作为卫星数据，附属在红黑树的中</li>\n<li>在使用TreeMap时，要么键值对中的键实现 Comparable接口，要么在构建TreeMap时传入Comparator接口的匿名类对象</li>\n<li>TreeMap直接实现的接口时SortedMap，而非Map，这是因为TreeMap底层依赖红黑树来实现，其中中序遍历的结构是有序的，因此，相对于基于哈希表实现的HashMap，TreeMap可以提供更多丰富的功能，比如查看最大键、最小键值、大于某个值的键值、有序输出所有的键值等等，这些操作都定义在SortedMap接口中</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-1-HashMap\"><a href=\"#6-1-HashMap\" class=\"headerlink\" title=\"6-1.HashMap\"></a>6-1.HashMap</h4><h5 id=\"1-基本原理\"><a href=\"#1-基本原理\" class=\"headerlink\" title=\"1.基本原理\"></a>1.基本原理</h5><ol>\n<li><p>HashMap容器实现了接口Map，是一个映射，通过key快速获取value，key与value具有一一映射关系，HashMap中的key不能重复，但value可以重复，存储重复的key，后面存储的value会覆盖前面的value</p>\n</li>\n<li><p>HashMap容器是基于哈希表实现的，对key计算哈希值，并将key和value包裹为一个对象，存储在哈希表中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n    final int hash;\n    final K key;\n    V value;\n    Node&lt;K,V&gt; next;\n\n    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n        this.hash &#x3D; hash;\n        this.key &#x3D; key;\n        this.value &#x3D; value;\n        this.next &#x3D; next;\n    &#125;\n    &#x2F;&#x2F;省略getter、setter等方法\n&#125;\n&#x2F;&#x2F;哈希表\ntransient Node&lt;K,V&gt;[] table;</code></pre></li>\n<li><p>HashMap通过链表法来解决哈希冲突，table数组用来存放链表，Node类便是链表中节点的定义，其中的hash值由key通过哈希函数计算得到，起到缓冲作用，在查询元素时，用此值做预判，详见哈希函数，冲突情况见下图</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221130212338801.png\" alt=\"image-20221130212338801\"></p>\n</li>\n</ol>\n<h5 id=\"2-哈希函数\"><a href=\"#2-哈希函数\" class=\"headerlink\" title=\"2.哈希函数\"></a>2.哈希函数</h5><ol>\n<li><p>HashMap中的哈希函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final int hash(Object key) &#123;\n    int h;\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n&#x2F;&#x2F;因为得到的哈希范围往往会超过table数组长度n，因此，需要跟n取模，n默认为16\n&#x2F;&#x2F;因为取模操作比较耗时，所以用位运算实现取模运算，如下所示\nint index &#x3D; hash(key)&amp;(n-1); &#x2F;&#x2F; 插入数组时选择的位置</code></pre>\n\n<ol>\n<li><p>key的hashCode()函数：hashCode()函数定义在Object类中，根据对象在内存中的地址来计算哈希值，也可以在Object的子类中重写hashCode()函数，</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Integer的hashCode()函数\npublic int hashCode() &#123;\n    return Integer.hashCode(value);\n&#125;\n&#x2F;&#x2F;String类的hashCode()函数\npublic int hashCode() &#123;\n    int h &#x3D; hash;\n    if (h &#x3D;&#x3D; 0 &amp;&amp; value.length &gt; 0) &#123;\n        char val[] &#x3D; value;\n\n        for (int i &#x3D; 0; i &lt; value.length; i++) &#123;\n            h &#x3D; 31 * h + val[i];\n        &#125;\n        hash &#x3D; h;\n    &#125;\n    return h;\n&#125;</code></pre></li>\n<li><p>h^(h&gt;&gt;&gt;16)：在hash()函数中，不直接返回h的原因是因为，一般来说，table数组的大小n不会很大，一般会小于2^16（65536），而hashCode()函数的返回值h为int类型，长度为4个字节，在计算key对用的数组下标时，h跟n取模后，h的高16位消息将会丢失，相当于只使用了h的后16位信息，理论上来讲，参与运算的信息越多，得到的数组下标越随机，所以将hashCode()函数的返回值h与其高16位异或，这样所有的信息都没有浪费</p>\n</li>\n<li><p>取模h&amp;(n-1)：之所以可以用这种方法来实现取模运算，有一个前提是：HashMap中table数组的大小n为2的幂次方，例如2^4，将其减一之后的二进制串为11111，跟h求与，相当于取模操作</p>\n</li>\n<li><p>key可为null值：从hash()函数中，可以发现，值为null的key的哈希值为0，对应数组下标为0，所以，值为null的key也可以存储在HashMap中，不过，一个HashMap容器只能存储一个值为null的key</p>\n</li>\n</ol>\n</li>\n<li><p>hash属性：hash属性存储的是key的哈希值，这个值作用是预判、提高查询速度，避免重复计算</p>\n<ol>\n<li>当调用get(xkey)函数查询xkey的xvalue时，HashMap容器先通过hash(xkey)函数计算得到xkey的哈希值，假设为xhash，xhash跟table数组大小n取模，得到数组下标xindex，也就说明x应该出现在table[xindex]对应的链表中</li>\n<li>遍历table[xindex]所对应的链表，查找xkey对应的节点，当遍历到每个node节点之后，首先会拿出node.hash，与x的哈希值xhash比较，如果不相等，则继续比较下一节点</li>\n<li>如果相等，因为存在hash冲突，所以还需要再调用equls()方法，比较node.key和xkey是否真的想等</li>\n<li>因为hash的比较为整数比较(==)，key的比较为对象的比较(equals())，所以前者效率更高，可以提高查询速度</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);\n        &#125;\n    &#125;\n    return null;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-装载因子\"><a href=\"#3-装载因子\" class=\"headerlink\" title=\"3.装载因子\"></a>3.装载因子</h5><ol>\n<li><p>JCF提供的容器都支持动态扩容，HashMap的扩容主要由table数组的大小(n，默认16)和装载因子(loadFactor，默认0.75)决定，当HashMap容器中的元素个数超过n*loadFactor时，就会触发扩容，其中n*loadFactor再HashMap类中定义为属性threshold。n和loadFactor可以用默认的也可以通过构造函数传入</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public HashMap(int initialCapacity, float loadFactor) &#123;\n    if (initialCapacity &lt; 0)\n        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                           initialCapacity);\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity &#x3D; MAXIMUM_CAPACITY;\n    if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                           loadFactor);\n    this.loadFactor &#x3D; loadFactor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);\n&#125;</code></pre></li>\n<li><p>前面提到，为了方便是用位运算来实现取模运算，table数组的大小必须是2的幂次方，如果自定义的不是，则需要tableSizeFor()函数，它会寻找比initialCapacity大的第一个2的幂次方数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final int tableSizeFor(int cap) &#123;\n    int n &#x3D; cap - 1;\n    n |&#x3D; n &gt;&gt;&gt; 1;\n    n |&#x3D; n &gt;&gt;&gt; 2;\n    n |&#x3D; n &gt;&gt;&gt; 4;\n    n |&#x3D; n &gt;&gt;&gt; 8;\n    n |&#x3D; n &gt;&gt;&gt; 16;\n    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n&#125;</code></pre></li>\n<li><p>将<code>tableSizeFor(initialCapacity)</code>直接赋值给<code>threshold</code>的原因：在创建HashMap对象时，table数组只声明未创建，其值为null，只有当第一次调用put()函数时，table数组才会被创建，但是，HashMap并没有定义表示table数组大小的属性，于是，tableSizeFor(initialCapacity)的值暂存在threshold属性中，当真正要创建table数组时，HashMap会先用threshold作为数组大小创建table数组，再将其重新赋值为真正的扩容阈值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">this.table &#x3D; new T[this.threshold];\nthis.threshold *&#x3D; this.factor;</code></pre></li>\n<li><p>一般不改变装载因子，但若更关注时间效率，则可以适当减小装载因子，哈希冲突的概率会更小，链表长度更短；若更关注空间效率，则可以适当增大装载因子，table数组中的空闲空间就更少，不过，这也会导致冲突概率更大，链表长度更长，增删改查以及扩容都会变慢</p>\n</li>\n<li><p>装载因子是0.75的原因：</p>\n<ul>\n<li>权衡时间效率和空间效率之后的结果</li>\n<li>大概是[0.5,1]之间，因为小于0.5会有一半空间从来未用，当大于1时，哈希冲突的概率会大大增加，即使有链表和树化，也会影响性能</li>\n<li>因为table数组的大小n都是2的倍数，而且触发扩容的阈值threshold = n * loadfactor，所以，在[0.5,1]之间，只有0.75能使得得到的阈值一直是整数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* &lt;p&gt;As a general rule, the default load factor (.75) offers a good\n* tradeoff between time and space costs.  Higher values decrease the\n* space overhead but increase the lookup cost (reflected in most of\n* the operations of the &lt;tt&gt;HashMap&lt;&#x2F;tt&gt; class, including\n* &lt;tt&gt;get&lt;&#x2F;tt&gt; and &lt;tt&gt;put&lt;&#x2F;tt&gt;).  The expected number of entries in\n* the map and its load factor should be taken into account when\n* setting its initial capacity, so as to minimize the number of\n* rehash operations.  If the initial capacity is greater than the\n* maximum number of entries divided by the load factor, no rehash\n* operations will ever occur.\n*&#x2F;</code></pre></li>\n</ol>\n<h5 id=\"4-动态扩容\"><a href=\"#4-动态扩容\" class=\"headerlink\" title=\"4.动态扩容\"></a>4.动态扩容</h5><ol>\n<li><p>当我们调用put()函数往HashMap容器中添加键值对时，在添加完成后，会判断容器中键值对的个数时候超过threshold，如果超过则触发动态扩容，申请一个新的table[]数组，大小为原table数组的2倍，并将原table数组中的节点，一个一个的搬移到新的table[]数组中。</p>\n</li>\n<li><p>扩容会逐一处理table数组中的每条链表，当由红黑树时，跟链表的处理方式类似</p>\n<ol>\n<li><p>因为容量变大，位置会发生变化，将每个节点的hash值与新的容量取模，取模操作仍可以用位运算来替代，但JDK8中优化为：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221130212436476.png\" alt=\"image-20221130212436476\"></p>\n</li>\n<li><p>扫描table数组中的每一条链表，根据节点的下标是否更改，将链表中的节点分配到lo链表和hi链表，lo链表中存储的是下标值未变的节点，hi链表存储的是下标值有所改变的节点。处理完一条链表后，将lo链表和hi链表分别存储到新的table数组中的对应位置。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;使用resize创建新table\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null) &#x2F;&#x2F;数组中链表头不存在，初始化\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123; &#x2F;&#x2F;数组中插入位置有链表头，遍历\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;先检查第一个节点\n            e &#x3D; p; &#x2F;&#x2F;找到\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;没找到，新建节点\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F;树化？\n                    break;\n                &#125;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#x2F;&#x2F;找到\n                    break;\n                p &#x3D; e;&#x2F;&#x2F;继续遍历\n            &#125;\n        &#125;\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;&#x2F;&#x2F;更新值\n            afterNodeAccess(e);&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions？？？\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);&#x2F;&#x2F; Callbacks to allow LinkedHashMap post-actions？？？\n    return null;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"5-链表树化\"><a href=\"#5-链表树化\" class=\"headerlink\" title=\"5.链表树化\"></a>5.链表树化</h5><ol>\n<li><p>尽管我们可以通过装载因子，限制HashMap容器中不会装载太多的键值对，但只能限制平均链表长度，对于单个链表的长度，我们无法限制，当链表长度过长时，HashMap上的增删改查都会变慢，针对这种情况，JDK8做了优化，当某个链表中的节点个数大于等于8（此值定义在HashMap类的TREEIFY_THRESHOLD静态常量中），并且table数组的大小大于等于64时，将会把链表转化为红黑树，这个过程就叫treeify（树化）。</p>\n</li>\n<li><p>但是如果table数组长度小于64，即便链表中的节点个数大于等于8，也不会触发treeify，而是触发扩容操作，试图通过扩容长链表拆分为短链表，因为小数据量的情况下，扩容要比treeify更简单，更省时间。</p>\n</li>\n<li><p>当红黑树中节点个数比较少时，HashMap会再将其转换回链表，因为维护红黑树的成本比较高，对于少许节点，使用链表存储更高效，红黑树转换为链表的过程，叫做untreeify，促发untreeify的场景有两个，一个是删除键值对时，另一个是扩容时。</p>\n<ol>\n<li><p>在删除键值对时，如果红黑树满足以下结构，则会触发untreeify，这个结构的红黑树的节点个数应该处于[2,6]之间，尽管treeify的阈值是8，但untreeify的阈值是[2,6]之间的某个数，之所以不相等是为了避免频繁的插入删除操作，导致节点个数在7，8之间频繁波动</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;removeTreeNode函数中\nif (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||\n    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;\n    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small\n    return;\n&#125;</code></pre></li>\n<li><p>在扩容时，每一条链表都会分割为lo和hi两条，同理红黑树也会分割为lt和ht两个红黑树，lt中存储的是下标位置不变的节点，ht中存储的是下标位置变化的节点。不过，我们在构建lt和ht之前，会先统计属于lt和ht的节点个数lc和hc，如果lc小于等于6（此值定义在HashMap类的UNTREEIFY_THRESHOLD静态常量中），在新的table数组中，HashMap会使用链表来存储下标不变的节点，同理，如果hc小于等于6，在新的table数组中，HashMap会使用链表来存储下标改变的节点。</p>\n</li>\n</ol>\n</li>\n<li><p>链表树化阈值为什么是8：</p>\n<ol>\n<li><p>装在因子限定的是链表的平均长度，用来保证HashMap的整体性能，链表树化限定的是链表长度的最大值，用来保证HashMap的最差情况下的性能。</p>\n</li>\n<li><p>通过泊松分布：入为事件发生的平均次数，k为想要得到发生概率的次数。链表的平均长度为0.5，带入到公式中，并将k赋值为0、1、2…8，得到对应发生的概率值，8的概率为千万分之六，发生的概率已经足够低了，所以选择8作为链表树化的阈值。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220520090714341-165468719667760-165668658181117.png\" alt=\"image-20220520090714341\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-2-LinkedHashMap\"><a href=\"#6-2-LinkedHashMap\" class=\"headerlink\" title=\"6-2.LinkedHashMap\"></a>6-2.LinkedHashMap</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>HashMap的增强版，既能实现快速的增删改查操作，又能实现容器内的有序遍历</p></blockquote>\n<h5 id=\"1-整体结构\"><a href=\"#1-整体结构\" class=\"headerlink\" title=\"1.整体结构\"></a>1.整体结构</h5><ol>\n<li><p>哈希表+双向有序链表</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;\n    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n        Entry&lt;K,V&gt; before, after;\n        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n            super(hash, key, value, next);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;双向链表的头指针和尾指针\n    transient LinkedHashMap.Entry&lt;K,V&gt; head;\n    transient LinkedHashMap.Entry&lt;K,V&gt; tail;\n    &#x2F;**\n     * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;&#x2F;tt&gt;\n     * for access-order（访问顺序）, &lt;tt&gt;false&lt;&#x2F;tt&gt; for insertion-order（插入顺\n     * 序）.\n     *&#x2F;\n    final boolean accessOrder;\n    &#x2F;&#x2F;键和值不再包裹为Node节点，而是包裹为Entry节点\n    &#x2F;&#x2F;next用来将节点串联在table数组的链表中，before和after用来串联双向链表\n    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;\n        Entry&lt;K,V&gt; before, after;\n        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;\n            super(hash, key, value, next);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>示例：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221130212532240.png\" alt=\"image-20221130212532240\"></p>\n</li>\n</ol>\n<h5 id=\"2-entrySet\"><a href=\"#2-entrySet\" class=\"headerlink\" title=\"2.entrySet()\"></a>2.entrySet()</h5><ol>\n<li><p>在Map接口中，定义了三个方法来返回内部数据：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;\n    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;\n    return (es &#x3D; entrySet) &#x3D;&#x3D; null ? \n        (entrySet &#x3D; new LinkedEntrySet()) : es;\n&#125;\npublic Set&lt;K&gt; keySet() &#123;\n    Set&lt;K&gt; ks &#x3D; keySet;\n    if (ks &#x3D;&#x3D; null) &#123;\n        ks &#x3D; new LinkedKeySet();\n        keySet &#x3D; ks;\n    &#125;\n    return ks;\n&#125;\npublic Collection&lt;V&gt; values() &#123;\n    Collection&lt;V&gt; vs &#x3D; values;\n    if (vs &#x3D;&#x3D; null) &#123;\n        vs &#x3D; new LinkedValues();\n        values &#x3D; vs;\n    &#125;\n    return vs;\n&#125;</code></pre></li>\n<li><p>遍历方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;Integer,String&gt; map &#x3D; new HashMap&lt;&gt;();\n\n&#x2F;&#x2F;把HashMap改为LinkedHashMap后，输出结果的顺序跟键值对插入的先后顺序一致\n&#x2F;&#x2F;Map&lt;Integer,String&gt; map &#x3D; new LinkedHashMap&lt;&gt;();\n\n&#x2F;&#x2F;for-each循环\nSet&lt;Entry&lt;Integer,String&gt;&gt; entrySet  &#x3D; map.entrySet();\nfor(Entry&lt;Integer,String&gt; entry : entrySet)&#123;\n    System.out.println(entry);\n&#125;\n&#x2F;&#x2F;迭代器遍历\nIterator&lt;Map.Entry&lt;Integer,String&gt;&gt;itr &#x3D; entrySet.iterator();\nwhile(itr.hasNext())&#123;\n    System.out.println(itr.next().toString());\n&#125;\n&#x2F;&#x2F;forEach()函数，函数式编程，Lambda表达式\nentrySet.forEach(e-&gt;System.out.println(e.toString()));\n</code></pre></li>\n<li><p>EntrySet内部类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final int size() &#123; return size; &#125;\n    public final void clear() &#123; HashMap.this.clear(); &#125;\n    &#x2F;&#x2F;for-each遍历和迭代器遍历\n    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;\n        return new EntryIterator();\n    &#125;\n    &#x2F;&#x2F;foreach()遍历\n    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;\n        Node&lt;K,V&gt;[] tab;\n        if (action &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        if (size &gt; 0 &amp;&amp; (tab &#x3D; table) !&#x3D; null) &#123;\n            int mc &#x3D; modCount;\n            for (int i &#x3D; 0; i &lt; tab.length; ++i) &#123;\n                for (Node&lt;K,V&gt; e &#x3D; tab[i]; e !&#x3D; null; e &#x3D; e.next)\n                    action.accept(e);\n            &#125;\n            if (modCount !&#x3D; mc)\n                throw new ConcurrentModificationException();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;迭代器\nfinal class EntryIterator extends HashIterator\n    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;\n&#125;\nabstract class HashIterator &#123;\n    &#x2F;&#x2F;省略属性和其他方法\n    public final boolean hasNext() &#123;\n        return next !&#x3D; null;\n    &#125;\n\n    final Node&lt;K,V&gt; nextNode() &#123;\n        Node&lt;K,V&gt;[] t;\n        Node&lt;K,V&gt; e &#x3D; next;\n        if (modCount !&#x3D; expectedModCount)\n            throw new ConcurrentModificationException();\n        if (e &#x3D;&#x3D; null)\n            throw new NoSuchElementException();\n        if ((next &#x3D; (current &#x3D; e).next) &#x3D;&#x3D; null &amp;&amp; (t &#x3D; table) !&#x3D; null) &#123;\n            do &#123;&#125; while (index &lt; t.length &amp;&amp; (next &#x3D; t[index++]) &#x3D;&#x3D; null);\n        &#125;\n        return e;\n    &#125;\n&#125;</code></pre></li>\n<li><p>LinkedHashMap有序遍历：迭代器和forEach()函数遍历的对象不再是table数组，而是双向链表</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final class LinkedEntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final int size()                 &#123; return size; &#125;\n    public final void clear()               &#123; LinkedHashMap.this.clear(); &#125;\n    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;\n        return new LinkedEntryIterator();\n    &#125;\n    public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;\n        if (action &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        int mc &#x3D; modCount;\n        for (LinkedHashMap.Entry&lt;K,V&gt; e &#x3D; head; e !&#x3D; null; e &#x3D; e.after)\n            action.accept(e);\n        if (modCount !&#x3D; mc)\n            throw new ConcurrentModificationException();\n    &#125;\n&#125;\nfinal class LinkedEntryIterator extends LinkedHashIterator\n    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;\n    public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;\n&#125;\nabstract class LinkedHashIterator &#123;\n    &#x2F;&#x2F;省略其他属性和方法\n    public final boolean hasNext() &#123;\n        return next !&#x3D; null;\n    &#125;\n\n    final LinkedHashMap.Entry&lt;K,V&gt; nextNode() &#123;\n        LinkedHashMap.Entry&lt;K,V&gt; e &#x3D; next;\n        if (modCount !&#x3D; expectedModCount)\n            throw new ConcurrentModificationException();\n        if (e &#x3D;&#x3D; null)\n            throw new NoSuchElementException();\n        current &#x3D; e;\n        next &#x3D; e.after;\n        return e;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-插入、删除、修改、查找\"><a href=\"#3-插入、删除、修改、查找\" class=\"headerlink\" title=\"3.插入、删除、修改、查找\"></a>3.插入、删除、修改、查找</h5><ol>\n<li><p>插入键值对：新增的键值对会被包裹成Entry节点，通过next指针串在table数组的对应链表中，同时，通过before、after指针串在双向有序链表的尾部。双向链表的有序性是动态维护的，不管哪种排序方式，将新键值对插入到双向链表的尾部，双向链表仍然有序。扩容时不影响双向链表，直接复用HashMap中的逻辑。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;将Entry节点串在table数组对应的链表中的逻辑见HashMap，可以直接复用\n&#x2F;&#x2F;将Entry节点串在双向有序链表尾部的代码如下：\nprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;\n    LinkedHashMap.Entry&lt;K,V&gt; last &#x3D; tail;\n    tail &#x3D; p;\n    if (last &#x3D;&#x3D; null)\n        head &#x3D; p;\n    else &#123;\n        p.before &#x3D; last;\n        last.after &#x3D; p;\n    &#125;\n&#125;</code></pre></li>\n<li><p>删除键值对：删除键值对时，对应的Entry节点会从table数组对应的链表和双向链表中删除，删除操作并不会破坏双向链表的有序性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; unlink\n    LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;\n        (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;\n    p.before &#x3D; p.after &#x3D; null;\n    if (b &#x3D;&#x3D; null)\n        head &#x3D; a;\n    else\n        b.after &#x3D; a;\n    if (a &#x3D;&#x3D; null)\n        tail &#x3D; b;\n    else\n        a.before &#x3D; b;\n&#125;</code></pre></li>\n<li><p>修改键对应值：修改键对应的值，结构不需要调整，对于双向有序链表，如果是按照插入顺序来排序，就不需要对其结构进行调整；如果是按照访问顺序来排序，需要将被修改的节点移动到双向链表的尾部。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void afterNodeAccess(Node&lt;K,V&gt; e) &#123; &#x2F;&#x2F; move node to last\n    LinkedHashMap.Entry&lt;K,V&gt; last;\n    if (accessOrder &amp;&amp; (last &#x3D; tail) !&#x3D; e) &#123;\n        LinkedHashMap.Entry&lt;K,V&gt; p &#x3D;\n            (LinkedHashMap.Entry&lt;K,V&gt;)e, b &#x3D; p.before, a &#x3D; p.after;\n        p.after &#x3D; null;\n        if (b &#x3D;&#x3D; null)\n            head &#x3D; a;\n        else\n            b.after &#x3D; a;\n        if (a !&#x3D; null)\n            a.before &#x3D; b;\n        else\n            last &#x3D; b;\n        if (last &#x3D;&#x3D; null)\n            head &#x3D; p;\n        else &#123;\n            p.before &#x3D; last;\n            last.after &#x3D; p;\n        &#125;\n        tail &#x3D; p;\n        ++modCount;\n    &#125;\n&#125;</code></pre></li>\n<li><p>查找键值对：对于按照访问数序排序的双向链表，操作同上述afterNodeAccess()函数。</p>\n</li>\n</ol>\n<h5 id=\"4-应用：LRU缓存\"><a href=\"#4-应用：LRU缓存\" class=\"headerlink\" title=\"4.应用：LRU缓存\"></a>4.应用：LRU缓存</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LRUCache&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; &#123;\n    private int cacheMaxSize;&#x2F;&#x2F;缓存大小限制\n    public LRUCache(int size) &#123;\n        &#x2F;&#x2F;因为动态扩容会影响效率，如果可以预估出数据量，并当作initialCapacity\n        &#x2F;&#x2F;传入构造函数就不会触发动态扩容了。\n        super((int) (size&#x2F;0.75f + 1),0.75f,true);\n        this.cacheMaxSize &#x3D; size;\n    &#125;\n    @Override\n    protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123;\n        &#x2F;&#x2F;this.size()返回LinkedHashMap中元素的个数\n        &#x2F;&#x2F;缓存满了的时候返回true，LinkedHashMap的afterNodeInsertion\n        &#x2F;&#x2F;会删除访问时间最早的节点\n        return cacheMaxSize &gt; this.size();\n    &#125;\n&#125;\npublic class LRUCache&lt;K,V&gt; &#123;\n    private int cacheMaxSize;\n    private LinkedHashMap&lt;K,V&gt; lmap;\n    public LRUCache(int size)&#123;\n        this.lmap &#x3D; new LinkedHashMap&lt;K,V&gt;&#123;\n            @Override\n            protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest)&#123;\n                &#x2F;&#x2F;this.size()返回LinkedHashMap中元素的个数\n                return cacheMaxSize &gt; this.size();\n            &#125;\n        &#125;;\n        this.cacheMaxSize &#x3D; size;\n    &#125;\n    public V get(K key)&#123;\n        return lmap.get(key);\n    &#125;\n    public void put(K key,V value)&#123;\n        lmap.put(key,value);\n    &#125;\n    public void remove(K key)&#123;\n        lmap.remove(key);\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"7-Collections\"><a href=\"#7-Collections\" class=\"headerlink\" title=\"7.Collections\"></a>7.Collections</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JCF提供的一个工具类，包含大量操作容器的静态函数，其中下文的XXX可以替换为List、Collection、Set、Map等</p></blockquote>\n<h5 id=\"1-sort\"><a href=\"#1-sort\" class=\"headerlink\" title=\"1.sort()\"></a>1.sort()</h5><ol>\n<li><p>Collections类中的sort()函数用来对List进行排序，默认方式为从小到大排序（也可通过传入Comparator接口的匿名类对象改变排序方式）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;函数定义\npublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;\n    list.sort(null);\n&#125;\n@SuppressWarnings(&#123;&quot;unchecked&quot;, &quot;rawtypes&quot;&#125;)\npublic static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123;\n    list.sort(c);\n&#125;\n&#x2F;&#x2F;使用方法\nList&lt;Integer&gt; list &#x3D; new LinkedList&lt;&gt;();\nlist.add(2);\nlist.add(3);\nlist.add(6);\n&#x2F;&#x2F;默认\nCollections.sort(list);\n&#x2F;&#x2F;自定义\nCollections.sort(list, new Comparator&lt;Integer&gt;() &#123;\n    @Override\n    public int compare(Integer o1, Integer o2) &#123;\n        return o2-o1;\n    &#125;\n&#125;);\n&#x2F;&#x2F;直接调用list的sort()\n&#x2F;&#x2F;Comparator接口的匿名类对象为null\n&#x2F;&#x2F;使用Integer实现的Comparable接口进行元素大小比较\nlist.sort(null);</code></pre></li>\n<li><p>不管是ArrayList容器还是LinkedList容器，使用sort()函数进行排序时，底层都会先将其转换为数组，对数组进行排序之后，再将排好序的数据存入容器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Collections类中\npublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123;\n    list.sort(null);\n&#125;\n&#x2F;&#x2F;List接口中\ndefault void sort(Comparator&lt;? super E&gt; c) &#123;\n    Object[] a &#x3D; this.toArray();\n    &#x2F;&#x2F;Arrays是数组的工具类，Collections是容器的工具类\n    Arrays.sort(a, (Comparator) c);\n    ListIterator&lt;E&gt; i &#x3D; this.listIterator();\n    for (Object e : a) &#123;\n        i.next();\n        i.set((E) e);\n    &#125;\n&#125;</code></pre></li>\n<li><p>Collections底层的sort()函数，底层依赖的Arrays类的sort()函数的是实现算法：</p>\n<ol>\n<li><p>基本类型数组排序算法：JDK8及以后使用DualPivotQuickSort()，JDK7及其以前使用快排</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void sort(int[] a) &#123;\n    DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);\n&#125;</code></pre></li>\n<li><p>对象数组排序算法：JDK8及其以后使用TimSort()，JDK7及其以前使用归并排序</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void sort(Object[] a) &#123;\n    if (LegacyMergeSort.userRequested)\n        legacyMergeSort(a);\n    else\n        ComparableTimSort.sort(a, 0, a.length, null, 0, 0);\n&#125;\npublic static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) &#123;\n    if (c &#x3D;&#x3D; null) &#123;\n        sort(a);\n    &#125; else &#123;\n        if (LegacyMergeSort.userRequested)\n            legacyMergeSort(a, c);\n        else\n            TimSort.sort(a, 0, a.length, c, null, 0, 0);\n    &#125;\n&#125;</code></pre></li>\n<li><p>一个对象用来构建数据结构的属性叫做键，对象中的其他属性叫做卫星数据，针对对象数组的排序，Arrays类使用稳定的TimSort来实现，对于基本类型数据的排序，使用对稳定性没有要求的DualPivotQuickSort来实现</p>\n</li>\n</ol>\n</li>\n<li><p>DualPivotQuickSort实现原理</p>\n<ol>\n<li><p>代码实现中用到了双轴快速排序算法、插入排序、计数排序、归并排序等算法</p>\n</li>\n<li><p>对快排改进，选取两个pivot：LP&amp;RP，采用5数取2法</p>\n</li>\n<li><p>对int、long、float、double这4种类型的数组：当数组长度小于QUICKSORT_THRESHOLD（286）时，执行双轴快速排序算法；在双轴快速排序算法中，在递归处理过程中，当待排序区间长度小于INSERTION_SORT_THRESHOLD（47）时，改为使用插入排序算法。如果待排序数组长度大于QUICKSORT_THRESHOLD（286）时，则通过从头到尾扫描统计数组中连续增和连续减区间的个数，如果区间个数超过MAX_RUN_COUNT（67）时，则说明待排序数组的数据杂乱无章一些，于是就选改进后的双轴快速排序，否则就选择执行非递归版的归并排序</p>\n</li>\n<li><p>对char、short类型的数组，如果数组元素大于COUNTING_SORT_THRESHOLD_FOR_SHORT_OR_CHAR（3200）时，将执行计数排序，否则同int等类型的数组相同的排序过程</p>\n</li>\n<li><p>对于byte类型的数组COUNTING_SORT_THRESHOLD_FOR_BYTE（29）时，将执行计数排序，否则执行插入排序</p>\n</li>\n</ol>\n</li>\n<li><p>TimSort实现原理</p>\n<ol>\n<li>使用非递归版本归并排序算法，在归并排序的过程中，大的排序区间不断分解为小的待排序区间，如果带排序区间的长度小于MIN_MERGE（32），就不再继续分解，转而执行二分插入排序算法</li>\n<li>二分插入排序算法将数组分为两部分：已排序区间和未排序区间，初始化已排序区间为空，为排序区间为整个数组。每次从未排序区间中取出一个数，插入到已排序区间中，并保持已排序区间继续有序。二分插入排序是通过二分查找，查找插入位置，当找到后，通过调用System.arraycopy()函数，将插入点之后的数据整体快速后移一位，腾出位置给要插入的数据。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-binarySearch\"><a href=\"#2-binarySearch\" class=\"headerlink\" title=\"2.binarySearch()\"></a>2.binarySearch()</h5><ol>\n<li><p>binarySearch()用来对已排序的List容器进行二分查找，定义如下，因为也涉及元素比较，所以需要传入实现Comparable接口的对象或者主动传入Comparator接口的匿名类对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123;\n    &#x2F;&#x2F;RandomAccess接口代表支持随机访问\n    &#x2F;&#x2F;BINARYSEARCH_THRESHOLD(5000)，每次找mid都需要遍历\n    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key);\n    else\n        return Collections.iteratorBinarySearch(list, key);\n&#125;\npublic static &lt;T&gt; int binarySearch(List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c) &#123;\n    if (c&#x3D;&#x3D;null)\n        return binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt;) list, key);\n\n    if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key, c);\n    else\n        return Collections.iteratorBinarySearch(list, key, c);\n&#125;\n&#x2F;&#x2F;使用\nCollections.sort(list);\nint idx &#x3D; Collections.binarySearch(list,targetNum);</code></pre></li>\n<li><p>两种二分查找：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static &lt;T&gt; int indexedBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c) &#123;\n    int low &#x3D; 0;\n    int high &#x3D; l.size()-1;\n\n    while (low &lt;&#x3D; high) &#123;\n        int mid &#x3D; (low + high) &gt;&gt;&gt; 1;\n        T midVal &#x3D; l.get(mid);\n        int cmp &#x3D; c.compare(midVal, key);\n        &#x2F;&#x2F;Comparable&lt;? super T&gt; midVal &#x3D; list.get(mid);\n        &#x2F;&#x2F;int cmp &#x3D; midVal.compareTo(key);\n\n        if (cmp &lt; 0)\n            low &#x3D; mid + 1;\n        else if (cmp &gt; 0)\n            high &#x3D; mid - 1;\n        else\n            return mid; &#x2F;&#x2F; key found\n    &#125;\n    return -(low + 1);  &#x2F;&#x2F; key not found\n&#125;\nprivate static &lt;T&gt; int iteratorBinarySearch(List&lt;? extends T&gt; l, T key, Comparator&lt;? super T&gt; c) &#123;\n    int low &#x3D; 0;\n    int high &#x3D; l.size()-1;\n    ListIterator&lt;? extends T&gt; i &#x3D; l.listIterator();\n\n    while (low &lt;&#x3D; high) &#123;\n        int mid &#x3D; (low + high) &gt;&gt;&gt; 1;\n        T midVal &#x3D; get(i, mid);\n        int cmp &#x3D; c.compare(midVal, key);\n\n        if (cmp &lt; 0)\n            low &#x3D; mid + 1;\n        else if (cmp &gt; 0)\n            high &#x3D; mid - 1;\n        else\n            return mid; &#x2F;&#x2F; key found\n    &#125;\n    return -(low + 1);  &#x2F;&#x2F; key not found\n&#125;\n&#x2F;&#x2F;get每次都从上一个mid的位置向前或向后找，查找的范围变小了，执行效率变高了\nprivate static &lt;T&gt; T get(ListIterator&lt;? extends T&gt; i, int index) &#123;\n    T obj &#x3D; null;\n    int pos &#x3D; i.nextIndex();\n    if (pos &lt;&#x3D; index) &#123;\n        do &#123;\n            obj &#x3D; i.next();\n        &#125; while (pos++ &lt; index);\n    &#125; else &#123;\n        do &#123;\n            obj &#x3D; i.previous();\n        &#125; while (--pos &gt; index);\n    &#125;\n    return obj;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-emptyXXX\"><a href=\"#3-emptyXXX\" class=\"headerlink\" title=\"3.emptyXXX()\"></a>3.emptyXXX()</h5><ol>\n<li><p>emptyXXX()用来返回一个空的容器，其中的XXX可以替换为List、Set、Map，定义如下，一般用来替换返回null值，因为返回null值有可能导致外部代码在调用函数时发生NullPointerException异常</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static final &lt;T&gt; List&lt;T&gt; emptyList() &#123;\n    return (List&lt;T&gt;) EMPTY_LIST;\n&#125;\npublic static final &lt;T&gt; Set&lt;T&gt; emptySet() &#123;\n    return (Set&lt;T&gt;) EMPTY_SET;\n&#125;\npublic static final &lt;K,V&gt; Map&lt;K,V&gt; emptyMap() &#123;\n    return (Map&lt;K,V&gt;) EMPTY_MAP;\n&#125;</code></pre></li>\n<li><p>一个要注意的用法：Collections.emptyList()函数返回的虽然是一个新类（EmptyList）的对象，但他是Collections的静态成员变量，当使用这个新类的add函数时，会抛出UnsupportedOperationException异常（见AbstractList）。为了避免这个问题，一般在外部代码重新定义一个容器，将调用函数返回的结果通过addAll()添加到容器中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static final List EMPTY_LIST &#x3D; new EmptyList&lt;&gt;();\nprivate static class EmptyList&lt;E&gt;\n    extends AbstractList&lt;E&gt;\n    implements RandomAccess, Serializable &#123;\n    private static final long serialVersionUID &#x3D; 8842843931221139166L;\n\n    public Iterator&lt;E&gt; iterator() &#123;\n        return emptyIterator();\n    &#125;\n    public ListIterator&lt;E&gt; listIterator() &#123;\n        return emptyListIterator();\n    &#125;\n\n    public int size() &#123;return 0;&#125;\n    public boolean isEmpty() &#123;return true;&#125;\n\n    public boolean contains(Object obj) &#123;return false;&#125;\n    public boolean containsAll(Collection&lt;?&gt; c) &#123; return c.isEmpty(); &#125;\n\n    public Object[] toArray() &#123; return new Object[0]; &#125;\n\n    public &lt;T&gt; T[] toArray(T[] a) &#123;\n        if (a.length &gt; 0)\n            a[0] &#x3D; null;\n        return a;\n    &#125;\n\n    public E get(int index) &#123;\n        throw new IndexOutOfBoundsException(&quot;Index: &quot;+index);\n    &#125;\n\n    public boolean equals(Object o) &#123;\n        return (o instanceof List) &amp;&amp; ((List&lt;?&gt;)o).isEmpty();\n    &#125;\n\n    public int hashCode() &#123; return 1; &#125;\n\n   &#x2F;&#x2F;...省略部分代码\n&#125;\nList&lt;Integer&gt; list &#x3D; Collections.emptyList();\nList&lt;Integer&gt; list2 &#x3D; Collections.emptyList();&#x2F;&#x2F;list2 &#x3D;&#x3D; list true\n&#x2F;&#x2F;错误使用方式,抛出异常\nlist.add(&quot;abc&quot;);\n&#x2F;&#x2F;正确使用方式\nList&lt;Integer&gt; list3 &#x3D; new ArrayList&lt;&gt;();\nlist3.addAll(list);\nlist3.add(&quot;abc&quot;);&#x2F;&#x2F;插入成功</code></pre></li>\n</ol>\n<h5 id=\"4-synchronizedXXX\"><a href=\"#4-synchronizedXXX\" class=\"headerlink\" title=\"4.synchronizedXXX()\"></a>4.synchronizedXXX()</h5><ol>\n<li><p>JCF中的容器都是非线程安全的，当要使用线程安全的容器时，首选使用JUC并发容器，但当没有合适的JUC并发容器可以使用时，可以使用Collectinos类中的synchronizedXXX()函数来创建线程安全的容器。定义如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) &#123;\n    return new SynchronizedCollection&lt;&gt;(c);\n&#125;\npublic static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;\n    return (list instanceof RandomAccess ?\n            new SynchronizedRandomAccessList&lt;&gt;(list) :\n            new SynchronizedList&lt;&gt;(list));\n&#125;\npublic static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) &#123;\n    return new SynchronizedSet&lt;&gt;(s);\n&#125;\npublic static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;\n    return new SynchronizedMap&lt;&gt;(m);\n&#125;\n&#x2F;&#x2F;创建线程安全的容器：\nList list &#x3D; Collections.synchronizedList(new LinekdList&lt;&gt;());\n&#x2F;&#x2F;底层原理，通过对每个方法加锁，来避免并发访问\nstatic class SynchronizedList&lt;E&gt;\n    extends SynchronizedCollection&lt;E&gt;\n    implements List&lt;E&gt; &#123;\n    private static final long serialVersionUID &#x3D; -7754090372962971524L;\n\n    final List&lt;E&gt; list;\n\n    SynchronizedList(List&lt;E&gt; list) &#123;\n        super(list);\n        this.list &#x3D; list;\n    &#125;\n    SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;\n        super(list, mutex);\n        this.list &#x3D; list;\n    &#125;\n\n    public boolean equals(Object o) &#123;\n        if (this &#x3D;&#x3D; o)\n            return true;\n        synchronized (mutex) &#123;return list.equals(o);&#125;\n    &#125;\n    public int hashCode() &#123;\n        synchronized (mutex) &#123;return list.hashCode();&#125;\n    &#125;\n\n    public E get(int index) &#123;\n        synchronized (mutex) &#123;return list.get(index);&#125;\n    &#125;\n    public E set(int index, E element) &#123;\n        synchronized (mutex) &#123;return list.set(index, element);&#125;\n    &#125;\n    public void add(int index, E element) &#123;\n        synchronized (mutex) &#123;list.add(index, element);&#125;\n    &#125;\n    public E remove(int index) &#123;\n        synchronized (mutex) &#123;return list.remove(index);&#125;\n    &#125;\n\t&#x2F;&#x2F;...\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"5-unmodifiable\"><a href=\"#5-unmodifiable\" class=\"headerlink\" title=\"5.unmodifiable()\"></a>5.unmodifiable()</h5><ol>\n<li><p>unmodifiableXXX()用来返回不可变容器，这里的不可变指的是容器内的数据只能访问，不可增删。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123;\n    return new UnmodifiableCollection&lt;&gt;(c);\n&#125;\npublic static &lt;T&gt; List&lt;T&gt; unmodifiableList(List&lt;? extends T&gt; list) &#123;\n    return (list instanceof RandomAccess ?\n            new UnmodifiableRandomAccessList&lt;&gt;(list) :\n            new UnmodifiableList&lt;&gt;(list));\n&#125;\npublic static &lt;T&gt; Set&lt;T&gt; unmodifiableSet(Set&lt;? extends T&gt; s) &#123;\n    return new UnmodifiableSet&lt;&gt;(s);\n&#125;\npublic static &lt;K,V&gt; Map&lt;K,V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n    return new UnmodifiableMap&lt;&gt;(m);\n&#125;\n&#x2F;&#x2F;使用\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nList&lt;Integer&gt; result &#x3D; Collections.unmodifiableList(list);\n&#x2F;&#x2F;抛出UnsupportedOperationException异常\nresult.add(Integer.valueof(1));</code></pre></li>\n<li><p>实现原理：定义新的UnmodifiableXXX类，重写add()、remove()等增删操作，让其抛出UnsupportedOperationException异常</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static class UnmodifiableList&lt;E&gt; extends UnmodifiableCollection&lt;E&gt;\n    implements List&lt;E&gt; &#123;\n    private static final long  &#x3D; -283967356065247728L;\n\n    final List&lt;? extends E&gt; list;\n\n    UnmodifiableList(List&lt;? extends E&gt; list) &#123;\n        super(list);\n        this.list &#x3D; list;\n    &#125;\n\n    public boolean equals(Object o) &#123;return o &#x3D;&#x3D; this || list.equals(o);&#125;\n    public int hashCode()           &#123;return list.hashCode();&#125;\n\n    public E get(int index) &#123;return list.get(index);&#125;\n    public E set(int index, E element) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public void add(int index, E element) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public E remove(int index) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    public int indexOf(Object o)            &#123;return list.indexOf(o);&#125;\n    public int lastIndexOf(Object o)        &#123;return list.lastIndexOf(o);&#125;\n    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n\n    @Override\n    public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n    @Override\n    public void sort(Comparator&lt;? super E&gt; c) &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n\n    public ListIterator&lt;E&gt; listIterator()   &#123;return listIterator(0);&#125;\n\n    public ListIterator&lt;E&gt; listIterator(final int index) &#123;\n        return new ListIterator&lt;E&gt;() &#123;\n            private final ListIterator&lt;? extends E&gt; i\n                &#x3D; list.listIterator(index);\n\n            public boolean hasNext()     &#123;return i.hasNext();&#125;\n            public E next()              &#123;return i.next();&#125;\n            public boolean hasPrevious() &#123;return i.hasPrevious();&#125;\n            public E previous()          &#123;return i.previous();&#125;\n            public int nextIndex()       &#123;return i.nextIndex();&#125;\n            public int previousIndex()   &#123;return i.previousIndex();&#125;\n\n            public void remove() &#123;\n                throw new UnsupportedOperationException();\n            &#125;\n            public void set(E e) &#123;\n                throw new UnsupportedOperationException();\n            &#125;\n            public void add(E e) &#123;\n                throw new UnsupportedOperationException();\n            &#125;\n\n            @Override\n            public void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n                i.forEachRemaining(action);\n            &#125;\n        &#125;;\n    &#125;\n\n    public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;\n        return new UnmodifiableList&lt;&gt;(list.subList(fromIndex, toIndex));\n    &#125;\n    private Object readResolve() &#123;\n        return (list instanceof RandomAccess\n                ? new UnmodifiableRandomAccessList&lt;&gt;(list)\n                : this);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"8-Iterator\"><a href=\"#8-Iterator\" class=\"headerlink\" title=\"8.Iterator\"></a>8.Iterator</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>遍历容器的常用方法</p></blockquote>\n<h5 id=\"1-容器的遍历方法\"><a href=\"#1-容器的遍历方法\" class=\"headerlink\" title=\"1.容器的遍历方法\"></a>1.容器的遍历方法</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>主要考虑List、Set、Map，不考虑操作受限的Stack和Queue，因为容器的底层可能比较复杂，所以将遍历逻辑包裹成迭代器，来降低开发成本。</p></blockquote>\n<ol>\n<li><p>for循环：只能用于List容器，因为需要根据下标获取元素，而Set、Map并没有下标的概念，所以不支持这种遍历方式，LinkedList虽然能用但性能差（O(n^2)）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for(int i &#x3D; 0;i &lt; list.size();++i)&#123;\n    System.out.println(list.get(i));\n&#125;</code></pre></li>\n<li><p>for-each循环：和迭代器遍历等价，是一种语法糖，底层用迭代器实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for(String s ； list)&#123;\n    System.out.println(s);\n&#125;</code></pre></li>\n<li><p>迭代器：只支持实现了Iterable接口的类，所以List和Set支持迭代器遍历，Map不支持，只能通过entrySet()获取EntrySet对象，然后通过EntrySet提供的迭代器来遍历</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Iterator&lt;String&gt; itr &#x3D; list.iterator();\nwhile(itr.hasNext())&#123;\n    System.out.println(itr.next());\n&#125;</code></pre></li>\n<li><p>forEach()函数：JDK8开始支持的函数式编程，List、Set、Map都支持，具体见函数式编程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">list.forEach(s-&gt;System.out.println(s));</code></pre></li>\n</ol>\n<h5 id=\"2-实现原理\"><a href=\"#2-实现原理\" class=\"headerlink\" title=\"2.实现原理\"></a>2.实现原理</h5><ol>\n<li><p>迭代器是迭代器设计模式的经典实现，迭代器设计模式的代码结构如下：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221130212631624.png\" alt=\"image-20221130212631624\"></p>\n</li>\n<li><p>Iterable接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Iterable&lt;T&gt; &#123;\n    Iterator&lt;T&gt; iterator();\n    \n    default void forEach(Consumer&lt;? super T&gt; action) &#123;\n        Objects.requireNonNull(action);\n        for (T t : this) &#123;\n            action.accept(t);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;用于配合实现forEach()函数式编程\n    default Spliterator&lt;T&gt; spliterator() &#123;\n        return Spliterators.spliteratorUnknownSize(iterator(), 0);\n    &#125;\n&#125;</code></pre></li>\n<li><p>ArrayList中iterator()函数的代码实现：容器实现Iterable接口，迭代器实现Iterator接口，容器中定义迭代器类，并通过iterator()函数返回迭代器类对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;\n    protected transient int modCount &#x3D; 0;\n    \n    public Iterator&lt;E&gt; iterator() &#123;\n        return new Itr();\n    &#125;\n\n    private class Itr implements Iterator&lt;E&gt; &#123;\n        int cursor;       &#x2F;&#x2F; index of next element to return\n        int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such\n        int expectedModCount &#x3D; modCount;\n\n        Itr() &#123;&#125;\n\n        public boolean hasNext() &#123;\n            return cursor !&#x3D; size;\n        &#125;\n\n        @SuppressWarnings(&quot;unchecked&quot;)\n        public E next() &#123;\n            checkForComodification();\n            int i &#x3D; cursor;\n            if (i &gt;&#x3D; size)\n                throw new NoSuchElementException();\n            Object[] elementData &#x3D; ArrayList.this.elementData;\n            if (i &gt;&#x3D; elementData.length)\n                throw new ConcurrentModificationException();\n            cursor &#x3D; i + 1;\n            return (E) elementData[lastRet &#x3D; i];\n        &#125;\n\n        public void remove() &#123;\n            if (lastRet &lt; 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try &#123;\n                ArrayList.this.remove(lastRet);\n                cursor &#x3D; lastRet;\n                lastRet &#x3D; -1;\n                expectedModCount &#x3D; modCount;\n            &#125; catch (IndexOutOfBoundsException ex) &#123;\n                throw new ConcurrentModificationException();\n            &#125;\n        &#125;\n\n        @Override\n        @SuppressWarnings(&quot;unchecked&quot;)\n        public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;\n            Objects.requireNonNull(consumer);\n            final int size &#x3D; ArrayList.this.size;\n            int i &#x3D; cursor;\n            if (i &gt;&#x3D; size) &#123;\n                return;\n            &#125;\n            final Object[] elementData &#x3D; ArrayList.this.elementData;\n            if (i &gt;&#x3D; elementData.length) &#123;\n                throw new ConcurrentModificationException();\n            &#125;\n            while (i !&#x3D; size &amp;&amp; modCount &#x3D;&#x3D; expectedModCount) &#123;\n                consumer.accept((E) elementData[i++]);\n            &#125;\n            &#x2F;&#x2F; update once at end of iteration to reduce heap write traffic\n            cursor &#x3D; i;\n            lastRet &#x3D; i - 1;\n            checkForComodification();\n        &#125;\n\n        final void checkForComodification() &#123;\n            if (modCount !&#x3D; expectedModCount)\n                throw new ConcurrentModificationException();\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>增强版的迭代器：ListIterator</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Iterator&lt;E&gt; &#123;\n    boolean hasNext();\n    E next();\n    default void remove() &#123;\n        throw new UnsupportedOperationException(&quot;remove&quot;);\n    &#125;\n    default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    &#125;\n&#125;\npublic interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;\n    boolean hasNext();\n    E next();\n    boolean hasPrevious();\n    E previous();\n    int nextIndex();\n    int previousIndex();\n    void remove();\n    void set(E e);\n    void add(E e);\n&#125;\n&#x2F;&#x2F;使用\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.addAll(Arrays.asList(0,1,2,3,4));\n&#x2F;&#x2F;从下标为2的位置开始遍历\nListIterator&lt;Integer&gt; litr &#x3D; list.listIterator(2);\nwhile(litr.hasNext())&#123;\n    System.out.println(litr.next());&#x2F;&#x2F;输出2 3 4\n&#125;\nwhile(litr.hasNext())&#123;\n    System.out.println(litr.previous());&#x2F;&#x2F;输出4 3 2 1 0\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-问题及解决思路\"><a href=\"#3-问题及解决思路\" class=\"headerlink\" title=\"3.问题及解决思路\"></a>3.问题及解决思路</h5><ol>\n<li>在创建迭代器之后，增删容器中的元素，再使用迭代器遍历容器，会导致未决行为（结果不确定），所以才引入了expectedModCount和modCount这两个成员变量</li>\n<li>当没有expectedModCount和modCount这两个成员变量的时候，在遍历的时候增删元素会遇到未决问题</li>\n<li>解决方法：在增删元素之后，让遍历报错，凡是实现了Iterable接口的容器，都有modCount成员变量，用来记录容器修改的次数，容器每调用一次增加或删除元素的函数，就会给modCount加1，当通过调用容器上的iterator()函数来创建迭代器的时候，把modCount的值传递给expectedModCount成员变量，之后每次调用迭代器上的next()函数，我们都会调用checkForComodification()函数，检查modCount是否改变过。如果expectedModCount和modCount的值不同， 则说明被修改过，迭代器就不能用了，抛出运行时异常ConcurrentModificationException，结束程序，让程序员尽快修复这个bug</li>\n</ol>\n<h5 id=\"4-安全删除元素\"><a href=\"#4-安全删除元素\" class=\"headerlink\" title=\"4.安全删除元素\"></a>4.安全删除元素</h5><ol>\n<li>Iterator接口中出了最基本的hasNext()、next()方法之外，还定义了一个remove()方法，使用它可以在遍历的同时，安全的删除容器中的元素。但是它只能删除cursor指向的前一个元素，而且调用一个next()函数之后，只能跟着一个remove()操作</li>\n</ol>\n<h3 id=\"7-异常\"><a href=\"#7-异常\" class=\"headerlink\" title=\"7.异常\"></a>7.异常</h3><h4 id=\"1-异常使用\"><a href=\"#1-异常使用\" class=\"headerlink\" title=\"1.异常使用\"></a>1.异常使用</h4><ol>\n<li><p>作用：相比较C语言返回错误码的方式，可以携带更多的错误信息（message、stack trace等），并且可以将业务代码和异常处理代码分离，这样代码的可读性会更好。</p>\n</li>\n<li><p>异常关键词：</p>\n<ul>\n<li>throw：用来抛出异常</li>\n<li>throws：用来在方法定义中声明方法可能抛出的异常</li>\n<li>try：用来标记需要监控异常的代码</li>\n<li>catch：用来捕获代码抛出的异常并进行处理</li>\n<li>finally：用来兜底，只要try标记的代码被执行，不管有没有抛出异常，finally中的代码都会被执行，一般用来做清理工作，比如关闭打开的文件</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public byte[] readData(String filePath) throws DataReadException&#123;\n    IntputStream in &#x3D; null;\n    try&#123;\n        in &#x3D; new FileInputStream(filePath);\n        byte[] data &#x3D; new byte[in.available()];\n        in.read(data);\n        return data;\n    &#x2F;&#x2F;先捕获子类异常，再捕获父类异常\n    &#125;catch(FileNotFoundException e)&#123;\n        &#x2F;&#x2F;DataReadException是自定义异常\n        throw new DataReadException(&quot;File not found&quot; + filePath,e);\n    &#125;catch(IOException e)&#123;\n        throw new DataReadException(&quot;Failed to read&quot; + filePath,e);\n    &#125;finally&#123;\n        if(in !&#x3D; null)&#123;\n            try&#123;\n                in.close();\n            &#125;catch(IOException e)&#123;\n                &#x2F;&#x2F;使用日志框架记录日志\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;新特性\npublic void readData(String filePath)throws DataReadException&#123;\n    try(InputStram in &#x3D; new FileInputStream(filePath))&#123;\n        Thread.sleep(10);\n    &#125;catch(FileNotFoundException | InterruptedException e)&#123;\n        &#x2F;&#x2F;...\n    &#125;catch(IoException e)&#123;\n        throw new DataReadExceptioin(&quot;Failed to read&quot; + filePath,e);\n    &#125;\n&#125;\n&#x2F;&#x2F;对于实现了Java.lang.AutoClosale接口的资源类，可以使用try-with-resources语句来\n&#x2F;&#x2F;创建资源类对象，try代码执行完成之后，对应的资源会自动被关闭</code></pre></li>\n</ol>\n<h4 id=\"2-异常体系\"><a href=\"#2-异常体系\" class=\"headerlink\" title=\"2.异常体系\"></a>2.异常体系</h4><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221130212704806.png\" alt=\"image-20221130212704806\"></p>\n<ol>\n<li>Throwable是所有异常的父类，Error和Exception是Throwable的子类，RuntimeExeption是Exception的子类，因此所有异常可以分为三类：<ol>\n<li>继承自Error的异常，是一种比较特殊的异常，用来表示程序无法处理的严重错误，这些错误有可能导致线程或JVM终止</li>\n<li>继承自Exception的异常，也叫做受检异常（Checked Exception）或编译时异常（Compile Exception），在编写代码的时候，我们需要主动取捕获或者在函数定义中声明此类异常，否则编译就会报错</li>\n<li>继承自RuntimeException的异常，也叫做非受检异常（Unchecked Exception）或者运行时异常（Runtime Exception），在编写代码的时候，我们可以不主动取捕获和在函数定义中声明此类异常，不处理也可以通过编译</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-自定义异常\"><a href=\"#3-自定义异常\" class=\"headerlink\" title=\"3.自定义异常\"></a>3.自定义异常</h4><ol>\n<li><p>一般使用Java已经提供的内建异常，在不满足业务需求的情况下，就需要自定义异常，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserNotExistingException extends Exception&#123;\n    public UserNotExistingException()&#123;\n        super();\n    &#125;\n    public UserNotExistingException(String msg,Throwable cause)&#123;\n        super(msg,cause)；\n    &#125;\n    public UserNotExistingException(String msg)&#123;\n        super(msg);\n    &#125;\n    public UserNotExistingException(Throwable cause)&#123;\n        super(cause);\n    &#125;\n&#125;</code></pre></li>\n<li><p>自定义异常跟大多数内建异常一样，要么继承自Exception，要么继承自RuntimeException。对于代码bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以更倾向于使用非受检异常。对于可恢复异常、业务异常、预期可能发生的异常（比如现金额大于余额的异常），更倾向于使用受检异常。但是现在一般都依赖框架来编程，受检和非受检异常大部分情况下都会被框架兜底捕获并处理，并不会直接导致程序的终止，所以从这个角度来看，继承自哪个异常均可。</p>\n</li>\n<li><p>受检异常的缺点：</p>\n<ol>\n<li>受检异常需要显示地在函数定义中声明，如果过多，则会影响代码可读性</li>\n<li>编译器强制程序必须显示地捕获所有的受检异常，代码实现会比较繁琐</li>\n<li>受检异常的使用违反开闭原则，如果给某个函数新增一个受检异常，这个函数所在的函数调用链上的所有位于其上的数，都需要做相应的代码修改，知道某个函数捕获处理不再抛出为止，相反，新增非受检异常可以不改动调用链上的代码，可以灵活地选择在某个函数中集中处理，比如再Spring中的AOP切面集中处理异常</li>\n</ol>\n</li>\n<li><p>非受检异常的缺点：非受检异常使用起来更加灵活，怎么处理异常的主动权交给了程序员，在使用函数时，需要查看函数的逻辑，才能知道函数具体抛出哪些异常，一些本应该捕获处理的异常就有可能被程序员遗漏。</p>\n</li>\n</ol>\n<h4 id=\"4-异常处理\"><a href=\"#4-异常处理\" class=\"headerlink\" title=\"4.异常处理\"></a>4.异常处理</h4><ol>\n<li><p>一共有三种处理方法，选择的原则是：函数只抛出跟函数所涉及业务相关的异常，在函数内部，如果某代码的异常行为，并不会导致调用此函数的上层代码出现异常行为，也就是说，上层代码并不关心被调用函数内部的这个异常，我们就可以在函数内部将这个异常捕获并打印日志记录。相反，如果函数内部的异常行为会导致调用此函数时，知道如何处理异常，那么直接将其抛出即可。如果此异常跟函数的业务无关，上层代码无法理解这个异常的含义，不知道如何处理，那么需要将其包裹成新的跟函数业务相关的异常重新抛出。</p>\n<ol>\n<li>捕获后记录日志</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void f() throws LowLevelException&#123;...&#125;\npublic void g()&#123;\n    try&#123;\n        f();\n    &#125;catch(LowLevelException e)&#123;\n        log.warn(&quot;...&quot;,e);&#x2F;&#x2F;使用日志框架记录日志\n    &#125;\n&#125;</code></pre>\n\n\n\n<ol start=\"2\">\n<li>原封不动再抛出</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void f() throws LowLevelException&#123;...&#125;\n&#x2F;&#x2F;如果LowLevelException是非受检异常，则不需要再函数g()定义中声明\npublic void g() throws LowLevelException&#123;\n    f();\n&#125;</code></pre>\n\n\n\n<ol start=\"3\">\n<li>包装成新异常抛出</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void f() throws LowLevelException&#123;...&#125;\npublic void g()&#123;\n    try&#123;\n        f();\n    &#125;catch(LowLevelExceptioin e)&#123;\n        throw new HighLevelException(&quot;...&quot;,e);\n    &#125;\n&#125;</code></pre></li>\n<li><p>改版：</p>\n</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;文件打开失败的FileNotFoundException因为跟readData()函数业务相关，可以直接将其抛出\npublic byte[] readData(String filePath) throws \n    \t\t\t\tDataReadException,FileNotFoundException&#123;\n    IntputStream in &#x3D; null;\n    try&#123;\n        Thread.sleep(10);\n        in &#x3D; new FileInputStream(filePath);\n        byte[] data &#x3D; new byte[in.available()];\n        in.read(data);\n        return data;\n    &#125;catch(InterruptedException e)&#123;\n        &#x2F;&#x2F;DataReadException是自定义异常\n        throw new DataReadException(&quot;Interuupted when reading&quot; + filePath,e);\n    &#125;catch(IOException e)&#123;\n        &#x2F;&#x2F;因为IOException异常比较底层，如果原封不动抛出，上层不知道如何处理\n        &#x2F;&#x2F;所以，将其包裹成DataReadException异常再抛出\n        throw new DataReadException(&quot;Failed to read&quot; + filePath,e);\n    &#125;finally&#123;\n        if(in !&#x3D; null)&#123;\n            try&#123;\n                in.close();\n            &#125;catch(IOException e)&#123;\n                &#x2F;&#x2F;使用日志框架记录日志\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"5-异常调用链\"><a href=\"#5-异常调用链\" class=\"headerlink\" title=\"5.异常调用链\"></a>5.异常调用链</h4><ol>\n<li><p>异常调用链可以完整的描述异常发生的整个过程，但需要特别注意的是，捕获异常并包裹成新的异常抛出时，我们一定要将先前的异常通过cause参数传递进新的异常，否则，异常调用链会断开。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;错误\ntry&#123;\n    ...\n&#125;catch(CausedByException e)&#123;\n    throw new NewException(&quot;msg&quot;);&#x2F;&#x2F;e丢失\n&#125;\n&#x2F;&#x2F;正确\ntry&#123;\n    ...\n&#125;catch(CausedByException e)&#123;\n    throw new NewException(&quot;msg&quot;,e);\n&#125;</code></pre></li>\n<li><p>在平时开发中，我们还需要注意，对于异常的处理，要么记录，要么抛出，但两者不能同时执行，对于异常调用链，只需要在最后一个异常生命周期结束时，打印异常调用链即可，没必要如下，重复打印异常调用链</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;错误\ntry&#123;\n    ...\n&#125;catch(CauseByException)&#123;\n    logger.error(&quot;...&quot;,e);\n    throw new NewException(&quot;msg&quot;,e);\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"6-异常实现原理\"><a href=\"#6-异常实现原理\" class=\"headerlink\" title=\"6.异常实现原理\"></a>6.异常实现原理</h4><ol>\n<li><p>异常代码块执行顺序：不管try监听的代码块有没有异常抛出，finally代码块总是被执行，并且在finally代码执行完成之后，try代码块和catch代码块中的return语句才会被执行</p>\n</li>\n<li><p>异常的运行机制主要有3部分：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        double res &#x3D; div(2, 1);\n        System.out.println(res);\n        res &#x3D; div(2, 0);\n        System.out.println(res);\n    &#125;\n\n    public static double div(int a, int b) &#123;\n        try &#123;\n            double res &#x3D; a &#x2F; b;\n            System.out.println(&quot;in the block&quot;);\n            return res;\n        &#125;catch (ArithmeticException e)&#123;\n            System.out.println(&quot;in the ATE catch block&quot;);\n            return -1.0;\n        &#125;finally &#123;\n            System.out.println(&quot;in finally blocks&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220529091732696-165468719667764-165668658181121.png\" alt=\"image-20220529091732696\"></p>\n<ol>\n<li>异常表：对应于上图最后一部分的Exception table，其中from、to、target都表示字节码的行号，当行号在[from，to）之间的代码抛出type类型的异常时，JVM会跳转至target行字节码继续执行</li>\n<li>异常兜底：第50行代码开始，主要是捕获try代码块和catch代码块中未被捕获的异常，然后再执行完finally代码块之后，在原封不动的将异常抛出。</li>\n<li>finally内联：JVM在生成字节码时，会将finally代码块内联（插入）到try代码块和catch代码块中的return语句之前，这样就可以实现不管程序是否抛出异常，finally代码块总是会被执行，并且再函数返回之前执行。如果finally由return语句，会提前返回</li>\n</ol>\n</li>\n<li></li>\n</ol>\n<h4 id=\"7-异常性能分析\"><a href=\"#7-异常性能分析\" class=\"headerlink\" title=\"7.异常性能分析\"></a>7.异常性能分析</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果未发生异常，则性能不受影响；当有异常抛出时，一般会执行三个操作：使用new创建异常、使用throw抛出异常、打印异常调用链</p></blockquote>\n<ol>\n<li><p>使用new创建异常</p>\n<ol>\n<li><p>在堆上创建异常对象，初始化成员变量</p>\n</li>\n<li><p>调用异常父类Throwable中的fillInStackTrace()函数生成栈追踪信息</p>\n<ol>\n<li><p>栈追踪信息：当创建异常时函数调用栈中的所有函数的信息，栈追踪信息记录了异常产生的整个函数调用链路，方便开发者定位此异常是如何产生的</p>\n</li>\n<li><p>fillInStackTrace()函数所做的工作就是遍历函数调用栈，将每个函数的信息存入异常的stackTrace成员变量中，stackTrace成员变量的定义为：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private StackTraceElement[] stackTrace;\npublic final class StackTraceElement implements java.io.Serializable &#123;\n    &#x2F;&#x2F; Normally initialized by VM (public constructor added in 1.5)\n    private String declaringClass;&#x2F;&#x2F;函数所属类名\n    private String methodName;&#x2F;&#x2F;函数名\n    private String fileName;&#x2F;&#x2F;函数所属类文件名\n    private int    lineNumber;&#x2F;&#x2F;异常抛出时，函数执行到了哪一行\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li><p>通过getStackTrace()函数，将异常的stackTrace栈追踪信息打印出来</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">RuntimeException e &#x3D; new RuntimeException(&quot;oops&quot;);\nStackTraceElement[] stackTrace &#x3D; e.getStackTrace();\nfor(StackTraceElement element : stackTrace)&#123;\n    System.out.println(element);\n&#125;</code></pre></li>\n<li><p>当总的函数调用层次过深时，fillInStackTrace()的耗时就相当可观了，这就是异常导致程序变慢的其中一个原因，所以在递归中不要轻易抛出异常</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>使用throw抛出异常（）</p>\n<ol>\n<li><p><code>throw new RuntimeException(&quot;oops&quot;)</code>这样一个异常抛出代码包括两个操作：创建异常和抛出异常等价于下面的两行代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">RuntimeException e &#x3D; new RuntimeException(&quot;oops!&quot;);\nthrow e;</code></pre></li>\n<li><p>当函数执行throw语句抛出异常时，JVM底层会执行栈展开（stack unwinding），依次将函数调用栈中的函数栈帧弹出，直到找到哪个函数可以捕获这个异常为止，然后JVM从这个函数继续再执行。</p>\n</li>\n<li><p>相对于普通的函数返回（调用return语句）导致的栈帧弹出，调用throw导致的栈展开除了包含栈帧弹出之外，还增加了一个过程：在函数的异常表中查找是否有可匹配的处理规则。如果异常抛出之后，经过很多函数调用，最终才被捕获，那么查询这些函数的异常表的耗时就会比较多，这就是异常导致程序变慢的另一个原因。但是相比于创建异常来说，栈展开的耗时更小一些。因此，对于异常，应该遵守能捕获尽早捕获的开发原则，例如SpringAOP在程序的最外层捕获所有的异常，这样的做法增加了栈展开的耗时。</p>\n</li>\n</ol>\n</li>\n<li><p>打印异常调用链</p>\n<ol>\n<li><p>将异常封装成新的异常再抛出：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try&#123;\n    &#x2F;&#x2F;...\n&#125;catch(IOException e)&#123;\n    throw new RuntimeException(&quot;oops&quot;,e);\n&#125;\n\npublic class Throwable&#123;\n    private String detailMessage;\n    private Throwable cause &#x3D; this;&#x2F;&#x2F;异常调用\n    private StackTraceElement[] stackTrace &#x3D; UNASSIGNED_STACK;\n    \n    public Throwable(String message, Throwable cause) &#123;\n        fillInStackTrace();&#x2F;&#x2F;生成stackTrace\n        detailMessage &#x3D; message;\n        this.cause &#x3D; cause;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li><p>一般在开发中使用日志框架来记录异常，异常调用链信息会输出到日志文件中，方便开发者事后查看，一般不推荐使用<code>e.pringStackTrace()</code>来打印异常日志，因为会打印到标准出错输出<code>System.err</code>中，即命令行中，这不方便保存以便反复查看。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try&#123;\n    &#x2F;&#x2F;...\n&#125;catch(IOException e)&#123;\n    log.error(&quot;...&quot;,e);\n    &#x2F;&#x2F;e.printStackTrace() 不推荐\n&#125;</code></pre></li>\n<li><p>每个异常的stackTrace栈追踪消息都是一直到main函数的，不可以只记录生命周期内的函数，因为stackTrace栈追踪信息是在异常创建时生成的，在打印异常时，异常的声明周期未必就一定结束，所以无法只填充生命周期内所经历的函数。</p>\n</li>\n<li><p>因为大多情况下都需要调用日志框架来打印异常调用链，把所有异常的栈追踪信息都打印出来，显然是比较耗时的</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"8-异常最佳实践\"><a href=\"#8-异常最佳实践\" class=\"headerlink\" title=\"8.异常最佳实践\"></a>8.异常最佳实践</h4><ol>\n<li><p>对于业务异常，没必要记录stackTrace栈追踪信息，只需要将一些有用的信息，记录在异常的detailMessage成员变量中即可，比如对于UserNotExistingException这个业务异常，只需要记录不存在的用户的ID即可。</p>\n</li>\n<li><p>怎么创建不包含栈追踪信息的异常：Throwable有一个特殊的构造函数，可以用来禁止在创建异常的同时调用fillStackTrace()函数，只需要自定义异常时，调用父类Throwable的这个构造函数并且将writableStackTrace赋值为false即可。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Throwable(String message, Throwable cause,\n                    boolean enableSuppression,\n                    boolean writableStackTrace) &#123;\n    if (writableStackTrace) &#123;\n        fillInStackTrace();\n    &#125; else &#123;\n        stackTrace &#x3D; null;\n    &#125;\n    detailMessage &#x3D; message;\n    this.cause &#x3D; cause;\n    if (!enableSuppression)\n        suppressedExceptions &#x3D; null;\n&#125;\n&#x2F;&#x2F;使用，可以解决高并发下程序中大量业务异常导致的程序变慢的问题\npublic class UserNotExistingException extends Throwable&#123;\n    public UserNotExistingException() &#123;\n        super(null,null,true,false);\n    &#125;\n\n    public UserNotExistingException(String message) &#123;\n        super(message,null,true,false);    &#125;\n\n    public UserNotExistingException(String message, Throwable cause) &#123;\n        super(message,cause,true,false);\n    &#125;\n\n    public UserNotExistingException(Throwable cause) &#123;\n        super(null,cause,true,false);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"8-IO\"><a href=\"#8-IO\" class=\"headerlink\" title=\"8.IO\"></a>8.IO</h3><h4 id=\"1-io类库\"><a href=\"#1-io类库\" class=\"headerlink\" title=\"1.io类库\"></a>1.io类库</h4><h5 id=\"1-io类库整体结构\"><a href=\"#1-io类库整体结构\" class=\"headerlink\" title=\"1.io类库整体结构\"></a>1.io类库整体结构</h5><ol>\n<li><p>java的I/O库包括io类库和nio类库，如下是java的io类库的总览</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220605084620758-165468719667765-165668658181122.png\" alt=\"image-20220605084620758\"></p>\n</li>\n<li><p>使用规律：</p>\n<ul>\n<li>明确要操作的数据是数据源还是数据目的（要读还是要写）+要操作的数据是字节还是字符：<ul>\n<li>输入（读）：InputStream （字节）、Reader（字符）</li>\n<li>输出（写）：OutputStream（字节）、Writer（字符）</li>\n</ul>\n</li>\n<li>明确数据存在的具体设备：<ul>\n<li>硬盘：文件File开头</li>\n<li>内存：数组(CharArrayxxx)、字符串(Stringxxx)、字节（ByteArrayxxx）</li>\n<li>键盘/屏幕：System.in、System.out、System.err</li>\n<li>网络：Socket</li>\n<li>管道：Pipedxxx</li>\n</ul>\n</li>\n<li>明确是否需要额外的功能<ul>\n<li>需要转换（字符流通向字符的桥梁）：InputStreamReader、OutputStreamWriter</li>\n<li>需要高效（缓冲流，用来包装别的类）：Bufferedxxx</li>\n<li>多个源（序列流）：SequenceInputStream</li>\n<li>保证数据的输出形式（打印流）：PrintStream、PrintWriter</li>\n<li>操作基本数据，保证字节原样性：DataOutputStream、DataInputStream</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"2-输入流和输出流\"><a href=\"#2-输入流和输出流\" class=\"headerlink\" title=\"2.输入流和输出流\"></a>2.输入流和输出流</h5><ol>\n<li><p>按照数据流向可以分为：</p>\n<ol>\n<li>输入流：InputStream、Reader<ul>\n<li>将File、Network、标准输入System.in、管道中的数据输入到内存中。</li>\n</ul>\n</li>\n<li>输出流：OutputStream、Writer<ul>\n<li>将内存中的数据输出到File、Network、标准输出System.out和System.err、管道中</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>使用方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;输入流\ntry (InputStream inputStream &#x3D; new FileInputStream\n     (&quot;C:\\code\\AlgorithmLearning\\src\\main\\java\\ioLearning\\1.txt&quot;)) &#123;\n    byte[] data &#x3D; new byte[1024];\n    while (inputStream.read(data) !&#x3D; -1)&#123;\n        &#x2F;&#x2F;处理data数组\n    &#125;\n&#125; catch (FileNotFoundException e) &#123;\n    e.printStackTrace();\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n&#x2F;&#x2F;输出流\nOutputStream outputStream &#x3D; new FileOutputStream\n    (&quot;C:\\code\\AlgorithmLearning\\src\\main\\java\\ioLearning\\2.txt&quot;);\nbyte[] data &#x3D; new byte[1024];\noutputStream.write(data);</code></pre></li>\n</ol>\n<h5 id=\"3-字节流和字符流\"><a href=\"#3-字节流和字符流\" class=\"headerlink\" title=\"3.字节流和字符流\"></a>3.字节流和字符流</h5><ol>\n<li>按照数据流的读写单位分为：<ol>\n<li>字节流：InputStream、OutputStream<ul>\n<li>一个字节一个字节的从输入流读取数据或者将数据写入输出流</li>\n</ul>\n</li>\n<li>字符流：Reader、Writer<ul>\n<li>一个字符一个字符的从输入流中读取数据或者将数据写入输出流</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>字符流比字节流多了一个字符编码转换的环节<ol>\n<li>Java中的char类型数据使用UTF-16编码，而文件的编码方式有可能是UTF-8、GBK等，所以，当从文件中读取数据到Java内存中的char数组时，我们需要将其从文件的编码方式转换为UTF-16编码方式，写入同理。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"4-原始库和装饰类库\"><a href=\"#4-原始库和装饰类库\" class=\"headerlink\" title=\"4.原始库和装饰类库\"></a>4.原始库和装饰类库</h5><ol>\n<li><p>java.io类库的设计用到了设计模式中的装饰器模式，从这个角度，我们可以将java.io类库中的类分为原始类和装饰器类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n  void f();\n&#125;\npublic class A implements IA &#123;\n  public void f() &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class ADecorator implements IA &#123;\n  private IA a;\n  public ADecorator(IA a) &#123;\n    this.a &#x3D; a;\n  &#125;\n  \n  public void f() &#123;\n    &#x2F;&#x2F; 功能增强代码\n    a.f();\n    &#x2F;&#x2F; 功能增强代码\n  &#125;\n&#125;</code></pre></li>\n<li><p>装饰器类是对原始类的增强，不能独立使用，使用方式如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">InputStream in &#x3D; new FileInputStream(&quot;...&quot;);\nInoutStream bin &#x3D; new BufferedInputStream(in);\nbyte[] data &#x3D; new byte[1024];\nwhile(bin.read(data) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;处理data数组\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"5-原始类分类介绍\"><a href=\"#5-原始类分类介绍\" class=\"headerlink\" title=\"5.原始类分类介绍\"></a>5.原始类分类介绍</h5><ol>\n<li><p>文件：跟文件读写相关的类有：FileInputStream、FileOutputStream、FileReader、FileWriter</p>\n</li>\n<li><p>网络：</p>\n<ol>\n<li><p>java.io类库并没有提供专门的类用于网络I/O的读写，而是直接复用InputStream类、OutputStream类进行网络I/O的读写。除此之外，还需要java.net类库的配合，java.net类库用来管理网络连接，比如创建连接、关闭连接、监听连接等。java.io类库中只负责读写已经建立的网络连接，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Socket socket &#x3D; new Socket(&quot;127.29.2.4&quot;,8090);\nOutputStream out &#x3D; socket.getOutputStream();\nout.write(&quot;hi&quot;.getBytes());\n\nInputStream in &#x3D; socket.getInputStream();\nbyte[] data &#x3D; new byte[1024];\nwhile(in.read(data) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;do something\n&#125;</code></pre></li>\n<li><p>InputStream、OutputStream是所有字节流类的父类，它既可以读写文件，也可以读写网路，还可以读写其它I/O，这充分体现了“抽象”的设计思想，尽管深入硬件层面，各个I/O设备的读写方式各不相同，但是，上层应用开发并不关心底层实现细节，大部分I/O设备的访问都可以抽象为打开、读、写、关闭等几个操作，因此，Java将所有的I/O设备都抽象为Stream（流），并未不同的I/O设备的读写设计了一套统一的接口，从而对于不同I/O设备的读写，我们可以用同样的代码实现，代码更加统一、简洁。</p>\n</li>\n</ol>\n</li>\n<li><p>内存</p>\n<ol>\n<li><p>跟内存读写相关的类有：ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter、StringReader、StringWriter</p>\n</li>\n<li><p>在大部分情况下，我们都不需要这种内存读写类，直接对byte数组，char数组进行读写即可，没必要将它们封装成流来操作，使用情景如下：</p>\n<ol>\n<li><p>实现兼容：例如，当调用第三方类库中的某个函数来处理byte数组中的数据时，但这个函数的入参是InputStream类型的，那么就需要将待处理byte数组封装成ByteArrayInputStream对象，在传递给这个函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">byte[] source &#x3D; &quot;测试数据&quot;.getBytes();\nInputStream in &#x3D; new ByteArrayInputStream(source);\n&#x2F;&#x2F;用in代替source继续处理</code></pre></li>\n<li><p>在编写单元测试时，这些内存读写类也非常有用，可以替代文件或网路，将测试数据内置于内存，准备起来更加容易，即可以直接在内存中构建测试数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;待测试函数\npublic int readFromFIle(InputStream inputStream)&#123;...&#125;\n\n&#x2F;&#x2F;测试代码\npublic void test_readFromFile()&#123;\n    byte[] testData &#x3D; new byte[512];\n    &#x2F;&#x2F;构建测试数据，填入testData数组\n    InputStream in &#x3D; new ByteInputStream(testData);\n    int res &#x3D; readFromFile(in);\n    &#x2F;&#x2F;assert 判断返回值是否符合预期\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>管道</p>\n<ol>\n<li><p>跟读写管道相关的类有：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter，不同于Unix中的管道（进程间通信），这里的管道是Java提供的为同一个进程内的两个线程之间通信的工具，一个线程通过PipedOutputStream写入的数据，另一个线程就可以通过PipedInputStream读取数据</p>\n</li>\n<li><p>示例代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">PipedOutputStream out &#x3D; new PipedOutputStream();\ntry &#123;\n    PipedInputStream in &#x3D; new PipedInputStream(out);\n    new Thread(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            try &#123;\n                out.write(&quot;Hi Dajunnnnnn&quot;.getBytes());\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;).start();\n    new Thread(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            byte[] buffer &#x3D; new byte[512];\n            try &#123;\n                in.read(buffer);\n                System.out.println(new String(buffer));\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;).start();\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>标准输入输出：</p>\n<ol>\n<li>操作系统中，一般会有三个标准I/O系统：标准输入、标准输出、标准错误输出。<ol>\n<li>System.in是一个定义在System类中的静态InputStream对象</li>\n<li>System.out和System.err都是定义在System类中的PrintStream对象。PrintStream为装饰器类，需要嵌套OutputStream来使用，支持按照格式输出数据（System.err显示的字符串为红色，以表示出错）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"6-装饰器类分类介绍\"><a href=\"#6-装饰器类分类介绍\" class=\"headerlink\" title=\"6.装饰器类分类介绍\"></a>6.装饰器类分类介绍</h5><ol>\n<li><p>支持读写缓存功能的装饰器类</p>\n<ol>\n<li>主要有BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</li>\n<li>对比InputStream，BufferedInputStream会在内存中维护一个8192字节大小的缓存，如果缓存中没有足够的数据，那么read()函数会从I/O设备中读取8192个字节存储到缓存中，然后read()函数再从缓存中返回需要的数据量。如果缓存中有足够多的数据，read()函数直接从缓存中读取数据，而不会触发真正I/O操作，可以减少I/O操作的次数，但是如果每次请求的数据量大于等于8192字节，那么BufferedInputStream就不起作用了。</li>\n<li>同理OutputStream用于缓存写入I/O设备中的数据，当积攒到一定量（默认为8192字节），再一次性将其写入I/O设备，减少I/O操作的次数，提高程序的性能。</li>\n</ol>\n</li>\n<li><p>支持基本类型数据读写的装饰器类</p>\n<ol>\n<li><p>DataInputStream支持将输入流中读取的数据解析为基本类型（byte、char、short、int、float、double等），DataOutputStream类支持将基本类型数据转化为字节数组写入输出流。</p>\n</li>\n<li><p>示例代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DataOutputStream out &#x3D; new DataOutputStream(new FileOutputStream(&quot;...&quot;));\nout.writeInt(12);\nout.writeChar(&quot;a&quot;);\nout.writeFloat(12,12f);\nout.close();\n\nDataIntputStream in &#x3D; new DataInputStream(new FileInputStream(&quot;...&quot;));\nSystem.out.println(in.readInt());\nSystem.out.println(in.readChar());\nSystem.out.println(in.readFloat());\nin.close();</code></pre></li>\n<li><p>readChar()、writeChar()也可以按字符为单位读取、写入数据，但是，DataInputStream一次只能处理一个字符，而字符流可以处理char数组，并且字符流提供的函数更多，功能更丰富</p>\n</li>\n</ol>\n</li>\n<li><p>支持对象读写的装饰器类：</p>\n<ol>\n<li><p>ObjectInputStream支持将从输入流中读取到的数据反序列化为对象，ObjectOutputStream支持将对象序列化之后写入到输出流</p>\n</li>\n<li><p>示例代码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ObjectOutputStream out &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;.&quot;));\nout.writeObject(new Person(12,&quot;Dajunnnnnn&quot;));\n\nObjectInputStream in &#x3D; new ObjectInputStream(new FileInputStream(&quot;.&quot;));\nPerson p &#x3D; (Person) in.readObject();</code></pre></li>\n</ol>\n</li>\n<li><p>支持格式化打印数据的装饰器类:</p>\n<ol>\n<li><p>PrintStream和PrintWrite可以将数据按照一定的格式，转化为字符串，写入到输出流。前面讲到System.out、System.err就是PrintStream类型的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">PrintStream printStream &#x3D; new PrintStream(new FileOutputStream(&quot;..&quot;));\nprintStream.print(124);&#x2F;&#x2F;int-&gt;Integer-&gt;toString(),写入字符串“124”\nprintStream.print(&quot;hello %d&quot;,43);&#x2F;&#x2F;写入字符串“hello 43”</code></pre></li>\n</ol>\n</li>\n<li><p>除了以上装饰器类之外，还有一组原始类，其功能非常类似装饰器类，那就是InputStreamReader、OutputStreamWriter。InputStreamReader可以充当InputStream的装饰器类，OutputStreamWriter可以充当OutputStream的装饰器类。它们可以将字节流转化为字符流。示例代码如下所示。从这一点上，我们也可以看出，java.io类库的设计有很多不合理的地方，更晚开发的java.nio类库在设计上明显要合理很多。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">OutputStream outStream &#x3D; new FileOutputStream(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;a.txt&quot;);\nOutputStreamWriter writer &#x3D; new OutputStreamWriter(outStream, &quot;gbk&quot;);\nwriter.write(&quot;王a争&quot;); &#x2F;&#x2F;按照gbk编码将字符串写入文件</code></pre></li>\n</ol>\n<h4 id=\"2-nio类库\"><a href=\"#2-nio类库\" class=\"headerlink\" title=\"2.nio类库\"></a>2.nio类库</h4><h5 id=\"1-java-nio类库\"><a href=\"#1-java-nio类库\" class=\"headerlink\" title=\"1.java.nio类库\"></a>1.java.nio类库</h5><ol>\n<li><p>JDK1.4引入，也称：New I/O、Non-blocking I/O、Network I/O。一般情况使用java.io，在网络编程中大多使用java.nio</p>\n</li>\n<li><p>java.io中所有的I/O都抽象为Stream，java.nio中引入Channel代替Stream，并且引入新的概念：Buffer，用来存储待写入或读取的数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">FileChannel channel &#x3D; FileChannel.open(Paths.get(&quot;...&quot;));\nByteBuffer buffer &#x3D; ByteBuffer.allocate(512);\nwhile(channel.read(buffer) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;处理buffer中的数据data\n&#125;</code></pre></li>\n<li><p>核心概念</p>\n<ol>\n<li><p>Buffer：</p>\n<ol>\n<li>本质上就是一块内存，就相当于java.io申请的byte数组，常见的Buffer有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer、MappedByteBuffer，不同之处在于解析数据的方式不同</li>\n<li>java.io有字节流解析和字符流解析，java.nio将这些部分抽取出来，独立到Buffer类中，不同的Channel跟不同的Buffer组合在一起，可以实现不同的IO读写需求。</li>\n</ol>\n</li>\n<li><p>同步Channel：</p>\n<ol>\n<li>常用的Channel有FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel用于文件读写，其余三个用于网络编程，其中DatagramChannel用于读写UDP数据，SocketChannel和ServerSocketChannel用于读写TCP数据，ServerSocketChannel用于服务器编程，可以使用accept()函数监听客户端SocketChannel的连接请求。</li>\n<li>java.nio中的Channel即可以读也可以写，每个Channel类通过实现不同的接口组合，来支持不同的功能组合<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/424900_1654187538-165468719667766-165668658181223.png\" alt=\"img\"></li>\n<li>Channel有两种运行方式：阻塞和非阻塞方式，其中除FileChannel只支持阻塞模式外，其余三个都同时支持两种方式，默认为阻塞方式，可以调用configureBlocking(false)函数将其设置为非阻塞模式，非阻塞Channel一般会配合Selector，用于实现多路复用I/O模型。<ul>\n<li>阻塞模式与非阻塞模式：线程在调用read()或write()函数对I/O进行读写时，如果I/O不可读或者不可写（待会解释这两个的意思），那么，在阻塞模式下，read()或write()函数会等待，直到读取到数据或者写入完成时才会返回，在非阻塞模式下，read()或write()函数会直接返回，并报告读取或写入未成功。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>Selector：</p>\n<ol>\n<li><p>在网络编程中，使用非阻塞模式，线程需要通过while循环，不停轮询调用read()、write()、accept()函数，查看是否有数据可读，是否可写，是否有客户端连接到来</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SeverSocketChannel serverChannel &#x3D; ServerSocketChannel.open();\nserverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,1192));\nserverChannel.configureBlocking(false);\nByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n\nSocketChannel clinetChannel &#x3D; null;\nwhile(clinetChannel &#x3D;&#x3D; null)&#123;\n    clientChannel &#x3D; serverChannel.accept();\n&#125;\n\nwhile(clientChannel.read(buffer) &#x3D;&#x3D; -1);\n\nbuffer.flip();&#x2F;&#x2F;将buffer从用于读变成用于写\nwhile(buffer.hasRemaining())&#123;\n    clientChannel.write(buffer);&#x2F;&#x2F;echo,读了啥就写啥\n&#125;</code></pre></li>\n<li><p>多路复用I/O用来解决while轮询的问题，为了实现多路复用，Unix提供了epoll库、Windows提供了iocp库、BSD提供了kequeue库，Java作为一种跨平台语言，对不同操作系统的实现进行了封装，提供了统一的Selector，可以将需要监听的Channel，调用registor()函数，注册到Selector中，Selector底层会通过轮询的方式，查看哪些Channel可读、可写、可连接等，并将其返回处理。</p>\n</li>\n</ol>\n</li>\n<li><p>异步Channel：</p>\n<ol>\n<li>尽管使用Selector可以避免开发者手写轮询代码，但是Selector底层仍然依赖轮询来实现，在JDK7中，java.nio类库做了升级，引入了支持异步模式的Channel，主要包括：AdynchronousFileChannel、AsynchronousSocketChannel、AsynchronousServerSocketChannel</li>\n<li>在异步模式下，Channel不再注册到Selector，而是注册到操作系统内核中，由内核来通知某个Channel可读、可写或可连接，java.nio收到通知之后，为了不阻塞主线程，会使用线程池去执行事先注册的回调函数。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-Java-IO模型（网络）\"><a href=\"#2-Java-IO模型（网络）\" class=\"headerlink\" title=\"2.Java IO模型（网络）\"></a>2.Java IO模型（网络）</h5><ol>\n<li><p>阻塞I/O模型（BIO）</p>\n<ol>\n<li><p>利用阻塞模式搭配多线程来实现服务器，因为服务器需要连接大量客户端，因为read()函数是阻塞函数，所以，为了实现接受客户端发来的数据，服务器需要创建大量线程，每个线程负责等待读取一个客户端的数据。因为java.io支持阻塞模式，java.nio既支持阻塞模式也支持非阻塞模式，所以都可以实现阻塞I/O模型。</p>\n</li>\n<li><p>示例代码：如果有n个客户端连接服务器，那么服务器需要创建n+1个线程，其中n个线程用于调用read()函数，除此之外，因为accept()函数也是阻塞函数，所以也独占一个线程。当连接的客户端非常多时，服务器需要创建大量线程，而每个线程会分配一个线程栈，需要占用一定的内存空间。当线程比较多时，内存资源的消耗就会比较大。大量线程来回切换，什么都不做但又要白白占用内存和线程资源，非常浪费。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket serverSocket &#x3D; new ServerSocket();\n        serverSocket.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        while (true) &#123;\n            &#x2F;&#x2F; accept()为阻塞函数，直到有连接到来才返回\n            Socket clientSocket &#x3D; serverSocket.accept();\n            &#x2F;&#x2F; 为了每个客户端单独创建一个线程处理\n            new Thread(new ClientHandler(clientSocket)).start();\n        &#125;\n    &#125;\n\n    private static class ClientHandler implements Runnable &#123;\n        private Socket socket;\n        public ClientHandler(Socket socket) &#123;\n            this.socket &#x3D; socket;\n        &#125;\n\n        @Override\n        public void run() &#123;\n            byte[] data &#x3D; new byte[1024];\n            while (true) &#123; &#x2F;&#x2F;持续接收客户端发来的数据\n                try &#123;\n                    &#x2F;&#x2F; read()为阻塞函数，直到读取到数据再返回\n                    socket.getInputStream().read(data);\n                    &#x2F;&#x2F; write()为阻塞函数，全部写完成才会返回\n                    socket.getOutputStream().write(data); &#x2F;&#x2F;echo\n                &#125; catch (IOException e) &#123;\n                    &#x2F;&#x2F; log and exit\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>非阻塞I/O模型（NIO）</p>\n<ol>\n<li><p>非阻塞模型利用非阻塞模式和Selector多路复用器来开发服务器，也叫做多路复用I/O模型</p>\n</li>\n<li><p>示例代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F; Selector\n        Selector selector &#x3D; Selector.open();\n\n        &#x2F;&#x2F; create serverChannel and register to selector\n        ServerSocketChannel serverChannel &#x3D; ServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        serverChannel.configureBlocking(false);\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n        while (true) &#123;\n            int channelCount &#x3D; selector.select();\n            if (channelCount &gt; 0) &#123;\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n                Iterator&lt;SelectionKey&gt; iterator &#x3D; keys.iterator();\n                while (iterator.hasNext()) &#123;\n                    SelectionKey key &#x3D; iterator.next();\n                    if (key.isAcceptable()) &#123;\n                        &#x2F;&#x2F; create clientChannel and register to selector\n                        SocketChannel clientChannel &#x3D; \n                            serverChannel.accept();\n                        clientChannel.configureBlocking(false);\n                        clientChannel.register\n                            (selector, SelectionKey.OP_READ);\n                    &#125; else if (key.isReadable()) &#123;\n                        SocketChannel clientChannel &#x3D; \n                            (SocketChannel) key.channel();\n                        clientChannel.read(buffer);\n                        buffer.flip(); &#x2F;&#x2F;从&quot;用于读&quot;变为&quot;用于写&quot;\n                        if (buffer.hasRemaining())&#123;&#x2F;&#x2F;也可以注册到selector中\n                            clientChannel.write(buffer); &#x2F;&#x2F;echo\n                        &#125;\n                        buffer.clear(); &#x2F;&#x2F;重复利用\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>在NioEchoServer类中，如果有n可客户端连接服务器，那么就会创建n+1个Channel，其中一个serverChannel用于接受客户端的连接，另外n个clientChannel用于与客户端进行通信。这n+1个Channel均注册到Selector中。Selector会间隔一定时间轮训这n+1个Channel，查找可连接、可读、可写的Channel，然后再进行连接、读取、写入操作。</p>\n</li>\n<li><p>大部分情况下，我们都不需要监听Channel是否可写，毕竟网络写入跟文件写入类似，大部分情况下都不需要等待。只有当写入出现问题时，比如write()函数返回0，表示网络拥塞，此时才需要如下代码所示，将Channel注册到Selector中，等待可写。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">clientChannel.register(selector, SelectionKey.OP_WRITE);</code></pre></li>\n<li><p>只有实现了SelectableChannel接口的Channel才可以注册到Selector中被监听，比如DatagramChannel、SocketChannel、ServerSocketChannel。FileChannel无法被Selector监听</p>\n</li>\n<li><p>多路复用I/O模型：只需要一个线程即可，解决了阻塞I/O模型线程开销大的问题。但是如果某些clientChannel耗时比较久，那么其它clientChannel便需要阻塞，使得服务器响应的延迟变高，但可以用过线程池中取线程来处理，而不是所有的clientChannel都在一个线程中处理。跟非阻塞I/O的区别在于不管有没有数据可读，阻塞I/O模型中的每个clientSocket都会一直占用线程。而这里的多线程只会处理经过Selector筛选之后有可读数据的clientChannel，并且处理完之后就释放回线程池，线程的利用率更高。</p>\n</li>\n</ol>\n</li>\n<li><p>异步I/O模型（AIO）</p>\n<ol>\n<li><p>通过异步Channel调用accept()、read()、write()函数。当有连接建立、数据读取完成、数据写入完成时，底层会通过线程池执行对应的回调函数。这种服务器的实现方式叫做异步I/O模型。</p>\n</li>\n<li><p>示例代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AioEchoServer &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        AsynchronousServerSocketChannel serverChannel &#x3D; AsynchronousServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        &#x2F;&#x2F; 异步accept()\n        serverChannel.accept(null, new AcceptCompletionHandler(serverChannel));\n        Thread.sleep(Integer.MAX_VALUE);\n    &#125;\n\n    private static class AcceptCompletionHandler\n        implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;\n        private AsynchronousServerSocketChannel serverChannel;\n        public AcceptCompletionHandler(AsynchronousServerSocketChannel serverChannel) &#123;\n            this.serverChannel &#x3D; serverChannel; \n        &#125;\n\n        @Override\n        public void completed(AsynchronousSocketChannel clientChannel, Object attachment) &#123;\n            &#x2F;&#x2F; in order to accept other client&#39;s connections\n            serverChannel.accept(attachment, this);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n            &#x2F;&#x2F; 异步read()\n            clientChannel.read(buffer, buffer, new ReadCompletionHandler(clientChannel)); \n        &#125;\n\n        @Override\n        public void failed(Throwable exc, Object attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n\n    private static class ReadCompletionHandler \n        implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private AsynchronousSocketChannel clientChannel;\n        public ReadCompletionHandler(AsynchronousSocketChannel clientChannel) &#123;\n            this.clientChannel &#x3D; clientChannel;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer buffer) &#123;\n            buffer.flip();\n            &#x2F;&#x2F; 异步write()。回调函数为null，写入完成就不用回调了\n            clientChannel.write(buffer, null, null); &#x2F;&#x2F; echo\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>实际上，在平时的开发中，我们一般不会直接使用底层的ava.nio类库，而是使用Netty等框架来进行网络编程，这些框架封装了网络编程的复杂性，使用起来更加简单，开发效率更高。除了以上三种常见的I/O模型之外，实际上，还有更多更加复杂的I/O模型，比如Netty框架提供的Reactor模型。</p>\n</li>\n<li><p>在《Unix网络编程》一书中，介绍了Unix操作系统的5种I/O模型：阻塞I/O模型、非阻塞I/O模型、多路复用I/O模型、信号驱动I/O模型、异步I/O模型。实际上，不同的操作系统会提供不同的I/O模型。Java是一种跨平台语言，为了屏蔽各个操作系统I/O模型的差异，设计了3种新的I/O模型：BIO（阻塞I/O）、NIO（非阻塞I/O）、AIO（异步I/O），并且提供了I/O类库来支持这3种I/O模型的代码实现。而Java的I/O类库底层需要依赖操作系统的I/O接口（专业名称为系统调用）来实现，因此，从本质上来讲，Java I/O模型只是对操作系统I/O模型的重新封装。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"3-对比java-io与java-nio\"><a href=\"#3-对比java-io与java-nio\" class=\"headerlink\" title=\"3.对比java.io与java.nio\"></a>3.对比java.io与java.nio</h5><ol>\n<li>按照喜好或者团队的编程习惯来选择</li>\n<li>对于网络编程，首选java.nio，对于文件读写，java.io和java.nio都可以</li>\n</ol>\n<h4 id=\"3-文件（高速I-O）\"><a href=\"#3-文件（高速I-O）\" class=\"headerlink\" title=\"3.文件（高速I/O）\"></a>3.文件（高速I/O）</h4><h5 id=\"1-用户态和内核态\"><a href=\"#1-用户态和内核态\" class=\"headerlink\" title=\"1.用户态和内核态\"></a>1.用户态和内核态<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/79491300_1654417843-165668658181224.png\" alt=\"img\"></h5><ol>\n<li><strong>系统调用：</strong>操作系统内核包含各种操作硬件资源的系统调用，应用程序必须通过操作系统提供的系统调用才能访问硬件资源</li>\n<li><strong>库函数：</strong>系统调用比较底层，所以Linux又提供了库函数，比如Glibc库、Posix库，对系统调用进行封装，提供更加简单易用的函数，供应用程序开发使用，比如：Glibc中的malloc()函数封装了sbrk()系统调用，fread()、fwrite()封装了read()、write()系统调用，在开发应用程序的时候，既可以使用库函数，也可以直接使用系统调用</li>\n<li><strong>Shell：</strong>Linux还提供了Shell这一程序，即命令行，Shell能在不进行编程的情况下，通过命令行中运行Shell命令或脚本，达到访问硬件的目的，比如cp拷贝文件、rm删除文件</li>\n<li><strong>用户态&amp;内核态：</strong>为避免应用程序在运行时，访问到内核所用的内存空间，操作系统将虚拟内存分为内核空间和用户空间两部分，CPU因此有内核态和用户态两种，在内核态CPU拥有最高权限，可以执行所有的机器指令并且可以访问硬件，而且内核态能访问所有虚拟内存空间，在用户态则不能。</li>\n<li><strong>上下文切换：</strong>当应用调用操作系统的系统调用时，会涉及内核态与用户态的上下文切换，主要耗时的操作有：<ol>\n<li>寄存器保存与恢复耗时：因为内核空间不使用应用程序的函数调用栈，会分配新的函数调用栈，所以在上下文切换时需要更新更多栈相关的寄存器，比如SS栈基址寄存器。除此之外，应用程序和内核程序的代码存储位置也不同，CS代码段基址寄存器也需要更新。并且更新前会保存下来原始值，以便切换回用户态之后恢复执行</li>\n<li>缓存失效带来的性能损耗：CPU有L1、L2、L3三级Cache，用于缓存将要执行的代码以及所需的内存数据，上下文切换会导致CPU缓存失效</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-I-O读写的底层实现原理\"><a href=\"#2-I-O读写的底层实现原理\" class=\"headerlink\" title=\"2.I/O读写的底层实现原理\"></a>2.I/O读写的底层实现原理</h5><ol>\n<li>Linux操作系统下，Java的I/O类库调用open()、read()、write()系统调用来实现，通过open()返回Linux下I/O设备的文件描述符，来和I/O设备建立连接</li>\n<li>操作系统为每个文件描述符都分配一个内核读缓存区和一个内核写缓存区，内核读写缓存区只有在第一次调用read()或write()系统调用时，才会真正被分配内存空间。默认读缓冲区的大小为8192字节，写缓冲区的大小为16384字节。当然，也可以根据业务需求，通过系统调用，来重新设置</li>\n<li>在读写完成后需要调用close()系统调用</li>\n<li>Linux下读写文件的C语言代码实现如下，数据会先被放到内核读写缓存区，读缓冲区不够时才会从磁盘读取文件，写缓冲区满时才会写入到磁盘中（如果想立刻存入磁盘则需要调用sync()系统调用），这样做的原因是应用程序缓存区是应用程序维护的，内核代码无法控制其大小和生命周期，出于稳妥起见才申请了内核缓冲区，而且可以减少与I/O设备的交互次数</li>\n</ol>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;Linux下读写文件的C语言代码实现\n#include &lt;stdio.h&gt;\n#include stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys&#x2F;types.h&gt;\n#include &lt;sys&#x2F;stat.h&gt;\n#include &lt;fcntl.h&gt;\nint main (int argc, char *argv)&#123;\n    int rfd;\n    int wfd;\n    int nbytes;\n    char rfile[]&#x3D; &quot;&#x2F;users&#x2F;root&#x2F;in.txt&quot;;\n    char wfile[]&#x3D; &quot;&#x2F;users&#x2F;rootout.txt&quot;;\n    char buffer[256];&#x2F;&#x2F;应用程序缓冲区\n    rfd &#x3D; open(rfile, O_RDONLY,0666);\n    wfd &#x3D; open(wfile, o_CREAT | O_WRONLY, 0666);\n    if(rfd &lt; 0 || wfd &lt; 0)&#123;\n        printf(&quot;open file failed!\\n&quot;);\n        return -1;\n    &#125;\n    while((nbytes &#x3D; read(rfd, buf, 255)) &gt; 0)&#123;\n        write(wfd, buffer, nbytes);\n    &#125;\n    close(rfd);\n    close(wfd);\n    return 0;\n&#125;</code></pre>\n\n\n\n<h5 id=\"3-CPU减负神器之DMA技术\"><a href=\"#3-CPU减负神器之DMA技术\" class=\"headerlink\" title=\"3.CPU减负神器之DMA技术\"></a>3.CPU减负神器之DMA技术<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220610104529512-165668658181226.png\" alt=\"image-20220610104529512\"></h5><ol>\n<li>DMA(Direct Memory Access）技术：通过在主板上安装一个叫做DMAC (DMA Controller，DMA控制器)的协处理器(或叫芯片)，协助CPU来完成I/O设备的数据读写工作。随着计算机的发展，安装在计算机上的I/O设备越来越多，仅在主板上安装一个通用的DMAC已经远远不够了，因此，现在很多IO设备都自带DMAC，比如硬盘、网卡、显示器都有各自的DMAC。</li>\n<li>工作原理：DMAC替代CPU从设备中读取数据或向设备写入数据，通过中断通知CPU，CPU利用率提高了</li>\n</ol>\n<h5 id=\"4-mmap\"><a href=\"#4-mmap\" class=\"headerlink\" title=\"4.mmap\"></a>4.mmap</h5><ol>\n<li><p>mmap（memory-mapped file，内存映射文件）是提高文件读写性能的有效技术，mmap一般用于文件，像网络这种数据未知的I/O设备，不适合使用mmap。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;java.nio.FileChannel类中\npublic MappedByteBuffer map(MapMode mode , long position, long size);</code></pre></li>\n<li><p>前置知识：操作系统记录物理内存跟虚拟内存之间的映射关系，这样每个进程只需要操作虚拟内存地址即可。并且因为并不是将整个程序加载到物理内存再执行，所以如果待执行的代码没有在物理内存中，就会向操作系统发出一个缺页中断，操作系统会将带执行的代码从磁盘加载到物理内存，并会将不再执行的代码置换出物理内存</p>\n</li>\n<li><p>底层原理：通过将文件或文件中的某段映射到用户空间中的某段虚拟内存地址上，如果没加载到物理内存，则触发缺页中断；如果有脏页，操作系统自动写回磁盘或者调用msync()立即写回</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int main(void)&#123;\n    char file &#x3D; &quot;&#x2F;users&#x2F;root&#x2F;in.txt&quot;;\n    int fd &#x3D; open(file, O_RDWR,0666);\n    if(fd &lt;0)&#123;\n        printf(&quot;open file failedl\\n&quot;);\n        return -1;\n    &#125;\n    &#x2F;&#x2F;映射文件开头(offset&#x3D;0)的512字节(length&#x3D;512)到ptr\n    size_t length &#x3D; 512;\n    int offset &#x3D; 0;\n    char *ptr &#x3D; mmap(null, length, PROT_READn| PROT_WRITE, MAP_SHARED, fd , offset);\n    if (ptr &#x3D;&#x3D; MAP_FAILED)&#123;\n        printf(&quot;mmap failed.&quot;);\n        return -1;\n    &#125;\n    &#x2F;&#x2F;创建好内存映射文件之后，fd就没用了，可以释放了\n    close(fd);\n    \n    &#x2F;&#x2F;操作ptr就等同于读写文件\n    for (int i &#x3D; 0; i &lt; length; i++)&#123;\n        ptr[i] &#x3D; &#39;a&#39; +(length%26);\n    &#125;\n\n    for (int i &#x3D; 0; i &lt;N, i++)&#123;\n        printf(&quot;%c&quot;,ptr[i]);\n    &#125;\n    &#x2F;&#x2F;删除内存映射文件，释放占用的虚拟内存空间\n    munmap(ptr, length);\n    return 0;\n&#125;</code></pre></li>\n<li><p>mmap相当于直接将数据在磁盘和用户空间之间互相拷贝，相对于使用read()、write()系统调用读写文件，数据拷贝次数由2次减少为1次，并且减少了内核态和用户态上下文切换的耗时，之后读写文件就像读写内存一样</p>\n</li>\n<li><p>对于少量文件读写，使用read()、write()更合适，对于大文件的读写，一般使用mmap，并且需要一些测试来验证性能。进程间通信当两个应用程序都采用MAP_SHARED模式创建匿名的内存映射文件时，这两个应用程序会共享物理内存，一个应用程序可以读取另一个程序写入物理内存的数据，以此来实现互相通信</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">char* ptr &#x3D; mmap(NULL,length,PROT_READ | PROT_WRITE,MAP_SHARED | MAP_ANONYMOUS,-1,0);&#x2F;&#x2F;fd &#x3D; -1 </code></pre></li>\n</ol>\n<h5 id=\"5-零拷贝\"><a href=\"#5-零拷贝\" class=\"headerlink\" title=\"5.零拷贝\"></a>5.零拷贝<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220610124534798-165668658181227.png\" alt=\"image-20220610124534798\"></h5><ol>\n<li><p>mmap主要用于文件的读写这一应用场景，而零拷贝（Zero-copy）技术主要用于两个I/O设备之间互相传输数据，特别是将文件中的数据发送到网络或者将从网络接受的数据存储到文件这一场景中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;java.nio.FileChannel\npublic abstract long transferTo(long position,long count WritableByteChannel target);\npublic abstract long transferFrom(ReadableByteChannel src, long position,long count);</code></pre></li>\n<li><p>零拷贝不需要将数据拷贝到应用程序缓冲区，而是直接从内核读缓冲区拷贝到内核写缓冲区，应用程序只需要进行一次系统调用（执行sendfile()），接可以将文件发送到网络。</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys&#x2F;sendfile.h&gt;\n#include &lt;sys&#x2F;stat.h&gt;\n#include sys&#x2F;types.h&gt;\nint main (int argc, char*argv[)&#123;\n    int read_fd;\n    int write_fd;\n    struct stat stat_buf;\n    off_t offset &#x3D; o;\n    read_fd &#x3D; open (argv[1],O_RDONLY);\n    fstat (read_fd, &amp;stat_buf) ;\n    write_fd &#x3D; open (argv[2],O_WRONLY \\ O_CREAT, stat_buf.st_mode);\n    sendfile (write_fd, read_fd, &amp;offset, stat_buf.st_size);\n    close(read_fd);\n    close (write_fd);\n    return 0;\n&#125;</code></pre></li>\n<li><p>SG-DMAC（Scatter-Gatter DMA Controller）使得零拷贝再少1次数据拷贝<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220610125717587-165668658181228.png\" alt=\"image-20220610125717587\"></p>\n</li>\n</ol>\n<h3 id=\"9-特殊语法\"><a href=\"#9-特殊语法\" class=\"headerlink\" title=\"9.特殊语法\"></a>9.特殊语法</h3><h4 id=\"1-泛型\"><a href=\"#1-泛型\" class=\"headerlink\" title=\"1.泛型\"></a>1.泛型</h4><h5 id=\"1-为什么使用泛型\"><a href=\"#1-为什么使用泛型\" class=\"headerlink\" title=\"1.为什么使用泛型\"></a>1.为什么使用泛型</h5><ol>\n<li><p>泛型语法：可以编写出更通用的代码，而且可以提前在编译时做类型检查，保证类型的安全性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Stack&lt;E&gt; &#123;\n    private Object[]arr;&#x2F;&#x2F;这里不是T[arr;原因稍后解释\n    private int top;\n    private int size;\n    \n    public Stack(int size) &#123;\n        this.arr &#x3D; new Object[size];\n        this.size &#x3D; size,\n        this.top &#x3D; o;\n    &#125;\n    public void push(E elem) &#123;\n        if (top &#x3D;&#x3D; size) return;\n        arr[top++] &#x3D; elem;\n    &#125;\n    public E pop() &#123;\n        if (top &#x3D;&#x3D; 0) return null;\n        return (E) arr[--top];\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"2-泛型的基本用法\"><a href=\"#2-泛型的基本用法\" class=\"headerlink\" title=\"2.泛型的基本用法\"></a>2.泛型的基本用法</h5><ol>\n<li><p>使用方式</p>\n<ul>\n<li>尖括号内表示类型参数：E（容器中的元素的类型参数）、T（非容器元素的数据类型参数）、K,V（键值对中键和值的类型参数）、N（数字类型参数）</li>\n<li>使用extends上界限定符，例如&lt;T extends Person&gt;，必须传入Person或者其子类</li>\n<li>没有implements，例如&lt;T extends Closable&gt;，表示限定传入类型参数的具体类型必须实现了Closable接口</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;泛型接口\npublic interface List&lt;E&gt; &#123;\n    void add(E element);\n    E get(int index);\n    &#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;泛型类\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    private Object[]arr;&#x2F;&#x2F;这里不是T[]arr;原因稍后解释\n    public void add(E element) &#123; ...&#125;\n    public E get(int index) &#123; ...&#125;\n\t&#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F;泛型方法\npublic class Collections &#123;\n    public static &lt;T&gt; int binarySearch(List&lt;T&gt; list, T key);\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li></li>\n</ol>\n<h5 id=\"3-泛型中的通配符（-）\"><a href=\"#3-泛型中的通配符（-）\" class=\"headerlink\" title=\"3.泛型中的通配符（?）\"></a>3.泛型中的通配符（?）</h5><ol>\n<li><p>通配符跟类型参数的应用场景并不相同，类型参数一般用于定义泛型类、泛型接口和泛型方法，而通配符跟Integer、Person、String这些具体类型无异，用来具体化泛型类或泛型接口，可以看做一种特殊的具体类型。当我们在具体化某个泛型类或泛型接口，但又无法指明明确的具体类型时，我们就可以使用通配符这种特殊的具体类型</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Collections&#123;\n    &#x2F;&#x2F; 不需要有类型参数声明\n    public static void reverse(List&lt;?&gt; list)&#123;...&#125;\n    &#x2F;&#x2F; 泛型方法\n    &#x2F;&#x2F; public static &lt;T&gt; void reverse(List&lt;T&gt; list)&#123;...&#125;\n&#125;</code></pre></li>\n<li><p><code>&lt;? extends Person&gt;</code>或<code>&lt;T extends Person&gt;</code>，extends上界限定符可用于类型参数或者通配符，表示传入通配符是Person或者Person的子类</p>\n</li>\n<li><p><code>&lt;? super Person&gt;</code>，super下界限定符只用于通配符，表示传入通配符是Person或者Person的父类</p>\n</li>\n<li><p><code>&lt;? extends T&gt;</code>或<code>&lt;? super T&gt;</code>，通配符可以extends或super类型参数，但类型参数不可以etends或super类型参数<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220610152000137-165668658181229.png\" alt=\"image-20220610152000137\"></p>\n</li>\n</ol>\n<h5 id=\"4-泛型中的类型擦除\"><a href=\"#4-泛型中的类型擦除\" class=\"headerlink\" title=\"4.泛型中的类型擦除\"></a>4.泛型中的类型擦除</h5><ol>\n<li>底层原理：泛型只不过是一个语法糖，在编译时，编译器会使用泛型做类型检查，但是，当代码编译为字节码之后，泛型中的类型参数和通配符统统替换成上界，比如&lt;T&gt;替换为Object，<code>&lt;T extends String&gt;</code>替换为String，这种实现方式叫做类型擦除</li>\n<li>因为Java泛型的类型擦除，不能使用new T()来创建类型参数对象，在代码编译成字节之后类型信息已经擦除，所以，在运行时，JVM无法确定具体类型，也就无法知道T是否存在无参构造函数，所以也就无法使用new来创建T对象了，这也是为什么前面实现Stack泛型类中使用Object来定义arr数组的原因。</li>\n<li>因为需要继承自Object，所以基本类型不可以传入类型参数，只有引用类型可以。但是有语法糖可以让<code>List&lt;int&gt;</code>中的int替换为Integer，但是开发上依旧需要为每个基本类型分别定义多个不同的函数接口</li>\n</ol>\n<h4 id=\"2-反射\"><a href=\"#2-反射\" class=\"headerlink\" title=\"2.反射\"></a>2.反射</h4><h5 id=\"1-反射的作用\"><a href=\"#1-反射的作用\" class=\"headerlink\" title=\"1.反射的作用\"></a>1.反射的作用</h5><ol>\n<li><strong>创建对象：</strong><ol>\n<li>一般使用new语句来创建对象，但是如果想要在代码的运行过程中，根据配置、输入、执行结果等，动态创建一些额外的对象，这个时候就需要用到反射动态地告知JVM去创建某个类的对象</li>\n<li>不管是new还是反射，对象的创建都是在运行时进行的，不过申请创建对象的时机却是不同的。通过new来创建对象，其创建对象的需求是在代码编写时确定的（静态申请对象创建）；而通过反射来创建对象，其创建对象的需求是在运行时确定的（动态申请对象创建）</li>\n</ol>\n</li>\n<li><strong>执行方法：</strong>除动态申请对象创建之外，程序还可以动态申请执行方法。一般程序会执行哪些方法都是在代码编写的时候确定的；但是在运行时，额外申请新的要执行的方法就需要靠反射来实现（动态代理就是依赖反射动态执行方法来实现的）</li>\n<li><strong>区别：</strong>不管是反射创建对象还是执行方法，跟普通的对象创建和方法执行，本质上没有太大区别，只不过是告知JVM的时机和方式不同而已</li>\n<li><strong>获取类信息：</strong>除了创建对象、执行方法之外，反射还能够获取对象的类信息，包括类中的构造函数、方法、成员变量。（注解就是依赖反射的这个作用）</li>\n</ol>\n<h5 id=\"2-反射的用法\"><a href=\"#2-反射的用法\" class=\"headerlink\" title=\"2.反射的用法\"></a>2.反射的用法</h5><ol>\n<li><p>Class类</p>\n<ol>\n<li><p>与class关键字无关，是一个存储类的信息的特殊的类，提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等</p>\n</li>\n<li><p>获取类信息主要方法如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;获取类信息\npublic static Class&lt;?&gt; forName(String className);\n\n&#x2F;&#x2F;获取类名\npublic String getName();\npublic String getSimpleName();\n&#x2F;&#x2F;获取父类信息\npublic native Class&lt;? super T&gt; getSuperclass();\n&#x2F;&#x2F;获取package信息\npublic Package getPackage();\n\n&#x2F;&#x2F;获取接口信息\npublic Class&lt;?&gt;[]getlnterfaces();\n\n&#x2F;&#x2F;获取成员的变量，包含私有成员变量，不包含父类成员变量\npublic Field[] getDeclaredFields();\npublic Field getDeclaredField(String name);\n&#x2F;&#x2F;获取成员变量，只包含公有成员变量，包含父类成员变量\npublic Field[] getFields();\npublic Field getField(String name);\n&#x2F;&#x2F;获取类的方法，包括私有方法，不包含父类方法\npublic Method[] getDeclaredMethods();\npublic Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);\n&#x2F;&#x2F;获取类的方法，只包含公有方法，包含父类方法\npublic Method getMethods();\npublic Method getMethod(String name,Class&lt;?&gt;...parameterTypes);\n\n&#x2F;&#x2F;获取构造函数，只包含公共构造函数\npublic Constructor&lt;?&gt;[]getConstructors();\npublic Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes);\n&#x2F;&#x2F;获取构造函数，包含私有构造函数\npublic Constructor[] getDeclaredConstructors();\npublic Constructor getDeclaredConstructor(Class... parameterTypes);\n\n&#x2F;&#x2F;获取类上的注解\npublic Annotation[] getAnnotations();</code></pre>\n\n<ul>\n<li><p>使用方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.ys.reflex;\npublic class Person &#123;\n    &#x2F;&#x2F;私有属性\n    private String name &#x3D; &quot;Tom&quot;;\n    &#x2F;&#x2F;公有属性\n    public int age &#x3D; 18;\n    &#x2F;&#x2F;构造方法\n    public Person() &#123;\n    &#125;\n    &#x2F;&#x2F;私有方法\n    private void say()&#123;\n        System.out.println(&quot;private say()...&quot;);\n    &#125;\n    &#x2F;&#x2F;公有方法\n    public void work()&#123;\n        System.out.println(&quot;public work()...&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;1、通过对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object\n&#x2F;&#x2F;  类型的对象，而我不知道你具体是什么类，用这种方法\nPerson p1 &#x3D; new Person();\nClass c1 &#x3D; p1.getClass();\n\n&#x2F;&#x2F;2、直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高\n&#x2F;&#x2F;  这说明任何一个类都有一个隐含的静态成员变量 class\nClass c2 &#x3D; Person.class;\n\n&#x2F;&#x2F;3、通过 Class 对象的 forName() 静态方法来获取，用的最多，\n&#x2F;&#x2F;   但可能抛出 ClassNotFoundException 异常\nClass c3 &#x3D; Class.forName(&quot;com.ys.reflex.Person&quot;);\n\n&#x2F;&#x2F;获得类完整的名字\nString className &#x3D; c2.getName();\nSystem.out.println(className);&#x2F;&#x2F;输出com.ys.reflex.Person\n\n&#x2F;&#x2F;获得类的public类型的属性。\nField[] fields &#x3D; c2.getFields();\nfor(Field field : fields)&#123;\n    System.out.println(field.getName());&#x2F;&#x2F;age\n&#125;\n\n&#x2F;&#x2F;获得类的所有属性。包括私有的\nField [] allFields &#x3D; c2.getDeclaredFields();\nfor(Field field : allFields)&#123;\n    System.out.println(field.getName());&#x2F;&#x2F;name    age\n&#125;\n\n&#x2F;&#x2F;获得类的public类型的方法。这里包括 Object 类的一些方法\nMethod [] methods &#x3D; c2.getMethods();\nfor(Method method : methods)&#123;\n    System.out.println(method.getName());&#x2F;&#x2F;work waid equls toString hashCode等\n&#125;\n\n&#x2F;&#x2F;获得类的所有方法。\nMethod [] allMethods &#x3D; c2.getDeclaredMethods();\nfor(Method method : allMethods)&#123;\n    System.out.println(method.getName());&#x2F;&#x2F;work say\n&#125;\n\n&#x2F;&#x2F;获得指定的属性\nField f1 &#x3D; c2.getField(&quot;age&quot;);\nSystem.out.println(f1);\n&#x2F;&#x2F;获得指定的私有属性\nField f2 &#x3D; c2.getDeclaredField(&quot;name&quot;);\n&#x2F;&#x2F;启用和禁用访问安全检查的开关，值为 true，则表示反射的对象在使用时应该取消 java 语言的访问检查；反之不取消\nf2.setAccessible(true);\nSystem.out.println(f2);\n\n&#x2F;&#x2F;创建这个类的一个对象\nObject p2 &#x3D;  c2.newInstance();\n&#x2F;&#x2F;将 p2 对象的  f2 属性赋值为 Bob，f2 属性即为 私有属性 name\nf2.set(p2,&quot;Bob&quot;);\n&#x2F;&#x2F;使用反射机制可以打破封装性，导致了java对象的属性不安全。\nSystem.out.println(f2.get(p2)); &#x2F;&#x2F;Bob\n\n&#x2F;&#x2F;获取构造方法\nConstructor [] constructors &#x3D; c2.getConstructors();\nfor(Constructor constructor : constructors)&#123;\n    System.out.println(constructor.toString());&#x2F;&#x2F;public com.ys.reflex.Person()\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>创建对象方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;创建对象\npublic T newInstance();\n\n&#x2F;&#x2F;方法一：使用forName()+类名全称\n&#x2F;&#x2F;通过 Class 对象的 forName() 静态方法来获取，用的最多，\n&#x2F;&#x2F;但可能抛出 ClassNotFoundException 异常\nClass&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.wz.demo.Student&quot;);\n&#x2F;&#x2F;方法二：通过class属性，只用这一种方法可以不用通配符“？”，直接具体化Class类\n&#x2F;&#x2F;直接通过 类名.class 的方式得到,该方法最为安全可靠，程序性能更高\n&#x2F;&#x2F; 这说明任何一个类都有一个隐含的静态成员变量 class\nClass&lt;?&gt; clazz &#x3D; Student.class;\nClass&lt;Student&gt; clazz &#x3D; Student.class;\n&#x2F;&#x2F;方法三：通过getClass()方法\n&#x2F;&#x2F;通过对象调用 getClass() 方法来获取,通常应用在：\n&#x2F;&#x2F;比如你传过来一个 Object类型的对象，而我不知道你具体是什么类，用这种方法\nClass&lt;?&gt; clazz &#x3D; student.getClass();</code></pre></li>\n</ol>\n</li>\n<li><p>Constructor类</p>\n<ol>\n<li><p>Constructor用来存储构造函数的信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;构造函数所包含的信息\n&#x2F;&#x2F;在Constructor中，以下信息都有相应的方法来获取\npublic final class Constructor&lt;T&gt; extends Executable &#123;\n    private Class&lt;T&gt;            clazz;\n    private int                 slot;\n    private Class&lt;?&gt;[]          parameterTypes;\n    private Class&lt;?&gt;[]          exceptionTypes;\n    private int                 modifiers;\n    &#x2F;&#x2F; Generics and annotations support\n    private transient String    signature;\n    &#x2F;&#x2F; generic info repository; lazily initialized\n    private transient ConstructorRepository genericInfo;\n    private byte[]              annotations;\n    private byte[]              parameterAnnotations;\n&#125;\n</code></pre></li>\n<li><p>举例：newInstance()方法，通过newInstance()方法，可以调用构造函数来创建对象。Class类中的newInstance()方法只能无参构造；Constructor类对象可以使用newInstance()方法进行有参构造。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public T newInstance(Object ... initargs);</code></pre></li>\n</ol>\n</li>\n<li><p>Method类</p>\n<ol>\n<li><p>Method存储的是方法的信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class Method extends Executable &#123;\n    private Class&lt;?&gt;            clazz;\n    private int                 slot;\n    &#x2F;&#x2F; This is guaranteed to be interned by the VM in the 1.4\n    &#x2F;&#x2F; reflection implementation\n    private String              name;\n    private Class&lt;?&gt;            returnType;\n    private Class&lt;?&gt;[]          parameterTypes;\n    private Class&lt;?&gt;[]          exceptionTypes;\n    private int                 modifiers;\n    &#x2F;&#x2F; Generics and annotations support\n    private transient String              signature;\n    &#x2F;&#x2F; generic info repository; lazily initialized\n    private transient MethodRepository genericInfo;\n    private byte[]              annotations;\n    private byte[]              parameterAnnotations;\n    private byte[]              annotationDefault;\n    private volatile MethodAccessor methodAccessor;\n&#125;</code></pre></li>\n<li><p>Method类也提供了大量方法来获取以上信息，例如invoke()方法，调用此方法可以执行对应方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Object invoke(Object obj, Object... args);</code></pre></li>\n</ol>\n</li>\n<li><p>Field类</p>\n<ol>\n<li><p>Field用来存储成员变量的信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final  class Field extends AccessibleObject implements Member &#123;\n    private Class&lt;?&gt;            clazz;\n    private int                 slot;\n    &#x2F;&#x2F; This is guaranteed to be interned by the VM in the 1.4\n    &#x2F;&#x2F; reflection implementation\n    private String              name;\n    private Class&lt;?&gt;            type;\n    private int                 modifiers;\n    &#x2F;&#x2F; Generics and annotations support\n    private transient String    signature;\n    &#x2F;&#x2F; generic info repository; lazily initialized\n    private transient FieldRepository genericInfo;\n    private byte[]              annotations;\n    &#x2F;&#x2F; Cached field accessor created without override\n    private FieldAccessor fieldAccessor;\n    &#x2F;&#x2F; Cached field accessor created with override\n    private FieldAccessor overrideFieldAccessor;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"3-反射攻击\"><a href=\"#3-反射攻击\" class=\"headerlink\" title=\"3.反射攻击\"></a>3.反射攻击</h5><ol>\n<li><p>在Constructor、Method、Field类，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限<code>public void setAccessible(boolean flag)</code>，利用这个方法，可以将私有的构造函数、方法、成员变量设置为可以访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量。如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static class Person &#123;\n        private int age;\n        private Person()&#123;&#125;;\n        private void print() &#123;\n            system.out.printIn(this.age);\n        &#125;\n    &#125;\n    public static void main(String[]args) throws Exception &#123;\n        Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.wz.demo.Demo$Person&quot;);\n\n        Constructor&lt;?&gt; constructor &#x3D; clazz.getDeclaredConstructor();\n        constructor.setAccessible(true);\n        Person pobj &#x3D; (Person) constructor.newInstance();\n\n        Field field &#x3D; clazz.getDeclaredField(&quot;age&quot;);\n        field.setAccessible(true);\n        field.set(pobj,10);\n\n        Method method &#x3D; clazz.getDeclaredMethod(&quot;print&quot;);\n        method.setAccessible(true);\n        method.invoke(pobj);\n    &#125;\n&#125;</code></pre></li>\n<li><p>反射攻击：打破单例类只能实例化一个对象的限制的情况</p>\n</li>\n</ol>\n<h5 id=\"4-反射的作用\"><a href=\"#4-反射的作用\" class=\"headerlink\" title=\"4.反射的作用\"></a>4.反射的作用</h5><ol>\n<li><p>Spring可以作为一种IOC容器（DI容器、依赖注入容器），就是一个大的工厂类，负责在程序启动时，根据配置，事先创建好对象，当应用程序需要使用某个对象时，直接从容器中获取即可。</p>\n</li>\n<li><p>在普通的工厂模式中，工厂类要创建哪个对象是事先确定好的，并且写死在工厂类代码中的。但是Spring通过读取事先定义好的配置文件，将每个要创建的对象信息，解析为一定的内存结构：BeanDefinition，然后根据BeanDefinition中的信息，通过反射创建对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BeansFactory &#123;\n    private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();\n    private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n        &#125;\n\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;\n                createBean(beanDefinition);\n            &#125;\n        &#125;\n    &#125;\n\n    public Object getBean(String beanId) &#123;\n        BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);\n        if (beanDefinition &#x3D;&#x3D; null) &#123;\n            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n        &#125;\n        return createBean(beanDefinition);\n    &#125;\n\n    @VisibleForTesting\n    protected Object createBean(BeanDefinition beanDefinition) &#123;\n        if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n\n        Object bean &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F;得到类信息\n            Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());\n            &#x2F;&#x2F;得到构造参数列表\n            List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();\n            if (args.isEmpty()) &#123;\n                bean &#x3D; beanClass.newInstance();\n            &#125; else &#123;\n                Class[] argClasses &#x3D; new Class[args.size()];\n                Object[] argObjects &#x3D; new Object[args.size()];\n                for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;\n                    BeanDefinition.ConstructorArg arg &#x3D; args.get(i);\n                    if (!arg.getIsRef()) &#123;\n                        argClasses[i] &#x3D; arg.getType();\n                        argObjects[i] &#x3D; arg.getArg();\n                    &#125; else &#123;\n                        BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());\n                        if (refBeanDefinition &#x3D;&#x3D; null) &#123;\n                            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());\n                        &#125;\n                        argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());\n                        argObjects[i] &#x3D; createBean(refBeanDefinition);\n                    &#125;\n                &#125;\n                &#x2F;&#x2F;有参构造\n                bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);\n            &#125;\n        &#125; catch (ClassNotFoundException | IllegalAccessException\n                 | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;\n            throw new BeanCreationFailureException(&quot;&quot;, e);\n        &#125;\n\n        if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;\n            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n        &#x2F;&#x2F;返回新对象bean\n        return bean;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"5-反射的原理\"><a href=\"#5-反射的原理\" class=\"headerlink\" title=\"5.反射的原理\"></a>5.反射的原理</h5><ol>\n<li>反射创建对象比new慢一些，大概10倍的，但是不会是应用程序的性能瓶颈</li>\n<li>反射动态执行方法比普通方法调用慢几百倍，但是也不需要担忧：<ol>\n<li>使用反射执行方法，并不会让方法内部逻辑的执行速度变慢，只是增加一些额外耗时而已，这部分额外耗时是固定的，跟方法内部逻辑的复杂程度无关</li>\n<li>方法的额外耗时并不长，对于大部分方法来说，特别是一些I/O操作的方法（比如访问数据库），方法本身内部逻辑执行的耗时远远大于使用反射而额外增加的耗时</li>\n</ol>\n</li>\n<li>额外耗时产生的原因：<ol>\n<li><strong>安全性检查：</strong>普通函数的参数类型匹配、和确保方法存在都是在编译时完成的，不占用运行时间，但是，对于反射，因为其在运行时才能确定创建什么对象，执行什么方法，所以，安全性检查无法在编译时执行，只能在运行时真正创建，执行方法时再完成，这就会增加额外的运行时间</li>\n<li><strong>类、方法查找：</strong>当我们使用反射创建对象或执行方法时，需要通过类名、方法名去查找对应的类或方法，因为字符串匹配比较慢，所以代码经过编译之后得到的字节码中，每个类和方法都会分配一个对应的编号，保存在常量池中，代码中所有出现类或方法的地方，都会被替换为编号，可以提高查找速度。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-注解\"><a href=\"#3-注解\" class=\"headerlink\" title=\"3.注解\"></a>3.注解</h4><h5 id=\"1-定义注解\"><a href=\"#1-定义注解\" class=\"headerlink\" title=\"1.定义注解\"></a>1.定义注解</h5><ol>\n<li><p>自定义注解的方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Java内建注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override &#123;\n&#125;\n\n&#x2F;&#x2F;自定义注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimit &#123;\n\tpublic enum TimeUnit &#123; SECOND,MINUTE, HOUR, DAY,MONTH&#125;\n    string apiName();\n\tint limitCount();\n\tTimeUnit timeUnit() default TimeUnit.SECOND;\n&#125;</code></pre></li>\n<li><p>元注解</p>\n<ol>\n<li><p>@Target：用来描述注解的使用范围，他有以下值，一个注解可以有多个使用范围，如果没有Target则可以用于任何范围。</p>\n<ul>\n<li>ElementType.TYPE：类、接口、枚举</li>\n<li>ElementType.METHOD：用于方法</li>\n<li>ElementType.CONSTRUCTOR：用于构造器</li>\n<li>ElementType.FIELD：用于成员变量</li>\n<li>ElementType.LOCAL_VARIABLE：用于局部变量</li>\n<li>ElementType.PARAMETER：用于参数</li>\n<li>ElementType.PACKAGE：用于包</li>\n</ul>\n</li>\n<li><p>@Retention：用来描述注解的可见范围（或叫生命周期），有以下值，</p>\n<ul>\n<li>RetentionPolicy SOURCE：仅在源码中可见，当编译器将源码编译成字节码后，注解信息将被丢弃，但是，编译器可以读取到可见范围为SOURCE的注解。比如，在编译时，如果函数上标有@Override，就会去检查对应的函数有没有在父类中定义，如果没有，就提示编译错误</li>\n<li>RetentionPolicy.CLASS：表示注解在源码、字节码均可见，但在运行时是不可见的，无法在程序运行时，利用反射获取到代码（类、方法等）的这类注解信息</li>\n<li>RetentionPolicy.RUNTIME：表示注解在源码、字节码、运行时均可见，生命周期最长，可以在程序运行时，利用反射获取代码的这类注解信息</li>\n</ul>\n</li>\n<li><p>@Documented：表示注解信息会输出到Javadoc文档中，当我们根据源码生成Javadoc文档时，类或方法上的用@Documented标记的注解也会跟随输出到Javadoc文档中</p>\n</li>\n<li><p>@interface：class、interface、enum、@interface这四者是平级关系，<code>@interface</code>用来定义注解，在注解中，还可以定义一些变量，特殊的是注解使用方法来定义变量，对于只有一个变量的注解，可以将其定义为value，这样，在使用时，可以不指定变量的名称</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Target(ElementType.TYPE)\n@Retention(RetentionPolicy. SOURCE)\npublic @interface Author &#123;\n\tstring value();\n&#125;\n\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Description &#123;\n\tstring author();\n\tstring date();\n&#125;\n@Author(&quot;wangzheng&quot;)\npublic class Demo &#123;\n\t@Description(author&#x3D;&quot;wangzheng&quot;, date&#x3D;&quot;2020-11-22&quot;)\n    public void f() &#123;\n\t&#x2F;&#x2F;...\n\t&#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-标记注解\"><a href=\"#2-标记注解\" class=\"headerlink\" title=\"2.标记注解\"></a>2.标记注解</h5><ol>\n<li><p>注解相当于给元素打了一个tag，任何编译器或者应用程序通过反射可以访问的代码元素，都可以用注解去标识</p>\n</li>\n<li><p>不管是内建注解，还是自定义注解，使用方法都一样，注解用于类、方法等代码元素之上，起到标记作用。比如<code>@Override</code>，用来标记某个函数是对父类的重写；再比如，前面定义的<code>@RateLimit</code>注解，用于标记需要限流的接口，使用方式如下，在使用注解时，可以为注解中定义的变量赋值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController&#123;\n    @RateLimit(apiName&#x3D;&quot;&#x2F;user&#x2F;register&quot;,\n               limitCount&#x3D;1000,tiimeUnit&#x3D;RateLimit.TimeUnit.Second)\n    public UseerVo register(String telephone,String passward)&#123;\n        \n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-读取注解\"><a href=\"#3-读取注解\" class=\"headerlink\" title=\"3.读取注解\"></a>3.读取注解</h5><ol>\n<li>大部分情况下，只定义和标记注解还不够，还需要有读取注解并做相应处理的代码逻辑，才能发挥注解的真正作用。这就类似于推荐算法中，只定义标签和给数据打标签是没用的，还需要设计根据标签分类数据的算法，这样才能发挥标签的作用。对于Java内建注解，编译器和JVM都可以对其进行读取和处理，比如@Override注解，编译器会处理</li>\n<li>对于自定义注解，我们需要自己开发相应的读取和处理逻辑，读取代码（类或方法等）中的注解信息就需要用到反射语法，因为反射作用于代码运行时，所以自定义注解的@Rentention可见范围一般应该设置为RUNTIME。</li>\n</ol>\n<h5 id=\"4-注解应用\"><a href=\"#4-注解应用\" class=\"headerlink\" title=\"4.注解应用\"></a>4.注解应用</h5><ol>\n<li><p>替代注释：单元测试一般只能测试public和protected方法，如果想要测试private方法，那么就需要将这个方法的访问权限从private变为protected。为了表明此方法设置为protected只是为了测试，以免开发人员误解和误用，可以使用Google Guava提供的@VisibleForTesting注解在方法上进行标记，这个注解只起到注释的作用，并没有实际的作用，并不能限制除了单元测试代码之外的其他代码访问这个方法。尽管这里我们也可以使用注释代替注解，但是注解相对于注释，更加规范、统一、可读性更好。</p>\n</li>\n<li><p>替代Marker Interface：</p>\n<ol>\n<li><p>Java中有一种特殊的接口，叫做标记接口（Marker Interface）。标记接口中不包含任何方法，跟注解类似，起到标记作用，比如RandomAccess、Cloneable、Serializable，可以根据标记接口判断对象是否可以执行某些操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface RandomAccess&#123;&#125;&#x2F;&#x2F;支持随机访问\npublic interface Cloneable&#123;&#125;&#x2F;&#x2F;支持克隆\npublic interface Serializable&#123;&#125;&#x2F;&#x2F;支持序列化\n\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n    implements List&lt;E&gt;,RandomAccess,Cloneable,java.io.Serializable&#123;\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F;位于java.util.Collections类中\npublic static &lt;T&gt; int binarySearch\n    (List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; C)&#123;\n    if (C&#x3D;&#x3D;null)\n\t\treturn binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt; ) list, key);\n    \n    &#x2F;&#x2F;如果实现了RandomAccess标记接口的List容器，\n    &#x2F;&#x2F;binarySearch()函数调用indexedBinarySearch()函数来实现二分查找\n\tif (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)\n\t\treturn Collections.indexedBinarySearch(list, key, c);\n\telse\n\t\treturn Collections.iteratorBinarySearch(list, key, c),\n&#125;</code></pre></li>\n<li><p>注解也可以起到标记的作用，因此可以使用注解来替代标记接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface RandomAccess &#123;\n    \n&#125;\n\n@RandomAccess\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n    implements List&lt;E&gt;, Cloneable, java.io.Serializable &#123;\n    &#x2F;&#x2F;.....省略代码...\n&#125;\n\npublic static &lt;T&gt; int binarySearch\n    (List&lt;? extends T&gt; list, T key, Comparator&lt;? super T&gt; c)&#123;\n    if (c&#x3D;&#x3D;null)\n\t\treturn binarySearch((List&lt;? extends Comparable&lt;? super T&gt;&gt; ) list, key);\n    \n    &#x2F;&#x2F;读取注解\n\tClass&lt;?&gt; clazz &#x3D; list.getClass();\n\tif(clazz.isAnnotationPresent(RandomAccess.class )\n       || list.size()&lt;BINARYSEARCH_THRESHOLD)\n        return Collections.indexedBinarySearch(list, key, c);\n\telse\n\t\treturn Collections.iteratorBinarySearch(list, key,c);\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>替代XML配置文件</p>\n<ol>\n<li><p>Spring IOC容器需要读取应用程序的配置文件，解析出需要创建的对象，然后使用反射来创建对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[]args)&#123;\n        ApplicationContext applicationContext &#x3D; new ClassPathXmIApplicationContext(&quot;beans.xml&quot;);\n        RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter.test();\n    &#125;\n    \n&#x2F;&#x2F;配置文件beans.xml\n&lt;beans&gt;\n\t&lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n        &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot; scope&#x3D;&quot;&quot;singleton&quot; lazy-init&#x3D;&quot;true&quot;&gt;\n\t\t\t&lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n            &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n     &lt;&#x2F;bean&gt;\n&lt;&#x2F;bean&gt;\n</code></pre></li>\n</ol>\n</li>\n<li><p>Spring还支持基于注解的配置方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@configuration\npublic class AppConfig &#123;\n    @Bean\n    public RateLimiter rateLimiter() &#123;\n        return new RateLimiter(redisCounter());\n    &#125;\n    @Bean(&quot;redisCnt&quot;)\n    public RedisCounter redisCounter()&#123;\n        return new RedisCounter(&quot;127.0.0.1&quot;,1234);\n    &#125;\n&#125;\npublic class Demo &#123;\n    public static void main(String[]args)&#123;\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n        RateLimiter rateLimiter &#x3D;(RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter test();\n    &#125;\n&#125;\n</code></pre></li>\n<li><p>程序在启动时，Spring lOC容器利用反射获取到AppConfig上的注解，发现包含@Configuration注解，便确定这个类为配置类，然后，利用反射获取标记有@Bean注解的方法，利用反射执行方法并将创建的对象放置于BeansFactory中。BeansFactory维护了一个Map结构，Map中的键为对象名称，值为对象本身，之后我们便可以使用getBean(“rateLimiter”)这种方式从BeansFactory中获取对象了。对于@Bean标注的方法，默认使用类名首字母小写作为对象名称(比如rateLimiter)，当然，也可以通过注解中的value变量来指定对象名称(比如rediCnt)。</p>\n</li>\n<li><p>从上述示例，我们发现，跟XML配置文件的配置方式类似，基于Java注解的配置方式，也是集中式的配置方式，所有要创建对象都集中在AppConfig类中。AppConfig类就等同于XML配置文件，只不过形式不同而已。有些Java程序员偏爱于Java代码做配置，有些Java程序员偏爱于XML文件做配置，两者没有绝对的优势。不过，基于Java注解，不仅可以实现集中式配置，还可以将配置分散在各个类中。</p>\n</li>\n<li><p>如下所示，如果我们需要Spring lOC容器帮忙创建和管理某个类的对象，那么我们只需要在这个类上标记上@Component注解(当然也可以是@Controller、@Service、@Repository等Spring可以识别的其他注解)。Spring IOC容器会为标记了<br>   @Component注解的类创建一个同名对象。当然，我们也可以在@Component注解中指定创建的对象名称。除此之外，如果创建某个类的对象需要依赖其他对象，那么，我们可以使用@Autowired自动依赖注入注解，标记依赖的成员变量，这样Spring lOC容器会从BeanFactory中获取依赖的对象，自动赋值给成员变量。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@component\npublic class RateLimiter &#123;\n    @Autowired\n    private RedisCounter redisCounter;\n    public void test() &#123;\n        system.out.printIn(&quot;Hello World!&quot;);\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n</code></pre></li>\n<li><p>因为被标记为@Component的类可散落在项目代码中的各个地方，为了让Spring lOC容器能查找到这些类，我们需要告知SpringIOC去哪些package下扫描查找。告知的方法如下所示，编写AppConfig类，并且通过注解@ComponentScan指定扫描路径。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@configuration\n@componentScan(&quot;com.xzg&quot;)\npublic class AppConfig &#123;\n\n&#125;\npublic class Demo &#123;\n    public static void main(String[]args)&#123;\n        ApplicationContext context &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n        RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter test();\n    &#125;\n&#125;\n</code></pre></li>\n<li><p>程序在启动时，Spring lOC容器会通过反射读取AppConfig类上的注解，发现包含@Configuration，确认是配置文件，然后再通过反射读取@ComponentScan注解中的value值，获得扫描范围com.xzg。接下来，Spring lOC容器便在com.xzg包下，扫描标记有@Component注解的类（RateLimiter），然后利用反射创建类的对象，并存储到BeansFactory中。在创建的过程中，如果某个类中的成员变量标记有@Autowired注解，那么Spring lOC容器会从BeansFactory中，查找已经创建好的对象，自动赋值给这个成员变量。</p>\n</li>\n<li><p>对于以上非集中式的配置方式，添加、删除类不需要修改集中的配置文件，并且，注解还能在代码中起到注释的作用，比如，在阅读代码时，如果我们发现某个方法标记了@Transactional注解，那么，我们可以得知这个方法支持事务。当然，集中式配置也有优点，那就是配置信息跟代码解耦合，方便代码复用，除此之外，使用集中式配置，配置集中于一处，项目中有哪些配置─目了然，比如，如果我们使用配置文件配置事务，那么通过查看配置文件，我们就可以得知项目中所有支持事务的方法。集中式配置方式(基于XML配置文件、基于Java注解)和非集中式配置方式(基于Java注解)各有利弊，没有哪个具有绝对优势，你可以根据团队的习惯自行选择。</p>\n</li>\n</ol>\n<h4 id=\"4-动态代理\"><a href=\"#4-动态代理\" class=\"headerlink\" title=\"4.动态代理\"></a>4.动态代理</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>代理模式可以在不改变原始类的代码的情况下，通过引入代理类来给原始类附加功能。代理模式分为静态代理和动态代理</p></blockquote>\n<h5 id=\"1-静态代理（见设计模式）\"><a href=\"#1-静态代理（见设计模式）\" class=\"headerlink\" title=\"1.静态代理（见设计模式）\"></a>1.静态代理（见设计模式）</h5><ol>\n<li>通过实现接口或继承的方式，通过注入原始类并添加新功能的方式实现</li>\n<li>实现简单，但会导致项目中的类成倍增加，所有相关的类都需要增加代理类，重复代码多</li>\n</ol>\n<h5 id=\"2-动态代理\"><a href=\"#2-动态代理\" class=\"headerlink\" title=\"2.动态代理\"></a>2.动态代理</h5><ol>\n<li>一般静态指的编译阶段，动态指的运行阶段。在代理模式上，静态代理指的是在编译阶段时生成代理类的字节码，动态代理指的是运行时生成代理类的字节码，且字节码只存在与内存中，并不会生成对应的class文件</li>\n<li>之所以可以实现动态代理，是因为JVM设计得非常灵活，只要是符合类的格式的字节码，都可以在运行时被JVM解析并加载，不管这个字节码是来自预先编译好的(class文件)，还是在内存中临时生成的(典型应用:动态代理)，又或者从网络加载而来的(典型应用: Applet)。这部分内容涉及到JVM的类加载机制，见JVM。<ol>\n<li>实现方法一：利用JDK提供的类来实现</li>\n<li>实现方法二：使用第三方的字节码类库来实现，比如CGLIB、BECL、ASM、Javassit等直接编辑字节码</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"3-基于JDK实现动态代理\"><a href=\"#3-基于JDK实现动态代理\" class=\"headerlink\" title=\"3.基于JDK实现动态代理\"></a>3.基于JDK实现动态代理</h5><ol>\n<li><p>基本语法</p>\n<ol>\n<li><p>为UserController类实现动态代理，当为其它Controller类中的方法也添加时间统计代码时，可以复用CtrlProxyHandler类，并通过Proxy类的newProxyInstance()静态方法生成对应的代理类对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CtrlProxyHandler implements InvocationHandler &#123;\n    private Object origBean;\n\n    public CtrlProxyHandler(Object origBean) &#123;\n        this.origBean &#x3D; origBean;\n    &#125;\n    @override\n    public Object invoke(Object proxy， Method method, Object[] args) throws Throwable &#123;\n        long startTime &#x3D; system.currentTimeMillis();\n        \n        Object res &#x3D; method.invoke(origBean, args);\n        \n        long costTime &#x3D; System.currentTimeMillis() - startTime;\n        System.out.printIn(origBean.getClass().getSimpleName()+&quot;#&quot;+ method.getName() + &quot; cost time: &quot; + costTime);\n        return res;\n    &#125;\n&#125;\n\npublic class JDKProxyDemo &#123;\n    public static void main(String] args) &#123;\n        luserController userController &#x3D; new UserController();\n        CtrIProxyHandler handler &#x3D; new CtrIProxyHandler(userController);\n        &#x2F;&#x2F;用Proxy的静态方法生成代理类\n        lUserController userControllerProxy &#x3D; (IUserController)Proxy.newProxyInstance\n            (handler.getClass().getClassLoader(), UserController.class.getInterfaces(), handler);\n        userControllerProxy.login(&quot;139********&quot;，&quot;*********&quot;);\n    &#125;\n&#125;\n</code></pre></li>\n<li><p>基于JDK来实现动态代理主要用到了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类。</p>\n<ol>\n<li><p>InvocationHandler接口只包含一个invoke()函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface InvocationHandler &#123;\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n&#125;</code></pre></li>\n<li><p>Proxy类生成代理类和实例化对象的方法如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Foo为接口\n\nInvocationHandler handler &#x3D; new MyInvocationHandler(...); &#x2F;&#x2F; InvocationHandler\n&#x2F;&#x2F;生成代理类\nClass&lt;?&gt; proxyClass &#x3D; Proxy.getProxyClass(Foo.class.getClassLoader(), Foo.class);\n&#x2F;&#x2F;实例化对象\nFoo f&#x3D;(Foo) proxyClass.getConstructor(\n    InvocationHandler.class).newInstance(handler);\n\n&#x2F;&#x2F;大部分情况下，我们只需要用到代理类的实例化对象，\n&#x2F;&#x2F;所以，上述代码中的后两行代码可以简化为如下一行代码。\nFoo f &#x3D;(Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(), new Class&lt;?&gt;[] &#123; Foo.class &#125;, handler);</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>实现原理</p>\n<ol>\n<li><p><strong>newProxyInstance函数的定义：</strong><code>public static Object newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code></p>\n<ul>\n<li><code>ClassLoader loader</code>loader表示类加载器，用于加载动态代理类到JVM</li>\n<li><code>Class&lt;?&gt;[] interfaces</code>用于生成动态代理类，接口中的方法就是动态代理类包含的方法</li>\n<li><code>InvocationHandler h</code>用于创建（实例化）动态代理类对象</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static Object newProxyInstance(\n    ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h)&#123;\n    \n    &#x2F;&#x2F;1)生成动态代理类\n    &#x2F;&#x2F;2)加载动态代理类\n    Class&lt;?&gt; cl&#x3D; getProxyClass0(loader, intfs);\n\n    &#x2F;&#x2F;3)实例化动态代理类对象\n    final Class&lt;?&gt;[] constructorParams &#x3D; &#123; InvocationHandler.class &#125;;\n    final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);\n    return cons.newlnstance(new Object]&#123;h);\n&#125;</code></pre></li>\n<li><p><strong>生成动态代理类的过程：</strong>newProxyInstance()函数调用ProxyGenerator类(JDK提供的生成字节码的类)，按照类的字节码格式，生成动态代理类的字节码，并存储到内存（proxyClassFile）中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;生成动态代理类的名称\nfinal String proxyClassNamePrefix &#x3D; &quot;$Proxy&quot;;\nlong num &#x3D; nextUniqueNumber.getAndIncrement();\nString proxyName &#x3D; proxyPkg + proxyClassNamePrefix + num;\n\n&#x2F;&#x2F;ProxyGenerator类似字节码类库，可以生成动态代理类的字节码\nbyte[] proxyClassFile &#x3D; ProxyGenerator.generateProxyClass(\n    proxyName, interfaces, accessFlags);\ntry &#123;\n    &#x2F;&#x2F;通过JVM的类加载器来加载动态代理类\n    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n&#125; \ncatch(ClassFormatError e) &#123; &#x2F;&#x2F;如果生成的动态代理类的字节码格式有误，则报错\n    throw new lllegalArgumentException(e.toString());\n&#125;\n</code></pre>\n\n<ol>\n<li><strong>动态代理类具有哪些方法：</strong>只跟接口有关，跟原始类没有任何关系，这也是基于JDK实现的动态代理要求原始类必须有接口定义才行。</li>\n</ol>\n</li>\n<li><p><strong>类名：</strong>动态代理类的类名是自动生成的，由两部分组成，$Proxy+自增编号，如果项目中使用Proxy类生成了两个动态代理类，名称将分别为$Proxy0，$Proxy1</p>\n</li>\n<li><p><strong>反编译动态代理类：</strong></p>\n<ol>\n<li><p>动态代理类字节码的保存方式：<code>byte[] bytecodes = ProxyGenerator.generateProxyClass(&quot;CtrIProxy&quot;, new Class[] &#123; IUserController.class &#125;);</code></p>\n</li>\n<li><p>利用反编译工具生成CtrlProxy.class字节码文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class CtrlProxy extends Proxy implements IUserController&#123;\n    private static Method m4;&#x2F;&#x2F;register()\n    \n    public final UserVo register(String var1,String var2) throws &#123;\n        try &#123;\n            &#x2F;&#x2F;super.h的值，在实例化动态代理类对象时，赋值为自定义的InvoationHandler实现类对象（比如CtrlProxyHandler类对象）\n            return (UserVo)super.h.invoke(this, m4, new Object[]&#123;var1, var2&#125;);\n        &#125; catch (RuntimeException | Error var4) &#123;\n            throw var4;\n        &#125;catch (Throwable var5)&#123;\n            throw new UndeclaredThrowableException(var5);\n        &#125;\n    &#125;\n    \n    static &#123;\n        try&#123;\n            m4 &#x3D; Class.forName(&quot;demo.proxy.IUserController&quot;).getMethod(&quot;register&quot;,\n                Class.forName(&quot;java.lang.String&quot;),Class.forName(&quot;java.lang.String&quot;));\n        &#125;catch (NoSuchMethodException var2)&#123;\n            throw new NoSuchMethodError(var2.getMessage());\n        &#125; catch (ClassNotFoundException var3)&#123;\n            throw new NoClassDefFoundError(var3.getMessageO));\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>当调用login()方法时，login()方法会调用CtrlProxyHandler上的invoke()方法。invoke()方法执行一些附加逻辑，然后再拿传递过来的方法和参数，利用反射在原始类对象上执行<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220618204824711-165668658181230.png\" alt=\"image-20220618204824711\"></p>\n</li>\n</ol>\n</li>\n<li><p>性能分析：动态代理耗时的地方有，运行时动态生成代理类的字节码、利用反射执行方法</p>\n</li>\n</ol>\n<h5 id=\"4-基于CGLIB实现动态代理\"><a href=\"#4-基于CGLIB实现动态代理\" class=\"headerlink\" title=\"4.基于CGLIB实现动态代理\"></a>4.基于CGLIB实现动态代理</h5><ol>\n<li><p>Maven导入cglib的依赖</p>\n</li>\n<li><p>基于CGLIB实现动态代理，也要用到一个核心接口MethodInterceptor和一个核心类Enhancer，他们的用法跟JDK中的InvocationHandler接口和Proxy类相似</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProxyFactory implements MethodInterceptor &#123;\n    private Object origBean;\n\n    public ProxyFactory(Object origBean)&#123;\n        this.origBean &#x3D; origBean;\n    &#125;\n    \n    @Override\n    public Object intercept(Object obj, Method method, \n                            Object[] args,MethodProxy methodProxy)throws Throwable &#123;\n        long startTime &#x3D; System.currentTimeMillis();\n        Object res &#x3D; method.invoke(origBean, args);\n        long costTime &#x3D; System.currentTimeMillis() - startTime;\n        System.out.printIn(origBean.getClass().getSimpleName()+\n                           &quot;#&quot;+ method.getName() + &quot; cost time: &quot; + costTime);\n        return res;\n    &#125;\n&#125;\npublic class CGLIBProxyDemo &#123;\n    public static void main(Stringargs)&#123;\n        Enhancer enhancer &#x3D; new Enhancer();\n        enhancer.setSuperclass(UserController.class);\n        enhancer.setCallback(new ProxyFactory(new UserController()));\n        UserController userControllerProxy &#x3D; (UserController) enhancer.create();\n        userControllerProxy.login(&quot;&quot;.&quot;&quot;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>基于CGLIB的动态代理实现方式，并不依赖接口，通过继承原始类来生成动态代理类，因此，是一种基于继承的动态代理实习方式</p>\n</li>\n</ol>\n<h4 id=\"5-函数式编程\"><a href=\"#5-函数式编程\" class=\"headerlink\" title=\"5.函数式编程\"></a>5.函数式编程</h4><h5 id=\"1-函数式编程\"><a href=\"#1-函数式编程\" class=\"headerlink\" title=\"1.函数式编程\"></a>1.函数式编程</h5><ol>\n<li><p>编程范式对比：</p>\n<ol>\n<li>面向对象编程的特点：以类、对象作为组织代码的单元以及它的四大特性</li>\n<li>面向过程编程的特点：以函数作为组织代码的单元，数据与方法相分离</li>\n<li>函数式编程的特点：用一系列数学函数或表达式组合来表示，式程序面向数学的更底层的抽象，将计算过程描述为表达式</li>\n</ol>\n</li>\n<li><p>应用场景：科学计算、数据处理、统计分析等，在这些领域，程序往往比较容易用数学表达式来表示，比非函数式编程实现同样的功能需要更少的代码</p>\n</li>\n<li><p>函数编程的实现：</p>\n<ol>\n<li><p>函数是无状态的，只有局部变量不共享全局变量/成员变量，函数的执行结果只与入参有关，同样的入参，不管怎么执行，得到的结果都一样</p>\n</li>\n<li><p>Java函数式编程举例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FPDemo &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n            &#x2F;&#x2F;先过滤非空字符串\n            .filter(((Predicate&lt;string&gt; ) string::isEmpty).negate())\n            &#x2F;&#x2F;查找以&quot;wz-&quot;为前缀的字符串\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            &#x2F;&#x2F;统计每个字符串的长度\n            .map(String::length)\n            &#x2F;&#x2F;打印输出\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-函数接口\"><a href=\"#2-函数接口\" class=\"headerlink\" title=\"2.函数接口\"></a>2.函数接口</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>把函数包裹成接口，来实现把函数当作参数一样使用（Java不像C可以使用函数指针把函数直接当参数来使用）</p></blockquote>\n<ol>\n<li><p>因为Java没有函数指针，所以通过函数接口，将函数包裹在接口中，当作变量来使用，例如Runnable、Comparator等都是函数接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Functionallnterface\npublic interface Runnable &#123;\n    &#x2F;&#x2F;只有一个未实现方法\n    public abstract void run();\n&#125;\n\n@Functionallnterface\npublic interface Comparator&lt;T&gt; &#123;\n    &#x2F;&#x2F;未实现方法\n    int compare(T o1,T o2);\n    &#x2F;&#x2F;虽然未实现，但继承了Object的equals方法的默认实现\n    boolean equals(Object obj);\n    &#x2F;&#x2F;有默认实现的方法\n    default Comparator&lt;T&gt; reversed() &#123;\n        return Collections.reverseOrder(this);\n    &#125;\n    \n    default Comparator&lt;T&gt; thenComparing(Comparator&lt;? super T&gt; other)&#123;\n        Objects.requireNonNull(other);\n        return (Comparator&lt;T&gt; &amp; Serializable)(c1, c2) -&gt;&#123;\n            int res &#x3D; compare(c1,c2);                                                         \n            return (res !&#x3D; 0) ? res : other.compare(c1, c2);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>当函数接口只包含一个未实现的方法，Java提供了专门的注解<code>@Functionallnterface</code>来标识某个接口是函数接口，这个注解的作用就是检查接口中是否只有一个未实现的方法。只包含一个未实现方法但未使用注解的也会被认为是函数接口。可以自行定义加上注解<code>@Functionallnterface</code>的函数接口</p>\n</li>\n<li><p>Java预定义的其它函数接口，比如<code>Predicate&lt;T&gt;</code>，<code>Function&lt;T,R&gt;</code>、<code>Consumer&lt;T&gt;</code>、<code>Supplier&lt;T&gt;</code>等，详见java.util.function包</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">：@Functionallnterface\npublic interface Predicate&lt;T&gt; &#123;\n    boolean test(T t); &#x2F;&#x2F;只有这一个未实现的方法\n    default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) &#123;\n        objects.requireNonNull(other);\n        return (t) -&gt; test(t) &amp;&amp; other.test(t);\n    &#125;\n    default Predicate&lt;T&gt; negate() &#123;\n        return (t) -&gt; ltest(t);\n    &#125;\n    default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other)&#123;\n        Objects.requireNonNull(other);\n        return (t) -&gt; test(t) || other.test(t);\n    &#125;\n    static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) &#123;\n        return (null &#x3D;&#x3D; targetRef)\n            ? Objects:..isNull\n                : object -&gt; targetRef.equals(object);\n    &#125;\n&#125;</code></pre></li>\n<li><p>使用：作用上类似于模板模式、实现上类似于回调。将某个流程中可变的逻辑抽离出来，设计成函数接口，以此来支持灵活定制可变逻辑</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[]args) &#123;\n        List&lt;String&gt; files &#x3D; Arrays.asList(&quot;wang.txt&quot;, &quot;zheng.java&quot;, &quot;xiao.txt&quot; , &quot;ge.java&quot;);\n        List&lt;String&gt; javaFiles &#x3D; filterFiles(files, new Filter&lt;String&gt;()&#123;\n            @override\n            public boolean accept(String name) &#123;\n                return name.endsWith(&quot;.java&quot;);\n            &#125;\n        &#125;);\n    &#125;\n    &#x2F;&#x2F; filter过滤策略为可变逻辑\n    public static List&lt;String&gt; filterFiles(List&lt;Strings files, Filter&lt;String&gt; filter) &#123;\n        List&lt;String&gt; res &#x3D; new ArrayList&lt;&gt;();\n        for (String file : files) &#123;\n            if (filter.accept(file))&#123;\n                res.add(file);\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-Lambda表达式\"><a href=\"#3-Lambda表达式\" class=\"headerlink\" title=\"3.Lambda表达式\"></a>3.Lambda表达式</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>简化函数接口的匿名实现类的代码编写</p></blockquote>\n<ol>\n<li><p>Lambda表达式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">(类型 a,类型 b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\n(a,b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\na-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a为输入参数\n&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;没有入参\n</code></pre></li>\n<li><p>实现，简化Filter</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String] args) &#123;\n    List&lt;String&gt; files &#x3D; Arrays.asList(&quot;wang.txt&quot;, &quot;zheng.java&quot;, &quot;xiao.txt&quot;, &quot;ge.java&quot;);\n    &#x2F;&#x2F;使用匿名实现类\n    List&lt;String&gt; javaFiles &#x3D; filterFiles(files, new Filter&lt;String&gt;()&#123;\n        @override\n        public boolean accept(String name) &#123;\n            return name.endsWith(&quot;.java&quot;);\n        &#125;\n    &#125;);\n    &#x2F;&#x2F;使用Lambda表达式\n    List&lt;String&gt; javaFiles2 &#x3D; filterFiles(files, (String name)-&gt;&#123;\n        return name.endsWith(&quot;. java&quot;);\n    &#125;);\n    &#x2F;&#x2F;有入参，只有一条返回语句\n\tList&lt;String&gt; javaFiles &#x3D; filterFiles(files,name-&gt;name.endWith(&quot;.java&quot;));\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"4-方法引用\"><a href=\"#4-方法引用\" class=\"headerlink\" title=\"4.方法引用\"></a>4.方法引用</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>进一步简化Lambda表达式</p></blockquote>\n<ol>\n<li><p>当Lambda中的逻辑已经有现成的方法实现时，可以直接使用方法引用。方法引用要求所引用的方法的参数列表的返回值，跟函数接口中未实现方法的参数列表和返回值完全一致，格式如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">对象::实例方法\n类::静态方法\n类::实例方法</code></pre></li>\n<li><p>实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FPDemo &#123;\n    public static void main(String] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n            .filter(((Predicate&lt;String&gt;) String::isEmpty).negate())\n            &#x2F;&#x2F; .filter(s-&gt;s.isEmpty())\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            .map(String::length)\n            &#x2F;&#x2F;.map(s-&gt;s.length())\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"5-Sream流\"><a href=\"#5-Sream流\" class=\"headerlink\" title=\"5.Sream流\"></a>5.Sream流</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>支持通过”.”级联多个函数操作的代码编写方式</p></blockquote>\n<ol>\n<li><p>函数式编程其本质应该是Stream流，每个函数都返回一个通用的类（Stream对象），在Stream上的操作有两种：</p>\n<ol>\n<li>中间操作：返回的仍然式Stream对象，可以继续级联其它操作</li>\n<li>终止操作：确定的值结果或者没有返回值，无法继续往下级联处理</li>\n</ol>\n</li>\n<li><p>Stream类中的filter()、map()、forEach()等方法的参数为Java预定义的函数接口，因此函数接口的匿名实现类可以通过Lambda表达式来简化</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; &#123;\n    Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);\n    &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper);\n    void forEach(Consumer&lt;? super T&gt; action);\n&#125;</code></pre></li>\n<li><p>Java预定义的函数接口中，有一些具有默认实现的方法，比如<code>Predicate&lt;T&gt;</code>函数接口中的add()、or()、negate()等方法，一般用来组合操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot; , &quot;c.java&quot;);\nPredicate&lt;String&gt; p1 &#x3D; s-&gt;s.startsWith(&quot;wz-&quot;);\nPredicate&lt;String&gt; p2&#x3D; s-&gt;s.endsWith(&quot;. java&quot;);\nList&lt;String&gt; res &#x3D; strList.stream()\n    &#x2F;&#x2F;既包含wz-前缀，又.java后缀\n    .filter(p1.and(p2))\n    .collect(Collectors.toList());</code></pre></li>\n</ol>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><h3 id=\"1-线程概述\"><a href=\"#1-线程概述\" class=\"headerlink\" title=\"1.线程概述\"></a>1.线程概述</h3><h4 id=\"1-线程由来\"><a href=\"#1-线程由来\" class=\"headerlink\" title=\"1.线程由来\"></a>1.线程由来</h4><ol>\n<li>单进程：对程序运行过程中所涉及的数据（比如创建的对象、变量）、代码、资源（比如打开的文件）、执行信息（执行到哪行代码）的封装聚合，起到方便管理的作用。</li>\n<li>多进程：<ol>\n<li>原理：计算机的需求从CPU密集型的计算任务转变为对实时性要求更高的个人操作，计算机内部采用并发（concurrency）的方式来实现用户眼里的并行（paralelism）需求，类似于视频的帧切换</li>\n<li>上下文切换：在进程切换的过程中，OS需要记录下进程暂停时的环境信息，重启执行时，需要恢复这个进程执行的环境信息，这个环境信息就叫做上下文（Context），两个进程之间切换执行，就会导致上下文切换（Context Switching）</li>\n<li>操作系统用进程表（Process Table）来记录所有进程的执行信息，每一个表项叫做进程控制块，简称PCB（Process Control Block），一个PCB记录一个进程的执行信息，主要包括：进程ID、进程状态、程序计数器（PC计数器 Programm Counter，记录接下来要执行的代码所在的内存地址）、寄存器值（程序执行的中间结果）、调度信息（如进程的优先级）、文件列表（已打开的文件信息）、其他信息（如统计信息，进程运行了多长时间）</li>\n</ol>\n</li>\n<li>多线程：对多进程的一种优化<ol>\n<li>设计方面：相当于对进程进行了拆分，进程只负责线程共享资源的管理，线程负责代码的执行，线程负责部分数据（函数调用栈、程序计数器、寄存器值）；进程是资源分配的最小单元，线程是CPU调度的最小单元，OS按线程来分配CPU执行时间；线程切换也会导致上下文的切换。</li>\n<li>性能方面：随着多核计算机的发展，多线程可以让一个程序并行运行在多个CPU上，提高程序运行效率，使得CPU密集型和IO密集型逻辑可以并行执行，不仅程序间可以并行执行，程序内也可以并行执行。</li>\n<li>易用性方面：引入多线程后，每个线程负责执行一个逻辑，OS负责多个逻辑之间的调度执行，如果没有多线程，就需要程序员维护</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-线程概述\"><a href=\"#2-线程概述\" class=\"headerlink\" title=\"2.线程概述\"></a>2.线程概述</h4><ol>\n<li>调度策略概览：先来先服务、最短作业优先、高优先级优先、多优先级队列、轮转调度等</li>\n<li>线程状态<ul>\n<li>NEW：新创建的线程、在没有调用start()函数前，线程处于NEW状态</li>\n<li>READY：线程一切就绪，等待操作系统调度</li>\n<li>RUNNING：线程正在执行</li>\n<li>WAITING：线程在等待I/O读写完成，等待获得锁、等待时钟定时到期（调用sleep()函数）等</li>\n<li>TERMINATED：线程终止状态，线程终止后，未必就立即销毁，有些OS为了节省线程创建的时机（因为要分配内存和初始化一些变量），会复用处于TERMINATED状态的线程</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-线程模型\"><a href=\"#3-线程模型\" class=\"headerlink\" title=\"3.线程模型\"></a>3.线程模型</h4><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220706171016908.png\" alt=\"image-20220706171016908\"></p>\n<ol>\n<li>d<ol>\n<li>由操作系统负责内核调度，调用程序运行在内核空间，CPU处于内核态。操作系统暴漏内核的系统调用给应用程序使用，比如Linux中的pthread、C++中的std::thread。</li>\n<li>内核线程也叫做1：1模型，表示一个应用程序的用户线程（比如Java Thread创建的线程对象）对应一个内核线程</li>\n<li>缺点是：系统调用会导致用户态和内核态的上下文切换，比较耗时</li>\n</ol>\n</li>\n<li>用户线程：<ol>\n<li>概念：线程的调度由虚拟机完成，因为虚拟机本质上就是一个应用程序，运行在用户空间，所以，用户线程也叫做用户空间线程或用户态线程。协程就是用户线程</li>\n<li>调度：调度程序会通过调度算法来调度用户线程，调度算法大部分都是依靠轮询的策略。调度是在用户空间完成的，完全不需要OS内核的参与，避免可上下文切换。</li>\n<li>虚拟机：保存用户线程的上下文，并且为每个用户线程维护独立的函数调用栈</li>\n<li>用户线程也叫做M：1模型，也就是M个用户线程对应1个内核线程。虚拟机本质上也是程序，在运行时，OS会为其创建进程，并且是单内核线程</li>\n<li>缺点：只能共享一个内核线程，没法利用多核优势；无法使用阻塞模式的系统调用，一个用户线程阻塞其它也都无法工作</li>\n</ol>\n</li>\n<li>混合线程：<ol>\n<li>一个进程中的M个用户线程对应N个内核线程，M一般大于N，M个线程并不会绑定在一个内核线程上，不用的用户线程可以分散到不同的CPU上，可以利用计算机的多核优势</li>\n<li>M：N模型也可以称为是协程，Go语言中的协程就是基于M：N模型来实现的，也叫做Go协程</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-实现原理\"><a href=\"#4-实现原理\" class=\"headerlink\" title=\"4.实现原理\"></a>4.实现原理</h4><ol>\n<li>Green Thread：就是M：1线程模型，名字是因为开发团队名字叫Green Team，JDK1.3便已经废弃。</li>\n<li>Native Thread：内核线程模型，也就是1：1线程模型，Java线程库是对OS内核线程系统调用的二次封装，而且为了实现统一的编程接口，定义了自己的线程状态和优先级<ol>\n<li>线程状态有：NEW、RUNNABLE、WAITING、TIMED_WAITING、BLOCKED、TERMINATED</li>\n<li>线程优先级有10个，从1到10</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-代码实现\"><a href=\"#5-代码实现\" class=\"headerlink\" title=\"5.代码实现\"></a>5.代码实现</h4><h5 id=\"1-创建一个线程\"><a href=\"#1-创建一个线程\" class=\"headerlink\" title=\"1.创建一个线程\"></a>1.创建一个线程</h5><ol>\n<li>通过实现 Runnable 接口</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class RunnableDemo implements Runnable &#123;\n   private Thread t;\n   private String threadName;\n   \n   RunnableDemo( String name) &#123;\n      threadName &#x3D; name;\n      System.out.println(&quot;Creating &quot; +  threadName );\n   &#125;\n   \n   public void run() &#123;\n      System.out.println(&quot;Running &quot; +  threadName );\n      try &#123;\n         for(int i &#x3D; 4; i &gt; 0; i--) &#123;\n            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);\n            &#x2F;&#x2F; 让线程睡眠一会\n            Thread.sleep(50);\n         &#125;\n      &#125;catch (InterruptedException e) &#123;\n         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);\n      &#125;\n      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);\n   &#125;\n   \n   public void start () &#123;\n      System.out.println(&quot;Starting &quot; +  threadName );\n      if (t &#x3D;&#x3D; null) &#123;\n         t &#x3D; new Thread (this, threadName);\n         t.start ();\n      &#125;\n   &#125;\n&#125;\n \npublic class TestThread &#123;\n \n   public static void main(String args[]) &#123;\n      RunnableDemo R1 &#x3D; new RunnableDemo( &quot;Thread-1&quot;);\n      R1.start();\n      \n      RunnableDemo R2 &#x3D; new RunnableDemo( &quot;Thread-2&quot;);\n      R2.start();\n   &#125;   \n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>通过继承 Thread 类本身</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class ThreadDemo extends Thread &#123;\n   private Thread t;\n   private String threadName;\n   \n   ThreadDemo( String name) &#123;\n      threadName &#x3D; name;\n      System.out.println(&quot;Creating &quot; +  threadName );\n   &#125;\n   \n   public void run() &#123;\n      System.out.println(&quot;Running &quot; +  threadName );\n      try &#123;\n         for(int i &#x3D; 4; i &gt; 0; i--) &#123;\n            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);\n            &#x2F;&#x2F; 让线程睡眠一会\n            Thread.sleep(50);\n         &#125;\n      &#125;catch (InterruptedException e) &#123;\n         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);\n      &#125;\n      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);\n   &#125;\n   \n   public void start () &#123;\n      System.out.println(&quot;Starting &quot; +  threadName );\n      if (t &#x3D;&#x3D; null) &#123;\n         t &#x3D; new Thread (this, threadName);\n         t.start ();\n      &#125;\n   &#125;\n&#125;\n \npublic class TestThread &#123;\n \n   public static void main(String args[]) &#123;\n      ThreadDemo T1 &#x3D; new ThreadDemo( &quot;Thread-1&quot;);\n      T1.start();\n      \n      ThreadDemo T2 &#x3D; new ThreadDemo( &quot;Thread-2&quot;);\n      T2.start();\n   &#125;   \n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>通过 Callable 和 Future 创建线程</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CallableThreadTest implements Callable&lt;Integer&gt; &#123;\n    public static void main(String[] args)  \n    &#123;  \n        CallableThreadTest ctt &#x3D; new CallableThreadTest();  \n        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);  \n        for(int i &#x3D; 0;i &lt; 100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  \n            if(i&#x3D;&#x3D;20)  \n            &#123;  \n                new Thread(ft,&quot;有返回值的线程&quot;).start();  \n            &#125;  \n        &#125;  \n        try  \n        &#123;  \n            System.out.println(&quot;子线程的返回值：&quot;+ft.get());  \n        &#125; catch (InterruptedException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125; catch (ExecutionException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n    &#125;\n    @Override  \n    public Integer call() throws Exception  \n    &#123;  \n        int i &#x3D; 0;  \n        for(;i&lt;100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  \n        &#125;  \n        return i;  \n    &#125;  \n&#125;</code></pre>\n\n<h5 id=\"2-线程状态\"><a href=\"#2-线程状态\" class=\"headerlink\" title=\"2.线程状态\"></a>2.线程状态</h5><ol>\n<li>新建</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestJoin implements Runnable&#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestJoin testJoin &#x3D; new TestJoin();\n        Thread thread &#x3D; new Thread(testJoin);\n        thread.start();\n        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n            if (i &#x3D;&#x3D; 200)&#123;\n                thread.join();\n            &#125;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+i);\n        &#125;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;线程vip来了&quot;+i);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>阻塞</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.text.SimpleDateFormat;\nimport java.util.Date;\n\n&#x2F;&#x2F;模拟网络延时\n&#x2F;&#x2F;模拟倒计时\npublic class TestSleep &#123;\n    public void printSlowly() throws InterruptedException &#123;\n\n        char[] chars &#x3D; new char[1024];\n        chars &#x3D; &quot;写Java的说门口开了一家Spring串店，挺火。写php的说去以前高中门口的烤面筋小摊吃，怀旧。写python的说在家里炒点牛肉片跟去外面吃烧烤一样，还快\\n&quot;.toCharArray();\n        for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n            System.out.print(chars[i]);\n            Thread.sleep(20);\n        &#125;\n    &#125;\n    public void tenDown() throws InterruptedException &#123;\n        int num &#x3D; 10;\n        Date startTime &#x3D; new Date(System.currentTimeMillis());&#x2F;&#x2F;获取当前时间\n        while(true)&#123;\n            Thread.sleep(1000);\n            System.out.println(num--);\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(startTime));\n            startTime &#x3D; new Date(System.currentTimeMillis());\n            if (num&lt;&#x3D;0) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestSleep testSleep &#x3D; new TestSleep();\n        testSleep.printSlowly();\n        testSleep.tenDown();\n\n    &#125;\n&#125;\npublic class TestJoin implements Runnable&#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        TestJoin testJoin &#x3D; new TestJoin();\n        Thread thread &#x3D; new Thread(testJoin);\n        thread.start();\n        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n            if (i &#x3D;&#x3D; 200)&#123;\n                thread.join();\n            &#125;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;+i);\n        &#125;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;线程vip来了&quot;+i);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>查看状态</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestState &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread thread &#x3D; new Thread(()-&gt;&#123;\n            for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n                try &#123;\n                    Thread.sleep(1000);\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        &#125;);\n        &#x2F;&#x2F;观察状态\n        Thread.State state &#x3D; thread.getState();\n        System.out.println(state);\n\n        &#x2F;&#x2F;观察启动后\n        thread.start();\n        state &#x3D; thread.getState();\n        System.out.println(state);\n\n        &#x2F;&#x2F;只要线程不终止，就一直输出状态\n        while(state !&#x3D; Thread.State.TERMINATED)&#123;\n            Thread.sleep(100);\n            state &#x3D; thread.getState();&#x2F;&#x2F;更新线程状态\n            System.out.println(state);\n        &#125;\n        thread.setPriority(Thread.MAX_PRIORITY);\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>线程终止</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;测试stop\n&#x2F;&#x2F;1.建议线程正常终止--&gt;利用次数，不建议死循环\n&#x2F;&#x2F;2.建议使用标志位---&gt;设置一个标志位\n&#x2F;&#x2F;3.不要使用stop或者destroy等过时的或者JDK不建议使用的方法\npublic class TestStop implements Runnable&#123;\n\n    &#x2F;&#x2F;1.设置一个标注为\n    private Boolean flag&#x3D; true;\n    @Override\n    public void run() &#123;\n        int i &#x3D; 0;\n        while(flag)&#123;\n            System.out.println(&quot;run...Thread&quot;+i++);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;设置一个公开方法用来停止线程，转换标志位\n    public void stop()&#123;\n        this.flag &#x3D; false;\n    &#125;\n    public static void main(String[] args) &#123;\n        TestStop testStop &#x3D; new TestStop();\n        new Thread(testStop).start();\n        for (int i &#x3D; 0; i &lt; 1000; i++) &#123;\n            System.out.println(&quot;main&quot;+i);\n            if (i &#x3D;&#x3D; 900)&#123;\n                &#x2F;&#x2F;调用stop方法切换标志位，该线程停止了\n                testStop.stop();\n                System.out.println(&quot;该线程停止了&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h5 id=\"3-线程池\"><a href=\"#3-线程池\" class=\"headerlink\" title=\"3.线程池\"></a>3.线程池</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class TestPool &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;1.创建服务，创建线程池\n        ExecutorService service &#x3D; Executors.newFixedThreadPool(10);\n        &#x2F;&#x2F;2.执行\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        service.execute(new MyThread());\n        &#x2F;&#x2F;3.关闭连接\n        service.shutdown();\n    &#125;\n&#125;\nclass MyThread implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n\n        System.out.println(Thread.currentThread().getName());\n\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"6-线程安全\"><a href=\"#6-线程安全\" class=\"headerlink\" title=\"6.线程安全\"></a>6.线程安全</h4><ol>\n<li><p>线程安全：描述的对象可以是函数也可以是类，线程安全意味者不同线程并发执行相同的函数，或者不同线程执行一个类的不同函数，因为线程切换，函数内的指令都可以任意交叉执行，最终任意执行顺序得到的结果都是相同的，符合预期的。</p>\n</li>\n<li><p>临界区和竞态</p>\n<ol>\n<li><p>临界区：可能会引起线程不安全的局部代码块，一般包括以下两个特征</p>\n<ol>\n<li><p>访问共享资源：类中的成员变量、参数传递进来的共享对象（注意指令重排序问题）</p>\n</li>\n<li><p>包含复合操作：先检查再执行、先读取再修改后写入</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;先检查再执行\npublic class Singleton &#123;\n    private static Singleton instance;\n    private Singleton()&#123;&#125;\n    public static Singleton getInstance()&#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;先读取再修改后写入\npublic class Demo &#123;\n    private int count &#x3D; 0;\n    public void increment()&#123;\n        count++;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>竞态：两个线程处于竞态执行临界区，就有可能执行出错，就有可能线程不安全</p>\n</li>\n</ol>\n</li>\n<li><p>互斥和同步</p>\n<ol>\n<li>互斥：对临界区加锁，让临界区变为原子操作，目的就是让多个线程互斥访问临界区</li>\n<li>同步：多个线程之间如何协同执行，比如一个线程等待另一个线程执行完成后再执行</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-JMM\"><a href=\"#2-JMM\" class=\"headerlink\" title=\"2.JMM\"></a>2.JMM</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Java内存模型（规范为JSR-133）用来解决多线程的三大问题：可见性问题、有序性问题、原子性问题。模型中Java定义了一些关键字（volatile、synchronized），或者增强了某些关键字（final），以此来限制内存中多线程共享数据的读写方式，最终达到解决可见性、有序性、原子性问题。</p></blockquote>\n<h4 id=\"1-CPU缓存导致可见性问题\"><a href=\"#1-CPU缓存导致可见性问题\" class=\"headerlink\" title=\"1.CPU缓存导致可见性问题\"></a>1.CPU缓存导致可见性问题</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>内存的访问速度对于CPU来说太慢了，依靠局部性原理通过缓存来提高数据读写速度。在单线程或单CPU多线程下并没有影响，但是在多CPU多线程下会导致CPU缓存之间存在数据的一致性问题，或叫可见性问题</p></blockquote>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220715143551636.png\" alt=\"image-20220715143551636\"></p>\n<ol>\n<li>大部分CPU都支持缓存一致性协议，可以在硬件层面解决各个CPU缓存数据的一致性问题，比如MESI，它具有四种状态：<ul>\n<li>M（Modified）：表示当前缓存行中的数据已被修改，但并未同步到内存</li>\n<li>E（Exclusive）：表示当前缓存行中有这个数据，其他CPU缓存中没有这个数据</li>\n<li>S（Shared）：表示当前缓存中有这个数据，其它CPU缓存中也有这个数据</li>\n<li>I（Invalid）：表示当前缓存行中的数据已经失效，说明其他CPU对数据进行了修改，下次CPU读取数据要从内存中读取，并同步更新缓存</li>\n</ul>\n</li>\n<li>Store Buffer<ol>\n<li>从MESI状态来看，当多个CPU缓存中都有同一数据时，一个CPU对缓存数据进行修改，需要广播invalidate消息，其他CPU收到invalidate消息之后，将对应的缓存行设置为l，然后再发送invalid ack消息给这个CPU。此时，这个CPU才可以将数据更新写入缓存和内存。</li>\n<li>因为保证缓存数据一致性，写操作需要大量耗时，所以在CPU和CPU缓存之间，增加了类似消息中间件的存储结构，叫做Store Buffer，用来异步执行写操作</li>\n<li>CPU将写操作的所有信息存储到Store Buffer之后，就立刻返回执行其他指令了，由Store Buffer来完成剩下的工作，包括发送invalidate消息，接收invalidate ack，写入缓存和内存。引入Store Buffer之后，在读取数据时，CPU会先从Store Buffer中读取，如果读取不到再从缓存中读取。这样就可以保证CPU总是能读取到自己写入的最新值。</li>\n</ol>\n</li>\n<li>Invalidate Queue<ol>\n<li>Store Buffer发送给其他CPU的invalidate消息之后，需要等待其他CPU设置缓存失效并返回invalidate ack消息，才能执行更新缓存和内存的操作。而其他CPU有可能忙于其他事情，导致来不及设置缓存失效和回复invalidate ack消息，这样写操作便会堆积在Store Buffer中很长时间。</li>\n<li>Store Buffer的存储空间很小，当有大量写操作堆积在Store Buffer中等待执行，导致Store Buffer无法存储更多数据时，CPU往Store Buffer中存储新的写操作，便会阻塞等待，此时，Store Buffer便失去了作用。</li>\n<li>为了解决这个问题，计算机科学家又引入了一个新的存储结构: Invalidate Queue，专门用来存储invlidate消息和回复invalidateack消息，并异步执行设置缓存行失效操作。这样就进一步节省了Store Buffer处理写操作的时间，能够让Store Buffer尽快清空。</li>\n</ol>\n</li>\n<li>JIT编译时，会进行一定的编译优化，所以有时判断真假的语句会直接将变量转换为true或false，解决这种情况的方法时：禁止JIT编译来运行代码，或者将变量声明为volatile后JIT就不会优化</li>\n</ol>\n<h4 id=\"2-指令重排导致有序性问题\"><a href=\"#2-指令重排导致有序性问题\" class=\"headerlink\" title=\"2.指令重排导致有序性问题\"></a>2.指令重排导致有序性问题</h4><ol>\n<li><p>通过指令重排序可以提高指令的运行效率，但是会出现问题使得执行结果不确定，如下所示，因为t2线程执行的两行代码没有任何联系，会发生指令重排，在多核情况下t1和t2同时运行，t2代码的执行顺序会影响到t1的输出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private static boolean ready &#x3D; false;\n    private static int value &#x3D; 1;\n\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                while (!ready) &#123;\n                &#125;\n                System.out.println(value);\n            &#125;\n        &#125;);\n        Thread t2 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                value &#x3D; 2;\n                ready &#x3D; true;\n            &#125;\n        &#125;);\n        t1.start();\n        t2.start();\n        t1.join();\n        t2.join();\n    &#125;\n&#125;</code></pre></li>\n<li><p>在代码的编译执行过程中，会发生3种不同类型的重排序：</p>\n<ol>\n<li>编译优化导致的重排序（见JVM）</li>\n<li>CPU指令并行执行导致的重排序（如上代码）：为了提高指令的执行效率，现在的处理器大都采用指令级并行技术（Instruction-Level Parallelism，简称IPL），来并行的执行多条指令。CPU从内存中逐一读取并解码指令，然后放入执行队列，每次从执行队列中选择没有依赖关系的几条指令来并行执行。在多线程情况下就会出现指令顺序的重排序</li>\n<li>硬件内存模型导致的重排序</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-线程竞争导致原子性问题\"><a href=\"#3-线程竞争导致原子性问题\" class=\"headerlink\" title=\"3.线程竞争导致原子性问题\"></a>3.线程竞争导致原子性问题</h4><ol>\n<li>多个线程同时读写一个数据，会导致结果不确定，因为是非原子操作。</li>\n</ol>\n<h4 id=\"4-volatile\"><a href=\"#4-volatile\" class=\"headerlink\" title=\"4.volatile\"></a>4.volatile</h4><ol>\n<li><p>解决可见性问题：用volatile修饰的变量，在编译成机器指令时，会加入特殊指令，使得CPU对此变量的修改立即写入内存，并通过其它CPU更新缓存数据</p>\n</li>\n<li><p>解决有序性问题：volatile通过禁止指令重排序来解决有序性问题，并且是部分指令重排</p>\n<ol>\n<li><p>完全禁止指令重排：volatile修饰的变量的读写指令不可以跟其前面或后面的读写指令重排</p>\n</li>\n<li><p>部分禁止指令重排：也可以保证多线程运行的有序性，规则有：</p>\n<ul>\n<li>对volatile修饰的变量执行写操作，JMM只禁止位于其起前面的读写操作不与其进行重排序，但后面的可以</li>\n<li>对volatile修饰的变量执行读操作，JMM只禁止位于其起后面的读写操作不与其进行重排序，但前面的可以</li>\n</ul>\n</li>\n<li><p>内存屏障（Memory Barrier）：为了实现部分指令重排，JMM定义了4个细粒度的内存屏障，也叫做内存栅栏（Memory Fence），其底层依赖CPU提供的内存屏障指令。分别是StoreStore、StoreLoad、LoadLoad、LoadStore，指令含义为：StoreStore内存屏障禁止屏障前面的写操作，跟屏障后面的写操作重排序。StoreLoad内存屏障禁止屏障前的写操作，跟屏障后的读操作重排序。LoadStore内存屏障禁止屏障前的读操作，跟屏障后的写操作重排序。LoadLoad内存屏障禁止屏障前的读操作，跟屏障后的读操作重排序。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220711163632975.png\" alt=\"image-20220711163632975\"></p>\n<ol>\n<li>JMM内存模型定义部分禁止重排序的方法：volatile写操作后或者volatile读操作前会添加[StoreLoad]来防止volatile写和读的重排序，一般选择添加在写后面，因为读多写少。</li>\n</ol>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220711163948428.png\" alt=\"image-20220711163948428\"></p>\n<ol start=\"2\">\n<li>对于X86 CPU来说只需要在volatile写操作后添加一条额外的指令，所以volatile的性能比synchronized更好</li>\n<li>内存屏障也可以用来禁止编译优化（JIT编译）导致的指令重排序</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>解决原子性问题：</p>\n<ol>\n<li>在32位计算机上，读写64位的long或double类型数据，会执行两次内存读写操作，如果用volatile修饰，那么编译器会在两次读或写之间锁定总线指令，保证变量读写的原子性，但在64位机上就不需要了</li>\n<li>自增语句（count++）因为是对寄存器的值进行操作，但是volatile对变量只能保证立刻写入内存让所有CPU的缓存失败，所以不能影响寄存器内的值，需要synchronized关键字</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-synchronized-amp-final\"><a href=\"#5-synchronized-amp-final\" class=\"headerlink\" title=\"5.synchronized&amp;final\"></a>5.synchronized&amp;final</h4><ol>\n<li>synchronized：通过让原本并发执行的代码串行执行，并且每次加锁和释放锁，都会同步CPU缓存和内存中的数据，可以解决可见性、有序性、原子性的问题</li>\n<li>final<ol>\n<li>final用来限制变量是否可变</li>\n<li>JMM对final的语义做了增强，禁止编译器将构造函数中对final变量的写操作，重排序到对象引用之后，也就是禁止初始化对象（构造函数中的语句）和将内存空间赋值给引用的重排序，否则在多线程环境下，一个线程可能看到final变量的两个不同的值</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-happens-before规则\"><a href=\"#6-happens-before规则\" class=\"headerlink\" title=\"6.happens-before规则\"></a>6.happens-before规则</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>用于检查自己编写的代码在多线程下的执行顺序是否符合预期</p></blockquote>\n<ol>\n<li>单线程规则:在单线程中，前面的操作先于后面的操作执行。但是编译器可以偷偷的重排序</li>\n<li>锁规则:一个线程释放锁先于另一个线程获取锁。</li>\n<li>volatile规则:在时间序上，如果对一个volatile变量的写操作，先于后面的对这个变量的读操作执行，那么，volatile读操作必定能读到volatile写操作的结果。也就是说，如果x为volatile变量，在t1时刻执行了x=1，在t2时刻执行了y=x， t1小于t2，那么y肯定等于1。不管编译器或者CPU会如何优化指令的执行顺序，都能保证这个结果。</li>\n<li>线程启动规则:如果线程A在执行过程中，启动了线程B，那么，线程A对共享变量的修改对线程B可见。</li>\n<li>线程终结规则:如果线程A在执行的过程中，通过Thread.join()等待钱程B终止，那么，线程B对共享变量的修改，在线程B终止之后，对线程A可见。</li>\n<li>线程中断规则:线程A对线程B调用interrupt()方法，先行发生于线程B的代码检测到中断事件的发生。</li>\n<li>对象终结规则:一个对象的初始化完成，先行发生于调用它的finalize()方法。</li>\n<li>传递规则:如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。</li>\n</ol>\n<h3 id=\"3-互斥锁\"><a href=\"#3-互斥锁\" class=\"headerlink\" title=\"3.互斥锁\"></a>3.互斥锁</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>临界区互斥的手段，提供了各种不同粒度和作用的锁，最大限度的减小加锁范围，提高代码并发执行程度。基本功能：多个线程进程获取锁，没有得到的排队阻塞等待并且不分配时间片，锁释放后会通知排队等待的锁，得到锁后取消阻塞，并且给相应的内核线程分配时间片</p></blockquote>\n<h4 id=\"1-Synchronized\"><a href=\"#1-Synchronized\" class=\"headerlink\" title=\"1.Synchronized\"></a>1.Synchronized</h4><ol>\n<li><p>对象锁</p>\n<ol>\n<li><p>方法：在方法的声明上加<code>synchronized</code>关键字</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;两个方法加了相同的锁，函数本身不可并发执行，函数间也不可并发执行\npublic class Counter &#123;\n    private int count &#x3D; 0;\n    public synchronized void add(int value) &#123;\n        count +&#x3D; value;\n    &#125;\n    public synchronized void substract(int value)&#123;\n        count -&#x3D; value;\n    &#125;\n&#125;</code></pre></li>\n<li><p>局部代码块：为了提高代码执行的并发度，减小加锁范围</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Counter &#123;\n    private int count &#x3D; 0;\n    public void add(int value)&#123;\n        synchronized (this) &#123;\n            count +&#x3D; value;\n        &#125;\n    &#125;\n    public void substract(int value) &#123;\n        synchronized (this) &#123;\n            count -&#x3D; value;&#125;\n    &#125;\n&#125;\n</code></pre></li>\n<li><p><code>synchronized</code>底层使用的锁叫做Monitor锁，无法直接创建和使用，Monitor锁是寄生存在的，每个对象都会拥有一个。如果想要一个新的Monitor锁只需要使用一个新的对象，并在<code>synchronized</code>关键字后附带声明要使用哪个对象的Monitor锁。不加声明隐式的使用<code>this</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Counter &#123;\n    private int increasedsum &#x3D; 0;\n    private int decreasedsum &#x3D; 0;\n    private Object obj1 &#x3D; new Object();\n    private Object obj2 &#x3D; new Object();\n    \n    public void add(int value)&#123;\n        synchronized (obj1) &#123;\n            increasedSum +&#x3D; value;\n        &#125;\n    &#125;\n    public void substract(int value) &#123;\n        synchronized (obj2)&#123;\n            decreasedsum -&#x3D; value;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>类锁</p>\n<ol>\n<li><p>对象锁只能保证一个对象上的函数不能并发执行，但是为了做到不仅一个对象的某个函数不能并发执行，同一个类的所有对象的这个函数都不能并发执行，所以使用类锁代替对象锁，即<code>synchronized</code>后跟随某个类的Class对象即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Wallet &#123;\n    private int balance;\n    public void transferTo(Wallet targetwallet, int amount) &#123;\n        synchronized (Wallet.class) &#123;\n            if (this.balance &gt;&#x3D; amount) &#123;\n                this.balance -&#x3D; amount;\n                targetWallet.balance +&#x3D; amount;&#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>对于对象锁，<code>synchronized</code>底层使用的是对象上的Monitor锁；对于类锁<code>synchronized</code>使用的也是某个对象上的Monitor锁，只不过这个对象是类的Class类对象，class类对象是所有类的抽象，每个类再JVM中都有一个Class类对象来表示这个类</p>\n</li>\n<li><p>除了显示声明类锁，对静态方法加<code>synchronized</code>也会隐式地使用当前类的类锁</p>\n</li>\n</ol>\n</li>\n<li><p>字节码：只是简单的翻译了<code>synchronized</code></p>\n<ol>\n<li>作用于方法：在flags中添加了<code>ACC_SYNCHRONIZED</code>标记，其它部分不变</li>\n<li>作用域局部代码块：字节码通过<code>monitorenter</code>和<code>monitorexit</code>来标记<code>synchronized</code>的作用范围<ul>\n<li>有可能由多个<code>monitorexit</code>对应着抛出异常后仍能解锁</li>\n<li><code>synchronized</code>可以选择任意对象的Monitor锁，通过<code>monitorenter</code>前面的几行字解码来表示用了哪个对象的Monitor锁</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>锁类别：为了提高加解锁的效率，在不同场景下使用不同的锁来实现<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220720095222384.png\" alt=\"image-20220720095222384\"></p>\n<ol>\n<li><p>重量级锁，即Monitor锁，synchronized锁被多个线程交叉使用，存在竞争使用的情况</p>\n<ol>\n<li><p>不同JVM有不同的实现版本，在Hotspot JVM实现中，Monitor锁对应的实现类为<code>ObjectMonitor</code></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class ObjectlMonitor &#123;\n    void * volatile _object;&#x2F;&#x2F;该Monitor锁所属的对象\n    void * volatile _owner;&#x2F;&#x2F;获取到该Monitor锁的线程\n    ObjectWaiter * volatile_cxq;&#x2F;&#x2F;没有获取到锁的线程暂时加入_cxq\n    ObjectWaiter * volatile _EntryList;&#x2F;&#x2F;存储等待被唤醒的线程\n    &#x2F;&#x2F;存储调用了wait()的线程，用来实现wait()、notify()线程同步功能\n    ObjectWaiter * volatile _waitSet;\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li><p>通过对象查找到对应的Monitor锁：对象头中的<code>Mark Word</code>字段便可以用来记录对象所对应的Monitor锁</p>\n<ol>\n<li><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220718100144111.png\" alt=\"image-20220718100144111\"></p>\n</li>\n<li><p>Mark Word字段<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220720092211023.png\" alt=\"image-20220720092211023\"></p>\n</li>\n</ol>\n</li>\n<li><p>ObjectMonitor中互斥锁基本功能的实现：</p>\n<ol>\n<li><p><strong>多个线程竞争获取锁：</strong></p>\n<ul>\n<li>通过CAS操作来设置<code>_owner</code>字段，谁设置成功，谁获取这个Moitor锁</li>\n<li>参与竞争的线程会先检查<code>_owner</code>是否是null，如果是再将自己的Thread对象地址赋值给<code>_owner</code></li>\n<li>底层JVM依靠CPU提供的<code>cmpxchg</code>指令来实现CAS操作，CPU通过总线锁来保证<code>cmpxchg</code>指令的原子性来保证CAS操作的线程的线程安全性，相当于在硬件层面上给CAS操作加了锁</li>\n</ul>\n</li>\n<li><p><strong>没有获取到锁的线程队等待获取锁：</strong>在<code>_cxq</code>中等待锁，<code>_cxq</code>是一个单向链表，链表节点定义为<code>class Objectwaiter : public StackObj</code>，里面包含线程的信息和结构信息</p>\n</li>\n<li><p><strong>锁释放之后会通知排队等待的锁去竞争锁：</strong></p>\n<ul>\n<li>当持有锁的线程释放锁之后，会从<code>_EntryList</code>取出一个线程，通过CAS来竞争获取Monitor锁（防止有新来的）。</li>\n<li>如果<code>_EntryList</code>中没有线程，就将<code>_cxq</code>中的线程全部移到<code>_EntryList</code>中，因为可以减少多线程环境下链表存取操作的冲突。<code>_cxq</code>只负责将存操作（往链表中添加节点)，<code>_EntryList</code>负责取操作(从链表中删除节点)。</li>\n</ul>\n</li>\n<li><p><strong>没有获取锁的线程会阻塞，并且对应的内核线程不再被分配时间片：</strong>应用程序将代码提交给Java线程（Runnable接口中的run()中的代码），当内核线程执行到<code>synchronized</code>关键字，会执行上述的1-3个步骤，如果没得到锁则嗲用park()函数将自己阻塞，Linux下实现如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">pthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;\nvoid park() &#123;\n    pthread_mutex_lock(&amp;mutex);\n    pthread_cond_wait(&amp;cond,&amp;mutex);&#x2F;&#x2F;阻塞等待其他线程发送信号\n    pthread_mutex_unlock(&amp;mutex);\n&#125;</code></pre></li>\n<li><p><strong>阻塞线程获取到锁之后取消阻塞，并且对应的内核线程将被分配时间片：</strong>通过调用unpark()函数来取消对应内核线程的阻塞状态，来让它去执行竞争锁的代码。Linux下实现如下：</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void unpark()&#123;\n    pthread_mutex_lock(&amp;mutex);\n    pthread _cond_signal(&amp;cond);\n    pthread_mutex_unlock(&amp;mutex);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>偏向锁：一个synchronized锁只被一个线程使用</p>\n<ol>\n<li>新创建的对象，Mark Word处于无锁状态（可跳过），并随即很快变为偏向锁状态，并且threadID为0。如果某个线程在某个对象上使用synchronized关键字，发现其处于偏向锁状态且threadID为0，那么就通过CPU提供的CAS原子操作来竞争这个偏向锁（看Mark Word是否等于5，若等于在设置threadID为自己的线程ID）</li>\n<li>获得到锁的情况：执行业务代码（synchronized包裹的代码），执行完不会解锁偏向锁，即不会更改theadID为0，为了提高同一线程再次加锁的效率（减少CAS操作的次数）</li>\n<li>没获得到锁的情况：<ol>\n<li>问题：一个线程获取锁，另一个线程来请求；或者更特殊情况，两个线程竞争偏向锁，只有一个得到。</li>\n<li>解决：请求偏向锁的线程将锁升级为轻量级锁，升级过程中虚拟机暂停持有偏向锁的线程，查看是否在运行synchronized内的代码。如果已不再使用，虚拟机就像Mark Word设置为无锁状态；如果还在使用，虚拟机就将偏向锁升级为轻量级锁<ul>\n<li>暂停的原因：检查是否运行synchronized的代码是复合操作，非线程安全</li>\n<li>如何暂停：因为挂机线程的系统调用在不同平台上不一样，而且有时会导致IO出问题，所以虚拟机选择复用垃圾收集器中的STW（Stop The World）功能</li>\n<li>未在使用时可不可以跳过无锁状态继续保持偏向锁（只把ThreadID设置为0），将偏向锁移交给另一线程使用：STW会暂停所有线程，偏向锁升级代价大，如果将偏向锁交给另一线程就可能带来更多的STW操作，不如直接使用重量级锁</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>轻量级锁：一个synchronized锁被多个线程交叉使用，不存在竞争使用的情况</p>\n<ol>\n<li>Mark Word处于无锁状态：线程会先在自己栈中创建一个Lock Record结构（用于解锁时快速恢复为无d锁状态），并将Mark Word拷贝到此结构中的Displaced Mark Word中。然后线程通过CAS操作去竞争轻量级锁，先检查Mark Word的低三位是否为001（无锁状态），如果是的话再将Mark Word中的Lock Record指针设置为指向自己的Lock Record</li>\n<li>Mark Word处于轻量级锁状态：暂缓升级为重量级锁，通过自旋的方式循环执行CAS操作，如果执行了很多次之后，仍然没有等到另一个线程释放轻量级锁，那么就将其升级为重量级锁<ul>\n<li>自适应自旋：针对所有在用的轻量级锁，如果上次自旋之后成功等到了另一个线程释放轻量级锁，那么下次自旋的次数就增加，如果上次自旋没有等到等到另一个线程释放轻量级锁，那么下次自旋的次数就减少。</li>\n<li>锁升级：通过CAS操作，持有锁的线程继续执行，请求锁的线程负责升级任务，包括创建Monitor锁，将自己放到Monitor锁的_cxq中，调用OS系统调用来阻塞自己</li>\n<li>解锁：先检查锁标志位，如果标记为00，说明没有升级，只需要使用CAS操作解锁即可（先检查是否为00，再将Displaced Mark Word）赋值给Mark Word；如果锁标识为10，即已升级为重量级锁，那么持有轻量级锁的线程去唤醒等待重量级锁的进程</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>其他优化</p>\n<ol>\n<li><p>锁消除：虚拟机在执行JIT编译时，会根据对代码的分析(逃逸分析)，去掉某些没有必要的锁。如下示例代码所示。为了保证多线程操作的安全性，StringBuffer中的append()函数在设计实现时加了锁。但是，在下面的代码中，strBuffer是局部变量，不会被多线程共享，更不会在多线程环境下调用它的append()函数。因此append()函数的锁可以被优化消除。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public String concat(String s1, string s2)&#123;\n        stringBuffer strBuffer &#x3D; new StringBuffer();\n        strBuffer.append(s1);\n        strBuffer.append(s2);\n        return strBuffer.tostring0);\n    &#125;\n&#125;</code></pre></li>\n<li><p>锁粗化：缩小加锁范围能够提高程序的并发程度，提高多线程环境下的程序的执行效率。但是，在有些情况下，虚拟机在执行JIT编译时，会扩大加锁范围，将对多个小范围代码的加锁，合并一个对大范围代码的加锁，这样的做法叫做锁粗化。如下所示代码所示，执行10000次append()函数，会加锁解锁10000次。通过锁粗化，编译器将append()函数的锁去掉，移到for循环外面，这样就只需要加锁解锁1次即可。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n    private StringBuffer strBuffer;\n    public void reproduce(String s)&#123;\n        for (int i &#x3D; 0, i &lt;10000;++i)&#123;\n            strBuffer.append(s);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Lock\"><a href=\"#2-Lock\" class=\"headerlink\" title=\"2.Lock\"></a>2.Lock</h4><h5 id=\"1-Lock\"><a href=\"#1-Lock\" class=\"headerlink\" title=\"1.Lock\"></a>1.Lock</h5><ol>\n<li><p>概述</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220722081331063.png\" alt=\"image-20220722081331063\"></p>\n<ol>\n<li><p>Lock接口，因为平常用到的都是可重入锁，所以只有一个实现类<code>ReentrantLock</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Lock &#123;\n    void lock();\n    void lockInterruptibly() throws InterruptedException;\n    boolean tryLocK();\n    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n    void unlocK();\n    Condition newCondition();\n&#125;</code></pre></li>\n<li><p>ReadWriteLock接口，同上也只有一个实现类<code>ReetrantReadWriteLock</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ReadWriteLock &#123;\n    Lock readLock();\n    Lock writeLock();\n&#125;\n</code></pre></li>\n<li><p><code>StampedLock</code>是对<code>ReadWriteLock</code>锁的优化，在<code>ReadWriteLock</code>锁的基础上引入了读乐观锁</p>\n</li>\n</ol>\n</li>\n<li><p>可重入锁：可以被同一个线程多次加锁的锁，即在锁没有解锁前，再次加锁，通过变量记录重入次数。JUC提供的锁都是可重入锁。如下，getEvenSeq中调用了increment，如果不是可重入锁的话，increment等待getEvenSeq释放锁，就会出现死锁情况。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    Lock lock &#x3D; new ReentrantLock();\n    private int seq &#x3D; 0;\n    public int getEvenSeq() &#123;\n        lock.locK();\n        try &#123;\n            if (seq%2 &#x3D;&#x3D; 1)&#123;\n                increment();\n            &#125;\n            return seq;\n        &#125;finally &#123;\n            &#x2F;&#x2F;放在finally里是为了避免代码抛出异常导致锁无法释放，从而产生死锁问题\n            lock.unlock();\n        &#125;\n    &#125;\n    public void increment()&#123;\n        lock.lock();\n        seq++;\n        lock.unlock();\n    &#125;\n&#125;\n</code></pre></li>\n<li><p>公平锁：对于公平锁，线程会按照请求的先后顺序获得锁。synchronized锁是非公平锁（新请求可插队），ReentrantLock既支持公平锁也支持非公平锁，默认为非公平锁，通过在构造函数中添加true可声明为公平锁。非公平锁的性能比公平锁更好。ReentrantLock通过AQS（抽象队列同步器）来排队等待锁的线程</p>\n</li>\n<li><p>可中断锁：</p>\n<ol>\n<li>对于synchronized来说，一个线程在阻塞等待锁时，是无法响应中断的，即不可被打断。JUC Lock接口提供了<code>lockInterruptibly()</code>函数，支持可响应中断的方式来请求锁。</li>\n<li>可中断锁一般用于线程池中，方便关闭正在执行的线程，如Nginx中调用stop命令关闭服务器时通过中断的方式中止等待锁的线程，示例代码如下</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private static Lock lock &#x3D; new ReentrantLock();\n    public static void main(String[] args)&#123;\n        Thread t1 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    lock.lockInterruptibly();&#x2F;&#x2F;以可中断的方式请求锁\n                &#125;catch (InterruptedException e) &#123;\n                    system.out.printIln(&quot;I am interrupted&quot;);\n                    return;\n                &#125;\n                try &#123;\n                    system.out.printIn(&quot;l got lock&quot;);\n                &#125; finally &#123;\n                    lock.unlocK();\n                &#125;\n            &#125;\n        &#125;);\n        lock.Iock();&#x2F;&#x2F;主线程先获得锁并一直持有\n        t1.start();&#x2F;&#x2F;t1线程启动，调用lockInterruptibly请求锁，因锁被主线程持有，所以阻塞等待\n        t1.interrupt();&#x2F;&#x2F;主线程向t1线程发起中断，t1线程退出阻塞，响应中断，打印&quot;I am ... &quot;\n        lock.unlocK();\n    &#125;\n&#125;</code></pre></li>\n<li><p>非阻塞锁：JUC提供了tryLock()函数，支持非阻塞的方式获取锁，如果锁已经被其他线程获取，则不阻塞直接返回</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private Lock lock &#x3D; new ReetrantLock();\n    public void useTryLock()&#123;\n        if (lock.tryLock())&#123;\n            try &#123;\n                &#x2F;&#x2F; ...执行业务代码...\n            &#125;finally &#123;\n                lock.unlock();&#125;\n        &#125;else &#123;\n            &#x2F;&#x2F; ...没有获取锁，执行其他业务代码..\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>可超时锁：</p>\n<ol>\n<li>JUC提供了带参数的tryLock()函数，支持非阻塞获取锁的同时设置超时时间，即获取锁失败时，阻塞等待一会，直到超过了设定的时间，直接返回。tryLock()也可被中断。</li>\n<li>应用场景：对响应时间敏感的系统，比如面向用户的系统。比如Tomcat等服务器采用线程池的方式并发执行用户请求，如果某个特殊请求不能并发执行需要加锁，并且请求执行时间较长，当多个线程同时执行这个请求时，就会存在有线程长时间无法获得锁而请求无法执行的情况，从而导致用户请求超时和线程数量变少请求超时的问题</li>\n<li>底层实现</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private Lock lock &#x3D; new ReentrantLock();\n    public void useTryLockWithTimeout()&#123;\n        boolean locked &#x3D; false;\n        try &#123;\n            locked &#x3D; lock.tryLock(100,TimeUnit.MILLISECONDS);\n        &#125; catch (InterruptedException e) &#123;\n            system.out.printIn(&quot;I am interrupted&quot;);\n        &#125;\n        if (locked) &#123;\n            try &#123;\n                &#x2F;&#x2F;...执行业务代码...\n            &#125; finally &#123;\n                lock.unlocK();\n            &#125;\n        &#125;else &#123;\n            &#x2F;&#x2F; ...没有获取锁，执行其他业务代码...\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>读写锁：</p>\n<ol>\n<li>为了提到并发度，可多次获得读锁，JUC提供了ReadWrite接口和其实现类ReetrantReadWriteLock。读锁是一种共享锁，可以被多个线程同时获取，写锁时排他锁，同时只能被一个线程获取，读写锁之间也是排他的，有以下几种情况<ul>\n<li>如果有线程已经获取读锁，那么，请求写锁的线程将会排队等待。</li>\n<li>如果有线程已经获取读锁，并且没有线程在排队等待写锁，那么，请求读锁的线程会直接获取读锁。</li>\n<li>如果有线程已经获取到读锁，并且有线程在排队等待写锁，那么，请求读锁或者写锁的线程都将排队等待。这样可以避免等待写锁的线程迟迟获取不到写锁。</li>\n<li>如果有线程已经获取到写锁，那么请求读锁或写锁的线程都将排队等待。</li>\n</ul>\n</li>\n<li>原理</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    private ReadWriteLock rwLock &#x3D; new ReentrantReadvriteLock();\n    private Lock rLock &#x3D; rwLock.readLock();\n    private Lock wLock &#x3D; rwLock.writeLocK();\n    public void add(int idx, String elem)&#123;\n        wLock.lock();\n        try &#123;\n            list.add(idx, elem);\n        &#125; finally &#123;\n            wLock.unlocK();\n        &#125;\n    &#125;\n    public String get(int idx)&#123;\n        rLock.locK();\n        try &#123;\n            return list.get( idx);\n        &#125; finally &#123;\n            rLock. unlock();\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>乐观读锁：StampedLock是对ReadWriteLock的进一步优化，提供了读锁、写锁和乐观读锁，其中的读锁和写锁与ReadWriteLock中的类似，乐观读锁是对读锁的进一步优化，在读多写少的时候，大部分读操作都不会被写操作干扰，因此连读锁都不需要加，只有验证真正有被写操作干扰的情况下，再加读锁即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private stampedLock slock &#x3D; new stampedLock();\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    public void add(int idx, String elem)&#123;\n        long stamp &#x3D; slock.writeLock();&#x2F;&#x2F;申请写锁\n        try &#123;\n            list.add(idx, elem);\n        &#125;finally &#123;\n            slock.unlockWrite(stamp);\n        &#125;\n    &#125;\n    public String get(int idx)&#123;\n        &#x2F;&#x2F;申请乐观读锁，返回时间戳，再执行完读操作之后，验证stamp是否被更改\n        long stamp &#x3D; slock.tryOptimisticRead(); \n        String res &#x3D; list.get(idx);\n        if (slock.validate(stamp))&#123;&#x2F;&#x2F;没写操作干扰\n            return res;\n        &#125;\n        &#x2F;&#x2F;有写操作干扰，重新使用读锁\n        stamp &#x3D; slock.readLock();&#x2F;&#x2F;申请读锁\n        try &#123;\n            return list.get(idx);&#x2F;&#x2F;之前得到的结果需要作废\n        &#125;finally &#123;\n            slock.unlockRead(stamp);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"2-AQS\"><a href=\"#2-AQS\" class=\"headerlink\" title=\"2.AQS\"></a>2.AQS</h5><ol>\n<li><p>简介：全称为AbstractQueueSynchronizer，即抽象队列同步器，与synchronized底层的ObjectMonitor类相似，都实现了排队线程、阻塞线程和唤醒线程等功能，但只有一个队列。但是AQS是在JDK中基于Java语言实现，因为JUC只是JDK中的一个工具包</p>\n</li>\n<li><p>数据结构</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractQueuedSynchronizer\n    extends AbstractOwnableSynchronizer\n    implements java.io.Serializable &#123;\n\n    private transient volatile Node head;\n    private transient volatile Node tail;\n    private volatile int state;\n&#125;\npublic abstract class AbstractOwnableSynchronizer\n    implements java.io.Serializable &#123;\n    private transient Thread exclusiveOwnerThread;\n&#125;</code></pre>\n\n<ol>\n<li><p>state：用于在多个线程竞争锁时，谁设置成功了，谁获得锁。0为无人获得锁，1为有人获得锁，大于1的数表示重入的次数。多个线程竞争锁时，通过如下CAS操作来更新state的值。先检查是否为0，如果是的话，就设置为1，谁设置成功了，谁就获得了这个锁。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean compareAndSetState(int expect, int update) &#123;\n    &#x2F;&#x2F;底层仍然依靠硬件提供的原子CAS指令来实现\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n&#125;</code></pre></li>\n<li><p>exclusiveOwnerThread：存储持有锁的线程，配合state成员变量，实现锁的重入机制</p>\n</li>\n<li><p>head和tail：实现了一个双向链表的队列，Node节点定义如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final class Node &#123;\n\n    static final Node SHARED &#x3D; new Node();\n    static final Node EXCLUSIVE &#x3D; null;\n\n    static final int CANCELLED &#x3D;  1;\n    static final int SIGNAL    &#x3D; -1;\n    static final int CONDITION &#x3D; -2;\n    static final int PROPAGATE &#x3D; -3;\n\n    volatile int waitStatus;\n    volatile Node prev;\n    volatile Node next;\n    volatile Thread thread;\n    Node nextWaiter;\n\n    final boolean isShared() &#123;\n        return nextWaiter &#x3D;&#x3D; SHARED;\n    &#125;\n    final Node predecessor() throws NullPointerException &#123;\n        Node p &#x3D; prev;\n        if (p &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        else\n            return p;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>基本原理：使用了模板方法模式</p>\n<ol>\n<li><p>AQS定义了8个模板方法，可以分为两组：独占模式和共享模式。Lock为排他锁，底层只会用到AQS的独占模式，ReadWriteLock中的读锁为共享锁，写锁为排他锁，其底层会用到两种模式，Semaphore、CountdownLatch这些工具只会用到共享模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;独占模式\npublic final void acquire(int arg) &#123; ...&#125;\npublic final void acquirelnterruptibly(int arg)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean release(int arg) &#123; ...&#125;\n&#x2F;&#x2F;共享模式\npublic final void acquireShared(int arg) &#123; ...&#125;\npublic final void acquireSharedInterruptibly(int arg)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)\n\t\t\t\t\t\tthrows InterruptedException &#123; ...&#125;\npublic final boolean releaseShared(int arg) &#123; ...&#125;</code></pre></li>\n<li><p>AQS提供了4个抽象方法：没有声明为abstract是为了减少代码量，更灵活编写代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;独占模式\nprotected boolean tryAcquire(int arg)&#123;\n\t\t\t\t\t\tthrow new UnsupportedOperationException();&#125;\nprotected boolean tryRelease(int arg)&#123;\n\t\t\t\t\t\tthrow new UnsupportedOperationException();&#125;\n&#x2F;&#x2F;共享模式\nprotected int tryAcquireShared(int arg) &#123;\n\t\t\t\t\t\tthrow new UnsupportedOperationException();&#125;\nprotected boolean tryReleaseShared(int arg) &#123;\n    \t\t\t\t\tthrow new UnsupportedOperationException();&#125;</code></pre></li>\n<li><p>示例：ReetrantLock，其部分代码如下，定义了两个继承自AQS的子类：NofairSync和FairSync，分别用来实现非公平锁和公平锁，并且因为底层释放锁的逻辑相同，故又抽象出公共父类Sync</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReentrantLock implements Lock, java.io.Serializable &#123;\n    private final sync sync;\n    \n    abstract static class Sync extends AbstractQueuedSynchronizer &#123; ...&#125;\n    static final class NonfairSync extends Sync &#123; ...&#125;\n\tstatic final class FairSync extends Sync &#123; ...&#125;\n    \n\tpublic ReentrantLock()&#123;\n\t\tsync &#x3D; new NonfairSync();\n    &#125;\n\tpublic ReentrantLock(boolean fair) &#123;\n\t\tsync &#x3D; fair ? new FairSync() : new NonfairSync();\n    &#125;\n        \n\tpublic void lock()&#123;sync.acquire(1);&#125;\n\tpublic void unlock() &#123;sync.release(1);&#125;\n\t&#x2F;&#x2F;...省略其他方法...\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li><p>acquire()模板方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquire(int arg) &#123;\n    &#x2F;&#x2F;1.调用tryAcquire去竞争获取锁，如果成功，则直接返回\n    &#x2F;&#x2F;2.调用addWaiter，将线程包裹为Node节点放入等待队列的尾部\n    &#x2F;&#x2F;3.调用acquireQueued阻塞当前线程，\n    if ( !tryAcquire(arg) &amp;&amp; acquireQueued( addWaiter(Node.EXCLUSIVE), arg ) )\n        &#x2F;&#x2F;用来处理中断，如果在等待锁的过程中，被其它线程中断，\n        &#x2F;&#x2F;则在获取锁之后，将现成的中断标记设置为true\n        selfInterrupt();\n&#125;\n\nstatic final class NonfairSync extends Sync &#123;\n    &#x2F;&#x2F;尝试获取锁，成功返回true，失败返回false。AQS用于实现锁时，acquires&#x3D;1\n    protected final boolean tryAcquire(int acquires)&#123;\n        final Thread current &#x3D; Thread.currentThread();\n        int c &#x3D; getState(); &#x2F;&#x2F;获取state值\n        if (c &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;锁没有被其他线程占用\n            if (compareAndSetstate(0,acquires)) &#123; &#x2F;&#x2F;CAS设置state值为1\n                setExclusiveOwnerThread(current);&#x2F;&#x2F;设置exclusiveownerThread\n                return true;&#x2F;&#x2F;获取锁成功\n            &#125;\n        &#125;else if (current &#x3D;&#x3D; getExclusiveOwnerThread())&#123;&#x2F;&#x2F;锁已被自己占用，可重入\n            int nextc &#x3D; c + acquires; &#x2F;&#x2F; state+1\n            if (nextc &lt; 0)&#x2F;&#x2F;重入次数太多，超过了int最大值，溢出为负数，此情况罕见\n                throw new Error(&quot;Maximum lock count exceeded&quot;);\n            setState(nextc); &#x2F;&#x2F; state&#x3D;state+1,state记录重入的次数，解锁的时候用\n            return true;&#x2F;&#x2F;获取锁成功\n        &#125;\n        return false;&#x2F;&#x2F;获取锁失败\n    &#125;\n&#125;\nstatic final class FairSync extends Sync &#123;\n    protected final boolean tryAcquire(int acquires) &#123;\n        final Thread current &#x3D; Thread.currentThread();int c &#x3D; getState();\n        if (c &#x3D;&#x3D; 0)&#123;\n            if (!hasQueuedPredecessors() &amp;&amp;&#x2F;&#x2F;等待队列中没有线程时才获取锁\n                compareAndSetstate(0, acquires))&#123;\n                setExclusiveownerThread(current);\n                return true;\n            &#125;\n        &#125;else if (current &#x3D;&#x3D; getExclusiveOwnerThread())&#123;\n            int nextc &#x3D; C + acquires;\n            if (nextc &lt; 0)\n                throw new Error(&quot;Maximum lock count exceeded&quot;);setState(nextc);\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\n&#x2F;&#x2F;通过自旋和CAS操作解决往链表尾部添加节点和特殊处理链表为空所存在的线程安全问题\nprivate Node addWaiter(Node mode)&#123;\n    Node node &#x3D; new Node(Thread.currentThread(), mode);\n    &#x2F;&#x2F;自旋执行CAS操作，直到成功为止\n    for (;;) &#123;\n        Node t &#x3D; tail;\n        if (t &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;链表为空，添加虚拟头节点\n            &#x2F;&#x2F;CAS操作解决添加虚拟头节点的线程安全问题\n            if (compareAndSetHead(null, new Node()))\n                tail &#x3D; head;\n        &#125;else &#123;&#x2F;&#x2F;链表不为空\n            node.prev &#x3D; t;\n            &#x2F;&#x2F;CAS操作解决了同时往链表尾部添加节点时的线程安全问题\n            if (compareAndSetTail(t, node)) &#123;\n                t.next &#x3D; node;\n                return t;\n            &#125;\n        &#125;\n    &#125;\n    return node;\n&#125;\n&#x2F;&#x2F;主要有两部分逻辑，使用tryAcquire函数来竞争锁和使用park()函数来阻塞线程\n&#x2F;&#x2F;采用for循环来交替执行这两个逻辑，为了在吸纳成被唤醒后，并不是直接获取锁，\n&#x2F;&#x2F;而是重新竞争锁，如果竞争失败，则需要再次被阻塞\nfinal boolean acquireQueued(final Node node, int arg) &#123;\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;)&#123;\n            &#x2F;&#x2F;使用tryAcquire()函数来竞争锁\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return interrupted;\n            &#125;\n            &#x2F;&#x2F;调用park()函数来阻塞线程，等待其他线程调用unpark()函数唤醒\n            if (parkAndCheckInterrupt()) interrupted &#x3D; true;\n        &#125;\n    &#125;finally &#123;\n        if (failed) cancelAcquire(node);\n    &#125;\n&#125;\nprivate final boolean parkAndChecklnterrupt() &#123;\n    LockSupport.park(this);&#x2F;&#x2F;底层也是调用JVM提供的native park()函数来实现\n    return Thread.interrupted();\n&#125;</code></pre></li>\n<li><p>release()模板方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final boolean release(int arg) &#123;\n    &#x2F;&#x2F;tryRelease释放锁\n    if (tryRelease(arg)) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)\n            unparkSuccessor(h);&#x2F;&#x2F;内部调用unpark()函数，唤醒链表首节点对应的线程\n        return true;\n    &#125;\n    return false;\n&#125;\n&#x2F;&#x2F;公平锁和非公平锁的实现相同\nstatic final class Sync extends AbstractQueuedSynchronizer &#123;\n    &#x2F;&#x2F;释放锁，成功返回true，失败返回false。AQS用于实现锁时，releases&#x3D;1\n    protected final boolean tryRelease(int releases)&#123;\n        int c &#x3D; getState() - releases; &#x2F;&#x2F;state-1\n        &#x2F;&#x2F;不持有锁的线程去释放锁，抛出异常\n        if (Thread.currentThread() !&#x3D; getExclusiveownerThread())\n            throw new lllegalMonitorStateException();\n        boolean free &#x3D; false;\n        if (c &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;stat-1之后为0，解锁\n            free &#x3D; true;\n            setExclusiveownerThread(null);\n        &#125;\n        setState(c); &#x2F;&#x2F;state-1之后不为0，说明锁被重入多次，还不能解锁。\n        return free;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>中断机制：独占模式下的另两个<code>acquirelnterruptibly</code>和<code>tryAcquireNanos</code>分别用于实现ReetrantLock中的locklnterruptibly()函数和带超时时间的tryLock()函数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void lockInterruptibly() throws InterruptedException &#123;\n    sync.acquirelnterruptibly(1);\n&#125;\n&#x2F;&#x2F;如果线程中断则抛出异常，否则。调用tryAcquire()竞争获取锁，\n&#x2F;&#x2F;获得失败后调用doAcquireInterruptibly\npublic final void acquirelnterruptibly(int arg) throws InterruptedException &#123;\n    if (Thread.interrupted()) throw new InterruptedException();\n    if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n&#125;\n&#x2F;&#x2F;与acquireQueued()函数的代码非常相似，唯一区别是对中断的响应处理不同\nprivate void doAcquireInterruptibly(int arg) throws InterruptedException &#123;\n    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n    boolean failed &#x3D; true;\n    try &#123;\n        for(;;)&#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return;\n            &#125;\n            if (parkAndChecklnterrupt())\n                throw new lnterruptedException(); &#x2F;&#x2F;区别:抛出异常! 阻止等待锁\n        &#125;\n    &#125;finally &#123;\n        if (failed) \n            cancelAcquire(node);&#125;\n&#125;\n</code></pre></li>\n<li><p>超时机制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean tryLock(long timeout,TimeUnit unit)\n    throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1 , unit.toNanos(timeout));\n&#125;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\n    throws InterruptedException &#123;\n    &#x2F;&#x2F;如果线程被中断则抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    &#x2F;&#x2F;调用tryAcquire竞争获取锁，成功则返回，失败则调用doAcquireNanos\n    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);\n&#125;\n&#x2F;&#x2F;在acquirelnterruptibly函数基础上，添加了对超时的处理机制\nprivate boolean doAcquireNanos(int arg, long nanosTimeout)\n    throws InterruptedException &#123;\n    if (nanosTimeout &lt;&#x3D; 0L) return false;\n    final long deadline &#x3D; System.nanoTime() + nanosTimeout;\n    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n    boolean failed &#x3D; true;\n    try &#123;\n        for (;;)&#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg))&#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return true;\n            &#125;\n            nanosTimeout &#x3D; deadline - System.nanoTime();\n            if (nanosTimeout &lt;&#x3D; 0L) return false;\n            if(nanosTimeout &gt; spinForTimeoutThreshold)&#x2F;&#x2F;不着急阻塞，先自旋—下\n                LockSupport.parkNanos(this, nanosTimeout);&#x2F;&#x2F;超时阻塞\n            if (Thread.interrupted()) throw new InterruptedException();\n        &#125;\n    &#125;finally &#123;\n        if (failed) cancelAcquire(node);\n    &#125;\n&#125;\n&#x2F;&#x2F;为了支持超时阻塞，在阻塞线程时，doAcquireNanos调用parkNanos函数\n&#x2F;&#x2F;synchronized中park函数实现如下，parkNanos只将其中的pthread_cond_wait换成了\n&#x2F;&#x2F;pthread_cond_timewait，便可实现超时等待。\npthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;\nvoid park() &#123;\n    pthread_mutex_lock(&amp;mutex);\n    pthread_cond_wait(&amp;cond,&amp;mutex);&#x2F;&#x2F;阻塞等待其他线程发送信号\n    pthread_mutex_unlock(&amp;mutex);\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-ReadWriteLock\"><a href=\"#3-ReadWriteLock\" class=\"headerlink\" title=\"3.ReadWriteLock\"></a>3.ReadWriteLock</h5><ol>\n<li><p>读写锁基本用法</p>\n<ol>\n<li><p>ReadWriteLock只有一个可重入的实现类ReentrantReadWriteLock</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ReadwriteLock &#123;\n    Lock readLock();\n    Lock writeLock();\n&#125;</code></pre></li>\n<li><p>基本使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    private ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\n    private Lock rLock &#x3D; rwLock.readLock();&#x2F;&#x2F;读锁\n    private Lock wLock &#x3D; rwLock.writeLock();&#x2F;&#x2F;写锁\n    public void add(String elem) &#123;\n        wLock.lock(); &#x2F;&#x2F;加写锁\n        try &#123;\n            list.add(idx, elem);\n        &#125; finally &#123;\n            wLock.unlock(); &#x2F;&#x2F;释放写锁\n        &#125;\n    &#125;\n    public String get(int idx) &#123;\n        rLock.Iock();&#x2F;&#x2F;加读锁\n        try &#123;\n            return list.get(idx);\n        &#125; finally &#123;\n            rLock.unlock();&#x2F;&#x2F;释放读锁\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>ReentrantReadWriteLock既支持公平锁有支持非公平锁，默认为非公平锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock(true); &#x2F;&#x2F;公平锁\nReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock(false);&#x2F;&#x2F;非公平锁\nReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();&#x2F;&#x2F;默认为非公平锁</code></pre></li>\n<li><p>锁升级：读写锁不支持锁升级，即一个线程获取读锁之后，在读锁释放前，不可以再获取写锁</p>\n</li>\n<li><p>锁降级：</p>\n<ol>\n<li><p>读写锁支持锁降级，一个线程在获取写锁之后，在写锁释放前，可以再获取读锁，当写锁释放之后，线程持有的锁从写锁降级为读锁</p>\n</li>\n<li><p>既有写操作又有读操作的临界区，如果先加写锁，锁释放后再加读锁，会出现线程安全的问题，所以选择在写锁释放前先加读锁，即锁降级的方式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220727084952759.png\" alt=\"image-20220727084952759\"></p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>读写锁的实现原理</p>\n<ol>\n<li><p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReentrantReadWriteLock\n    implements ReadWriteLock, java.io.Serializable &#123;\n    &#x2F;&#x2F;内部类提供实现，使用NonfairSync和FairSync来编程实现读锁（ReadLock）和\n    &#x2F;&#x2F;写锁（WriteLock），均实现了Lock接口、相同的AQS、Lock接口中的所有加解锁函数\n    private final ReentrantReadWriteLock.ReadLock readerLock;\n    private final ReentrantReadWriteLock.WriteLock writerLock;\n    final Sync sync;&#x2F;&#x2F;执行所有同步机制\n    public ReentrantReadWriteLock() &#123;\n        this(false);\n    &#125;\n    public ReentrantReadWriteLock(boolean fair) &#123;\n        sync &#x3D; fair ? new FairSync() : new NonfairSync();\n        readerLock &#x3D; new ReadLock(this);\n        writerLock &#x3D; new WriteLock(this);\n    &#125;\n    public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;\n    public ReentrantReadWriteLock.ReadLock  readLock()  &#123; return readerLock; &#125;\n    &#x2F;&#x2F;AQS的子类NonfairSync和FairSyn的公共父类\n    abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n        abstract boolean readerShouldBlock();&#x2F;&#x2F;区分公平锁和非公平锁\n        abstract boolean writerShouldBlock();&#x2F;&#x2F;区分公平锁和非公平锁\n        &#x2F;&#x2F;以下为AQS模板方法的抽象方法的实现\n        protected final boolean tryRelease(int releases) &#123;&#125;\n        protected final boolean tryAcquire(int acquires) &#123;&#125;\n        protected final boolean tryReleaseShared(int unused) &#123;&#125;\n        protected final int tryAcquireShared(int unused) &#123;&#125;\n\n        final boolean tryWriteLock() &#123;&#125;\n        final boolean tryReadLock() &#123;&#125;      \n    &#125;\n    static final class NonfairSync extends Sync &#123;\n        final boolean writerShouldBlock() &#123;return false; &#125;\n        final boolean readerShouldBlock() &#123;return apparentlyFirstQueuedIsExclusive();&#125;\n    &#125;\n    static final class FairSync extends Sync &#123;\n        final boolean writerShouldBlock() &#123;return hasQueuedPredecessors();&#125;\n        final boolean readerShouldBlock() &#123;return hasQueuedPredecessors();&#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>写锁实现</p>\n<ol>\n<li><p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static class WriteLock implements Lock, java.io.Serializable &#123;\n    private final Sync sync;\n    protected WriteLock(ReentrantReadWriteLock lock) &#123;sync &#x3D; lock.sync;&#125;\n    public void lock() &#123;sync.acquire(1);&#125;\n    public void unlock() &#123;sync.release(1);&#125;\n    public boolean tryLock( ) &#123;return sync.tryWriteLock();&#125;\n    public void lockInterruptibly() throws InterruptedException &#123;\n        sync.acquireInterruptibly(1);\n    &#125;\n    public boolean tryLock(long timeout, TimeUnit unit)\n        \t\t\t\t\t\tthrows InterruptedException &#123;\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    &#125;\n    \n    public Condition newCondition() &#123;return sync.newCondition();&#125;\n    public boolean isHeldByCurrentThread() &#123;return sync.isHeldExclusively();&#125;\n    public int getHoldCount() &#123;return sync.getWriteHoldCount();&#125;\n&#125;</code></pre></li>\n<li><p>state：低16位表示，0表示没有加写锁，1表示已经加写锁，大于1表示写锁的可重入次数</p>\n</li>\n<li><p>实现原理</p>\n<ol>\n<li><p>lock：lock调用AQS的acquire方法，其中的tryAcquire方法的实现在Sync中<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220727095916665.png\" alt=\"image-20220727095916665\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryAcquire(int acquires) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    int w &#x3D; exclusiveCount(c);&#x2F;&#x2F;高16位的值，也就是写锁的加锁情况\n    &#x2F;&#x2F;1.已经加读锁或写锁（state!&#x3D;0）\n    if (c !&#x3D; 0) &#123;\n        &#x2F;&#x2F; 已加读锁(w&#x3D;&#x3D;0)或者当前加写锁的线程不是自己\n        if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())\n            return false;&#x2F;&#x2F;去排队\n        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        &#x2F;&#x2F; 获取到了写锁\n        setState(c + acquires);&#x2F;&#x2F;更新写锁的重入次数\n        return true;\n    &#125;\n    &#x2F;&#x2F;2.没有加锁（state&#x3D;0）\n    if (writerShouldBlock() ||\n        !compareAndSetState(c, c + acquires))\n        return false;&#x2F;&#x2F;去排队\n    setExclusiveOwnerThread(current);\n    return true;&#x2F;&#x2F;获取了锁\n&#125;\n&#x2F;&#x2F;writerShouldBlock函数控制锁是否位公平锁，在state&#x3D;0，也就是没有加读锁和\n&#x2F;&#x2F;写锁的情况下，如果writerShouldBlock返回值为true，那么线程不尝试竞争锁，\n&#x2F;&#x2F;而是直接去排队，如果writerShouldBlock返回值是false，那么线程尝试竞争锁，\n&#x2F;&#x2F;失败再去排队。\n&#x2F;&#x2F;对于非公平锁，总是返回false，对于公平锁如果等待队列中有线程，则返回true</code></pre></li>\n<li><p>trylock调用tryRelease，实现在Sync中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryRelease(int releases) &#123;\n    &#x2F;&#x2F;tryRelease是AQS工作在独占模式下的函数，只能用于排他锁，也就是写锁\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    &#x2F;&#x2F;更新state值，写锁的重入次数-releases，对于锁来说，releases总是等于1\n    int nextc &#x3D; getState() - releases;\n    &#x2F;&#x2F;只有更新之后的state值为0时，才可以将写锁释放\n    boolean free &#x3D; exclusiveCount(nextc) &#x3D;&#x3D; 0;\n    if (free)\n        setExclusiveOwnerThread(null);\n    setState(nextc);\n    return free;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>读锁实现</p>\n<ol>\n<li><p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static class ReadLock implements Lock, java.io.Serializable &#123;\n    private final Sync sync;\n    protected ReadLock(ReentrantReadWriteLock lock) &#123;sync &#x3D; lock.sync;&#125;\n    public void lock() &#123;sync.acquireShared(1);&#125;\n    public void unlock() &#123;sync.releaseShared(1);&#125;\n    public boolean tryLock() &#123;return sync.tryReadLock();&#125;\n    public void lockInterruptibly() throws InterruptedException &#123;\n        sync.acquireSharedInterruptibly(1);\n    &#125;\n    public boolean tryLock(long timeout, TimeUnit unit)\n        throws InterruptedException &#123;\n        return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n    &#125;\n    public Condition newCondition() &#123;\n        throw new UnsupportedOperationException();\n    &#125;\n&#125;</code></pre></li>\n<li><p>state：高16位表示，0表示没有加读锁，1表示已经加读锁，大于1表示读锁总共被获取了多少次（每个线程对读锁重入的次数相加），使用ThreadLocal变量存储重入次数</p>\n</li>\n<li><p>实现原理</p>\n<ol>\n<li><p>lock：lock调用AQS的acquireShared方法，其中的tryAcquireShared实现在Sync中<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/image-20220727100628468.png\" alt=\"image-20220727100628468\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquireShared(int arg) &#123;\n    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争读锁\n        doAcquireShared(arg);&#x2F;&#x2F;竞争失败去排队\n&#125;\n&#x2F;&#x2F;返回-1表示竞争锁失败，返回1表示竞争锁成功\nprotected final int tryAcquireShared(int unused) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    &#x2F;&#x2F;一些优化代码\n    return fullTryAcquireShared(current);\n&#125;\nfinal int fullTryAcquireShared(Thread current) &#123;\n    HoldCounter rh &#x3D; null;\n    &#x2F;&#x2F;如果state没加锁或者是加了读锁，那么线程会通过CAS操作改变state值来竞争锁;\n    &#x2F;&#x2F;如果其他线程也在竟争读锁，并且竞争成功，那么此线程就会竟争失败;\n    &#x2F;&#x2F;于是，此线程就要自旋(for循环)再次尝试去竞争读锁。\n    for (;;) &#123;\n        int c &#x3D; getState();\n        if (exclusiveCount(c) !&#x3D; 0) &#123;&#x2F;&#x2F;已加写锁\n            &#x2F;&#x2F;如果加写锁的线程不是此线程，那么读锁也加不成，直接返回-1\n            &#x2F;&#x2F;否则，读写锁支持锁降级，加了写锁的线程可以再加读锁\n            if (getExclusiveOwnerThread() !&#x3D; current)\n                return -1;\n        &#125; \n        &#x2F;&#x2F;理论上讲，如果没有加写锁，不管有没有加读锁，都可以去竞争读锁了，\n        &#x2F;&#x2F;毕竟读锁是共享锁。但是，存在两个特殊情况:\n        &#x2F;&#x2F;1.对于公平锁来说，如果等待队列不为空，并且当前线程没有持有读锁(重入加\n        &#x2F;&#x2F;锁)，那么，线程就要去排队。\n        &#x2F;&#x2F;2.对于非公平锁来说，如果等待队列中队首线程(接下来要被唤醒的）是写线\n        &#x2F;&#x2F;程，那么，线程就要去排队。这样做是为了避免请求写锁的线程迟迟获取不\n        &#x2F;&#x2F;到写锁。\n        else if (readerShouldBlock()) &#123;&#x2F;&#x2F;上述1和2情况在此时返回true      \n            if (readHolds.get().count &#x3D;&#x3D; 0)&#x2F;&#x2F;此线程没有持有读锁，不能重入\n                return -1;\n            &#x2F;&#x2F;以下是对上述代码中readHolds的解释:readHolds是ThreadLocal变量，保存\n            &#x2F;&#x2F;跟这个线程的读锁重入次数。如果重入次数为0，表示没有加读锁，返回-1去\n            &#x2F;&#x2F;排队。如果重入次数大于等于0，表示已加读锁，可以继续重入，不用排队。\n        &#125;\n        if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        &#x2F;&#x2F;CAS竞争读锁，此时有可能还有其他线程在竞争读锁或写锁\n        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;&#x2F;&#x2F;SHARED_UNIT&#x3D;1&lt;&lt;16\n            &#x2F;&#x2F;竞争读锁成功\n            readHolds.get().count++;&#x2F;&#x2F;更新线程重入次数\n            return 1;&#x2F;&#x2F;成功获取读锁\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;负责排队和等待唤醒，与之前的acquireQueued有两个不同\nprivate void doAcquireShared(int arg) &#123;\n    final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;一：标记此线程等待的是共享锁\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;) &#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head) &#123;\n                int r &#x3D; tryAcquireShared(arg);\n                if (r &gt;&#x3D; 0) &#123;\n                    &#x2F;&#x2F;区别二：如果下一个节点对应的线程也在等待读锁，那么顺道唤醒它\n                    &#x2F;&#x2F;线程获取到读锁之后，如果下一个节点对应的线程也在等待读锁，\n                    &#x2F;&#x2F;那么也会被唤醒。下一个节点对应的线程获取到读锁之后，又会去唤醒\n                    &#x2F;&#x2F;下下个节点对应的线程(如果下下个节点对应的线程也在等待读锁的\n                    &#x2F;&#x2F;话)。唤醒操作一直传播下去，直到遇到等待写锁的线程为止。\n                    setHeadAndPropagate(node, r);\n                    p.next &#x3D; null; &#x2F;&#x2F; help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed &#x3D; false;\n                    return;\n                &#125;\n            &#125;\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted &#x3D; true;\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            cancelAcquire(node);\n    &#125;\n&#125;</code></pre></li>\n<li><p>tryReleaseShared</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;当所有的读锁都释放之后（state变为0）才会返回true\nprotected final boolean tryReleaseShared(int unused) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    readHolds.get().count--;&#x2F;&#x2F;更新本线程对读锁的重入次数\n    for (;;) &#123;&#x2F;&#x2F;有可能多个线程同时释放读锁，同时CAS更新state，因此要自旋+CAS\n        int c &#x3D; getState();\n        int nextc &#x3D; c - SHARED_UNIT;&#x2F;&#x2F;相当于将读锁的加锁次数-1\n        if (compareAndSetState(c, nextc)) \n            return nextc &#x3D;&#x3D; 0;&#x2F;&#x2F;state变为0才会返回true，才会去唤醒等待队列中的线程\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>读写锁的升级版</p>\n<ol>\n<li><p>StampedLock是ReadWriteLock的进一步优化，在读写锁的基础上提供了乐观读锁。在读多写少的情况下，大部分操作都不会被写操作干扰，只有在真正被干扰的情况下再加读锁重复执行读操作。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    private stampedLock slock &#x3D; new stampedLock();\n    private List&lt;String&gt; list &#x3D; new LinkedList&lt;&gt;();\n    \n    public void add(int idx, String elem) &#123;\n        long stamp &#x3D; slock.writeLock();&#x2F;&#x2F;加写锁\n        try &#123;\n            list.add(elem);\n        &#125;finally &#123;\n            slock.unlockWrite(stamp);&#x2F;&#x2F;释放写锁\n        &#125;\n    &#125;\n    \n    public String get(int idx) &#123;\n        long stamp &#x3D; slock.tryOptimisticRead(); &#x2F;&#x2F;加乐观读锁，不需要解锁\n        string res &#x3D; list.get(idx);\n        if (slock.validate(stamp)) &#123;&#x2F;&#x2F;时间错stamp没有被更改，即没写操作干扰\n            return res;\n        &#125; \n        &#x2F;&#x2F;有写操作干扰，读期间，writeLock()函数有被执行，重新使用读锁，重新执行读操作\n        stamp &#x3D; slock.readLock(); &#x2F;&#x2F;加读锁\n        try &#123;\n            return list.get(idx);\n        &#125;finally &#123;\n            slock.unlockRead(stamp);&#x2F;&#x2F;释放读锁\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-无锁编程\"><a href=\"#3-无锁编程\" class=\"headerlink\" title=\"3.无锁编程\"></a>3.无锁编程</h4><h5 id=\"1-CAS\"><a href=\"#1-CAS\" class=\"headerlink\" title=\"1.CAS\"></a>1.CAS</h5><ol>\n<li><p>概述：CAS指的是先检查后更新这类复合操作，全称为Compare And Set或Compare And Swap。示例代码如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private int state &#x3D; 0;\n  &#x2F;&#x2F;state 为共享变量，0表示没有加锁，多个线程调用tryAcquire()函数，谁将state变为1，谁就获取锁\n  public boolean tryAcquire()&#123;\n    &#x2F;&#x2F;非线程安全，因为下面操作非原子操作，可以通过硬件层面提供的CAS原子指令\n    if(state &#x3D;&#x3D; 0)&#123;\n      state &#x3D; 1;\n      return true;\n    &#125;\n    return false;\n  &#125;\n&#125;</code></pre></li>\n<li><p>硬件指令：x86提供的原子指令为<code>cmpxchg[目标操作数],[源操作数]</code>。</p>\n<ul>\n<li>用于存储变量当前值的目标操作数C，用于存储变量的更新值源操作数N，隐藏的位于寄存器上的存储变量的期望值E</li>\n<li>当执行cmpxchg指令时，CPU先判断C是否等于E，相等的话，将更新值N赋值给C，并将ZF标志位设为1；如果不想等的话，CPU将当前值C赋值给期望值E，并将ZF标识位设为0，表示更新值失败。</li>\n<li>因为CPU是一个指令一个指令执行的，所以cmpxchg在单核计算机上是原子操作，在多核计算机上需要用<code>LOCK cmpxchg[目标操作数],[源操作数]</code>，LOCK前缀主要用于同步缓存和内存，锁定总线，禁止多个CPU核同时操作一块共享的内存单元。</li>\n</ul>\n</li>\n<li><p>native方法</p>\n<ol>\n<li><p>因为Java无法使用底层的CPU指令，JVM的Unsafe类中提供了大量的native方法，对底层操作进行了封装，比如根据地址直接访问内存。但是增加了程序发生指针问题的风险，通过看JVM源码才能获得Unsafe类中native方法的代码实现（C++）</p>\n</li>\n<li><p>Unsafe类中提供了3个CAS方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;expected是旧值，x是新值\npublic final native boolean compareAndSwapObject(\n  Object o, long offset,Object expected,Object x);\n\npublic final native boolean compareAndSwapInt(\n  Object o, long offset,int expected,int x);\n\npublic final native boolean compareAndSwapLong(\n  Object o, long offset,long expected,long x);</code></pre>\n\n<ul>\n<li><p>compareAndSwapInt源码实现</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;以下代码位于safe.cpp中\nUNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(\n  JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))\n  UnsafeWrapper(&quot;Unsafe_CompareAndSwapInt&quot;);\n\toop p &#x3D; JNIHandles::resolve(obj);\n\tjint* addr &#x3D; (jint *) index_oop_rom_field_offset_long(p, offset);\n\treturn (jint)(Atomic::cmpxchg(x, addr, e)) &#x3D;&#x3D; e;\nUNSAFE_END\n  \ninline jint Atomic::cmpxchg(\n\tjint exchange_value, volatile jint* dest, jint compare_value) &#123;\n\tint mp &#x3D; os::is_MP();\n  &#x2F;&#x2F;调用了汇编代码，执行cmpxchg汇编指令\n\t__asm__ volatile (LOCK_IF_MP(%4) &quot; cmpxchgl %1 , (%3)&quot;\n\t\t\t\t\t\t\t:&quot;&#x3D;a&quot;(exchange_value)\n\t\t\t\t\t\t\t:&quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)\n\t\t\t\t\t\t\t:&quot;cc&quot;, &quot;memory&quot;);\nreturn exchange_ value;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>使用CAS方法实现tryAcquire()函数</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">public class Demo&#123;\n  private int state &#x3D; 0;\n  \n  private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\n  private static final long stateOffset;\n  \n  static &#123;\n    try&#123;\n      stateOffset &#x3D; unsafe.objectFieldOffset(\n      \t\t\t\t\t\t\t\tDemo.class.getDeclaredField(&quot;state&quot;));\n    &#125;catch(Exception ex)&#123;\n      throw new Error(ex);\n    &#125;\n    public boolean tryAcquire()&#123;\n      return unsafe.compareAndSwapInt(this, stateOffset, 0, 1);\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>失败处理：如果多个线程执行CAS操作，只有一个会成功，其他均会失败。此时可以根据不同的业务逻辑，选择不同的处理逻辑，既可以转去执行处理逻辑，也可以自旋执行CAS直到成功</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private int id &#x3D; 0;\n  &#x2F;&#x2F;使用锁，相当于悲观锁，lock同理\n  public void incerment_lock()&#123;\n    synchronized(this)&#123;\n      id++;\n    &#125;\n  &#125;\n  &#x2F;&#x2F;失败则执行其他逻辑\n  public void inrement_CAS()&#123;\n    int oldValue &#x3D; id;\n    int newValue &#x3D; oldValue + 1;\n    unsafe.compareAndSwapInt(this,idOffset,oldValue,newValue);\n  &#125;\n  &#x2F;&#x2F;自旋+CAS，相当于乐观锁\n  public void incerment_CAS()&#123;\n    boolean succeded &#x3D; false;\n    while(!succeded)&#123;\n      int oldValue &#x3D; id;\n      int newValue &#x3D; oldValue + 1;\n      succeded &#x3D; unsafe.compareAndSwapInt(this,idOffset,oldValue,newValue);\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F;乐观素：乐观地认为不大可能会有资源竞争，不需要加锁，避免了阻塞导致的上下文切换，但消耗了更多的\n&#x2F;&#x2F;CPU资源，可通过限制自旋次数，避免大量自旋\n\n&#x2F;&#x2F;悲观锁：悲观地认为很有可能会出现资源竞争，需要加锁</code></pre></li>\n<li><p>应用场景</p>\n<ol>\n<li><p>在不使用synchronized和lock时，实现一个线程安全的链表，假设只在结尾处插入</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  public static final class Node&#123;\n    private int threadId;\n    private Node prev;\n    private Node next;\n    public Node(int val,Node prev,Node next)&#123;\n      this.threadId &#x3D; val;\n      this.prev &#x3D; prev;\n      this.next &#x3D; next;\n    &#125;\n  &#125;\n  \n  private Node head &#x3D; new Node(-1,null,null);&#x2F;&#x2F;虚拟头节点\n  private Node tail &#x3D; head;\n  \n  public void addWaiter(int val) &#123;\n    Node waiter  &#x3D; new Node(val,null,null);\n    for(;;)&#123;\n      Node oldFail &#x3D; tail;\n      &#x2F;&#x2F;tail从旧值变成了新值，然后将此节点连到链表上\n      if(unsafe.compareAndSwapObject(this,tailOffset,oldTail,waiter))&#123;\n        waiter.prev &#x3D; oldTail;\n        oldTail.next &#x3D; waiter;\n        return;\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-原子类\"><a href=\"#2-原子类\" class=\"headerlink\" title=\"2.原子类\"></a>2.原子类</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>因为实现自旋+CAS的代码比较复杂，JUC提供了各种原子类，封装了对各种类型数据的自旋+CAS操作</p></blockquote>\n<ol>\n<li><p>原子类：原子类的每个操作都可以看成是原子操作，在多线程环境下，执行原子类的操作不会出现线程安全问题。主要可分为四类<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220803085207478.png\" alt=\"image-20220803085207478\"></p>\n</li>\n<li><p>基本类型原子类<code>AtomicInteger</code></p>\n<ol>\n<li><p>因为浮点数无法精确表示和比较大小，所以不包含double和float的原子类，对于char类型，需要将其转换为int类型，然后使用AtomicInteger</p>\n</li>\n<li><p>AtomicInteger代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AtomicInteger extends Number implements java.io.Serializable &#123;\n  &#x2F;&#x2F;创建Unsafe对象，获取value变量在AtomicInteger对象中的偏移位置\n  private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\n  private static final long valueOffset;\n  static &#123;\n    try &#123;\n      valueOffset &#x3D; unsafe.objectFieldOffset\n        (AtomicInteger.class.getDeclaredField(&quot;value&quot;));\n    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;\n  &#125;\n  &#x2F;&#x2F;默认为0\n  private volatile int value;\n  &#x2F;&#x2F;constructor getter setter...\n&#125;</code></pre></li>\n<li><p>AtomicInteger原子操作</p>\n<ul>\n<li><p>CAS：如果value等于expect，就将value更新为update</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final boolean compareAndSet(int expect, int update) &#123;\n  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n&#125;</code></pre></li>\n<li><p>增加：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;返回旧值\npublic final int getAndAdd(int delta) &#123;\n  return unsafe.getAndAddInt(this, valueOffset, delta);\n&#125;\n&#x2F;&#x2F;返回新值\npublic final int addAndGet(int delta) &#123;\n  return unsafe.getAndAddInt(this, valueOffset, delta) + delta;\n&#125;\n&#x2F;&#x2F;底层Unsafe实现，在多线程竞争执行时，CAS可能会执行失败，因此通过自旋重复执行CAS，直到成功an\npublic final int getAndAddInt(Object o, long offset, int delta) &#123;\n  int v;\n  do &#123;\n    v &#x3D; getIntVolatile(o, offset);\n  &#125; while (!compareAndSwapInt(o, offset, v, v + delta));\n  return v;\n&#125;</code></pre></li>\n<li><p>自增：底层实现和增加函数同理，只是将delta设置为1</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final int getAndIncrement() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, 1);\n&#125;\npublic final int incrementAndGet() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, 1) + 1;\n&#125;</code></pre></li>\n<li><p>自减：底层实现和增加函数同理，只是讲delta设置为-1</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final int getAndDecrement() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, -1);\n&#125;\npublic final int decrementAndGet() &#123;\n  return unsafe.getAndAddInt(this, valueOffset, -1) - 1;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>引用类型原子类</p>\n<ol>\n<li><p>AtomicReference</p>\n<ul>\n<li><p>实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123;\n  private static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\n  private static final long valueOffset;\n  static &#123;\n    try &#123;\n      valueOffset &#x3D; unsafe.objectFieldOffset\n        (AtomicReference.class.getDeclaredField(&quot;value&quot;));\n    &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;\n  &#125;\n  private volatile V value;\n  &#x2F;&#x2F;constructor setter getter\n  public AtomicReference(V initialValue) &#123;\n    value &#x3D; initialValue;\n  &#125;\n  public final boolean compareAndSet(V expect, V update) &#123;\n    return unsafe.compareAndSwapObject(this, valueOffset, expect, update);\n  &#125;\n&#125;</code></pre></li>\n<li><p>使用方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DemoLock&#123;\n  private AtomicReference&lt;Thread&gt; owner &#x3D; null;\n  public boolean tryAcquire()&#123;\n    return owner.compareAndSet(null,Thread.currentThread());\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>AtomicStampedReference</p>\n<ul>\n<li><p>相对于AtomicReference，AtomicStampedReference增加了时间戳的概念，主要是用来解决CAS的ABA问题（链表操作头节点时，可能会出现两个线程同时更改同时写回的情况，线程不安全）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AtomicStampedReference&lt;V&gt; &#123;\n  private static class Pair&lt;T&gt; &#123;\n    &#x2F;&#x2F;引用对象\n    final T reference;\n    &#x2F;&#x2F;版本戳\n    final int stamp;\n    private Pair(T reference, int stamp) &#123;\n      this.reference &#x3D; reference;\n      this.stamp &#x3D; stamp;\n    &#125;\n    static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123;\n      return new Pair&lt;T&gt;(reference, stamp);\n    &#125;\n  &#125;\n  private volatile Pair&lt;V&gt; pair;\n\n  public boolean compareAndSet(V expectedReference, V newReference,\n                               int expectedStamp,int newStamp) &#123;\n    Pair&lt;V&gt; current &#x3D; pair;\n    return\n      expectedReference &#x3D;&#x3D; current.reference &amp;&amp;\n      expectedStamp &#x3D;&#x3D; current.stamp &amp;&amp;\n      ((newReference &#x3D;&#x3D; current.reference &amp;&amp;\n        newStamp &#x3D;&#x3D; current.stamp) ||\n       casPair(current, Pair.of(newReference, newStamp)));\n  &#125;\n  private boolean casPair(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val) &#123;\n    return UNSAFE.compareAndSwapObject(this, pairOffset, cmp, val);\n  &#125;\n&#125;</code></pre></li>\n<li><p>既可以使用synchronized或lock加锁，也可以使用自旋+CAS来解决，但是使用AtomicReference会出现问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;出现ABA问题\npublic class LinkedListThreadSafe&#123;\n  private AtomicReference&lt;Node&gt; head &#x3D; new AtomicReference&lt;&gt;(null);\n  public void addAtHead(Node newNode)&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeed)&#123;\n      Node oldHead &#x3D; head.get();\n      newNode.next &#x3D; oldHead;\n      &#x2F;&#x2F;链表结构已改变，但是oleHead和newNode没变，如下图\n      succeeded &#x3D; head.compareAndSet(oldHead,newNode);\n    &#125;\n  &#125;\n  public void removeAtHead()&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeeded)&#123;\n      Node oldHead &#x3D; head.get();\n      if(oldHead &#x3D;&#x3D; null) return;\n      Node nextNode &#x3D; oldHead.next;\n      succeeded &#x3D; head.compareAndSet(oldHead,nextNode);\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n\n\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220803093927693.png\" alt=\"image-20220803093927693\"></p>\n</li>\n<li><p>所以使用AtomicStampedReference改造：即便references存在ABA问题，但是stamp总在增加</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkedList&#123;\n  private AtomicStampedReference&lt;Node&gt; head &#x3D; \n    \t\t\t\t\t\t\t\t\t\t\tnew AtomicStampedReference&lt;&gt;(null,0);&#x2F;&#x2F;stamp初始值为0\n  \n  public void addAtHead(Node newNode)&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeeded)&#123;\n      int oldStamp &#x3D; head.getStamp();\n      Node oldHead &#x3D; head.getReference();\n      newNode.next &#x3D; oldHead;\n      succeeded &#x3D; head.compareAndSet(oldHead,newNode,oldStamp,oldStamp+1);\n    &#125;\n  &#125;\n  public void removeAtHead()&#123;\n    boolean succeeded &#x3D; false;\n    while(!succeeded)&#123;\n      int oldStamp &#x3D; head.getStamp();\n      Node oldHead &#x3D; head.getReference();\n      if(oldHead &#x3D;&#x3D; null) return;\n      Node nextNode &#x3D; oldHead.next;\n      succeeded &#x3D; head.compareAndSet(oldHead,nextNode,oldStamp,oldStamp+1);\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>AtomicMarkableReference：与AtomicStampedReference作用相同，区别在于AtomicMarkableReference使用boolean类型的mark是否被更改来判断reference是否被更改过，原理同上</p>\n</li>\n</ol>\n</li>\n<li><p>数组类型原子类：AtomicIntegerArray中的原子操作和AtomicInteger中的原子操作一一对应，只是在操作中多了一个下标的入参，其他同AtomicInteger，只不过计算元素的偏移位置比较复杂</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;AtomicInteger\npublic final boolean compareAndSet(int expect,int update)&#123;\n  return unsafe.compareAndSwapInt(this, valueOffset, expect, update);\n&#125;\n&#x2F;&#x2F;AtomicIntegerArray\npublic final boolean compareAndSet(int i, int expect, int update)&#123;\n  return unsafe.compareAndSwapInt(array, checkedByteOffset(i), expect, update);\n&#125;</code></pre></li>\n<li><p>对象属性原子类：如果某个类中的属性没有提供合适的原子操作，那么就可以使用对象属性原子类对其进行原子操作，前提属性是public的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Updater&#123;\n  private static AtomicIntegerFieldUpdater&lt;Node&gt; updator &#x3D; \n    \t\t\t\t\t\t\t\t\t\t\t\t\tAtomicIntegerFieldUpdater.newUpdater(Node.class,&quot;val&quot;);\n  \n  public static void incrementVal(Node node)&#123;\n    updator.incrementAndGet(node);\n  &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-累加器\"><a href=\"#3-累加器\" class=\"headerlink\" title=\"3.累加器\"></a>3.累加器</h5><ol>\n<li><p>没有累加器加锁方法</p>\n<ul>\n<li><p>改造前非线程安全</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Counter&#123;\n  private long sum;\n  public long get()&#123;\n    return sum;\n  &#125;\n  public void add(long value)&#123;\n    sum +&#x3D; value;\n  &#125;\n&#125;</code></pre></li>\n<li><p>三种改造方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;加锁，性能影响大\npublic void add_lock(long value)&#123;\n  synchronized(this)&#123;\n    sum +&#x3D; value;\n  &#125;\n&#125;\n\n&#x2F;&#x2F;自旋+CAS，性能影响小，适合低并发\nprivate static final Unsafe unsafe &#x3D; Unsafe.getUnsafe();\nprivate static final long sumOffset;\nstatic&#123;\n  try&#123;\n    sumOffset &#x3D; unsafe.objectFieldOffset(Counter.class.getDeclaredField(&quot;sum&quot;));\n  &#125;catch(Exception ex)&#123;\n    throw new Error(ex);\n  &#125;\n&#125;\n\npublic void add_cas(long value)&#123;\n  boolean succeeded &#x3D; false;\n  while(!succeeded)&#123;\n    long oldValue &#x3D; sum;\n    succeeded &#x3D; unsafe.compareAndSwapLong(this,sumOffset,oldValue,oldValue+value);\n  &#125;\n&#125;\n&#x2F;&#x2F;原子类，实现简单\nprivate AtomicLong atomicSum &#x3D; new AtomicLong();\npublic void add_atomic(int value)&#123;\n  atomicSum.addAndGet(value);\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>LongAdder累加器基本用法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CounterLongAdder&#123;\n  private LongAdder ladder &#x3D; new LongAdder();\n  \n  public void add(long value)&#123;\n    ladder.add(value);\n  &#125;\n  public long get()&#123;\n    &#x2F;&#x2F;sum用来返回累加之后的总和，高并发情况下，不能返回精确的累加值，为了高性能付出的代价\n    return ladder.sum();\n  &#125;\n&#125;</code></pre></li>\n<li><p>数据分片</p>\n<ol>\n<li><p>作用：在高并发情况下，依然可以保持高性能。AtoimcLong因为多线程同时CAS更新一个累加变量，所以性能不高。但是LongAdder将一个累加变量分解为多个累加变量，多线程同时执行累加操作时，不同线程对不同的累加变量进行操作，线程之间互不影响，避免了一个线程需要等待另一个线程操作完之后再操作</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220808092413021.png\" alt=\"image-20220808092413021\" style=\"zoom:50%;\" /></li>\n<li><p>核心成员变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">abstract class Striped64 extends Number &#123;\n  \n  &#x2F;&#x2F;NCPU表示JVM最大可用CPU核数，同时执行累加操作的线程数不可能大于CPU的核数，当cells数组的长度\n  &#x2F;&#x2F;大于等于NCPU时，cells数组中的累加变量个数便可以满足最大NCPU个线程同时互不干涉地执行累加操作\n  &#x2F;&#x2F;cells最大等于NCPU的最小2的幂次方，如NCPU为6，cells数组最大长度为8\n  static final int NCPU &#x3D; Runtime.getRuntime().availableProcessors();\n  &#x2F;&#x2F;cells数组保存多个累加变量，支持动态扩容，初始化为null，首次出现竞争时创建，Cell定义见下\n  transient volatile Cell[] cells;\n  &#x2F;&#x2F;当线程执行add()函数时，首先尝试CAS更新base（将新增值累加到base上），如果成功，则直接返回，\n  &#x2F;&#x2F;如果失败，则执行分片累加的逻辑（将新增值累加到cells数组中），即base只用在低并发情况下\n  transient volatile long base;\n  &#x2F;&#x2F;用来实现锁，类似ReentrantLock中的state字段，初始化为0，多个线程通过CAS竞争更新cellsBusy\n  &#x2F;&#x2F;谁先设置为1，谁就持有锁，这把锁用于避免多个线程同时创建cells数组、同时创建数组中Cell对象、\n  &#x2F;&#x2F;对cells数组进行动态扩容，三个操作的线程安全性\n  transient volatile int cellsBusy;\n  \n  &#x2F;&#x2F;LongAdder中add()函数\n  final void longAccumulate(long x, LongBinaryOperator fn,\n                            boolean wasUncontended) &#123; &#125;\n  \n  &#x2F;&#x2F;Cell只包含一个成员变量value，以及一个操作value的cas()函数\n  @sun.misc.Contended static final class Cell &#123;\n    volatile long value;\n    Cell(long x) &#123; value &#x3D; x; &#125;\n    \n    &#x2F;&#x2F; 实现value的CAS函数\n    final boolean cas(long cmp, long val) &#123;\n      return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);\n    &#125;\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long valueOffset;\n    static &#123;\n      try &#123;\n        UNSAFE &#x3D; sun.misc.Unsafe.getUnsafe();\n        Class&lt;?&gt; ak &#x3D; Cell.class;\n        valueOffset &#x3D; UNSAFE.objectFieldOffset\n          (ak.getDeclaredField(&quot;value&quot;));\n      &#125; catch (Exception e) &#123;\n        throw new Error(e);\n      &#125;\n    &#125;\n  &#125;</code></pre></li>\n<li><p>LongAdder的累加过程</p>\n<ul>\n<li><p>源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LongAdder extends Striped64 implements Serializable &#123;\n  &#x2F;&#x2F;用来累加\n  public void add(long x) &#123;\n    Cell[] as; long b, v; int m; Cell a;\n    &#x2F;&#x2F;低并发，没有cells，直接更新base\n    if ((as &#x3D; cells) !&#x3D; null || !casBase(b &#x3D; base, b + x)) &#123;\n      boolean uncontended &#x3D; true;\n      if (as &#x3D;&#x3D; null || (m &#x3D; as.length - 1) &lt; 0 ||\n          &#x2F;&#x2F;getProbe为哈希函数，返回当前线程的哈希值，getProbe()&amp;m相当于getProbe()%n\n          (a &#x3D; as[getProbe() &amp; m]) &#x3D;&#x3D; null ||\n          &#x2F;&#x2F;有cells，且更新对应cell成功，则直接返回\n          !(uncontended &#x3D; a.cas(v &#x3D; a.value, v + x)))\n        &#x2F;&#x2F;cells为空、线程要更新的cells对象为null、cas更新cells的对象值失败\n        longAccumulate(x, null, uncontended);\n    &#125;\n  &#125;\n&#125;\n\nabstract class Striped64 extends Number &#123;\n  &#x2F;&#x2F;wasUncontended&#x3D;true，fn&#x3D;null，x&#x3D;改变的值+1&#x2F;-1\n  final void longAccumulate(long x, LongBinaryOperator fn,\n                            boolean wasUncontended) &#123;\n    int h;\n    if ((h &#x3D; getProbe()) &#x3D;&#x3D; 0) &#123;\n      ThreadLocalRandom.current(); &#x2F;&#x2F; force initialization\n      h &#x3D; getProbe();\n      wasUncontended &#x3D; true;\n    &#125;\n    boolean collide &#x3D; false;                &#x2F;&#x2F; True if last slot nonempty\n    for (;;) &#123;\n      Cell[] as; Cell a; int n; long v;\n      if ((as &#x3D; cells) !&#x3D; null &amp;&amp; (n &#x3D; as.length) &gt; 0) &#123;\n        if ((a &#x3D; as[(n - 1) &amp; h]) &#x3D;&#x3D; null) &#123;\n          if (cellsBusy &#x3D;&#x3D; 0) &#123;       &#x2F;&#x2F; Try to attach new Cell\n            Cell r &#x3D; new Cell(x);   &#x2F;&#x2F; Optimistically create\n            if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; casCellsBusy()) &#123;\n              boolean created &#x3D; false;\n              try &#123;               &#x2F;&#x2F; Recheck under lock\n                Cell[] rs; int m, j;\n                if ((rs &#x3D; cells) !&#x3D; null &amp;&amp;\n                    (m &#x3D; rs.length) &gt; 0 &amp;&amp;\n                    rs[j &#x3D; (m - 1) &amp; h] &#x3D;&#x3D; null) &#123;\n                  rs[j] &#x3D; r;\n                  created &#x3D; true;\n                &#125;\n              &#125; finally &#123;\n                cellsBusy &#x3D; 0;\n              &#125;\n              if (created)\n                break;\n              continue;           &#x2F;&#x2F; Slot is now non-empty\n            &#125;\n          &#125;\n          collide &#x3D; false;\n        &#125;\n        else if (!wasUncontended)       &#x2F;&#x2F; CAS already known to fail\n          wasUncontended &#x3D; true;      &#x2F;&#x2F; Continue after rehash\n        else if (a.cas(v &#x3D; a.value, ((fn &#x3D;&#x3D; null) ? v + x :\n                                     fn.applyAsLong(v, x))))\n          break;\n        else if (n &gt;&#x3D; NCPU || cells !&#x3D; as)\n          collide &#x3D; false;            &#x2F;&#x2F; At max size or stale\n        else if (!collide)\n          collide &#x3D; true;\n        else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; casCellsBusy()) &#123;\n          try &#123;\n            if (cells &#x3D;&#x3D; as) &#123;      &#x2F;&#x2F; Expand table unless stale\n              Cell[] rs &#x3D; new Cell[n &lt;&lt; 1];\n              for (int i &#x3D; 0; i &lt; n; ++i)\n                rs[i] &#x3D; as[i];\n              cells &#x3D; rs;\n            &#125;\n          &#125; finally &#123;\n            cellsBusy &#x3D; 0;\n          &#125;\n          collide &#x3D; false;\n          continue;                   &#x2F;&#x2F; Retry with expanded table\n        &#125;\n        &#x2F;&#x2F;引入随机数，重新计算h\n        h &#x3D; advanceProbe(h);\n      &#125;\n      else if (cellsBusy &#x3D;&#x3D; 0 &amp;&amp; cells &#x3D;&#x3D; as &amp;&amp; casCellsBusy()) &#123;\n        boolean init &#x3D; false;\n        try &#123;                           &#x2F;&#x2F; Initialize table\n          if (cells &#x3D;&#x3D; as) &#123;\n            Cell[] rs &#x3D; new Cell[2];\n            rs[h &amp; 1] &#x3D; new Cell(x);\n            cells &#x3D; rs;\n            init &#x3D; true;\n          &#125;\n        &#125; finally &#123;\n          cellsBusy &#x3D; 0;\n        &#125;\n        if (init)\n          break;\n      &#125;\n      else if (casBase(v &#x3D; base, ((fn &#x3D;&#x3D; null) ? v + x :\n                                  fn.applyAsLong(v, x))))\n        break;                          &#x2F;&#x2F; Fall back on using base\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>longAccumulate逻辑</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220808103108936.png\" alt=\"image-20220808103108936\"></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>哈希优化</p>\n<ul>\n<li><p>源代码中频繁用到了哈希函数<code>getProbe()</code>、<code>advanceProbe()</code>，用于确定累加到cells中的哪个Cell对象</p>\n</li>\n<li><p>优化：</p>\n<ul>\n<li>因为n为2的幂次方，所以getProbe()%n可以转化为getProbe()&amp;(n-1)，以提高计算速度</li>\n<li>哈希函数计算得到的哈希值，汇报存在线程对应的Thread对象的成员变量中，每次需要时，直接取出使用，如果失败（即两个线程同时更新同一个Cell对象），执行cas失败的线程会重新生成新的哈希值，更新到Thread对象中</li>\n</ul>\n</li>\n<li><p>源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;直接获取当前线程对应的Thread对象的PROBE成员变量值\nstatic final int getProbe() &#123;\n  return UNSAFE.getInt(Thread.currentThread(), PROBE);\n&#125;\n&#x2F;&#x2F;基于老的哈希值probe重新计算新的哈希值，并存储到当前线程对应的Thread对象的PROBE成员变量中\nstatic final int advanceProbe(int probe) &#123;\n  probe ^&#x3D; probe &lt;&lt; 13;   &#x2F;&#x2F; xorshift\n  probe ^&#x3D; probe &gt;&gt;&gt; 17;\n  probe ^&#x3D; probe &lt;&lt; 5;\n  UNSAFE.putInt(Thread.currentThread(), PROBE, probe);\n  return probe;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>去伪共享</p>\n<ul>\n<li><p>LongAdder在Cell的类定义的前面添加了一个注解@Contended注解，隐藏了一个优化：去伪共享，主要用于提高多线程并发执行效率，在DIsruptor高性能消息队列中也有用到</p>\n</li>\n<li><p>伪共享：CPU操作缓存的最小单元是缓存行，不同CPU上的缓存行大小不同，可以为32字节、64字节或128字节。计算Cell对象大小，Cell对象头占12字节，value成员变量为long类型，占8个字节，对象头与value成员变量之间有4字节对齐填充，所以一个Cell对象占24字节，如果一个缓存行大小为64字节，那么两个Cell对象就可能存储在同一个缓存行中。当t1更改cellA的时候，会把缓存行设为无效，导致t2对cellB的缓存也会失效，t1和t2互相影响，导致缓存频繁失效</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220808105552515.png\" alt=\"image-20220808105552515\" style=\"zoom:50%;\" /></li>\n<li><p>为了解决伪共享的问题，可以使用@Contended注解。标记在类上会强制这个类的对象独占一个缓存行，不够的做对齐填充，标记在变量上的作用相同，强制这个变量独占一个缓存行</p>\n</li>\n</ul>\n</li>\n<li><p>非准确求和</p>\n<ul>\n<li><p>LongAdder中的sum()函数会累加base和cells中的Cell对象的value值，和便是最终的累加值。但这个值是不准确的，代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public long sum() &#123;\n  Cell[] as &#x3D; cells; Cell a;\n  long sum &#x3D; base;\n  if (as !&#x3D; null) &#123;\n    for (int i &#x3D; 0; i &lt; as.length; ++i) &#123;\n      if ((a &#x3D; as[i]) !&#x3D; null)\n        sum +&#x3D; a.value;\n    &#125;\n  &#125;\n  return sum;\n&#125;</code></pre></li>\n<li><p>从代码中可以发现，LongAdder在执行sum()函数时，并没有加锁，也就是说，在执行sum()的同时，有可能其他线程正在执行add()函数。所以会使得累加值不准确</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220808110348574.png\" alt=\"image-20220808110348574\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ol>\n<h5 id=\"4-ThreadLocal\"><a href=\"#4-ThreadLocal\" class=\"headerlink\" title=\"4.ThreadLocal\"></a>4.ThreadLocal</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全</p></blockquote>\n<ol>\n<li><p>基本用法</p>\n<ol>\n<li><p>将Java的变量粗略的分为两类，类的成员变量和函数内局部变量，对于类的成员变量在有多个线程共同访问时，就是共享变量，就可能存在线程安全问题；对于函数内局部变量，每个线程执行函数时会在自己的栈上创建私有的局部变量，函数局部变量仅限函数内可见，不同函数之间不可以共享局部变量。多个函数共享局部变量，需要通过参数传递的方式来实现，示例如下：</p>\n<ul>\n<li><p>在标准的Controller-Service-Repository三层结构的后端系统中，实现一个简单的调用链追踪功能</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController&#123;\n  private static final Logger logger &#x3D; \n    \t\t\t\t\t\t\t\t\t\tLoggerFactory.getLogger(UserController.class);\n  private UserService userService &#x3D; new UserService();\n  \n  public long login(String username, String password)&#123;\n    &#x2F;&#x2F;创建traceId，通过traceId可以轻松得到一个接口请求的所有日志，方便通过日志查找代码问题\n    String traceId &#x3D; &quot;[&quot;+System.currentTimeMillis()+&quot;]&quot;;\n    &#x2F;&#x2F;所有的日志都带有traceId\n    logger.trace(traceId + &quot;username&quot; + username);\n    &#x2F;&#x2F;省略校验逻辑\n    return userService.login(username, password, traceId);&#x2F;&#x2F;传递traceId\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>上述代码需要在每个函数中定义traceId参数，将业务代码和非业务代码耦合在一起，为了解决这个问题，可以使用ThreadLocal，其作用域范围介于类的成员变量和函数内局部变量之间，既是线程私有的，又可以在函数之间共享，不但避免了线程安全问题，还能避免参数传递带来的代码耦合问题，重构如下：</p>\n<ul>\n<li><p>使用ThreadLocal重新实现调用链追踪功能，</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Context&#123;\n  &#x2F;&#x2F;实现一个匿名类，重写initialValue方法来提供threadLocalTraceId的初始值\n  &#x2F;&#x2F;如果调用get之前没有调用set，ThreadLocal则会调用initialValue来初始化\n  private static final ThreadLocal&lt;String&gt; threadLocalTraceId &#x3D; \n    new ThreadLocal&lt;String&gt;()&#123;\n    @Override\n    protected String initialValue()&#123;\n      return &quot;[&quot;+System.currentTimeMillis()+&quot;]&quot;;\n    &#125;\n  &#125;;\n  public static void setTraceId(String traceId)&#123;\n    threadLocalTraceId.set(tracdId);\n  &#125;\n  public static String getTraceId()&#123;\n    return threadLocalTraceId.get();\n  &#125;\n  public static void remove()&#123;\n    threadLocalTraceId.remove;\n  &#125;\n&#125;\npublic class UserController&#123;\n  private static final Logger logger &#x3D; \n    LoggerFactory.getLogger(UserController.class);\n  private UserService userService &#x3D; new UserService();\n  \n  public long login(String username, String password)&#123;\n    &#x2F;&#x2F;所有日志都带有tracdId\n    logger.trace(Context.getTraceId()+&quot;username&quot;+username);\n    &#x2F;&#x2F;省略校验逻辑\n    return userService.login(username, password);&#x2F;&#x2F;通过Context传递tracdId\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>ThreadLocal提供的api</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadLocal&lt;T&gt; &#123;\n  protected T initialValue() &#123;return null;&#125;\n  public T get() &#123; &#125;\n  public void set(T value) &#123; &#125;\n  public void remove() &#123; &#125;\n  &#x2F;&#x2F;...\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>实现原理</p>\n<ol>\n<li><p>问题：ThreadLocal定义的一个变量怎么存储多个线程的数据？在类中定义的ThreadLocal变量如何分身到多个线程使用</p>\n</li>\n<li><p>源码结构</p>\n<ul>\n<li><p>ThreadLocal只定义了读写数据的方法，并没有定义任何成员变量来存储数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadLocal&lt;T&gt; &#123;\n  public ThreadLocal() &#123; &#125;\n  protected T initialValue() &#123; &#125;\n  public T get() &#123; &#125;\n  public void set(T value) &#123; &#125;\n  public void remove() &#123; &#125;\n  \n  public static class ThreadLocalMap&#123; &#125;\n&#125;\npublic class Thread implements Runnable&#123;\n  &#x2F;&#x2F;...\n  ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;\n  &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li><p>ThreadLocal的数据存储结构：数据是存储在线程对应的Thread对象的ThreadLocals成员变量中，类行为ThreadLocalMap是ThreadLocal的内部类，ThreadLocal类似于HashMap，键为ThreadLocal对象，值为Object对象</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220818084744695.png\" alt=\"image-20220818084744695\"></p>\n</li>\n</ul>\n</li>\n<li><p>函数底层实现原理</p>\n<ol>\n<li><p>set函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void set(T value) &#123;\n  Thread t &#x3D; Thread.currentThread();&#x2F;&#x2F;获取当前线程对应的Thread对象\n  ThreadLocalMap map &#x3D; getMap(t);&#x2F;&#x2F;获取Thread对象的threadLocals成员变量\n  if (map !&#x3D; null) &#123;&#x2F;&#x2F;threadLocals不为空，则添加键值对\n    map.set(this, value);\n  &#125; else &#123;&#x2F;&#x2F;threadLocals为空，则先创建再添加\n    createMap(t, value);\n  &#125;\n&#125;\nThreadLocalMap getMap(Thread t) &#123;\n  return t.threadLocals;\n&#125;\nvoid createMap(Thread t, T firstValue) &#123;\n  t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);\n&#125;</code></pre></li>\n<li><p>get函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public T get() &#123;\n  Thread t &#x3D; Thread.currentThread();&#x2F;&#x2F;获取当前线程对应的Thread对象\n  ThreadLocalMap map &#x3D; getMap(t);&#x2F;&#x2F;获取Thread对象的threadLocals成员变量\n  if (map !&#x3D; null) &#123;\n    ThreadLocalMap.Entry e &#x3D; map.getEntry(this);&#x2F;&#x2F;this是ThreadLocal变量\n    if (e !&#x3D; null) &#123;\n      @SuppressWarnings(&quot;unchecked&quot;)\n      T result &#x3D; (T)e.value;\n      return result;&#x2F;&#x2F;获取对应的数据值\n    &#125;\n  &#125;\n  &#x2F;&#x2F;map为null或者没有获取到对应的数据值，则执行初始化操作\n  return setInitialValue();\n&#125;\nprivate Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;\n  int i &#x3D; key.threadLocalHashCode &amp; (table.length - 1);&#x2F;&#x2F;找到位置，hash表\n  Entry e &#x3D; table[i];&#x2F;&#x2F;e为弱引用\n&#x2F;&#x2F;这里为什么要使用弱引用呢？原因是如果不使用弱引用，那么当持有value的强引用释放掉后，当线程没有回收释放时，threadLocalMap会一直持有ThreadLocal以及value的强引用d，导致value不能够被回收，从而造成内存泄漏。通过使用弱引用，当ThreadLocal的强引用释放掉后，通过一次系统gc检查，发现ThreadLocal对象只有threadLocalMap中Entry的弱引用持有，此时根据弱引用的机制就会回收ThreadLocal对象，从而避免了内存泄露。当然ThreadLocal还有一些额外的保护措施，\n  if (e !&#x3D; null &amp;&amp; e.get() &#x3D;&#x3D; key)\n    return e;\n  else\n    return getEntryAfterMiss(key, i, e);\n&#125;\nprivate T setInitialValue() &#123;\n  T value &#x3D; initialValue();&#x2F;&#x2F;默认返回null，可重写此函数，见Context示例\n  Thread t &#x3D; Thread.currentThread();\n  ThreadLocalMap map &#x3D; getMap(t);\n  if (map !&#x3D; null) &#123;\n    map.set(this, value);&#x2F;&#x2F;添加键值对\n  &#125; else &#123;\n    createMap(t, value);&#x2F;&#x2F;创建threadLocals\n  &#125;\n  if (this instanceof TerminatingThreadLocal) &#123;\n    TerminatingThreadLocal.register((TerminatingThreadLocal&lt;?&gt;) this);\n  &#125;\n  return value;\n&#125;</code></pre></li>\n<li><p>remove函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void remove() &#123;\n  ThreadLocalMap m &#x3D; getMap(Thread.currentThread());\n  if (m !&#x3D; null) &#123;\n    m.remove(this);\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>应用场景：ReentrantReadWriteLock，记录每个线程的重入次数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;位于ReentrantReadWriteLock.java中\nstatic final class HoldCounter&#123;\n  int count &#x3D; 0;\n  final long tid &#x3D; getTheadId(Thread.currentThread());\n&#125;\n&#x2F;&#x2F;集成自ThreadLocal\nstatic final class ThreadLocalHoldCounter extends ThreadLocal&lt;HoldCounter&gt;&#123;\n  public HoldCounter initialValue()&#123;\n    return new HoldCounter();\n  &#125;\n&#125;\nprivate transient ThreadLocalHoldCounter readHolds;</code></pre></li>\n</ol>\n<h5 id=\"5-锁产生的问题（活跃性问题）\"><a href=\"#5-锁产生的问题（活跃性问题）\" class=\"headerlink\" title=\"5.锁产生的问题（活跃性问题）\"></a>5.锁产生的问题（活跃性问题）</h5><ol>\n<li><p>死锁：多个线程互相等待对方持有的资源，而导致线程无法继续执行的问题</p>\n<ol>\n<li><p>死锁举例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private Object lock1 &#x3D; new Object();\n  private Object lock2 &#x3D; new Object();\n  \n  public void f()&#123;\n    synchronized(lock1)&#123;\n      synchronized(lock2)&#123;\n        &#x2F;&#x2F;业务代码\n      &#125;\n    &#125;\n  &#125;\n  public void g()&#123;\n    synchronized(lock2)&#123;\n      synchronized(lock1)&#123;\n        &#x2F;&#x2F;业务代码\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>死锁检测：将资源依赖情况组织成有向图，通过DFS算法来检查是否有环，有环即有死锁存在。在发生死锁时，可以使用jstack这类工具将线程的运行状态等重要信息打印出来，来分析死锁发生的原因</p>\n</li>\n<li><p>避免死锁的方法</p>\n<ul>\n<li><p>统一线程请求锁的顺序：以转账为例，实际情况使用数据库锁（可看作进程级锁）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Transaction&#123;\n  public static void transfer(Account from,Account to,double transAmount)&#123;\n    Account lockFirst &#x3D; from;\n    Account lockSecond &#x3D; to;\n    &#x2F;&#x2F;如果不转换的话，没法确定from和to所引用的对象是否顺序全局一致，可能是A+B和B+A\n    if(form.id &gt; to.id)&#123;\n      lockFirst &#x3D; to;\n      lockSecond &#x3D; from;\n    &#125;\n    \n    synchronized(lockFirst)&#123;\n      synchronized(lockSecond)&#123;\n        from.amount -&#x3D; transAmount;\n        to.amount +&#x3D; transAmount;\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>避免线程持有锁并等待锁；如果一个线程请求一个锁时，这个锁已经被其他线程持有，那么这个线程不再阻塞等待这个锁，而是释放掉所持有的所有锁，让其他线程先执行，实现如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private Lock lock1 &#x3D; new ReentrantLock();\n  private Lock lock2 &#x3D; new ReentrantLock();\n  \n  private void f()&#123;\n    for(;;)&#123;\n      lock1.lock();\n      try&#123;\n        boolean locked &#x3D; lock2.trylock();\n        if(locked)&#123;&#x2F;&#x2F;获取到锁\n          try&#123;\n            &#x2F;&#x2F;业务逻辑\n            return;\n          &#125;finally&#123;\n            lock2.unlock();\n          &#125;\n        &#125;&#x2F;&#x2F;else 没有获取lock2锁，执行finally，释放lock1锁\n      &#125;finally&#123;\n        lock1.unlock();\n      &#125;\n    &#125;\n  &#125;\n  \n  public void g()&#123;\n    for(;;)&#123;\n      lock2.lock();\n      try&#123;\n        boolean locked &#x3D; lock1.trylock();\n        if(locked)&#123;&#x2F;&#x2F;获取到锁\n          try&#123;\n            &#x2F;&#x2F;业务逻辑\n            return;\n          &#125;finally&#123;\n            lock1.unlock();\n          &#125;\n        &#125;&#x2F;&#x2F;else 没有获取lock1锁，执行finally，释放lock2锁\n      &#125;finally&#123;\n        lock2.unlock();\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>活锁：</p>\n<ol>\n<li><p>上述避免死锁的方法2会出现活锁的情况，如下图</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220805105726851.png\" alt=\"image-20220805105726851\"></p>\n</li>\n<li><p>活锁相对于死锁来说，线程不会阻塞，持续消耗CPU资源，相对于死锁来说，性能损耗更大，但是发生概率更低</p>\n</li>\n<li><p>解决方法：在线程执行的过程中，暂停随机的一段时间，打破两个线程的持续同步。具体可以既可以通过在trylock()后添加sleep()语句，也可以将trylock()改为带超时时间的trylock()</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void f()&#123;\n  Random r &#x3D; new Random();\n  for(;;)&#123;\n    lock1.lock();\n    try&#123;\n      boolean locked &#x3D; false;\n      try&#123;\n        locked &#x3D; lock2.trylock(r.nextLong()%10, TImeUnit.MILLISECONDS);\n      &#125;catch(InterruptedException e)&#123;\n        &#x2F;&#x2F;log error and return\n      &#125;\n      if(locked)&#123;&#x2F;&#x2F;两个锁都获取了\n        try&#123;\n          &#x2F;&#x2F;业务逻辑\n          return;\n        &#125;finally&#123;\n          lock2.unlock();\n        &#125;\n      &#125;&#x2F;&#x2F;else 没有获取lock2锁，执行finally，释放lock1锁\n    &#125;finally&#123;\n      lock1.unlock();\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>饥饿：发生的情况</p>\n<ul>\n<li>迟迟获取不到死锁或活锁</li>\n<li>非公平锁中，线程排队一直有插队的线程</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-同步工具\"><a href=\"#4-同步工具\" class=\"headerlink\" title=\"4.同步工具\"></a>4.同步工具</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>主要包括条件变量、信号量、Latch（CountDownLatch）、Barrier（CyclicBarrier）等，用来实现各种线程协作模式。</p></blockquote>\n<h4 id=\"1-条件变量\"><a href=\"#1-条件变量\" class=\"headerlink\" title=\"1.条件变量\"></a>1.条件变量</h4><ol>\n<li><p>条件变量的由来</p>\n<ol>\n<li><p>实现一个大小无限制的队列，而且是阻塞队列并且需要是线程安全的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Queue&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n\n  public void put(String elem)&#123;\n    synchronized(this)&#123;\n      list.add(count, elem);\n      count++;\n    &#125;\n  &#125;\n  public String get()&#123;\n    for(;;)&#123;\n      while(count &lt;&#x3D; 0)&#123;\n        &#x2F;&#x2F;自旋等待队列不为空，但会消耗CPU资源\n        &#x2F;&#x2F;添加sleep()函数可减少CPU的浪费，但是会使得唤醒响应不及时\n      &#125;\n      synchronized(this)&#123;&#x2F;&#x2F;队列不为空时才加锁\n        if(count &gt; 0)&#123;&#x2F;&#x2F;双重检测，否则会出现同时取元素的访问越界\n          count--;\n          return list.get(count);\n        &#125;&#x2F;&#x2F;else 重新自旋等待队列不为空，所以需要一个for循环\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>Java的条件变量可以分为两种</p>\n<ul>\n<li>Java提供的内置条件变量，即Object类上的wait()和notify()，类比于synchronized</li>\n<li>JUC提供的条件变量，使用Condition接口上的await()和signal()，类比于JUC提供的Lock锁</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>内置条件变量使用方式</p>\n<ol>\n<li><p>Object源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Object &#123;\n  &#x2F;&#x2F;线程调用此函数进入WAITTINTG状态，有两种情况返回：其他线程调用notify或notifyAll唤醒；\n  &#x2F;&#x2F;线程被中断，此时wait函数会抛出InterruptedException\n  public final void wait() throws InterruptedException &#123;wait(0);&#125;\n  &#x2F;&#x2F;线程调用此函数进入WAITTING状态，有三种情况返回：其他线程调用notify或notifyAll唤醒；\n  &#x2F;&#x2F;线程被中断，此时wait函数会抛出InterruptedException；等待时间超过了预设的超时时间，\n  &#x2F;&#x2F;即timeout毫秒+nacos纳秒\n  public final void wait(long timeout, int nanos) throws InterruptedException &#123;&#125;\n  &#x2F;&#x2F;跟上一个函数的唯一区别在于超时时间，此函数的超时时间只能精确到毫秒\n  public final native void wait(long timeout) throws InterruptedException;\n \t&#x2F;&#x2F;唤醒一个调用了同一个对象上的wait()函数的线程 \n  public final native void notify();\n  &#x2F;&#x2F;唤醒所有调用了同一个对象上的wait()函数的线程\n  public final native void notifyAll();\n&#125;</code></pre></li>\n<li><p>改写Queue</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class QueueCond&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      this.notify();&#x2F;&#x2F;通知\n    &#125;\n  &#125;\n  \n  public String get()&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          this.wait();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>条件变量的通用使用模式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220811090709160.png\" alt=\"image-20220811090709160\"></p>\n<ul>\n<li>执行wait()或notify()前先加锁：如果不加锁就会出现线程安全问题（同时满足条件变量，同时执行业务逻辑），线程执行wait时会进入等待队列并且释放锁，否则会产生死锁问题</li>\n<li>使用while循环避免假唤醒：<ul>\n<li>一种情况是：多个线程同时调用wait等待状态变量来满足条件，只有一个线程调用notifyAll函数，所有线程都被唤醒，但只有一个线程能执行逻辑，需要while让线程再次进入wait状态</li>\n<li>另一种情况是：两个线程等待不同的状态变量（A和B），同时放在同一个等待队列（调用了同一个对象上的wait函数），如果A资源到了，会唤醒所有进程，只有等待A的线程才会被执行，等待B的需要重新调用wait函数</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>内置条件变量实现原理</p>\n<ol>\n<li><p>在Synchronized内置锁的实现原理中，ObjectMonitor类中有三个等待队列：_cxq、_EntryList、_WaitSet</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class ObjectMonitor&#123;\n  void* volatile _object;&#x2F;&#x2F;该Monitor锁所属的对象\n  void* volatile _owner;&#x2F;&#x2F;获取到该Monitor锁的线程\n  ObjectWaiter* volatile _cxq;&#x2F;&#x2F;没有获取到锁的线程暂时存入_cxq\n  ObjectWaiter* volatile _EntryList;&#x2F;&#x2F;存储等待被唤醒的线程\n  ObjectWaiter* volatile _WaitSet;&#x2F;&#x2F;存储调用了wait的线程\n&#125;</code></pre></li>\n<li><p>当某个线程调用wait函数时，线程会先将自己放入_WaitSet中，然后释放锁，并调用park方法阻塞自己，当某个线程调用notify函数时，如果_cxq和_EntryList均为空，那么它从_WaitSet中取出一个线程，直接调用unpark方法取消这个线程的阻塞状态，让其去竞争锁。当调用了wait函数的线程再次获取到锁，便会从wait函数中返回，执行后续业务逻辑。</p>\n</li>\n<li><p>notifyAll和notify的区别在于notifyAll会将_WaitSet中的所有线程都取出，然后放入_EntryList中等待锁。所有调用了wait函数的线程会依次获取到锁，然后执行后续业务逻辑</p>\n</li>\n</ol>\n</li>\n<li><p>JUC条件变量使用方式</p>\n<ol>\n<li><p>使用方式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Condition &#123;\n  &#x2F;&#x2F;作用同Object的wait\n  void await() throws InterruptedException;\n  &#x2F;&#x2F;不可被中断版本\n  void awaitUninterruptibly();\n  &#x2F;&#x2F;等待超过nacosTimeout纳秒时函数返回，返回值为等待的时间\n  long awaitNanos(long nanosTimeout) throws InterruptedException;\n  &#x2F;&#x2F;同上，但可以设置时间单位unit\n  boolean await(long time, TimeUnit unit) throws InterruptedException;\n  &#x2F;&#x2F;等待某个时间点dealline是函数返回，返回值false表示超时返回，true为中断或被唤醒\n  boolean awaitUntil(Date deadline) throws InterruptedException;\n  &#x2F;&#x2F;以下两函数同notify，notifyAll\n  void signal();\n  void signalAll();\n&#125;</code></pre></li>\n<li><p>改写Queue</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class QueueCondJUC&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  private Lock lock &#x3D; new ReentrantLock();\n  private Condition condition &#x3D; lock.newCondition();\n  \n  private void put(String elem)&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      condition.signal();&#x2F;&#x2F;通知\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n  public String get()&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          condition.await();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>JUC条件变量使用原理</p>\n<ol>\n<li><p>Lock通过newCondition函数来创建Condition对象，其中ConditionObject类是AQS的内部类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;位于ReetrantLock中\nfinal ConditionObject newCondition() &#123;\n  return new ConditionObject();\n&#125;\n&#x2F;&#x2F;位于AbstractQueuedSynchronizer中\npublic class ConditionObject implements Condition, java.io.Serializable &#123;\n  private transient Node firstWaiter;\n  private transient Node lastWaiter;\n  public ConditionObject()&#123; &#125;\n  &#x2F;&#x2F;实现了Condition中的所有方法\n&#125;</code></pre></li>\n<li><p>ReentrantLock中有一个存放等待锁线程的队列，ConditionObject对象中包含一个调用await函数线程的队列，称前者为Lock等待队列，后者为Condition等待队列</p>\n<ul>\n<li><p>Lock等待队列用双向链表实现；Condition等待队列用单向链表实现，两者共用同一节点定义，只不过Condition等待队列使用Node类中的nextWaiter属性作为节点的后继指针。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final class Node&#123;\n  volatile Thread thread;\n  volatile Node prev;\n  volatile Node next;\n  Node nextWaiter;&#x2F;&#x2F;用于Condition\n&#125;</code></pre></li>\n<li><p>ConditionObject对象的ReentrantLock对象所维护的等待队列的结构示意图</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220811100521511.png\" alt=\"image-20220811100521511\"></p>\n</li>\n</ul>\n</li>\n<li><p>Condition接口中的方法在ConditionObject类中的实现</p>\n<ul>\n<li><p>awaitUninterruptibly函数：不响应中断，</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void awaitUninterruptibly() &#123;\n  &#x2F;&#x2F;将线程包裹为Node节点添加到Condition等待队列尾部\n  Node node &#x3D; addConditionWaiter();\n  &#x2F;&#x2F;将state修改为0，表示释放了锁\n  int savedState &#x3D; fullyRelease(node);\n  &#x2F;&#x2F;阻塞等待被signal或signalAll唤醒\n  boolean interrupted &#x3D; false;\n  while (!isOnSyncQueue(node)) &#123;&#x2F;&#x2F;检查节点是否已移动到Lock等待队列中\n    &#x2F;&#x2F;调用park函数进入阻塞状态，在被中断或另一线程调用signal时会返回，\n    &#x2F;&#x2F;对于情况一：但是此函数不响应中断，因此线程中断唤醒之后，再次调用park阻塞\n    &#x2F;&#x2F;对于情况二：另一线程调用signal会先将Condition等待队列中的线程移动到Lock等待队列，\n    &#x2F;&#x2F;然后调用unpark函数唤醒线程，isOnSyncQueue作用就是检查是否已经移动\n    LockSupport.park(this);\n    if (Thread.interrupted())\n      interrupted &#x3D; true;\n  &#125;\n  &#x2F;&#x2F;acquireQueued用来排队等待锁，见Lock原理\n  if (acquireQueued(node, savedState) || interrupted)\n    selfInterrupt();\n&#125;</code></pre></li>\n<li><p>signal函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;按照FIFO原则处理Condition等待队列中的线程\npublic final void signal() &#123;\n  if (!isHeldExclusively())\n    throw new IllegalMonitorStateException();\n  &#x2F;&#x2F;从Condition等待队列的头部取一个节点\n  Node first &#x3D; firstWaiter;\n  if (first !&#x3D; null)\n    doSignal(first);\n&#125;\nprivate void doSignal(Node first) &#123;\n  do &#123;\n    if ( (firstWaiter &#x3D; first.nextWaiter) &#x3D;&#x3D; null)\n      lastWaiter &#x3D; null;\n    first.nextWaiter &#x3D; null;\n  &#125; while (!transferForSignal(first) &amp;&amp;\n           (first &#x3D; firstWaiter) !&#x3D; null);\n&#125;\n&#x2F;&#x2F;将取的节点，放入Lock等待队列中，并调用unpack函数唤醒对应的线程\nfinal boolean transferForSignal(Node node) &#123;\n  if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n    return false;\n  Node p &#x3D; enq(node);\n  int ws &#x3D; p.waitStatus;\n  if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n    LockSupport.unpark(node.thread);\n  return true;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-信号量\"><a href=\"#2-信号量\" class=\"headerlink\" title=\"2.信号量\"></a>2.信号量</h4><ol>\n<li><p>信号量</p>\n<ol>\n<li><p>JUC提供了Semaphore类来实现信号量，用来限制临界区和共享资源的并发访问。使用互斥锁，临界区和共享资源同时只被一个线程访问；使用信号量，临济区和共享资源同时可被多个线程访问。信号量可以看成共享锁，底层使用AQS实现。</p>\n</li>\n<li><p>应用举例：一个接口服务器，同一时刻控制只有N个线程并发执行</p>\n<ul>\n<li><p>实现一：AtomicInteger原子类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  &#x2F;&#x2F;apiX接口同时只允许10个线程并发执行\n  private final AtomicInteger permits &#x3D; new AtomicInteger(10);\n  \n  public void apiX()&#123;\n    int newPermits &#x3D; permits.decrementAndGet();\n    if(newPermits &lt; 0)&#123;\n      permits.incrementAndGet();\n      return;&#x2F;&#x2F;拒绝执行业务逻辑，直接返回\n    &#125;\n    \n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      permits.incrementAndGet();\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>使用锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  &#x2F;&#x2F;apiX接口同时只允许10个线程并发执行\n  private int permits &#x3D; 10;\n  public void apiX()&#123;\n    if(permits &lt;&#x3D; 0)&#123;\n      return;\n    &#125;\n    synchronized(this)&#123;\n      if(permits &lt;&#x3D; 0)&#123;&#x2F;&#x2F;双重检测\n        return;\n      &#125;\n      permits--;\n    &#125;\n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      synchronized(this)&#123;\n        permits++;\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>等待通知机制：上述两种实现，在第11个线程调用apiX时，将无法获取到许可（permit），于是直接返回，这样会使得大量接口请求被拒绝。可以将无法获取许可的线程阻塞，等有许可的时候再唤醒，但是这样会让接口请求的响应时间增大。即可以用条件变量来实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  &#x2F;&#x2F;apiX接口同时只允许10个线程并发执行\n  private int permits &#x3D; 10;\n  private Lock lock &#x3D; new ReentrantLock();\n  private Condition condition &#x3D; lock.newCondition():\n  public void apiX()&#123;\n    &#x2F;&#x2F;阻塞访问condition\n    lock.lock():\n    try&#123;\n      while(permits &lt;&#x3D; 0)&#123;\n        &#x2F;&#x2F;线程阻塞\n        condition.awaitUninterruptibly();\n      &#125;\n      &#x2F;&#x2F;获取许可\n      permits--;\n    &#125;finally&#123;\n      lock.unlock();\n    &#125;\n    \n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      lock.lock();\n      permits++;\n      &#x2F;&#x2F;唤醒线程\n      condition.signal();\n      lock.unlock();\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>Semaphore类</p>\n<ul>\n<li>如果信号量中的许可个数为1，那么信号量就退化成了互斥锁；如果互斥量的许可个数大于1，信号量就可以看作是一种共享锁</li>\n<li>信号量与锁的区别是，释放锁的线程必须持有锁，而信号量则不用。即没有调用acquire()函数的线程也可以直接调用release()函数，用来增加可用许可个数。此时，信号量不再是用来限制对临界区的并发访问，而是用来对共享资源的并发访问。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;第一组，默认一次获取或释放的许可（permit）个数为1\n  public void acquire() throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly() &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire()&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release()&#123;&#125;\n  &#x2F;&#x2F;第二组，默认制定一次获取或释放的许可个数\n  public void acquire(int permits) throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly(int permits) &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire(int permits)&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(int permits, long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release(int permits)&#123;&#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>并发访问控制</p>\n<ol>\n<li><p>临界区并发访问控制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private final Semaphore semaphore &#x3D; new Semaphore(10);\n  \n  public void apiX()&#123;\n    semaphore.acquireUniterruptibly();\n    try&#123;\n      &#x2F;&#x2F;执行业务逻辑\n    &#125;finally&#123;\n      semaphore.release();\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>共享资源并发访问控制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class QueueSemaphore&#123;\n  private static final int Q_SIZE &#x3D; 20;\n  &#x2F;&#x2F;表示队列中的空闲位置\n  private Semaphore semaphore &#x3D; new Semaphore(Q_SIZE);\n  private list&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(Q_SIZE);\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    &#x2F;&#x2F;当可用许可个数为0时，线程执行put函数时会阻塞在acquireUniterruptibly()函数中\n    semaphore.acquireUniterruptibly();\n    synchronized(this)&#123;\n      list.add(count, elem);\n      count++;\n    &#125;\n  &#125;\n  public String get()&#123;\n    if(count &#x3D;&#x3D; 0) return null;\n    synchronized(this)&#123;\n      if(count &#x3D;&#x3D; 0) return null;&#x2F;&#x2F;双重检测\n      String ret &#x3D; list.get(--count);\n      semaphore.release();\n      return ret;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>信号量的实现原理</p>\n<ol>\n<li><p>基于AQS</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;实现AQS\n  private final Sync sync;\n  abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n    Sync(int permits) &#123;setState(permits);&#125;\n    protected final boolean tryReleaseShared(int releases) &#123;&#125;\n  &#125;\n\n  static final class NonfairSync extends Sync &#123;\n    NonfairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      return nonfairTryAcquireShared(acquires);\n    &#125;\n  &#125;\n  \n  &#x2F;*\n  final int nonfairTryAcquireShared(int acquires) &#123;\n    for (;;) &#123;\n      int available &#x3D; getState();&#x2F;&#x2F;许可个数存放在state变量中\n      int remaining &#x3D; available - acquires;\n      if (remaining &lt; 0 ||\n          compareAndSetState(available, remaining))\n        return remaining;\n    &#125;\n  &#125;\n  *&#x2F;\n\n  static final class fairSync extends Sync &#123;\n    fairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      for (;;) &#123;\n        if (hasQueuedPredecessors()) return -1;&#x2F;&#x2F;比NonfairSync多了这一行\n        int available &#x3D; getState();\n        int remaining &#x3D; available - acquires;\n        if (remaining &lt; 0 ||\n            compareAndSetState(available, remaining))\n          return remaining;\n      &#125;\n    &#125;\n  &#125;\n\n  public Semaphore(int permits) &#123;&#x2F;&#x2F;默认非公平模式\n    sync &#x3D; new NonfairSync(permits);\n  &#125;\n  public Semaphore(int permits, boolean fair) &#123;&#x2F;&#x2F;指定工作模式（公平&#x2F;非公平）\n    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);\n  &#125;\n  &#x2F;&#x2F;暂时省略核心方法的实现\n&#125;</code></pre>\n\n<ul>\n<li><p>acquireUninterruptibly()函数</p>\n<ul>\n<li><p>源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;位于Semaphore.java中\npublic void acquireUninterruptibly() &#123;\n  sync.acquireShared(1);\n&#125;\n&#x2F;&#x2F;位于AbstractQueuedSynchronizer.java中\npublic final void acquireShared(int arg) &#123;\n  if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争获取许可，返回值&lt;0表示失败，需要排队等待许可\n    doAcquireShared(arg);&#x2F;&#x2F;排队等待许可\n&#125;\n&#x2F;&#x2F;其中tryAcquireShared()函数的代码实现位于NonfairSync和FairSync中，实现见上\n&#x2F;&#x2F;两种实现均通过自旋+CAS的方式获取许可，唯一区别是从等待队列中取还是可以插队</code></pre></li>\n</ul>\n</li>\n<li><p>release()函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void release() &#123;\n  sync.releaseShared(1);\n&#125;\npublic final boolean releaseShared(int arg) &#123;\n  if (tryReleaseShared(arg)) &#123;\n    doReleaseShared();\n    return true;\n  &#125;\n  return false;\n&#125;\n&#x2F;&#x2F;采用自旋+CAS来更新state\nprotected final boolean tryReleaseShared(int releases) &#123;\n  for (;;) &#123;\n    int current &#x3D; getState();\n    int next &#x3D; current + releases;\n    if (next &lt; current) &#x2F;&#x2F; overflow\n      throw new Error(&quot;Maximum permit count exceeded&quot;);\n    if (compareAndSetState(current, next))\n      return true;\n  &#125;\n&#125;\n&#x2F;&#x2F;用来唤醒排队等待许可的第一个线程，即等待队列中的第一个线程，详见ReentrantReadWriteLock\nprivate void doReleaseShared() &#123;\n  for (;;) &#123;\n    Node h &#x3D; head;\n    if (h !&#x3D; null &amp;&amp; h !&#x3D; tail) &#123;\n      int ws &#x3D; h.waitStatus;\n      if (ws &#x3D;&#x3D; Node.SIGNAL) &#123;\n        if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n          continue;            &#x2F;&#x2F; loop to recheck cases\n        unparkSuccessor(h);\n      &#125;\n      else if (ws &#x3D;&#x3D; 0 &amp;&amp;\n               !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n        continue;                &#x2F;&#x2F; loop on failed CAS\n    &#125;\n    if (h &#x3D;&#x3D; head)                   &#x2F;&#x2F; loop if head changed\n      break;\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-Latch-amp-Barrier\"><a href=\"#3-Latch-amp-Barrier\" class=\"headerlink\" title=\"3.Latch&amp;Barrier\"></a>3.Latch&amp;Barrier</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>用于线程之间的协调执行</p></blockquote>\n<ol>\n<li><p>CountDownLatch的用法</p>\n<ol>\n<li><p>中文叫锁存器，源码如下，</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CountDownLatch &#123;\n  &#x2F;&#x2F;具体化抽象模版方法类AQS\n  private static final class Sync extends AbstractQueuedSynchronizer &#123;\n    Sync(int count) &#123;setState(count);&#125;&#x2F;&#x2F;将count值存储在AQS的state中\n    protected int tryAcquireShared(int acquires) &#123;&#x2F;&#x2F;实现AQS的抽象方法\n      return (getState() &#x3D;&#x3D; 0) ? 1 : -1;&#x2F;&#x2F;检查count是不是为0了\n    &#125;\n    protected boolean tryReleaseShared(int releases) &#123;&#x2F;&#x2F;实现AQS的抽象方法\n      &#x2F;&#x2F; Decrement count; signal when transition to zero\n      for (;;) &#123;\n        int c &#x3D; getState();\n        if (c &#x3D;&#x3D; 0)\n          return false;\n        int nextc &#x3D; c-1;\n        if (compareAndSetState(c, nextc))\n          return nextc &#x3D;&#x3D; 0;\n      &#125;\n    &#125;\n  &#125;\n  \n  private final Sync sync;\n  \n  &#x2F;&#x2F;构造函数，传入count值\n  public CountDownLatch(int count) &#123;\n    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);\n    this.sync &#x3D; new Sync(count);\n  &#125;\n  &#x2F;&#x2F;阻塞等待count值变为0\n  public void await() throws InterruptedException &#123;\n    sync.acquireSharedInterruptibly(1);&#x2F;&#x2F;使用Sync的模版方法编程\n  &#125;\n  public boolean await(long timeout, TimeUnit unit)\n    throws InterruptedException &#123;\n    &#x2F;&#x2F;使用Sync的模版方法编程\n    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));\n  &#125;\n  &#x2F;&#x2F;将count值减一\n  public void countDown() &#123;\n    sync.releaseShared(1);&#x2F;&#x2F;使用Sync的模版方法编程\n  &#125;\n&#125;</code></pre></li>\n<li><p>类似于Thread类中的join()函数，用于一个线程等待其他多个线程的事件发生，对于join()函数来说，这里的事件指的是线程结束。对于CountDownLatch来说，这里的事件可以根据业务逻辑来定义。另外，使用join需要知道被等待的线程是谁，而CountDownLatch则不需要。因此CountDownLatch相对于join更加通用</p>\n</li>\n<li><p>示例：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DemoJoin&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new RunnableForJoin());\n    THread t2 &#x3D; new THread(new RunnableForJoin());\n    t1.start();\n    t2.start();\n    t1.join();&#x2F;&#x2F;join只用来等待线程执行结束，并且必须知道被等待线程是谁\n    t2.join();\n  &#125;\n  public static class RunnableForJoin implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;业务逻辑\n    &#125;\n  &#125;\n&#125;\npublic class DemoLatch&#123;\n  private static final CountDownLatch latch &#x3D; new CountDownLatch(2);\n  public static void main(String[] args) throws InterruptedException&#123;\n    new Thread(new RunnableForLatch()).start();\n    new Thread(new RunnbaleForLatch()).start();\n    latch.await();&#x2F;&#x2F;等待something执行完成而非等待线程结束，并且不需要知道在等谁\n    &#x2F;&#x2F;执行后续逻辑\n  &#125;\n  public static class RunnableForLatch implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;do something\n      latch.countDown();\n      &#x2F;&#x2F;do otheer thing\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>CountDownLatch的实现原理</p>\n<ol>\n<li><p>底层依赖AQS来实现，代码结构大致为：具体化抽象模版方法类AQS；在具体类Sync中实现AQS中的抽象方法；使用具体类Sync中的模版方法来编程</p>\n</li>\n<li><p>await函数：await函数直接调用AQS的acquireSharedInterruptibly函数，源码如下，其中count值存在state中。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquireSharedInterruptibly(int arg)\n  throws InterruptedException &#123;\n  if (Thread.interrupted())\n    throw new InterruptedException();\n  &#x2F;&#x2F;调用tryAcquireShared函数查看state，如果state为0，则直接返回，\n  &#x2F;&#x2F;否则，调用doAcquireSharedInterruptibly函数阻塞等待state变为0\n  if (tryAcquireShared(arg) &lt; 0)\n    doAcquireSharedInterruptibly(arg);&#x2F;&#x2F;阻塞等待state为0\n&#125;\n&#x2F;&#x2F;原理同ReentrantReadWriteLock的doAcquireShared函数\nprivate void doAcquireSharedInterruptibly(int arg)\n  throws InterruptedException &#123;\n  final Node node &#x3D; addWaiter(Node.SHARED);\n  boolean failed &#x3D; true;\n  try &#123;\n    for (;;) &#123;\n      final Node p &#x3D; node.predecessor();\n      if (p &#x3D;&#x3D; head) &#123;\n        int r &#x3D; tryAcquireShared(arg);\n        if (r &gt;&#x3D; 0) &#123;\n          setHeadAndPropagate(node, r);\n          p.next &#x3D; null; &#x2F;&#x2F; help GC\n          failed &#x3D; false;\n          return;\n        &#125;\n      &#125;\n      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n          parkAndCheckInterrupt())\n        throw new InterruptedException();\n    &#125;\n  &#125; finally &#123;\n    if (failed)\n      cancelAcquire(node);\n  &#125;\n&#125;</code></pre></li>\n<li><p>countDown函数：直接调用AQS的releaseShared函数来实现，源码如下，</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ReservedStackAccess\npublic final boolean releaseShared(int arg) &#123;\n  &#x2F;&#x2F;将state减1，如果此时state变为0，则执行doReleaseShared\n  if (tryReleaseShared(arg)) &#123;\n    &#x2F;&#x2F;唤醒等待队列中的线程，即唤醒调用了await函数的线程\n    doReleaseShared();\n    return true;\n  &#125;\n  return false;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>CyclicBarrier的用法</p>\n<ol>\n<li><p>中文名为栅栏，主要用于多个线程互相等待，互相等待的线程都就位之后，再同时开始执行。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CyclicBarrier &#123;\n  &#x2F;&#x2F;构造函数，传入parties\n  public CyclicBarrier(int parties) &#123;\n    this(parties, null);\n  &#125;\n  public CyclicBarrier(int parties, Runnable barrierAction) &#123;\n    if (parties &lt;&#x3D; 0) throw new IllegalArgumentException();\n    this.parties &#x3D; parties;\n    this.count &#x3D; parties;\n    this.barrierCommand &#x3D; barrierAction;\n  &#125;\n  &#x2F;&#x2F;调用await函数的线程会将parties减一，如果不为0，则阻塞，直到为0为止\n  public int await() throws InterruptedException, BrokenBarrierException &#123;\n    try &#123;\n      return dowait(false, 0L);\n    &#125; catch (TimeoutException toe) &#123;\n      throw new Error(toe); &#x2F;&#x2F; cannot happen\n    &#125;\n  &#125;\n  public int await(long timeout, TimeUnit unit)\n    throws InterruptedException,BrokenBarrierException,TimeoutException &#123;\n    return dowait(true, unit.toNanos(timeout));\n  &#125;\n&#125;</code></pre></li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  &#x2F;&#x2F;创建parties为10的CyclicBarrier对象，用于10个线程之间相互等待，尽管10个线程的启动（执行\n  &#x2F;&#x2F;start函数）的时间不同，但每个线程结束都会调用await函数，将paeties减一，然后检查parties\n  &#x2F;&#x2F;如果不为0，则当前线程阻塞等待，如果parties为0，则当前线程唤醒所有调用了await函数的线程。\n  private static final CyclicBarrier barrier &#x3D; new CyclicBarrier(10);\n  public static void main(String[] args)&#123;\n    for(int i&#x3D;0; i&lt;10; ++i)&#123;\n      new Thread(new Runnbale()&#123;\n        @Override\n        public void run()&#123;\n          try&#123;\n            barrier.await();\n          &#125;catch(InterruptedException e)&#123;&#x2F;&#x2F;当前线程被中断\n            e.printStackTrace();\n          &#125;catch(BrokenBarrierException e)&#123;&#x2F;&#x2F;其他线程调用await()期间被中断\n            e.printStachTrace();\n          &#125;\n          &#x2F;&#x2F;执行业务逻辑\n        &#125;\n      &#125;).start();\n    &#125;\n    &#x2F;&#x2F;主线程需要等待以上10个线程执行结束，方法有以下3种：\n    &#x2F;&#x2F;1.sleep() 2.join() 3.CountDownLatch()\n  &#125;\n&#125;</code></pre></li>\n<li><p>使用CountDownLatch实现CyclicBarrier的功能</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  &#x2F;&#x2F;10个线程都调用await函数阻塞等待count为0，主线程调用countDown函数将count值减一，变为0，\n  &#x2F;&#x2F;然后唤醒调用了await函数的10个线程，实现10个线程同步执行的功能\n  private static final CountDownLatch latch &#x3D; new CountDownLatch(1);\n  public static void main(String[] args)&#123;\n    for(int i &#x3D; 0; i&lt; 10; ++i)&#123;\n      new Thread(new Runnable()&#123;\n        @Override\n        public void run()&#123;\n          try&#123;\n            latch.await();\n          &#125;catch(InterruptedExceptino e)&#123;\n            e.printStackTrace();\n          &#125;\n          &#x2F;&#x2F;执行业务逻辑\n        &#125;\n      &#125;).start();\n    &#125;\n    latch.countDown();\n    &#x2F;&#x2F;主线程需要等待以上10个线程执行结束，方法有以下3种：\n    &#x2F;&#x2F;1.sleep() 2.join() 3.CountDownLatch()\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>CyclicBarrier的实现原理：使用条件变量来实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CyclicBarrier &#123;\n  private final ReentrantLock lock &#x3D; new ReentrantLock();\n  private final Condition trip &#x3D; lock.newCondition();\n  private final int parties;\n  public CyclicBarrier(int parties) &#123;\n    this(parties, null);\n  &#125;\n  &#x2F;&#x2F;函数返回值线程调用await()函数之后的parties剩余值\n  &#x2F;&#x2F;await调用的dowait，省略了对InterruptedException和BrokenBarrierException的处理\n  private int dowait(boolean timed, long nanos)throws InterruptedException, \n  BrokenBarrierException,TimeoutException &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      int index &#x3D; --count;\n      if (index &#x3D;&#x3D; 0) &#123;  &#x2F;&#x2F;最后一个调用await()的线程，唤醒其他线程\n        trip.signalAll();&#x2F;&#x2F;在breakBarrier中\n        return 0;\n      &#125;\n      trip.await();\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>在接口性能测试中的应用：接口并发性能测试代码，如果测试N个接口请求并发执行时接口的性能，我们需要创建N个测试线程，让每个测试线程循环执行接口请求，并且记录每个接口请求的响应时间。主线程通过CountDownLatch来等待其他测试线程执行完成，然后，再通过记录的运行数据统计接口的性能，比如平均响应时间、QPS等。使用CyclicBarrier，让各测试线程更加精确地同时开始执行，以便更加准确地测试执行并发下的接口性能。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ApiBenchmark&#123;\n  private static int numThread &#x3D; 20;&#x2F;&#x2F;并发度为20\n  private static int numReqPerThread &#x3D; 1000;&#x2F;&#x2F;每个线程请求1000次接口\n  \n  private static CountDownLatch latch &#x3D; new CountDownLatch(numThread);\n  private static CyclicBarrier barrier &#x3D; new CyclicBarrier(numThread);\n  \n  public static void main(String[] args)throws InterruptedException&#123;\n    &#x2F;&#x2F;创建线程\n    Thread[] threads &#x3D; new Thread[numThread];\n    TestRunnable[] runnables &#x3D; new TestRunnable[numThread];\n    for(int i &#x3D; 0; i &lt; numThread; ++i)&#123;\n      runnable[i] &#x3D; new TestRunnable();\n      thread[i] &#x3D; new Thread(runnable[i]);\n    &#125;\n    &#x2F;&#x2F;启动线程\n    long startTime &#x3D; System.nanoTime();\n    for(int i &#x3D; 0; i &lt; numThread; ++i)&#123;\n      thread[i].start();\n    &#125;\n    &#x2F;&#x2F;等待测试线程结束\n    latch.await();\n    long endTime &#x3D; System.nanoTime();\n    &#x2F;&#x2F;统计接口性能\n    long qps &#x3D; (numThread*numReqPerThread*1000)&#x2F;((endTime-startTIme)&#x2F;1000000);\n    float avgRespTime &#x3D; 0.0f;\n    for(int i &#x3D; 0; i &lt; numThread; ++i)&#123;\n      for(Long respTime : runnables[i].respTime)&#123;\n        avgRespTime +&#x3D; respTime;\n      &#125;\n    &#125;\n    avgRespTime &#x2F;&#x3D; (numThread*numReqPerThread);\n  &#125;\n  \n  public static class TestRunnable implements Runnable&#123;\n    public List&lt;Long&gt; respTimes &#x3D; new ArrayList&lt;&gt;();\n    @Override\n    public void run()&#123;\n      try&#123;\n        &#x2F;&#x2F;所有线程同时开始执行\n        barrier.await();\n      &#125;catch(InterruptedException e)&#123;\n        e.printStackTrace();\n      &#125;catch(BrokenBarrierException e)&#123;\n        e.printStackTrace();\n      &#125;\n      for(int i &#x3D; 0; i &lt; numReqPerThread; ++i)&#123;\n        long reqStartTime &#x3D; System.nanoTime();\n        &#x2F;&#x2F;调用接口\n        long reqEndTime &#x3D; System.nanoTime();\n        respTimes.add(reqEndTime-reqStartTime);\n      &#125;\n      latch.countDown();\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"5-并发容器\"><a href=\"#5-并发容器\" class=\"headerlink\" title=\"5.并发容器\"></a>5.并发容器</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>ConcurrentHashMap、各种阻塞队列</p></blockquote>\n<ol>\n<li><p>Java容器回顾：除了废弃的几个，都不是线程安全的</p>\n<ol>\n<li>List：ArrayList、LinkedList、Vector（废弃）</li>\n<li>Stack：Stack（废弃）</li>\n<li>Queue：ArrayDeque、LinkedList、PriorityQueue</li>\n<li>Set：HashSet、LinkedHashSet、TreeSet</li>\n<li>Map：HashMap、LinkedHashMap、TreeMap、HashTable（废弃）</li>\n</ol>\n</li>\n<li><p>Java并发容器：为了更符合开发者的编程习惯，JCF将非线程安全容器和线程安全容器（并发容器）分开来设计，在非多线程环境下，使用非线程安全的容器，性能更高。</p>\n<ul>\n<li><p>并发容器：</p>\n<ul>\n<li>SynchronizedCollection</li>\n<li>SynchronizedSet、SynchronizedSortedSet、SynchronizedNavigableSet</li>\n<li>SynchronizedList、SynchronizedRandomAccessList</li>\n<li>SynchronizedMap、SynchronizedSortedMap、SynchronizedNavigableMap</li>\n</ul>\n</li>\n<li><p>创建方法</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220820184627656.png\" alt=\"image-20220820184627656\"></p>\n</li>\n<li><p>创建示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List list &#x3D; Collections.synchronziedList(new LinkedList&lt;&gt;());</code></pre></li>\n<li><p>源码示例：通过使用synchronized加锁来避免线程安全问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;\n  return (list instanceof RandomAccess ?\n          new SynchronizedRandomAccessList&lt;&gt;(list) :\n          new SynchronizedList&lt;&gt;(list));\n&#125;\nstatic class SynchronizedList&lt;E&gt;\n  extends SynchronizedCollection&lt;E&gt; implements List&lt;E&gt; &#123;\n  final List&lt;E&gt; list;\n\n  SynchronizedList(List&lt;E&gt; list) &#123;\n    super(list);\n    this.list &#x3D; list;\n  &#125;\n  SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;\n    super(list, mutex);\n    this.list &#x3D; list;\n  &#125;\n\n  public boolean equals(Object o) &#123;\n    if (this &#x3D;&#x3D; o)\n      return true;\n    synchronized (mutex) &#123;return list.equals(o);&#125;\n  &#125;\n  public int hashCode() &#123;\n    synchronized (mutex) &#123;return list.hashCode();&#125;\n  &#125;\n\n  public E get(int index) &#123;\n    synchronized (mutex) &#123;return list.get(index);&#125;\n  &#125;\n  public E set(int index, E element) &#123;\n    synchronized (mutex) &#123;return list.set(index, element);&#125;\n  &#125;\n  public void add(int index, E element) &#123;\n    synchronized (mutex) &#123;list.add(index, element);&#125;\n  &#125;\n  public E remove(int index) &#123;\n    synchronized (mutex) &#123;return list.remove(index);&#125;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>JUC并发容器：因为上述Java提供的并发容器代码实现简单，锁粒度大而导致并发性能不高，于是JUC变实现了一套更高性能的并发容器，使用了分段加锁、写时复制、无锁编程等技术进行了全新的实现。主要提供了以下并发容器，按照Java容器的对应关系进行分类</p>\n<ol>\n<li>List：JUC提供了CopyOnWriteArrayList，只适合读多写少的场景，没有LinkedList相关的并发容器</li>\n<li>Stack：栈可以用双端队列（Deque）来替代，JUC没有提供相关的容器</li>\n<li>Queue：<ul>\n<li>非阻塞并发队列（基于链表实现）：ConcurrentLinkedDequeue、ConcurrentLinkedQueue</li>\n<li>阻塞并发队列：ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue、DelayQueue、SynchronousQueue、LinkedTransferQueue</li>\n</ul>\n</li>\n<li>Set：CopyOnWriteArraySet（对应HashSet）、ConcurrentSkipListSet（对应TreeSet）</li>\n<li>Map：ConcurrentHashMap（对应HashMap）、ConcurrentSkipListMap（对应TreeMap）</li>\n</ol>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220820191425233.png\" alt=\"image-20220820191425233\"></p>\n</li>\n</ol>\n<h4 id=\"1-并发阻塞\"><a href=\"#1-并发阻塞\" class=\"headerlink\" title=\"1.并发阻塞\"></a>1.并发阻塞</h4><ol>\n<li><p>阻塞并发队列</p>\n<ol>\n<li>阻塞并发队列有两个特点：线程安全和支持读写阻塞。读写阻塞即队列空时读操作阻塞，直到队列有新数据写入；队列满时写操作阻塞，直到队列有数据被读走。阻塞并发队列一般用于实现生产者-消费者模型。</li>\n<li>JUC提供的阻塞并发队列有：ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue、DelayQueue、SynchronousQueue、LinkedTransferQueueQ</li>\n</ol>\n</li>\n<li><p>BlockingQueue</p>\n<ol>\n<li><p>ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue的实现原理类似，都是基于ReentrantLock锁来实现线程安全，基于Condition条件变量来实现阻塞等待，下面将以ArrayBlockingQueue为例</p>\n</li>\n<li><p>ArrayBlockingQueue</p>\n<ol>\n<li><p>源码一：使用方法和普通队列类似，只不过增加了读写可阻塞</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;\n  implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;\n  final Object[] items;\n  int takeIndex;&#x2F;&#x2F;下一次入队时，数据存储的下标位置\n  int putIndex;&#x2F;&#x2F;下一次出队时，出队数据的下标位置\n  int count;&#x2F;&#x2F;队列中的元素个数\n\n  final ReentrantLock lock;&#x2F;&#x2F;加锁实现线程并发安全\n  private final Condition notEmpty;&#x2F;&#x2F;用来阻塞读，等待非空条件的发生\n  private final Condition notFull;&#x2F;&#x2F;用来阻塞写，等待非满条件的发生\n\n  public ArrayBlockingQueue(int capacity) &#123;\n    this(capacity, false);\n  &#125;\n  &#x2F;&#x2F;支持公平和非公平两种工作模式，默认为非公平\n  public ArrayBlockingQueue(int capacity, boolean fair) &#123;\n    if (capacity &lt;&#x3D; 0) throw new IllegalArgumentException();\n    this.items &#x3D; new Object[capacity];&#x2F;&#x2F;底层基于数组实现的有界阻塞并发队列\n    lock &#x3D; new ReentrantLock(fair);&#x2F;&#x2F;公平性依赖锁的公平性来实现，即是否可插队获取锁\n    notEmpty &#x3D; lock.newCondition();\n    notFull &#x3D;  lock.newCondition();\n  &#125;\n  &#x2F;&#x2F;见下\n&#125;</code></pre></li>\n<li><p>源码二：支持读写阻塞的put和take函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;入队函数，支持阻塞写\npublic void put(E e) throws InterruptedException &#123;\n  checkNotNull(e);\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lockInterruptibly();&#x2F;&#x2F;加锁，被中断时会抛出异常\n  try &#123;\n    while (count &#x3D;&#x3D; items.length)&#x2F;&#x2F;循环是为了避免假唤醒，唤醒后还再检查一遍\n      notFull.await();&#x2F;&#x2F;调用await函数，等待非满条件的唤醒，\n    enqueue(e);&#x2F;&#x2F;入队\n  &#125; finally &#123;\n    lock.unlock();&#x2F;&#x2F;解锁\n  &#125;\n&#125;\nprivate void enqueue(E x) &#123;\n  &#x2F;&#x2F;调用enqueue时已加锁，不用担心线程安全问题，而且队列未满，不需要处理队列满的情况\n  final Object[] items &#x3D; this.items;\n  items[putIndex] &#x3D; x;&#x2F;&#x2F;放入队列对应位置\n  if (++putIndex &#x3D;&#x3D; items.length)\n    putIndex &#x3D; 0;&#x2F;&#x2F;循环队列\n  count++;\n  notEmpty.signal();&#x2F;&#x2F;唤醒等待执行读的线程\n&#125;\n\n&#x2F;&#x2F;出队函数，支持阻塞读\npublic E take() throws InterruptedException &#123;\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lockInterruptibly();\n  try &#123;\n    while (count &#x3D;&#x3D; 0)\n      notEmpty.await();&#x2F;&#x2F;等待非空条件的发生，\n    return dequeue();&#x2F;&#x2F;队列非空时，执行出队操作，并返回出队元素\n  &#125; finally &#123;\n    lock.unlock();\n  &#125;\n&#125;\nprivate E dequeue() &#123;\n  &#x2F;&#x2F;不需要处理线程安全问题以及队列为空的情况\n  final Object[] items &#x3D; this.items;\n  @SuppressWarnings(&quot;unchecked&quot;)\n  E x &#x3D; (E) items[takeIndex];\n  items[takeIndex] &#x3D; null;\n  if (++takeIndex &#x3D;&#x3D; items.length)\n    takeIndex &#x3D; 0;\n  count--;\n  if (itrs !&#x3D; null)\n    itrs.elementDequeued();\n  notFull.signal();\n  return x;\n&#125;</code></pre>\n\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220826092026721.png\" alt=\"image-20220826092026721\"></p>\n</li>\n<li><p>源码三：非阻塞的offer和poll函数，只通过ReentrantLock锁来保证线程安全，没有通过条件变量来实现阻塞读写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean offer(E e) &#123;\n  Objects.requireNonNull(e);\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lock();\n  try &#123;\n    if (count &#x3D;&#x3D; items.length)\n      return false;\n    else &#123;\n      enqueue(e);\n      return true;\n    &#125;\n  &#125; finally &#123;\n    lock.unlock();\n  &#125;\n&#125;\npublic E poll() &#123;\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lock();\n  try &#123;\n    return (count &#x3D;&#x3D; 0) ? null : dequeue();\n  &#125; finally &#123;\n    lock.unlock();\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>其余三个：均适用ReentrantLock来保证线程安全性，使用Condition条件变量来实现读写操作的阻塞等待</p>\n<ol>\n<li>LinkedBlockingQueue是基于链表实现的有界阻塞并发队列，默认大小为<code>Integer.MAX_VALUE</code>，也可以指定队列大小</li>\n<li>LinkedBlockingDeque与LinkedBlockingQueue的区别在于，它是一个双端队列，支持两端读写操作</li>\n<li>PriorityBlockingQueue是一个无界阻塞并发优先级队列，底层基于支持扩容的堆来实现，写操作永远不需要阻塞，只有读操作会阻塞</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>DelayQueue</p>\n<ol>\n<li><p>源码一：延迟阻塞并发队列，底层基于PriorityQueue来实现，因为PriorityQueue支持动态扩容，所以DelayQueue为无界队列，写永远都不会阻塞，只有读会阻塞。DelayQueue中存储的每个元素都必须实现Delayed接口，提供延迟被读取时间delayTime，PriorityQueue按照delayTime的大小将元素组织成最小顶堆，也就是说，堆顶的元素是delayTime最小的元素，应该最先被读取到。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt;\n  implements BlockingQueue&lt;E&gt; &#123;\n  private final transient ReentrantLock lock &#x3D; new ReentrantLock();&#x2F;&#x2F;可重入锁\n  private final PriorityQueue&lt;E&gt; q &#x3D; new PriorityQueue&lt;E&gt;();&#x2F;&#x2F;支持动态扩容\n  \n  private Thread leader;&#x2F;&#x2F;线程指定等待队列头元素\n  private final Condition available &#x3D; lock.newCondition();\n&#125;\n&#x2F;&#x2F;DelayQueue存储的每个元素都需要实现Delayed接口\npublic interface Delayed extends Comparable&lt;Delayed&gt; &#123;\n  long getDelay(TimeUnit unit);&#x2F;&#x2F;按照delayTime的大小来建堆\n&#125;</code></pre></li>\n<li><p>源码二：take函数，包含两个逻辑，针对leader线程的逻辑和针对非leader线程的逻辑。当多个线程先后调用take函数，第一个线程就是leader线程，剩下的就是非leader线程。第一个线程执行读取操作完成之后，第二个线程便称为leader线程。</p>\n<ul>\n<li>非leader线程直接调用await函数阻塞，等待leader线程执行完成之后调用signal来唤醒</li>\n<li>leader线程读取的是队首的元素，如果队首的元素delayTime大于0，那么leader线程会调用awaitNanos阻塞delayTime时间，当delayTime时间过去之后，leader线程自动唤醒，为了避免假唤醒（插队情况见下），leader线程会检查队首元素的delayTime是否真正变为小于等于0，如果是，则队首元素出队，调用signal唤醒第二个线程，第二个线程就成了leader线程</li>\n<li>插队情况：如果一个线程执行take函数时，如果检查发现队列不为空，并且队首元素的delayTime小于等于0，于是，不管是不是有其他线程在调用await或awaitNanos阻塞等待，这个线程都会直接读取队首元素并返回</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220826105219976.png\" alt=\"image-20220826105219976\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public E take() throws InterruptedException &#123;\n  final ReentrantLock lock &#x3D; this.lock;\n  lock.lockInterruptibly();\n  try &#123;\n    for (;;) &#123;&#x2F;&#x2F;自旋，以免假唤醒\n      E first &#x3D; q.peek();\n      if (first &#x3D;&#x3D; null) available.await();&#x2F;&#x2F;put函数会调用signal唤醒它\n      else &#123;\n        long delay &#x3D; first.getDelay(NANOSECONDS);&#x2F;&#x2F;获取延迟时间\n        if (delay &lt;&#x3D; 0L) return q.poll();&#x2F;&#x2F;元素到期被读取，会有插队情况\n        first &#x3D; null;  \n        if (leader !&#x3D; null) available.await();&#x2F;&#x2F;不是第一个读阻塞等待的线程\n        else &#123;&#x2F;&#x2F;第一个读阻塞等待的线程\n          Thread thisThread &#x3D; Thread.currentThread();\n          leader &#x3D; thisThread;\n          try &#123;\n            available.awaitNanos(delay);&#x2F;&#x2F;等待delay时间自己唤醒\n          &#125; finally &#123;\n            if (leader &#x3D;&#x3D; thisThread)\n              leader &#x3D; null;\n          &#125;\n        &#125;\n      &#125;\n    &#125;\n  &#125; finally &#123;\n    &#x2F;&#x2F;唤醒第二个写阻塞等待的线程\n    if (leader &#x3D;&#x3D; null &amp;&amp; q.peek() !&#x3D; null)\n      available.signal();\n    lock.unlock();\n  &#125;\n&#125;</code></pre></li>\n<li><p>示例：简单的任务延迟执行框架</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  public static class Job inplements Delayed&#123;\n    private String name;\n    private long scheduleTime;&#x2F;&#x2F;millisecond\n\n    public Job(String name, long scheduleTime)&#123;\n      this.name &#x3D; name;\n      this.scheduleTime &#x3D; scheduleTime;\n    &#125;\n    public void run()&#123;\n      System.out.println(&quot;I am &quot; + name);\n    &#125;\n    @Override\n    public long getDelay(TimeUnit unit)&#123;\n      long delayTime &#x3D; scheduleTime - System.currentTimeMillis();\n      return unit.convert(delayTime, TimeUnit.MILLISECONDS);\n    &#125;\n    @Override\n    public int compareTo(Delayed o)&#123;\n      return (int) (this.getDelay(TimeUnit.NANOSECONDS)) - \n        o.getDelay(TimeUnit.NANOSECONDS));\n    &#125;\n  &#125;\n  public static void main(String[] args) throws InterruptedException&#123;\n    DelayQueue&lt;Job&gt; jobs &#x3D; new DelayQueue&lt;&gt;();\n    &#x2F;&#x2F;job1、job2、job3的delayTime分别为1s、2s、3s\n    jobs.put(new Job(&quot;job1&quot;, System.currentTimeMillis()+1000));\n    jobs.put(new Job(&quot;job2&quot;, System.currentTimeMillis()+2000));\n    jobs.put(new Job(&quot;job3&quot;, System.currentTimeMillis()+3000));\n    Thread t1 &#x3D; new Thread(new JobRunnable(jobs));\n    Thread t2 &#x3D; new Thread(new JobRunnable(jobs));\n    &#x2F;&#x2F;t1和t2均调用take，然后都阻塞，1s后，t1从阻塞中唤醒，读取到job1，2s后，t2从阻塞总唤醒\n    &#x2F;&#x2F;读取到job2，\n    t1.start();\n    t2.start();\n    t1.join();&#x2F;&#x2F;确保子线程执行完毕后才能执行主线程\n    t2.join();\n  &#125;\n  &#x2F;&#x2F;新线程，先执行take从队列中拿job，然后运行改job\n  private static class JobRunnable implements Runnable&#123;\n    private DelatQueue&lt;Job&gt; jobs;\n    public JobRunnable(DelayQueue&lt;Job&gt; jobs)&#123;this.jobs &#x3D; jobs;&#125;\n    @Override\n    public void run()&#123;\n      try&#123;\n        Job job &#x3D; job.take();\n        job.run();\n      &#125;catch(InterruptedException e)&#123;\n        e.printStackTrace();\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>SynchronousQueue：用于两个线程之间传递数据，每个put操作必须阻塞等待take操作，队列中不存储任何元素，使用的很少，示例如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    SynchronousQueue&lt;String&gt; sq &#x3D; new SynchronizedQueue&lt;&gt;();\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        try&#123;\n          sq.put(&quot;a&quot;);&#x2F;&#x2F;每个put操作必须阻塞等待take操作\n          System.out.println(&quot;put done!&quot;);\n        &#125;catch (InterruptedException e)&#123;\n          e.printStackTrace();\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(3000);\n    System.out.println(&quot;sleep done!&quot;);\n    sq.take();&#x2F;&#x2F;每个put操作必须阻塞等待take操作\n    System.out.println(&quot;take done!&quot;);\n  &#125;\n&#125;\n&#x2F;&#x2F;先后输出sleep done! take done! put done!</code></pre></li>\n<li><p>LinkedTransferQueue：基于链表实现的无界阻塞并发队列，是LinkedBlockingQueue和SynchronousQueue的综合体，提供了transfer函数，跟SynchronousQueue的put函数的功能相同，调用transfer的线程会一直阻塞，知道数据被其他线程消费才会返回。使用的较少，示例代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    LinkedTransferQueue&lt;String&gt; ltq &#x3D; new LinkedTransferQueue&lt;&gt;();\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        ltq.put(&quot;a&quot;);&#x2F;&#x2F;不需要阻塞等待\n        System.out.println(&quot;put done!&quot;);\n        try&#123;\n          ltq.transfer(&quot;b&quot;);&#x2F;&#x2F;会阻塞等待\n          System.out.println(&quot;transfer done!&quot;);\n        &#125;catch (InterruptedException e)&#123;\n          e.printStackTrace();\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(3000);\n    System.out.println(&quot;sleep done!&quot;);\n    ltq.take();&#x2F;&#x2F;put写入的数据\n    ltq.take();&#x2F;&#x2F;transfer写入的数据\n    System.out.println(&quot;take done!&quot;)\n  &#125;\n&#125;\n&#x2F;&#x2F;先后输出put done! sleep done! take done! transfer done!</code></pre></li>\n</ol>\n<h4 id=\"2-分段加锁\"><a href=\"#2-分段加锁\" class=\"headerlink\" title=\"2.分段加锁\"></a>2.分段加锁</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>HashMap不是线程安全的，HashTable、SynchronizedMap虽然是线程安全的，但采用粗力度锁，并发性能不佳，所以JUC提供了ConcurrentHashMap，利用分段加锁等技术来提高并发性能</p></blockquote>\n<ol>\n<li><p>HashMap线程不安全分析：共享资源是table数组及其table数组中的链表，主要分析get中的读操作、put中的写操作、扩容操作、树化操作之间的线程安全性</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220830152533392.png\" alt=\"image-20220830152533392\" style=\"zoom: 67%;\" />\n\n<ul>\n<li>读操作与读操作、写操作、扩容、树化之间是否线程安全<ul>\n<li>读操作和读操作不存在线程安全问题：不涉及临界资源竞争</li>\n<li>读操作和写操作也不存在线程安全问题：写操作添加到table数组中链表的尾部，读操作从链表头遍历</li>\n<li>读操作和扩容之间存在线程安全问题：扩容时，会将数据一点一点移动，扩容初期会导致读取失败</li>\n<li>读操作和树化之间不存在线程安全问题：链表中的节点定义和红黑树中的节点定义不相同，所以树化的时候，HashMap无法将链表中的节点直接搬移到红黑树中，而是采用复制的方式，重新创建新的红黑树节点，将key、value复制到新创建的红黑树节点，然后在将节点添加到红黑树中。红黑树构建完成后，才会将table数组中的引用更新指向红黑树，所以是写时复制操作，读操作和树化之间无影响</li>\n</ul>\n</li>\n<li>写操作与写操作、扩容、树化之间是否线程安全<ul>\n<li>写操作与写操作之间存在线程安全问题：都是尾插，会导致线程不安全</li>\n<li>写操作和扩容之间存在线程安全问题：扩容搬移数据和写操作是并行执行写操作，会导致线程不安全</li>\n<li>写操作和树化之前存在线程安全问题：在红黑树构建完成但table数组中的引用没更新前，导致写入的数据无法搬移到红黑树中，会导致写操作无效</li>\n</ul>\n</li>\n<li>扩容与扩容、树化之间是否线程安全<ul>\n<li>扩容和扩容之间存在线程安全问题：两个线程同时执行扩容操作，会争抢搬移老的table数组中的数据，最终引用仅指向一个新数组，所以会导致数据的大量丢失</li>\n<li>扩容和树化之间存在线程安全问题：树化过程中另一线程若扩容，会因为搬移数据导致树化操作只能针对链表中的部分数据进行，进而导致数据大量丢失</li>\n</ul>\n</li>\n<li>树化与树化之前是否线程安全<ul>\n<li>树化与树化之前不存在线程安全问题：树化通过写时复制来实现，两个树化同时进行只会导致生成两个重复的红黑树，并不会引起数据丢失的问题</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>ConcurrentHashMap介绍</p>\n<ul>\n<li>HashTable和SynchronizedMap都通过简单的对所有方法加锁，来解决线程安全问题，SynchronziedMap的引入是为了让JCF框架的类结构更加清晰，线程安全容器和非线程安全容器相分离，线程安全容器通过统一的方式（Collections的synchronizedXXX方法）来创建</li>\n<li>JDK8版本的ConcurrentHashMap比JDK7版本的分段加锁力度更小，并发度更高，扩容方式有所不同，size实现更高效等优势</li>\n<li>ConcurrentHashMap中，table数组被分段加锁，如果table数组的大小为n，那么就对应存在n把锁，每一个链表独享一把锁，不同链表之间的操作可以多线程并行执行，互不影响，以此来提高并发性能</li>\n</ul>\n</li>\n<li><p>get函数的实现原理</p>\n<ul>\n<li>get函数就是读操作，没有加锁的处理逻辑，get函数可以跟任何操作（读操作、写操作、树化、扩容）并行执行，并发性能极高</li>\n<li>get与其他操作没有线程安全问题，但get和扩容操作之间因为有线程安全问题，所以需要特殊处理</li>\n</ul>\n</li>\n<li><p>put函数的实现原理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V put(K key, V value) &#123;\n  return putVal(key, value, false);\n&#125;\n\n&#x2F;** Implementation for put and putIfAbsent *&#x2F;\nfinal V putVal(K key, V value, boolean onlyIfAbsent) &#123;\n  if (key &#x3D;&#x3D; null || value &#x3D;&#x3D; null) throw new NullPointerException();&#x2F;&#x2F;空值\n  int hash &#x3D; spread(key.hashCode());&#x2F;&#x2F;求hash值\n  int binCount &#x3D; 0;\n  for (Node&lt;K,V&gt;[] tab &#x3D; table;;) &#123;&#x2F;&#x2F;遍历table\n    Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv;\n    if (tab &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n      tab &#x3D; initTable();&#x2F;&#x2F;空hash表初始化，通过CAS操作\n    else if ((f &#x3D; tabAt(tab, i &#x3D; (n - 1) &amp; hash)) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;空链表\n      if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))&#x2F;&#x2F;cas操作增加元素\n        break;                   &#x2F;&#x2F; no lock when adding to empty bin\n    &#125;\n    else if ((fh &#x3D; f.hash) &#x3D;&#x3D; MOVED)\n      tab &#x3D; helpTransfer(tab, f);\n    else if (onlyIfAbsent &#x2F;&#x2F; check first node without acquiring lock\n             &amp;&amp; fh &#x3D;&#x3D; hash\n             &amp;&amp; ((fk &#x3D; f.key) &#x3D;&#x3D; key || (fk !&#x3D; null &amp;&amp; key.equals(fk)))\n             &amp;&amp; (fv &#x3D; f.val) !&#x3D; null)\n      return fv;\n    else &#123;\n      V oldVal &#x3D; null;\n      synchronized (f) &#123;&#x2F;&#x2F;对头节点f加锁\n        if (tabAt(tab, i) &#x3D;&#x3D; f) &#123;&#x2F;&#x2F;\n          if (fh &gt;&#x3D; 0) &#123;\n            binCount &#x3D; 1;\n            for (Node&lt;K,V&gt; e &#x3D; f;; ++binCount) &#123;&#x2F;&#x2F;遍历链表看是否存在key跟写入数据相同的节点\n              K ek;\n              if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                  ((ek &#x3D; e.key) &#x3D;&#x3D; key ||\n                   (ek !&#x3D; null &amp;&amp; key.equals(ek)))) &#123;\n                oldVal &#x3D; e.val;&#x2F;&#x2F;存在\n                if (!onlyIfAbsent)\n                  e.val &#x3D; value;&#x2F;&#x2F;更新此节点的value\n                break;\n              &#125;\n              Node&lt;K,V&gt; pred &#x3D; e;\n              if ((e &#x3D; e.next) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;不存在，写入到链表的尾部\n                pred.next &#x3D; new Node&lt;K,V&gt;(hash, key, value);\n                break;\n              &#125;\n            &#125;\n          &#125;&#x2F;&#x2F;if\n          else if (f instanceof TreeBin) &#123;&#x2F;&#x2F;红黑树节点\n            Node&lt;K,V&gt; p;\n            binCount &#x3D; 2;\n            if ((p &#x3D; ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) !&#x3D; null) &#123;\n              oldVal &#x3D; p.val;\n              if (!onlyIfAbsent)\n                p.val &#x3D; value;\n            &#125;\n          &#125;&#x2F;&#x2F;else if\n          else if (f instanceof ReservationNode)\n            throw new IllegalStateException(&quot;Recursive update&quot;);\n        &#125;&#x2F;&#x2F;if\n      &#125;&#x2F;&#x2F;synchronized\n      if (binCount !&#x3D; 0) &#123;\n        if (binCount &gt;&#x3D; TREEIFY_THRESHOLD)\n          &#x2F;&#x2F;树化，会加锁，创建红黑树，将链表数据复制到红黑树，将table[index]指向红黑树\n          treeifyBin(tab, i);\n        if (oldVal !&#x3D; null)\n          return oldVal;\n        break;\n      &#125;\n    &#125;&#x2F;&#x2F;else结束\n  &#125;\n  addCount(1L, binCount);\n  return null;\n&#125;</code></pre>\n\n<ul>\n<li><p>写操作：两种加锁方式，链表为空的时候，通过CAS操作将table[index]指向写入数据对应的节点；链表不为空，先对头节点使用synchronized加锁，再执行写操作</p>\n</li>\n<li><p>树化：写入操作完成后，如果链表中的节点个数大于等于树化阈值（默认为8），put会执行树化操作，尽管是写时复制操作，但是在树化的同时执行写入操作或扩容，会导致数据丢失，因此树化操作也需要使用synchronzied加锁</p>\n</li>\n<li><p>扩容：扩容需要对整个table的所有链表加锁，也是通过分段加锁分段执行，对HashMap增加了两点改进</p>\n<ul>\n<li><p>写时复制：</p>\n<ul>\n<li>在创建好新的table数组之后，采用写时复制的方法，一点点复制，在全部复制完之后，才会将table引用指向新创建的table数组。</li>\n<li>table会出现三种不同类型的链表，已复制未加锁链表、在复制已加锁链表、未复制未加锁链表，根据类型不同决定在那个table处理读、写、树化操作。</li>\n<li>类型的标记由新节点类型ForwardingNode标记，此节点类型的hash值为-1。在扩容的时候，将复制完解锁前的链表头节点换成ForwardingNode节点，并将ForwardingNode节点中的nextTable属性指向新创建的table数组，读、写、树化table数组的某个链表时，如果头节点的hash值为-1.就在这个节点的nextTable属性所指向的table数组中重新查找对应的链表，在执行相应操作</li>\n</ul>\n</li>\n<li><p>复制替代搬移：扩容基于复制而非搬移实现，将老的table数组中的节点中的key、value等数据，复制一份存储在一个新创建的节点中，再将新创建的节点插入到新的table数组中</p>\n</li>\n<li><p>多个线程共同协作完成扩容：</p>\n<ul>\n<li><p>每个线程根据transferIndex来决定具体负责哪几个链表的复制，transferIndex初始化为table.length，多个线程通过CAS修改transferIndex共享变量，谁成功更新，谁就获得[transferIndex-stride, transferIndex)之间的stride个链表的复制权，争夺失败的线程自旋重新执行CAS</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)&#123;\n  int n &#x3D; tab.length;\n  int stride;&#x2F;&#x2F;每个线程负责相邻的stride个链表\n  int NCPU &#x3D; Runtime.getRuntime().availableProcessors();\n  if((stride &#x3D; (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) &#x2F; NCPU : n) &lt; MIN_TRANSFER_STRIDE)\n    stride &#x3D; MIN_TRANSFER_STRIDE;&#x2F;&#x2F;MIN_TRANSFER_STRIDE &#x3D; 16\n  \n  &#x2F;&#x2F;循环获取stride个链表的处理权并处理，直到没有剩余的链表要处理\n  while(transferIndex &gt; 0)&#123;\n    int oldIndex &#x3D; transferIndex;\n    int newIndex &#x3D; oldIndex &gt; stride ? oldIndex-stride : 0;\n    if(!cas(transferIndex, oldIndex, newIndex))&#123;\n      continue;&#x2F;&#x2F;失败继续，自旋CAS\n    &#125;\n    &#x2F;&#x2F;CAS成功，处理下标在[transferIndex-stride, transferIndex)之间的\n    &#x2F;&#x2F;table数组中的链表\n  &#125;\n&#125;</code></pre></li>\n<li><p>执行table引用更新的线程：ConcurrentHashMap定义了一个int类型的sizeCtl变量，用来标记当前正在参与扩容的线程个数，进入和退出的线程通过CAS操作增减sizeCtl，如果变为0，那么这个线程就是最后一个线程，负责引用更新</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>size函数的实现原理</p>\n<ul>\n<li>扫描统计：每次调用size函数时，都把table数组中的所有链表都遍历一遍，统计得到总的元素个数。每次扫描都需要加锁，导致并发性能降低，执行效率也非常低</li>\n<li>实时统计：ConcurrentHashMap中维护一个size成员变量，每当执行增、删元素操作时，同步更新size，无论将size设置为AtomicInteger还是通过CAS更新size，在高并发场景下，都会存在性能问题，进而影戏那个增、删操作的性能</li>\n<li>非一致性统计：借鉴LongAdder的实现思路，每个链表维护一个实时统计的cellSize，表示这个链表的节点个数，当调用size函数时，每个链表的cellSize相加即可得到元素总个数，但会导致统计结果不一致</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-写时复制\"><a href=\"#3-写时复制\" class=\"headerlink\" title=\"3.写时复制\"></a>3.写时复制</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>写时复制并发容器：CopyOnWriteArrayList、CopyOnWriteArraySet</p></blockquote>\n<ol>\n<li><p>基本原理：主要应用于并发容器中，为了避免读操作和写操作（增、删、改）同时发生而产生的线程安全问题，写时复制将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作，而对读操作继续在原始容器上进行，这样读写之间不会存在数据访问冲突，当写操作执行完成后，新创建的容器替代原始容器。以CopyOnWriteArrayList的源码为例，CopyOnWriteArraySet的底层存储结构使用的是基于CopyOnWriteArrayList</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;CopyOnWriteArrayList是ArrayList的线程安全版本，也实现了List接口\npublic class CopyOnWriteArrayList&lt;E&gt;\n  implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;\n  final transient ReentrantLock lock &#x3D; new ReentrantLock();\n  private transient volatile Object[] array;\n  public CopyOnWriteArrayList() &#123;setArray(new Object[0]);&#125;\n\n  &#x2F;&#x2F;get()函数，读操作，直接按下标访问array数组\n  private E get(Object[] a, int index) &#123;\n    return (E) a[index];&#x2F;&#x2F;return (E) this.array[index];\n  &#125;\n  public E get(int index) &#123;return get(getArray(), index);&#125;\n  final Object[] getArray() &#123;return array;&#125;\n  &#x2F;&#x2F;add()函数，用于新增数据包含写时复制逻辑\n  public boolean add(E e) &#123;\n    &#x2F;&#x2F;使用可重入锁来保证写操作的线程安全性，避免两个线程同时执行写时复制\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      &#x2F;&#x2F;获得原始数组array\n      Object[] elements &#x3D; getArray();\n      int len &#x3D; elements.length;\n      &#x2F;&#x2F;添加数据时，首先创建一个长度比原始数组大一的数组，并拷贝数据到新数组\n      &#x2F;&#x2F;Arrays.copyOf()底层以来native方法System.arrayCopy()来实现，比较快速\n      Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);\n      &#x2F;&#x2F;将新数据添加到数据末尾\n      newElements[len] &#x3D; e;\n      &#x2F;&#x2F;修改array引用指向newElements\n      setArray(newElements);\n      return true;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n  &#x2F;&#x2F;remove()函数，删除元素，类似于add函数，\n  public E remove(int index) &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      Object[] elements &#x3D; getArray();\n      int len &#x3D; elements.length;\n      E oldValue &#x3D; get(elements, index);\n      int numMoved &#x3D; len - index - 1;\n      if (numMoved &#x3D;&#x3D; 0)&#x2F;&#x2F;删除array数组的最后一个元素\n        setArray(Arrays.copyOf(elements, len - 1));\n      else &#123;&#x2F;&#x2F;删除array数组内部的元素\n        Object[] newElements &#x3D; new Object[len - 1];\n        &#x2F;&#x2F;拷贝array中下标在[0, index-1]之间的元素到newElements\n        System.arraycopy(elements, 0, newElements, 0, index);\n        &#x2F;&#x2F;拷贝array中下标在[index+1, len-1]之间的元素到newElements\n        System.arraycopy(elements, index + 1, newElements, index,\n                         numMoved);\n        setArray(newElements);\n      &#125;\n      return oldValue;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n  &#x2F;&#x2F;set()函数，用于改元素\n  public E set(int index, E element) &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n      Object[] elements &#x3D; getArray();\n      E oldValue &#x3D; get(elements, index);\n\n      if (oldValue !&#x3D; element) &#123;\n        int len &#x3D; elements.length;\n        Object[] newElements &#x3D; Arrays.copyOf(elements, len);\n        newElements[index] &#x3D; element;\n        setArray(newElements);\n      &#125; else &#123;\n        &#x2F;&#x2F; Not quite a no-op; ensures volatile write semantics\n        setArray(elements);\n      &#125;\n      return oldValue;\n    &#125; finally &#123;\n      lock.unlock();\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>读多写少</p>\n<ol>\n<li>CopyOnWriteArrayList源码显示，写操作需要加锁，只能串行执行，而且写操作执行写时复制逻辑，涉及大量数据的拷贝，因此写操作的执行效率很低，所以写时复制逻辑只适用于读多写少的应用场景</li>\n<li>对于写比较多的应用场景，可以使用链表，因为链表的增删操作是局部操作，可以使用之前的无锁编程技巧，在保证线程安全的同时，尽可能提高并发性能。所以对于写操作比较多的场景，可以使用链表来实现线程安全的List容器，具体实现见下一节</li>\n</ol>\n</li>\n<li><p>弱一致性：CopyOnWriteArrayList源码显示，写操作的结果并非对读操作立即可见，这就导致了短暂的数据不一致，称为弱一致性，在某些业务场景下，会引发bug，如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private List&lt;Integer&gt; scores &#x3D; new CopyOnWriteArrayList&lt;&gt;();\n  \n  public void add(int idx, int score)&#123;\n    scores.add(idx, score);&#x2F;&#x2F;将数据插入到idx下标位置\n  &#125;\n  public int sum()&#123;\n    int ret &#x3D; 0;\n    for(int i &#x3D; 0; i &lt; scores.size(); ++i)&#123;\n      ret +&#x3D; scores.get(i);\n    &#125;\n    return ret;\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>遍历容器求和将存在重复统计的问题：如下图所示。线程A遍历原始数组进行累加，当累加完下标为3的元素23之后，线程B执行add(3, 17)函数，将array引用切换为指向新的数组。此时变量i的值仍然为4,线程A从下标为4的位置开始遍历新的数组，于是，元素23又被遍历累加了一遍。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220822194120474.png\" alt=\"image-20220822194120474\"></p>\n</li>\n<li><p>解决办法：CopyOnWriteArrayList提供了用于遍历容器的迭代器，在创建迭代器对象时，CopyOnWriteArrayList会将</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Iterator&lt;E&gt; iterator() &#123;\n  return new COWIterator&lt;E&gt;(getArray(), 0);\n&#125;\nstatic final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123;\n  private final Object[] snapshot;&#x2F;&#x2F;指向原始数组\n  &#x2F;** Index of element to be returned by subsequent call to next.  *&#x2F;\n  private int cursor;\n\n  private COWIterator(Object[] elements, int initialCursor) &#123;\n    cursor &#x3D; initialCursor;\n    snapshot &#x3D; elements;\n  &#125;\n  @SuppressWarnings(&quot;unchecked&quot;)\n  public E next() &#123;\n    if (! hasNext())\n      throw new NoSuchElementException();\n    return (E) snapshot[cursor++];\n  &#125;\n\t&#x2F;&#x2F;省略其他方法\n&#125;</code></pre></li>\n<li><p>对sum函数重构如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int sum()&#123;\n  int ret &#x3D; 0;\n  Iterator&lt;Integer&gt; itr &#x3D; scores.iterator();\n  while(itr.hasNext())&#123;\n    ret +&#x3D; itr.next();\n  &#125;\n  return ret;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>连续存储</p>\n<ol>\n<li><p>JUC提供了CopyOnWriteArrayList、CopyOnWriteArraySet，却没有提供CopyOnWriteLinkedList、CopyOnWriteHashMap等其他类型的写时复制容器的原因：因为执行写操作需要复制整个数据，对于链表和哈希表来说，因为数据在内存中不是连续存储的，所以耗时非常大，写操作的性能无法满足工业级通用类对性能的要求。CopyOnWriteArrayList、CopyOnWriteArraySet底层都是基于数组来实现的，而且使用了JVM底层提供的native方法，通过C++代码中的指针实现了内存块的快速拷贝，</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;位于System.java中\npublic static native void arraycopy(Object src,  int  srcPos,\n                                    Object dest, int destPos,int length);</code></pre></li>\n<li><p>支持写时复制的HashMap实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Configuration&#123;\n  private static final Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\n  &#x2F;&#x2F;热更新，不需要加锁（只有一个线程调此函数），也不需要拷贝（全量更新配置）\n  public void reload()&#123;\n    Map&lt;String, String&gt; newMap &#x3D; new HashMap&lt;&gt;();\n    &#x2F;&#x2F;从配置文件加载配置，并解析放入newMap\n    map &#x3D; newMap;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-线程管理\"><a href=\"#6-线程管理\" class=\"headerlink\" title=\"6.线程管理\"></a>6.线程管理</h3><h4 id=\"1-线程状态\"><a href=\"#1-线程状态\" class=\"headerlink\" title=\"1.线程状态\"></a>1.线程状态</h4><ol>\n<li><p>线程状态概述</p>\n<ul>\n<li><p>Linux线程状态：NEW（新创建）、READY（就绪，等待CPU时间片）、RUNNING（使用CPU时间片）、WAITING（等待其他事件：I/O、锁）、TERMINATED（终止，未必立即销毁），转化关系如下</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905124708312.png\" alt=\"image-20220905124708312\"></p>\n</li>\n<li><p>Java线程状态：NEW（同Linux的NEW）、RUNNABLE、WAITING（执行特殊函数可进入）、TIMED_WAITING（执行特殊函数可进入）、BLOCKED、TERMINATED（同Linux的TERMINATED）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905124722690.png\" alt=\"image-20220905124722690\"></p>\n<ul>\n<li><p>与Linux的状态对应关系：RUNNABLE包括Linux的READY &amp; RUNNING &amp; 部分WAITING操作，因为Java应用层面不关心底层硬件的使用情况（CPU有没有在执行），所以Linux的RUNNING和等待I/O的WAITING都归类为RUNNABLE</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905124756435.png\" alt=\"image-20220905124756435\"></p>\n</li>\n<li><p>BLOCKED：只有两种状态，一种是线程执行synchronized语句，阻塞等待获取锁；另一种是线程执行Object.wait()后被notify()或notifyAll()唤醒，再次阻塞等待获取锁，synchronized阻塞和lock阻塞状态不同的原因如下</p>\n<ul>\n<li>执行JUC Lock的lock()函数时，底层调用LockSupport.park()进行阻塞，更底层又调用Unsafe.park()，对应线程状态变为WAITING，与synchronized进入的BLOCKED状态不同</li>\n<li>Java线程状态的修改是在JVM层面实现的，没有为上层（JDK和JUC）提供修改的函数，而是将线程状态耦合在了一些JVM提供的特殊函数和语法中（如Thread.sleep、Object.wait、synchronzied、Thread.join、Object.notify、Unsafe.park）<ul>\n<li>JUC在实现Lock时，用到了JVM提供的Unsafe.park，所以线程进入WAITING状态（JVM在WAITING和BLOCKED之间选了WAITING，否则JUC的Condition调用await是会进入BLOCKED，与Object.wait的状态又不一致）</li>\n<li>synchronized调用的park函数，JVM将其线程状态设置为BLOCKED</li>\n</ul>\n</li>\n<li>synchronized的park、Unsafe.park、LockSupport.park三个函数功能相同，区别在于synchronized的park是JVM内部私有的，只给synchronized使用；Unsafe.park给所有开发者使用；LockSupport.park是对Unsafe.park的封装为了JUC使用方便</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程状态与函数对应关系</p>\n<ul>\n<li><p>jstack是JVM自带的一个线程信息打印工具，能够打印线程的快照信息，比如函数调用栈信息、线程状态等，可以清晰地知道线程执行到哪里、处于什么状态、等待什么资源等。jstack常用于定位线程长时间卡顿问题，比如死锁、死循环等</p>\n</li>\n<li><p>jstack的使用：首先通过jps列出所有Java进程ID，查找要打印线程信息的进程ID，然后使用jstack 进程ID命令即可打印线程包含的所有线程的信息</p>\n</li>\n<li><p>示例</p>\n<table>\n<thead>\n<tr>\n<th>代码行为</th>\n<th>线程状态</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>synchronized阻塞时</td>\n<td>BLOCKED</td>\n</tr>\n<tr>\n<td>Thread.sleep(long time)</td>\n<td>TIMED_WAITING</td>\n</tr>\n<tr>\n<td>Thread.join()，基于Object.wait()</td>\n<td>WAITING</td>\n</tr>\n<tr>\n<td>Object.wait()</td>\n<td>WAITING</td>\n</tr>\n<tr>\n<td>Object.wait()被notify/notifyAll唤醒</td>\n<td>BLOCKED</td>\n</tr>\n<tr>\n<td>Lock.lock()（LockSupport-&gt;Unsafe）</td>\n<td>WAITING</td>\n</tr>\n<tr>\n<td>Condition.await()（同上）</td>\n<td>WAITING</td>\n</tr>\n<tr>\n<td>Semaphore.aquire()（同上）</td>\n<td>WAITING</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n<li><p>线程状态与jstack的应用</p>\n<ul>\n<li><p>在平时开发的时候，有时会遇到CPU占用率100%、请求超时的情况，往往是因为死循环导致的。此时可以调用jstack将所有的进程运行信息都打印出来，查看线程的函数调用栈信息，定位哪个线程在执行循环操作。如果出现两个线程互相等待对方持有的锁，就说明出现了死锁</p>\n</li>\n<li><p>示例</p>\n<ul>\n<li><p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo01 &#123;\n    private static final Object obj1 &#x3D; new Object();\n    private static final Object obj2 &#x3D; new Object();\n    public static void main(String[] args) throws InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                synchronized (obj1)&#123;\n                    try&#123;\n                        Thread.sleep(1000);\n                    &#125;catch (InterruptedException e)&#123;\n                        e.printStackTrace();\n                    &#125;\n                    synchronized (obj2)&#123;\n\n                    &#125;\n                &#125;\n            &#125;\n        &#125;,&quot;t1&quot;);\n        t1.start();\n        Thread.sleep(500);\n        synchronized (obj2)&#123;\n            synchronized (obj1)&#123;\n\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>jstack结果</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220905124818133.png\" alt=\"image-20220905124818133\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-线程池\"><a href=\"#2-线程池\" class=\"headerlink\" title=\"2.线程池\"></a>2.线程池</h4><ol>\n<li><p>线程池的简介（ThreadPoolExecutor类）</p>\n<ul>\n<li><p>线程池是池化技术的一种，常见的池化技术还有数据库连接池、对象池等。池化技术用来避免频繁的资源创建和销毁，提高资源的复用率，可以使得在需要线程的时候，直接从线程池中获取，在请求处理完成之后，再将线程归还给线程池，以供复用</p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo_pool&#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F;创建与配置\n        ThreadPoolExecutor pool &#x3D; new ThreadPoolExecutor(5, 10, 1000,\n                TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(15), \n                new ThreadFactory()&#123;\n            private final AtomicInteger idx &#x3D; new AtomicInteger(1);\n            @Override\n            public Thread newThread(Runnable r)&#123;\n                return new Thread(r, &quot;pool-&quot; + idx.getAndIncrement());\n            &#125;\n        &#125;, new ThreadPoolExecutor.DiscardPolicy());\n\n        &#x2F;&#x2F;执行\n        pool.execute(new Runnable()&#123;\n            @Override\n            public void run()&#123;\n                System.out.println(&quot;hello&quot;);\n            &#125;\n        &#125;);\n        &#x2F;&#x2F;关闭\n        pool.shutdown();&#x2F;&#x2F;发起关闭请求\n        boolean terminated &#x3D; false;\n        while(!terminated)&#123;\n            &#x2F;&#x2F;返回值为false表示超时，返回值为true表示线程池真正关闭\n            terminated &#x3D; pool.awaitTermination(100, TimeUnit.SECONDS);\n        &#125;\n        System.out.println(&quot;pool is shutdown&quot;);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>线程池的创建（JUC中会提供一些工厂方法来简化线程池的创建过程）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;ThreadPoolExecutor类最底层的构造函数\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) &#123;...&#125;</code></pre>\n\n<ul>\n<li><p>int corePoolSize：核心线程池的大小，整个线程池分为核心和非核心两部分，核心线程池一旦创建就不会销毁、非核心线程在创建之后，如果长时间未使用，便会销毁</p>\n</li>\n<li><p>int maximumPoolSize：整个线程池的大小（核心+非核心）</p>\n</li>\n<li><p>long keepAliveTime：非核心线程池中的线程销毁前的等待时间，单位为<code>TimeUnit unit</code>参数指定</p>\n</li>\n<li><p>BlockingQueue&lt;Runnable&gt; workQueue：用来存储任务，核心线程池已满时的新请求线程会被放入此队列，等待线程处理。workQueue是阻塞队列，其他JUC提供的阻塞队列都可以在此处使用</p>\n</li>\n<li><p>ThreadFactory threadFactory：如果传入threadFactory工厂类对象，线程池中线程的创建均通过工厂类的newThread()方法来实现，可以自定义实现，例如附加一些线程名称等信息</p>\n</li>\n<li><p>RejectedExecutionHandler handler：线程池中已存在maximumPoolSize个线程，等待队列workQueue（有界阻塞队列）已满时，新到来的任务就会触发拒绝策略，可以通过handler参数来设置拒绝策略</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;RejectedExecutionHandler接口定义\npublic interface RejectedExecutionHandler &#123;\n  void rejectedExecution(Runnable r, ThreadPoolExecutor executor);\n&#125;\n&#x2F;&#x2F;ThreadPoolExecutor类中预先实现的拒绝策略\n&#x2F;&#x2F;拒绝策略：由任务递交者代替线程池来执行这个任务，递交者若关闭，则丢弃任务\npublic static class CallerRunsPolicy implements RejectedExecutionHandler &#123;\n  public CallerRunsPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n    if (!e.isShutdown()) &#123;\n      r.run();\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F;拒绝策略：直接放弃执行任务，并抛出RejectedExecutionException异常\npublic static class AbortPolicy implements RejectedExecutionHandler &#123;\n  public AbortPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n    throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +\n                                         &quot; rejected from &quot; +\n                                         e.toString());\n  &#125;\n&#125;\n&#x2F;&#x2F;拒绝策略：直接放弃执行任务\npublic static class DiscardPolicy implements RejectedExecutionHandler &#123;\n  public DiscardPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n  &#125;\n&#125;\n&#x2F;&#x2F;拒绝策略：删掉workQueue中的一个任务，再次调用execute执行当前任务\npublic static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;\n  public DiscardOldestPolicy() &#123; &#125;\n  public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;\n    if (!e.isShutdown()) &#123;\n      e.getQueue().poll();\n      e.execute(r);\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>线程池的执行</p>\n<ul>\n<li><p>使用线程池执行任务，只需要将任务封装成Runnable对象，然后传递给execute()函数即可，任务的执行全部由execute()函数负责。线程池中的线程是动态的，有如下几种处理方式</p>\n<ul>\n<li><p>检查核心线程池是否已满，如果未满，则创建核心线程执行任务</p>\n</li>\n<li><p>如果核心线程池已满，再检查等待队列是否已满，如果未满，则将任务放入等待队列</p>\n</li>\n<li><p>如果等待队列已满，再检查非核心线程池是否已满，如果未满，则创建非核心线程执行任务</p>\n</li>\n<li><p>如果核心线程池、非核心线程池、等待队列都满，则按照拒绝策略对任务进行处理</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220907140149914.png\" alt=\"image-20220907140149914\"></p>\n</li>\n</ul>\n</li>\n<li><p>线程池执行任务的过程，并非是从线程池中取出线程然后执行任务，而是将任务放在等待队列中等待线程的读取并执行。</p>\n<ul>\n<li>核心线程创建之后，会调用workQueue上的take函数，不停的从workQueue中取任务来执行，take函数是阻塞函数，即没有任务时线程会一直阻塞等待</li>\n<li>非核心线程创建之后，会调用workQueue上的poll函数，不停的从workQueue中取任务处理，poll函数也是阻塞的，但是其会设置阻塞的超时时间，如果poll函数的阻塞时间超过keepAliveTime，poll就会从阻塞中返回并执行线程销毁逻辑</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程池的关闭</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;线程池会拒绝接受新的任务，但是会将正在执行的任务和等待队列中的任务全部执行完\npublic void shutdown() &#123;&#125;\n&#x2F;&#x2F;线程池会拒绝接受新的任务，而且会清空等待队列，并向所有的线程发送中断请求，调用take或poll阻塞等待的线\n&#x2F;&#x2F;程会被中断然后结束，正在执行任务的线程在收到中断请求后，既可以中断终止执行，也可以继续执行任务，\n&#x2F;&#x2F;返回值为等待队列中未被执行的任务\npublic List&lt;Runnable&gt; shutdownNow() &#123;&#125;\n\n&#x2F;&#x2F;确保所有的线程都已经结束，需要调用awaitTermination函数阻塞等待\nwhile(!terminated)&#123;\n  &#x2F;&#x2F;返回值为false表示超时，返回值为true表示线程池真正关闭\n  terminated &#x3D; pool.awaitTermination(100, TimeUnit.SECONDS);\n&#125;</code></pre></li>\n<li><p>线程池的配置</p>\n<ul>\n<li><p>COU密集型程序：线程池可以等于或大于可用CPU核数</p>\n</li>\n<li><p>I/O密集型程序：程序的大部分时间都在执行I/O操作，可以将线程池设置的大一些，以便众多线程轮流使用CPU</p>\n</li>\n<li><p>计算公式</p>\n<ul>\n<li><p>通过监控统计，得知线程池执行的任务平均CPU耗时为cpu_time毫秒，平均I/O耗时（非CPU耗时）为io_time毫秒，线程池大小设置参考公式为<code>pool_size = (cpu_time + io_time)/cpu_time</code>，此公式计算出的线程池大小指的是CPU利用率100%时对应的线程池大小</p>\n</li>\n<li><p>示例：cpu_time = 1/3总耗时，io_time = 2/3总耗时，单核CPU上，线程池需要设置为3，CPU的利用率将会是100%，如下图</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220907142435347.png\" alt=\"image-20220907142435347\"></p>\n</li>\n<li><p>上述公式的前提：没有瓶颈操作+没有瓶颈资源</p>\n<ul>\n<li>瓶颈操作：尽管<strong>Redis</strong>执行命令这一任务是I/O密集型，应该将线程池开大点，才能充分利用CPU资源，但是Redis执行命令的过程中，I/O操作才是瓶颈操作，就算开很大的线程池让CPU利用率高达100%，但是命令的执行都会阻塞在I/O操作上，整体的执行效率并不会提高，这是就该关注I/O的利用率，而不是使用更多的线程</li>\n<li>瓶颈资源：任务的执行依赖<strong>数据库</strong>，数据库是通过数据库连接池来管理的，假设数据库连接池的大小是N，当线程数大于N时，数据库连接就成了瓶颈资源，多余的线程需要等待连接池，并不会提高整体的执行效率，此时的连接池中的数据库连接就是瓶颈资源，此时就应该以充分利用瓶颈资源为目标，也就是说，线程池的大小应该设置为跟数据库连接池大小相当才合理</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-线程中断\"><a href=\"#3-线程中断\" class=\"headerlink\" title=\"3.线程中断\"></a>3.线程中断</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>线程执行业务逻辑的过程中，有可能被提前终止，所以需要一些安全的线程终止方式，避免突然中止业务逻辑导致的数据不一致、资源得不到回收等问题</p></blockquote>\n<ol>\n<li><p>基于标志终止线程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private static volatile boolean stopped &#x3D; false;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;&#x2F;&#x2F;t1是长时间运行的程序\n        int count &#x3D; 0;\n        while(!stopped)&#123;&#x2F;&#x2F;t1运行中会检查stopped是否为true\n          System.out.println(count++);\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    stopped &#x3D; true;&#x2F;&#x2F;想终止t1，就将stopped设置为true\n  &#125;\n&#125;</code></pre></li>\n<li><p>基于中断终止线程</p>\n<ul>\n<li><p>基于中断终止线程可以直接使用线程提供的内部中断标志位，不用自己定义，Thread提供了以下3个函数来操作中断标志位</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Thread.java\npublic void interrupt();&#x2F;&#x2F;设置中断标志位\npublic boolean isInterrupted();&#x2F;&#x2F;检查中断标志位是否设置\npublic static boolean interrupted();&#x2F;&#x2F;检查并清除中断标志位</code></pre></li>\n<li><p>示例：思想与基于标志终止线程一样，只不过用了线程的标志位</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread (new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        int count &#x3D; 0;\n        while(!Thread.currentThread().isInterrupted())&#123;\n          System.out.println(count++);\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    t1.interrupt();\n  &#125;\n&#125;\n\n&#x2F;&#x2F;中断并不是强制的，只是发起了中断请求，线程可以无视中断，也可以在中断前进行善后工作，避免数据\n&#x2F;&#x2F;不一致或资源无法回收等问题的发生\npublic class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        int count &#x3D; 0;\n        while(true)&#123;&#x2F;&#x2F;无视中断\n          System.out.println(count++);\n        &#125;\n      &#125;\n    &#125;);\n    t1.start();\n    Thread.sleep(1000);\n    t1.interrupt();&#x2F;&#x2F;发起中断请求\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>基于中断异常终止线程</p>\n<ul>\n<li><p>线程正在执行阻塞函数的时候，比如Thread.sleep()，此时线程无法响应中断请求，也就无法及时终止线程。实际上这些阻塞函数都会在接收到中断请求的时候，停止执行并抛出InterruptedException中断异常，可以基于中断异常来终止线程，示例如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;\n      @Override\n      public void run()&#123;\n        int count &#x3D; 0;\n        while(!Thread.currentThread().isInterrupted())&#123;\n          System.out.println(count++);\n          try&#123;\n            Thread.sleep(10000);&#x2F;&#x2F;10s\n          &#125;catch (InterruptedException e)&#123;&#x2F;&#x2F;sleep的过程中响应中断请求，并抛出异常\n            &#x2F;&#x2F;因为大部分阻塞函数在抛出InterruptedException前，会调用interrupted函数清除\n            &#x2F;&#x2F;中断标志位，所以需要下面这条语句重新设置线程的中断标志位，也可以直接return\n            Thread.currentThread().interrupted();\n          &#125;\n        &#125;&#x2F;&#x2F;while\n      &#125;&#x2F;&#x2F;run\n    &#125;);\n    t1.start();\n    Thread.sleep(2000);\n    t1.interrupt();\n  &#125;\n&#125;</code></pre></li>\n<li><p>Java中断 VS OS中断：Java中断完全由Java语言来实现，并不依赖OS中断。Java中断用来中断线程，OS中断用来中断CPU，每当一个CPU周期结束，就会查看中断寄存器是否有中断请求，如果有，则在事先设置好的中断向量表找到对应的中断处理函数入口地址，然后跳转执行中断处理程序。一般来说，常用的OS中断有I/O中断、时钟中断、异常、系统调用中断等</p>\n</li>\n<li><p>其他可支持中断的阻塞函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Lock 接口\nvoid lock();&#x2F;&#x2F;不可中断\nvoid lockInterrutibly() throws InterruptedException;&#x2F;&#x2F;可中断\n&#x2F;&#x2F;Condition 类\nvoid await() throws InterruptedException;&#x2F;&#x2F;可中断\nvoid awaitUninterruptiblu();&#x2F;&#x2F;不可中断\n&#x2F;&#x2F;Semaphore 类\npublic void acquire() throws InterruptedException;&#x2F;&#x2F;可中断\npublic void acquireUninterruptibly();&#x2F;&#x2F;不可中断</code></pre>\n\n<ul>\n<li><p>lock的实现原理：不可中断</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;ReentrantLock.java\nstatic final class FairSync extends Sync &#123;\n  final void lock() &#123;\n    acquire(1);\n  &#125;\n&#125;\n&#x2F;&#x2F;AbstractQueuedSynchronizer.java\npublic final void acquire(int arg) &#123;\n  &#x2F;&#x2F;tryAcquire尝试竞争获取锁，如果获取失败，则执行acquireQueued函数排队等待\n  if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n    &#x2F;&#x2F;acquireQueued返回true表示收到了中断请求，在内部清除了中断标志位，所以需要重设标志位\n    selfInterrupt();&#x2F;&#x2F;内部执行Thread.currentThread().interrupt();重设中断标志位\n&#125;\nfinal boolean acquireQueued(final Node node, int arg) &#123;\n  boolean failed &#x3D; true;\n  try &#123;\n    boolean interrupted &#x3D; false;\n    for (;;) &#123;\n      final Node p &#x3D; node.predecessor();&#x2F;&#x2F;返回前一个节点\n      if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;&#x2F;&#x2F;前节点是头节点，特殊处理\n        setHead(node);\n        p.next &#x3D; null; &#x2F;&#x2F; help GC\n        failed &#x3D; false;\n        return interrupted;&#x2F;&#x2F;返回是否被中断过\n      &#125;&#x2F;&#x2F;if\n\t\t\t&#x2F;&#x2F;parkAndCheckInterrupt被中断并返回true，for循环再次执行\n      &#x2F;&#x2F;parkAndCheckInterrupt，所以中断请求不会终止acquireQueued\n      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())\n        interrupted &#x3D; true;\n    &#125;&#x2F;&#x2F;for\n  &#125; finally &#123;\n    if (failed)\n      cancelAcquire(node);\n  &#125;\n&#125;\n&#x2F;&#x2F;返回的情况一：被其他线程唤醒（调用AQS中的release函数）\n&#x2F;&#x2F;返回的情况二：被其他线程中断（调用interrupt函数），返回true\nprivate final boolean parkAndCheckInterrupt() &#123;\n  LockSupport.park(this);&#x2F;&#x2F;底层调用Unsafe.park\n  return Thread.interrupted();&#x2F;&#x2F;检查并清除中断设置\n&#125;\n&#x2F;&#x2F;LockSupport.java\npublic static void park(Object blocker) &#123;\n  Thread t &#x3D; Thread.currentThread();\n  setBlocker(t, blocker);\n  &#x2F;&#x2F;Linux下，底层采用pthread_cond_wait()条件变量来实现，其中不包括中断标志位的检测逻辑\n  &#x2F;&#x2F;当另一个线程调用interrupt设置中断标志位之后，\n  UNSAFE.park(false, 0L);\n  setBlocker(t, null);\n&#125;</code></pre></li>\n<li><p>lockInterrutibly的实现原理：可中断</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;ReentrantLock.java\npublic void lockInterruptibly() throws InterruptedException &#123;\n  sync.acquireInterruptibly(1);\n&#125;\n&#x2F;&#x2F;AbstractQueuedSynchronizer.java\npublic final void acquireInterruptibly(int arg) throws InterruptedException &#123;\n  &#x2F;&#x2F;收到中断请求之后，会终止函数并抛出InterruptedException\n  if (Thread.interrupted()) throw new InterruptedException();\n  if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n&#125;\n&#x2F;&#x2F;\nprivate void doAcquireInterruptibly(int arg) throws InterruptedException &#123;\n  final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n  boolean failed &#x3D; true;\n  try &#123;\n    for (;;) &#123;\n      final Node p &#x3D; node.predecessor();\n      if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n        setHead(node);\n        p.next &#x3D; null; &#x2F;&#x2F; help GC\n        failed &#x3D; false;\n        return;\n      &#125;\n      if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())\n        &#x2F;&#x2F;parkAndCheckInterrupt因中断返回时，会直接抛出异常\n        throw new InterruptedException();\n    &#125;\n  &#125; finally &#123;\n    if (failed)\n      cancelAcquire(node);\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h2><h3 id=\"1-编译执行\"><a href=\"#1-编译执行\" class=\"headerlink\" title=\"1.编译执行\"></a>1.编译执行</h3><h4 id=\"1-编译链接\"><a href=\"#1-编译链接\" class=\"headerlink\" title=\"1.编译链接\"></a>1.编译链接</h4><ol>\n<li><p>编译执行流程：Java的编译执行的整个过程包括前端编译、类加载、解释执行、JIT编译执行</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220919082822636.png\" alt=\"image-20220919082822636\"></p>\n</li>\n<li><p>前端编译</p>\n<ul>\n<li><p>将.java文件编译成.class文件（字节码）的过程，由javac编译器来完成，通过词法分析、语法分析、语义分析等方法将源代码翻译成字节码（编译型语言翻译结果为机器码），并且还包裹特有的注解处理、解语法糖操作</p>\n</li>\n<li><p>注解处理：从JDK6开始，可以根据JSR269规范来开发注解插件（包含定义注解、使用注解、对应的注解处理器），在前端编译时会调用注解插件来执行相应的注解处理器代码。例如Lombok插件的注解处理器根据@getter、@setter等注解为类的变量生成getter、setter方法，由于是SOURCE级别的注解，所以只作用于编译之前</p>\n</li>\n<li><p>解语法糖：在一开始Java更注重开发效率，这就导致Java更适合做业务系统开发，C/C++更适合底层的系统级开发。Java为了提高开发效率，提供了很多与法糖，即对基本语法的二次封装，主要为了提高易用性，例如泛型、自动装箱拆箱、for-each遍历、内部类等，在做前端编译的时候，会还原为基本语法，也就是说字节码不包含语法糖、JVM也不会感知到语法糖，语法糖仅存在于源码中</p>\n<ul>\n<li><p>泛型：编译时会进行类型擦除，泛型只用于编译时的类型检查，字节码中不存在，所以称为伪泛型</p>\n</li>\n<li><p>自动拆装箱：方便基本类型和包装类的互相转换</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer iobj &#x3D; 12; &#x2F;&#x2F;底层实现为Integer iobj &#x3D; Integer.valueOf(12);\nint i &#x3D; iobj; &#x2F;&#x2F;底层实现为：int i &#x3D; iobj.intValue();</code></pre></li>\n<li><p>for-each循环</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; arr &#x3D; Arrays.asList(&quot;chen&quot;, &quot;zi&quot;, &quot;jun&quot;);\nfor(String s : arr)&#123;\n  System.out.println(s);\n&#125;\nIterator&lt;String&gt; itr &#x3D; arr.iterator();&#x2F;&#x2F;增强for循环底层依赖迭代器遍历\nwhile(itr.hasNext())&#123;\n  System.out.println(itr.next());\n&#125;</code></pre></li>\n<li><p>内部类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class A&#123;&#x2F;&#x2F;A.class\n  public class B&#123;&#125;&#x2F;&#x2F;内部类，编译为A$B.class\n  public void f()&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;&#x2F;&#x2F;匿名内部类，编译为A$1.class\n      @Override\n      public void run()&#123;\n        System.out.println(&quot;anonymous inner class.&quot;);\n      &#125;\n    &#125;);\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类加载</p>\n<ul>\n<li><p>在Java应用程序中，类的字节码是按需加载到内存中的，当第一次创建某个类的对象，或调用某个类的方法时，这个类就会被加载到内存中，之后便一直保存在内存中。类加载过程包括验证、准备、解析、初始化等步骤，类的加载遵从双亲委派机制，不同的类由不同的classLoader加载器来加载</p>\n</li>\n<li><p>字节码格式示例</p>\n<ul>\n<li><p>代码，Demo.java</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  private String greeting &#x3D; &quot;hello&quot;;\n  public String greet(String name)&#123;\n    return greeting;\n  &#125;\n&#125;</code></pre></li>\n<li><p>经过javac编译器编程为Demo.class文件，再用javap工具反编译，示例如下。常量池中的符号引用包括这个类所涉及到的类、接口、方法、成员变量的名称和描述符，当执行代码时，虚拟机根据符号引用找到所引用的类、接口、方法等信息，查找对应的内存存储地址，然后再调整执行</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220919090709087.png\" alt=\"image-20220919090709087\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>解释执行</p>\n<ul>\n<li><p>对于C/C++，代码会被事先编译出机器指令（可执行文件），然后再交由CPU来执行；对于Java来说，编译出的.class文件，需要由JVM逐条取出，边解释为机器码，边交由CPU执行</p>\n</li>\n<li><p>示例：虚拟机从main开始执行，执行Demo类对象的创建语句时，虚拟机发现内存中没有Demo类的字节码信息，于是通过类加载器在classpath对应的路径下查找Demo.class文件，并将其加载到内存中。之后虚拟机根据类的字节码在堆中创建demo对象，当虚拟机执行demo.greet(“hello”);时，虚拟机根据对象demo中的类指针，找到内存中的Demo类，然后在类的方法中查找greet函数对应的字节码，最后逐句解释执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class App&#123;\n  public static void main(String[] args)&#123;\n    Demo demo &#x3D; new Demo();\n    demo.greet(&quot;hello&quot;);\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>JIT编译执行</p>\n<ul>\n<li>解释执行需要在执行的过程中，将字节码解释为机器码，再交由CPU执行，边解释边执行，效率比C/C++低，因此引入了JIT（Just-In-Time）编译执行，也称即时编译或运行时编译</li>\n<li>对于一些经常运行的热点代码，可以将其编译为机器码并存储下来，不需要边解释边执行，而且可以利用运行信息做优化</li>\n<li>AOT（Ahead Of Time Compile）编译，运行前编译，类似于C/C++的编译，但是仍支持一次编写，到处运行的特点，代码的可移植性由AOT编译器来负责，而C/C++代码的可移植性完全由程序员来运行</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-JIT编译\"><a href=\"#2-JIT编译\" class=\"headerlink\" title=\"2.JIT编译\"></a>2.JIT编译</h4><ol>\n<li>JIT编译器<ul>\n<li>HotSpot虚拟机支持两种JIT编译器，区别在于编译时间和编译优化程度<ul>\n<li>Client编译器（C1编译器）：只进行局部的编译优化，编译时间短，编译优化程度低</li>\n<li>Server编译器（C2编译器）：进行局部和全局优化，编译时间长，编译优化程度高</li>\n</ul>\n</li>\n<li>JVM有两种运行模式，Client模式和Server模式，这两种模式就是基于JIT编译器类型来区分的，所以对于长时间运行的服务器程序，可以使用Server模式牺牲一些编译时间，生成一些高效的机器码</li>\n</ul>\n</li>\n<li>分层编译<ul>\n<li>在Java7之前，两种JIT编译器只能通过参数二选一，但是Java7引入了分层编译的技术，对编译类型做了更加细化的区分，虚拟机可以根据代码、实际运行情况，选择不同的编译类型，更有针对性</li>\n<li>分层编译有5个层级：解释执行、使用不带编译优化的Clinet编译器、使用仅带部分编译优化的Client编译器、使用带有所有编译优化的Client编译器、使用Server编译器</li>\n<li>分层编译在Java8中稳定成熟，所以JVM默认开启分层编译技术，当分层编译技术关闭时，JVM直接选择使用Server编译器</li>\n</ul>\n</li>\n<li>热点探测<ul>\n<li>热点代码：主要包括被多次执行的方法和被多次执行的循环，JIT编译的对象是方法，对循环的编译是编译循环所在的整个方法</li>\n<li>计数器：HotSpot虚拟机使用计数器来统计方法或循环的执行次数，以此来判断方法或循环是否是热点代码。JVM对每个方法维护两个计数器，方法调用计数器和回边计数器，前者用来统计方法的执行次数，后者用来统计方法内循环的执行次数</li>\n<li>阈值：当某个方法的方法调用计数器的值和回边计数器的值的总和超过某个阈值时，虚拟机就会对方法进行JIT编译。Client编译器下阈值是1500，Server编译器下是10000，可以通过参数更改。但是开启分层编译后，会使用动态阈值，根据当前编译方法数以及编译线程数动态计算得到</li>\n<li>热度衰减机制：防止因为运行时间长而超过阈值的代码被判定为成热点代码，此机制（通过-XX:-UseCounterDecay开关）在超过一定的时间（通过-XX:CounterHalfLifeTIme设置）限制之后，如果某个方法没有达到触发JIT编译的阈值要求，那么这个方法的方法计数器的值就减半，回边计数器不存在此机制</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-编译优化\"><a href=\"#3-编译优化\" class=\"headerlink\" title=\"3.编译优化\"></a>3.编译优化</h4><ul>\n<li>编译优化：在编译代码时，对代码进行优化，减少无效、冗余代码，以便生成更加高效的机器码，在一定程度上，编译优化的质量决定了编译器是否优秀，编程语言是否高效</li>\n<li>JIT编译优化策略：方法内联、逃逸分析、无用代码消除、循环展开、消除公共子表达式、范围检查消除、空值检查消除<a href=\"https://wiki.openjdk.org/display/HotSpot/PerformanceTacticIndex\">等</a><ul>\n<li>方法内联<ul>\n<li>函数调用会涉及栈帧的压栈、出栈、现场的保存和恢复，很耗时，为了提高效率，将短小的函数（getter、setter）嵌入到函数调用处，通过内存的增加减少时间的消耗，并可以进行进一步的优化</li>\n<li>内联的要求：函数短小（字节码小于325字节）+调用次数达到阈值（大于等于100次）、或者字节码小于35字节+方法调用次数少于100次</li>\n<li>final：将方法设置为final会有助于触发方法内联，特别是多态的情况下，因为final声明的函数不会被重载，所以可以直接通过类的方法来内联，而不用分析是否有重载变化函数的情况</li>\n</ul>\n</li>\n<li>逃逸分析<ul>\n<li>JIT编译器通过分析对象的使用范围来优化对象的内存存储方式和访问方式，针对不同的逃逸分析结果，有3种不同的优化策略：栈上分配、标量替换、锁消除<ul>\n<li>栈上分配：编译器分析完，发现某个对象使用范围仅限于某个函数内部（没有逃逸到方法外），就可以启动栈上分配编译优化，将对象作为局部变量直接分配在栈上</li>\n<li>标量替换：如果某个对象只在某个函数内使用，并且函数内只访问对象的基本类型成员变量等标量数据，就可以使用基本类型变量替代对象</li>\n<li>锁消除：对不存在多线程并发访问的代码（逃逸到线程外），编译器会去掉其中保证线程安全的加锁逻辑</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-类加载器\"><a href=\"#2-类加载器\" class=\"headerlink\" title=\"2.类加载器\"></a>2.类加载器</h3><h4 id=\"1-类加载\"><a href=\"#1-类加载\" class=\"headerlink\" title=\"1.类加载\"></a>1.类加载</h4><ol>\n<li><p>类加载过程：虚拟机将类的二进制字节码加载到内存中，以便创建类的对象或者执行类上的方法</p>\n<ul>\n<li><strong>验证：</strong>验证所加载的类字节码格式是否符合JVM规范，因为类字节码来源包括javac编译工具编译、网络的类字节码、通过字节码生成工具生成的类字节码，所以不可控的来源是的类字节码可能被恶意篡改，因此需要合法性的校验</li>\n<li><strong>准备：</strong>虚拟机为类的静态变量分配内存，并初始化为默认值。对于static final修饰的静态常量，直接初始化指定值；对于只有static修饰的变量，初始化为默认值而不是代码指定值，指定值会在下面的初始化阶段赋予</li>\n<li><strong>解析：</strong>解析类似C++中的链接，把类字节码的常量池中的符号引用（间接引用）转换为直接引用。常量池存储了所涉及的类、方法、变量等描述符，这一步就是将描述符转化为可以直接访问的内存存储地址（直接引用）</li>\n<li><strong>初始化：</strong>虚拟机执行静态变量的初始化代码，包括初始化语句（<code>private static int a = 25;</code>）、静态代码块（<code>static &#123; a = 13; &#125;</code>）</li>\n</ul>\n</li>\n<li><p>类加载机制</p>\n<ul>\n<li><p>类加载器：类加载由类加载器来完成，虚拟机定义了几种不同类型的类加载器：</p>\n<ul>\n<li>启动类加载器（BootStrap ClassLoader）：负责加载$JAVA_HOME/jre/lib/rt.jar包中的类</li>\n<li>扩展类加载器（Extension ClassLoader）：负责加载$JAVA_HOME/jre/lib/ext目录下的jar包中的类</li>\n<li>应用程序类加载器（Application ClassLoader）：负责加载classpath所指定路径下的其余类</li>\n</ul>\n</li>\n<li><p>双亲委派机制</p>\n<ul>\n<li><p>尽管每个加载器负责的路径是明确的，但是当虚拟机无法根据全限定名（如java.lang.StringUtils）找到路径和对应的类加载器时，虚拟机需要通过在各个类加载器所负责的路径下查找这个类，当有重复的时候，需要机制来确定加载哪一个类，所以虚拟机设计了双亲委派机制</p>\n</li>\n<li><p>双亲委派机制定义了类加载器之间的父子关系，如下图所示</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220925144257905.png\" alt=\"image-20220925144257905\" style=\"zoom:50%;\" /></li>\n<li><p>类加载器父子关系示例代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import sun.applet.AppletClassLoader;\n\npublic class Demo01 &#123;\n  &#x2F;&#x2F;默认父类加载器为AppClassLoader\n  public static class ClassLoaderA extends ClassLoader &#123;\n  &#125;\n\n  &#x2F;&#x2F;通过构造函数指定父类加载器\n  public static class ClassLoaderB extends ClassLoader &#123;\n    public ClassLoaderB(ClassLoader parent) &#123;\n      super(parent);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F;ClassLoaderB的父类加载器为ClassloaderA\n  &#x2F;&#x2F;ClassLoaderA的父类加载器为AppClassloader\n  &#x2F;&#x2F;AppClassLoader的父类加载器为ExtClassLoader\n  &#x2F;&#x2F;ExtClassLoader的父类加载器为null,实际为BootrapClassLoader\n  &#x2F;&#x2F;由于其由C++代码实现，因此无法在打印结果中显示。\n  public static void main(String[] args) &#123;\n    ClassLoaderA loaderA &#x3D; new ClassLoaderA();\n    ClassLoaderB loaderB &#x3D; new ClassLoaderB(loaderA);\n\n    &#x2F;&#x2F;Demo01$ClassLoaderA@4aa298b7\n    System.out.println(loaderA);\n    &#x2F;&#x2F;Demo01$ClassLoaderB@7d4991ad\n    System.out.println(loaderB);\n    &#x2F;&#x2F;Demo01$ClassLoaderA@4aa298b7\n    System.out.println(loaderB.getParent());\n    &#x2F;&#x2F;sun.misc.Launcher$AppClassLoader@18b4aac2\n    System.out.println(loaderB.getParent().getParent());\n    &#x2F;&#x2F;sun.misc.Launcher$ExtClassLoader@28d93b30\n    System.out.println(loaderB.getParent().getParent().getParent());\n    &#x2F;&#x2F;null\n    System.out.println(\n      loaderB.getParent().getParent().getParent().getParent());\n  &#125;\n&#125;</code></pre></li>\n<li><p>在某个类加载器接收到某个类的加载请求时（使用new或反射创建类的对象时，默认为请求应用程序类加载器加载对应的类），如果这个类加载器之前没有加载过这个类，那么他便委托父类加载器加载这个类，如果父类没有加载过则继续向上委托直到有类加载器加载了这个类，如果达到最顶层父类加载器还没有的话，就从上往下请求各个类加载器在自己负责的路径下查找并加载这个类</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220925151358397.png\" alt=\"image-20220925151358397\"></p>\n</li>\n<li><p>双亲委派机制可以有效防止对核心类的恶意修改，比如在自己的路径下定义一个新的java.util.String类，请求应用程序类加载器来加载，意图覆盖核心类库中的String类，但是，基于双亲委派机制，应用程序类加载器会委托父类加载器来加载java.util.String类，最终仍然会由启动类加载器加载核心类库中的String类</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>自定义类加载器</p>\n<ul>\n<li><p>默认通过应用程序加载器加载类，但是某些特殊的类在加载的过程中需要特殊处理，无法将特殊处理逻辑插入到应用程序类加载器中，这个时候就需要自定义类加载器，将特殊处理逻辑插入到自定义类加载器中，通过调用自定义类加载器上的loadClass函数来加载这个类，达到对这个类特殊加载的目的</p>\n</li>\n<li><p>自定义类加载器：定义继承自ClassLoader类的子类，并重写其中的findClass函数，其定义如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n  throw new ClassNotFoundException(name);\n&#125;</code></pre></li>\n<li><p>ClassLoader是一个模版方法模式类，其中的loadClass函数是模版方法，里面包含类加载的整个逻辑，比如双亲委派机制的实现逻辑，findClass函数为模版方法模式中的抽象方法，被loadClass函数使用，用来根据类名查找类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)\n  throws ClassNotFoundException\n&#123;\n  synchronized (getClassLoadingLock(name)) &#123;\n    &#x2F;&#x2F; First, check if the class has already been loaded\n    Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n    if (c &#x3D;&#x3D; null) &#123;\n      long t0 &#x3D; System.nanoTime();\n      try &#123;\n        if (parent !&#x3D; null) &#123;\n          c &#x3D; parent.loadClass(name, false);\n        &#125; else &#123;\n          c &#x3D; findBootstrapClassOrNull(name);\n        &#125;\n      &#125; catch (ClassNotFoundException e) &#123;\n        &#x2F;&#x2F; ClassNotFoundException thrown if class not found\n        &#x2F;&#x2F; from the non-null parent class loader\n      &#125;\n\n      if (c &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; If still not found, then invoke findClass in order\n        &#x2F;&#x2F; to find the class.\n        long t1 &#x3D; System.nanoTime();\n        c &#x3D; findClass(name);\n\n        &#x2F;&#x2F; this is the defining class loader; record the stats\n        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n        sun.misc.PerfCounter.getFindClasses().increment();\n      &#125;\n    &#125;\n    if (resolve) &#123;\n      resolveClass(c);\n    &#125;\n    return c;\n  &#125;\n&#125;</code></pre></li>\n<li><p>默认情况下自定义类加载器的父类为应用程序类加载器，可以在构造函数中指定自定义类加载器的父类加载器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;默认父类加载器为AppClassLoader\npublic static class ClassLoaderA extends ClassLoader&#123;\n  @Override\n  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n&#x2F;&#x2F;通过构造函数指定父类加载器\npublic static class ClassLoaderB extends ClassLoader&#123;\n  public ClassLoaderB(ClassLoader parent)&#123;\n    super(parent);\n  &#125;\n  @Override\n  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;</code></pre></li>\n<li><p>自定义类加载器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;从文件系统的绝对路径下读取类的二进制字节码，通过调用CLassLoader的defineClass函数将二进制的\n&#x2F;&#x2F;字节码转化成Class对象，以此来实现一个加载特定路径下的类的加载器\npublic class FileSystemClassLoader extends ClassLoader&#123;\n  private String rootDir;\n  public FileSystemClassLoader(String rootDir)&#123;\n    this.rootDir &#x3D; rootDir;\n  &#125;\n  @Override\n  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n    String path &#x3D; rootDir + File.separatorChar + \n      name.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;\n    byte[] bytecode &#x3D; null;\n    try(InputStream input &#x3D; new FileInputStream(path))&#123;\n      ByteArrayOutputStream byteStream &#x3D; new ByteArrayOutputStream();\n      byte[] buffer &#x3D; new byte[4096];\n      int readSize &#x3D; 0;\n      while((readSize &#x3D; input.read(buffer)) !&#x3D; -1)&#123;\n        byteStream.write(buffer, 0, readSize);\n      &#125;\n      bytecode &#x3D; byteStream.toByteArray();\n    &#125;catch(FileNotFoundException | IOException e)&#123;\n      e.printStackTrace();\n    &#125;\n    if(bytecode &#x3D;&#x3D; null)&#123;\n      throw new ClassNotFoundException(&quot;class name:&quot; + name);\n    &#125;else&#123;\n      return defineClass(name, bytecode, 0, bytecode.length);\n    &#125;\n  &#125;\n&#125;\npublic class Demo&#123;\n  public static void main(Stringp[] args) throws ClassNotFoundException&#123;\n    ClassLoader classLoader &#x3D; new FileSystemClassLoader(&quot;&#x2F;Users&#x2F;dajunnnnnn&quot;);\n    Class&lt;?&gt; clazz &#x3D; classLoader.loadCLass(&quot;com.code.hello&quot;);\n    System.out.println(clazz.getClassLoader());&#x2F;&#x2F;打印SystemFileClassLoader对象信息\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-双亲委派机制\"><a href=\"#2-双亲委派机制\" class=\"headerlink\" title=\"2.双亲委派机制\"></a>2.双亲委派机制</h4><h3 id=\"3-内存分区\"><a href=\"#3-内存分区\" class=\"headerlink\" title=\"3.内存分区\"></a>3.内存分区</h3><h4 id=\"1-内存分区\"><a href=\"#1-内存分区\" class=\"headerlink\" title=\"1.内存分区\"></a>1.内存分区</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>编译执行的结果会放在内存中，其中包括代码和数据，为了区分存储和管理不同的内容，所以JVM将内存划分为不同的分区，包括方法区、程序计数器、堆、虚拟机栈、本地方法栈</p></blockquote>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220929082915337.png\" alt=\"image-20220929082915337\"></p>\n<ol>\n<li>方法区<ul>\n<li>存储的主要内容<ul>\n<li>类信息：类的权限定名和修饰符（访问标志 public、static、final等），父类、接口列表等相关信息</li>\n<li>方法信息：方法的名称和修饰符（入参、返回值、访问标志等），方法的字节码</li>\n<li>静态变量：静态变量隶属于类，因此存储在方法区而非堆上</li>\n<li>运行时常量池：此分区对应类字节码中的常量池，存储字面量和符号引用</li>\n<li>字符串常量池：此分区专门服务于字符串，避免String对象的重复创建，减少内存开销</li>\n<li>JIT编译代码缓存：此分区存储的是JIT编译之后的机器码</li>\n</ul>\n</li>\n<li>方法区是一种抽象分区，不同JVM可以有不同的实现方式。以HotSpot为例，在Java7之前的版本，实现为永久代（Permanent Generation）；Java7中，方法区的字符串常量池和静态变量从永久代中移除，放入堆中；Java7之后，永久带被元空间（MetaSpace）取代，但字符串常量池和静态变量仍存储在堆中</li>\n</ul>\n</li>\n<li>程序计数器<ul>\n<li>虚拟机相当于一个抽象的计算机，也有自己的指令集（字节码集），因此也需要一个存储单元（程序计数器）用来存储下一条要执行的字节码的地址</li>\n<li>与PC寄存器不同的地方在于：PC寄存器是线程共享的，PC寄存器会随着线程的切换而进行保存和恢复，程序计数器是线程私有的，每个线程都会分配一个独立的程序计数器，记录当前线程执行到哪一行字节码。原因在于PC寄存器位于CPU，是稀缺资源；而程序计数器位于内存，资源相对富裕，线程独享能减少线程上下文切换的信息量，有利于提高线程切换的速度</li>\n</ul>\n</li>\n<li>堆（见垃圾回收器）<ul>\n<li>用来存储Java对象，在Java中对象的回收是有虚拟机中的垃圾收集器自动完成的，堆是垃圾收集器的主要工作分区，为了配合垃圾收集器算法，堆有以下划分<ul>\n<li>年轻代（Young Generation）：<ul>\n<li>Eden区</li>\n<li>Survivor区：From Survivor区、To Survivor区</li>\n</ul>\n</li>\n<li>老年代（Old Generation）：</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>虚拟机栈（见下一节）：函数调用中，主要用栈存储函数的局部变量、参数、返回地址等信息。栈是线程私有的，每个线程会有一个栈，因此也叫线程栈。Java中的栈叫做虚拟机栈</li>\n<li>本地方法栈<ul>\n<li>Java提供了很多使用C/C++语言实现的native方法，很多Java函数最终是通过调用native方法来实现的。在JVM规范中，Java将服务于Java方法调用的栈，跟服务于native方法调用的栈做了区分，服务于Java方法调用的栈称为虚拟机栈，服务于native方法调用的栈称为本地方法栈。两个栈的功能相同，在具体的虚拟机实现中，如HotSpot中，把两栈合并为一个栈，同时存储Java方法调用的栈帧和native方法调用的栈帧</li>\n<li>默认线程栈的大小：不同平台下有区别，HotSpot默认的每个线程的栈大小为1MB（可更改），JVM可创建的线程个数由进程可用内存大小（计算机可用内存）除以线程栈大小决定，如果不够可以减小线程栈大小来支持创建更多的线程，如果因为函数调用深度太深导致栈溢出，可以通过增大线程栈大小来避免溢出</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-栈内存\"><a href=\"#2-栈内存\" class=\"headerlink\" title=\"2.栈内存\"></a>2.栈内存</h4><h4 id=\"3-堆内存\"><a href=\"#3-堆内存\" class=\"headerlink\" title=\"3.堆内存\"></a>3.堆内存</h4><h3 id=\"4-垃圾回收\"><a href=\"#4-垃圾回收\" class=\"headerlink\" title=\"4.垃圾回收\"></a>4.垃圾回收</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>不同于C++中需要显示地调用delete语句进行内存释放，Java中由JVM负责自动回收（垃圾回收），既提高了开发效率又避免了内存泄漏的问题</p></blockquote>\n<h4 id=\"1-可达性分析\"><a href=\"#1-可达性分析\" class=\"headerlink\" title=\"1.可达性分析\"></a>1.可达性分析</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>虚拟机在进行垃圾回收时，首先要判读哪些对象可以被回收，常用的判断算法为可达性分析。其中还会涉及到STW、安全点、安全区等知识</p></blockquote>\n<ol>\n<li><p>引用计数</p>\n<ul>\n<li><p>是同可达性分析类似的另一种用来判断对象是否可以被回收的算法，但是因为存在问题不被虚拟机采用</p>\n</li>\n<li><p>在Java中通过引用来表示变量和对象之间的关系，将对象赋值给变量就表示变量引用对象，有多少个变量引用某个对象，此对象的引用计数就是几，并随着变量而增减，知道引用计数为0，该对象被虚拟机当作垃圾回收</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void f()&#123;\n  Object a &#x3D; new Object();&#x2F;&#x2F;对象的引用计数为1\n  g(a);&#x2F;&#x2F;1\n  &#x2F;&#x2F;g(a)退出后，变量b的生命周期结束，对象的引用计数变为1\n&#125;&#x2F;&#x2F;f()函数结束，变量a的声明周期结束，对象的引用计数变为0，可以被垃圾回收\npublic void g(Object a)&#123;\n  Object b &#x3D; a;&#x2F;&#x2F;2\n  Object c &#x3D; a;&#x2F;&#x2F;3\n  Object d &#x3D; a;&#x2F;&#x2F;4\n  d &#x3D; new Object();&#x2F;&#x2F;3\n  c &#x3D; null;&#x2F;&#x2F;2\n&#125;</code></pre></li>\n<li><p>问题：无法检测循环依赖，如两个对象互相引用，尽管都已经被设置为null，但是引用计数并不为0，仍然无法被回收</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Wife hanmeimei &#x3D; new Wife(&quot;Hanmeimei&quot;);&#x2F;&#x2F;Wife对象的引用计数为1\nHusband lilei &#x3D; new Husband(&quot;Lilei&quot;);&#x2F;&#x2F;Husband对象的引用计数为1\nhanmeimei.husband &#x3D; lilei;&#x2F;&#x2F;Husband对象的引用计数为2\nlilei.wife &#x3D; hanmeimei;&#x2F;&#x2F;Wife对象的引用计数为2\nhanmeimei &#x3D; null;&#x2F;&#x2F;Wife对象的引用计数为1\nlilei &#x3D; null;&#x2F;&#x2F;Husband对象的引用计数为1\n&#x2F;&#x2F;剩下一个循环引用，应该被删除</code></pre></li>\n</ul>\n</li>\n<li><p>可达性分析</p>\n<ul>\n<li><p>把对象之间的引用关系用数据结构中的有向图来表示，图中的顶点表示对象，通过有向边表示变量对对象的引用。</p>\n</li>\n<li><p>在有向图中，由一组特殊的顶点叫做GC Roots，GC Roots为堆外变量所直接引用的堆内对象，包括虚拟机栈、本地方法栈中的局部变量所直接引用的对象、方法区中静态变量所直接引用的对象等</p>\n</li>\n<li><p>虚拟机以GC Roots为起点，遍历（DFS或BFS）整个图，可以遍历到的对象为可达对象，也叫做存活对象，遍历不到的对象为不可达对象，也叫做死亡对象，死亡对象会被虚拟机当作垃圾回收</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221008160458011.png\" alt=\"image-20221008160458011\"></p>\n</li>\n</ul>\n</li>\n<li><p>STW（见垃圾回收器）</p>\n<ul>\n<li>运行在虚拟机上的应用程序启动的线程叫做用户线程，执行垃圾回收的线程叫做垃圾回收线程。由于线程之间的并行性，垃圾回收线程执行垃圾回收时，对象可能被用户线程更改，导致可达性分析结果存在误报和漏报的情况（只针对存活对象）</li>\n<li>误报：将非存活对象误报为存货对象。导致本该被垃圾回收的对象没有被回收，只需等待再次垃圾回收</li>\n<li>漏报：漏报存活对象，从而将其判定为死亡对象。会产生严重的问题，导致本不该被回收的对象被回收，从而导致程序出错，解决此问题最简单的方法就是STW（Stop The World），即停止所有用户线程的执行，知道垃圾回收结束，因此会影响程序性能。因此优化垃圾回收过程，尽量减少STW的时间，是各个垃圾回收器努力的重点</li>\n</ul>\n</li>\n<li><p>安全点</p>\n<ul>\n<li><p>GC Roots的获得方式：遍历栈中的局部变量和方法区中的静态变量，找出引用类型变量，然后，再将引用类型变量所引用的对象放入GC Roots中</p>\n</li>\n<li><p>每次更新垃圾回收都要遍历栈和方法区来查找GC Roots，效率非常低。所以，虚拟机使用OopMap来存储当前的GC Roots并动态更新。</p>\n<ul>\n<li><p>具体做法为：虚拟机先遍历查找一次GC Roots并初始化OopMap，然后在代码的执行过程中，如果有变量更新所引用的对象，那么虚拟机就同步更新OopMap，当虚拟机需要进行垃圾回收时，OopMap中存储的便是当前的GC Roots</p>\n</li>\n<li><p>对于解释执行来说，上述做法可行，但是对于JIT编译执行来说，上述做法无法实现，因为JIT编译之后的机器码直接交由CPU执行，并不经虚拟机之手，虚拟机无法边执行指令边分析然后再动态更新OopMap，虚拟机需要在字节码编译为机器码时，静态地分析指令，为每一条指令存储此指令执行结束后对应的OopMap，这显然会浪费内存空间</p>\n</li>\n<li><p>安全点：为了节约空间，虚拟机采用了时间换空间的策略，将为每个指令存储一个OopMap，改为只选取部分指令存储OopMap。这些被选取的指令称为安全点，当虚拟机启动垃圾回收并需要STW时，会向用户线程发送暂停的中断请求，此时，用户线程并不能立刻停止，而是需要运行到安全点之后才能停止，因为只有安全点处才记录了OopMap，只有所有线程都运行到安全点之后，虚拟机才能得到完整的GC Roots</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221008163405061.png\" alt=\"image-20221008163405061\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全区</p>\n<ul>\n<li>大部分情况，用户线程在接收到暂停的中断请求之后，都可以在较短的时间内达到最近的安全点，但是在少数情况下，如果用户线程处于阻塞状态（如等待I/O读写就绪），就无法在较短的时间内达到最近的安全点，为了解决这个问题，虚拟机引入了一个新的概念：安全区，即不会改变对象引用关系的一段连续的代码区间</li>\n<li>当虚拟机执行垃圾回收并发起STW请求时，如果某个线程处于安全区，那么，这个线程并不需要停止执行，而是可以跟垃圾回收线程并行执行。但是，当用户线程离开安全区时，他需要检查虚拟机是否处于STW状态，如果是，用户线程需要阻塞等待STW结束，才能继续往下执行，以免用户线程跳出安全区之后，执行非安全代码导致对象引用关系的改变</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-垃圾回收算法\"><a href=\"#2-垃圾回收算法\" class=\"headerlink\" title=\"2.垃圾回收算法\"></a>2.垃圾回收算法</h4><ol>\n<li><p>概述：垃圾回收算法用于回收死亡对象，分代垃圾回收算法是主流的垃圾回收算法，虚拟机将堆空间分为年轻代和老年代，针对不同的分代单独进行垃圾回收，针对年轻代的垃圾回收叫做YoundGC、针对老年代的垃圾回收叫做FullGC，FullGC比YoungGC慢很多，原因见下</p>\n</li>\n<li><p>基础垃圾回收算法（标记使用可达性分析找出需要被回收的死亡对象）</p>\n<ul>\n<li><p>标记-清除：虚拟机将死亡对象所占用的内存空间释放，放入到空闲列表中。当创建对象时，虚拟机从空闲空间列表中，查找大小合适的空闲空间分配给对象。会出现内存碎片的问题，标记-清除后得到的空闲空间不连续，缺点是查找耗时、大对象无法分配</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221014082634361.png\" alt=\"image-20221014082634361\" style=\"zoom: 67%;\" /></li>\n<li><p>标记-整理：又叫标记-压缩算法，在标记-清除算法的基础上，额外增加了整理的环节，先使用可达性分析标记存活对象所占用的内存空间，然后顺序遍历内存空间，将存活对象移动到内存的一端，从而解决内存碎片的问题，只需记录空闲空间的起始地址用于非配内存空间</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221014084224772.png\" alt=\"image-20221014084224772\" style=\"zoom:67%;\" /></li>\n<li><p>标记-复制：将整个内存分为轮流使用的两块内存，一块内存为对象分配内存空间，称为工作内存，另一块内存作为复制时备用（称为备用内存），当工作内存使用完之后，标记-复制算法将这块内存中的存活对象逐一复制到备用内存中，然后，两块内存互换角色。缺点：内存只有一般的利用率，长时间存活的对象会在两块内存复制多次，浪费时间</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221014085525770.png\" alt=\"image-20221014085525770\" style=\"zoom:67%;\" /></li>\n</ul>\n</li>\n<li><p>分代垃圾回收算法</p>\n<ul>\n<li><strong>不需回收：</strong>JVM将内存划分为方法区、程序计数器、堆、虚拟机栈、本地方法栈，其中程序计数器的内存非常小，并且随着线程的创建而创建、销毁而销毁。虚拟机栈和本地方法栈存储的是方法对应的栈帧，栈帧随着方法的调用而入栈，随着方法的退出而出栈，因此这三个分区中的垃圾，会随着生命周期的结束而被立刻回收，不需要经过虚拟机的垃圾回收线程的处理</li>\n<li><strong>需要回收：</strong>堆中存储的是对象，对象供所有线程共享，作用域范围大，生命周期长，在使用完成之后并不会立刻回收，所以堆是进行垃圾回收的重点工作分区。方法区也会涉及垃圾回收，比如方法区中的一些无用的类（该类的所有对象都已被回收、类的Class对象没有任何变量在引用、加载该类的类加载器已经卸载）或者无用的String常量对象（存储在字符串常量池中的并且没有变量引用的String对象）</li>\n<li><strong>对堆的垃圾回收：</strong>应用程序所创建的对象生命周期并不相同，有的生命周期长有的生命周期短。对于短的希望以较高的频率执行垃圾回收，尽快释放所占用的内存空间；对于长的希望以较低的频率进行垃圾回收，避免无效的垃圾回收</li>\n<li><strong>分代垃圾回收算法：</strong>因此虚拟机将堆分为年轻代（Young Generation）和老年代（Old Generation）两个分区，年轻代存储声明周期比较短的对象、老年代存储声明周期比较长的对象。虚拟机针对不同的分代使用不同的基础垃圾回收算法（标记-清除、标记-整理、标记-复制），在基础垃圾回收算法之上增加分代之后的垃圾回收算法，叫做分代垃圾回收算法</li>\n</ul>\n</li>\n<li><p>年轻代和YoungGC</p>\n<ul>\n<li><p>新创建的对象会分配在年轻代，因此年轻代也叫新生代（New Generation）。因为大部分对象存活时间都很短，所以年轻代适合标记-复制算法进行垃圾回收，只需要复制少量存活对象，复制耗时少，执行效率高</p>\n</li>\n<li><p>为了提高标记-算法的内存利用率，将年轻代分为不均等的三个分区：一个Eden区和两个Survivor区。虚拟机将Eden区和一个Survivor区（From Survivor区）作为分配对象使用（工作分区），将另一个Survivor（To Survivor区）作为复制备用（备用分区）。当工作分区满了之后，虚拟机便执行标记-复制算法，将工作区的存活对象复制到To Survivor区，并交换两个Survivor区的角色</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221014094050078.png\" alt=\"image-20221014094050078\"></p>\n</li>\n<li><p>一般情况下，Eden区比较大，Survivor区比较小，一般根据每次垃圾回收之后存活对象的比例，动态调整Eden区和Survivor区的大小比例，也可以通过JVM参数-XX:SurvivorRatio设置固定的比例，其值表示Eden区和一个Survivor区的大小比例</p>\n</li>\n<li><p><strong>空间分配担保机制：</strong>如果ToSurvivor区存不下一次垃圾回收之后的存活对象，虚拟机会借用老年代的部分空间，将存不下的对象存储在老年代中，老年代起到一个担保的作用（老年代也不够时会执行FullGC，如果仍不够空间则抛出OOM Error），这种处理机制叫做空间分配担保机制。缺点：部分生命周期短的对象存储到了老年代，等待很长时间才能被回收</p>\n</li>\n</ul>\n</li>\n<li><p>老年代和FullGC</p>\n<ul>\n<li>新生代存不下的对象、大对象、长期存活对象都会进入老年代<ul>\n<li>大对象指的是占用大量连续内存空间的对象，比如大的字符串或数组，默认也会在年轻代创建，但如果设置了JVM参数-XX:PretenureSizeThreshold，当对象大小超过这个阈值，对象会直接在老年代创建，避免生命周期比较长的大对象在年轻代反复被复制</li>\n<li>长期存活的对象指的是经过多次年轻代垃圾回收仍然存活的对象，虚拟机在对象的对象头中记录对象的GC年龄，每经过一次GC，GC年龄就增一，当GC年龄超过一定阈值（默认15，或通过-XX:PretenureSizeThreshold设置）之后，对象便从年轻代移动到老年代。不过，人为设定一个固定值不够灵活，于是，虚拟机设计了动态年龄判断机制，结合存活对象的多少来动态的设置最大GC年龄</li>\n<li><strong>动态年龄判断机制：</strong>统计YoungGC后，处于每个GC年龄值的对象占To Survivor区的比例，如果GC年龄&gt;=X（X取最大值）的对象占To Survivor区的比例超过50%（比例通过-XX:TargetSurvivorRatio来设置），那么GC年龄&gt;=X的对象都将直接进入老年代，不等GC年龄大于15</li>\n</ul>\n</li>\n<li>老年代的垃圾回收<ul>\n<li>因为老年代中的对象生命周期比较长，每次垃圾回收之后，存活对象比较多，所以采用标记-整理算法（标记-清除有内存碎片）进行回收，同理，永久代也使用标记-整理算法进行回收</li>\n<li>老年代的垃圾回收叫做OldGC，但是，在主流虚拟机的实现中，比如HotSpot JVM，在对老年代进行垃圾回收的同时，虚拟机会一并对年轻代和永久代进行垃圾回收，这种对整个堆的垃圾回收叫做FullGC</li>\n<li>因为YoungGC只对年轻代进行垃圾回收，年轻代中的对象的存活率比较低，可达性分析需要遍历的对象和需要进行复制的对象比较少，所以YoungGC比较快，因此也称为MinorGC。而FullGC针对整个堆进行垃圾回收，并且老年代和永久代中的对象的存活率比较高，可达性分析需要遍历的对象和垃圾回收需要处理的对象比较多，所以FullGC比较慢，因此也称为MajorGC</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-垃圾回收器\"><a href=\"#3-垃圾回收器\" class=\"headerlink\" title=\"3.垃圾回收器\"></a>3.垃圾回收器</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>垃圾回收器是垃圾回收算法的具体实现，同一种垃圾回收算法可以有不同的实现方式，对应不同的垃圾回收器</p></blockquote>\n<ol>\n<li><p>垃圾回收器的性能指标</p>\n<ul>\n<li>吞吐量：业务代码运行时间 <strong>/</strong> 应用程序总运行时间「总时间包括业务代码运行时间和垃圾回收/GC时间」</li>\n<li>停顿时间：垃圾回收导致应用程序完全停止业务执行的时间，及STW（Stop-The-World）时间</li>\n<li>资源消耗：资源指的是CPU、内存资源，比如Parallel垃圾回收器使用多线程进行垃圾回收，占用的CPU资源比Serial垃圾回收器多，CMS垃圾回收器的停顿时间虽然比较短，但需要预留内存</li>\n<li>其它指标：与虚拟机的垃圾回收的策略、堆和堆中各个分代大小的设置有关<ul>\n<li>回收延迟：从一个对象死亡到被回收所经历的等待时间</li>\n<li>回收频率：隔多久进行一次垃圾回收</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>四大类常用的垃圾回收器（分类依据：串行/并行、是否STW、针对年轻代/老年代）</p>\n<ul>\n<li><p>Serial垃圾回收器：使用单线程进行垃圾回收，并在垃圾回收时，虚拟机需要暂停应用程序的运行（即Stop The World），针对工作的分区不同有以下两种分类</p>\n<ul>\n<li><p>Serial New：用于年轻代的垃圾回收，基于标记-清除算法来实现</p>\n</li>\n<li><p>Serial Old：用于老年代的垃圾回收，基于标记-整理算法来实现</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221019182248271.png\" alt=\"image-20221019182248271\" style=\"zoom: 67%;\" /></li>\n</ul>\n</li>\n<li><p>Parallel垃圾回收器：使用多线程进行垃圾回收，可以充分利用CPU资源，同Serial，垃圾回收时需要暂停应用程序的运行，有以下三种分类</p>\n<ul>\n<li><p>Parallel Scavenge（简称PS）：用于年轻代，基于标记-复制算法，与ParOld配合使用</p>\n</li>\n<li><p>Parallel New（简称ParNew）：用于年轻代，基于标记-复制算法，与CMS配合使用</p>\n</li>\n<li><p>Parallel Old（简称ParOld）：用于老年代，基于标记-整理算法</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221019182727916.png\" alt=\"image-20221019182727916\" style=\"zoom:67%;\" /></li>\n</ul>\n</li>\n<li><p>CMS垃圾回收器：全称为Concurrent Mark Sweep，采用多线程执行垃圾回收，不同于Parallel，CMS不需要暂停应用程序，但是CMS不能用于年轻代的垃圾回收，年轻代默认使用Parallel New垃圾回收器</p>\n<ul>\n<li><p>CMS垃圾回收器将整个垃圾回收过程分为四个阶段：初始标记、并发标记、重新标记、并发清理，其中初始标记和重新标记需要暂停应用程序，其余两个阶段可以做到并发处理</p>\n</li>\n<li><p>CMS垃圾回收器在应用程序并行执行的过程中会争抢CPU资源，因此CMS使用的并发线程数等于（CPU内核数+3）/ 4，并且需要在老年代未满的时候进行垃圾回收，为并发执行的应用程序预留内存</p>\n<ul>\n<li>预留内存通过JVM参数-XX:CMSInitiatingOccupancyFraction来指定已用内存占老年代的比值，超过此阈值就会触发CMS垃圾回收器的执行</li>\n<li>预留内存空间不够时，转而使用SerialOld垃圾回收器执行本次垃圾回收</li>\n</ul>\n</li>\n<li><p>为了减少STW时间，CMS采用标记-清除算法来实现，相对于标记-整理算法，节省了整理空闲空间的时间，并且CMS针对内存碎片问题进行了改进，即在多次垃圾回收之后进行一次内存碎片的整理</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221019183151598.png\" alt=\"image-20221019183151598\" style=\"zoom:67%;\" /></li>\n</ul>\n</li>\n<li><p>G1垃圾回收器：全称为Garbage First，是一个应用于堆上的垃圾回收器，借鉴分代的处理思路，G1垃圾回收器将整个堆划分为很多（2048）小的区域（Region），并进一步分为年轻代（Eden区或Survivor区）、老年代，如下图</p>\n<ul>\n<li><p>之前的垃圾回收器都是针对整个分代进行垃圾回收，当分代被划分为更小的区域后，每次垃圾回收时，虚拟机可以只回收分代中的部分区域，进一步缩短STW时间</p>\n</li>\n<li><p>G1同CMS类似，都是多线程进行垃圾回收，并且回收的过程与应用程序并发执行，不同的地方是G1垃圾回收器整体使用标记-整理算法、局部（每个Region）使用标记-复制</p>\n</li>\n<li><p>因为G1的STW时间可以预测，所以可以通过-XX:MaxGCPauseMillis设置可允许的最大STW时间，G1根据这个时间决定每次对多少个区域进行垃圾回收</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221019185543559.png\" alt=\"image-20221019185543559\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>垃圾回收器的对比与选择</p>\n<ul>\n<li><p>默认Java7、Java8采用Parallel垃圾回收器，Java9采用G1垃圾回收器，可以通过设置JVM参数来指定项目使用的垃圾回收器</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221019190248715.png\" alt=\"image-20221019190248715\"></p>\n</li>\n<li><p>实战建议</p>\n<ul>\n<li>Serial：单核系统，多个应用程序争用CPU资源的环境下，需要刻意限制虚拟机所占用资源的环境，比如运行在移动端的客户端程序</li>\n<li>Parallel与CMS相比，前者吞吐量更大，后者停顿时间更少，对于离线服务，首选吞吐量达的Parallel垃圾回收器，对于实时服务，特别是对响应时间敏感的服务，首选停顿时间更少的CMS垃圾回收器</li>\n<li>Java9中，CMS被标记为Deprecated，使用G1取代，针对比较大的堆（大于6GB），首选停顿时间可控的G1垃圾回收器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>并发垃圾回收</p>\n<ul>\n<li>并发：并非完全并发，而是大部分时间不需要暂停应用程序，并发垃圾回收整个过程分为4个阶段，分别是：初始标记、并发标记、重新标记、并发清理，其中并发标记和并发清理这两个比较耗时的阶段可以与应用程序并发执行，而其余两个阶段仍需要暂停应用程序的执行</li>\n<li>回收过程：初始标记指的是标记GC Roots。并发标记指的是在应用程序不暂停的情况下，以GC Roots为起点，广度或深度优先遍历所有可达对象（存活对象），在并发标记的过程中，应用程序有可能修改对象之间的引用关系，导致并行标记过程出现误标或漏标的情况，重新标记所做的工作就是对误标和漏标进行修正。并发清理指的是在不暂停应用情况下，对标记出来的垃圾对象进行清理</li>\n<li>并发清理：前面三个阶段属于可达性分析，即标记-清除算法中的标记环节，并发清理是标记-清除算法中的清除环节。在并发清理过程中，如果存活对象变为死亡对象，只需要在下一次垃圾回收中被回收即可；而死亡对象不会再变成存活对象，因为死亡对象不再有变量（局部变量或静态变量）的直接或间接引用，因此应用程序是无法在代码中使用这些死亡对象（比如局部变量在函数执行结束后就被销毁了）</li>\n</ul>\n</li>\n<li><p>三色标记算法</p>\n<ul>\n<li><p>三色标记算法主要用于可达性分析，其将遍历过程中的对象分别标记为：白色、灰色、黑色三种类型，各个颜色含义如下</p>\n<ul>\n<li>白色：对象没有遍历过，遍历开始时，所有对象都初始化白色，遍历结束后，仍为白表示对象不可达</li>\n<li>灰色：对象已经被遍历，但是对象所直接引用的对象还没有完全被遍历</li>\n<li>黑色：对象已经被遍历，并且对象所直接引用的对象都已经被遍历</li>\n</ul>\n</li>\n<li><p>可达性分析基于图的广度或深度遍历算法来实现，这里以广度优先搜索为例</p>\n<ul>\n<li>初始化GC Roots为灰色，其余为白色</li>\n<li>从灰色集合中取出一个灰色对象，标记为黑色，将此对象直接引用的所有白色对象标记为灰色</li>\n<li>重复第二步，知道灰色集合中没有对象为止。此时黑色集合存放的是可达对象，也就是存活对象；白色集合中存在的是不可达对象，也就是死亡对象</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221023190509031.png\" alt=\"image-20221023190509031\"></p>\n</li>\n<li><p>误标和漏标：在三色标记算法执行的过程中，由于并发标记不会暂停应用程序的执行，所以其在执行的过程中，有可能会改变对象的引用关系，从而导致存活对象的误标和漏标问题。误标指的是将非存活对象误标为存活对象（白的标成黑的），漏标指的是将其存活对象漏标，漏标的存活对象会被判定为死亡对象（黑的标成白的）</p>\n<ul>\n<li><p>误标：如果可达性分析进行到如下所示情况，此时应用程序执行<code>objA.fieldB = null;</code>这样一条语句后，由于B已经被标记为灰色，所以B及其所引用的对象仍然会被判定为存活对象</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221023191148132.png\" alt=\"image-20221023191148132\" style=\"zoom:50%;\" /></li>\n<li><p>漏标：当可达性分析进行到上图所示的状态，应用程序执行了如下两行代码后，效果如下图所示，此时因为A已经是黑色对象，所以不会再被遍历，因此尽管C是存活对象，但不会被遍历，从而出现漏标的问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">objA.fieldc &#x3D; objA.fieldB.fieldC;\nobjA.fieldB.fieldC &#x3D; null;</code></pre>\n\n\n\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221023191211685.png\" alt=\"image-20221023191211685\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>增量更新和原始快照</p>\n<ul>\n<li>并发标记的误标和漏标问题会在重新标记中解决，其中误标问题不大，是可以接受的，只会导致垃圾对象延迟回收，但是漏标问题会导致应用程序运行出错，回收不该回收的对象，漏标产生的原因主要有以下两点，两者缺一不可<ul>\n<li>新增引用：新增一个黑色对象对一个白色对象的引用</li>\n<li>删除引用：删除所有灰色对象到此白色对象的直接或间接引用</li>\n</ul>\n</li>\n<li>针对以上两点，Java发明了两种漏标解决方案，针对第一点新增引用的漏标解决方案叫做增量更新，是CMS垃圾回收器所使用的方案；针对第二点删除引用的漏标解决方案叫做原始快照，是G1垃圾回收器所使用的方案，方案具体如下：<ul>\n<li>增量更新：在并发标记的过程中，如果应用程序<strong>新增</strong>了一个黑色对象对一个白色对象的引用，虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下的白色对象为起点，重新进行可达性分析，这样漏标的白色对象会被重新标记为黑色对象</li>\n<li>原始快照：在并发标记的过程中，如果应用程序<strong>删除</strong>了一个灰色对象对一个白色对象的直接/间接引用，那么虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下来的白色对象为起点，重新进行可达性分析，这就相当于虚拟机对引用关系改变之前的原始快照进行可达性分析。不过，这些记录下的白色对象有可能是死亡对象，而重新标记阶段会将这些死亡对象重新标记为存活对象，因此，原始快照这种解决方案会导致误标问题，会导致垃圾对象延迟回收</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-JVM实战\"><a href=\"#5-JVM实战\" class=\"headerlink\" title=\"5.JVM实战\"></a>5.JVM实战</h3><h4 id=\"1-JVM性能优化\"><a href=\"#1-JVM性能优化\" class=\"headerlink\" title=\"1.JVM性能优化\"></a>1.JVM性能优化</h4><ol>\n<li><p>JVM性能指标</p>\n<ul>\n<li>对于垃圾回收来说，应用程序直接关注的性能指标主要就两个：GC频率和GC时间，也就是多久一次GC和GC一次多久</li>\n<li>一些决定GC频率和时间的内部性能指标<ul>\n<li>年轻代中对象的增长速率</li>\n<li>每次YoungGC之后存活对象大小</li>\n<li>每次YoungGC之后进入老年代的对象大小</li>\n<li>老年代对象的增长速率</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM参数设置</p>\n<ul>\n<li>JVM参数一般有3种类型：标准参数（以-开头，比如-version）、X参数（以-X开头，比如-Xint，-Xms2048m）、XX参数（以-XX开头，比如-XX:PrintGCDetails、-XX:PermSize=512m）,这三种类型的参数的稳定性依次下降，即在Java版本更新的过程中，标准参数很少改动，X参数可能会改动，XX参数该懂的可能性比较大</li>\n<li>JVM参数有上百个，但是对绝大部分参数来说，默认的设置便是最普适、最合理的设置。常用的JVM GC参数只有几个，主要集中在内存分配和垃圾回收器的设置这两个方面，如下所示<ul>\n<li>设置堆的大小：一般设置为相同的值，避免堆大小的调整而引起的性能损耗<ul>\n<li>-Xms：Java堆内存的初始大小</li>\n<li>-Xmx：Java堆内存的最大大小</li>\n</ul>\n</li>\n<li>设置年轻代和老年代的大小：设置年轻代大小的方法有三种，但是对于老年代的大小只需要通过堆大小减去年轻代大小即可得到<ul>\n<li>-Xmn：年轻代的大小</li>\n<li>-XX:NewSize：年轻代的初始大小</li>\n<li>-XX:MaXNewSize：年轻代的最大大小</li>\n<li>-XX:NewRatio：年轻代与老年的大小比值，值为老年代/年轻代</li>\n</ul>\n</li>\n<li>设置永久代或元空间的大小<ul>\n<li>-XX:PermSize：永久代的初始大小</li>\n<li>-XX:MaxPermSize：永久代的最大大小，这两个参数只在1.7之前有效</li>\n<li>-XX:MetaspaceSize：元空间的初始大小</li>\n<li>-XX:MaxMetaspaceSize：元空间的最大大小，这两个参数只在1.8之后有效</li>\n</ul>\n</li>\n<li>设置Eden区和survivor区的大小<ul>\n<li>-XX:SurvivorRatio：一个Survivor区跟Eden区的大小比例，值为Eden区/Survivor区，注意：一共有两个Survivor区</li>\n</ul>\n</li>\n<li>设置线程栈的大小<ul>\n<li>-Xss：每个线程的栈大小，HotSpot JVM不区分虚拟机栈和本地方法栈，使用一个栈同时存储Java方法和本地方法的栈帧，因此这里只有一个栈大小的设置参数，线程栈大小默认为512KB或1MB，除非系统在运行的过程中，出现非代码因素导致的StackOverflow，才需要调整线程栈的大小，否则默认即可</li>\n</ul>\n</li>\n<li>设置垃圾回收器<ul>\n<li>-XX:+UseSerialGC：用Serial垃圾回收器</li>\n<li>-XX:+UseParallelGC：用Parallel垃圾回收器</li>\n<li>-XX:+UseConcMarkSweepGC：用CMS垃圾回收器</li>\n<li>-XX:+UseG1GC：用G1垃圾回收器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM性能预估</p>\n<ul>\n<li><p>大部分情况针对JVM参数预设一些经验值，然后根据线上或压测的情况，在做调整优化即可</p>\n</li>\n<li><p>也可以预估系统对内存的使用情况，每秒产生多少对象，对象的生命周期等，然后根据GC频率和GC时间针对性地设置JVM参数</p>\n</li>\n<li><p>示例一：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221028133500257.png\" alt=\"image-20221028133500257\"></p>\n</li>\n</ul>\n</li>\n<li><p>JVM性能调优</p>\n<ul>\n<li>在线上，可以基于<strong>jstat</strong>等工具得到的JVM性能统计数据，进一步做性能调优</li>\n<li>一般来说JVM性能调优所努力的方向是<strong>减少GC频率和GC时间</strong>，特别是FullGC频率和FullGC时间，相比较YoungGC来说，FullGC要慢很多，需要调整JVM参数，比如：<ul>\n<li>增大年轻代的大小，增大Survivor区大小，让对象尽量在年轻代就被回收掉，减少老年代中对象的增长速率，从而降低FullGC频率</li>\n<li>增加老年代的大小也会降低FullGC的频率，但会增大FullGC的时间</li>\n</ul>\n</li>\n<li>一般来说，如果堆不是很大，没有长期存活的大对象和内存泄漏，那么应用CMS垃圾回收器并调节年轻代、老年代、Survivor区等内存分配，完全可以将FullGC时间优化到合适的范围，否则可以选择GC时间可控的G1垃圾回收器</li>\n<li>大部分情况，不需要刻意的进行调优，只有当通过监控发现GC严重影响系统性能时，才有必要对JVM参数进行调优</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2-JVM问题排查\"><a href=\"#2-JVM问题排查\" class=\"headerlink\" title=\"2.JVM问题排查\"></a>2.JVM问题排查</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>jstat、jmap</p></blockquote>\n<ol>\n<li><p>JVM性能监控和分析工具</p>\n<ul>\n<li><p>GC统计信息监控：</p>\n<ul>\n<li><p>可视化：JConsole、VisualVM，不仅可以监控GC情况，还可以监控系统资源（CPU、内存等）的使用情况、线程的执行情况</p>\n</li>\n<li><p>jstat</p>\n<ul>\n<li><p>只需要通过jps命令查找到要监控的JVM进程ID，然后执行jstat -gcutil [vmid] [time-interval]即可</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/AgAABebs1Olmk_imtkBNMaRgL0WZjd0D.jpeg\" alt=\"img\"></p>\n</li>\n<li><p>各列含义如下：</p>\n<ul>\n<li>S0：表示Survivor0的内存使用率；S1：表示Survivor1的内存使用率；E：表示Eden区的内存使用率；O：表示老年代的内存使用率；M：表示Metaspace的内存使用率；</li>\n<li>YGC：YoungGC的次数；YGCT：YoungGC的总耗时；FGC：FullGC的次数； FGCT：FullGC的总耗时；GCT：GC的总耗时。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>GC详细日志分析</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/AgAABebs1OlbOVhxuHtOD5wTJ9rQnI0d-20221105183741728.jpeg\" alt=\"img\"></p>\n<ul>\n<li><p>-XX:+PrintGCDetails 打印详细GC日志</p>\n</li>\n<li><p>-Xloggc:./logs/gc.log 详细GC日志存储的位置</p>\n</li>\n<li><p>以上日志可以粗略的分为两类：ParNew日志和CMS日志</p>\n<ul>\n<li><p>ParNew日志示例</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">[GC (Allocation Failure) 4.527: [ParNew: 48243K-&gt;6054K(55296K), 0.0101725 secs] 48243K-&gt;11277K(96256K), 0.0103798 secs] [Times: user&#x3D;0.08 sys&#x3D;0.01, real&#x3D;0.01 secs]</code></pre>\n\n<ul>\n<li><strong>GC（Allocation Failure）</strong>：表示GC是因为内存分配失败触发的</li>\n<li><strong>4.527</strong>：表示GC发生的时间（距离JVM启动所经历的秒数）</li>\n<li>**[ParNew：48243K-&gt;6054K(55296K)，0.0101725 secs]**：表示GC的情况。ParNew表示GC类型为Parallel New，48243K和6054K表示GC前后年轻代中对象的大小。55296K表示年轻代的总大小。0.0101725表示GC耗时</li>\n<li><strong>48243K-&gt;11277K(96256K)，0.0103798 secs</strong>：48243K和11277K表示本次GC前后整个堆中对象的大小变化。96256K表示整个堆的总大小</li>\n<li>**[Times: user=0.08 sys=0.01, real=0.01 secs]**：表示GC具体的耗时分析。user=0.08表示GC线程使用CPU的时间，sys=0.01表示系统调用的时间，real=0.01表示墙上时钟，也就是从GC开始到结束所经历的时间，即STW停顿时间。注意，在多核多线程情况下，user时间为每个线程所使用的CPU时间之和，因此，它的大小很有可能超过real时间的大小</li>\n</ul>\n</li>\n<li><p>CMS日志示例：CMS日志包含的信息比ParNew日志要多很多，其中，CMS Initial Mark、CMS-cocurrent-mark、CMS Final Remark、CMS-concurrent-sweep分别对应并发垃圾回收的四个阶段：初始标记、并发标记、重新标记、并发清理。除此之外，CMS日志中的CMS-concurrent-preclean和CMS-concurrent-reset为更加细化的并发垃圾回收阶段，负责CMS内部数据结构的调整工作，这里就不展开详细讲解了</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM内存快照获取和分析：</p>\n<ul>\n<li><p>当JVM出现问题时，比如OOM、频繁GC，我们希望得知当前堆中存储的对象情况，比如哪些对象占据了大量堆内存，我们就需要将当下的内存快照dump出来，然后利用工具来查看和分析</p>\n</li>\n<li><p>常用的dump堆内存快照的方法有两种，一种是使用JVM参数，另一种是使用jmap命令行工具。具体如下所示。dump出来的堆内存快照为二进制文件，我们需要通过工具来查看，常用的查看工具有MAT、jhat等。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">方法一：使用JVM参数\n-XX:+HeapDumpBeforeFullGC\n-XX:HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath&#x3D;目录\n\n方法二：使用jmap命令行工具\njmap -dump:format&#x3D;b,file&#x3D;文件名 [pid] </code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM常见问题一：OOM</p>\n<ul>\n<li><p>当程序申请不到足够的内存空间，并且JVM通过GC也无法释放出足够的内存空间时，JVM便会抛出OOM</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Stack &#123;\n  private Object[] array;\n  private int capacity;\n  private int top;\n\n  public Stack(int capacity) &#123;\n    this.capacity &#x3D; capacity;\n    this.top &#x3D; 0;\n    this.array &#x3D; new Object[capacity];\n  &#125;\n\n  public void push(Object obj) &#123;\n    array[top++] &#x3D; obj;\n  &#125;\n\n  public Object pop() &#123;\n    &#x2F;&#x2F;只是将top值减一并返回对应的对象，并没有删除array数组对对象的引用关系\n    &#x2F;&#x2F;对象即便已经使用完成，也无法被回收\n    return array[--top];\n  &#125;\n&#125;\n&#x2F;&#x2F;改进版本的pop函数\npublic Object pop() &#123;\n  Object obj &#x3D; array[top-1];\n  array[top-1] &#x3D; null; &#x2F;&#x2F;删除引用关系\n  top--;\n  return obj;\n&#125;</code></pre></li>\n<li><p>OOM一般有两种：永久代（元空间）的内存溢出和堆的内存溢出，分别对应以下两种错误信息</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">java.lang.OutOfMemoryError: PermGen space(或 MetaSpace)\njava.lang.OutOfMemoryError: Java heap space</code></pre></li>\n<li><p>导致内存溢出的常见的原因有如下几种</p>\n<ul>\n<li>设置的堆或永久代（元空间）的大小太小</li>\n<li>一次性创建过多的对象，比如通过SQL查询全表数据。</li>\n<li>应用程序使用完成的对象没有被及时释放，导致对应的内存无法被回收，长期积累，便会导致内存耗尽。我们把这种情况叫做内存泄露</li>\n</ul>\n</li>\n<li><p>如何排查OOM问题</p>\n<ul>\n<li>当JVM出现OOM问题时，应用程序的对应表现一般是无法继续执行，如果应用程序是接口系统，那么接口将出现大量503错误。这时，我们通过查看日志，便会发现大量java.lang.OutOfMemoryError错误信息。为了排查出到底哪些对象长期存在并大量占用内存，我们需要通过jmap或JVM参数获取堆内存快照，并通过MAT等工具来查看和分析</li>\n<li>使用MAT工具可以得知内存泄漏的数据可能集中在哪些代码，然后就可以去分析源代码，看是否代码存在内存泄漏，又或者创建了太多长期存在的对象，最后可以尝试调大堆内存的大小</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM常见问题二：频繁GC</p>\n<ul>\n<li>一般OOM前会出现频繁GC，主要有两种：频繁YoungGC和频繁FullGC，单纯的频繁YoungGC往往是由年轻代空间太小导致的，只需要适当增大年轻代的大小即可解决这个问题，因为YoungGC只与存活对象的数量有关，与年轻代大小无关</li>\n<li>相对于频繁YoungGC，频繁FullGC会引发更加严重的问题，且解决起来更加复杂。因为FullGC更加消耗CPU资源并且STW停顿时间较长，所以，在发生频繁FullGC时，CPU利用率一般会飙升，并且会出现应用程序变慢的情况（比如接口请求处理速度变慢甚至大量超时）</li>\n<li>触发FullGC的主要原因是老年代空间不足。前面我们已经总结过，老年代的对象一般来源于长期存活的对象、大对象、空间分配担保。接下来，我们从这3个对象来源来分析频繁GC发生的原因。<ul>\n<li>长期存活的对象：如果应用程序创建的长期存活的对象比较多，那么，我们可以适当调大老年代的大小，以减少FullGC的频率。不过，这种情况并不常见，大部分应用程序并不会创建太多的长期存活的对象。实际上，内存泄露往往才是导致对象长期存活无法回收的主要原因。如果每次FullGC回收率很低，释放出来的空间很少，那么就说明是存在内存泄露了。频繁FullGC一段时间之后，JVM便会出现OOM</li>\n<li>大对象：前面讲到，大对象会直接进入老年代。过多的大对象是引起频繁FullGC的最常见的原因之一。比如，在某个接口中执行了未分页SQL，一次性加载过多数据到内存中，当高并发下，接口大量被调用，就会导致大量大对象被创建，从而导致老年代空间不足，引发频繁FullGC。定位此种频繁FullGC发生的原因，我们需要在FullGC前（设置JVM参数-XX:+HeapDumpBeforeFullGC）dump内存快照，分析占用堆内存比较多的是哪个对象，以此来定位问题代码</li>\n<li>空间分配担保：前面讲到，在执行YoungGC时，如果To Survivor空间不足，JVM会触发空间分配担保，将对象存储到老年代。因此，如果每次YoungGC，To Survivor都被占满，那么，我们就要考虑增大To Survivor区，避免空间分配担保，减少进入老年代的对象数量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM常见问题三：GC时间过长</p>\n<ul>\n<li><strong>堆内存过大：</strong>前面讲到，年轻代使用标记-复制垃圾回收算法，并且，年轻代空间增大并不会导致存活对象增多，因此，YoungGC时间跟年轻代的大小无关，但是，老年代使用标记-整理或标记-清除垃圾回收算法，并且，老年代空间增大会导致存活对象增多，因此，FullGC时间跟老年代的大小有关。老年代过大会导致FullGC时间过长。针对比较大的堆内存，我们应该选择GC时间可控的G1垃圾回收器，或者在一台大物理内存的机器上部署多个JVM，以减小单个堆内存的大小</li>\n<li><strong>Concurrent Mode Failure：</strong>前面讲到，CMS垃圾回收器采用并发垃圾回收算法，在垃圾回收的某些阶段，应用程序可以与之并发执行。应用程序的执行需要堆内存，因此，JVM在执行垃圾回收前，会预留一定的堆内存空间。但是，在执行垃圾回收的的过程中，如果预留空间不足，应用程序无法继续执行，那么，JVM便会抛出Concurrent Mode Failure错误，并且，暂停CMS垃圾回收器的执行，改为STW停顿时间更长的Serial Old垃圾回收器。垃圾回收器的中止和切换势必会增长FullGC时间。如果我们在GC详细日志中（通过设置JVM参数-XX:+PrintGCDetails得到）发现大量Concurrent Mode Failre字样，那么，我们就需要通过减小JVM参数-XX:CMSInitialOccupancyFraction的值来调大预留空间的大小</li>\n<li><strong>操作系统swap：</strong>swap是操作系统中的概念。当物理内存不足时，操作系统会将物理内存中的部分不活跃的数据放入磁盘，当这部分数据重新被使用时，再从磁盘加载到物理内存中。这种数据在物理内存和磁盘之间换入换出的机制，就叫作swap。swap涉及磁盘I/O操作，非常影响进程的性能。如果设置的JVM堆内存大小超过物理内存大小，或者多个应用程序争用有限的物理内存，那么，就有可能触发swap而导致GC时间增长。解决这个问题的方法也很简单，尽量保证JVM堆大小不要超过物理内存的大小，并且为操作系统或者其他软件预留充足的物理内存，比如物理内存有8GB，我们设置JVM堆大小为6GB，预留2GB给操作系统和其他并发运行的软件</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"新特性\"><a href=\"#新特性\" class=\"headerlink\" title=\"新特性\"></a>新特性</h2><h3 id=\"1-jdk9（2017-09）\"><a href=\"#1-jdk9（2017-09）\" class=\"headerlink\" title=\"1.jdk9（2017.09）\"></a>1.jdk9（2017.09）</h3><ol>\n<li><p>模块化</p>\n<ul>\n<li><p>JPMS（Java Platform Module System）是Java 9发行版的核心亮点。它也被称为Jigshaw项目。模块是新的结构，就像我们已经有包一样。使用新的模块化编程开发的应用程序可以看作是交互模块的集合，这些模块之间具有明确定义的边界和依赖关系。</p>\n</li>\n<li><p>JPMS包括为编写模块化应用程序提供支持，以及将JDK源代码模块化。JDK 9 附带了大约 92 个模块（在 GA 版本中可以进行更改）。Java 9 Module System有一个”<strong>java.base</strong>“模块。它被称为基本模块。它是一个独立的模块，不依赖于任何其他模块。默认情况下，所有其他模块都依赖于”java.base”。</p>\n</li>\n<li><p>在java模块化编程中：</p>\n<ul>\n<li>一个模块通常只是一个 jar 文件，在根目录下有一个文件module-info.class。</li>\n<li>要使用模块，请将 jar 文件包含到modulepath而不是classpath. 添加到类路径的模块化 jar 文件是普通的 jar 文件，module-info.class文件将被忽略。</li>\n</ul>\n</li>\n<li><p>典型的module-info.java类如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">module helloworld &#123;\n  exports com.alibaba.eight; \n&#125; \nmodule test &#123;\n  requires helloworld; \n&#125;</code></pre></li>\n<li><p><strong>总结：模块化的目的，是让jdk的各个组件可以被分拆，复用和替换重写，</strong>比如对java的gui不满意，可以自己实现一个gui，对java的语法不满意，可以把javac替换成其他语言和其他语言的编译器，比如kotlin和kotlinc等，没有模块化，几乎很难实现，每次修改某个模块，总不能把整个jdk给重新编译一遍，再发布一个整个sdk吧，模块化可以帮助更有效的定制化和部署</p>\n</li>\n</ul>\n</li>\n<li><p>优化API</p>\n<ul>\n<li>提供了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法</li>\n<li>接口支持私有方法</li>\n<li>try-with-resources的改进</li>\n</ul>\n</li>\n<li><p>JVM采用G1为默认垃圾收集器</p>\n</li>\n</ol>\n<h3 id=\"2-jdk10（2018-03）\"><a href=\"#2-jdk10（2018-03）\" class=\"headerlink\" title=\"2.jdk10（2018.03）\"></a>2.jdk10（2018.03）</h3><ol>\n<li><p>通过var关键字实现局部变量类型推断，是Java变为弱类型语言。虽然我们在代码中使用var进行了定义，但是对于虚拟机来说他是不认识这个var的，在java文件编译成class文件的过程中，会进行解糖，使用变量真正的类型来替代var</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">var value &#x3D; new MyObject();</code></pre></li>\n<li><p>JVM的G1垃圾回收由单线程改成多线程并行处理，降低G1的停顿时间</p>\n</li>\n<li><p>线程本地握手，允许在不执行全局VM安全点的情况下执行线程回调，可以停止单个线程，而不需要停止所有线程或不停止线程</p>\n</li>\n</ol>\n<h3 id=\"3-jdk11（2018-09-LTS）\"><a href=\"#3-jdk11（2018-09-LTS）\" class=\"headerlink\" title=\"3.jdk11（2018.09 LTS）\"></a>3.jdk11（2018.09 LTS）</h3><ol>\n<li><p>对Stream、Optional、集合API进行增强</p>\n<ul>\n<li><p>Stream API改进：Collectors.teeting()，teeing 收集器已公开为静态方法Collectors::teeing。该收集器将其输入转发给其他两个收集器，然后将它们的结果使用函数合并</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Student&gt; list &#x3D; Arrays.asList(\n        new Student(&quot;唐一&quot;, 55),\n        new Student(&quot;唐二&quot;, 60),\n        new Student(&quot;唐三&quot;, 90));\n\n&#x2F;&#x2F;平均分 总分\nString result &#x3D; list.stream().collect(Collectors.teeing(\n        Collectors.averagingInt(Student::getScore),\n        Collectors.summingInt(Student::getScore),\n        (s1, s2) -&gt; s1 + &quot;:&quot; + s2));\n\n&#x2F;&#x2F;最低分  最高分\nString result2 &#x3D; list.stream().collect(Collectors.teeing(\n        Collectors.minBy(Comparator.comparing(Student::getScore)),\n        Collectors.maxBy(Comparator.comparing(Student::getScore)),\n        (s1, s2) -&gt; s1.orElseThrow() + &quot;:&quot; + s2.orElseThrow()\n));\n\nSystem.out.println(result);\nSystem.out.println(result2);</code></pre></li>\n</ul>\n</li>\n<li><p>新增ZGC垃圾收集器：可伸缩低延迟垃圾收集器，ZGC可以看做是G1之上更细粒度的内存管理策略。由于内存的不断分配回收会产生大量的内存碎片空间，因此需要整理策略防止内存空间碎片化，在整理期间需要将对于内存引用的线程逻辑暂停，这个过程被称为”Stop the world”。只有当整理完成后，线程逻辑才可以继续运行。（并行回收）</p>\n</li>\n<li><p>Http Client重写，支持HTTP/1.1和HTTP/2 ，也支持 websockets</p>\n<ul>\n<li>Java 使用HttpURLConnection进行HTTP通信已经很长一段时间了。但随着时间的推移，要求变得越来越复杂，应用程序的要求也越来越高。在 Java 11 之前，开发人员不得不求助于功能丰富的库，如Apache HttpComponents或OkHttp等。</li>\n<li>作为JDK11中正式推出的新Http连接器，支持的功能还是比较新的，主要的特性有：<ul>\n<li>完整支持HTTP 2.0 或者HTTP 1.1</li>\n<li>支持 HTTPS/TLS</li>\n<li>有简单的阻塞使用方法</li>\n<li>支持异步发送，异步时间通知</li>\n<li>支持WebSocket</li>\n<li>支持响应式流</li>\n</ul>\n</li>\n<li>HTTP2.0其他的客户端也能支持，而HttpClient使用CompletableFuture作为异步的返回数据。WebSocket的支持则是HttpClient的优势。响应式流的支持是HttpClient的一大优势。</li>\n<li>HttpClient中的NIO模型、函数式编程、CompletableFuture异步回调、响应式流让HttpClient拥有极强的并发处理能力，所以其性能极高，而内存占用则更少。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-jdk12（2019-03）\"><a href=\"#4-jdk12（2019-03）\" class=\"headerlink\" title=\"4.jdk12（2019.03）\"></a>4.jdk12（2019.03）</h3><ol>\n<li>G1收集器的优化，将GC的垃圾分为强制部分和可选部分，强制部分会被回收，可选部分可能不会被回收，提高GC的效率。新增Shenandoah GC垃圾回收算法</li>\n</ol>\n<h3 id=\"5-jdk13（2019-09）\"><a href=\"#5-jdk13（2019-09）\" class=\"headerlink\" title=\"5.jdk13（2019.09）\"></a>5.jdk13（2019.09）</h3><ol>\n<li><p>ZGC优化，增强 ZGC 释放未使用内存，将标记长时间空闲的堆内存空间返还给操作系统，保证堆大小不会小于配置的最小堆内存大小，如果堆最大和最小内存大小设置一样，则不会释放内存还给操作系统</p>\n</li>\n<li><p>SocketAPI 重构，Socket的底层实现优化，引入了NIO</p>\n</li>\n<li><p>文本块升级 “”” ，引入了文本块，可以使用”””三个双引号表示文本块，文本块内部就不需要使用换行的转义字符</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;改进前\nString json  &#x3D; &quot;&#123;\\r\\n&quot; + &quot;\\&quot;name\\&quot; : \\&quot;lingli\\&quot;,\\r\\n&quot; + &quot;\\&quot;website\\&quot; : \\&quot;https:&#x2F;&#x2F;www.alibaba.com&#x2F;\\&quot;\\r\\n&quot; + &quot;&#125;&quot;;\n&#x2F;&#x2F;改进后\nString json &#x3D; &quot;&quot;&quot; \n&#123;     \n    &quot;name&quot; : &quot;Baeldung&quot;,     \n    &quot;website&quot; : &quot;https:&#x2F;&#x2F;www.alibaba.com&#x2F;&quot; \n&#125; \n&quot;&quot;&quot;;</code></pre>\n\n<ul>\n<li>isBlank()：如果字符串为空或字符串仅包含空格（包括制表符），则返回 true。注意与isEmpty() 不同，isEmpty()仅在长度为 0 时返回 true。</li>\n<li>lines()：将字符串拆分为字符串流，每个字符串包含一行。</li>\n<li>strip() ：分别从开头和结尾；</li>\n<li>stripLeading()/stripTrailing()仅开始和仅结束删除空格。</li>\n<li>repeat(int times)：返回一个字符串，该字符串采用原始字符串并按指定的次数重复该字符串。</li>\n<li>readString()：允许从文件路径直接读取到字符串。</li>\n<li>writeString(Path path)：将字符串直接写入指定路径处的文件。</li>\n<li>indent(int level)：缩进字符串的指定量。负值只会影响前导空格。</li>\n<li>transform(Function f)：将给定的 lambda 应用于字符串。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"6-jdk14（2020-03）\"><a href=\"#6-jdk14（2020-03）\" class=\"headerlink\" title=\"6.jdk14（2020.03）\"></a>6.jdk14（2020.03）</h3><ol>\n<li><p>改进 NullPointerExceptions提示信息，打印具体哪个方法抛的空指针异常，避免同一行代码多个函数调用时无法判断具体是哪个函数抛异常的困扰，方便异常排查；</p>\n</li>\n<li><p>switch表达式语法扩展</p>\n<ul>\n<li><p>可以有返回值。此更改扩展了switch 语句以便它可以用作语句或表达式。不必为break每个 case 块定义一个语句，我们可以简单地使用<strong>箭头语法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">boolean isWeekend &#x3D; switch (day) &#123;\n  case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; false; \n  case SATURDAY, SUNDAY -&gt; true;\n  default -&gt; throw new IllegalStateException(&quot;Illegal day entry :: &quot; + day);\n&#125;;\n\n\nint size &#x3D; 3;\nString cn &#x3D; switch (size) &#123;\n    case 1 -&gt; &quot;壹&quot;;\n    case 2 -&gt; &quot;贰&quot;;\n    case 3, 4 -&gt; &quot;叁&quot;;\n    default -&gt; &quot;未知&quot;;\n&#125;;\nSystem.out.println(cn);\n&#x2F;&#x2F;要使用此预览功能，我们必须在应用程序启动期间使用–enable-preview标志明确指示 JVM。</code></pre></li>\n<li><p>switch表达式增加yield关键字用于返回结果，作用类似于return，如果没有返回结果则使用break</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">boolean isWeekend &#x3D; switch (day) &#123;\n  case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -&gt; false; \n  case SATURDAY, SUNDAY -&gt; true;\n  default -&gt; throw new IllegalStateException(&quot;Illegal day entry :: &quot; + day);\n&#125;;\n\n\nint size &#x3D; 3;\nString cn &#x3D; switch (size) &#123;\n    case 1 -&gt; &quot;壹&quot;;\n    case 2 -&gt; &quot;贰&quot;;\n    case 3, 4 -&gt; &quot;叁&quot;;\n    default -&gt; &quot;未知&quot;;\n&#125;;\nSystem.out.println(cn);\n&#x2F;&#x2F;要使用此预览功能，我们必须在应用程序启动期间使用–enable-preview标志明确指示 JVM。</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"7-jdk15（2020-09）\"><a href=\"#7-jdk15（2020-09）\" class=\"headerlink\" title=\"7.jdk15（2020.09）\"></a>7.jdk15（2020.09）</h3><ol>\n<li>Sealed Classes（封闭类，预览），通过sealed关键字修饰抽象类限定只允许指定的子类才可以实现或继承抽象类，避免抽象类被滥用</li>\n</ol>\n<h3 id=\"8-jdk16（2021-03）\"><a href=\"#8-jdk16（2021-03）\" class=\"headerlink\" title=\"8.jdk16（2021.03）\"></a>8.jdk16（2021.03）</h3><ol>\n<li><p>instanceof模式匹配，instanceof类型匹配语法简化，可以直接给对象赋值，如if(obj instanceof String str),如果obj是字符串类型则直接赋值给了str变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">之前：\n\nObject obj &#x3D; &quot;大阳&quot;;\nif (obj instanceof String) &#123;\n    String t &#x3D; (String) obj;\n    &#x2F;&#x2F; TODO\n&#125;\n\n现在：\n\nObject obj &#x3D; &quot;大阳&quot;;\nif (obj instanceof String t) &#123;\n    &#x2F;&#x2F; TODO 此时t已经是String类型了\n&#125;</code></pre></li>\n<li><p>引入Record类型，类似于Lombok 的@Data注解，可以向Lombok一样自动生成构造器、equals、getter等方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * record 记录类\n * 你也可以覆写equals() hashCode() toString()方法，不用写get、set了\n * @author DAYANG\n *&#x2F;\nrecord User(String name, Integer age) &#123;\n    \n    @Override\n    public String toString() &#123;\n        return &quot;User[&quot; +\n                &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, age&#x3D;&quot; + age +\n                &#39;]&#39;;\n    &#125;\n    @Override\n    public boolean equals(Object obj) &#123;\n        return false;\n    &#125;\n    @Override\n    public int hashCode() &#123;\n        return 0;\n    &#125;\n&#125;</code></pre></li>\n<li><p>提供用于打包独立 Java 应用程序的 jpackage 工具</p>\n</li>\n</ol>\n<h3 id=\"9-jdk17（2021-09-LTS）\"><a href=\"#9-jdk17（2021-09-LTS）\" class=\"headerlink\" title=\"9.jdk17（2021.09 LTS）\"></a>9.jdk17（2021.09 LTS）</h3><ol>\n<li><p>Free Java License</p>\n</li>\n<li><p>Spring 6 和 Spring Boot 3需要JDK17</p>\n</li>\n<li><p>正式引入密封类sealed class，限制抽象类的实现：在Java15之前，所有的类都可以没有限制地继承其他类–除非被继承类被声明为final类型，任何类都可以实现公共接口。现在在Java15中，一个类或者接口可以使用修饰符sealed声明为密封类或者接口，来限制其继承类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 定义一个抽象密封类Pet，它的实现类只能是Dog, Cat这两个，其他的实现类均不允许\n *&#x2F;\npublic abstract sealed class Pet\n    permits Dog, Cat &#123;&#125;\n\nfinal class Dog extends Pet &#123;\n&#125;\n\nfinal class Cat extends Pet &#123;\n    \n&#125;\n\n&#x2F;&#x2F;密封的类和接口限制了其他类或接口可以扩展或实现它们\npublic sealed interface Shape&#123;\n    final class Planet implements Shape &#123;&#125;\n    final class Star   implements Shape &#123;&#125;\n    final class Comet  implements Shape &#123;&#125;\n&#125;\n\npublic abstract sealed class Test&#123;\n    final class A extends Test &#123;&#125;\n    final class B extends Test &#123;&#125;\n    final class C extends Test &#123;&#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"10-JVM变化总结\"><a href=\"#10-JVM变化总结\" class=\"headerlink\" title=\"10.JVM变化总结\"></a>10.JVM变化总结</h3><ol>\n<li>JDK9: 设置G1为JVM默认垃圾收集器</li>\n<li>JDK10：并行全垃圾回收器 G1，通过并行Full GC, 改善G1的延迟。目前对G1的full GC的实现采用了单线程-清除-压缩算法。JDK10开始使用并行化-清除-压缩算法。</li>\n<li>JDK11：推出ZGC新一代垃圾回收器（实验性）,目标是GC暂停时间不会超过10ms，既能处理几百兆的小堆，也能处理几个T的大堆。</li>\n<li>JDK14 ：删除CMS垃圾回收器;弃用 ParallelScavenge + SerialOld GC 的垃圾回收算法组合;将 zgc 垃圾回收器移植到 macOS 和 windows 平台</li>\n<li>JDk 15 : <strong>ZGC</strong> (JEP 377) 和<strong>Shenandoah</strong> (JEP 379) 不再是实验性功能。默认的 GC 仍然是<strong>G1</strong>。</li>\n<li>JDK16：增强ZGC，ZGC获得了 46个增强功能 和25个错误修复，控制stw时间不超过10毫秒</li>\n</ol>\n<h1 id=\"Data-Structure\"><a href=\"#Data-Structure\" class=\"headerlink\" title=\"Data Structure\"></a>Data Structure<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220622145107270-165668658181231.png\" alt=\"image-20220622145107270\"></h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><h3 id=\"1-大O复杂度表示法\"><a href=\"#1-大O复杂度表示法\" class=\"headerlink\" title=\"1.大O复杂度表示法\"></a>1.大O复杂度表示法</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 一个不用具体的测试数据来测试，就可以粗略地估计算法执行效率的方法</p></blockquote>\n<ol>\n<li>分析方法：<ul>\n<li>只关注循环执行次数最多的一段代码</li>\n<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>\n<li>乘法法则：嵌套代码的复杂度等于嵌套内外的代码复杂度乘积</li>\n<li>复杂度：O(1)&lt;O(log2 n)&lt;O(n)&lt;O(nlog2 n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)</li>\n</ul>\n</li>\n<li>空间复杂度：<ol>\n<li>循环、递归调用栈、辅存</li>\n<li>算法的储存空间与数据规模之间的增长关系，看额外的内存消耗而不是数据本身存储需要多少空间</li>\n</ol>\n</li>\n<li>时间复杂度：<ol>\n<li>不看低阶、不看系数、加法取大、乘法取积、最坏+平均+最好</li>\n<li>分类：<ul>\n<li>最好：在最理想的情况下，如排序的数据恰好顺序</li>\n<li>最坏：最糟糕情况下，如要排序的数据恰好逆序</li>\n<li>低阶、常量、系数都不考虑</li>\n<li>平均：要用到概率论，求平均次数。即将每种情况发生的概率也考虑进去得到加权平均值</li>\n<li>均摊：摊还分析：把一次O（n）操作均摊到n-1次O（1）操作上，得到时间复杂度为O（1），一般都等于最好时间复杂度</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-算法思想\"><a href=\"#2-算法思想\" class=\"headerlink\" title=\"2.算法思想\"></a>2.算法思想</h3><h4 id=\"2-1贪心算法\"><a href=\"#2-1贪心算法\" class=\"headerlink\" title=\"2.1贪心算法\"></a>2.1贪心算法</h4><h4 id=\"2-2分治算法\"><a href=\"#2-2分治算法\" class=\"headerlink\" title=\"2.2分治算法\"></a>2.2分治算法</h4><h4 id=\"2-3动态规划\"><a href=\"#2-3动态规划\" class=\"headerlink\" title=\"2.3动态规划\"></a>2.3动态规划</h4><h4 id=\"2-4回溯算法\"><a href=\"#2-4回溯算法\" class=\"headerlink\" title=\"2.4回溯算法\"></a>2.4回溯算法</h4><h4 id=\"2-5枚举算法\"><a href=\"#2-5枚举算法\" class=\"headerlink\" title=\"2.5枚举算法\"></a>2.5枚举算法</h4><h2 id=\"1-纯编程题\"><a href=\"#1-纯编程题\" class=\"headerlink\" title=\"1.纯编程题\"></a>1.纯编程题</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>题型说明：比重大，解决思路简单，但编程实现繁琐；如何准备：==多练-&gt;提高编程能力==</p></blockquote>\n<h3 id=\"1-1-解题技巧\"><a href=\"#1-1-解题技巧\" class=\"headerlink\" title=\"1.1 解题技巧\"></a>1.1 解题技巧</h3><ol>\n<li>先忽略掉不容易处理的特殊情况，只考虑正常情况，==简化==编程。</li>\n<li>写代码前先写注释，通过==注释==让代码模块化，让思路更清晰。</li>\n<li>写完代码多举几个==特例==，来验证代码是否正确。</li>\n</ol>\n<h3 id=\"1-2-解题步骤\"><a href=\"#1-2-解题步骤\" class=\"headerlink\" title=\"1.2 解题步骤\"></a>1.2 解题步骤</h3><ol>\n<li>举例读懂题意，梳理题目要求</li>\n<li>列出测试用例（测试驱动开发）</li>\n<li>总结归纳处理思路（把逻辑中重复出现部分抽象出来）</li>\n<li>第一轮编写代码（写注释，让代码模块化，逻辑更清晰）</li>\n<li>使用测试用例验证代码，并完善代码</li>\n</ol>\n<h3 id=\"1-3-例题\"><a href=\"#1-3-例题\" class=\"headerlink\" title=\"1.3 例题\"></a>1.3 例题</h3><table>\n<thead>\n<tr>\n<th>拼多多.IP地址解析</th>\n<th>1.两数之和</th>\n<th>1108.IP地址无效化</th>\n<th>344.反转字符串</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>剑指offer58-1</td>\n<td>125.验证回文串</td>\n<td>9.回文数</td>\n<td>58.最后一个单词长度</td>\n</tr>\n<tr>\n<td>剑指offer05</td>\n<td>剑指offer58-2</td>\n<td>26.删排序数组中重复项</td>\n<td>剑指offer67*</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"2-找规律题\"><a href=\"#2-找规律题\" class=\"headerlink\" title=\"2.找规律题\"></a>2.找规律题</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>题型说明：较常考，但不要花太多时间。难在找规律但编程实现简单</p></blockquote>\n<h3 id=\"2-1-解题技巧\"><a href=\"#2-1-解题技巧\" class=\"headerlink\" title=\"2.1 解题技巧\"></a>2.1 解题技巧</h3><p>==举例总结规律，猜想距离验证==</p>\n<p>​    先抛开它是一道算法题，抛开要用计算机编程实现。我们针对某个具体的例子，去思考如何解决，实际上，解决具体的例子就是一个小学数学题或者智力题。我们去通过解决多个例子，从中得到启发，总结出规律，总结出针对任何例子的通用解决方案，然后翻译成代码。</p>\n<h3 id=\"2-2-例题\"><a href=\"#2-2-例题\" class=\"headerlink\" title=\"2.2 例题\"></a>2.2 例题</h3><table>\n<thead>\n<tr>\n<th>钉钉22暑期实习：换啤酒</th>\n<th>剑指offer61.扑克牌中的顺子</th>\n<th>面试题01.08零矩阵</th>\n<th>面试题16.11跳水板</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>面试题01.05一次编辑</td>\n<td>面试题16.15珠玑妙算</td>\n<td>面试题16.04井字游戏</td>\n<td>55.跳跃游戏</td>\n</tr>\n<tr>\n<td>48.旋转图像*</td>\n<td>54.螺旋矩阵*</td>\n<td>240.搜索二维矩阵2*</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"3-数组和链表\"><a href=\"#3-数组和链表\" class=\"headerlink\" title=\"3.数组和链表\"></a>3.数组和链表</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>==数据结构==就是指一组数据的存储结构，==算法==就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。数据结构是静态的，如果不在数据结构上构建算法，那么孤立的数据结构是没有用的，</p></blockquote>\n<h3 id=\"3-1数组\"><a href=\"#3-1数组\" class=\"headerlink\" title=\"3.1数组\"></a>3.1数组</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>数组用一组连续的内存空间，来存储一组具有相同数据类型的数据。</p></blockquote>\n<ol>\n<li>数组的特点：按照下标快速访问数组元素。（基址加偏移量，其中偏移量=数据个数*数据大小）</li>\n<li>支持动态扩容的数组：==ArrayList==</li>\n<li>编程语言中的数组是一种数据类型，每种编程语言会结合自己语言的实现特点，对数组这种数据类型进行调整，并不会完全严格按照数据结构中数组的定义。</li>\n<li>基础知识：<ol>\n<li>定义：Array是一种线性表数据结构，它用一种连续的内存空间，来存储一组具有相同类型的数据。</li>\n<li>操作：高效的查找（支持随机访问）</li>\n<li>插入：有序，需要移动数据；无序，直接加，原数据移最后即可</li>\n<li>删除：可以不直接删除，标记一下，最后一起删除（JVM标记清除垃圾回收算法的核心思想）</li>\n<li>下标从0开始</li>\n<li>警惕数组的访问越界，循环时要注意判定条件：a[k]_address = base_address + k * type_size</li>\n<li>下标的确切定义是偏移，相对首地址偏移的量</li>\n<li>适用情况<ol>\n<li>基本类型（int，long）用数组</li>\n<li>数据大小事先知道，并且对数组的操作非常简单</li>\n<li>多维数据往往用多维数组更直观</li>\n</ol>\n</li>\n<li>容器与数组的关系：一般业务开发，如Java中ArrayList完全可以解决，但做一些非常底层的开发，为了做到极致的性能可以用数组</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-2链表\"><a href=\"#3-2链表\" class=\"headerlink\" title=\"3.2链表\"></a>3.2链表</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>链表用非连续的内存空间来存储数据，用过next指针将内存块串联在一起。==LinkedList为双向链表==</p></blockquote>\n<ol>\n<li>经典案例：LRU缓存淘汰算法<ol>\n<li><p>维护一个有序数组，越靠近链表尾部的节点是越早之前访问的，当有新的数据时，从头遍历，若已存在，则删掉重新插入到头部；若未存在，则可当内存满时删掉尾节点，插入到头部，内存未满直接插入到头部</p>\n</li>\n<li><p>其它缓存淘汰机制：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LRUCache &#123;\n    private class DLinkedNode&#123;\n        private int key;\n        private int value;\n        public DLinkedNode prev;\n        public DLinkedNode next;\n        public DLinkedNode(int key, int value)&#123;\n            this.key &#x3D; key;\n            this.value &#x3D; value;\n        &#125;\n    &#125;\n    private Map&lt;Integer,DLinkedNode&gt; hashtable &#x3D; new HashMap&lt;Integer, DLinkedNode&gt;();\n    private int size;\n    private int capacity;\n    private DLinkedNode head;\n    private DLinkedNode tail;\n\n    public LRUCache(int capacity) &#123;\n        this.size &#x3D; 0;\n        this.capacity &#x3D; capacity;\n        this.head &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.tail &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.head.prev &#x3D; null;\n        this.head.next &#x3D; tail;\n        this.tail.prev &#x3D; head;\n        this.tail.next &#x3D; null;\n    &#125;\n\n    public int get(int key)&#123; &#x2F;&#x2F;在缓存中查找数据\n        if (size &#x3D;&#x3D; 0)&#123;\n            return -1;\n        &#125;\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node &#x3D;&#x3D; null)&#123;\n            return -1;\n        &#125;\n        removeNode(node);\n        addNodeAtHead(node);\n        return node.value;\n    &#125;\n\n    public void remove(int key)&#123; &#x2F;&#x2F;从缓存中删除数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            removeNode(node);\n            hashtable.remove(key);\n        &#125;\n    &#125;\n\n    private void addNodeAtHead(DLinkedNode node) &#123;\n        node.next &#x3D; head.next;\n        head.next.prev &#x3D; node;\n        head.next &#x3D; node;\n        node.prev &#x3D; head;\n    &#125;\n\n    private void removeNode(DLinkedNode node) &#123;&#x2F;&#x2F;特殊情况（删除尾节点、删除最后一个节点））\n        node.next.prev &#x3D; node.prev;\n        node.prev.next &#x3D; node.next;\n    &#125;\n\n    public void put(int key, int value)&#123;&#x2F;&#x2F;往缓存中添加一个数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            node.value &#x3D; value;\n            removeNode(node);\n            addNodeAtHead(node);\n        &#125;\n        if (size &#x3D;&#x3D; capacity)&#123;\n            hashtable.remove(tail.prev.key);\n            removeNode(tail.prev);\n            size--;\n        &#125;\n        DLinkedNode newNode &#x3D; new DLinkedNode(key,value);\n        addNodeAtHead(newNode);\n        hashtable.put(key, newNode);\n        size++;\n    &#125;\n&#125;\n</code></pre></li>\n</ol>\n</li>\n<li>定义：通过“指针”将一组零散的内存块串联起来使用</li>\n<li>链表结构<ol>\n<li>单链表：数据data+后继指针next、尾节点指向null<ol>\n<li>基本操作：插入、删除、访问、遍历（回文字符串：快慢指针）</li>\n</ol>\n</li>\n<li>双向链表：前驱节点prev+ 数据data+后继指针next<ol>\n<li>空间换时间的思想</li>\n<li>入或删除给定指针指向的节点时，比单链表高效</li>\n<li>查询的效率也会更高，可以记录上次查到的节点</li>\n</ol>\n</li>\n<li>循环链表：尾节点指针指向头节点<ol>\n<li>从链尾到链头比较方便</li>\n<li>简化约瑟夫问题</li>\n</ol>\n</li>\n<li>双向循环链表</li>\n</ol>\n</li>\n<li>链表书写技巧<ol>\n<li>理解指针或引用的含义：将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量</li>\n<li>警惕指针缺失或内存泄漏</li>\n<li>在插入时一定要注意操作的顺序，在删除时，一定要记得手动释放内存空间</li>\n<li>利用哨兵简化实现难度</li>\n<li>解决边界问题，从而防止对特殊条件的判断。如插入第一个节点和删除最后一个节点</li>\n<li>在任何时候，不管链表是不是空，head指针都会一直指向这个哨兵节点，把这时的链表称为带头链表</li>\n<li>重点留意边界值处理<ol>\n<li>如果链表为空，代码是否能正常工作</li>\n<li>如果链表只包含一个节点时，代码是否能正常工作</li>\n<li>如果链表只包含两个节点时，代码是否能正常工作</li>\n<li>代码逻辑在处理头节点和尾节点时，是否能正常工作</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;LinkList\npublic class LinkList&#123;\n    public class Node&#123;\n        public int data;\n        public Node next;\n        public Node(int data, Node next)&#123;\n            this.data &#x3D; data;\n            this.next &#x3D; next;\n        &#125;\n    &#125;\n    private Node head &#x3D; null;\n    public void travel(Node node)&#123;\n        Node p &#x3D; head;\n        while(p!&#x3D;null)&#123;\n            &#x2F;&#x2F;处理p节点的数据\n            p &#x3D; p.next;\n        &#125;\n    &#125;\n    public Node find(int value)&#123;\n        Node p &#x3D; head;\n        while(p !&#x3D; null)&#123;\n            if(p.data &#x3D;&#x3D; value)\treturn p;\n            p &#x3D; p.next;\n        &#125;\n        return null;\n    &#125;\n    public void insertAtHead(int value)&#123;\n        Node newNode &#x3D; new Node(value,null);\n        newNode.next &#x3D; head;\n        head &#x3D; newNode;\n    &#125;\n    public void insetAtTail(int value)&#123;\n        Node newNode &#x3D; new Node(value, null);\n        if(head &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;优化2：添加虚拟head头节点&#x2F;哑节点&#x2F;哨兵节点，不需要考虑head &#x3D;&#x3D; null的情况\n            head &#x3D; newNode;\n        &#125;else&#123;\n            Node p &#x3D; head;\n            while(p.next !&#x3D; null)&#123;&#x2F;&#x2F;优化1：添加tail尾指针，但需要考虑空链表的特殊情况\n                p &#x3D; p.next;\n            &#125;\n            p.next &#x3D; newNode;\n        &#125;\n    &#125;\n    public void deleteNextNode(Node p)&#123;\n        if (p &#x3D;&#x3D; null || p.next &#x3D;&#x3D; null)&#123;return;&#125;\n\t\tp.next &#x3D; p.next.next;&#x2F;&#x2F;GC会回收        \n    &#125;\n    public void deleteNode(Node p)&#123;\n        if(p &#x3D;&#x3D; null || head &#x3D;&#x3D; null)&#123;return;&#125;\n        Node prev &#x3D; null;\n        Node q &#x3D; head;\n        while(q !&#x3D; null)&#123;\n            if(q &#x3D;&#x3D; p) break;\n            prev &#x3D; q;\n            q &#x3D; q.next;\n        &#125;\n        if(q &#x3D;&#x3D; null)return;&#x2F;&#x2F;没找到\n        if(prev &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;删除头节点\n            head &#x3D; head.next;\n        &#125;else&#123;&#x2F;&#x2F;删除非头节点\n            prev.next &#x3D; q.next;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"3-3题型\"><a href=\"#3-3题型\" class=\"headerlink\" title=\"3.3题型\"></a>3.3题型</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>题型有限，代码实现难，主要考编程能力，可能会出原题，经典题要写熟练！</p></blockquote>\n<h4 id=\"3-3-1-解题技巧\"><a href=\"#3-3-1-解题技巧\" class=\"headerlink\" title=\"3.3.1 解题技巧\"></a>3.3.1 解题技巧</h4><ol>\n<li>链表相关题目都会涉及遍历，核心是通过画图举例确定遍历的三要素<ol>\n<li>遍历的结束条件：p == null or p.next == null or …</li>\n<li>指针的初始值：p == head or …</li>\n<li>遍历的核心逻辑：视题目要求而定</li>\n</ol>\n</li>\n<li>特殊情况处理：是否需要对==头节点==、==尾节点==、==空链表==等做特殊处理？</li>\n<li>引入==虚拟节点==：是否可以通过添加虚拟节点简化编程？</li>\n</ol>\n<p>###3.4例题</p>\n<table>\n<thead>\n<tr>\n<th>203.移除链表元素</th>\n<th>876.链表的中间节点</th>\n<th>83.删除排序链表中的重复元素</th>\n<th>剑指offer25.合并排序链表</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2.两数相加</td>\n<td>206.反转链表</td>\n<td>234.回文链表</td>\n<td>328.奇偶链表</td>\n</tr>\n<tr>\n<td>25.K个一组翻转链表</td>\n<td>剑指offer22.链表倒数第K节点</td>\n<td>19.删除链表倒数第N结点</td>\n<td>160.相交链表</td>\n</tr>\n<tr>\n<td>141.环形链表</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"4-栈和队列\"><a href=\"#4-栈和队列\" class=\"headerlink\" title=\"4.栈和队列\"></a>4.栈和队列</h2><h3 id=\"4-1栈\"><a href=\"#4-1栈\" class=\"headerlink\" title=\"4.1栈\"></a>4.1栈</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>先进后出，后进先出，只允许在一端（栈顶）插入和删除数据，当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Stack&#123;\n    public void push(int data)&#123;...&#125;\n    public int pop()&#123;return -1;&#125;&#x2F;&#x2F;弹出栈\n    public int peek()&#123;...&#125;&#x2F;&#x2F;不弹出栈\n&#125;</code></pre>\n\n\n\n<h4 id=\"4-1-1-顺序栈\"><a href=\"#4-1-1-顺序栈\" class=\"headerlink\" title=\"4.1.1 顺序栈\"></a>4.1.1 顺序栈</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayStack&#123;&#x2F;&#x2F;基于数组实现的顺序栈\n    private int[] items;&#x2F;&#x2F;数组\n    private int count;&#x2F;&#x2F;栈中元素个数\n    private int n;&#x2F;&#x2F;栈的大小\n    public ArrayStack(int n)&#123;\n        this.items &#x3D; new int[n];&#x2F;&#x2F;申请一个大小为n的数组空间\n        this.count &#x3D; 0;\n        this.n &#x3D; n;\n    &#125;\n    public boolean push(int item)&#123;\n        if(count &#x3D;&#x3D; n) return false;&#x2F;&#x2F;数组空间不够用了，入栈失败\n        &#x2F;&#x2F;将item放到下标为count的位置，并且count加1\n        items[count] &#x3D; item;\n        ++count;\n        return true;\n    &#125;\n    public int pop()&#123;\n        if(count &#x3D;&#x3D; 0) return -1;&#x2F;&#x2F;栈为空，则直接返回-1\n        &#x2F;&#x2F;返回下标为count-1的数组元素，并且栈中元素个数count-1\n        int value &#x3D; items[count-1];\n        --count;\n        return value;\n    &#125;\n    public int peek()&#123;\n        if(count &#x3D;&#x3D; 0) return -1;&#x2F;&#x2F;栈为空，则直接返回-1\n        return items[count-1];\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"4-1-2-链式栈\"><a href=\"#4-1-2-链式栈\" class=\"headerlink\" title=\"4.1.2 链式栈\"></a>4.1.2 链式栈</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkedListStack&#123;\n    private class Node&#123;\n        public int data;\n        public Node next;\n        public Node(int data,Node next)&#123;\n            this.data &#x3D; data;\n            this.Node &#x3D; next;\n        &#125;\n    &#125;\t\n    private Node head &#x3D; Null;\n    \n    public void push(int value)&#123;\n        Node newNode &#x3D; new Node(value,null);\n        newNode.next &#x3D; head;\n        head &#x3D; newNode;\n    &#125;\n    public int pop()&#123;\n    \tif(head &#x3D;&#x3D; null) return -1;\n        int value &#x3D; head.data;\n        head &#x3D; head.next;\n        return value;\n    &#125;\n    public int peek()&#123;\n        if(head &#x3D;&#x3D; null) return -1;\n        return head.data;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"4-1-3经典应用\"><a href=\"#4-1-3经典应用\" class=\"headerlink\" title=\"4.1.3经典应用\"></a>4.1.3经典应用</h4><ol>\n<li>浏览器的前进和后退<ol>\n<li>两个栈，x和y，把首次浏览的页面压入栈x，当浏览器后退时，再依次从栈x中出栈，并压入栈y，当前进时再反过来</li>\n</ol>\n</li>\n<li>函数调用中的应用<ol>\n<li>我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</li>\n</ol>\n</li>\n<li>表达式求值<ol>\n<li>维护两个栈，一个保存操作数，一个保存运算符</li>\n</ol>\n</li>\n<li>括号匹配<ol>\n<li>看是否是一对对括号</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-2队列\"><a href=\"#4-2队列\" class=\"headerlink\" title=\"4.2队列\"></a>4.2队列</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>先进先出，后进后出，只允许在队列头部取出数据，尾部插入数据</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Queue&#123;\n    public boolean enqueue(String data)&#123;...&#125;\n    public String dequeue()&#123;...&#125;\n    public String peek()&#123;...&#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"4-2-1-循环队列\"><a href=\"#4-2-1-循环队列\" class=\"headerlink\" title=\"4.2.1 循环队列\"></a>4.2.1 循环队列</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CircularQueue&#123;\n    private String[] items;\n    private int n;\n    private int head &#x3D; 0;\n    private int tail &#x3D; 0;\n    \n    public CircularQueue(int n)&#123;\n        this.items &#x3D; new String[n];\n        this.n &#x3D; n;\n    &#125;\n    \n    public boolean enqueue(String item)&#123;\n        if((tail + 1) % n &#x3D;&#x3D; head) return false;&#x2F;&#x2F;空一个位置，即为队列满\n        items[tail] &#x3D; item;\n        tail &#x3D; (tail + 1) % n;\n        return true;\n    &#125;\n    \n    public String dequeue()&#123;\n        if(head &#x3D;&#x3D; tail) return null;&#x2F;&#x2F;队列空，两个指针指向同一个位置\n        String ret &#x3D; items[head];&#x2F;&#x2F;head指向第一个元素\n        head &#x3D; (head + 1 ) % n;\n        return ret;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h4 id=\"4-2-2-链表队列\"><a href=\"#4-2-2-链表队列\" class=\"headerlink\" title=\"4.2.2 链表队列\"></a>4.2.2 链表队列</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkedListQueue&#123;\n    private class Node&#123;\n        public String data;\n        public Node next;\n        public Node(String data,Node next)&#123;\n            this.data &#x3D; data;\n            this.next &#x3D; next;\n        &#125;\n    &#125;\n    private Node head &#x3D; null;\n    private Node tail &#x3D; null;\n    \n    public void enqueue(String value)&#123;\n        Node newNode &#x3D; new Node(value, null);\n        if(tail &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;空队列\n            head &#x3D; newNode;\n            tail &#x3D; newNode;\n        &#125;else&#123;\n            tail.next &#x3D; newNode;\n            tail &#x3D; newNode;\n        &#125;\n    &#125;\n    public String dequeue()&#123;\n        if(head &#x3D;&#x3D; null)&#123;&#x2F;&#x2F;空队列\n            return null;\n        &#125;\n        String value &#x3D; head.data;\n        head &#x3D; head.next;\n        if(head &#x3D;&#x3D; null)&#123;\n            tail &#x3D;&#x3D; null;\n        &#125;\n        return value;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"4-2-3经典应用\"><a href=\"#4-2-3经典应用\" class=\"headerlink\" title=\"4.2.3经典应用\"></a>4.2.3经典应用</h4><ol>\n<li>在线程池等有限资源池中，当线程池已满，再请求时，如何处理<ol>\n<li>非阻塞：直接拒绝</li>\n<li>阻塞：将请求排队等有空闲时再处理，用数组比用链表好</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-3题型\"><a href=\"#4-3题型\" class=\"headerlink\" title=\"4.3题型\"></a>4.3题型</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>栈和队列处于平等地位，但在面试中，栈的出题量远多于队列，队列的题目很少</p></blockquote>\n<h4 id=\"4-3-1细分题型\"><a href=\"#4-3-1细分题型\" class=\"headerlink\" title=\"4.3.1细分题型\"></a>4.3.1细分题型</h4><ol>\n<li>直接以栈为背景的题目：比如用栈实现队列、最小栈、栈排序</li>\n<li>连连消题目：字符串连连消、求表达式</li>\n<li>单调栈题目：栈延申出来的一种新的数据结构（不多，不怎么考，比较难）</li>\n</ol>\n<h4 id=\"4-3-2例题\"><a href=\"#4-3-2例题\" class=\"headerlink\" title=\"4.3.2例题\"></a>4.3.2例题</h4><table>\n<thead>\n<tr>\n<th>剑指offer9.用两个栈实现队列</th>\n<th>225.用队列实现栈</th>\n<th>面试题03.05栈排序</th>\n<th>155.最小栈</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>面试题03.01三合一</td>\n<td>20.有效的括号</td>\n<td>面试题16.26计算器</td>\n<td>772.基本计算器3</td>\n</tr>\n<tr>\n<td>1047删除字符串相邻重复项</td>\n<td>剑指offer31.栈的压入弹出序列</td>\n<td>739.每日温度</td>\n<td>42.接雨水</td>\n</tr>\n<tr>\n<td>84.柱状图中最大的矩形</td>\n<td>面试题03.06.动物收容所</td>\n<td>剑指59-2队列最大值</td>\n<td>剑指59-1滑动窗口最大值</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-分治和递归\"><a href=\"#5-分治和递归\" class=\"headerlink\" title=\"5.分治和递归\"></a>5.分治和递归</h2><h3 id=\"5-1概念\"><a href=\"#5-1概念\" class=\"headerlink\" title=\"5.1概念\"></a>5.1概念</h3><ol>\n<li>分治是一种思想，分而治之，具体到算法方面，就是将原问题划分成多个规模更小并且结构与原问题相同的子问题，先解决这些子问题，然后再合并其结果，就得到原问题的解。</li>\n<li>递归是一种编程技巧，一个函数自己调用自己。递归也具有结构相同，规模不同的特点，所以，涉及到用分治思想解决的问题，比较适合用递归来实现。</li>\n</ol>\n<p>==注：堆栈溢出常出现在工程中，解决方法：限制递归深度，或者改用非递归实现。==</p>\n<h3 id=\"5-2重复计算问题如何解决\"><a href=\"#5-2重复计算问题如何解决\" class=\"headerlink\" title=\"5.2重复计算问题如何解决\"></a>5.2重复计算问题如何解决</h3><ol>\n<li>运用备忘录：当有些全局变量需要定义的时候，我们可以在递归函数外侧嵌套一个非递归的壳。</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private int[] mem;\npublic int f(int n)&#123;\n    mem &#x3D; new int[n+1];\n    return f_r(n);\n&#125;\nprivate int f_r(int n)&#123;\n    if (n &#x3D;&#x3D; 1) return 1;\n    if (n &#x3D;&#x3D; 2) return 2;\n    if (mem[n] !&#x3D; 0) return mem[n];\n    mem[n] &#x3D; f_r(n-1) + f_r(n-2);\n    return mem[n];\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>可以考虑是否可以用动态规划（DP）解决：回溯这类递归代码</li>\n</ol>\n<h3 id=\"5-3编写递归代码的技巧\"><a href=\"#5-3编写递归代码的技巧\" class=\"headerlink\" title=\"5.3编写递归代码的技巧\"></a>5.3编写递归代码的技巧</h3><ol>\n<li>怎么发现这个问题可以用递归来做：<ul>\n<li>规模更小的问题，跟规模大点的问题，解决思路相同，但规模不同</li>\n<li>利用子问题的解可以组合得到原问题的解</li>\n<li>存在最小子问题，可以直接返回结果，即存在递归终止条件</li>\n</ul>\n</li>\n<li>递归的正确编写姿势：<ul>\n<li>我们可以假设子问题B,C已经解决，在此基础上思考如何解决原问题A，基于此，找递推公式+终止条件，然后翻译成代码</li>\n</ul>\n</li>\n</ol>\n<p>==注：千万不要试图想清楚整个递和归的执行过程，实际上是进入了一个思维误区==</p>\n<ol start=\"3\">\n<li>时间复杂度和空间复杂度分析：<ul>\n<li>时间复杂度：递推公式或者递归树</li>\n<li>空间复杂度：跟递归的函数调用栈最大深度成正比，即递归树的高度</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-4题型\"><a href=\"#5-4题型\" class=\"headerlink\" title=\"5.4题型\"></a>5.4题型</h3><ol>\n<li>解题技巧：寻找重复结构，是否能将问题结构转化成结构相同，规模更小的子问题，然后写递推公式，包括递归终止条件，然后翻译成代码。<ol>\n<li>原问题解决思路和子问题解决思路是否一样</li>\n<li>子问题的解能否构造出原问题的解（递推公式）</li>\n<li>找到最小子问题（终止条件）</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"6-排序\"><a href=\"#6-排序\" class=\"headerlink\" title=\"6.排序\"></a>6.排序</h2><h3 id=\"6-1排序算法总览\"><a href=\"#6-1排序算法总览\" class=\"headerlink\" title=\"6.1排序算法总览\"></a>6.1排序算法总览</h3><ol>\n<li>O（n^2）<ol>\n<li>冒泡排序：一对对比较，一对对交换</li>\n<li>插入排序：分为已排和未排区间，取未排插入到已排。例：希尔排序</li>\n<li>选择排序：分为已排和未排区间，从未排选一个最小的插入到已排的</li>\n<li>希尔排序</li>\n</ol>\n</li>\n<li>O（nlogn）<ol>\n<li>归并排序：“分治思想”，分而治之，然后再合并</li>\n<li>快速排序：选一个pivot，大的放左，小的放右</li>\n<li>堆排序：先将数组原地建成一个堆，从下往上堆化，取堆顶元素，将下标n的元素放到堆顶，堆化</li>\n<li>二叉排序树排序</li>\n</ol>\n</li>\n<li>O（n）<ol>\n<li>计数排序：例：10G数据，100个桶</li>\n<li>基数排序：高考成绩排序，760个桶</li>\n<li>桶排序：10万个手机号码排序，从个位开始一位位进行桶或基数排序</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-2排序算法细节\"><a href=\"#6-2排序算法细节\" class=\"headerlink\" title=\"6.2排序算法细节\"></a>6.2排序算法细节</h3><p>####冒泡排序</p>\n<ol>\n<li>原理：整个冒泡排序包括多趟冒泡操作，每一趟冒泡操作都会遍历整个数组，依次对数组相邻的元素进行比较，看是否满足大小关系要求，如果不满足，就将他们互换位置，一趟冒泡至少一个元素移动到他应该在的位置，重复n次，就完成了n个数据的排序工作。</li>\n<li>代码实现</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void bubbleSort(int[] a,int n)&#123;\n    if(n &lt;&#x3D; 1) return;\n    for(int i &#x3D; 0; i &lt; n ; ++i)&#123;&#x2F;&#x2F;第几趟冒泡\n        boolean flag &#x3D; false;\n        for(int j &#x3D; 0; j &lt; n-i-1 ; ++j)&#123;\n            if(a[j] &gt; a[j+1])&#123;&#x2F;&#x2F;交换（相等不交换，所以是稳定的排序算法）\n                int temp &#x3D; a[j];\n                a[j] &#x3D; a[j+1];\n                a[j+1] &#x3D; temp;\n                flag &#x3D; true;\n            &#125;\n        &#125;\n        if(!flag) break;&#x2F;&#x2F;没有数据交换，提前结束\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>时间复杂度：O(n^2)，依靠顺序度和逆序度来求比较和交换操作的平均时间复杂度</li>\n</ol>\n<p>####插入排序</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>==相等的不换：稳定的排序算法==</p></blockquote>\n<ol>\n<li><p>原理：将数组分为两个区间（已排序，未排序），初始已排序区间只有一个元素，就是数组中的第一个元素，每次去未排序区间的元素，在已排序区间中找到合适的插入位置将其插入，保证已排序区间一直有序，重复直到未排序区间元素为空。</p>\n</li>\n<li><p>代码实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void insertionSort(int[] a, int n) &#123;\n        if (n &lt;&#x3D; 1) return;\n\n        for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n            int value &#x3D; a[i];\n            int j &#x3D; i - 1;\n            &#x2F;&#x2F; 查找要插入的位置并移动数据\n            for (; j &gt;&#x3D; 0; --j) &#123;\n                if (a[j] &gt; value) &#123;\n                    a[j + 1] &#x3D; a[j];\n                &#125; else &#123;\n                    break;\n                &#125;\n            &#125;\n            a[j + 1] &#x3D; value;\n        &#125;\n    &#125;</code></pre>\n\n<ol start=\"3\">\n<li>时间复杂度：O(n^2)</li>\n</ol>\n</li>\n</ol>\n<p>####选择排序</p>\n<ol>\n<li>原理：选择排序算法实现类似于插入排序，也将整个数组划分为已排序区间和未排序区间，不同点在于：选择排序算法每次从未排序区间中，找到最小的元素，将其放到已排序区间的末尾。</li>\n<li>代码：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void selectionSort(int[] a,int n)&#123;\n    if(n &lt;&#x3D; 1) return;\n    for(int i &#x3D; 0; i &lt; n-1; ++i)&#123;\n        int minPos &#x3D; i;\n        for(int j &#x3D; i; j &lt; n; ++j)&#123;\n            if(a[j] &lt; a[minPos])&#123;&#x2F;&#x2F;非稳定算法，因为换了位置\n                minPos &#x3D; j;\n            &#125;\n        &#125;\n        int temp &#x3D; a[i];\n        a[i] &#x3D; a[minPos];\n        a[minPos] &#x3D; temp;\n    &#125;\n&#125;</code></pre>\n\n<p>3.时间复杂度：O(n^2)</p>\n<h4 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>==（重点）（稳定算法，merge有优先级）==</p></blockquote>\n<ol>\n<li>原理：分治的思想，采用递归实现。如果要排序一个数组，先把数组从中间分成前后两部分，然后，对前后两部分分别排序，再将排序好的两部分合并在一起，这样整个数组就都有序了。</li>\n<li>代码：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MergeSort &#123;\n    \n  &#x2F;&#x2F; 归并排序算法, a是数组，n表示数组大小\n  public static void mergeSort(int[] a, int n) &#123;\n    mergeSortInternally(a, 0, n-1);\n  &#125;\n\n  &#x2F;&#x2F; 递归调用函数\n  private static void mergeSortInternally(int[] a, int p, int r) &#123;\n    &#x2F;&#x2F; 递归终止条件\n    if (p &gt;&#x3D; r) return;\n\n    &#x2F;&#x2F; 取p到r之间的中间位置q,防止（p+r）的和超过int类型最大值\n    int q &#x3D; p + (r - p)&#x2F;2;\n    &#x2F;&#x2F; 分治递归\n    mergeSortInternally(a, p, q);\n    mergeSortInternally(a, q+1, r);\n\n    &#x2F;&#x2F; 将A[p...q]和A[q+1...r]合并为A[p...r]\n    merge(a, p, q, r);\n  &#125;\n\n  private static void merge(int[] a, int p, int q, int r) &#123;\n    int i &#x3D; p;\n    int j &#x3D; q+1;\n    int k &#x3D; 0; &#x2F;&#x2F; 初始化变量i, j, k\n    int[] tmp &#x3D; new int[r-p+1]; &#x2F;&#x2F; 申请一个大小跟a[p...r]一样的临时数组\n    while (i&lt;&#x3D;q &amp;&amp; j&lt;&#x3D;r) &#123;\n      if (a[i] &lt;&#x3D; a[j]) &#123;\n        tmp[k++] &#x3D; a[i++]; &#x2F;&#x2F; i++等于i:&#x3D;i+1\n      &#125; else &#123;\n        tmp[k++] &#x3D; a[j++];\n      &#125;\n    &#125;\n\n    &#x2F;&#x2F; 判断哪个子数组中有剩余的数据\n    int start &#x3D; i;\n    int end &#x3D; q;\n    if (j &lt;&#x3D; r) &#123;\n      start &#x3D; j;\n      end &#x3D; r;\n    &#125;\n\n    &#x2F;&#x2F; 将剩余的数据拷贝到临时数组tmp\n    while (start &lt;&#x3D; end) &#123;\n      tmp[k++] &#x3D; a[start++];\n    &#125;\n\n    &#x2F;&#x2F; 将tmp中的数组拷贝回a[p...r]\n    for (i &#x3D; 0; i &lt;&#x3D; r-p; ++i) &#123;\n      a[p+i] &#x3D; tmp[i];\n    &#125;\n  &#125;\n\n  &#x2F;**\n   * 合并(哨兵)\n   *&#x2F;\n  private static void mergeBySentry(int[] arr, int p, int q, int r) &#123;\n    int[] leftArr &#x3D; new int[q - p + 2];\n    int[] rightArr &#x3D; new int[r - q + 1];\n\n    for (int i &#x3D; 0; i &lt;&#x3D; q - p; i++) &#123;\n      leftArr[i] &#x3D; arr[p + i];\n    &#125;\n    &#x2F;&#x2F; 第一个数组添加哨兵（最大值）\n    leftArr[q - p + 1] &#x3D; Integer.MAX_VALUE;\n\n    for (int i &#x3D; 0; i &lt; r - q; i++) &#123;\n      rightArr[i] &#x3D; arr[q + 1 + i];\n    &#125;\n    &#x2F;&#x2F; 第二个数组添加哨兵（最大值）\n    rightArr[r-q] &#x3D; Integer.MAX_VALUE;\n\n    int i &#x3D; 0;\n    int j &#x3D; 0;\n    int k &#x3D; p;\n    while (k &lt;&#x3D; r) &#123;\n      &#x2F;&#x2F; 当左边数组到达哨兵值时，i不再增加，直到右边数组读取完剩余值，同理右边数组也一样\n      if (leftArr[i] &lt;&#x3D; rightArr[j]) &#123;\n        arr[k++] &#x3D; leftArr[i++];\n      &#125; else &#123;\n        arr[k++] &#x3D; rightArr[j++];\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>时间复杂度分析：<ul>\n<li>递推公式：T(n) = T(n/2) + T(n/2) +n 和 T(1) = C</li>\n<li>递归树：O（nlogn）每层和为n个数据，一共log2n层</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"快速排序（重点）\"><a href=\"#快速排序（重点）\" class=\"headerlink\" title=\"快速排序（重点）\"></a>快速排序（重点）</h4><ol>\n<li>原理：先找pivot，再按pivot划分，依靠分治思想进行继续对前后两部分进行划分并排序。</li>\n<li>代码：</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class QuickSort &#123;\n\n  &#x2F;&#x2F; 快速排序，a是数组，n表示数组的大小\n  public static void quickSort(int[] a, int n) &#123;\n    quickSortInternally(a, 0, n-1);\n  &#125;\n\n  &#x2F;&#x2F; 快速排序递归函数，p,r为下标\n  private static void quickSortInternally(int[] a, int p, int r) &#123;\n    if (p &gt;&#x3D; r) return;\n\n    int q &#x3D; partition(a, p, r); &#x2F;&#x2F; 获取分区点\n    quickSortInternally(a, p, q-1);\n    quickSortInternally(a, q+1, r);\n  &#125;\n\n  private static int partition(int[] a, int p, int r) &#123;\n    int pivot &#x3D; a[r];\n    int i &#x3D; p;\n    for(int j &#x3D; p; j &lt; r; ++j) &#123;\n      if (a[j] &lt; pivot) &#123;\n        if (i &#x3D;&#x3D; j) &#123;\n          ++i;\n        &#125; else &#123;\n          int tmp &#x3D; a[i];\n          a[i++] &#x3D; a[j];\n          a[j] &#x3D; tmp;\n        &#125;\n      &#125;\n    &#125;\n\n    int tmp &#x3D; a[i];\n    a[i] &#x3D; a[r];\n    a[r] &#x3D; tmp;\n\n    System.out.println(&quot;i&#x3D;&quot; + i);\n    return i;\n  &#125;\n&#125;</code></pre>\n\n<ol>\n<li><p>桶排序（海量数据处理）</p>\n</li>\n<li><p>计数排序（没什么用）</p>\n</li>\n<li><p>基数排序（排序算法的稳定性）：多种指标按优先级排序</p>\n</li>\n</ol>\n<h3 id=\"6-3题型\"><a href=\"#6-3题型\" class=\"headerlink\" title=\"6.3题型\"></a>6.3题型</h3><ol>\n<li>特殊排序：不是单纯的增减顺序，而是有一些特殊要求</li>\n<li>Top K：找到前K个大的，第K个大的……</li>\n<li>链表上的排序：数据结构由数组转换为链表，并进行排序</li>\n<li>排序预处理：排序只是问题的一部分预处理，可以运用库函数</li>\n<li>区间问题：（252题、56题） 先排序，再处理</li>\n</ol>\n<h2 id=\"7-二分查找\"><a href=\"#7-二分查找\" class=\"headerlink\" title=\"7.二分查找\"></a>7.二分查找</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>针对一个有序的数据集合，查找思想类似于分治，每次通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到要查找的元素或区间被缩小为0。局限：要是数组组织的有序数据，数据量不能过大也不能过小</p></blockquote>\n<h3 id=\"7-1原理\"><a href=\"#7-1原理\" class=\"headerlink\" title=\"7.1原理\"></a>7.1原理</h3><p>​    又叫折半查找，在有序数组中快速查找元素，找中值比较，选择前或后某一部分，继续进行二分查找</p>\n<h4 id=\"7-1-1其它查找\"><a href=\"#7-1-1其它查找\" class=\"headerlink\" title=\"7.1.1其它查找\"></a>7.1.1其它查找</h4><ol>\n<li><p>B树、B+树</p>\n<ol>\n<li>定义：m叉树m个分支m-1个关键字；若根不是终端则至少两颗子树；除根节点外所有非叶至少m/2上取整颗子树</li>\n<li>B树不支持顺序查找，B+树支持顺序查找</li>\n<li>B树删除：兄弟够借（&gt;=2）就左旋借一圈；左右兄弟都不够借，父节点下来一个跟兄弟合并</li>\n</ol>\n</li>\n<li><p>Hash查找</p>\n<ol>\n<li>开放地址法（探测到表尾从表头起）&amp;拉链法</li>\n<li>线性探测：+K；= 线形探测再散列</li>\n<li>二次探测：冲突时按+1、-1、+4、-4、+9、-9</li>\n<li>如果m=13，ASL成功：除表中数据个数；ASL失败：除能映射到的地址个数！！！</li>\n<li>开放地址法删除：只做标记，不删除</li>\n<li>装填因子：表中记录数/散列表长度</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"7-2代码实现\"><a href=\"#7-2代码实现\" class=\"headerlink\" title=\"7.2代码实现\"></a>7.2代码实现</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BinarySearch &#123;\n\n    &#x2F;**\n     * 搜索区间：闭区间\n     * 循环结束条件：low &lt;&#x3D; high\n     * 更新：low，high\n     * 返回值：mid\n     * @param a\n     * @param n\n     * @param value\n     * @return\n     *&#x2F;\n    public int BiSearch(int[] a, int n, int value) &#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        while (low &lt;&#x3D; high) &#123;\n            int mid &#x3D; ( low + high ) &#x2F; 2;\n            if (a[mid] &#x3D;&#x3D; value)&#123;\n                return mid;\n            &#125;else if (a[mid] &lt; value) &#123;\n                low &#x3D; mid - 1;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n\n    &#x2F;**\n     * \n     * @param a\n     * @param n\n     * @param value\n     * @return\n     *&#x2F;\n    public int BiSearchRecur(int[] a, int n, int value) &#123;\n        return BiSearchRecur(a,0,n-1,value);\n    &#125;\n    public int BiSearchRecur(int[] a, int low, int high, int value)&#123;\n        if (low &gt; high) &#123;\n            return -1;\n        &#125;\n        int mid &#x3D; (low + high) &#x2F; 2;\n        if (a[mid] &#x3D;&#x3D; value)&#123;\n            return mid;\n        &#125;else if (a[mid] &lt; value)&#123;\n            return BiSearchRecur(a,mid+1, high, value);\n        &#125;else &#123;\n            return BiSearchRecur(a, low, mid-1, value);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"7-3复杂度分析\"><a href=\"#7-3复杂度分析\" class=\"headerlink\" title=\"7.3复杂度分析\"></a>7.3复杂度分析</h3><ol>\n<li>时间复杂度：<ul>\n<li>递推公式：T(n) = T(n/2) + C</li>\n<li>递归树：O(logn)</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"7-4题型\"><a href=\"#7-4题型\" class=\"headerlink\" title=\"7.4题型\"></a>7.4题型</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>重点题型，大部分都是变形二分查找或二分答案，代码不长，但容易写对。难点在于：确定搜索区间，循环条件，区间更新，返回值。</p></blockquote>\n<h4 id=\"7-4-1解题技巧\"><a href=\"#7-4-1解题技巧\" class=\"headerlink\" title=\"7.4.1解题技巧\"></a>7.4.1解题技巧</h4><ol>\n<li>查找区间永远是闭区间[low,high]</li>\n<li>循环条件永远是：low &lt;= high</li>\n<li>对于low == high的情况，必要的时候特殊处理，在while内部补充退出条件</li>\n<li>返回值永远是mid，而不是low，high</li>\n<li>low、high的更新永远是low = mid + 1和high = mid - 1</li>\n<li>对于非确定性查找，使用前后探测法，来确定搜索区间（不用while，而只更新low或high）</li>\n<li>先处理命中情况，再处理在左右半部分查找的情况</li>\n</ol>\n<p>==注：非确定查找：第一个、最后一个、第一个大于等于、最后一个小于等于、循环数组寻找最小值、寻找峰值==</p>\n<h4 id=\"7-4-2题型\"><a href=\"#7-4-2题型\" class=\"headerlink\" title=\"7.4.2题型\"></a>7.4.2题型</h4><p>例题一：查找第一个等于x，最后一个等于x的元素</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int BiSearch(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &#x3D;&#x3D; target) &#123;\n                \n                &#x2F;&#x2F;第一个等于\n                if (mid &#x3D;&#x3D; 0 || a[mid-1] !&#x3D; target) &#123; return mid;&#125;\n                else &#123;high &#x3D; mid - 1;&#125;\n                \n                &#x2F;&#x2F;最后一个等于\n&#x2F;&#x2F;                    if (mid &#x3D;&#x3D; n - 1  || a[mid+1] !&#x3D; target) &#123; return mid; &#125;\n&#x2F;&#x2F;                    else &#123; low &#x3D; mid + 1; &#125;\n                \n            &#125;else if (a[mid] &lt; target)&#123;\n                low &#x3D; mid + 1;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;</code></pre>\n\n\n\n<p>例题二：查找第一个大于等于x，最后一个小于等于x的元素</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int BiSearch(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &gt;&#x3D; target)&#123;\n                if (mid &#x3D;&#x3D; 0 || a[mid-1] &lt; target)&#123;\n                     return mid;\n                &#125;else &#123;\n                    high &#x3D; mid - 1;\n                &#125;\n            &#125;else &#123;\n                low &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\npublic int BiSearch2(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &lt;&#x3D; target)&#123;\n                if (mid &#x3D;&#x3D; n-1 || a[mid+1] &gt; target)&#123;\n                     return mid;\n                &#125;else &#123;\n                    low &#x3D; mid + 1;\n                &#125;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;</code></pre>\n\n\n\n<p>例题三：循环有序数组中查找元素x（33题无重复，81题有重复）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int BiSearch(int[] a, int n, int target)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (a[mid] &#x3D;&#x3D; target) &#123;\n                return mid;\n            &#125;else if (a[low] &lt;&#x3D; a[mid]) &#123; &#x2F;&#x2F;左有序\n                if (a[low] &lt;&#x3D; target &amp;&amp; target &lt; a[mid])&#123;\n                    high &#x3D; mid -1;\n                &#125;else &#123;\n                    low &#x3D; mid + 1;\n                &#125;\n            &#125;else &#123;\n                if ( a[mid] &lt; target &amp;&amp; a[mid] &lt;&#x3D; a[high])&#123;\n                    low &#x3D; mid + 1;\n                &#125;else &#123;\n                    high &#x3D; mid - 1;\n                &#125;\n            &#125;\n        &#125;\n        return -1;\n    &#125;</code></pre>\n\n\n\n<p>例题四：循环有序数组中查找最小元素（153题无重复，154题有重复）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int BiSearch(int[] a, int n)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (low &#x3D;&#x3D; high)&#123;\n                return mid;\n            &#125;\n            if ((mid &#x3D;&#x3D; 0 &amp;&amp; a[mid] &lt; a[high]) \n                    ||(mid !&#x3D; 0 &amp;&amp; a[mid-1] &gt; a[mid]))&#123;\n                return mid;\n            &#125;else if (a[mid] &gt; a[high])&#123;&#x2F;&#x2F;右循环有序\n                low &#x3D; mid + 1;\n            &#125;else &#123;\n                high &#x3D; mid - 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;</code></pre>\n\n\n\n<p>例题五：查找峰值（852题）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int BiSearch(int[] a, int n)&#123;\n        int low &#x3D; 0;\n        int high &#x3D; n-1;\n        int mid;\n        while (low &lt;&#x3D; high)&#123;\n            mid &#x3D; low + (high-low)&#x2F;2;\n            if (mid &#x3D;&#x3D; 0)&#123;\n                low &#x3D; mid + 1;\n            &#125;else if (mid &#x3D;&#x3D; n-1)&#123;\n                high &#x3D; mid - 1;\n            &#125;else if (a[mid] &gt; a[mid-1] &amp;&amp; a[mid] &gt; a[mid+1])&#123;\n                return mid;\n            &#125;else if (a[mid] &gt; a[mid-1])&#123;\n                low &#x3D; mid + 1;\n            &#125;else &#123;\n                high &#x3D; mid -1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\t</code></pre>\n\n\n\n<p>例题六：二分答案（69题）</p>\n<h2 id=\"8-哈希表\"><a href=\"#8-哈希表\" class=\"headerlink\" title=\"8.哈希表\"></a>8.哈希表</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>散列表用的就是数组支持O（1）的随机访问特性，通过散列函数把元素的健值映射为下标，然后将数据存储在数组对应下标的位置。工业级散列表（Java中的HashMap源代码）</p></blockquote>\n<h3 id=\"8-1基础知识\"><a href=\"#8-1基础知识\" class=\"headerlink\" title=\"8.1基础知识\"></a>8.1基础知识</h3><ol>\n<li><p>概念：==查找、tong’ji==</p>\n</li>\n<li><p>哈希冲突解决办法：</p>\n<ol>\n<li>链表法：链表、红黑树、跳表</li>\n<li>开放寻址法：线性探测、二次探测、双重哈希</li>\n</ol>\n</li>\n<li><p>动态扩容：</p>\n<ol>\n<li>因为哈希冲突的存在，哈希表的性能会因为装入数据的个数增加而降低，所以当哈希表性能下降到一定程度之后，就会触发扩容。其中这个参考指标称为装载因子（数据个数 / 槽的个数）。</li>\n<li>当达到阈值时，可以申请一个更大的哈希表，并将原哈希表数据重新计算hash值并搬移到新的哈希表（可以均摊到之后每次新数据插入操作，来避免集中扩容）。</li>\n</ol>\n</li>\n<li><p>Java中的HashMap和HashSet：Map和Set为业务意义，其中Map意味着键值对(key,value)，Set意味着键(key)的无重复集合，并且两者都是对哈希表的封装</p>\n</li>\n<li><p>Hash查找</p>\n<ul>\n<li>开放地址法（探测到表尾从表头起）&amp;拉链法</li>\n<li>线性探测：+K；= 线形探测再散列</li>\n<li>二次探测：冲突时按+1、-1、+4、-4、+9、-9</li>\n<li>如果m=13，ASL成功：除表中数据个数；ASL失败：除能映射到的地址个数！！！</li>\n<li>开放地址法删除：只做标记，不删除</li>\n<li>装填因子：表中记录数/散列表长度</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"8-2哈希表的扩展\"><a href=\"#8-2哈希表的扩展\" class=\"headerlink\" title=\"8.2哈希表的扩展\"></a>8.2哈希表的扩展</h3><ol>\n<li><p>位图：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BiMap &#123;\n    private char[] a;\n    private int nBits;\n\n    public BiMap(int nBits)&#123;\n        this.nBits &#x3D; nBits;\n        this.a &#x3D; new char[(nBits-1)&#x2F;16+1];\n    &#125;\n    public void set(int k)&#123;\n        if (k&gt;nBits) &#123;\n            return;\n        &#125;\n        int charIndex &#x3D; k &#x2F; 16;\n        int biIndex &#x3D; k % 16;\n        a[charIndex] |&#x3D; (1 &lt;&lt; biIndex);\n    &#125;\n    public boolean get(int k)&#123;\n        if (k &gt; nBits) &#123;\n            return false;\n        &#125;\n        int charIndex &#x3D; k &#x2F; 16;\n        int biIndex &#x3D; k % 16;\n        return ( a[charIndex] &amp; (1 &lt;&lt; biIndex) ) !&#x3D; 0;\n    &#125;\n&#125;</code></pre></li>\n<li><p>布隆过滤器：类似于位图，但空间不是一一对应，而是多个数据会共用同一个位，这样当位为true时，该数据可能存在，但当位为false时，该数据一定不存在，可以减少数据读取所耗时。</p>\n</li>\n<li><p>LRU缓存：缓存主要包含3个操作：在缓存中查找一个数据；从缓存中删除一个数据；往缓存中添加一个数据（基于哈希表来快速查找，双向有序链表维护数据有序性的实现方案）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package main.java;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LRUCache &#123;\n    private class DLinkedNode&#123;\n        private int key;\n        private int value;\n        public DLinkedNode prev;\n        public DLinkedNode next;\n        public DLinkedNode(int key, int value)&#123;\n            this.key &#x3D; key;\n            this.value &#x3D; value;\n        &#125;\n    &#125;\n    private Map&lt;Integer,DLinkedNode&gt; hashtable &#x3D; new HashMap&lt;Integer, DLinkedNode&gt;();\n    private int size;\n    private int capacity;\n    private DLinkedNode head;\n    private DLinkedNode tail;\n\n    public LRUCache(int capacity) &#123;\n        this.size &#x3D; 0;\n        this.capacity &#x3D; capacity;\n        this.head &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.tail &#x3D; new DLinkedNode(-1, -1);&#x2F;&#x2F;guard node\n        this.head.prev &#x3D; null;\n        this.head.next &#x3D; tail;\n        this.tail.prev &#x3D; head;\n        this.tail.next &#x3D; null;\n    &#125;\n\n    public int get(int key)&#123; &#x2F;&#x2F;在缓存中查找数据\n        if (size &#x3D;&#x3D; 0)&#123;\n            return -1;\n        &#125;\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node &#x3D;&#x3D; null)&#123;\n            return -1;\n        &#125;\n        removeNode(node);\n        addNodeAtHead(node);\n        return node.value;\n    &#125;\n\n    public void remove(int key)&#123; &#x2F;&#x2F;从缓存中删除数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            removeNode(node);\n            hashtable.remove(key);\n        &#125;\n    &#125;\n\n    private void addNodeAtHead(DLinkedNode node) &#123;\n        node.next &#x3D; head.next;\n        head.next.prev &#x3D; node;\n        head.next &#x3D; node;\n        node.prev &#x3D; head;\n    &#125;\n\n    private void removeNode(DLinkedNode node) &#123;&#x2F;&#x2F;特殊情况（删除尾节点、删除最后一个节点））\n        node.next.prev &#x3D; node.prev;\n        node.prev.next &#x3D; node.next;\n    &#125;\n\n    public void put(int key, int value)&#123;&#x2F;&#x2F;往缓存中添加一个数据\n        DLinkedNode node &#x3D; hashtable.get(key);\n        if (node !&#x3D; null)&#123;\n            node.value &#x3D; value;\n            removeNode(node);\n            addNodeAtHead(node);\n        &#125;\n        if (size &#x3D;&#x3D; capacity)&#123;\n            hashtable.remove(tail.prev.key);\n            removeNode(tail.prev);\n            size--;\n        &#125;\n        DLinkedNode newNode &#x3D; new DLinkedNode(key,value);\n        addNodeAtHead(newNode);\n        hashtable.put(key, newNode);\n        size++;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"8-3题型\"><a href=\"#8-3题型\" class=\"headerlink\" title=\"8.3题型\"></a>8.3题型</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>重点，但题不难，只是一个配角为了提高查找效率，大部分可以直接使用编程语言现有的实现类</p></blockquote>\n<p>纯粹考察哈希表的题目不难，也不多。大部分情况下，哈希表只不过是一个小配角，配合解决其他算法类型的题目。用到哈希表的场景也比较明确，就是为了提高查找效率，让查找的时间复杂度降为O(1)，</p>\n<p>例题：LRU缓存</p>\n<h2 id=\"9-二叉树\"><a href=\"#9-二叉树\" class=\"headerlink\" title=\"9.二叉树\"></a>9.二叉树</h2><h3 id=\"9-1二叉树的前中后序遍历\"><a href=\"#9-1二叉树的前中后序遍历\" class=\"headerlink\" title=\"9.1二叉树的前中后序遍历\"></a>9.1二叉树的前中后序遍历</h3><ol>\n<li>递归</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void preOrder(Node root)&#123;\n    if(root &#x3D;&#x3D; null) return;\n    System.out.println(root.data);\n    preOrder(root.left);\n    preOrder(root.right);\n&#125; \npublic void inOrder(Node root)&#123;\n    if(root &#x3D;&#x3D; null) return;\n    inOrder(root.left);\n    System.out.println(root.data);\n    inOrder(root.right);\n&#125;\npublic void postOrder(Node root)&#123;\n    if(root &#x3D;&#x3D; null) return;\n    postOrder(root.left);\n    postOrder(root.right);\n    System.out.println(root.data);\n&#125;\n</code></pre>\n\n<ol start=\"2\">\n<li>非递归</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n        private class TreeNode &#123;\n            int val;\n            TreeNode left;\n            TreeNode right;\n            TreeNode(int x) &#123;\n                val &#x3D; x;\n            &#125;\n        &#125;\n        private class SFrame&#123;\n            public int status &#x3D; 1;\n            public TreeNode node &#x3D; null;\n            public SFrame(int status,TreeNode node)&#123;\n                this.status &#x3D; status;\n                this.node &#x3D; node;\n            &#125;\n        &#125;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        public List&lt;Integer&gt; preOrderTraversal(TreeNode root)&#123;\n            if (root &#x3D;&#x3D; null)&#123;\n                return result;\n            &#125;\n            Stack&lt;SFrame&gt; stack &#x3D; new Stack&lt;&gt;();\n            stack.push(new SFrame(1,root));\n            while (!stack.isEmpty())&#123;\n                if (stack.peek().status &#x3D;&#x3D; 1)&#123;\n                    result.add(stack.peek().node.val);&#x2F;&#x2F;前序\n                    stack.peek().status &#x3D; 2;\n                    if (stack.peek().node.left !&#x3D; null)&#123;\n                        stack.push(new SFrame(1,stack.peek().node.left));\n                    &#125;\n                    continue;\n                &#125;\n                if (stack.peek().status &#x3D;&#x3D; 2)&#123;\n&#x2F;&#x2F;                    result.add(stack.peek().node.val);&#x2F;&#x2F;中序\n                    stack.peek().status &#x3D; 3;\n                    if (stack.peek().node.right !&#x3D; null)&#123;\n                        stack.push(new SFrame(1,stack.peek().node.right));\n                    &#125;\n                    continue;\n                &#125;\n                if (stack.peek().status &#x3D;&#x3D; 3)&#123;\n&#x2F;&#x2F;                    result.add(stack.peek().node.val);&#x2F;&#x2F;后序\n                    stack.pop();\n                &#125;\n            &#125;\n            return result;\n        &#125;\n    &#125;\n\n</code></pre>\n\n<ol start=\"3\">\n<li>层次遍历</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;层次遍历（链队列）\n&#x2F;&#x2F;层次遍历易于找到某节点的父节点\nclass Solution &#123;\n        private class TreeNode &#123;\n            int val;\n            TreeNode left;\n            TreeNode right;\n            TreeNode(int x) &#123;\n                val &#x3D; x;\n            &#125;\n        &#125;\n        private List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;\n            dfs(root,0);\n            return result;\n        &#125;\n        private void dfs(TreeNode root,int level)&#123;\n            if (root &#x3D;&#x3D; null)&#123;\n                return;\n            &#125;\n            if(level &gt; result.size()-1)&#123;\n                result.add(new ArrayList&lt;&gt;());\n            &#125;\n            result.get(level).add(root.val);\n            dfs(root.left,level+1);\n            dfs(root.right,level+1);\n        &#125;\n    &#125;\n\n&#x2F;&#x2F;求高度（非递归层次遍历）\nint Btdepth(BiTree T)&#123;\n    if（!T)\n        return 0;\n    int front&#x3D;-1,rear&#x3D;-1;\n    int last&#x3D;0,level&#x3D;0;\n    BiTree Q[MaxSize];&#x2F;&#x2F;线形队列\n    Q[++rear] &#x3D; T;\n    BiTree p;\n    while(front&lt;rear)&#123;\n        p&#x3D;Q[++front];\n        if(p-&gt;lchild)\n            Q[++rear]&#x3D;p-&gt;lchild;\n        if(p-&gt;rchild)\n            Q[++rear]&#x3D;p-&gt;rchild;\n        if(front&#x3D;&#x3D;last)&#123;\n            level++;\n            last&#x3D;rear;&#x2F;&#x2F;下一层最右端节点\n        &#125;\n    &#125;\n    return level;\n&#125;\n\n&#x2F;&#x2F;求层数（递归）\nint depth(BiTree T,int level)&#123;\n    if(T)&#123;\n        if(T-&gt;lchild)\n            depth(T-&gt;lchild,++level);\n            level—-;\n        if(T-&gt;rchild)\n            depth(T-&gt;rchild,++level);\n            level—-;\n    &#125;\n    &#x2F;&#x2F;level初值为0，此时level即为层数\n&#125;\n</code></pre>\n\n\n\n<h3 id=\"9-2二叉查找树-BST-的查找，插入，删除\"><a href=\"#9-2二叉查找树-BST-的查找，插入，删除\" class=\"headerlink\" title=\"9.2二叉查找树(BST)的查找，插入，删除\"></a>9.2二叉查找树(BST)的查找，插入，删除</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>二叉查找树中序遍历结果有序，是从小到大的排列</p></blockquote>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import java.util.TreeSet;\n\npublic class BST &#123;\n\n    public static class Node &#123;\n        private int data;\n        private Node left;\n        private Node right;\n\n        public Node(int data) &#123;\n            this.data &#x3D; data;\n            left &#x3D; null;\n            right &#x3D; null;\n        &#125;\n    &#125;\n\n    public void insertReverse(Node root, int data) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            root &#x3D; new Node(data);\n            return;\n        &#125;\n        insert_r(root, data);\n    &#125;\n\n    public void insert_r(Node root, int data) &#123;\n        if (data &gt; root.data) &#123;\n            if (root.right &#x3D;&#x3D; null) &#123;\n                root.right &#x3D; new Node(data);\n            &#125; else &#123;\n                insert_r(root.right, data);\n            &#125;\n        &#125; else &#123;\n            if (root.left &#x3D;&#x3D; null) &#123;\n                root.left &#x3D; new Node(data);\n            &#125; else &#123;\n                insert_r(root.left, data);\n            &#125;\n        &#125;\n    &#125;\n\n    public void insert(Node root, int data) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            root &#x3D; new Node(data);\n            return;\n        &#125;\n        Node p &#x3D; root;\n        while (p !&#x3D; null) &#123;\n            if (data &gt; p.data) &#123;\n                if (p.right &#x3D;&#x3D; null) &#123;\n                    p.right &#x3D; new Node(data);\n                    return;\n                &#125;\n                p &#x3D; p.right;\n            &#125; else &#123;\n                if (p.left &#x3D;&#x3D; null) &#123;\n                    p.left &#x3D; new Node(data);\n                    return;\n                &#125;\n                p &#x3D; p.left;\n            &#125;\n        &#125;\n    &#125;\n\n    public Node find_r(Node root, int data) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        if (root.data &#x3D;&#x3D; data) &#123;\n            return root;\n        &#125;\n        if (root.data &gt; data) &#123;\n            return find_r(root.left, data);\n        &#125; else &#123;\n            return find_r(root.right, data);\n        &#125;\n    &#125;\n\n    public Node find(Node root, int data) &#123;\n        Node p &#x3D; root;\n        while (p !&#x3D; null) &#123;\n            if (p.data &gt; data)&#123;\n                p &#x3D; p.left;\n            &#125;else if (p.data &lt; data)&#123;\n                p &#x3D; p.right;\n            &#125;else &#123;\n                return p;\n            &#125;\n        &#125;\n        return null;\n    &#125;\n\n    public void delete(Node root,int data)&#123;\n        Node p &#x3D; root;\n        Node pp &#x3D; null;\n        while (p !&#x3D; null &amp;&amp; p.data !&#x3D; data)&#123;&#x2F;&#x2F;找到要删除的节点和其父节点\n            pp &#x3D; p;\n            if (data &gt; p.data)&#123;\n                p &#x3D; p.right;\n            &#125;\n            else &#123;\n                p &#x3D; p.left;\n            &#125;\n        &#125;\n        if (p &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        if (p.left !&#x3D; null &amp;&amp; p.right !&#x3D; null)&#123;&#x2F;&#x2F;两个子节点\n            Node minP &#x3D; p.right;\n            Node minPP &#x3D; p;\n            while (minP.left !&#x3D; null)&#123;\n                minPP &#x3D; minP;\n                minP &#x3D; minP.left;\n            &#125;\n            p.data &#x3D; minP.data;\n            p &#x3D; minP;\n            pp &#x3D; minPP;\n        &#125;\n        Node child &#x3D; null;&#x2F;&#x2F;查找删除节点的子节点\n        if (p.left !&#x3D; null)&#123;\n            child &#x3D; p.left;\n        &#125;else if (p.right !&#x3D; null)&#123;\n            child &#x3D; p.right;\n        &#125;\n\n        if (pp &#x3D;&#x3D; null)&#123;\n            root &#x3D; child;&#x2F;&#x2F;删除的是根节点\n        &#125;else if (pp.left &#x3D;&#x3D; p)&#123;\n            pp.left &#x3D; child;\n        &#125;else &#123;\n            pp.right &#x3D; child;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">void JudgeAVL(BiTree bt,int &amp;balance,int &amp;h)&#123;\n    int bl&#x3D;0,br&#x3D;0,hl&#x3D;0,hr&#x3D;0;\n    if(btNULL)&#123;\n        h&#x3D;0;\n        balance&#x3D;1;\n    &#125;\n    else if(bt-&gt;lchildNULL&amp;&amp;bt-&gt;rchild&#x3D;&#x3D;NULL)&#123;\n        h&#x3D;1;\n        balance&#x3D;1;\n    &#125;\n    else&#123;\n        JudgeAVL(bt-&gt;lchild,bl,hl);\n        JudgeAVL(bt-&gt;rchild,br,hr);\n        h&#x3D;(hl&gt;hr?hl:hr)+1;\n        if(abs(hl-hr)&lt;2)&#x2F;&#x2F;本层平衡\n            balance&#x3D;bl&amp;&amp;br;&#x2F;&#x2F;子树平衡\n        else\n            balance&#x3D;0;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"9-3平衡二叉查找树BBST，平衡二叉树AVL\"><a href=\"#9-3平衡二叉查找树BBST，平衡二叉树AVL\" class=\"headerlink\" title=\"9.3平衡二叉查找树BBST，平衡二叉树AVL\"></a>9.3平衡二叉查找树BBST，平衡二叉树AVL</h3><h3 id=\"9-4Java中的TreeMap，TreeSet\"><a href=\"#9-4Java中的TreeMap，TreeSet\" class=\"headerlink\" title=\"9.4Java中的TreeMap，TreeSet\"></a>9.4Java中的TreeMap，TreeSet</h3><h3 id=\"9-5B树、B-树\"><a href=\"#9-5B树、B-树\" class=\"headerlink\" title=\"9.5B树、B+树\"></a>9.5B树、B+树</h3><ul>\n<li>定义：m叉树m个分支m-1个关键字；若根不是终端则至少两颗子树；除根节点外所有非叶至少m/2上取整颗子树</li>\n<li>B树不支持顺序查找，B+树支持顺序查找</li>\n<li>B树删除：兄弟够借（&gt;=2）就左旋借一圈；左右兄弟都不够借，父节点下来一个跟兄弟合并</li>\n</ul>\n<h3 id=\"9-6线索二叉树\"><a href=\"#9-6线索二叉树\" class=\"headerlink\" title=\"9.6线索二叉树\"></a>9.6线索二叉树</h3><pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">typedef struct ThreadNode&#123;\n    ElemType data;\n    struct ThreadNode *lchild, *rchild;\n    int ltag,rtag;&#x2F;&#x2F;0为左孩子，1为前驱\n&#125;ThreadNode,*ThreadTree;\n&#x2F;&#x2F;左指前、右指后\n&#x2F;&#x2F;可以更方便地得到节点在遍历中的前驱和后继&#96;&#96;&#96;\n&#x2F;&#x2F;二叉树中序线索化\n&#x2F;&#x2F;可以在线索链表上也添加一个头节点：左指根，右指中序尾，中序第一个和最后一个都指向头节点。（双向线索链表）\nvoid InThread(ThreadTree &amp;p,ThreadTre &amp;pre)&#123;&#x2F;&#x2F;线索指向上一层\n    if(p!&#x3D;NULL)&#123;\n        InThread(p-&gt;lchild,pre);\n        if(p-&gt;lchild &#x3D;&#x3D; NULL)&#123;\n            p-&gt;lchild&#x3D;pre;\n            p-&gt;ltag&#x3D;1;\n        &#125;\n        if(pre!&#x3D;NULL&amp;&amp;pre-&gt;rchild&#x3D;&#x3D;NULL)&#123;\n            pre-&gt;rchild&#x3D;p;\n            pre-&gt;rtag&#x3D;1;\n        &#125;\n        pre&#x3D;p;\n        Inthread(p-&gt;rchild,pre);\n            &#x2F;&#x2F;先序线索化(p的左指针被改过)\n    &#x2F;&#x2F;if(0&#x3D;&#x3D;p-&gt;ltag) PreThread(p-&gt;lchild);\n    &#x2F;&#x2F;if(0&#x3D;&#x3D;p-&gt;rtag) PreThread(p-&gt;rchild);\n&#125;\n    &#125;\nvoid CreateInThread(ThreadTree T)&#123;\n    ThreadTree pre&#x3D;NULL;\n    if(T!&#x3D;NULL)&#123;\n        InThread(T,pre);\n        pre-&gt;rchild&#x3D;NULL;\n        pre-&gt;rtag&#x3D;1;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;线索二叉树遍历\nvoid Preorder(ThreadTree T)&#123;\n    ThreadNode *p &#x3D; T;\n    while(p!&#x3D;null)&#123;\n        while(p-&gt;ltag &#x3D;&#x3D; 0)&#123;\n            visit (p);\n            p&#x3D;p-&gt;lchild;\n        &#125;\n        visit(p)\n        p&#x3D;p-&gt;rchild;\n    &#125;\n&#125;\n\nThreadNode *getFirstNode(ThreadTree T)&#123;\n    ThreadNode *p&#x3D;T;\n    while(p-&gt;ltag &#x3D;&#x3D; 0)&#123;\n        p&#x3D;p-&gt;lchild;\n    &#125;\n    return p;&#x2F;&#x2F;返回最左下的节点\n&#125;\nThreadNode *getSuccessor(ThreadTree T)&#123;\n    ThreadNode *p&#x3D;T:\n    if(p-&gt;ltag&#x3D;&#x3D;0)\n        return(getFirstNode(p-&gt;lchild));\n    else\n        return p-&gt;rchild;\n&#125;\nvoid Inorder(ThreadTree T)&#123;\n    ThreadNode *p &#x3D;T;\n    while(p!&#x3D;null)&#123;\n        visit(p);\n        p&#x3D;getSuccessor(p);\n    &#125;\n&#125;\n\nvoid PostOrder(ThreadTree T)&#123;\n    ThreadNode *p&#x3D;T;\n    ThreadNode pre&#x3D;null;\n    while(null !&#x3D; p)&#123;\n        while(pre!&#x3D;p-&gt;lchild &amp;&amp; 0p-&gt;ltag)&#x2F;&#x2F;往左下找\n            p&#x3D;p-&gt;lchild;\n        while(null!&#x3D;p&amp;&amp;1p-&gt;rtag)&#123;&#x2F;&#x2F;开始访问\n            visit(p);\n            pre&#x3D;p;\n            p&#x3D;pre-&gt;rchild;\n        &#125;\n        if(T &#x3D;&#x3D; p)\n            visit(p);\n            p&#x3D;null;\n        while(null!&#x3D;p&amp;&amp;p-&gt;rchildpre)&#123;\n            visit(p);\n            pre&#x3D;p;\n            p&#x3D;p-&gt;parent;\n        &#125;\n        if(p!&#x3D;null&amp;&amp;p-&gt;rtag0)&#123;\n            p&#x3D;p-&gt;rchild;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;找左，访问，定根，找根，找右\n&#x2F;\n中序可找前可找后、先序可找后（找前需parent）、后序可找前（找后需parent，且注意根无后继）遍历需栈\n先找到序列中的第一个节点，然后依次找节点后继，直至其后继为空\n中序线索二叉树（左根右）找后继：若rtag&#x3D;1，p&#x3D;p-rchild（没有右子树）;否则遍历右子树中第一个访问的节点（右子树最左下的节点）。\n先序线索二叉树（根左右）找后继：如果有左孩子，左孩子为其后继；如果没左孩子但有右孩子，则右孩子为其后继；如果是叶节点，则右链域直接指示其后继。\n后续线索二叉树（左右根）找后继：1.若为根，则后继为空；2.若是双亲右孩子，或是双亲左孩子且双亲没有右子树，则其后继为双亲；3.若节点是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树按后序遍历列出的第一个节点。\n*&#x2F;\n\n&#x2F;&#x2F;先序遍历中序线索二叉树\nvoid PreOrderTraverse (ThreadTree)&#123;\n    ThreadNode *p &#x3D; T;\n    while(NULL!&#x3D;p)&#123;\n        while(0p-&gt;lTag)&#123;\n            Visit(P);\n            p&#x3D;p-&gt;lchild;\n        &#125;\n        while(1p-&gt;rchild)&#123;\n            p&#x3D;p-&gt;rchild;\n        &#125;\n        p&#x3D;p-&gt;rchild; \n    &#125;\n&#125;&#96;&#96;&#96;\n</code></pre>\n\n\n\n<h3 id=\"9-7题型套路\"><a href=\"#9-7题型套路\" class=\"headerlink\" title=\"9.7题型套路\"></a>9.7题型套路</h3><ol>\n<li>二叉树前中后序遍历</li>\n<li>二叉树按层遍历</li>\n<li>二叉树上的递归</li>\n<li>二叉查找树</li>\n<li>LCA最近公共祖先（学会用递归实现！ ）</li>\n<li>二叉树转单，双，循环链表</li>\n<li>按照遍历结果反向构建二叉树</li>\n<li>二叉树上的最长路径和</li>\n</ol>\n<h2 id=\"10-堆-使用优先级队列\"><a href=\"#10-堆-使用优先级队列\" class=\"headerlink\" title=\"10.堆(使用优先级队列)\"></a>10.堆(使用优先级队列)</h2><h3 id=\"10-1堆\"><a href=\"#10-1堆\" class=\"headerlink\" title=\"10.1堆\"></a>10.1堆</h3><ol>\n<li>堆是完全二叉树，分为大顶堆，小顶堆</li>\n<li>自上而下堆化，自下而上堆化</li>\n<li>操作：往堆中插入数据，取堆顶元素，删除堆顶元素，更新元素值</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package Week1;\n\n&#x2F;**\n * @author 10640\n *&#x2F;\npublic class Heap &#123;\n    private int a[];\n    private int n;\n    private int count;\n\n    public Heap(int capacity) &#123;\n        a &#x3D; new int[capacity];\n        n &#x3D; capacity;\n        count &#x3D; 0;\n    &#125;\n\n    public void insert(int data) &#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            return;\n        &#125;\n        ++count;\n        a[count] &#x3D; data;\n        int i &#x3D; count;\n\n        &#x2F;&#x2F;从下往上堆化\n        while (i &#x2F; 2 !&#x3D; 0 &amp;&amp; a[i] &gt; a[i &#x2F; 2]) &#123;\n            swap(a, i, i &#x2F; 2);\n            i &#x3D; i &#x2F; 2;\n        &#125;\n    &#125;\n\n    private void swap(int[] a, int i, int j) &#123;\n        int temp &#x3D; a[i];\n        a[j] &#x3D; a[i];\n        a[i] &#x3D; temp;\n    &#125;\n\n    public void removeTop() &#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            return;\n        &#125;\n        a[1] &#x3D; a[count];\n        --count;\n        heapify(a, count, 1);\n    &#125;\n\n    private void heapify(int[] a, int n, int i) &#123;\n        while (true) &#123;\n            int maxPos &#x3D; i;\n            if (i * 2 &lt;&#x3D; n &amp;&amp; a[i] &lt; a[i * 2]) &#123;\n                maxPos &#x3D; i * 2;\n            &#125;\n            if (i * 2 + 1 &lt;&#x3D; n &amp;&amp; a[i] &lt; a[i * 2 + 1]) &#123;\n                maxPos &#x3D; i * 2 + 1;\n            &#125;\n            if (maxPos &#x3D;&#x3D; i) &#123;\n                break;\n            &#125;\n            swap(a, i, maxPos);\n            i &#x3D; maxPos;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * take the top element of heap\n     *\n     * @return\n     *&#x2F;\n    public int top() &#123;\n        if (count &#x3D;&#x3D; 0) &#123;\n            return Integer.MAX_VALUE;\n        &#125;\n        return a[1];\n    &#125;\n\n    public void sort(int[] a, int n) &#123;\n        buildHeap(a, n);\n        int k &#x3D; n;\n        while (k &gt; 1) &#123;\n            swap(a, 1, k);\n            --k;\n            heapify(a, k, 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h3 id=\"10-2堆排序\"><a href=\"#10-2堆排序\" class=\"headerlink\" title=\"10.2堆排序\"></a>10.2堆排序</h3><ol>\n<li>建堆：将数据原地组织成一个堆<ol>\n<li>第一种：从前往后处理每个元素，对每个元素执行自下而上的堆化，O(nlogn)</li>\n<li>第二种：从后往前处理每个元素，对每个元素执行自上而下的堆化，O(n)</li>\n</ol>\n</li>\n<li>排序：基于堆排序数据<ol>\n<li>将堆顶元素与最后一个元素交换，最大元素就放到了下标为n的位置，堆大小-1</li>\n<li>交换之后的堆顶元素，自上而下堆化，重新构建成堆</li>\n<li>一直重复1，2直到堆中只剩下一个元素，排序结束</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"10-3题型\"><a href=\"#10-3题型\" class=\"headerlink\" title=\"10.3题型\"></a>10.3题型</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>用PriorityQueue和compare（o1-o2为小顶堆，o2-o1为大顶堆）</p></blockquote>\n<ol>\n<li><p>优先级队列</p>\n<p>利用优先级队列模拟堆的操作</p>\n</li>\n<li><p>TOP K</p>\n<p>求前K大的维护小顶堆</p>\n</li>\n<li><p>求中位数，百分位数</p>\n<p>维护两个堆，一个大顶堆，一个小顶堆</p>\n</li>\n</ol>\n<h2 id=\"11-字符串匹配（Trie树）\"><a href=\"#11-字符串匹配（Trie树）\" class=\"headerlink\" title=\"11.字符串匹配（Trie树）\"></a>11.字符串匹配（Trie树）</h2><h3 id=\"11-1单模式串匹配算法：在主串中查找一个模式串\"><a href=\"#11-1单模式串匹配算法：在主串中查找一个模式串\" class=\"headerlink\" title=\"11.1单模式串匹配算法：在主串中查找一个模式串\"></a>11.1单模式串匹配算法：在主串中查找一个模式串</h3><ol>\n<li><p>BF算法：在主串中按顺序检查是否有跟模式穿匹配的</p>\n</li>\n<li><p>Robin-Karp：通过Hash算法算出主串中的子串的Hash值，用Hash值来比较大小</p>\n</li>\n<li><p>Boyer-Moore （高效）：当模式串和主串不匹配时，能够跳过一些不会匹配的情况，模式串可以多滑动几位</p>\n<ol>\n<li>坏字符规则：模式串从后向前匹配，找到坏字符，拿坏字符在模式串查找，并移到相应位置</li>\n<li>好后缀规则：遇到坏字符，将好后缀记录下来，在模式串中找此子串，并滑动到对应位置</li>\n</ol>\n</li>\n<li><p>KMP算法：同上</p>\n</li>\n</ol>\n<h3 id=\"11-2多模式串匹配算法：在主串中查找多个模式串\"><a href=\"#11-2多模式串匹配算法：在主串中查找多个模式串\" class=\"headerlink\" title=\"11.2多模式串匹配算法：在主串中查找多个模式串\"></a>11.2多模式串匹配算法：在主串中查找多个模式串</h3><ol>\n<li>Trie树：适合前缀匹配，n叉树</li>\n<li>AC自动机：多模式匹配首选</li>\n</ol>\n<h3 id=\"11-3\"><a href=\"#11-3\" class=\"headerlink\" title=\"11.3\"></a>11.3</h3><h2 id=\"12-回溯\"><a href=\"#12-回溯\" class=\"headerlink\" title=\"12.回溯\"></a>12.回溯</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>回溯（backtrack）是重点，常考，并且DFS和动态规划的基础，因为回溯用到递归，比较绕，入门很难。</p></blockquote>\n<h3 id=\"12-1核心思想\"><a href=\"#12-1核心思想\" class=\"headerlink\" title=\"12.1核心思想\"></a>12.1核心思想</h3><ol>\n<li>回溯的处理过程是一个穷举（或者叫枚举）的过程，枚举所有的解，找出其中满足期望的可行解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们把问题求解的过程归纳为<strong>多阶段决策模型</strong>。每个阶段的决策会对应多个选择，从可选的选择列表中，任意选择一个，然后继续进行下一阶段的决策。</li>\n<li>整个决策的过程，如果用图来形象化表示的话，就是一颗<strong>决策树</strong>。回溯穷举所有解来查找可行解的过程，就是在决策树中进行遍历的过程，遍历过程中记录的路径就是解。</li>\n<li>回溯一般使用<strong>递归</strong>来实现，递归树就跟决策树完全一样。递的过程进行函数调用，对应到递归树上为从一个节点进入它的子节点，归的过程进行函数调用返回，对应到递归树上是从子节点返回上一层节点。</li>\n</ol>\n<h3 id=\"12-2代码模板\"><a href=\"#12-2代码模板\" class=\"headerlink\" title=\"12.2代码模板\"></a>12.2代码模板</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220417191538719-165668658181332.png\" alt=\"image-20220417191538719\"></p>\n<h3 id=\"12-3回溯相关题型\"><a href=\"#12-3回溯相关题型\" class=\"headerlink\" title=\"12.3回溯相关题型\"></a>12.3回溯相关题型</h3><ol>\n<li>全排列：给定n个不重复的数，求这组数的所有排列组合</li>\n<li>八皇后：</li>\n<li>0-1背包：穷举出2^n种装法，然后找出总重量小于等于Wkg的装法</li>\n<li>穷举出所有的组合：</li>\n<li>正则表达式：</li>\n</ol>\n<h2 id=\"13-图\"><a href=\"#13-图\" class=\"headerlink\" title=\"13.图\"></a>13.图</h2><h3 id=\"13-1基础概念\"><a href=\"#13-1基础概念\" class=\"headerlink\" title=\"13.1基础概念\"></a>13.1基础概念</h3><ul>\n<li>完全图：有向图边数0～n(n-1)、无向图边数0～n(n-1)/2（任意两个顶点之间都存在弧）</li>\n<li>子图：顶点和边的子集，生成子图：顶点都在的子图</li>\n<li>连通：无向图两个节点间有路径；强连通：有向图两个节点间有双向路径（！极大连通子图=连通分量；极大强连通子图=强连通分量）非连通图最多(n-1)(n-2)/2(C排列组合公式完全图去掉n-1条边)</li>\n<li>一个单独的顶点也是一个强连通分量</li>\n<li>生成树：包含全部顶点的一个极小连通子图，含有n-1条边（类似树，少一个不连通，多一个有回路）</li>\n<li>距离：两点间最短路径</li>\n<li>无向图某顶点的度为依附顶点的边的个数；有向图某顶点的度为入度和出度的和</li>\n<li>A^n对应i行j列数值为i到j路径长度为n的路径数目</li>\n<li>7个顶点无向图边数为16时必连通，n个节点连通无向图至少n-1条边，强连通有向图至少n条边</li>\n<li>判断是否是一棵树：连通：能否遍历全部顶点；是一棵树：无回路的的连通图或有n-1条边的连通图（一次遍历就能访问到n个顶点和n-1条边，无向图为2*（n-1）条边）</li>\n</ul>\n<h3 id=\"13-2存储\"><a href=\"#13-2存储\" class=\"headerlink\" title=\"13.2存储\"></a>13.2存储</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;有向无权图，邻接矩阵\npublic class Graph&#123;\n    private int v;\n    private boolean matrix[][];\n    \n    public Graph(int v)&#123;\n        this.v &#x3D; v;\n        matrix &#x3D; new boolean[v][v];&#x2F;&#x2F;默认都为false\n    &#125;\n    \n    public void addEdge(int s,int t)&#123;\n        matrix[x][t] &#x3D; true;\n    &#125;\n&#125;\n&#x2F;&#x2F;有向无权图，邻接表\npublic class Graph&#123;\n    private int v;&#x2F;&#x2F;顶点个数\n    private LinkedList&lt;Integer&gt; adj[];&#x2F;&#x2F;邻接表\n    \n    public Graph(int v)&#123;\n        this.v &#x3D; v;\n        adj &#x3D; new LinkedList[v];\n        for(int i &#x3D; 0; i &lt; v ;++i)&#123;\n            adj[i] &#x3D; new LinkedList&lt;&gt;();\n        &#125;\n    &#125;\n    public void addEdge(int s,int t)&#123;\n        adj[s].add(t);\n    &#125;\n&#125;</code></pre>\n\n\n\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;邻接矩阵\n#define MaxVertexNum 100\ntypedef char VertexType;\ntypedef int EdgeType;\ntypedef struct&#123;\n    VertexType Vex[MaxVertexNum];\n    EdgeType Edge[MaxVertexNum][MaxVertexNum];\n    int vexnum,arcnum;\n&#125;MGraph;\n&#x2F;&#x2F;无权图用1&#x2F;0，带权图用∞&#x2F;权值\n\n&#x2F;&#x2F;邻接表法（结构体非指针）\n#define MaxVertexNum 100\ntypedef struct ArcNode&#123;\n    int adjvex;&#x2F;&#x2F;邻接表弧头节点(指谁存谁)；逆邻接表弧尾节点（谁指的存谁）             \n    struct ArcNode *next;\n    &#x2F;&#x2F;InfoType info;\n&#125;ArcNode;\ntypedef struct VNode&#123;\n    VertexType data;\n    ArcNode *first;\n&#125;VNode,AdjList[MaxVertexNum];\ntypedef struct&#123;\n    AdjList vertices;&#x2F;&#x2F;是一个数组，用int表示点\n    int vexnum,arcnum;\n&#125;ALGraph;</code></pre>\n\n<h3 id=\"13-3BFS、DFS（C语言伪码版）\"><a href=\"#13-3BFS、DFS（C语言伪码版）\" class=\"headerlink\" title=\"13.3BFS、DFS（C语言伪码版）\"></a>13.3BFS、DFS（C语言伪码版）</h3><ul>\n<li><p>BFS（类似树层次遍历），无权图求单源最短路径</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bool visited[MaxVertexNum];\nvoid BFSTraverse(Graph G)&#123;\n    for(i&#x3D;0;i&lt;G.vexnum;++i)\n        visited[i]&#x3D;FALSE;\n    InitQueue(Q);\n    for(i&#x3D;0;i&lt;G.vexnum;++i)\n        if(!visited[i])\n            BFS(G,i);\n&#125;\nvoid BFS(Graph G,int v)&#123;\n    visit(v);\n    visited[v]&#x3D;TRUE;\n    Enqueue(Q,v);\n    while(!isEmpty(Q))&#123;\n        DeQueue(Q,v);\n    for(w&#x3D;FirstNeighbor(G,v);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,v,w))\n        if(!visited[w])&#123;\n            visit(w);\n            visited[w]&#x3D;TRUE;\n            EnQueue(Q,w);\n        &#125;\n    &#125;\n&#125;\n\nvoid BFSMinDistance(Graph G,int u)&#123;\n&#x2F;&#x2F;d[i]从u到i节点最短路径\n    for(i&#x3D;0;i&lt;G.vexnum;++i)\n        d[i] &#x3D; ∞;\n    visited[u]&#x3D;TRUE;\n    d[u]&#x3D;0;\n    Enqueue(Q,u);\n    while(!isEmpty(Q))&#123;\n        DeQueue(Q,u);\n        for(w&#x3D;FirstNeighbor(G,u);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,u,w))\n            if(!visited[w])&#123;\n                visited[w]&#x3D;TRUE;\n                d[w]&#x3D;d[u]+1;\n                EnQueue(Q,w);\n           &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>DFS（递归、非递归）（类似树先序遍历）【判断是否有环】</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bool visited[MaxVertexNum];\nvoid DFSTraverse(Graph G)&#123;\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        visited[v]&#x3D;FALSE;\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        if(!visited[v])\n            DFS(G,v);\n&#125;\nvoid DFS(Graph G,int v)&#123;\n    visit(v);\n    visited[v]&#x3D;TRUE;\n    for(w&#x3D;FirstNeighbor(G,v);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,v,w))\n        if(!visited[w])&#123;\n            DFS(G,w);\n    &#125;\n&#125;\n\nvoid DFS(Graph g,int v)&#123;\n    int w;\n    InitStack(S);\n    for(i&#x3D;0;i&lt;g.vexnum;i++)\n        visited[i]&#x3D;FALSE;\n    Push(S,v);\n    visited[v]&#x3D;TRUE;\n    while(!isEmpty(S))&#123;\n        k&#x3D;Pop(S);\n        visit(k);&#x2F;&#x2F;先访问，后将子节点入栈\n        for(w&#x3D;FirstNeighbor(G,k);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,k,w))\n            if(!visited[w])&#123;\n                Push(S,w);\n                visited[w]&#x3D;true;&#x2F;&#x2F;防止再次入栈\n            &#125;\n    &#125;\n&#125;\n## - 输出Vi到Vj的所有简单路径\nvoid FindPath(Graph *G,int u,int v,int path[],int d)&#123;\n    int w,i;\n    ArcNode *P;\n    d++;\n    path[d]&#x3D;u;\n    visited[u]&#x3D;1;\n    if(uv)\n        print(path[]);\n    P&#x3D;G-&gt;adjlist[u].firstarc;\n    while(p!&#x3D;NULL)&#123;\n        w&#x3D;p-&gt;adjvex;\n        if(visited[w]0)\n            FindPath(G,w,v,path,d);\n        p&#x3D;p-&gt;nextarc;\n    &#125;\n    visited[u]&#x3D;0;&#x2F;&#x2F;恢复环境，使该节点可重新使用\n&#125;</code></pre></li>\n</ul>\n<h3 id=\"13-4BFS、DFS（java版）\"><a href=\"#13-4BFS、DFS（java版）\" class=\"headerlink\" title=\"13.4BFS、DFS（java版）\"></a>13.4BFS、DFS（java版）</h3><ol>\n<li>树是图的一种特殊情况，二叉树的层次遍历，实际上就是广度优先搜索，从根节点开始，一层层的从上往下遍历， 先遍历与根节点近的，再逐层遍历与根节点远的。图上的广度优先搜索（或遍历）跟树上的按层遍历很像，先查找离起始顶点s最近的，然后是次近的，依次往外搜索，直到找到终止顶点t（或所有顶点都遍历了一遍）。树的按层遍历需要用到队列，同理，图的广度优先搜索（或遍历）也要用到队列。除此之外，对于图的按层遍历，需要用一个visited数组，记录已经遍历过的顶点，防止图中存在环，出现循环遍历多次的情况。==广度优先搜索处理的是无权图，实际上，通过广度优先搜索找到的源点到终点的路径也是顶点s到顶点t的最短路径==</li>\n<li>前面提到广度优先搜索时一种“地毯式”的搜索策略，那么深度优先搜索（DFS）就是一种“不撞南墙不回头”的搜索策略。==DFS是图上的回溯==，沿着一条路一股脑地往前走，当走到无路可走时，再回退到上一个岔路口，选择另一条路继续前进。==树的前中后序遍历就是深度优先遍历==。前中后序的区别仅仅在于处理节点的时机的不同。换句话说：树上的深度优先遍历又分为三类：前中后序遍历。</li>\n<li>实际上，DFS也是一种回溯算法，也可以看做多阶段决策模型，用回溯模板解决。<ul>\n<li>每个阶段都是基于当前节点移动到下一节点</li>\n<li>可选列表是：相邻并没有被访问过的节点</li>\n<li>当前阶段做不同的选择，对应下一阶段是不同的</li>\n<li>回溯的结束条件是：所有节点都已经访问完成或找到了终止节点</li>\n<li>在回溯的过程中，我们用visited数组，记录已经遍历过的顶点，以免循环重复遍历。</li>\n</ul>\n</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package Graph;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class Graph &#123;\n    &#x2F;**\n     * 顶点个数\n     *&#x2F;\n    private int v;\n    &#x2F;**\n     * 邻接表\n     *&#x2F;\n    private LinkedList&lt;Integer&gt; adj[];\n\n    public Graph(int v) &#123;\n        this.v &#x3D; v;\n        adj &#x3D; new LinkedList[v];\n        for (int i &#x3D; 0; i &lt; v; i++) &#123;\n            adj[i] &#x3D; new LinkedList&lt;&gt;();\n        &#125;\n    &#125;\n\n    public void addEdge(int s, int t) &#123;\n        &#x2F;&#x2F;无向图一条边存两次\n        adj[s].add(t);\n        adj[t].add(s);\n    &#125;\n\n    &#x2F;**\n     * 广度优先搜索&#x2F;遍历算法\n     *\n     * @param s\n     * @param t\n     * @return\n     *&#x2F;\n    public void bfs_simple(int s, int t) &#123;\n        boolean[] visited &#x3D; new boolean[v];\n        Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();\n        queue.add(s);\n        visited[s] &#x3D; true;\n        while (!queue.isEmpty()) &#123;\n            int p &#x3D; queue.poll();\n            &#x2F;&#x2F;搜索时加上\n&#x2F;&#x2F;            if (p &#x3D;&#x3D; t)&#123;\n&#x2F;&#x2F;                return true;\n&#x2F;&#x2F;            &#125;\n            for (int i &#x3D; 0; i &lt; adj[p].size(); i++) &#123;\n                int q &#x3D; adj[p].get(i);\n                if (!visited[q]) &#123;\n                    visited[q] &#x3D; true;\n                    queue.add(q);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 支持打印从s到t的路径\n     *\n     * @param s\n     * @param t\n     *&#x2F;\n    public void bfs(int s, int t) &#123;\n        boolean[] visited &#x3D; new boolean[v];\n        Queue&lt;Integer&gt; queue &#x3D; new LinkedList&lt;&gt;();\n        queue.add(s);\n        visited[s] &#x3D; true;\n        &#x2F;&#x2F;+\n        int[] prev &#x3D; new int[v];\n        for (int i &#x3D; 0; i &lt; v; i++) &#123;\n            prev[i] &#x3D; -1;\n        &#125;\n        &#x2F;&#x2F;+\n        while (!queue.isEmpty()) &#123;\n            int p &#x3D; queue.poll();\n            if (p &#x3D;&#x3D; t) &#123;\n                &#x2F;&#x2F;+\n                print(prev, s, t);\n                &#x2F;&#x2F;+\n                return;\n            &#125;\n            for (int i &#x3D; 0; i &lt; adj[p].size(); i++) &#123;\n                int q &#x3D; adj[p].get(i);\n                if (!visited[q]) &#123;\n                    &#x2F;&#x2F;+\n                    prev[q] &#x3D; p;\n                    &#x2F;&#x2F;+\n                    visited[q] &#x3D; true;\n                    queue.add(q);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 有点类似于逆序打印链表\n     *\n     * @param prev\n     * @param s\n     * @param t\n     *&#x2F;\n    private void print(int[] prev, int s, int t) &#123;\n        if (prev[t] !&#x3D; -1 &amp;&amp; t !&#x3D; s) &#123;\n            print(prev, s, prev[t]);\n        &#125;\n        System.out.println(t + &quot;  &quot;);\n    &#125;\n\n    boolean found &#x3D; false;\n    private boolean[] visited &#x3D; new boolean[v];\n\n    public boolean dfs_simple(int s, int t) &#123;\n        dfs_simple(s, t);\n        return found;\n    &#125;\n\n    private void dfs_simple_r(int s, int t) &#123;\n        if (found) &#123;\n            return;\n        &#125;\n        visited[s] &#x3D; true;\n        if (s &#x3D;&#x3D; t) &#123;\n            found &#x3D; true;\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q]) &#123;\n                dfs_simple_r(q, t);\n            &#125;\n        &#125;\n    &#125;\n\n    private List&lt;Integer&gt; resultPath &#x3D; new ArrayList&lt;&gt;();\n\n    &#x2F;**\n     * 支持打印出从s到t的路径\n     * @param s\n     * @param t\n     * @return\n     *&#x2F;\n    public List&lt;Integer&gt; dfs(int s,int t)&#123;\n        dfs_r(s,t,new ArrayList&lt;&gt;());\n        return resultPath;\n    &#125;\n    public void dfs_r(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        visited[s] &#x3D; true;\n        path.add(s);\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                dfs_r(q,t,path);\n            &#125;\n        &#125;\n        path.remove(path.size()-1);\n    &#125;\n\n    public List&lt;Integer&gt; dfs2(int s,int t)&#123;\n        List&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();\n        path.add(s);\n        visited[s] &#x3D; true;\n        dfs_backtrack(s,t,path);\n        return resultPath;\n    &#125;\n\n    public void dfs_backtrack(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                path.add(q);\n                visited[q] &#x3D; true;\n                dfs_backtrack(q,t,path);\n                path.remove(path.size()-1);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<h3 id=\"13-5图上其他算法\"><a href=\"#13-5图上其他算法\" class=\"headerlink\" title=\"13.5图上其他算法\"></a>13.5图上其他算法</h3><h4 id=\"1-最小生成树（PK算法）\"><a href=\"#1-最小生成树（PK算法）\" class=\"headerlink\" title=\"1.最小生成树（PK算法）\"></a>1.最小生成树（PK算法）</h4><ul>\n<li>带权连通图的任意一个环中所包含的边权值均不相等时，其最小生成树是唯一的</li>\n<li>Prim：找点，适合求解边稠密的图</li>\n<li>Kruskal：找边，适合求解边稀疏而顶点较多的图，采用堆来存放边的集合</li>\n</ul>\n<h4 id=\"2-最短路径（DF算法）\"><a href=\"#2-最短路径（DF算法）\" class=\"headerlink\" title=\"2.最短路径（DF算法）\"></a>2.最短路径（DF算法）</h4><ul>\n<li><p>Dijkstra：</p>\n<ul>\n<li>针对有权图的单源最短路径算法，并且要求没有负权边</li>\n<li>求有向图某一个顶点到其余各顶点的最短路径，dist[]源点到各顶点最短路径长度 path[]v到当前节点的最短路径的前驱节点，首先初始化，算距离改dist[],找最小改path[],加和比较继续迭代</li>\n</ul>\n</li>\n<li><p>Floyd：</p>\n<ul>\n<li>针对有权图的多源最短路径算法，允许存在负权边，但不允许负权环</li>\n<li>求有向图每对顶点之间最短路径，用边矩阵作为A⁻¹进行迭代，每次加进来一个顶点，并遍历矩阵进行修改(A[i][j]&gt;A[i][k]+A[k][j])，最后得到任意两节点间最短路径矩阵</li>\n</ul>\n</li>\n<li><p>Bellman-Ford：</p>\n<ul>\n<li>针对有权图的单源最短路径算法，允许存在负权边</li>\n</ul>\n</li>\n<li><p>A*算法：</p>\n<ul>\n<li>启发式搜索算法，求有权图的次优最短路线</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-AOV网：拓扑排序\"><a href=\"#3-AOV网：拓扑排序\" class=\"headerlink\" title=\"3.AOV网：拓扑排序\"></a>3.AOV网：拓扑排序</h4><ul>\n<li>DAG图（有向无环图）</li>\n<li>可判断有向图是否有回路</li>\n<li>邻接矩阵是三角矩阵，则存在拓扑序列</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">bool TopologicalSort(Graph G)&#123;&#x2F;&#x2F;不用visited[]\n    InitStack(S);\n    for(int i&#x3D;0;i&lt;G.vexnum;i++)\n        if(indegree[i] &#x3D;&#x3D; 0)\n            Push(S,i);\n    int count &#x3D; 0;\n    while(!IsEmpty(S))&#123;\n        Pop(S,i);\n        print[count++]&#x3D;i;\n        for(p&#x3D;G.vertices[i].firstarc;p;p&#x3D;p-&gt;nextarc)&#123;\n            v&#x3D;p-&gt;adjvex;&#x2F;&#x2F;由边找到点\n            if(!(—-indegree[v]))\n                Push(S,v);\n        &#125;\n    &#125;\n    if(count&lt;G.vexnum)\n        return false;&#x2F;&#x2F;有环\n    else\n        return true;\n&#125;\n\n\n&#x2F;&#x2F;用DFS实现无环图拓扑排序！\nbool visited[MaxVertexNum];\nvoid DFSTraverse(Graph G)&#123;\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        visited[v]&#x3D;FALSE;\n    time &#x3D; 0&#x2F;&#x2F;有向无环图拓扑排序\n    for(v&#x3D;0;v&lt;G.vexnum;++v)\n        if(!visited[v])\n            DFS(G,v);\n&#125;\nvoid DFS(Graph G,int v)&#123;\n    visit(v);\n    visited[v]&#x3D;TRUE;\n    for(w&#x3D;FirstNeighbor(G,v);w&gt;&#x3D;0;w&#x3D;NextNeighbor(G,v,w))\n        if(!visited[w])&#123;\n            DFS(G,w);\n    &#125;\n    time &#x3D; time+1;\n    finishTime[v]&#x3D;time;\n    &#x2F;&#x2F;时间从大到小排序即可得到拓扑排序\n    &#x2F;&#x2F;从下往上一层层加时间，最上面的时间最长\n    &#x2F;&#x2F;子孙先结束，祖先后结束\n&#125;\n\n&#x2F;&#x2F;逆拓扑排序\n&#x2F;&#x2F;从AOV网中选择一个没有后继的顶点并输出\n&#x2F;&#x2F;从网中删除该顶点和所有以它为终点的有向边\n&#x2F;&#x2F;重复以上两点，直到为空</code></pre>\n\n<h4 id=\"4-AOE网\"><a href=\"#4-AOE网\" class=\"headerlink\" title=\"4.AOE网\"></a>4.AOE网</h4><ul>\n<li>关键路径（最大路径长度）<br>去大回小<br>拓扑排序+逆拓扑排序=关键路径<br>完成工程的最短时间=关键路径长度=最大路径长度</li>\n<li>顶点表示事件，有向边表示活动</li>\n<li>只有某节点所代表的事情发生后从该顶点出发的各有向边所代表的活动才能开始；只有进入某顶点的有向边所代表的活动都结束时，该顶点所代表的事件才能发生。Ve（k）、Vl（k）、e（i）、l（i）</li>\n<li>对于有多条关键路径的网，只有加快包含在所有关键路径上的关键活动才能达到缩短工期的目的。</li>\n</ul>\n<h4 id=\"5-最大流-，二分匹配\"><a href=\"#5-最大流-，二分匹配\" class=\"headerlink\" title=\"5.最大流 ，二分匹配\"></a>5.最大流 ，二分匹配</h4><ol>\n<li>Ford-Fulkerson</li>\n<li>Edmonds-Karp</li>\n</ol>\n<h3 id=\"13-6题型套路\"><a href=\"#13-6题型套路\" class=\"headerlink\" title=\"13.6题型套路\"></a>13.6题型套路</h3><ol>\n<li><p>二维矩阵搜索或遍历</p>\n</li>\n<li><p>最短路径（BFS）</p>\n</li>\n<li><p>连通分量/连通性</p>\n</li>\n<li><p>拓扑排序</p>\n<ol>\n<li><p>Kahn算法：</p>\n<ol>\n<li>数据结构：如果s需要先于t执行，那就添加一条s指向t的边，所以每个顶点的入度表示这个顶点依赖多少个其它顶点，如果某个顶点的入度变成了0，就表示这个顶点没有依赖的顶点了，或者说这个顶点依赖的顶点都已执行</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void topoSortByKahn() &#123;\n  int[] inDegree &#x3D; new int[v];\n  for (int i &#x3D; 0; i &lt; v; i++) &#123;\n    for (int j &#x3D; 0; j &lt; adj[i].size(); j++) &#123;\n      int w &#x3D; adj[i].get(j);\n      inDegree[w]++;\n    &#125;\n  &#125;\n  LinkedList&lt;Integer&gt; zeroSet &#x3D; new LinkedList&lt;&gt;();\n  for (int i &#x3D; 0; i &lt; v; i++) &#123;\n    if (inDegree[i] &#x3D;&#x3D; 0) &#123;\n      zeroSet.add(i);\n    &#125;\n  &#125;\n  while (!zeroSet.isEmpty()) &#123;\n    int i &#x3D; zeroSet.remove();\n    System.out.println(&quot;-&gt;&quot; + i);\n    for (int j &#x3D; 0; j &lt; adj[i].size(); j++) &#123;\n      int k &#x3D; adj[i].get(j);\n      inDegree[k]--;\n      if (inDegree[k] &#x3D;&#x3D; 0) &#123;\n        zeroSet.add(k);\n      &#125;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>DFS算法：</p>\n<ol>\n<li><p>数据结构：如果s需要先于t执行，也就是说，t依赖s，那就添加一条t指向s的边。算法处理的核心思想是递归，对于顶点vertex，我们先输出它可到达的所有顶点，也就是说，先把它依赖的所有顶点输出，然后再输出自己，这个过程可以借助DFS实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void topoSortByDFS()&#123;\n  for (int i &#x3D; 0; i &lt; v; i++) &#123;\n    if (visited[i] &#x3D;&#x3D; false)&#123;\n      visited[i] &#x3D; true;\n      dfs(i);\n    &#125;\n  &#125;\n&#125;\npublic void dfs(int vertex)&#123;\n  for (int i &#x3D; 0; i &lt; adj[vertex].size(); i++) &#123;\n    int w &#x3D; adj[vertex].get(i);\n    if (visited[w] &#x3D; true)&#123;\n      continue;\n    &#125;\n    visited[w] &#x3D; true;\n    dfs(w);\n  &#125;\n  System.out.println(&quot;-&gt;&quot; + vertex);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>检测环</p>\n</li>\n</ol>\n<h2 id=\"14-动态规划\"><a href=\"#14-动态规划\" class=\"headerlink\" title=\"14.动态规划\"></a>14.动态规划</h2><h3 id=\"1-理论知识\"><a href=\"#1-理论知识\" class=\"headerlink\" title=\"1.理论知识\"></a>1.理论知识</h3><ol>\n<li><p>适用问题：回溯+重复子问题（重复状态），部分问题可以使用回溯+备忘录的方法来解决。示例如下（0-1背包问题）</p>\n<ul>\n<li>构建多阶段决策模型：把每一层（每一阶段）重复的状态合并，只记录不同的状态，然后基于上一层（上一阶段）的状态集合，来推导下一层（下一阶段）的状态集合</li>\n<li>通过合并每一层重复的状态，这样就能保证每一层的状态个数不会超过w个（背包的承载重量）。于是，就可以避免回溯算法递归树中每层状态个数的指数级增长</li>\n<li>定义转移状态：使用一个boolean的二维数组表示，第i个物品放入后有哪几个重量是可行的</li>\n<li>状态转移方程：不断迭代，将可能的结果填入到二维数组相应的位置</li>\n</ul>\n</li>\n<li><p>解题步骤</p>\n<ul>\n<li>可用回溯解决：使用穷举结果才能得到结果的问题（最值、可行、计数等）</li>\n<li>构建多阶段决策模型：看是否能将问题求解的过程分为多个阶段</li>\n<li>查看是否存在重复子问题：是否有多个路径到达同一状态</li>\n<li>定义状态：也就是如何记录每一阶段的不重复状态</li>\n<li>定义状态转移方程：也就是找到如何通过上一阶段的状态推导下一阶段的状态</li>\n<li>画状态转移表：辅助理解，验证正确性，确定状态转移的初始值</li>\n</ul>\n</li>\n<li><p>0-1背包问题的最值、可行、计数</p>\n<ul>\n<li><p>最值</p>\n<ul>\n<li><p>示例一：有n个物品，选择其中一些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装物品总重量的最大值是多少</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123220749470.png\" alt=\"image-20221123220749470\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int knapsack1(int[] weight, int n, int w)&#123;&#x2F;&#x2F;最值\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  dp[0][0] &#x3D; true;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; i++)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D;&#x3D; true || (j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] &#x3D;&#x3D; true))&#123;\n        dp[i][j] &#x3D; true;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; w; i &gt;&#x3D; 0 ; i--)&#123;&#x2F;&#x2F;输出结果\n    if(dp[n-1][i] &#x3D;&#x3D; true) &#123;\n      return i;\n    &#125;\n  &#125;\n  return 0;\n&#125;</code></pre></li>\n<li><p>示例二：有n个物品，选择其中一些物品装入背包，正好装满背包所需物品最小个数（如果装不满，返回-1）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123221357522.png\" alt=\"image-20221123221357522\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int knapsack3(int[] weight, int n, int w)&#123;&#x2F;&#x2F;最值\n  int[][] dp &#x3D; new int[n][w+1];&#x2F;&#x2F;记录到达某个状态，最少物品数量\n  for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      dp[i][j] &#x3D; Integer.MAX_VALUE-1;&#x2F;&#x2F;解决越界问题\n    &#125;\n  &#125;\n  dp[0][0] &#x3D; 0;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; 1;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;&#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(j-weight[i] &lt; 0)&#123;\n        dp[i][j] &#x3D; dp[i-1][j];\n      &#125;else&#123;\n        dp[i][j] &#x3D; Math.min(dp[i-1][j], dp[i-1][j-weight[i]] + 1);&#x2F;&#x2F;会有越界问题\n      &#125;\n    &#125;\n  &#125;\n  if(dp[n-1][w] &#x3D;&#x3D; Integer.MAX_VALUE) &#123;\n    return -1;\n  &#125;\n  return dp[n-1][w];\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>可行</p>\n<ul>\n<li><p>示例：有n个物品，选择其中一些物品装入背包，能不能正好装满背包</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123221149678.png\" alt=\"image-20221123221149678\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean kanpsack2(int[] weight, int n, int w)&#123;&#x2F;&#x2F;可行\n  boolean[][] dp &#x3D; new boolean[n][w+1];&#x2F;&#x2F;默认值false\n  dp[0][0] &#x3D; true;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D; true || (j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] &#x3D;&#x3D; true))&#123;\n        dp[i][j] &#x3D; true;\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>计数</p>\n<ul>\n<li><p>示例：有n个物品，选择其中一些物品装入背包，装满背包有多少种不同的装法</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123221916906.png\" alt=\"image-20221123221916906\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int knapsack4(int[] weight, int n, int w)&#123; &#x2F;&#x2F;计数\n  int[][] dp &#x3D; new int[n][w+1]; &#x2F;&#x2F;记录到达某个状态有几条路径\n  dp[0][0] &#x3D; 1;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; 1;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(j-weight[i] &lt; 0)&#123;\n        dp[i][j] &#x3D; dp[i-1][j];\n      &#125;else&#123;\n        dp[i][j] &#x3D; dp[i-1][j] + dp[i-1][j-weight[i]];\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>完全背包问题的最值、可行、计数</p>\n<ul>\n<li><p>背包可装物品总重量的最大值是多少</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int wanquan_1(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        if(dp[i-1][j-c*weight[i]])&#123;\n          dp[i][j] &#x3D; true;\n          break;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; w; i &gt;&#x3D; 0; --i)&#123;\n    if(dp[n-1][i] &#x3D;&#x3D; true)&#123;\n      return i;\n    &#125;\n  &#125;\n  return 0;\n&#125;</code></pre></li>\n<li><p>是否能装满整个背包</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int wanquan_2(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        if(dp[i-1][j-c*weight[i]])&#123;\n          dp[i][j] &#x3D; true;\n          break;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;</code></pre></li>\n<li><p>正好装满背包至少需要多少物品</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int wanquan_3(int[] weight, int n, int w)&#123;\n  int[][] dp &#x3D; new int[n][w+1];\n  for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      dp[i][j] &#x3D; Integer.MAX_VALUE;\n    &#125;\n  &#125;\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; i;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        if(dp[i-1][j-c*weight[i]] !&#x3D; Integer.MAX_VALUE &amp;&amp; dp[i-1][j-c*weight[i]]+c &lt; dp[i][j])&#123;\n          dp[i][j] &#x3D; dp[i-1][j-c*weight[i]] + c;\n          break;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;</code></pre></li>\n<li><p>装满背包有多少种装法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int wanquan_4(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1];\n  for(int i &#x3D; 0; i &lt;&#x3D; w&#x2F;weight[0]; ++i)&#123;\n    dp[0][i+weight[0]] &#x3D; 1;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      int k &#x3D; j&#x2F;weight[i];\n      for(int c &#x3D; 0; c &lt;&#x3D; k; ++c)&#123;\n        dp[i][j] +&#x3D; dp[i+1][j-c*weight[i]];\n      &#125;\n    &#125;\n  &#125;\n  return dp[n-1][w];\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>空间优化</p>\n<ul>\n<li><p>问题：对于一组不同重量、不可分割的物品，选择其中一些物品装入背包，能不能正好装满背包</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123222900386.png\" alt=\"image-20221123222900386\"><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123223543710.png\" alt=\"image-20221123223543710\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-经典问题\"><a href=\"#2-经典问题\" class=\"headerlink\" title=\"2.经典问题\"></a>2.经典问题</h3><ol>\n<li><p>背包问题（0-1、完全、多重、二维费用、分组、有依赖的）</p>\n<ul>\n<li><p>0-1</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123212945761-20221123214859692.png\" alt=\"image-20221123212945761\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int knapsack(int[] weight, int n, int w)&#123;\n  boolean[][] dp &#x3D; new boolean[n][w+1]; &#x2F;&#x2F;默认为false\n  dp[0][0] &#x3D; true;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; true;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D;&#x3D; true)&#123;\n        dp[i][j] &#x3D; true;\n        if(j+weight[i] &lt;&#x3D; w)&#123;\n          dp[i][j+weight[i]] &#x3D; true;\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123; &#x2F;&#x2F;动态规划状态转移\n    for(itn j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D;&#x3D; true || (j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] &#x3D;&#x3D; true))&#123;\n        dp[i][j] &#x3D; true;\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; w; i &gt;&#x3D; 0; --i)&#123;&#x2F;&#x2F;输出结果\n    if(dp[n-1][i] &#x3D;&#x3D; true)&#123;\n      return i;\n    &#125;\n  &#125;\n  return 0;\n&#125;</code></pre></li>\n<li><p>二维</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221123214922025.png\" alt=\"image-20221123214922025\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public int knapsack_2(int[] weight, int[] value, int n, int w)&#123;\n  int[][] dp &#x3D; new int[n][w+1];\n  for(int i &#x3D; 0; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      dp[i][j] &#x3D;&#x3D; Integer.MIN_VALUE;\n    &#125;\n  &#125;\n  dp[0][0] &#x3D; 0;\n  if(weight[0] &lt;&#x3D; w)&#123;\n    dp[0][weight[0]] &#x3D; value[0];\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] &#x3D; Integer.MIN_VALUE)&#123;\n        continue;\n      &#125;\n      dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j]);\n      if(j+weight[i] &lt;&#x3D; w)&#123;\n        dp[i][j+weight[i]] &#x3D; Math.max(dp[i][j+weight[i]], dp[i-1][j] + value[i]);\n      &#125;\n    &#125;\n  &#125;\n  for(int i &#x3D; 1; i &lt; n; ++i)&#123;\n    for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n      if(dp[i-1][j] !&#x3D; Integer.MIN_VALUE)&#123;\n        dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j]);\n      &#125;\n      if(j-weight[i] &gt;&#x3D; 0 &amp;&amp; dp[i-1][j-weight[i]] !&#x3D; Integer.MIN_VALUE)&#123;\n        dp[i][j] &#x3D; Math.max(dp[i][j], dp[i-1][j-weight[i]] + value[i]);\n      &#125;\n    &#125;\n  &#125;\n  int res &#x3D; Integer.MIN_VALUE;\n  for(int j &#x3D; 0; j &lt;&#x3D; w; ++j)&#123;\n    if(res &lt; dp[n-1][j])&#123;\n      res &#x3D; dp[n-1][j];\n    &#125;\n  &#125;\n  return res;\n&#125;</code></pre></li>\n<li><p>多重背包问题，装满背包有多少种装法</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221208213135998.png\" alt=\"image-20221208213135998\"></p>\n</li>\n</ul>\n</li>\n<li><p>路径问题</p>\n</li>\n<li><p>打家劫舍和股票买卖</p>\n<ul>\n<li>一般动态规划问题，上一个阶段做了什么决策，不影响下一个阶段的决策。但是打家劫舍&amp;股票买卖这类问题，上一个阶段的决策会影响下一个阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值</li>\n</ul>\n</li>\n<li><p>爬楼梯问题</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221218154319803.png\" alt=\"image-20221218154319803\"></p>\n</li>\n<li><p>匹配问题（LCS、编辑距离）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221219132527375.png\" alt=\"image-20221219132527375\"></p>\n</li>\n<li><p>其他（LIS）</p>\n</li>\n</ol>\n<h3 id=\"3-动态规划相关题型\"><a href=\"#3-动态规划相关题型\" class=\"headerlink\" title=\"3.动态规划相关题型\"></a>3.动态规划相关题型</h3><h2 id=\"15-其它\"><a href=\"#15-其它\" class=\"headerlink\" title=\"15.其它\"></a>15.其它</h2><h3 id=\"1-海量数据处理\"><a href=\"#1-海量数据处理\" class=\"headerlink\" title=\"1.海量数据处理\"></a>1.海量数据处理</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一台机器的内存存不下，或者一台机器处理的太慢了</p></blockquote>\n<ol>\n<li>处理的核心思想：分治<ol>\n<li>单机：利用外存，分批加入内存处理</li>\n<li>多机：对数据分片，利用多机内存存储</li>\n<li>多机：并行计算，利用多线程、多机并行处理</li>\n</ol>\n</li>\n<li>一些处理技巧<ol>\n<li>外部排序：多路归并、桶排序</li>\n<li>哈希分片</li>\n<li>位图</li>\n</ol>\n</li>\n<li>常见的问题<ol>\n<li>海量数据排序</li>\n<li>海量数据查询</li>\n<li>海量数据TopK</li>\n<li>海量数据求频率TopK</li>\n<li>海量数据去重/找重</li>\n<li>两海量文件找重</li>\n</ol>\n</li>\n<li>例题：先考虑非海量，再调整方案适配海量<ol>\n<li>按照金额大小给10GB的订单文件进行排序<ol>\n<li>法一：分成n份，对每一份排序，再从每一份中拿出一个数字，进行排序并一个一个存回外存</li>\n<li>法二：桶排序，把数据分成10个桶，再对每一个桶排序</li>\n</ol>\n</li>\n<li>有一个IP地址白名单文件，包含10亿个IP地址，判断某IP是否在白名单中<ol>\n<li>若能存下：只需要构造哈希表或红黑树</li>\n<li>因为所有IP地址（0~2^32-1）一个地址一位，一共只需要500MB，所以可以构成位图，可以在为图里查询</li>\n<li>位图放不下的时候，使用多机的内存，通过对每个IP求MD5（Hash后分布均匀）再进行Hash，放到不同的机器上，在对应机器上构造位图</li>\n</ol>\n</li>\n<li>10亿个整数求Top100<ol>\n<li>都能放到内存里，使用堆</li>\n<li>放不到内存里，也可以使用堆，顺序读数据，构造小顶堆</li>\n</ol>\n</li>\n<li>100GB的搜索关键字文件，统计出现频率Top100关键词<ol>\n<li>统计频率的方法：先排序再顺序扫描，或者使用Hash表</li>\n<li>单机上：<ol>\n<li>多路归并排序、在统计出现频率、再通过堆求Top100</li>\n<li>通过Hash表：先分片，对每个关键词求MD5，求Hash，每次加载进去Hash值相同的一份，并统计频率再写回，一共N份，顺序读求TopK</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>一个文件包含10亿条URL，有可能会有重复的，将重复的去掉<ol>\n<li>如果内存能放下：排序/Hash去重</li>\n<li>排序去重</li>\n<li>Hash分片，把每一个分片都放到内存，去重后写回</li>\n</ol>\n</li>\n<li>a，b两个文件，各自有50亿条URL，每条URL占用64字节，内存限制是4GB，找出a，b文件共同的URL<ol>\n<li>分别排序，在顺序扫描，双指针问题</li>\n<li>Hash分片分别分成成N份，每次各取出一份，去重，再写回</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>配套练习<ul>\n<li>如何从大量的URL中找出相同的URL（百度）</li>\n<li>如何从大量数据中找出高频词（百度）</li>\n<li>如何找出某一天访问百度网站最多的IP（百度）</li>\n<li>如何在大量的数据中找出不重复的整数（百度）</li>\n<li>如何在大量的数据中判断一个数是否存在（腾讯）</li>\n<li>如何查找最热门的查询串（腾讯）</li>\n<li>如何统计不同电话号码的个数（百度）</li>\n<li>如何从5亿个数中找出中位数（百度）</li>\n<li>如何按照query的频度排序（百度）</li>\n<li>如何找出排名前500的数（腾讯）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-双指针\"><a href=\"#2-双指针\" class=\"headerlink\" title=\"2.双指针\"></a>2.双指针</h3><ol>\n<li>比较常考，主要用来求数对，特殊排序。单数组上前后指针、快慢指针、区间指针、双数组上的指针</li>\n</ol>\n<h3 id=\"3-滑动窗口\"><a href=\"#3-滑动窗口\" class=\"headerlink\" title=\"3.滑动窗口\"></a>3.滑动窗口</h3><ol>\n<li>常用来解决：求连续子串、连续子序列、连续子数组</li>\n</ol>\n<h3 id=\"4-前缀后缀匹配\"><a href=\"#4-前缀后缀匹配\" class=\"headerlink\" title=\"4.前缀后缀匹配\"></a>4.前缀后缀匹配</h3><ol>\n<li>不常考，前缀和、后缀和、前缀积、后缀积、前缀最大、后缀最大</li>\n<li>支持频繁+快速的区间估计</li>\n</ol>\n<h3 id=\"5-位运算-1\"><a href=\"#5-位运算-1\" class=\"headerlink\" title=\"5.位运算\"></a>5.位运算</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221219170152673.png\" alt=\"image-20221219170152673\"></p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221219170824535.png\" alt=\"image-20221219170824535\"></p>\n<h1 id=\"Design-Pattern\"><a href=\"#Design-Pattern\" class=\"headerlink\" title=\"Design Pattern\"></a>Design Pattern</h1><h2 id=\"1-高质量代码评价原则\"><a href=\"#1-高质量代码评价原则\" class=\"headerlink\" title=\"1.高质量代码评价原则\"></a>1.高质量代码评价原则</h2><ul>\n<li>可维护性（maintainability）<br>bug 容易修复，修改、添加功能能够轻松完成</li>\n<li>可读性（readability）<br>同事可以轻松地读懂你写的代码</li>\n<li>可扩展性（extensibility）<br>代码预留了一些功能扩展点，不用改动大量的源代码，就你可以把新功能代码，直接插到扩展点上</li>\n<li>灵活性（flexibility）<br>代码易扩展、易复用或者易用</li>\n<li>简洁性（simplicity）<br>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题</li>\n<li>可复用性（reusability）<br>尽量减少重复代码的编写，复用已有的代码</li>\n<li>可测试性（testability）<br>单元测试比较好写</li>\n</ul>\n<h2 id=\"2-编程范式\"><a href=\"#2-编程范式\" class=\"headerlink\" title=\"2.编程范式\"></a>2.编程范式</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Program = Logic+Control+Data Structure，有效地分离 Logic、Control（遍历数据、查找数据、多线程、并发、异步） 和 Data（用户的业务逻辑）是写出好程序的关键所在！Logic 部分才是真正有意义的（What），Control 部分只是影响 Logic 部分的效率（How）</p></blockquote>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/4a8c7c77df1f1a6b3ff701577986ee92-165668658181333.png\" alt=\"img\"></p>\n<p>==如何分离control 和 logic==</p>\n<ul>\n<li>State Machine<ul>\n<li>状态定义</li>\n<li>状态变迁</li>\n<li>条件状态的 action</li>\n</ul>\n</li>\n<li>DSL – Domain Specific Language<ul>\n<li>HTML，SQL，Unix Shell Script，AWK，正则表达式……</li>\n</ul>\n</li>\n<li>编程范式<ul>\n<li>面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC……</li>\n<li>函数式编程：修饰、管道、拼装</li>\n<li>逻辑推导式编程：Prolog    </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-面向过程（C）\"><a href=\"#1-面向过程（C）\" class=\"headerlink\" title=\"1.面向过程（C）\"></a>1.面向过程（C）</h3><ol>\n<li>面向过程编程，以过程（方法、函数、操作）作为组织代码的基本单元，以数据（成员变量、属性）与方法相分离为主要的特点，通过拼接一组顺序执行的方法来操作数据完成一项功能。</li>\n<li>适合开发微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅</li>\n</ol>\n<h3 id=\"2-面向对象（Java）\"><a href=\"#2-面向对象（Java）\" class=\"headerlink\" title=\"2.面向对象（Java）\"></a>2.面向对象（Java）</h3><ol>\n<li><p>Why</p>\n<ol>\n<li>面向对象VS面向过程<ol>\n<li>面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。面向对象风格的代码组织成一组类，方法和数据机构被绑定在一起，定义在类中。</li>\n<li>面向过程比较适合处理流程只有一条主线的程序，面向过程更适合大规模复杂程序（网状处理流程）的开发，先建模为类再按照处理流程搭建起整个程序。</li>\n<li>==编程==：<ol>\n<li>慎用getter、setter方法</li>\n<li>慎用全局变量和全局方法<ul>\n<li>静态方法可以在不创建对象的情况下直接使用</li>\n<li>不用包含全部final变量的Constants类，慎用只包含静态方法的Utils类</li>\n</ul>\n</li>\n<li>不定义数据和方法分离的类，例如MVC中将业务逻辑和数据分离开来（见贫血模型）</li>\n</ol>\n</li>\n<li>面向对象编程是一种自底向上的思考方式，不是按照执行流程来分解任务，而是将任务翻译成一个一个小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>What</p>\n<ol>\n<li><p>面向对象：</p>\n<ol>\n<li>面向对象分析、面向对象设计：围绕着对象和类来做软件开发中的需求分析和系统设计的，分析和设计两个阶段最终的产出式类的设计，包括程序==被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互、将类组装起来并提供执行入口==。他们比其它的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地渡过面向对象编程环节。</li>\n<li>面向对象编程：一种编程范式或编程风格，他以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石</li>\n<li>面向对象编程语言：是一种支持类和对象的，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言</li>\n</ol>\n</li>\n<li><p>四大特性：</p>\n<ol>\n<li><p>封装（Encapsulation）：</p>\n<ul>\n<li>类通过暴漏有限的访问接口，授权外部仅能通过类提供的方法（或叫函数）来访问内部信息或者数据。</li>\n<li>需要依靠编程语言本身提供一定的语法机制来支持，即访问访问权限控制（private、public等关键字）</li>\n<li>意义：对类中的属性可控使得代码易维护，仅暴漏必要的操作提高类的易用性，</li>\n</ul>\n</li>\n<li><p>抽象（Abstraction）：</p>\n<ul>\n<li>抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</li>\n<li>常通过编程语言提供的接口类（interface）或者抽象类（abstract）来实现抽象这一特性，使用者只需要了解接口类暴漏了哪些方法而不需要查看类里的具体实现逻辑。也可以依靠函数这一语法机制，调用者不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档，了解其提供了什么功能，就可以直接使用了。</li>\n<li>帮助我们过滤掉许多非必要的信息，指导我们定义类的方法时，要有抽象思维，不要暴漏太多实现细节</li>\n</ul>\n</li>\n<li><p>继承（Inheritance）：</p>\n<ul>\n<li>用来表示类之间is-a的关系</li>\n<li>通过编程语言中的特殊语法机制：Java中的extends、C++中的：，Python中的parentheses（）、Ruby中的&lt;，其中C++、Python、Perl支持多继承</li>\n<li>继承最大的一个好处就是代码复用，将两个类中的相同属性和方法抽象到父类中，但过度使用继承，继承层次过深过复杂，会导致代码的可读性、可维护性变差</li>\n<li>==多继承==：Java 不支持多重继承的原因 多重继承有副作用：钻石问题(菱形继承)。 假设类 B 和类 C 继承自类 A，且都重写了类 A 中的同一个方法，而类 D 同时继承了类 B 和类 C，那么此时类 D 会继承 B、C 的方法，那对于 B、C 重写的 A 中的方法，类 D 会继承哪一个呢？这里就会产生歧义。 考虑到这种二义性问题，Java 不支持多重继承。但是 Java 支持多接口实现，因为接口中的方法，是抽象的（从JDK1.8之后，接口中允许给出一些默认方法的实现，这里不考虑这个），就算一个类实现了多个接口，且这些接口中存在某个同名方法，但是我们在实现接口的时候，这个同名方法需要由我们这个实现类自己来实现，所以并不会出现二义性的问题。</li>\n</ul>\n</li>\n<li><p>多态（Polymorphism）：</p>\n<ul>\n<li><p>多态是指子类可以替换父类，提高代码的可扩展性和复用性，</p>\n</li>\n<li><p>有三种实现方法</p>\n</li>\n<li><p>继承加重写</p>\n<ul>\n<li><p>编程语言需要：支持父类对象可以引用子类对象、支持继承、支持子类可以重写父类的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Iterator &#123;\n  boolean hasNext();\n  String next();\n  String remove();\n&#125;\n\npublic class Array implements Iterator &#123;\n  private String[] data;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法...\n&#125;\n\npublic class LinkedList implements Iterator &#123;\n  private LinkedListNode head;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法... \n&#125;\n\npublic class Demo &#123;\n  private static void print(Iterator iterator) &#123;\n    while (iterator.hasNext()) &#123;\n      System.out.println(iterator.next());\n    &#125;\n  &#125;\n  \n  public static void main(String[] args) &#123;\n    Iterator arrayIterator &#x3D; new Array();\n    print(arrayIterator);\n    \n    Iterator linkedListIterator &#x3D; new LinkedList();\n    print(linkedListIterator);\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>接口类</p>\n<ul>\n<li><p>更易扩展</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Iterator &#123;\n  boolean hasNext();\n  String next();\n  String remove();\n&#125;\n\npublic class Array implements Iterator &#123;\n  private String[] data;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法...\n&#125;\n\npublic class LinkedList implements Iterator &#123;\n  private LinkedListNode head;\n  \n  public boolean hasNext() &#123; ... &#125;\n  public String next() &#123; ... &#125;\n  public String remove() &#123; ... &#125;\n  &#x2F;&#x2F;...省略其他方法... \n&#125;\n\npublic class Demo &#123;\n  private static void print(Iterator iterator) &#123;\n    while (iterator.hasNext()) &#123;\n      System.out.println(iterator.next());\n    &#125;\n  &#125;\n  \n  public static void main(String[] args) &#123;\n    Iterator arrayIterator &#x3D; new Array();\n    print(arrayIterator);\n    \n    Iterator linkedListIterator &#x3D; new LinkedList();\n    print(linkedListIterator);\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>duck-typing语法</p>\n<ul>\n<li><p>只要两个类有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，是一些动态语言所特有的语法机制</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class Logger:\n    def record(self):\n        print(“I write a log into file.”)\n        \nclass DB:\n    def record(self):\n        print(“I insert data into db. ”)\n        \ndef test(recorder):\n    recorder.record()\n\ndef demo():\n    logger &#x3D; Logger()\n    db &#x3D; DB()\n    test(logger)\n    test(db)</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Where</p>\n<ol>\n<li><p>实战一：基于贫血模型的MVC架构<code>VS</code>基于充血模型的DDD架构</p>\n<ol>\n<li><p>MVC：M 表示 Model，V 表示 View，C 表示 Controller。它将整个项目分为三层：展示层、逻辑层、数据层。并根据具体的项目需求，做适当的调整。例如：现在前后端分离的项目Web或App项目中，一般后端项目分为Repository层、Service层、Controller层，其中Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴漏接口</p>\n</li>\n<li><p>DDD：领域驱动设计（Domain Driven Design），主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。微服务的兴起加速了领域驱动设计的盛行。</p>\n</li>\n<li><p>贫血模型：只包含数据不包含业务逻辑的类（UserEntity）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Controller+VO(View Object)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserController&#123;\n    private UserService userService;&#x2F;&#x2F;通过构造函数或者IOC框架注入\n    \n    public UserVO getUserById(Long userId)&#123;\n        UserBo userBo &#x3D; userService.getUserById(userId);\n        userVo userVo &#x3D; [...convert userBo to userVo];\n        return userVo;\n    &#125;\n&#125;\npublic class UserVo&#123;&#x2F;&#x2F;省略其他属性，get、set、construct方法\n    private Long id;\n    private String name;\n    private String cellphone;\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Service+BO(Business Object)&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserService&#123;\n    private UserRepository userRepository;&#x2F;&#x2F;通过构造函数或者IOC框架注入\n    \n    public UserBo getUserById(Long userId)&#123;\n        UserEntity userEntity &#x3D; userRepository.getUserById(userId);\n        UserBo userBo &#x3D; [...convert userEntity to userBo...];\n        return userBo;\n    &#125;\n&#125;\npublic class UserBo&#123;&#x2F;&#x2F;省略其他属性，get、set、construct方法\n    private Long id;\n    private String name;\n    private String cellphone;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Repository+Entity&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class UserRepository&#123;\n    public UserEntity getUserById(Long userId)&#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\npublic class UserEntity&#123;\n    &#x2F;&#x2F;省略其他属性和get、set、construct方法\n    private long id;\n    private String name;\n    private String cellphone;\n&#125;</code></pre></li>\n<li><p>充血模型：数据和业务逻辑本封装到同一个类中</p>\n<ol>\n<li>Service类负责与Repository层打交道，调用Repository类的方法，获取数据库中的数据，转换成领域模型Domain，然后由Domain来完成业务逻辑，最后调用Repository类的方法，将数据返回数据库。Service类负责跨领域模型的业务聚合功能，例如需要多个实体的操作。Service类负责一些功能性及第三方系统交互的工作。</li>\n<li>Controller层和Repository层，因为业务较少，所以没必改成充血模型</li>\n</ol>\n</li>\n<li><p>基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。基于充血模型的DDD开发模式，更适合业务复杂的系统开发。</p>\n<ol>\n<li>落实到代码层面，就是一个将业务逻辑放到Service类中，一个将业务逻辑放到Domain领域模型中</li>\n<li>开发流程不同：<ul>\n<li>SQL驱动开发：依据接口需求，去写SQL语句，定义Entity、BO、VO，然后模板式地往对应的Repository、Service、Controller类中添加代码，业务逻辑包裹在一个大的SQL语句中，而Service层可以做的事情很少，新功能开发，只能重写新的SQL语句</li>\n<li>业务驱动开发（DDD）：在这种开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法，领域模型相当于可复用的业务中间层，新功能的开发，都基于之前定义好的这些领域模型来完成。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>如何对接口鉴权这样一个功能开发做面向对象分析</p>\n<ol>\n<li>需求分析：先从最简单的方案想起，不断优化，得到若干条需求</li>\n<li>==需求设计==：<ul>\n<li>划分模块-&gt;拆分功能点（名词）-&gt;组合成类</li>\n<li>定义类及其属性和方法：找动词作为候选的方法，再进一步筛选出真正的方法</li>\n<li>定义类与类之间的交互方式：UML包括六种：泛化、实现、关联、聚合、组合、依赖，==我们保留==：泛化（继承）、实现（接口）、组合（B是A的成员变量）、依赖（A与B有关系即可）</li>\n<li>将类组装起来并提供执行入口：main()或API接口</li>\n</ul>\n</li>\n<li>编程实现：</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>How</p>\n<ol>\n<li><p>接口（has-a）VS抽象类（is-a）</p>\n<ol>\n<li><p>抽象类的特性：抽象类不允许被实例化，只能被继承（不能new出来一个对象）；抽象类可以包含属性和方法，其中方法既可以包含代码实现，也可以不包含代码实现（抽象方法）；子类继承抽象类，必须实现抽象类中的所有抽象方法。</p>\n<ul>\n<li>相比较于继承，抽象类可以更优雅的保证多态的特性</li>\n</ul>\n</li>\n<li><p>接口的特性：接口不能包含属性（成员变量）；接口只能声明方法，方法不能包含代码实现；类实现接口的时候，必须实现接口中声明的所有方法。</p>\n<ul>\n<li><p>抽象类更多的是为了代码复用，而接口就更侧重于解耦，接口是对行为的一种抽象，相当于一组协议或契约</p>\n</li>\n<li><p>用抽象类模拟接口：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Strategy &#123; &#x2F;&#x2F; 用抽象类模拟接口\n  public:\n    ~Strategy();\n    virtual void algorithm()&#x3D;0;&#x2F;&#x2F;virtual相当于abstract\n  protected:\n    Strategy();\n&#125;;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MockInteface &#123;\n    &#x2F;&#x2F;protected修饰构造函数，避免非同包下的类去实例化这个类\n    &#x2F;&#x2F;亦可见Guava包中的@VisibleForTesting\n  protected MockInteface() &#123;&#125;\n  public void funcA() &#123;\n      &#x2F;&#x2F;模拟不包含实现的接口，并且子类必须主动实现父类的方法\n    throw new MethodUnSupportedException();\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>如何决定该用抽象类还是接口：</p>\n<ol>\n<li>需要表示一种is-a的关系，并且是为了解决代码复用的问题，我们就用抽象类。从设计思路上来看，是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（抽象类）</li>\n<li>需要表示一种has-a的关系，并且是为了解决抽象而非代码复用的问题，我们就用接口。从设计思路上来看，是一种自上而下的设计思路，在编程的时候一般是先设计接口，再去考虑具体的实现。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>基于接口VS基于实现</p>\n<ol>\n<li>基于接口而不是基于实现编程，可以将接口和实现相分离，封装不稳定的实现细节，暴露稳定的接口，上游系统面向接口而非实现编程，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低代码间的耦合性，提高扩展性。（越不稳定的系统，越是要在代码的扩展性、维护性上下功夫）</li>\n<li>在软件开发中，最大的挑战之一就是需求的不断变化，越抽象，越顶层，越脱离某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。</li>\n<li>如何做：<ol>\n<li>函数的命名不能暴漏任何实现细节</li>\n<li>封装具体的实现细节</li>\n<li>为实现类定义抽象的接口，具体的实现类都依赖统一的接口定义，遵从一致的功能协议，使用者以来接口，而不是具体的实现类来编程。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>组合VS继承</p>\n<ol>\n<li><p>组合优先于继承，多用组合少用继承</p>\n<ul>\n<li><p>继承可能过深，继承关系过于复杂会影响到代码的可读性和可维护性，也无法处理特例问题</p>\n</li>\n<li><p>通过组合、接口、委托三个技术解决继承的问题：针对每种特例实现一个相关接口，再实现一个实现类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Flyable &#123;\n  void fly()；\n&#125;\npublic class FlyAbility implements Flyable &#123;\n  @Override\n  public void fly() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n&#x2F;&#x2F;省略Tweetable&#x2F;TweetAbility&#x2F;EggLayable&#x2F;EggLayAbility\n\npublic class Ostrich implements Tweetable, EggLayable &#123;&#x2F;&#x2F;鸵鸟\n  private TweetAbility tweetAbility &#x3D; new TweetAbility(); &#x2F;&#x2F;组合\n  private EggLayAbility eggLayAbility &#x3D; new EggLayAbility(); &#x2F;&#x2F;组合\n  &#x2F;&#x2F;... 省略其他属性和方法...\n  @Override\n  public void tweet() &#123;\n    tweetAbility.tweet(); &#x2F;&#x2F; 委托\n  &#125;\n  @Override\n  public void layEgg() &#123;\n    eggLayAbility.layEgg(); &#x2F;&#x2F; 委托\n  &#125;\n&#125;</code></pre></li>\n<li><p>如何判断改用组合还是继承：继承改写成组合意味着要做细粒度的类的划分，要定义更多的类和接口，增加代码复杂度和维护成本。</p>\n<ul>\n<li><p>如果继承层次低，可以使用继承。</p>\n</li>\n<li><p>如果只是为了代码复用，则可以使用组合。</p>\n</li>\n<li><p>如果不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-原型编程（JavaScript）\"><a href=\"#3-原型编程（JavaScript）\" class=\"headerlink\" title=\"3.原型编程（JavaScript）\"></a>3.原型编程（JavaScript）</h3><ol>\n<li><p>定义：面向对象里面要有个 Class。但是 JavaScript 觉得不是这样的，它就是要基于原型编程，就不要 Class，就直接在对象上改就行了，基于编程的修改，直接对类型进行修改</p>\n<ol>\n<li>__proto__ 主要是安放在一个实际的对象中，用它来产生一个链接，一个原型链，用于寻找方法名或属性，等等。</li>\n<li>prototype 是用 new 来创建一个对象时构造__proto__ 用的。它是构造函数的一个属性。</li>\n<li>我们可以简单地认为：__proto__ 是所有对象用于链接原型的一个指针，而 prototype 则是 Function 对象的属性，其主要是用来当需要new一个对象时让 __proto__  指针所指向的地方。 对于超级对象 Function 而言， Function.__proto__ 就是 Function.prototype。</li>\n</ol>\n</li>\n<li><p>面向对象</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F;Define human class\nvar Person &#x3D; function (fullName, email) &#123;\n  this.fullName &#x3D; fullName;\n  this.email &#x3D; email;\n  \n  this.speak &#x3D; function()&#123;\n    console.log(&quot;I speak English!&quot;);\n  &#125;;\n  this.introduction &#x3D; function()&#123;\n    console.log(&quot;Hi, I am &quot; + this.fullName);\n  &#125;;\n&#125;\n\n\n&#x2F;&#x2F;Define Student class\nvar Student &#x3D; function(fullName, email, school, courses) &#123;\n\n  Person.call(this, fullName, email);\n\n  &#x2F;&#x2F; Initialize our Student properties\n  this.school &#x3D; school;\n  this.courses &#x3D; courses;\n  \n  &#x2F;&#x2F; override the &quot;introduction&quot; method\n  this.introduction&#x3D; function()&#123;\n  console.log(&quot;Hi, I am &quot; + this.fullName + \n        &quot;. I am a student of &quot; + this.school + \n        &quot;, I study &quot;+ this.courses +&quot;.&quot;);\n  &#125;;\n  \n  &#x2F;&#x2F; Add a &quot;exams&quot; method\n  this.takeExams &#x3D; function()&#123;\n    console.log(&quot;This is my exams time!&quot;);\n  &#125;;\n&#125;;\n\n\n&#x2F;&#x2F; Create a Student.prototype object that inherits \n&#x2F;&#x2F; from Person.prototype.\nStudent.prototype &#x3D; Object.create(Person.prototype); \n\n&#x2F;&#x2F; Set the &quot;constructor&quot; property to refer to Student\nStudent.prototype.constructor &#x3D; Student;\n\n\n&#x2F;&#x2F;使用\nvar student &#x3D; new Student(&quot;Hao Chen&quot;, \n              &quot;haoel@hotmail.com&quot;,\n              &quot;XYZ University&quot;, \n              &quot;Computer Science&quot;);\nstudent.introduction();   \nstudent.speak();       \nstudent.takeExams(); \n\n&#x2F;&#x2F; Check that instanceof works correctly\nconsole.log(student instanceof Person);  &#x2F;&#x2F; true \nconsole.log(student instanceof Student); &#x2F;&#x2F; true</code></pre></li>\n</ol>\n<h3 id=\"4-函数式编程（Lisp）\"><a href=\"#4-函数式编程（Lisp）\" class=\"headerlink\" title=\"4.函数式编程（Lisp）\"></a>4.函数式编程（Lisp）</h3><ol>\n<li><p>概念：只关心定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的，即==describe what to do, rather than how to do it==，有以下特点：</p>\n<ol>\n<li><strong>stateless</strong>：函数不维护任何状态。函数式编程的核心精神是 stateless，简而言之就是它不能存在状态，打个比方，你给我数据我处理完扔出来。里面的数据是不变的。</li>\n<li><strong>immutable</strong>：输入数据是不能动的，动了输入数据就有危险，所以要返回新的数据集。</li>\n<li><strong>优势</strong>：没有状态就没有伤害。并行执行无伤害。Copy-Paste 重构代码无伤害。函数的执行没有顺序上的问题。</li>\n<li><strong>惰性求值</strong>：这需要编译器的支持，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。</li>\n<li><strong>确定性</strong>：所谓确定性，就是像在数学中那样，f(x) = y 这个函数无论在什么场景下，都会得到同样的结果，而不是像程序中的很多函数那样。同一个参数，在不同的场景下（函数会根据运行中的状态信息的不同而发生变化）会计算出不同的结果，这个我们称之为函数的确定性。</li>\n<li><strong>缺点</strong>：数据复制比较严重，但因为没有状态，并发不需要锁，可以提高并发的使用率</li>\n</ol>\n</li>\n<li><p>函数式编程用到的技术</p>\n<ol>\n<li><strong>first class function（头等函数）</strong> ：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建、修改，并当成变量一样传递、返回，或是在函数中嵌套函数。</li>\n<li><strong>tail recursion optimization（尾递归优化）</strong> ： 我们知道递归的害处，那就是如果递归很深的话，stack 受不了，并会导致性能大幅度下降。因此，我们使用尾递归优化技术——每次递归时都会重用 stack，这样能够提升性能。当然，这需要语言或编译器的支持。Python 就不支持。</li>\n<li><strong>map &amp; reduce</strong> ：这个技术不用多说了，函数式编程最常见的技术就是对一个集合做 Map 和 Reduce 操作。这比起过程式的语言来说，在代码上要更容易阅读。（传统过程式的语言需要使用 for/while 循环，然后在各种变量中把数据倒过来倒过去的）这个很像 C++ STL 中 foreach、find_if、count_if 等函数的玩法。</li>\n<li><strong>pipeline（管道）</strong>：这个技术的意思是，将函数实例成一个一个的 action，然后将一组 action 放到一个数组或是列表中，再把数据传给这个 action list，数据就像一个 pipeline 一样顺序地被各个函数所操作，最终得到我们想要的结果。</li>\n<li><strong>recursing（递归）</strong> ：递归最大的好处就是简化代码，它可以把一个复杂的问题用很简单的代码描述出来。注意：递归的精髓是描述问题，而这正是函数式编程的精髓。</li>\n<li><strong>currying（柯里化）</strong> ：将一个函数的多个参数分解成多个函数， 然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数，这可以简化函数的多个参数。在 C++ 中，这很像 STL 中的 bind1st 或是 bind2nd。</li>\n<li><strong>higher order function（高阶函数）</strong>：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象满天飞一样。这个技术用来做 Decorator 很不错。</li>\n</ol>\n</li>\n<li><p>函数式语言的三套件：Map、Reduce、Filter</p>\n</li>\n<li><p>Pipeline模式：pipeline（管道）借鉴于 Unix Shell 的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。</p>\n</li>\n<li><p>Decorator（修饰器）模式：</p>\n<ol>\n<li><p>Python的Decorator</p>\n<ol>\n<li><p>Python 的 Decorator 在使用上和 Java 的 Annotation（以及 C# 的 Attribute）很相似，就是在方法名前面加一个 @XXX 注解来为这个方法装饰一些东西。但是，Java/C# 的 Annotation 太过于复杂了，需要先了解一堆 Annotation 的类库文档，几乎就是在学另外一门语言。</p>\n</li>\n<li><p>Python的@注解语法糖：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">#当用某个 @decorator 来修饰某个函数 func 时（可以带参数）\n@decorator\ndef func():\n    pass\n#解释器会解释成下面这样的语句\nfunc &#x3D; decorator(func)\n#注意：还有一个赋值语句，把 decorator 这个函数的返回值赋值回了原来的 func。</code></pre></li>\n<li><p>类方式的decorator：</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">class myDecorator(object):\n    def __init__(self, fn):\n        print &quot;inside myDecorator.__init__()&quot;\n        self.fn &#x3D; fn\n \n    def __call__(self):\n        self.fn()\n        print &quot;inside myDecorator.__call__()&quot;\n \n@myDecorator\ndef aFunction():\n    print &quot;inside aFunction()&quot;\n \nprint &quot;Finished decorating aFunction()&quot;\n \naFunction()\n \n# 输出：\n# inside myDecorator.__init__()\n# Finished decorating aFunction()\n# inside aFunction()\n# inside myDecorator.__call__()</code></pre></li>\n</ol>\n</li>\n<li><p>Go的Decorator</p>\n<ol>\n<li><p>Go没有修饰器语法糖</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc decorator(f func(s string)) func(s string) &#123;\n    return func(s string) &#123;\n        fmt.Println(&quot;Started&quot;)\n        f(s)\n        fmt.Println(&quot;Done&quot;)\n    &#125;\n&#125;\n\nfunc Hello(s string) &#123;\n    fmt.Println(s)\n&#125;\n\nfunc main() &#123;\n    decorator(Hello)(&quot;Hello, World!&quot;)\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-泛型编程（C-）\"><a href=\"#5-泛型编程（C-）\" class=\"headerlink\" title=\"5.泛型编程（C++）\"></a>5.泛型编程（C++）</h3><ol>\n<li><p>C 语言</p>\n<ol>\n<li><p>C语言特性：</p>\n<ol>\n<li>C 语言是一个静态弱类型语言，在使用变量时需要声明变量类型，但是类型间可以有隐式转换；</li>\n<li>不同的变量类型可以用结构体（struct）组合在一起，以此来声明新的数据类型；</li>\n<li>C 语言可以用 typedef 关键字来定义类型的别名，以此来达到变量类型的抽象；</li>\n<li>C 语言是一个有结构化程序设计、具有变量作用域以及递归功能的过程式语言；</li>\n<li>C 语言传递参数一般是以值传递，也可以传递指针；</li>\n<li>通过指针，C 语言可以容易地对内存进行低级控制，然而这加大了编程复杂度；</li>\n<li>编译预处理让 C 语言的编译更具有弹性，比如跨平台。</li>\n</ol>\n</li>\n<li><p>C语言的泛型：</p>\n<ol>\n<li><p>产生原因：通过使用一种更为通用的方式（抽象和隔离），让复杂的“世界”变得简单一些。</p>\n</li>\n<li><p>C语言中的泛型实现：</p>\n<ul>\n<li>函数接口中增加了一个size参数</li>\n<li>函数的实现中使用了memcpy()函数</li>\n<li>函数的实现中使用了一个temp[size]数组</li>\n<li>示例一：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;宏定义实现，但会有重复执行的问题\n#define swap(x, y, size) &#123;\\\n  char temp[size]; \\\n  memcpy(temp, &amp;y, size); \\\n  memcpy(&amp;y,   &amp;x, size); \\\n  memcpy(&amp;x, temp, size); \\\n&#125;\n&#x2F;&#x2F;void*实现\nvoid swap(void* x, void* y, size_t size)\n&#123;\n     char tmp[size];\n     memcpy(tmp, y, size);\n     memcpy(y, x, size);\n     memcpy(x, tmp, size);\n&#125;\n</code></pre>\n\n<ul>\n<li>示例二：</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;非泛型\nint search(int* a, size_t size, int target) &#123;\n  for(int i&#x3D;0; i&lt;size; i++) &#123;\n    if (a[i] &#x3D;&#x3D; target) &#123;\n      return i;\n    &#125;\n  &#125;\n  return -1;\n&#125;\n&#x2F;&#x2F;泛型\nint search(void* a, size_t size, void* target, \n  size_t elem_size, int(*cmpFn)(void*, void*) )\n&#123;\n  for(int i&#x3D;0; i&lt;size; i++) &#123;\n    &#x2F;&#x2F; why not use memcmp()\n    &#x2F;&#x2F; use unsigned char * to calculate the address\n    if ( cmpFn ((unsigned char *)a + elem_size * i, target) &#x3D;&#x3D; 0 ) &#123;\n      return i;\n    &#125;\n  &#125;\n  return -1;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>C语言总结：</p>\n<ol>\n<li>C 语言设计目标：提供一种能以简易的方式编译、处理底层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言</li>\n<li>C语言的伟大之处：使用 C 语言的程序员在高级语言的特性之上还能简单地做任何底层上的微观控制</li>\n<li>C语言的缺陷：对于更高阶、更为抽象的编程模型来说，C 语言这种基于过程和底层的初衷设计方式就会成为它的短板。因为，在编程这个世界中，更多的编程工作是解决业务上的问题，而不是计算机的问题，所以，我们需要更为贴近业务、更为抽象的语言。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>C++语言</p>\n<ol>\n<li><p>C++设计初衷：早期 C++ 的许多工作是对 C 的强化和净化，并把完全兼容 C 作为强制性要求，C++ 很大程度就是用来解决 C 语言中的各种问题和各种不方便的，如下：</p>\n<ol>\n<li>用引用来解决指针的问题。用 namespace 来解决名字空间冲突的问题。</li>\n<li>通过 try-catch 来解决检查返回值编程的问题。</li>\n<li>用 class 来解决对象的创建、复制、销毁的问题，从而可以达到在结构体嵌套时可以深度复制的内存安全问题。</li>\n<li>通过重载操作符来达到操作上的泛型。（比如用&gt;&gt;操作符消除printf()的数据类型不够泛型的问题。）通过模板 template 和虚函数的多态以及运行时识别来达到更高层次的泛型和多态。用 RAII、智能指针的方式，解决了 C 语言中因为需要释放资源而出现的那些非常 ugly 也很容易出错的代码的问题。用 STL 解决了 C 语言中算法和数据结构的 N 多种坑。</li>\n</ol>\n</li>\n<li><p>C++泛型编程</p>\n<ol>\n<li><p>它通过类的方式来解决：让一个用户自定义的数据类型和内建的那些数据类型一致</p>\n<ol>\n<li>类里面会有构造函数、析构函数表示这个类的分配和释放。</li>\n<li>还有它的拷贝构造函数，表示了对内存的复制。</li>\n<li>还有重载操作符，像我们要去比较大于、等于、不等于。</li>\n</ol>\n</li>\n<li><p>通过模板达到类型和算法的妥协：模板很好地取代了 C 时代宏定义带来的问题</p>\n<ol>\n<li>模板有点像 DSL，模板的特化会根据使用者的类型在编译时期生成那个模板的代码。</li>\n<li>模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时的问题。</li>\n</ol>\n</li>\n<li><p>通过虚函数和运行时类型识别：可以写出基于抽象接口的泛型</p>\n<ol>\n<li>虚函数带来的多态在语义上可以支持“同一类”的类型泛型。</li>\n<li>运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。</li>\n</ol>\n</li>\n<li><p>示例：</p>\n<ol>\n<li>使用模板技术来抽象类型，这样可以写出类型无关的数据结构（数据容器）。</li>\n<li>使用一个迭代器来遍历或是操作数据结构内的元素。</li>\n</ol>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template&lt;typename T, typename Iter&gt;\nIter search(Iter pStart, Iter pEnd, T target) \n&#123;\n  for(Iter p &#x3D; pStart; p !&#x3D; pEnd; p++) &#123;\n    if ( *p &#x3D;&#x3D; target ) \n      return p;\n  &#125;\n  return NULL;\n&#125;</code></pre>\n\n<ul>\n<li>使用typename T抽象了数据结构中存储数据的类型。</li>\n<li>使用typename Iter，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。</li>\n<li>我们对数据容器的遍历使用了Iter中的++方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。</li>\n<li>在函数的入参上使用了pStart和pEnd来表示遍历的起止。</li>\n<li>使用*Iter来取得这个“指针”的内容。这也是通过重载 * 取值操作符来达到的泛型。</li>\n</ul>\n</li>\n<li><p>迭代器（简易版）：</p>\n<ul>\n<li>首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。</li>\n<li>它需要重载一些操作符，比如：取值操作*、成员操作-&gt;、比较操作==和!=，还有遍历操作++，等等。</li>\n<li>然后，还要typedef一些类型，比如value_type，告诉我们容器内的数据的实际类型是什么样子。</li>\n<li>还有一些，如begin()和end()的基本操作。</li>\n<li>我们还可以看到其中有一个pointer _ptr的内部指针来指向当前的数据（注意，pointer就是 T*）。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">template &lt;class T&gt;\nclass container &#123;\npublic:\n  class iterator &#123;\n  public:\n    typedef iterator self_type;\n    typedef T   value_type;\n    typedef T*  pointer;\n    typedef T&amp;   reference;\n\n    reference operator*();\n    pointer operator-&gt;();\n    bool operator&#x3D;&#x3D;(const self_type&amp; rhs)；\n    bool operator!&#x3D;(const self_type&amp; rhs)；\n    self_type operator++() &#123; self_type i &#x3D; *this; ptr_++; return i; &#125;\n    self_type operator++(int junk) &#123; ptr_++; return *this; &#125;\n    ...\n    ...\n  private:\n    pointer _ptr;\n  &#125;;\n\n  iterator begin();\n  iterator end();\n  ...\n  ...\n&#125;;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>编程语言中的类型系统和泛型编程的本质</p>\n<ol>\n<li>类型系统：<ol>\n<li>定义：用于定义如何将编程语言中的数值和表达式归类为许多不同的类型，以及如何操作这些类型，还有这些类型如何互相作用。==任何语言都有类型系统，只是动态类型语言在运行时做类型检查==，一旦代码量比较大了，动态类型代码中出现“类型问题”而引发整个程序出错的情况非常多。</li>\n<li>功能：<ul>\n<li>程序语言的安全性。使用类型可以让编译器侦测一些代码的错误，如“Hello, World” + 3这样的不同数据类型间操作的问题。强类型语言提供更多的安全性，但是并不能保证绝对的安全。</li>\n<li>利于编译器的优化。 静态类型语言的类型声明，可以让编译器明确地知道程序员的意图。因此，编译器就可以利用这一信息做很多代码优化工作。例如：如果我们指定一个类型是 int ，那么编译就知道，这个类型会以 4 个字节的倍数进行对齐，编译器就可以非常有效地利用更有效率的机器指令。</li>\n<li>代码的可读性。有类型的编程语言，可以让代码更易读和更易维护，代码的语义也更清楚，代码模块的接口（如函数）也更丰富和清楚。</li>\n<li>抽象化。类型允许程序设计者对程序以较高层次的方式思考，而不是烦人的低层次实现。例如，我们使用整型或是浮点型来取代底层的字节实现，我们可以将字符串设计成一个值，而不是底层字节的数组。从高层上来说，类型可以用来定义不同模块间的交互协议，比如函数的入参类型和返回类型，从而可以让接口更有语义，而且不同的模块数据交换更为直观和易懂。</li>\n</ul>\n</li>\n<li>缺点：类型带来的问题就是我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。</li>\n</ol>\n</li>\n<li>泛型：<ol>\n<li>泛型的定义：屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型</li>\n<li>类型的本质：<ol>\n<li>类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配的策略。</li>\n<li>不同的类型，有不同的操作。所以，对于特定的类型，也有特定的一组操作。</li>\n</ol>\n</li>\n<li>泛型的目的：<ol>\n<li>标准化掉类型的内存分配、释放和访问。</li>\n<li>标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……</li>\n<li>标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……</li>\n<li>标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……</li>\n</ol>\n</li>\n<li>C++实现泛型的技术<ol>\n<li>通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。</li>\n<li>通过重载操作符，可以标准化类型的比较等操作。</li>\n<li>通过 iostream，标准化了类型的输入、输出控制。</li>\n<li>通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。</li>\n<li>通过迭代器来标准化数据容器的遍历操作。</li>\n<li>通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。</li>\n<li>通过函数式（函数对象），来标准化对于不同类型的特定操作。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-委托模式（Go）\"><a href=\"#6-委托模式（Go）\" class=\"headerlink\" title=\"6.委托模式（Go）\"></a>6.委托模式（Go）</h3><ol>\n<li>声明一个 struct，跟 C 很一样，然后直接把这个 struct 类型放到另一个 struct 里</li>\n</ol>\n<h2 id=\"3-设计原则\"><a href=\"#3-设计原则\" class=\"headerlink\" title=\"3.设计原则\"></a>3.设计原则</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一些代码设计的经验总结，重点掌握：设计初衷，解决的编程问题，应用场景</p></blockquote>\n<h3 id=\"3-1SOLID原则\"><a href=\"#3-1SOLID原则\" class=\"headerlink\" title=\"3.1SOLID原则\"></a>3.1SOLID原则</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221208162810262.png\" alt=\"image-20221208162810262\"></p>\n<ol>\n<li><p>SRP单一职责原则：==A class or module should hava a single responsibility==</p>\n<ol>\n<li>不要设计大而全的类，要设计粒度小、功能单一的类。也就是说，如果一个类包含了两个或以上业务不相干的功能，那么他的职责就不够单一，应该被拆分成多个功能单一、粒度更细的类。</li>\n<li>要判断职责是否单一，不能脱离具体的应用场景，所以可以先写一个粗粒度的类，满足业务需求，随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个独粒度的类拆分成几个更细粒度的类，这就是所谓的==持续重构==。</li>\n<li>==技巧==：<ul>\n<li>类中的代码行数（200行内）、函数或属性过多（少于10个），会影响代码的可读性和可维护性，我们就需要对类进行拆分</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要对类进行拆分</li>\n<li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性</li>\n<li>比较难给类起一个合适的名字，很难用一个业务名词概括或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义的可能不够清晰</li>\n<li>类中大量的方法都是集中操作类中的某几个属性。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>OCP开闭原则：==Software entities(modules,classes,functions) should be open for extension,but closed for modification==</p>\n<ol>\n<li><p>添加一个新功能应该是，在已有的代码基础上扩展代码（新增模块、类、方法等），而非修改已有的代码（修改模块、类、方法等）</p>\n</li>\n<li><p>指导思想：为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识，这些潜意识可能比任何开发技巧都重要。</p>\n</li>\n<li><p>==方法==：多态、依赖注入、基于接口而非实现编程、大部分设计模式（装饰、策略、模板、职责链、状态）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;抽象意识\npublic interface MessageQueue&#123;&#x2F;*...*&#x2F;&#125;\npublic class KafkaMessageQueue implements MessageQueue&#123;&#x2F;*...*&#x2F;&#125;\npublic class RocketMQMessageQueue implements MessageQueue&#123;&#x2F;*...*&#x2F;&#125;\n\npublic interface MessageFromatter&#123;&#x2F;*...*&#x2F;&#125;\npublic class JsonMessageFromatter&#123;&#x2F;*...*&#x2F;&#125;\npublic class ProtoBufMessageFromatter&#123;&#x2F;*...*&#x2F;&#125;\n\npublic class Demo&#123;\n    private MessageQueue msgQueue;&#x2F;&#x2F;基于接口而非实现编程\n    public Demo(MessageQueue msgQueue)&#123;&#x2F;&#x2F;依赖注入\n        this.msgQueue &#x3D; msgQueue;\n    &#125;\n    &#x2F;&#x2F;msgFormatter:多态、依赖注入\n    public void senNotification(Notification notification, MessageFormatter msgFormatter)&#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>LSP里式替换原则：==子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏==</p>\n<ol>\n<li>虽然从定义描述和代码实现上来看，多态和里氏替换有点类似，但他们的关注角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，它是一种代码实现的思路。而里氏替换原则是一种设计原则，是用来直到继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</li>\n<li>==按照协议来设计==：子类在设计的时候，要遵守父类的行为约定（或协议），父类定义了函数的行为约定，子类可以改变函数内部实现逻辑，但不能改变函数原有的行为约定（函数声明是实现的功能、对输入、输出、异常的约定、注释中所罗列的任何特殊说明）。</li>\n<li>==技巧==：用父类的单元测试来验证子类的代码，如果某些单元测试运行失败，就有可能违背里氏替换原则</li>\n</ol>\n</li>\n<li><p>ISP接口隔离原则：==Clients should not be forced to depend upon interfaces that they do not use==</p>\n<ol>\n<li>一组API接口集合：在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那么我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</li>\n<li>单个API接口或函数：函数的设计要功能单一，不要将多个功能逻辑在一个函数中实现。接口隔离原则跟单一职责原则有点类似，但是单一职责原则针对的是模块、类、接口的设计；而接口隔离原则相对于单一职责原则，一方面他更侧重于接口的设计，另一方面它提供了一种判断接口是否职责单一的标准（如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够指责单一）。</li>\n<li>OOP中的接口概念：拆分成小接口，而不是一个大而全的config接口</li>\n</ol>\n</li>\n<li><p>DIP依赖倒置原则：==High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.（高层模块和低层模块的划分就是，在调用链上，调用者属于高层，被调用者属于低层）==</p>\n<ol>\n<li><p>控制反转（IOC）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;所有的流程都由程序员来控制\npublic class UserServiceTest&#123;\n    public static boolean doTest()&#123;\n        &#x2F;&#x2F;...\n    &#125;\n    public static void main(String[] args)&#123;&#x2F;&#x2F;这部分逻辑可以放到框架中\n        if(doTest()) &#123;\n            System.out.println(&quot;Test succeed.&quot;);\n        &#125; else &#123;\n            System.out.println(&quot;Test failed.&quot;);\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用\n&#x2F;&#x2F;框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可\n&#x2F;&#x2F;以利用框架来驱动整个程序流程的执行。这里的“控制”指的是对程序执行流程的控制，\n&#x2F;&#x2F;而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架\n&#x2F;&#x2F;之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员“反转”到了\n&#x2F;&#x2F;框架。\npublic abstract class TestCase &#123;\n  public void run() &#123;\n    if (doTest()) &#123;\n      System.out.println(&quot;Test succeed.&quot;);\n    &#125; else &#123;\n      System.out.println(&quot;Test failed.&quot;);\n    &#125;\n  &#125;\n  \n  public abstract boolean doTest();\n&#125;\n\npublic class JunitApplication &#123;\n  private static final List&lt;TestCase&gt; testCases &#x3D; new ArrayList&lt;&gt;();\n  \n  public static void register(TestCase testCase) &#123;\n    testCases.add(testCase);\n  &#125;\n  \n  public static final void main(String[] args) &#123;\n    for (TestCase case: testCases) &#123;\n      case.run();\n    &#125;\n  &#125;\n&#125;\n    \npublic class UserServiceTest extends TestCase &#123;\n  @Override\n  public boolean doTest() &#123;\n    &#x2F;&#x2F; ... \n  &#125;\n&#125;\n\n&#x2F;&#x2F; 注册操作还可以通过配置的方式来实现，不需要程序员显示调用register()\nJunitApplication.register(new UserServiceTest();\n</code></pre></li>\n<li><p>依赖注入（DI）：不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、\n&#x2F;&#x2F;验证码等消息给用户\n\n&#x2F;&#x2F; 非依赖注入实现方式\npublic class Notification &#123;\n  private MessageSender messageSender;\n  \n  public Notification() &#123;\n    this.messageSender &#x3D; new MessageSender(); &#x2F;&#x2F;此处有点像hardcode\n  &#125;\n  \n  public void sendMessage(String cellphone, String message) &#123;\n    &#x2F;&#x2F;...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  &#125;\n&#125;\n\npublic class MessageSender &#123;\n  public void send(String cellphone, String message) &#123;\n    &#x2F;&#x2F;....\n  &#125;\n&#125;\n&#x2F;&#x2F; 使用Notification\nNotification notification &#x3D; new Notification();\n\n&#x2F;&#x2F; 依赖注入的实现方式\npublic class Notification &#123;\n  private MessageSender messageSender;\n  \n  &#x2F;&#x2F; 通过构造函数将messageSender传递进来\n  &#x2F;&#x2F; 通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性,\n  &#x2F;&#x2F; 我们可以灵活地替换依赖的类。\n  public Notification(MessageSender messageSender) &#123;\n    this.messageSender &#x3D; messageSender;\n  &#125;\n  \n  public void sendMessage(String cellphone, String message) &#123;\n    &#x2F;&#x2F;...省略校验逻辑等...\n    this.messageSender.send(cellphone, message);\n  &#125;\n&#125;\n&#x2F;&#x2F;使用Notification\nMessageSender messageSender &#x3D; new MessageSender();\nNotification notification &#x3D; new Notification(messageSender);</code></pre></li>\n<li><p>依赖注入框架（DI Framework）：</p>\n<ul>\n<li>在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现。在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。</li>\n<li>如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。</li>\n<li>我们只需要通过依赖注入框架提供的扩展点，简单==配置==一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现==由框架来自动创建对象、管理对象的生命周期、依赖注入==等原本需要程序员来做的事情</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n  public static final void main(String args[]) &#123;\n    MessageSender sender &#x3D; new SmsSender(); &#x2F;&#x2F;创建对象\n    Notification notification &#x3D; new Notification(sender);&#x2F;&#x2F;依赖注入\n    notification.sendMessage(&quot;13918942177&quot;, &quot;短信验证码：2346&quot;);\n  &#125;\n&#125;</code></pre></li>\n<li><p>依赖反转原则（DIP）：</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-2其它原则\"><a href=\"#3-2其它原则\" class=\"headerlink\" title=\"3.2其它原则\"></a>3.2其它原则</h3><ol>\n<li><p>KISS原则：==尽量保持简单==</p>\n<ul>\n<li>不要使用同事可能不懂的技术来实现代码，例如正则表达式或编程语言中的高级语法</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库</li>\n<li>不要过度优化，不要过度使用一些奇技淫巧（位运算、复杂条件语句、过于底层函数）来优化代码，牺牲代码的可读性</li>\n</ul>\n</li>\n<li><p>YAGNI原则：==You ain’t gonna need it 你不会需要它==，不要去设计当前用不到的功能，不要去编写当前用不到的代码，即不要过度设计，只需要预留好扩展点。</p>\n</li>\n<li><p>DRY原则：==Don’t repeat yourself==，不要写重复的代码。</p>\n<ul>\n<li>实现逻辑重复：尽管代码的实现逻辑是重复的，但是语义上不是重复的，可以判定它并不违反DRY原则</li>\n<li>功能语义重复：实现逻辑不重复，但语义重复，那么也就是功能重复，我们认为它违反了DRY原则</li>\n<li>代码执行重复：例如对输入校验了两次</li>\n</ul>\n</li>\n<li><p>LOD原则（Law of Demeter）：==Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.==</p>\n<ol>\n<li><p>高内聚，松耦合：</p>\n<ol>\n<li>高内聚：用来指导类本身的设计，相近的功能应该放到同一个类中，不想近的功能不要放到同一个类中，相近的功能往往会被同时更改，放到一个类中，代码容易维护</li>\n<li>低耦合：用来指导类与类之间依赖关系的设计，在代码中，类与类之间的依赖关系应该简单清晰，一个类的代码改动不会或者很少导致依赖类的代码改动</li>\n</ol>\n</li>\n<li><p>迪米特法则</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-3代码复用性\"><a href=\"#3-3代码复用性\" class=\"headerlink\" title=\"3.3代码复用性\"></a>3.3代码复用性</h3><ol>\n<li>代码复用性：<ul>\n<li>代码复用：表示一种行为：开发新功能的时候，尽量复用已经存在的代码</li>\n<li>代码的可复用性：表示一段代码可被复用的特性或能力</li>\n<li>DRY原则：是一条原则，不要写重复的代码，但不重复不代表可复用</li>\n</ul>\n</li>\n<li>==提高代码复用性的手段==：<ul>\n<li>减少代码耦合：将某个功能的代码抽取出来成为一个独立的模块、类或函数</li>\n<li>满足单一职责原则：越细粒度的代码，代码的通用性越好</li>\n<li>模块化：要善于将功能独立的代码封装成模块</li>\n<li>业务与非业务逻辑分离：将业务与非业务代码抽离，抽取成通用的框架、类库、组件等</li>\n<li>通用代码下沉：代码分层之后，只允许上层调用下层，不允许下层调用上层</li>\n<li>继承、多态、抽象、封装：利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</li>\n<li>应用模板等设计模式：一些设计模式，也能提高代码的复用性</li>\n</ul>\n</li>\n<li>==Rule of Three==：除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。当遇到复用场景的时候，再进行重构使其复用</li>\n</ol>\n<h3 id=\"3-4实战：系统设计\"><a href=\"#3-4实战：系统设计\" class=\"headerlink\" title=\"3.4实战：系统设计\"></a>3.4实战：系统设计</h3><ol>\n<li>需求分析：借鉴已有的系统，调研用户用例</li>\n<li>系统设计：<ol>\n<li>合理将功能划分到不同模块</li>\n<li>设计模块与模块之间的交互关系</li>\n<li>设计模块的接口、数据库、业务模型</li>\n</ol>\n</li>\n<li>为什么要使用MVC分层<ol>\n<li>代码复用</li>\n<li>隔离变化</li>\n<li>隔离关注点，每层职责分明</li>\n<li>提高代码的可测试性</li>\n<li>应对系统的复杂性：当一个类过于庞大，我们就要基于业务做水平化（模块化）拆分，或者基于流程做垂直化（分层）拆分</li>\n</ol>\n</li>\n<li>BO、VO、Entity存在的意义<ol>\n<li>相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？<ul>\n<li>VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。</li>\n<li>VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。</li>\n<li>为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！</li>\n</ul>\n</li>\n<li>既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？<ul>\n<li>将公共的字段定义在父类中，让 VO、BO、Entity 都继承这个父类，各自只定义特有的字段</li>\n<li>将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码</li>\n</ul>\n</li>\n<li>代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢<ul>\n<li>Java 中提供了多种数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作</li>\n</ul>\n</li>\n<li>VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。那到底该怎么办好呢？<ul>\n<li>前面我们也提到过，Entity 和 VO 的生命周期是有限的，都仅限在本层范围内。而对应的 Repository 层和 Controller 层也都不包含太多业务逻辑，所以也不会有太多代码随意修改数据，即便设计成贫血、定义每个字段的 set 方法，相对来说也是安全的。</li>\n<li>不过，Service 层包含比较多的业务逻辑代码，所以 BO 就存在被任意修改的风险了。但是，设计的问题本身就没有最优解，只有权衡。为了使用方便，我们只能做一些妥协，放弃 BO 的封装特性，由程序员自己来负责这些数据对象的不被错误使用。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-5实战：框架设计\"><a href=\"#3-5实战：框架设计\" class=\"headerlink\" title=\"3.5实战：框架设计\"></a>3.5实战：框架设计</h3><ol>\n<li>划分功能性需求和非功能性需求，并且划分模块</li>\n<li>小步快跑，逐步迭代，TDD+Protoytpe：先聚焦一个简单的应用场景，基于此设计实现一个简单的模型</li>\n<li>面向对象设计和实现要做的事情，==就是把合适的代码放到合适的类中==（当要实现某个功能的时候，不管如何设计，所需要编写的代码量基本上是一样的，唯一的区别就是如何将这些代码划分到不同的类中。不同的人有不同的划分方法，对应得到的代码结构也不尽相同，比如类与类之间交互等）<ol>\n<li>划分职责进而识别出有哪些类</li>\n<li>根据设计模式，定义类及类之间的关系</li>\n<li>将类组装起来并提供执行入口</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"4-编程规范与代码重构\"><a href=\"#4-编程规范与代码重构\" class=\"headerlink\" title=\"4.编程规范与代码重构\"></a>4.编程规范与代码重构</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>《代码大全》、《代码整洁之道》、《重构》</p></blockquote>\n<h3 id=\"1-代码重构\"><a href=\"#1-代码重构\" class=\"headerlink\" title=\"1.代码重构\"></a>1.代码重构</h3><ol>\n<li>重构：重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更容易理解，修改成本更低<ol>\n<li>目的（why）：<ul>\n<li>保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步</li>\n<li>优秀的代码和架构都是迭代出来的，无法从一开始就完全设计好</li>\n<li>重构是避免过度设计的有效手段，真正遇到问题时，在对代码进行重构</li>\n<li>重构是对设计思想、设计原则、设计模式、编程规范的一种应用</li>\n</ul>\n</li>\n<li>对象（what）：<ul>\n<li>大规模高层次重构：对顶层设计的重构，包括系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等</li>\n<li>小规模低层次重构：对代码细节的重构，主要针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等。</li>\n</ul>\n</li>\n<li>时机（when）：<ul>\n<li>可持续、可演进的方式，就像把单元测试、Code Review作为开发的一部分，也把持续重构作为开发的一部分，时刻保持重构意识</li>\n</ul>\n</li>\n<li>方法（how）：<ul>\n<li>对于大型重构，要提前做好完善的重构计划，分阶段进行，每个阶段完成一小部分代码的重构，然后提交、测试、运行，没有问题后在进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态</li>\n<li>小规模重构，因为影响范围小，改动耗时短，所以，随时都可以做</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>保证重构不出错的技术手段：单元测试<ol>\n<li>单元测试：有研发工程师自己来编写，用来测试自己写的代码的正确性，常用来测试一个类和函数是否都按照预期的逻辑执行，主要考研程序员思维的缜密程度</li>\n<li>单元测试的好处<ul>\n<li>单元测试能有效地帮你发现代码中的bug</li>\n<li>写单元测试能帮你发现代码设计上的问题：如果单元测试写起来吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着代码设计的不够合理</li>\n<li>单元测试是对集成测试的有力补充</li>\n<li>写单元测试的过程本身就是代码重构的过程（自我Code Review）</li>\n<li>阅读单元测试能帮助你快速熟悉代码</li>\n<li>单元测试是TDD可落地执行的改进方案</li>\n</ul>\n</li>\n<li>如何编写单元测试：<ul>\n<li>针对代码设计覆盖各种输入、异常、边界条件的测试用例，然后将这些测试用例翻译成代码</li>\n<li>可以使用Junit、Spring Test等测试框架，JaCoCo、Cobertura等工具来做单元测试覆盖率统计</li>\n<li>不可以为了追求测试覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试，否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，原有的单元测试都会运行失败</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>代码的可测试性：<ol>\n<li>单元测试主要是测试程序员自己编写的代码逻辑的正确性，并非是端到端的基层测试，不应该需要测试依赖的外部系统</li>\n<li>mock：如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网路通信、文件系统等，那么就需要将被测试代码与外部系统解依赖，这种解依赖的方法就叫做mock，就是用一个“假”的服务替换真正的服务，其中mock的服务完全在我们的控制之下，模拟输出我们想要的数据。<ul>\n<li>框架mock</li>\n<li>手动mock：通过继承并重写依赖类</li>\n</ul>\n</li>\n<li>==提高代码的可测试性的手段==<ol>\n<li>依赖注入而不是new的方式，可以很容易利用手动mock来测试</li>\n</ol>\n</li>\n<li>Anti-Patterns：<ol>\n<li>未决行为：代码的输出是随机或者说不确定的，比如跟时间、随机数有关的代码</li>\n<li>全局变量：全局变量时面向过程的编程风格，滥用会让编写单元测试变得困难</li>\n<li>静态方法：同全局变量一样，因为静态方法很难mock，但只有静态方法耗时太长，依赖外部资源，逻辑复杂，行为未决等情况下，我们才需要在单元测试中mock这个方法</li>\n<li>复杂继承：如果父类需要mock某个依赖对象，那么所有子类也都需要</li>\n<li>高耦合代码：如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试时，就需要mock这十几个以来的对象</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>解耦<ol>\n<li>降低代码的复杂性，保证代码松耦合、高内聚，保证代码不至于复杂到无法控制的有效手段，将依赖关系画出来，根据依赖关系来判断是否需要解耦重构</li>\n<li>解耦的方法：<ol>\n<li>封装和抽象：例如Unix系统提供的open()文件操作函数</li>\n<li>中间层：简化依赖关系，使其都依赖中间层；在重构时，可以起到过渡的作用，让开发和重构同步进行</li>\n<li>模块化：构建复杂系统常用的手段，</li>\n<li>其他设计思想和原则：<ol>\n<li>单一职责原则：减少依赖此类的其他类数量</li>\n<li>基于接口而非实现编程：有依赖关系的两个类之间，一个类的改动不会影响到另一个模块或类</li>\n<li>依赖注入：将代码之间的强耦合变为弱耦合，容易做到插拔替换</li>\n<li>多用组合少用继承：继承是一种强依赖关系，利用组合来替换继承，可以解耦</li>\n<li>迪米特法则：不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-20条编程规范\"><a href=\"#2-20条编程规范\" class=\"headerlink\" title=\"2.20条编程规范\"></a>2.20条编程规范</h3><ol>\n<li><p>命名</p>\n<ol>\n<li><p>命名多长最合适：</p>\n<ul>\n<li>在足够表达含义的情况下，命名应当越短越好</li>\n<li>对于一些默认的，可以使用缩写，例如：sec-second、str-string、num-number、doc-document</li>\n<li>对于一些作用域比较小的变量，可以使用相对短的命名，比如函数内的临时变量</li>\n</ul>\n</li>\n<li><p>利用上下文简化命名：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">User user &#x3D; new User();\nuser.getName(); &#x2F;&#x2F; 借助user对象这个上下文\n\npublic void uploadUserAvatarImageToAliyun(String userAvatarImageUri);\n&#x2F;&#x2F;利用上下文简化为：\npublic void uploadUserAvatarImageToAliyun(String imageUri);</code></pre></li>\n<li><p>命名要可读、可搜索：</p>\n<ul>\n<li>不使用一些生僻、难发音的英文单词来命名</li>\n<li>IDE中经常会用“关键词联想”的方法来自动补全和搜索，例如：大家都用selectXXX表示查询，那么就不要用queryXXX；大家都用insertXXX表示插入，那么就不要用addXXX</li>\n</ul>\n</li>\n<li><p>如何命名接口和抽象类：</p>\n<ul>\n<li>对于接口的命名，一种是加前缀“I”，或者加后缀“Impl”</li>\n<li>对于抽象类的命名，可以加前缀“Abstract”</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>注释</p>\n<ol>\n<li>注释到底该写什么：<ul>\n<li>注释的目的是让代码更容易看懂，主要包括三方面：做什么、为什么、怎么做</li>\n<li>对于复杂的类，可以包括如何用，还可以写一些总结性的说明来让代码结构更清晰、更有条理</li>\n</ul>\n</li>\n<li>注释是不是越多越好：<ul>\n<li>类和函数一定要写注释、而且要写的尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>代码风格</p>\n<ol>\n<li>函数、类多大才合适：函数一屏内，类200行内</li>\n<li>一行代码多长最合适：一行代码最长不能超过IDE现实的宽度</li>\n<li>善用空行分割单元块：让代码结构更清晰、更有条理</li>\n<li>==四行缩进还是两格缩进==：==不要用tab缩进==，因为不同IDE下，tab键的显示宽度不同</li>\n<li>大括号是否要另起一行：同团队</li>\n<li>类中成员的排列顺序：<ul>\n<li>依赖类按照字母序列从小到大排列</li>\n<li>在类中，成员变量排在函数的前面，成员变量之间或函数之间，都是按照“先静态（静态函数或静态成员变量）、后普通”的方式来排列，成员变量之间或函数之间，按照作用域范围从小到大的顺序来排列（先public，然后protected，最后private）</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>编程技巧</p>\n<ol>\n<li><p>把代码分割成更小的单元块：</p>\n<ul>\n<li>当代码逻辑比较复杂的时候，可以提炼类或函数，让阅读代码的人不至于迷失在细节中</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 重构前的代码\npublic void invest(long userId, long financialProductId) &#123;\n  Calendar calendar &#x3D; Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) &#x3D;&#x3D; 1) &#123;\n    return;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：提炼函数之后逻辑更加清晰\npublic void invest(long userId, long financialProductId) &#123;\n  if (isLastDayOfMonth(new Date())) &#123;\n    return;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;\n\npublic boolean isLastDayOfMonth(Date date) &#123;\n  Calendar calendar &#x3D; Calendar.getInstance();\n  calendar.setTime(date);\n  calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + 1));\n  if (calendar.get(Calendar.DAY_OF_MONTH) &#x3D;&#x3D; 1) &#123;\n   return true;\n  &#125;\n  return false;\n&#125;</code></pre></li>\n<li><p>避免函数参数过多：参数不宜多于4个</p>\n<ul>\n<li>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public User getUser(String username, String telephone, String email);\n\n&#x2F;&#x2F; 拆分成多个函数\npublic User getUserByUsername(String username);\npublic User getUserByTelephone(String telephone);\npublic User getUserByEmail(String email);</code></pre>\n\n\n\n<ul>\n<li>将函数的参数封装成对象</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void postBlog(String title, String summary, String keywords, String content, String category, long authorId);\n\n&#x2F;&#x2F; 将参数封装成对象\npublic class Blog &#123;\n  private String title;\n  private String summary;\n  private String keywords;\n  private Strint content;\n  private String category;\n  private long authorId;\n&#125;\npublic void postBlog(Blog blog);</code></pre></li>\n<li><p>勿用函数参数来控制逻辑：</p>\n<ul>\n<li>不要在函数中使用布尔类型的标识参数来控制内部逻辑，而是应该拆成两个函数，可读性上也要更好，但若经常一起调用，则可以选择不拆</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void buyCourse(long userId, long courseId, boolean isVip);\n\n&#x2F;&#x2F; 将其拆分成两个函数\npublic void buyCourse(long userId, long courseId);\npublic void buyCourseForVip(long userId, long courseId);</code></pre>\n\n<ul>\n<li>遇到根据参数是否为 null来控制逻辑的情况，我们也应该将其拆分成多个函数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;\n  if (startDate !&#x3D; null &amp;&amp; endDate !&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询两个时间区间的transactions\n  &#125;\n  if (startDate !&#x3D; null &amp;&amp; endDate &#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询startDate之后的所有transactions\n  &#125;\n  if (startDate &#x3D;&#x3D; null &amp;&amp; endDate !&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询endDate之前的所有transactions\n  &#125;\n  if (startDate &#x3D;&#x3D; null &amp;&amp; endDate &#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; 查询所有的transactions\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 拆分成多个public函数，更加清晰、易用\npublic List&lt;Transaction&gt; selectTransactionsBetween(Long userId, Date startDate, Date endDate) &#123;\n  return selectTransactions(userId, startDate, endDate);\n&#125;\n\npublic List&lt;Transaction&gt; selectTransactionsStartWith(Long userId, Date startDate) &#123;\n  return selectTransactions(userId, startDate, null);\n&#125;\n\npublic List&lt;Transaction&gt; selectTransactionsEndWith(Long userId, Date endDate) &#123;\n  return selectTransactions(userId, null, endDate);\n&#125;\n\npublic List&lt;Transaction&gt; selectAllTransactions(Long userId) &#123;\n  return selectTransactions(userId, null, null);\n&#125;\n\nprivate List&lt;Transaction&gt; selectTransactions(Long userId, Date startDate, Date endDate) &#123;\n  &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>函数设计要职责单一：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean checkUserIfExisting(String telephone, String username, String email)  &#123; \n  if (!StringUtils.isBlank(telephone)) &#123;\n    User user &#x3D; userRepo.selectUserByTelephone(telephone);\n    return user !&#x3D; null;\n  &#125;\n  \n  if (!StringUtils.isBlank(username)) &#123;\n    User user &#x3D; userRepo.selectUserByUsername(username);\n    return user !&#x3D; null;\n  &#125;\n  \n  if (!StringUtils.isBlank(email)) &#123;\n    User user &#x3D; userRepo.selectUserByEmail(email);\n    return user !&#x3D; null;\n  &#125;\n  \n  return false;\n&#125;\n\n&#x2F;&#x2F; 拆分成三个函数\npublic boolean checkUserIfExistingByTelephone(String telephone);\npublic boolean checkUserIfExistingByUsername(String username);\npublic boolean checkUserIfExistingByEmail(String email);</code></pre></li>\n<li><p>==移除过深的嵌套层次==：</p>\n<ul>\n<li><p>代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁。</p>\n</li>\n<li><p>解决方法：</p>\n<ul>\n<li>去掉多余的 if 或 else 语句</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 示例一\npublic double caculateTotalAmount(List&lt;Order&gt; orders) &#123;\n  if (orders &#x3D;&#x3D; null || orders.isEmpty()) &#123;\n    return 0.0;\n  &#125; else &#123; &#x2F;&#x2F; 此处的else可以去掉\n    double amount &#x3D; 0.0;\n    for (Order order : orders) &#123;\n      if (order !&#x3D; null) &#123;\n        amount +&#x3D; (order.getCount() * order.getPrice());\n      &#125;\n    &#125;\n    return amount;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 示例二\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;\n    for (String str : strList) &#123;\n      if (str !&#x3D; null) &#123; &#x2F;&#x2F; 跟下面的if语句可以合并在一起\n        if (str.contains(substr)) &#123;\n          matchedStrings.add(str);\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>使用编程语言提供的 continue、break、return 关键字，提前退出嵌套</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null)&#123; \n    for (String str : strList) &#123;\n      if (str !&#x3D; null &amp;&amp; str.contains(substr)) &#123;\n        matchedStrings.add(str);\n        &#x2F;&#x2F; 此处还有10行代码...\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：使用continue提前退出\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null)&#123; \n    for (String str : strList) &#123;\n      if (str &#x3D;&#x3D; null || !str.contains(substr)) &#123;\n        continue; \n      &#125;\n      matchedStrings.add(str);\n      &#x2F;&#x2F; 此处还有10行代码...\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>调整执行顺序来减少嵌套</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  if (strList !&#x3D; null &amp;&amp; substr !&#x3D; null) &#123;\n    for (String str : strList) &#123;\n      if (str !&#x3D; null) &#123;\n        if (str.contains(substr)) &#123;\n          matchedStrings.add(str);\n        &#125;\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：先执行判空逻辑，再执行正常逻辑\npublic List&lt;String&gt; matchStrings(List&lt;String&gt; strList,String substr) &#123;\n  if (strList &#x3D;&#x3D; null || substr &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;先判空\n    return Collections.emptyList();\n  &#125;\n\n  List&lt;String&gt; matchedStrings &#x3D; new ArrayList&lt;&gt;();\n  for (String str : strList) &#123;\n    if (str !&#x3D; null) &#123;\n      if (str.contains(substr)) &#123;\n        matchedStrings.add(str);\n      &#125;\n    &#125;\n  &#125;\n  return matchedStrings;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套:</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 重构前的代码\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) &#123;\n  if (passwords &#x3D;&#x3D; null || passwords.isEmpty()) &#123;\n    return Collections.emptyList();\n  &#125;\n  \n  List&lt;String&gt; passwordsWithSalt &#x3D; new ArrayList&lt;&gt;();\n  for (String password : passwords) &#123;\n    if (password &#x3D;&#x3D; null) &#123;\n      continue;\n    &#125;\n    if (password.length() &lt; 8) &#123;\n      &#x2F;&#x2F; ...\n    &#125; else &#123;\n      &#x2F;&#x2F; ...\n    &#125;\n  &#125;\n  return passwordsWithSalt;\n&#125;\n\n&#x2F;&#x2F; 重构后的代码：将部分逻辑抽成函数\npublic List&lt;String&gt; appendSalts(List&lt;String&gt; passwords) &#123;\n  if (passwords &#x3D;&#x3D; null || passwords.isEmpty()) &#123;\n    return Collections.emptyList();\n  &#125;\n\n  List&lt;String&gt; passwordsWithSalt &#x3D; new ArrayList&lt;&gt;();\n  for (String password : passwords) &#123;\n    if (password &#x3D;&#x3D; null) &#123;\n      continue;\n    &#125;\n    passwordsWithSalt.add(appendSalt(password));\n  &#125;\n  return passwordsWithSalt;\n&#125;\n\nprivate String appendSalt(String password) &#123;\n  String passwordWithSalt &#x3D; password;\n  if (password.length() &lt; 8) &#123;\n    &#x2F;&#x2F; ...\n  &#125; else &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n  return passwordWithSalt;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>学会使用解释性变量：</p>\n<ul>\n<li>常量取代魔法数字</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public double CalculateCircularArea(double radius) &#123;\n  return (3.1415) * radius * radius;\n&#125;\n\n&#x2F;&#x2F; 常量替代魔法数字\npublic static final Double PI &#x3D; 3.1415;\npublic double CalculateCircularArea(double radius) &#123;\n  return PI * radius * radius;\n&#125;</code></pre>\n\n\n\n<ul>\n<li>使用解释性变量来解释复杂表达式</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;\n  &#x2F;&#x2F; ...\n&#125; else &#123;\n  &#x2F;&#x2F; ...\n&#125;\n\n&#x2F;&#x2F; 引入解释性变量后逻辑更加清晰\nboolean isSummer &#x3D; date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);\nif (isSummer) &#123;\n  &#x2F;&#x2F; ...\n&#125; else &#123;\n  &#x2F;&#x2F; ...\n&#125; </code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-实战：ID生成器\"><a href=\"#3-实战：ID生成器\" class=\"headerlink\" title=\"3.实战：ID生成器\"></a>3.实战：ID生成器</h3><ol>\n<li><p>如何发现代码质量问题：看这段代码是否可读、可扩展、可维护、灵活、简洁、可复用、可测试等等，落实到具体细节：</p>\n<ol>\n<li>目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li>\n<li>是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li>\n<li>设计模式是否应用得当？是否有过度设计？</li>\n<li>代码是否容易扩展？如果要添加新功能，是否容易实现？</li>\n<li>代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li>\n<li>代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li>\n<li>代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li>\n</ol>\n</li>\n<li><p>代码实现是否满足业务本身特有的功能和非功能需求：</p>\n<ol>\n<li>代码是否实现了预期的业务需求？</li>\n<li>逻辑是否正确？是否处理了各种异常情况？</li>\n<li>日志打印是否得当？是否方便 debug 排查问题？</li>\n<li>接口是否易用？是否支持幂等、事务等？</li>\n<li>代码是否存在并发问题？是否线程安全（共享变量）？</li>\n<li>性能是否有优化空间，比如，SQL、算法是否可以优化，是否可以不调用外部存储？</li>\n<li>是否有安全漏洞？比如输入输出校验是否全面？</li>\n</ol>\n</li>\n<li><p>函数出错应该返回什么</p>\n<ol>\n<li><p>出错码：</p>\n<ol>\n<li>C语言没有异常的语法机制，所以通常返回错误码；而在Python和Java中大多使用异常来处理函数出错的情况</li>\n<li>C语言中有两种方式：<ol>\n<li>直接占用函数的返回值，函数正常执行的返回值放到出参中</li>\n<li>将错误码定义为全局变量，在函数执行出错时，函数调用者通过这个全局变量来获取错误码</li>\n<li>实际上，如果编程语言中有异常这种语法机制，就尽量不要使用错误码。异常相对于错误码，有诸多方面的优势，比如可以携带更多的错误信息（exception 中可以有 message、stack trace 等信息）等</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>NULL值</p>\n<ol>\n<li>在多数编程语言中，我们用 NULL 来表示“不存在”这种语义。但这是一种不好的设计思路，主要的理由有，使用时如果忘记做NULL值判断就可能会抛出空指针异常；或者代码有可能充斥着大量的NULL值判断逻辑影响代码的可读性</li>\n<li>某些时候NULL值不是异常而是正常情况，也可以用-1替换，代表数据不存在或没查找到</li>\n</ol>\n</li>\n<li><p>空对象</p>\n<ol>\n<li>空对象设计模式（Null Object Design Pattern）</li>\n<li>空字符串、空集合：<ul>\n<li>当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。这样，我们在使用函数的时候，就可以不用做 NULL 值判断。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>异常对象：</p>\n<ol>\n<li><p>运行时异常（Runtime Exception）</p>\n<ol>\n<li>对于运行时异常，我们在编写代码的时候，可以不用主动去 try-catch，编译器在编译代码的时候，并不会检查代码是否有对运行时异常做了处理。运行时异常也叫作非受检异常（Unchecked Exception）</li>\n<li>对于代码 bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了，也做不了太多事情，所以，我们倾向于使用非受检异常。</li>\n</ol>\n</li>\n<li><p>编译时异常（Compile Exception）</p>\n<ol>\n<li>对于编译时异常，我们在编写代码的时候，需要主动去 try-catch 或者在函数定义中声明，否则编译就会报错，编译时异常也叫作受检异常（Checked Exception）</li>\n<li>对于可恢复异常、业务异常，比如提现金额大于余额的异常，我们更倾向于使用受检异常，明确告知调用者需要捕获处理。</li>\n</ol>\n</li>\n<li><p>如何处理函数抛出的异常</p>\n<ol>\n<li>直接吞掉：如果 func1() 抛出的异常是可以恢复，且 func2() 的调用方并不关心此异常，我们完全可以在 func2() 内将 func1() 抛出的异常吞掉</li>\n<li>原封不动re-throw：如果 func1() 抛出的异常对 func2() 的调用方来说，也是可以理解的、关心的 ，并且在业务概念上有一定的相关性，我们可以选择直接将 func1 抛出的异常 re-throw</li>\n<li>包装成新的异常re-throw：如果 func1() 抛出的异常太底层，对 func2() 的调用方来说，缺乏背景去理解、且业务概念上无关，我们可以将它重新包装成调用方可以理解的新异常，然后 re-throw</li>\n</ol>\n<p>==总之，是否往上继续抛出，要看上层代码是否关心这个异常。关心就将它抛出，否则就直接吞掉。是否需要包装成新的异常抛出，看上层代码是否能理解这个异常、是否业务相关。如果能理解、业务相关就可以直接抛出，否则就封装成新的异常抛出。==</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-实战：框架设计重构\"><a href=\"#4-实战：框架设计重构\" class=\"headerlink\" title=\"4.实战：框架设计重构\"></a>4.实战：框架设计重构</h3><h2 id=\"5-设计模式\"><a href=\"#5-设计模式\" class=\"headerlink\" title=\"5.设计模式\"></a>5.设计模式</h2><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221208162847332.png\" alt=\"image-20221208162847332\"></p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220807140918397.png\" alt=\"image-20220807140918397\"></p>\n<h3 id=\"1-创建型设计模式\"><a href=\"#1-创建型设计模式\" class=\"headerlink\" title=\"1.创建型设计模式\"></a>1.创建型设计模式</h3><h4 id=\"1-单例模式\"><a href=\"#1-单例模式\" class=\"headerlink\" title=\"1.单例模式\"></a>1.单例模式</h4><ol>\n<li><p>概念：一个类在同一进程内只允许创建一个对象（或实例），那这个类就是一个单例类</p>\n</li>\n<li><p>使用场景：</p>\n<ol>\n<li>处理资源访问冲突</li>\n<li>表示全局唯一类：配置信息类、ID生成器</li>\n</ol>\n</li>\n<li><p>实现重点：</p>\n<ol>\n<li>构造函数是 private 的，避免外部通过 new 创建实例；</li>\n<li>考虑对象创建时的线程安全问题；</li>\n<li>考虑是否支持延迟加载（饿汉/懒汉）；</li>\n<li>考虑 getInstance() 性能是否高（是否加锁）。</li>\n</ol>\n</li>\n<li><p>实现方式：</p>\n<ol>\n<li><p>饿汉式：在类加载时就创建并初始化好，线程安全，但不支持延迟加载（在真正用到 IdGenerator 的时候，再创建实例）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private static final IdGenerator instance &#x3D; new IdGenerator();\n  private IdGenerator() &#123;&#125;\n  public static IdGenerator getInstance() &#123;\n    return instance;\n  &#125;\n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;</code></pre></li>\n<li><p>懒汉式：支持延迟加载，但通过加锁使得并发度很低（并发度为1），如果频繁使用，因锁的消耗会导致性能瓶颈</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() &#123;&#125;\n  public static synchronized IdGenerator getInstance() &#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n      instance &#x3D; new IdGenerator();\n    &#125;\n    return instance;\n  &#125;\n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;</code></pre></li>\n<li><p>双重检测：既支持延迟加载又支持高并发，有指令重排序相关问题（IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了），但高版本Java已解决</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private static IdGenerator instance;\n  private IdGenerator() &#123;&#125;\n  public static IdGenerator getInstance() &#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n      synchronized(IdGenerator.class) &#123; &#x2F;&#x2F; 此处为类级别的锁\n        if (instance &#x3D;&#x3D; null) &#123;\n          instance &#x3D; new IdGenerator();\n        &#125;\n      &#125;\n    &#125;\n    return instance;\n  &#125;\n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;</code></pre></li>\n<li><p>静态内部类：SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。只有当调用 getInstance() 方法时，SingletonHolder 才会被加载，这个时候才会创建 instance。instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证。（Basic Syntax/语法/关键字/static有解释）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123; \n  private AtomicLong id &#x3D; new AtomicLong(0);\n  private IdGenerator() &#123;&#125;\n\n  private static class SingletonHolder&#123;\n    private static final IdGenerator instance &#x3D; new IdGenerator();\n  &#125;\n  \n  public static IdGenerator getInstance() &#123;\n    return SingletonHolder.instance;\n  &#125;\n \n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;</code></pre></li>\n<li><p>枚举：通过 Java 枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum IdGenerator &#123;\n  INSTANCE;\n  private AtomicLong id &#x3D; new AtomicLong(0);\n \n  public long getId() &#123; \n    return id.incrementAndGet();\n  &#125;\n&#125;</code></pre></li>\n<li><p>线程唯一单例的实现（ThreadLocal 底层实现原理也是基于下面代码中所示的 HashMap）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n\n    private static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances\n        &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    private IdGenerator() &#123;&#125;\n\n    public static IdGenerator getInstance() &#123;\n        Long currentThreadId &#x3D; Thread.currentThread().getId();\n        instances.putIfAbsent(currentThreadId, new IdGenerator());\n        return instances.get(currentThreadId);\n    &#125;\n\n    public long getId() &#123;\n        return id.incrementAndGet();\n    &#125;\n&#125;</code></pre></li>\n<li><p>集群唯一单例实现：</p>\n<ol>\n<li>不同的进程间共享同一个对象，不能创建同一个类的多个对象。</li>\n<li>我们需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</li>\n<li>为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class IdGenerator &#123;\n    private AtomicLong id &#x3D; new AtomicLong(0);\n    private static IdGenerator instance;\n    private static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);\n    private static DistributedLock lock &#x3D; new DistributedLock();\n\n    private IdGenerator() &#123;&#125;\n\n    public synchronized static IdGenerator getInstance() \n        if (instance &#x3D;&#x3D; null) &#123;\n            lock.lock();\n            instance &#x3D; storage.load(IdGenerator.class);\n        &#125;\n    return instance;\n&#125;\n\npublic synchroinzed void freeInstance() &#123;\n    storage.save(this, IdGeneator.class);\n    instance &#x3D; null; &#x2F;&#x2F;释放对象\n    lock.unlock();\n&#125;\n\npublic long getId() &#123; \n    return id.incrementAndGet();\n&#125;\n&#125;\n\n&#x2F;&#x2F; IdGenerator使用举例\nIdGenerator idGeneator &#x3D; IdGenerator.getInstance();\nlong id &#x3D; idGenerator.getId();\nidGenerator.freeInstance();</code></pre></li>\n<li><p>多例模式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BackendServer &#123;\n  private long serverNo;\n  private String serverAddress;\n\n  private static final int SERVER_COUNT &#x3D; 3;\n  private static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\n\n  static &#123;\n    serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n    serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n    serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n  &#125;\n\n  private BackendServer(long serverNo, String serverAddress) &#123;\n    this.serverNo &#x3D; serverNo;\n    this.serverAddress &#x3D; serverAddress;\n  &#125;\n\n  public BackendServer getInstance(long serverNo) &#123;\n    return serverInstances.get(serverNo);\n  &#125;\n\n  public BackendServer getRandomInstance() &#123;\n    Random r &#x3D; new Random();\n    int no &#x3D; r.nextInt(SERVER_COUNT)+1;\n    return serverInstances.get(no);\n  &#125;\n&#125;\n&#x2F;&#x2F;同一类型的只能创建一个对象，不同类型的可以创建多个对象。\npublic class Logger &#123;\n  private static final ConcurrentHashMap&lt;String, Logger&gt; instances\n          &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n  private Logger() &#123;&#125;\n\n  public static Logger getInstance(String loggerName) &#123;\n    instances.putIfAbsent(loggerName, new Logger());\n    return instances.get(loggerName);\n  &#125;\n\n  public void log() &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</code></pre></li>\n</ol>\n</li>\n<li><p>单例有哪些问题</p>\n<ol>\n<li><p>单例对 OOP 特性的支持不友好：因为需要硬编码，在更改实现时需要把每一处都替换掉</p>\n</li>\n<li><p>单例会隐藏类之间的依赖关系：单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p>\n</li>\n<li><p>单例对代码的扩展性不友好：如果需要创建两个单例类，需要对代码做较大改动</p>\n</li>\n<li><p>单例对代码的可测试性不友好：单例类这种硬编码式的使用方式，无法实现 mock 替换依赖的外部资源。</p>\n</li>\n<li><p>单例不支持有参数的构造函数：有以下解决方案：</p>\n<ol>\n<li><p>创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要先调用 init() 方法，然后才能调用 getInstance() 方法，否则代码会抛出异常</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n\n    public static Singleton getInstance() &#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            throw new RuntimeException(&quot;Run init() first.&quot;);\n        &#125;\n        return instance;\n    &#125;\n\n    public synchronized static Singleton init(int paramA, int paramB) &#123;\n        if (instance !&#x3D; null)&#123;\n            throw new RuntimeException(&quot;Singleton has been created!&quot;);\n        &#125;\n        instance &#x3D; new Singleton(paramA, paramB);\n        return instance;\n    &#125;\n&#125;\n\nSingleton.init(10, 50); &#x2F;&#x2F; 先init，再使用\nSingleton singleton &#x3D; Singleton.getInstance();</code></pre></li>\n<li><p>将参数放到 getIntance() 方法中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Singleton &#123;\n    private static Singleton instance &#x3D; null;\n    private final int paramA;\n    private final int paramB;\n\n    private Singleton(int paramA, int paramB) &#123;\n        this.paramA &#x3D; paramA;\n        this.paramB &#x3D; paramB;\n    &#125;\n\n    public synchronized static Singleton getInstance(int paramA, int paramB) &#123; \n        if (instance &#x3D;&#x3D; null) &#123; \n            instance &#x3D; new Singleton(paramA, paramB); \n        &#125; else if (instance.paramA &#x3D;&#x3D; paramA &amp;&amp; instance.paramB &#x3D;&#x3D; paramB) &#123;\n            return instance;\n        &#125; else &#123;\n            instance &#x3D; new Singleton(paramA, paramB);\n        &#125;\n        return instance; \n    &#125;\n&#125;\n\nSingleton singleton &#x3D; Singleton.getInstance(10, 50);</code></pre></li>\n<li><p>将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值既可以像下面的代码那样通过静态常量来定义，也可以从配置文件中加载得到。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Config &#123;\n  public static final int PARAM_A &#x3D; 123;\n  public static final int PARAM_B &#x3D; 245;\n&#125;\n\npublic class Singleton &#123;\n  private static Singleton instance &#x3D; null;\n  private final int paramA;\n  private final int paramB;\n\n  private Singleton() &#123;\n    this.paramA &#x3D; Config.PARAM_A;\n    this.paramB &#x3D; Config.PARAM_B;\n  &#125;\n\n  public synchronized static Singleton getInstance() &#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n      instance &#x3D; new Singleton();\n    &#125;\n    return instance;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>有何替代的解决方案：</p>\n<ol>\n<li>将单例生成的对象，作为参数传递给函数（也可以通过构造函数传递给类的成员变量），可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 1. 老的使用方式\npublic demofunction() &#123;\n  &#x2F;&#x2F;...\n  long id &#x3D; IdGenerator.getInstance().getId();\n  &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 2. 新的使用方式：依赖注入\npublic demofunction(IdGenerator idGenerator) &#123;\n  long id &#x3D; idGenerator.getId();\n&#125;\n&#x2F;&#x2F; 外部调用demofunction()的时候，传入idGenerator\nIdGenerator idGenerator &#x3D; IdGenerator.getInsance();\ndemofunction(idGenerator);</code></pre>\n\n<ol start=\"2\">\n<li>工厂模式</li>\n<li>IOC容器</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-工厂模式\"><a href=\"#2-工厂模式\" class=\"headerlink\" title=\"2.工厂模式\"></a>2.工厂模式</h4><ol>\n<li><p>简单工厂：直接将创建代码拿出来</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;重构前\npublic class RuleConfigSource &#123;\n    public RuleConfig load(String ruleConfigFilePath) &#123;\n        String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n        IRuleConfigParser parser &#x3D; null;\n        if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new JsonRuleConfigParser();\n        &#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new XmlRuleConfigParser();\n        &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new YamlRuleConfigParser();\n        &#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;\n            parser &#x3D; new PropertiesRuleConfigParser();\n        &#125; else &#123;\n            throw new InvalidRuleConfigException(\n                &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n        &#125;\n\n        String configText &#x3D; &quot;&quot;;\n        &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n        RuleConfig ruleConfig &#x3D; parser.parse(configText);\n        return ruleConfig;\n    &#125;\n\n    private String getFileExtension(String filePath) &#123;\n        &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n        return &quot;json&quot;;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;重构后\npublic class RuleConfigSource &#123;\n    public RuleConfig load(String ruleConfigFilePath) &#123;\n        String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n        IRuleConfigParser parser &#x3D; RuleConfigParserFactory.createParser(ruleConfigFileExtension);\n        if (parser &#x3D;&#x3D; null) &#123;\n            throw new InvalidRuleConfigException(\n                &quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n        &#125;\n\n        String configText &#x3D; &quot;&quot;;\n        &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n        RuleConfig ruleConfig &#x3D; parser.parse(configText);\n        return ruleConfig;\n    &#125;\n\n    private String getFileExtension(String filePath) &#123;\n        &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n        return &quot;json&quot;;\n    &#125;\n&#125;\n&#x2F;&#x2F;第一种实现\npublic class RuleConfigParserFactory &#123;\n    public static IRuleConfigParser createParser(String configFormat) &#123;\n        IRuleConfigParser parser &#x3D; null;\n        if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new JsonRuleConfigParser();\n        &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new XmlRuleConfigParser();\n        &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new YamlRuleConfigParser();\n        &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new PropertiesRuleConfigParser();\n        &#125;\n        return parser;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;第二种实现：为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来\npublic class RuleConfigParserFactory &#123;\n    private static final Map&lt;String, RuleConfigParser&gt; cachedParsers &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        cachedParsers.put(&quot;json&quot;, new JsonRuleConfigParser());\n        cachedParsers.put(&quot;xml&quot;, new XmlRuleConfigParser());\n        cachedParsers.put(&quot;yaml&quot;, new YamlRuleConfigParser());\n        cachedParsers.put(&quot;properties&quot;, new PropertiesRuleConfigParser());\n    &#125;\n\n    public static IRuleConfigParser createParser(String configFormat) &#123;\n        if (configFormat &#x3D;&#x3D; null || configFormat.isEmpty()) &#123;\n            return null;&#x2F;&#x2F;返回null还是IllegalArgumentException全凭你自己说了算\n        &#125;\n        IRuleConfigParser parser &#x3D; cachedParsers.get(configFormat.toLowerCase());\n        return parser;\n    &#125;\n&#125;</code></pre></li>\n<li><p>工厂方法：利用多态去掉if分支（实现接口），利用工厂的工厂来简化使用（<code>RuleConfigParserFactoryMap</code>）。新增一种Parser只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类，将新的 parser factory 对象添加到 cachedFactories 中即可即可，符合开闭原则</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IRuleConfigParserFactory &#123;\n    IRuleConfigParser createParser();\n&#125;\n\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createParser() &#123;\n        return new JsonRuleConfigParser();\n    &#125;\n&#125;\n\npublic class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createParser() &#123;\n        return new XmlRuleConfigParser();\n    &#125;\n&#125;\n&#x2F;&#x2F;省略YamlRuleConfigParserFactory，PropertiesRuleConfigParserFactory\n\npublic class RuleConfigSource &#123;\n    public RuleConfig load(String ruleConfigFilePath) &#123;\n        String ruleConfigFileExtension &#x3D; getFileExtension(ruleConfigFilePath);\n\n        IRuleConfigParserFactory parserFactory &#x3D; RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);\n        if (parserFactory &#x3D;&#x3D; null) &#123;\n            throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);\n        &#125;\n        IRuleConfigParser parser &#x3D; parserFactory.createParser();\n\n        String configText &#x3D; &quot;&quot;;\n        &#x2F;&#x2F;从ruleConfigFilePath文件中读取配置文本到configText中\n        RuleConfig ruleConfig &#x3D; parser.parse(configText);\n        return ruleConfig;\n    &#125;\n\n    private String getFileExtension(String filePath) &#123;\n        &#x2F;&#x2F;...解析文件名获取扩展名，比如rule.json，返回json\n        return &quot;json&quot;;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;因为工厂类只包含方法，不包含成员变量，完全可以复用，\n&#x2F;&#x2F;不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n    private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n        cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n        cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n        cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());\n    &#125;\n\n    public static IRuleConfigParserFactory getParserFactory(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            return null;\n        &#125;\n        IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n        return parserFactory;\n    &#125;\n&#125;</code></pre></li>\n<li><p>抽象工厂：在简单工厂和工厂方法中，类只有一种分类方式。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml……）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应 8 个 parser 类。抽象工厂就是针对这种非常特殊的场景而诞生的。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IConfigParserFactory &#123;\n    IRuleConfigParser createRuleParser();\n    ISystemConfigParser createSystemParser();\n    &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\n\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createRuleParser() &#123;\n        return new JsonRuleConfigParser();\n    &#125;\n\n    @Override\n    public ISystemConfigParser createSystemParser() &#123;\n        return new JsonSystemConfigParser();\n    &#125;\n&#125;\n\npublic class XmlConfigParserFactory implements IConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createRuleParser() &#123;\n        return new XmlRuleConfigParser();\n    &#125;\n\n    @Override\n    public ISystemConfigParser createSystemParser() &#123;\n        return new XmlSystemConfigParser();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码</code></pre></li>\n<li><p>应用场景：当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离</p>\n<ol>\n<li>第一种情况：类似规则配置解析的例子，代码中存在 if-else 分支判断，动态地根据不同的类型创建不同的对象。针对这种情况，我们就考虑使用工厂模式，将这一大坨 if-else 创建对象的代码抽离出来，放到工厂类中。</li>\n<li>还有一种情况，尽管我们不需要根据不同的类型创建不同的对象，但是，单个对象本身的创建过程比较复杂，比如前面提到的要组合其他类对象，做各种初始化操作。在这种情况下，我们也可以考虑使用工厂模式，将对象的创建过程封装到工厂类中。==工厂方法模式==</li>\n</ol>\n<p>对于第一种情况，当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的简单工厂类，我推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。同理，对于第二种情况，因为单个对象本身的创建逻辑就比较复杂，所以，我建议使用工厂方法模式</p>\n</li>\n<li><p>依赖注入框架（依赖注入容器（Dependency Injection Container））</p>\n<ol>\n<li><p>DI 容器跟我们讲的工厂模式又有何区别和联系：实际上，DI 容器底层最基本的设计思路就是基于工厂模式的。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。正是因为它持有一堆对象，所以这个框架才被称为“容器”。</p>\n</li>\n<li><p>DI 容器的核心功能有哪些</p>\n<ol>\n<li><p>配置解析：我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。容器读取配置文件，根据配置文件提供的信息来创建对象，例如Spring容器的配置文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RateLimiter &#123;\n    private RedisCounter redisCounter;\n    public RateLimiter(RedisCounter redisCounter) &#123;\n        this.redisCounter &#x3D; redisCounter;\n    &#125;\n    public void test() &#123;\n        System.out.println(&quot;Hello World!&quot;);\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class RedisCounter &#123;\n    private String ipAddress;\n    private int port;\n    public RedisCounter(String ipAddress, int port) &#123;\n        this.ipAddress &#x3D; ipAddress;\n        this.port &#x3D; port;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\n配置文件beans.xml：\n&lt;beans&gt;\n   &lt;bean id&#x3D;&quot;rateLimiter&quot; class&#x3D;&quot;com.xzg.RateLimiter&quot;&gt;\n      &lt;constructor-arg ref&#x3D;&quot;redisCounter&quot;&#x2F;&gt;\n   &lt;&#x2F;bean&gt;\n \n   &lt;bean id&#x3D;&quot;redisCounter&quot; class&#x3D;&quot;com.xzg.redisCounter&quot;&gt;\n     &lt;constructor-arg type&#x3D;&quot;String&quot; value&#x3D;&quot;127.0.0.1&quot;&gt;\n     &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;1234&gt;\n   &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;</code></pre></li>\n<li><p>对象创建：在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要将所有类对象的创建都放到一个工厂类中完成就可以了，比如 BeansFactory。并且通过反射机制在程序运行的过程中，动态地加载类、创建对象，不需要事先在代码中写死要创建哪些对象。不管是创建一个对象还是十个对象，BeansFactory 工厂类代码都是一样的。</p>\n</li>\n<li><p>对象生命周期管理：</p>\n<ol>\n<li>简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以通过配置 scope 属性，来区分这两种不同类型的对象。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象</li>\n<li>我们还可以配置对象是否支持懒加载。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好</li>\n<li>我们还可以配置对象的 init-method 和 destroy-method 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>以及如何实现一个简单的 DI 容器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n    public static void main(String[] args) &#123;\n        ApplicationContext applicationContext &#x3D; new ClassPathXmlApplicationContext(\n            &quot;beans.xml&quot;);\n        RateLimiter rateLimiter &#x3D; (RateLimiter) applicationContext.getBean(&quot;rateLimiter&quot;);\n        rateLimiter.test();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic interface ApplicationContext &#123;\n    Object getBean(String beanId);\n&#125;\n\npublic class ClassPathXmlApplicationContext implements ApplicationContext &#123;\n    private BeansFactory beansFactory;\n    private BeanConfigParser beanConfigParser;\n\n    public ClassPathXmlApplicationContext(String configLocation) &#123;\n        this.beansFactory &#x3D; new BeansFactory();\n        this.beanConfigParser &#x3D; new XmlBeanConfigParser();\n        loadBeanDefinitions(configLocation);\n    &#125;\n\n    private void loadBeanDefinitions(String configLocation) &#123;\n        InputStream in &#x3D; null;\n        try &#123;\n            in &#x3D; this.getClass().getResourceAsStream(&quot;&#x2F;&quot; + configLocation);\n            if (in &#x3D;&#x3D; null) &#123;\n                throw new RuntimeException(&quot;Can not find config file: &quot; + configLocation);\n            &#125;\n            List&lt;BeanDefinition&gt; beanDefinitions &#x3D; beanConfigParser.parse(in);\n            beansFactory.addBeanDefinitions(beanDefinitions);\n        &#125; finally &#123;\n            if (in !&#x3D; null) &#123;\n                try &#123;\n                    in.close();\n                &#125; catch (IOException e) &#123;\n                    &#x2F;&#x2F; TODO: log error\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    @Override\n    public Object getBean(String beanId) &#123;\n        return beansFactory.getBean(beanId);\n    &#125;\n&#125;\n\npublic interface BeanConfigParser &#123;\n    List&lt;BeanDefinition&gt; parse(InputStream inputStream);\n    List&lt;BeanDefinition&gt; parse(String configContent);\n&#125;\n\npublic class XmlBeanConfigParser implements BeanConfigParser &#123;\n\n    @Override\n    public List&lt;BeanDefinition&gt; parse(InputStream inputStream) &#123;\n        String content &#x3D; null;\n        &#x2F;&#x2F; TODO:...\n        return parse(content);\n    &#125;\n\n    @Override\n    public List&lt;BeanDefinition&gt; parse(String configContent) &#123;\n        List&lt;BeanDefinition&gt; beanDefinitions &#x3D; new ArrayList&lt;&gt;();\n        &#x2F;&#x2F; TODO:...\n        return beanDefinitions;\n    &#125;\n&#125;\n\npublic class BeanDefinition &#123;\n    private String id;\n    private String className;\n    private List&lt;ConstructorArg&gt; constructorArgs &#x3D; new ArrayList&lt;&gt;();\n    private Scope scope &#x3D; Scope.SINGLETON;\n    private boolean lazyInit &#x3D; false;\n    &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n\n    public boolean isSingleton() &#123;\n        return scope.equals(Scope.SINGLETON);\n    &#125;\n\n\n    public static enum Scope &#123;\n        SINGLETON,\n        PROTOTYPE\n    &#125;\n\n    public static class ConstructorArg &#123;\n        private boolean isRef;\n        private Class type;\n        private Object arg;\n        &#x2F;&#x2F; 省略必要的getter&#x2F;setter&#x2F;constructors\n    &#125;\n&#125;\n\npublic class BeansFactory &#123;\n    private ConcurrentHashMap&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;();\n    private ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    public void addBeanDefinitions(List&lt;BeanDefinition&gt; beanDefinitionList) &#123;\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            this.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);\n        &#125;\n\n        for (BeanDefinition beanDefinition : beanDefinitionList) &#123;\n            if (beanDefinition.isLazyInit() &#x3D;&#x3D; false &amp;&amp; beanDefinition.isSingleton()) &#123;\n                createBean(beanDefinition);\n            &#125;\n        &#125;\n    &#125;\n\n    public Object getBean(String beanId) &#123;\n        BeanDefinition beanDefinition &#x3D; beanDefinitions.get(beanId);\n        if (beanDefinition &#x3D;&#x3D; null) &#123;\n            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + beanId);\n        &#125;\n        return createBean(beanDefinition);\n    &#125;\n\n    @VisibleForTesting\n    protected Object createBean(BeanDefinition beanDefinition) &#123;\n        if (beanDefinition.isSingleton() &amp;&amp; singletonObjects.contains(beanDefinition.getId())) &#123;\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n\n        Object bean &#x3D; null;\n        try &#123;\n            Class beanClass &#x3D; Class.forName(beanDefinition.getClassName());\n            List&lt;BeanDefinition.ConstructorArg&gt; args &#x3D; beanDefinition.getConstructorArgs();\n            if (args.isEmpty()) &#123;\n                bean &#x3D; beanClass.newInstance();\n            &#125; else &#123;\n                Class[] argClasses &#x3D; new Class[args.size()];\n                Object[] argObjects &#x3D; new Object[args.size()];\n                for (int i &#x3D; 0; i &lt; args.size(); ++i) &#123;\n                    BeanDefinition.ConstructorArg arg &#x3D; args.get(i);\n                    if (!arg.getIsRef()) &#123;\n                        argClasses[i] &#x3D; arg.getType();\n                        argObjects[i] &#x3D; arg.getArg();\n                    &#125; else &#123;\n                        BeanDefinition refBeanDefinition &#x3D; beanDefinitions.get(arg.getArg());\n                        if (refBeanDefinition &#x3D;&#x3D; null) &#123;\n                            throw new NoSuchBeanDefinitionException(&quot;Bean is not defined: &quot; + arg.getArg());\n                        &#125;\n                        argClasses[i] &#x3D; Class.forName(refBeanDefinition.getClassName());\n                        argObjects[i] &#x3D; createBean(refBeanDefinition);\n                    &#125;\n                &#125;\n                bean &#x3D; beanClass.getConstructor(argClasses).newInstance(argObjects);\n            &#125;\n        &#125; catch (ClassNotFoundException | IllegalAccessException\n                 | InstantiationException | NoSuchMethodException | InvocationTargetException e) &#123;\n            throw new BeanCreationFailureException(&quot;&quot;, e);\n        &#125;\n\n        if (bean !&#x3D; null &amp;&amp; beanDefinition.isSingleton()) &#123;\n            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);\n            return singletonObjects.get(beanDefinition.getId());\n        &#125;\n        return bean;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-建造者模式\"><a href=\"#3-建造者模式\" class=\"headerlink\" title=\"3.建造者模式\"></a>3.建造者模式</h4><ol>\n<li><p>为什么需要建造者模式</p>\n<ol>\n<li><p>构造函数的参数列表非常多时，可以使用set()函数来给成员变量赋值，以替代冗长的构造函数，但如果参数列表之间有依赖关系，或者一经构造就不能改变属性值时，建造者模式就派上用场了，使用场景如下：</p>\n<ul>\n<li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过 set() 方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li>\n<li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li>\n<li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了。</li>\n</ul>\n</li>\n<li><p>我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，做集中的校验，校验通过之后才会创建对象。除此之外，我们把 ResourcePoolConfig 的构造函数改为 private 私有权限。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ResourcePoolConfig &#123;\n  private String name;\n  private int maxTotal;\n  private int maxIdle;\n  private int minIdle;\n\n  private ResourcePoolConfig(Builder builder) &#123;\n    this.name &#x3D; builder.name;\n    this.maxTotal &#x3D; builder.maxTotal;\n    this.maxIdle &#x3D; builder.maxIdle;\n    this.minIdle &#x3D; builder.minIdle;\n  &#125;\n  &#x2F;&#x2F;...省略getter方法...\n\n  &#x2F;&#x2F;我们将Builder类设计成了ResourcePoolConfig的内部类。\n  &#x2F;&#x2F;我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。\n  public static class Builder &#123;\n    private static final int DEFAULT_MAX_TOTAL &#x3D; 8;\n    private static final int DEFAULT_MAX_IDLE &#x3D; 8;\n    private static final int DEFAULT_MIN_IDLE &#x3D; 0;\n\n    private String name;\n    private int maxTotal &#x3D; DEFAULT_MAX_TOTAL;\n    private int maxIdle &#x3D; DEFAULT_MAX_IDLE;\n    private int minIdle &#x3D; DEFAULT_MIN_IDLE;\n\n    public ResourcePoolConfig build() &#123;\n      &#x2F;&#x2F; 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等\n      if (StringUtils.isBlank(name)) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      if (maxIdle &gt; maxTotal) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n\n      return new ResourcePoolConfig(this);\n    &#125;\n\n    public Builder setName(String name) &#123;\n      if (StringUtils.isBlank(name)) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.name &#x3D; name;\n      return this;\n    &#125;\n\n    public Builder setMaxTotal(int maxTotal) &#123;\n      if (maxTotal &lt;&#x3D; 0) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.maxTotal &#x3D; maxTotal;\n      return this;\n    &#125;\n\n    public Builder setMaxIdle(int maxIdle) &#123;\n      if (maxIdle &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.maxIdle &#x3D; maxIdle;\n      return this;\n    &#125;\n\n    public Builder setMinIdle(int minIdle) &#123;\n      if (minIdle &lt; 0) &#123;\n        throw new IllegalArgumentException(&quot;...&quot;);\n      &#125;\n      this.minIdle &#x3D; minIdle;\n      return this;\n    &#125;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle\nResourcePoolConfig config &#x3D; new ResourcePoolConfig.Builder()\n        .setName(&quot;dbconnectionpool&quot;)\n        .setMaxTotal(16)\n        .setMaxIdle(10)\n        .setMinIdle(12)\n        .build();</code></pre></li>\n</ol>\n</li>\n<li><p>与工厂模式有何区别：顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p>\n</li>\n</ol>\n<h4 id=\"4-原型模式\"><a href=\"#4-原型模式\" class=\"headerlink\" title=\"4.原型模式\"></a>4.<del>原型模式</del></h4><ol>\n<li><p>原型模式的原理与应用</p>\n<ol>\n<li>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式（Prototype Design Pattern），简称原型模式。</li>\n<li>如果对象中的数据需要经过复杂的计算才能得到（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;代码有问题，重构见下\npublic class Demo &#123;\n  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n  private long lastUpdateTime &#x3D; -1;\n\n  public void refresh() &#123;\n    &#x2F;&#x2F; 原型模式就这么简单，拷贝已有对象的数据，更新少量差值\n    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime &#x3D; lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n      &#125;\n      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n        SearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      &#125; else &#123;\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      &#125;\n    &#125;\n\n    lastUpdateTime &#x3D; maxNewUpdatedTime;\n    currentKeywords &#x3D; newKeywords;\n  &#125;\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  &#125;\n&#125;</code></pre></li>\n<li><p>原型模式的实现方式：深拷贝和浅拷贝</p>\n<ol>\n<li><p>实现：浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，深拷贝不仅仅会复制索引，还会复制数据本身。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据（SearchWord 对象），而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509220710747-165668658181334.png\" alt=\"image-20220509220710747\"></p>\n</li>\n<li><p>在 Java 语言中，Object 类的 clone() 方法执行的就是我们刚刚说的浅拷贝。它只会拷贝对象中的基本数据类型的数据（比如，int、long），以及引用对象（SearchWord）的内存地址，不会递归地拷贝引用对象本身。</p>\n</li>\n<li><p>如何实现深拷贝</p>\n<ol>\n<li><p>递归拷贝对象、对象的引用对象以及引用对象的引用对象……直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n  private long lastUpdateTime &#x3D; -1;\n\n  public void refresh() &#123;\n    &#x2F;&#x2F; Deep copy\n    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; new HashMap&lt;&gt;();\n    for (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) &#123;\n      SearchWord searchWord &#x3D; e.getValue();\n      SearchWord newSearchWord &#x3D; new SearchWord(\n              searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());\n      newKeywords.put(e.getKey(), newSearchWord);\n    &#125;\n\n    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime &#x3D; lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n      &#125;\n      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n        SearchWord oldSearchWord &#x3D; newKeywords.get(searchWord.getKeyword());\n        oldSearchWord.setCount(searchWord.getCount());\n        oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());\n      &#125; else &#123;\n        newKeywords.put(searchWord.getKeyword(), searchWord);\n      &#125;\n    &#125;\n\n    lastUpdateTime &#x3D; maxNewUpdatedTime;\n    currentKeywords &#x3D; newKeywords;\n  &#125;\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  &#125;\n\n&#125;</code></pre></li>\n<li><p>先将对象序列化，然后再反序列化成新的对象。具体的示例代码如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Object deepCopy(Object object) &#123;\n  ByteArrayOutputStream bo &#x3D; new ByteArrayOutputStream();\n  ObjectOutputStream oo &#x3D; new ObjectOutputStream(bo);\n  oo.writeObject(object);\n  \n  ByteArrayInputStream bi &#x3D; new ByteArrayInputStream(bo.toByteArray());\n  ObjectInputStream oi &#x3D; new ObjectInputStream(bi);\n  \n  return oi.readObject();\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>重构版本：我们可以先采用浅拷贝的方式创建 newKeywords。对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据。具体的代码实现如下所示。这也是标题中讲到的，在我们这个应用场景下，最快速 clone 散列表的方式。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123;\n  private HashMap&lt;String, SearchWord&gt; currentKeywords&#x3D;new HashMap&lt;&gt;();\n  private long lastUpdateTime &#x3D; -1;\n\n  public void refresh() &#123;\n    &#x2F;&#x2F; Shallow copy\n    HashMap&lt;String, SearchWord&gt; newKeywords &#x3D; (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();\n\n    &#x2F;&#x2F; 从数据库中取出更新时间&gt;lastUpdateTime的数据，放入到newKeywords中\n    List&lt;SearchWord&gt; toBeUpdatedSearchWords &#x3D; getSearchWords(lastUpdateTime);\n    long maxNewUpdatedTime &#x3D; lastUpdateTime;\n    for (SearchWord searchWord : toBeUpdatedSearchWords) &#123;\n      if (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) &#123;\n        maxNewUpdatedTime &#x3D; searchWord.getLastUpdateTime();\n      &#125;\n      if (newKeywords.containsKey(searchWord.getKeyword())) &#123;\n        newKeywords.remove(searchWord.getKeyword());\n      &#125;\n      newKeywords.put(searchWord.getKeyword(), searchWord);\n    &#125;\n\n    lastUpdateTime &#x3D; maxNewUpdatedTime;\n    currentKeywords &#x3D; newKeywords;\n  &#125;\n\n  private List&lt;SearchWord&gt; getSearchWords(long lastUpdateTime) &#123;\n    &#x2F;&#x2F; TODO: 从数据库中取出更新时间&gt;lastUpdateTime的数据\n    return null;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-结构型设计模式\"><a href=\"#2-结构型设计模式\" class=\"headerlink\" title=\"2.结构型设计模式\"></a>2.结构型设计模式</h3><h4 id=\"1-代理模式\"><a href=\"#1-代理模式\" class=\"headerlink\" title=\"1.代理模式\"></a>1.代理模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p></blockquote>\n<ol>\n<li><p>代理模式（Proxy Design Pattern）：在不改变类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能</p>\n</li>\n<li><p>原始代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController &#123;\n    &#x2F;&#x2F;...省略其他属性和方法...\n    private MetricsCollector metricsCollector; &#x2F;&#x2F; 依赖注入\n\n    public UserVo login(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        &#x2F;&#x2F; ... 省略login逻辑...\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n\n    public UserVo register(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        &#x2F;&#x2F; ... 省略register逻辑...\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n&#125;</code></pre></li>\n<li><p>改动一：因为业务和框架耦合，类的职责不够单一，所以使用代理模式</p>\n<ol>\n<li><p>原始类定义了接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IUserController &#123;\n    UserVo login(String telephone, String password);\n    UserVo register(String telephone, String password);\n&#125;\n\npublic class UserController implements IUserController &#123;\n    &#x2F;&#x2F;...省略其他属性和方法...\n\n    @Override\n    public UserVo login(String telephone, String password) &#123;\n        &#x2F;&#x2F;...省略login逻辑...\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n\n    @Override\n    public UserVo register(String telephone, String password) &#123;\n        &#x2F;&#x2F;...省略register逻辑...\n        &#x2F;&#x2F;...返回UserVo数据...\n    &#125;\n&#125;\n\npublic class UserControllerProxy implements IUserController &#123;\n    private MetricsCollector metricsCollector;\n    private UserController userController;\n\n    public UserControllerProxy(UserController userController) &#123;\n        this.userController &#x3D; userController;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    @Override\n    public UserVo login(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        &#x2F;&#x2F; 委托\n        UserVo userVo &#x3D; userController.login(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n\n    @Override\n    public UserVo register(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        UserVo userVo &#x3D; userController.register(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;UserControllerProxy使用举例\n&#x2F;&#x2F;因为原始类和代理类实现相同的接口，是基于接口而非实现编程\n&#x2F;&#x2F;将UserController类对象替换为UserControllerProxy类对象，不需要改动太多代码\nIUserController userController &#x3D; new UserControllerProxy(new UserController());</code></pre></li>\n<li><p>原始类未定义接口，只能使用继承：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserControllerProxy extends UserController &#123;\n    private MetricsCollector metricsCollector;\n\n    public UserControllerProxy() &#123;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    public UserVo login(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        UserVo userVo &#x3D; super.login(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n\n    public UserVo register(String telephone, String password) &#123;\n        long startTimestamp &#x3D; System.currentTimeMillis();\n\n        UserVo userVo &#x3D; super.register(telephone, password);\n\n        long endTimeStamp &#x3D; System.currentTimeMillis();\n        long responseTime &#x3D; endTimeStamp - startTimestamp;\n        RequestInfo requestInfo &#x3D; new RequestInfo(&quot;register&quot;, responseTime, startTimestamp);\n        metricsCollector.recordRequest(requestInfo);\n\n        return userVo;\n    &#125;\n&#125;\n&#x2F;&#x2F;UserControllerProxy使用举例\nUserController userController &#x3D; new UserControllerProxy();</code></pre></li>\n</ol>\n</li>\n<li><p>改动二：因为需要实现原始类的所有方法，并且都添加相似的逻辑；并且每个原始类都得有一个代理类，所以采用==动态代理==</p>\n<ol>\n<li><p>动态代理（Dynamic Proxy）：不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理来替换原始类</p>\n</li>\n<li><p>Spring AOP底层的实现原理就是基于动态代理，用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能，Spring为这些类创建动态代理对象，并在JVM中替代原始类对象，原本在代码中执行的原始类的方法，被换作执行代理类的方法，也就实现了给原始类添加附加功能的目的。</p>\n</li>\n<li><p>实现：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;动态代理类\npublic class MetricsCollectorProxy &#123;\n    private MetricsCollector metricsCollector;\n\n    public MetricsCollectorProxy() &#123;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    &#x2F;&#x2F;封装了代理类的创建\n    public Object createProxy(Object proxiedObject) &#123;\n        &#x2F;&#x2F;返回Class数组，表示Class对象引用的类所实现的所有接口\n        Class&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();\n        DynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);\n        &#x2F;&#x2F;Proxy provides static methods for creating dynamic proxy classes and instances, \n        &#x2F;&#x2F;and it is also the superclass of all dynamic proxy classes created by those \n        &#x2F;&#x2F;methods.\n        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n    &#125;\n\n    private class DynamicProxyHandler implements InvocationHandler &#123;\n        private Object proxiedObject;\n\n        public DynamicProxyHandler(Object proxiedObject) &#123;\n            this.proxiedObject &#x3D; proxiedObject;\n        &#125;\n\n        &#x2F;&#x2F;所有方法的调用都会变成调用invoke方法，参数为生成的代理类、要调用的方法、对应的参数\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            long startTimestamp &#x3D; System.currentTimeMillis();\n            Object result &#x3D; method.invoke(proxiedObject, args);\n            long endTimeStamp &#x3D; System.currentTimeMillis();\n            long responseTime &#x3D; endTimeStamp - startTimestamp;\n            String apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n            RequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);\n            metricsCollector.recordRequest(requestInfo);\n            return result;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();\nIUserController userController &#x3D; (IUserController) proxy.createProxy(new UserController());</code></pre></li>\n</ol>\n</li>\n<li><p>应用场景</p>\n<ol>\n<li>业务系统的非功能性需求开发，比如：监控、统计、鉴权、限流、事务、幂等、日志</li>\n<li>RPC：将网络通信和数据编解码等细节隐藏起来，客户端在使用RPC服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。<a href=\"https://github.com/wangzheng0822/codedesign/tree/master/com/xzg/cd/rpc\">示例代码</a></li>\n<li>缓存：基于Spring框架来开发，在AOP切面中完成接口缓存的功能，在应用启动的时候，从配置文件中加载需要支持缓存的接口，以及相应的缓存策略（比如过期时间）等。当请求到来的时候，我们在 AOP 切面中拦截请求，如果请求中带有支持缓存的字段（比如 http://…?..&amp;cached=true），我们便从缓存（内存缓存或者 Redis 缓存等）中获取数据直接返回。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-桥接模式\"><a href=\"#2-桥接模式\" class=\"headerlink\" title=\"2.桥接模式\"></a>2.桥接模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。</p></blockquote>\n<ol>\n<li><p>经典应用：JDBC驱动</p>\n<ol>\n<li><p>JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行</p>\n</li>\n<li><p>JDBC驱动用法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;第一件事情是要求 JVM 查找并加载指定的 Driver 类\n&#x2F;&#x2F;第二件事情是执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中。\nClass.forName(&quot;com.mysql.jdbc.Driver&quot;);&#x2F;&#x2F;加载及注册JDBC驱动程序，一共做了两件事\n\nString url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;sample_db?user&#x3D;root&amp;password&#x3D;your_password&quot;;\nConnection con &#x3D; DriverManager.getConnection(url);\nStatement stmt &#x3D; con.createStatement()；\nString query &#x3D; &quot;select * from test&quot;;\nResultSet rs&#x3D;stmt.executeQuery(query);\nwhile(rs.next()) &#123;\n    rs.getString(1);\n    rs.getInt(2);\n&#125;</code></pre></li>\n<li><p>com.mysql.jdbc.Driver类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.mysql.jdbc;\nimport java.sql.SQLException;\n\npublic class Driver extends NonRegisteringDriver implements java.sql.Driver &#123;\n    static &#123;\n        try &#123;\n            java.sql.DriverManager.registerDriver(new Driver());\n        &#125; catch (SQLException E) &#123;\n            throw new RuntimeException(&quot;Can&#39;t register driver!&quot;);\n        &#125;\n    &#125;\n\n    &#x2F;**\n   * Construct a new driver and register it with DriverManager\n   * @throws SQLException if a database error occurs.\n   *&#x2F;\n    public Driver() throws SQLException &#123;\n        &#x2F;&#x2F; Required for Class.forName().newInstance()\n    &#125;\n&#125;</code></pre></li>\n<li><p>DriverManager类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，\n&#x2F;&#x2F;后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了\n&#x2F;&#x2F;相同的接口（java.sql.Driver ），这也是可以灵活切换 Driver 的原因\npublic class DriverManager &#123;\n    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers &#x3D; new CopyOnWriteArrayList&lt;DriverInfo&gt;();\n\n    &#x2F;&#x2F;...\n    static &#123;\n        loadInitialDrivers();\n        println(&quot;JDBC DriverManager initialized&quot;);\n    &#125;\n    &#x2F;&#x2F;...\n\n    public static synchronized void registerDriver(java.sql.Driver driver) throws SQLException &#123;\n        if (driver !&#x3D; null) &#123;\n            registeredDrivers.addIfAbsent(new DriverInfo(driver));\n        &#125; else &#123;\n            throw new NullPointerException();\n        &#125;\n    &#125;\n\n    public static Connection getConnection(String url, String user, String password) throws SQLException &#123;\n        java.util.Properties info &#x3D; new java.util.Properties();\n        if (user !&#x3D; null) &#123;\n            info.put(&quot;user&quot;, user);\n        &#125;\n        if (password !&#x3D; null) &#123;\n            info.put(&quot;password&quot;, password);\n        &#125;\n        return (getConnection(url, info, Reflection.getCallerClass()));\n    &#125;\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>应用二：重构API 接口监控告警</p>\n<ol>\n<li><p>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类（MsgSender 相关类）。其中，Notification 类相当于抽象，MsgSender 类相当于实现，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定（比如，通过读取配置来获取对应关系）。</p>\n</li>\n<li><p>重构前</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum NotificationEmergencyLevel &#123;\n    SEVERE, URGENCY, NORMAL, TRIVIAL\n&#125;\n\npublic class Notification &#123;\n    private List&lt;String&gt; emailAddresses;\n    private List&lt;String&gt; telephones;\n    private List&lt;String&gt; wechatIds;\n\n    public Notification() &#123;&#125;\n\n    public void setEmailAddress(List&lt;String&gt; emailAddress) &#123;\n        this.emailAddresses &#x3D; emailAddress;\n    &#125;\n\n    public void setTelephones(List&lt;String&gt; telephones) &#123;\n        this.telephones &#x3D; telephones;\n    &#125;\n\n    public void setWechatIds(List&lt;String&gt; wechatIds) &#123;\n        this.wechatIds &#x3D; wechatIds;\n    &#125;\n\n    public void notify(NotificationEmergencyLevel level, String message) &#123;\n        if (level.equals(NotificationEmergencyLevel.SEVERE)) &#123;\n            &#x2F;&#x2F;...自动语音电话\n        &#125; else if (level.equals(NotificationEmergencyLevel.URGENCY)) &#123;\n            &#x2F;&#x2F;...发微信\n        &#125; else if (level.equals(NotificationEmergencyLevel.NORMAL)) &#123;\n            &#x2F;&#x2F;...发邮件\n        &#125; else if (level.equals(NotificationEmergencyLevel.TRIVIAL)) &#123;\n            &#x2F;&#x2F;...发邮件\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;在API监控告警的例子中，我们如下方式来使用Notification类：\npublic class ErrorAlertHandler extends AlertHandler &#123;\n    public ErrorAlertHandler(AlertRule rule, Notification notification)&#123;\n        super(rule, notification);\n    &#125;\n\n\n    @Override\n    public void check(ApiStatInfo apiStatInfo) &#123;\n        if (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) &#123;\n            notification.notify(NotificationEmergencyLevel.SEVERE, &quot;...&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>重构后</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface MsgSender &#123;\n    void send(String message);\n&#125;\n\npublic class TelephoneMsgSender implements MsgSender &#123;\n    private List&lt;String&gt; telephones;\n\n    public TelephoneMsgSender(List&lt;String&gt; telephones) &#123;\n        this.telephones &#x3D; telephones;\n    &#125;\n\n    @Override\n    public void send(String message) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n&#x2F;&#x2F;省略EmailMsgSender、WechatMsgSender\n\n\npublic abstract class Notification &#123;\n    &#x2F;&#x2F;组合\n    protected MsgSender msgSender;\n\n    public Notification(MsgSender msgSender) &#123;\n        this.msgSender &#x3D; msgSender;\n    &#125;\n\n    public abstract void notify(String message);\n&#125;\n\npublic class SevereNotification extends Notification &#123;\n    public SevereNotification(MsgSender msgSender) &#123;\n        super(msgSender);\n    &#125;\n\n    @Override\n    public void notify(String message) &#123;\n        msgSender.send(message);\n    &#125;\n&#125;\n&#x2F;&#x2F;省略UrgencyNotification、NormalNotification、TrivialNotification</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-装饰者模式\"><a href=\"#3-装饰者模式\" class=\"headerlink\" title=\"3.装饰者模式\"></a>3.装饰者模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。例如JavaIO类</p></blockquote>\n<ol>\n<li><p>特点：</p>\n<ol>\n<li><p>用组合替代继承</p>\n</li>\n<li><p>装饰器类和原始类继承同样的父类，这样我们可以对原始类“嵌套”多个装饰器类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">InputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nDataInputStream din &#x3D; new DataInputStream(bin);\nint data &#x3D; din.readInt();</code></pre></li>\n<li><p>装饰器类是对功能的增强，这也是装饰器模式应用场景的一个重要特点。</p>\n</li>\n</ol>\n</li>\n<li><p>装饰器模式与代理模式对比</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。\n&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A impelements IA &#123;\n    public void f() &#123; &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class AProxy implements IA &#123;\n    private IA a;\n    public AProxy(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 新添加的代理逻辑\n        a.f();\n        &#x2F;&#x2F; 新添加的代理逻辑\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A implements IA &#123;\n    public void f() &#123; &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class ADecorator implements IA &#123;\n    private IA a;\n    public ADecorator(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 功能增强代码\n        a.f();\n        &#x2F;&#x2F; 功能增强代码\n    &#125;\n&#125;</code></pre></li>\n<li><p>实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class InputStream &#123;\n    &#x2F;&#x2F;...\n    public int read(byte b[]) throws IOException &#123;\n        return read(b, 0, b.length);\n    &#125;\n\n    public int read(byte b[], int off, int len) throws IOException &#123;\n        &#x2F;&#x2F;...\n    &#125;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class BufferedInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n\n    protected BufferedInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现基于缓存的读数据接口...  \n&#125;\n\npublic class DataInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n\n    protected DataInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现读取基本类型数据的接口\n&#125;</code></pre></li>\n<li><p>为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream，代码实现如下所示。InputStream 的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。例如：BufferedInputStream直接使用了FilterInputStream的close()，而没有重新实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FilterInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n\n    protected FilterInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    public int read() throws IOException &#123;\n        return in.read();\n    &#125;\n\n    public int read(byte b[]) throws IOException &#123;\n        return read(b, 0, b.length);\n    &#125;\n\n    public int read(byte b[], int off, int len) throws IOException &#123;\n        return in.read(b, off, len);\n    &#125;\n\n    public long skip(long n) throws IOException &#123;\n        return in.skip(n);\n    &#125;\n\n    public int available() throws IOException &#123;\n        return in.available();\n    &#125;\n\n    public void close() throws IOException &#123;\n        in.close();\n    &#125;\n\n    public synchronized void mark(int readlimit) &#123;\n        in.mark(readlimit);\n    &#125;\n\n    public synchronized void reset() throws IOException &#123;\n        in.reset();\n    &#125;\n\n    public boolean markSupported() &#123;\n        return in.markSupported();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"4-适配器模式\"><a href=\"#4-适配器模式\" class=\"headerlink\" title=\"4.适配器模式\"></a>4.适配器模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p></blockquote>\n<ol>\n<li><p>适配器模式的英文翻译是 Adapter Design Pattern。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p>\n</li>\n<li><p>实现方式：ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口，看情况选择哪种方式，接口大多相同则用类适配器，否则选用对象适配器</p>\n<ol>\n<li><p>类适配器：使用继承来实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n    public void fb() &#123;\n        &#x2F;&#x2F;... \n    &#125;\n    public void fc() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n&#125;\n\npublic class Adaptor extends Adaptee implements ITarget &#123;\n    public void f1() &#123;\n        super.fa();\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;</code></pre></li>\n<li><p>对象适配器：使用组合来实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123;\n        &#x2F;&#x2F;... \n    &#125;\n    public void fb() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n    public void fc() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class Adaptor implements ITarget &#123;\n    private Adaptee adaptee;\n\n    public Adaptor(Adaptee adaptee) &#123;\n        this.adaptee &#x3D; adaptee;\n    &#125;\n\n    public void f1() &#123;\n        adaptee.fa(); &#x2F;&#x2F;委托给Adaptee\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    public void fc() &#123;\n        adaptee.fc();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>应用场景</p>\n<ol>\n<li><p>封装有缺陷的接口设计：假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CD &#123; &#x2F;&#x2F;这个类来自外部sdk，我们无权修改它的代码\n  &#x2F;&#x2F;...\n  public static void staticFunction1() &#123; &#x2F;&#x2F;... &#125;\n  \n  public void uglyNamingFunction2() &#123; &#x2F;&#x2F;... &#125;\n\n  public void tooManyParamsFunction3(int paramA, int paramB, ...) &#123; &#x2F;&#x2F;... &#125;\n  \n   public void lowPerformanceFunction4() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n\n&#x2F;&#x2F; 使用适配器模式进行重构\npublic interface ITarget &#123;\n  void function1();\n  void function2();\n  void fucntion3(ParamsWrapperDefinition paramsWrapper);\n  void function4();\n  &#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F; 注意：适配器类的命名不一定非得末尾带Adaptor\npublic class CDAdaptor extends CD implements ITarget &#123;\n  &#x2F;&#x2F;...\n  public void function1() &#123;\n     super.staticFunction1();\n  &#125;\n  \n  public void function2() &#123;\n    super.uglyNamingFucntion2();\n  &#125;\n  \n  public void function3(ParamsWrapperDefinition paramsWrapper) &#123;\n     super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);\n  &#125;\n  \n  public void function4() &#123;\n    &#x2F;&#x2F;...reimplement it...\n  &#125;\n&#125;</code></pre></li>\n<li><p>统一多个类的接口设计：某个功能的实现依赖多个外部系统（或者说类）。通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑。具体我还是举个例子来解释一下。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ASensitiveWordsFilter &#123; &#x2F;&#x2F; A敏感词过滤系统提供的接口\n  &#x2F;&#x2F;text是原始文本，函数输出用***替换敏感词之后的文本\n  public String filterSexyWords(String text) &#123;\n    &#x2F;&#x2F; ...\n  &#125;\n  \n  public String filterPoliticalWords(String text) &#123;\n    &#x2F;&#x2F; ...\n  &#125; \n&#125;\n\npublic class BSensitiveWordsFilter  &#123; &#x2F;&#x2F; B敏感词过滤系统提供的接口\n  public String filter(String text) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n\npublic class CSensitiveWordsFilter &#123; &#x2F;&#x2F; C敏感词过滤系统提供的接口\n  public String filter(String text, String mask) &#123;\n    &#x2F;&#x2F;...\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 未使用适配器模式之前的代码：代码的可测试性、扩展性不好\npublic class RiskManagement &#123;\n  private ASensitiveWordsFilter aFilter &#x3D; new ASensitiveWordsFilter();\n  private BSensitiveWordsFilter bFilter &#x3D; new BSensitiveWordsFilter();\n  private CSensitiveWordsFilter cFilter &#x3D; new CSensitiveWordsFilter();\n  \n  public String filterSensitiveWords(String text) &#123;\n    String maskedText &#x3D; aFilter.filterSexyWords(text);\n    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n    maskedText &#x3D; bFilter.filter(maskedText);\n    maskedText &#x3D; cFilter.filter(maskedText, &quot;***&quot;);\n    return maskedText;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 使用适配器模式进行改造\npublic interface ISensitiveWordsFilter &#123; &#x2F;&#x2F; 统一接口定义\n  String filter(String text);\n&#125;\n\npublic class ASensitiveWordsFilterAdaptor implements ISensitiveWordsFilter &#123;\n  private ASensitiveWordsFilter aFilter;\n  public String filter(String text) &#123;\n    String maskedText &#x3D; aFilter.filterSexyWords(text);\n    maskedText &#x3D; aFilter.filterPoliticalWords(maskedText);\n    return maskedText;\n  &#125;\n&#125;\n&#x2F;&#x2F;...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...\n\n&#x2F;&#x2F; 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，\n&#x2F;&#x2F; 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。\npublic class RiskManagement &#123; \n  private List&lt;ISensitiveWordsFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n \n  public void addSensitiveWordsFilter(ISensitiveWordsFilter filter) &#123;\n    filters.add(filter);\n  &#125;\n  \n  public String filterSensitiveWords(String text) &#123;\n    String maskedText &#x3D; text;\n    for (ISensitiveWordsFilter filter : filters) &#123;\n      maskedText &#x3D; filter.filter(maskedText);\n    &#125;\n    return maskedText;\n  &#125;\n&#125;</code></pre></li>\n<li><p>替换依赖的外部系统：当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，利用适配器模式，可以减少对代码的改动。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 外部系统A\npublic interface IA &#123;\n  &#x2F;&#x2F;...\n  void fa();\n&#125;\npublic class A implements IA &#123;\n  &#x2F;&#x2F;...\n  public void fa() &#123; &#x2F;&#x2F;... &#125;\n&#125;\n&#x2F;&#x2F; 在我们的项目中，外部系统A的使用示例\npublic class Demo &#123;\n  private IA a;\n  public Demo(IA a) &#123;\n    this.a &#x3D; a;\n  &#125;\n  &#x2F;&#x2F;...\n&#125;\nDemo d &#x3D; new Demo(new A());\n\n&#x2F;&#x2F; 将外部系统A替换成外部系统B\npublic class BAdaptor implemnts IA &#123;\n  private B b;\n  public BAdaptor(B b) &#123;\n    this.b&#x3D; b;\n  &#125;\n  public void fa() &#123;\n    &#x2F;&#x2F;...\n    b.fb();\n  &#125;\n&#125;\n&#x2F;&#x2F; 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，\n&#x2F;&#x2F; 只需要将BAdaptor如下注入到Demo即可。\nDemo d &#x3D; new Demo(new BAdaptor(new B()));</code></pre></li>\n<li><p>兼容老版本接口：在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 deprecated，并将内部实现逻辑委托为新的接口实现。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;暂时保留 Enumeration 类，并将其实现替换为直接调用 Itertor\npublic class Collections &#123;\n    public static Emueration emumeration(final Collection c) &#123;\n        return new Enumeration() &#123;\n            Iterator i &#x3D; c.iterator();\n\n            public boolean hasMoreElments() &#123;\n                return i.hashNext();\n            &#125;\n\n            public Object nextElement() &#123;\n                return i.next():\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>适配不同格式的数据：可以用在不同格式的数据之间的适配，比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; stooges &#x3D; Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</code></pre></li>\n</ol>\n</li>\n<li><p>在Java日志中的作用：Slf4j定义了接口，但没有定义实现。因为JUL、JCL、log4j 等日志框架并没有将接口改造成符合Slf4j 接口规范。所以，Slf4j不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器。对不同日志框架的接口进行二次封装，适配成统一的 Slf4j 接口定义。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; slf4j统一的接口定义\npackage org.slf4j;\npublic interface Logger &#123;\n  public boolean isTraceEnabled();\n  public void trace(String msg);\n  public void trace(String format, Object arg);\n  public void trace(String format, Object arg1, Object arg2);\n  public void trace(String format, Object[] argArray);\n  public void trace(String msg, Throwable t);\n \n  public boolean isDebugEnabled();\n  public void debug(String msg);\n  public void debug(String format, Object arg);\n  public void debug(String format, Object arg1, Object arg2)\n  public void debug(String format, Object[] argArray)\n  public void debug(String msg, Throwable t);\n\n  &#x2F;&#x2F;...省略info、warn、error等一堆接口\n&#125;\n\n&#x2F;&#x2F; log4j日志框架的适配器\n&#x2F;&#x2F; Log4jLoggerAdapter实现了LocationAwareLogger接口，\n&#x2F;&#x2F; 其中LocationAwareLogger继承自Logger接口，\n&#x2F;&#x2F; 也就相当于Log4jLoggerAdapter实现了Logger接口。\npackage org.slf4j.impl;\npublic final class Log4jLoggerAdapter extends MarkerIgnoringBase\n  implements LocationAwareLogger, Serializable &#123;\n  final transient org.apache.log4j.Logger logger; &#x2F;&#x2F; log4j\n \n  public boolean isDebugEnabled() &#123;\n    return logger.isDebugEnabled();\n  &#125;\n \n  public void debug(String msg) &#123;\n    logger.log(FQCN, Level.DEBUG, msg, null);\n  &#125;\n \n  public void debug(String format, Object arg) &#123;\n    if (logger.isDebugEnabled()) &#123;\n      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    &#125;\n  &#125;\n \n  public void debug(String format, Object arg1, Object arg2) &#123;\n    if (logger.isDebugEnabled()) &#123;\n      FormattingTuple ft &#x3D; MessageFormatter.format(format, arg1, arg2);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    &#125;\n  &#125;\n \n  public void debug(String format, Object[] argArray) &#123;\n    if (logger.isDebugEnabled()) &#123;\n      FormattingTuple ft &#x3D; MessageFormatter.arrayFormat(format, argArray);\n      logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());\n    &#125;\n  &#125;\n \n  public void debug(String msg, Throwable t) &#123;\n    logger.log(FQCN, Level.DEBUG, msg, t);\n  &#125;\n  &#x2F;&#x2F;...省略一堆接口的实现...\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"5-门面模式\"><a href=\"#5-门面模式\" class=\"headerlink\" title=\"5.门面模式\"></a>5.<del>门面模式</del></h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。</p></blockquote>\n<ol>\n<li>应用场景<ol>\n<li>解决易用性问题：门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。比如，Linux 系统调用函数就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 Shell 命令，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</li>\n<li>解决性能问题：过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。组织门面接口和非门面接口的方法：如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。</li>\n<li>解决分布式事务问题：要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务（如果是 Java 语言的话），在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-组合模式\"><a href=\"#6-组合模式\" class=\"headerlink\" title=\"6.组合模式\"></a>6.<del>组合模式</del></h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让代码的使用者可以统一单个对象和组合对象的处理逻辑。</p></blockquote>\n<ol>\n<li><p>应用一：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：动态地添加、删除某个目录下的子目录或文件；统计指定目录下的文件个数；统计指定目录下的文件总大小。</p>\n<ol>\n<li>重构前</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class FileSystemNode &#123;\n    private String path;\n    private boolean isFile;\n    private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\n    public FileSystemNode(String path, boolean isFile) &#123;\n        this.path &#x3D; path;\n        this.isFile &#x3D; isFile;\n    &#125;\n\n    public int countNumOfFiles() &#123;\n        &#x2F;&#x2F; TODO:...\n    &#125;\n\n    public long countSizeOfFiles() &#123;\n        &#x2F;&#x2F; TODO:...\n    &#125;\n\n    public String getPath() &#123;\n        return path;\n    &#125;\n\n    public void addSubNode(FileSystemNode fileOrDir) &#123;\n        subNodes.add(fileOrDir);\n    &#125;\n\n    public void removeSubNode(FileSystemNode fileOrDir) &#123;\n        int size &#x3D; subNodes.size();\n        int i &#x3D; 0;\n        for (; i &lt; size; ++i) &#123;\n            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n                break;\n            &#125;\n        &#125;\n        if (i &lt; size) &#123;\n            subNodes.remove(i);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>重构后</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class FileSystemNode &#123;\n    protected String path;\n\n    public FileSystemNode(String path) &#123;\n        this.path &#x3D; path;\n    &#125;\n\n    public abstract int countNumOfFiles();\n    public abstract long countSizeOfFiles();\n\n    public String getPath() &#123;\n        return path;\n    &#125;\n&#125;\n\npublic class File extends FileSystemNode &#123;\n    public File(String path) &#123;\n        super(path);\n    &#125;\n\n    @Override\n    public int countNumOfFiles() &#123;\n        return 1;\n    &#125;\n\n    @Override\n    public long countSizeOfFiles() &#123;\n        java.io.File file &#x3D; new java.io.File(path);\n        if (!file.exists()) return 0;\n        return file.length();\n    &#125;\n&#125;\n\npublic class Directory extends FileSystemNode &#123;\n    private List&lt;FileSystemNode&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\n    public Directory(String path) &#123;\n        super(path);\n    &#125;\n\n    @Override\n    public int countNumOfFiles() &#123;\n        int numOfFiles &#x3D; 0;\n        for (FileSystemNode fileOrDir : subNodes) &#123;\n            numOfFiles +&#x3D; fileOrDir.countNumOfFiles();\n        &#125;\n        return numOfFiles;\n    &#125;\n\n    @Override\n    public long countSizeOfFiles() &#123;\n        long sizeofFiles &#x3D; 0;\n        for (FileSystemNode fileOrDir : subNodes) &#123;\n            sizeofFiles +&#x3D; fileOrDir.countSizeOfFiles();\n        &#125;\n        return sizeofFiles;\n    &#125;\n\n    public void addSubNode(FileSystemNode fileOrDir) &#123;\n        subNodes.add(fileOrDir);\n    &#125;\n\n    public void removeSubNode(FileSystemNode fileOrDir) &#123;\n        int size &#x3D; subNodes.size();\n        int i &#x3D; 0;\n        for (; i &lt; size; ++i) &#123;\n            if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;\n                break;\n            &#125;\n        &#125;\n        if (i &lt; size) &#123;\n            subNodes.remove(i);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>应用二：在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class HumanResource &#123;\n    protected long id;\n    protected double salary;\n\n    public HumanResource(long id) &#123;\n        this.id &#x3D; id;\n    &#125;\n\n    public long getId() &#123;\n        return id;\n    &#125;\n\n    public abstract double calculateSalary();\n&#125;\n\npublic class Employee extends HumanResource &#123;\n    public Employee(long id, double salary) &#123;\n        super(id);\n        this.salary &#x3D; salary;\n    &#125;\n\n    @Override\n    public double calculateSalary() &#123;\n        return salary;\n    &#125;\n&#125;\n\npublic class Department extends HumanResource &#123;\n    private List&lt;HumanResource&gt; subNodes &#x3D; new ArrayList&lt;&gt;();\n\n    public Department(long id) &#123;\n        super(id);\n    &#125;\n\n    @Override\n    public double calculateSalary() &#123;\n        double totalSalary &#x3D; 0;\n        for (HumanResource hr : subNodes) &#123;\n            totalSalary +&#x3D; hr.calculateSalary();\n        &#125;\n        this.salary &#x3D; totalSalary;\n        return totalSalary;\n    &#125;\n\n    public void addSubNode(HumanResource hr) &#123;\n        subNodes.add(hr);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 构建组织架构的代码\npublic class Demo &#123;\n    private static final long ORGANIZATION_ROOT_ID &#x3D; 1001;\n    private DepartmentRepo departmentRepo; &#x2F;&#x2F; 依赖注入\n    private EmployeeRepo employeeRepo; &#x2F;&#x2F; 依赖注入\n\n    public void buildOrganization() &#123;\n        Department rootDepartment &#x3D; new Department(ORGANIZATION_ROOT_ID);\n        buildOrganization(rootDepartment);\n    &#125;\n\n    private void buildOrganization(Department department) &#123;\n        List&lt;Long&gt; subDepartmentIds &#x3D; departmentRepo.getSubDepartmentIds(department.getId());\n        for (Long subDepartmentId : subDepartmentIds) &#123;\n            Department subDepartment &#x3D; new Department(subDepartmentId);\n            department.addSubNode(subDepartment);\n            buildOrganization(subDepartment);\n        &#125;\n        List&lt;Long&gt; employeeIds &#x3D; employeeRepo.getDepartmentEmployeeIds(department.getId());\n        for (Long employeeId : employeeIds) &#123;\n            double salary &#x3D; employeeRepo.getEmployeeSalary(employeeId);\n            department.addSubNode(new Employee(employeeId, salary));\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"7-享元模式\"><a href=\"#7-享元模式\" class=\"headerlink\" title=\"7.享元模式\"></a>7.<del>享元模式</del></h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的</p></blockquote>\n<ol>\n<li><p>棋牌游戏</p>\n<ol>\n<li><p>重构前</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChessPiece &#123;&#x2F;&#x2F;棋子\n    private int id;\n    private String text;\n    private Color color;\n    private int positionX;\n    private int positionY;\n\n    public ChessPiece(int id, String text, Color color, int positionX, int positionY) &#123;\n        this.id &#x3D; id;\n        this.text &#x3D; text;\n        this.color &#x3D; color;\n        this.positionX &#x3D; positionX;\n        this.positionY &#x3D; positionX;\n    &#125;\n\n    public static enum Color &#123;\n        RED, BLACK\n    &#125;\n\n    &#x2F;&#x2F; ...省略其他属性和getter&#x2F;setter方法...\n&#125;\n\npublic class ChessBoard &#123;&#x2F;&#x2F;棋局\n    private Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\n    public ChessBoard() &#123;\n        init();\n    &#125;\n\n    private void init() &#123;\n        chessPieces.put(1, new ChessPiece(1, &quot;車&quot;, ChessPiece.Color.BLACK, 0, 0));\n        chessPieces.put(2, new ChessPiece(2,&quot;馬&quot;, ChessPiece.Color.BLACK, 0, 1));\n        &#x2F;&#x2F;...省略摆放其他棋子的代码...\n    &#125;\n\n    public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n        &#x2F;&#x2F;...省略...\n    &#125;\n&#125;</code></pre></li>\n<li><p>重构后：因为需要保存太多盘棋局，耗费大量内存。因为id、text、color都相同，只是positionX、positionY 不同，所以将棋子的 id、text、color 属性拆分出来，设计成独立的类，并且作为享元供多个棋盘复用，棋盘只需要记录每个棋子的位置信息就可以了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 享元类\npublic class ChessPieceUnit &#123;\n    private int id;\n    private String text;\n    private Color color;\n\n    public ChessPieceUnit(int id, String text, Color color) &#123;\n        this.id &#x3D; id;\n        this.text &#x3D; text;\n        this.color &#x3D; color;\n    &#125;\n\n    public static enum Color &#123;\n        RED, BLACK\n    &#125;\n\n    &#x2F;&#x2F; ...省略其他属性和getter方法...\n&#125;\n&#x2F;&#x2F;工厂模式，通过一个 Map 来缓存已经创建过的享元对象，来达到复用的目的\npublic class ChessPieceUnitFactory &#123;\n    private static final Map&lt;Integer, ChessPieceUnit&gt; pieces &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        pieces.put(1, new ChessPieceUnit(1, &quot;車&quot;, ChessPieceUnit.Color.BLACK));\n        pieces.put(2, new ChessPieceUnit(2,&quot;馬&quot;, ChessPieceUnit.Color.BLACK));\n        &#x2F;&#x2F;...省略摆放其他棋子的代码...\n    &#125;\n\t&#x2F;&#x2F;取享元对象\n    public static ChessPieceUnit getChessPiece(int chessPieceId) &#123;\n        return pieces.get(chessPieceId);\n    &#125;\n&#125;\n&#x2F;&#x2F;棋子只剩下位置属性\npublic class ChessPiece &#123;\n    private ChessPieceUnit chessPieceUnit;\n    private int positionX;\n    private int positionY;\n\n    public ChessPiece(ChessPieceUnit unit, int positionX, int positionY) &#123;\n        this.chessPieceUnit &#x3D; unit;\n        this.positionX &#x3D; positionX;\n        this.positionY &#x3D; positionY;\n    &#125;\n    &#x2F;&#x2F; 省略getter、setter方法\n&#125;\n\npublic class ChessBoard &#123;\n    private Map&lt;Integer, ChessPiece&gt; chessPieces &#x3D; new HashMap&lt;&gt;();\n\n    public ChessBoard() &#123;\n        init();\n    &#125;\n\n    private void init() &#123;\n        chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(1), 0,0));\n        chessPieces.put(1, new ChessPiece(\n            ChessPieceUnitFactory.getChessPiece(2), 1,0));\n        &#x2F;&#x2F;...省略摆放其他棋子的代码...\n    &#125;\n\n    public void move(int chessPieceId, int toPositionX, int toPositionY) &#123;\n        &#x2F;&#x2F;...省略...\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>文本编辑器</p>\n<ol>\n<li><p>重构前</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Character &#123;&#x2F;&#x2F;文字\n    private char c;\n\n    private Font font;\n    private int size;\n    private int colorRGB;\n\n    public Character(char c, Font font, int size, int colorRGB) &#123;\n        this.c &#x3D; c;\n        this.font &#x3D; font;\n        this.size &#x3D; size;\n        this.colorRGB &#x3D; colorRGB;\n    &#125;\n&#125;\n&#x2F;&#x2F;在文本编辑器中，每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。\npublic class Editor &#123;\n    private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\n    public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n        Character character &#x3D; new Character(c, font, size, colorRGB);\n        chars.add(character);\n    &#125;\n&#125;</code></pre></li>\n<li><p>重构后：实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，对于字体格式，可以将它设计成享元，让不同的文字共享使用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;享元类\npublic class CharacterStyle &#123;\n    private Font font;\n    private int size;\n    private int colorRGB;\n\n    public CharacterStyle(Font font, int size, int colorRGB) &#123;\n        this.font &#x3D; font;\n        this.size &#x3D; size;\n        this.colorRGB &#x3D; colorRGB;\n    &#125;\n\n    @Override\n    public boolean equals(Object o) &#123;\n        CharacterStyle otherStyle &#x3D; (CharacterStyle) o;\n        return font.equals(otherStyle.font)\n            &amp;&amp; size &#x3D;&#x3D; otherStyle.size\n            &amp;&amp; colorRGB &#x3D;&#x3D; otherStyle.colorRGB;\n    &#125;\n&#125;\n&#x2F;&#x2F;工厂方法\npublic class CharacterStyleFactory &#123;\n    private static final List&lt;CharacterStyle&gt; styles &#x3D; new ArrayList&lt;&gt;();\n\n    public static CharacterStyle getStyle(Font font, int size, int colorRGB) &#123;\n        CharacterStyle newStyle &#x3D; new CharacterStyle(font, size, colorRGB);\n        for (CharacterStyle style : styles) &#123;\n            if (style.equals(newStyle)) &#123;\n                return style;\n            &#125;\n        &#125;\n        styles.add(newStyle);\n        return newStyle;\n    &#125;\n&#125;\n&#x2F;&#x2F;剩余的字符类，字符类型是共享的\npublic class Character &#123;\n    private char c;\n    private CharacterStyle style;\n\n    public Character(char c, CharacterStyle style) &#123;\n        this.c &#x3D; c;\n        this.style &#x3D; style;\n    &#125;\n&#125;\n\npublic class Editor &#123;\n    private List&lt;Character&gt; chars &#x3D; new ArrayList&lt;&gt;();\n\n    public void appendCharacter(char c, Font font, int size, int colorRGB) &#123;\n        Character character &#x3D; new Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));\n        chars.add(character);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>在Integer、String中的应用</p>\n<ol>\n<li><p>Integer中：通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建。（其他包装器类型，比如 Long、Short、Byte 等，也都利用了享元模式来缓存 -128 到 127 之间的数据）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i1 &#x3D; 56;\nInteger i2 &#x3D; 56;\nInteger i3 &#x3D; 129;\nInteger i4 &#x3D; 129;\nSystem.out.println(i1 &#x3D;&#x3D; i2);&#x2F;&#x2F;true\nSystem.out.println(i3 &#x3D;&#x3D; i4);&#x2F;&#x2F;false</code></pre></li>\n<li><p>String中：String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; &quot;小争哥&quot;;\nString s2 &#x3D; &quot;小争哥&quot;;\nString s3 &#x3D; new String(&quot;小争哥&quot;);\n\nSystem.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;true\nSystem.out.println(s1 &#x3D;&#x3D; s3);&#x2F;&#x2F;false</code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-行为型设计模式\"><a href=\"#3-行为型设计模式\" class=\"headerlink\" title=\"3.行为型设计模式\"></a>3.行为型设计模式</h3><h4 id=\"1-观察者模式\"><a href=\"#1-观察者模式\" class=\"headerlink\" title=\"1.观察者模式\"></a>1.观察者模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p></blockquote>\n<ol>\n<li><p>模板代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Subject &#123;\n    &#x2F;&#x2F;也可起名为attach\n    void registerObserver(Observer observer);\n    &#x2F;&#x2F;也可起名为detach\n    void removeObserver(Observer observer);\n    &#x2F;&#x2F;一个一个通知\n    void notifyObservers(Message message);\n&#125;\n&#x2F;&#x2F;被依赖的对象叫被观察者（Observable）；依赖的对象叫观察者（Observer）\npublic interface Observer &#123;\n    void update(Message message);\n&#125;\n&#x2F;&#x2F;Concrete：具体的\npublic class ConcreteSubject implements Subject &#123;\n    private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n\n    @Override\n    public void registerObserver(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    @Override\n    public void removeObserver(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    @Override\n    public void notifyObservers(Message message) &#123;\n        for (Observer observer : observers) &#123;\n            observer.update(message);\n        &#125;\n    &#125;\n\n&#125;\n\npublic class ConcreteObserverOne implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteObserverTwo implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n    &#125;\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ConcreteSubject subject &#x3D; new ConcreteSubject();\n        subject.registerObserver(new ConcreteObserverOne());\n        subject.registerObserver(new ConcreteObserverTwo());\n        subject.notifyObservers(new Message());\n    &#125;\n&#125;</code></pre></li>\n<li><p>应用一同步阻塞方式：用户注册成功之后，采取发放投资体验金或者发放优惠卷等措施</p>\n<ol>\n<li><p>重构前</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n        promotionService.issueNewUserExperienceCash(userId);\n        return userId;\n    &#125;\n&#125;</code></pre></li>\n<li><p>重构后</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface RegObserver &#123;\n    void handleRegSuccess(long userId);\n&#125;\n\npublic class RegPromotionObserver implements RegObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Override\n    public void handleRegSuccess(long userId) &#123;\n        promotionService.issueNewUserExperienceCash(userId);\n    &#125;\n&#125;\n\npublic class RegNotificationObserver implements RegObserver &#123;\n    private NotificationService notificationService;&#x2F;&#x2F; 依赖注入\n\n    @Override\n    public void handleRegSuccess(long userId) &#123;\n        notificationService.sendInboxMessage(userId, &quot;Welcome...&quot;);\n    &#125;\n&#125;\n\npublic class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n    private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();\n\n    &#x2F;&#x2F; 一次性设置好，之后也不可能动态的修改，\n    &#x2F;&#x2F;如果想增加新的观察者，只需要添加一个实现了RegObserver接口的类，\n    &#x2F;&#x2F;并且通过setRegObserver()函数将它注册到UserController类中即可\n    public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;\n        regObservers.addAll(observers);\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n\n        &#x2F;&#x2F;同步阻塞方式：register() 函数依次调用执行每个观察者的 handleRegSuccess() 函数，\n        &#x2F;&#x2F;等到都执行完成之后，才会返回结果给客户端。  \n        for (RegObserver observer : regObservers) &#123;\n            &#x2F;&#x2F;非同进程时，使用RPC接口或Message Queue\n            observer.handleRegSuccess(userId);\n        &#125;\n        \n        &#x2F;&#x2F;异步非阻塞方式：当 userService.register() 函数执行完成之后，我们启动一个新的线程\n        &#x2F;&#x2F;来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不\n        &#x2F;&#x2F;需要等到所有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。\n        \n        return userId;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>应用二异步非阻塞方式：EventBus（Google Guava）</p>\n<ol>\n<li><p>简单实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 第一种实现方式，其他类代码不变，就没有再重复罗列\n&#x2F;&#x2F;频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出\npublic class RegPromotionObserver implements RegObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Override\n    public void handleRegSuccess(Long userId) &#123;\n        Thread thread &#x3D; new Thread(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                promotionService.issueNewUserExperienceCash(userId);\n            &#125;\n        &#125;);\n        thread.start();\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 第二种实现方式，其他类代码不变，就没有再重复罗列\n&#x2F;&#x2F;尽管利用了线程池解决了第一种实现方式的问题，但线程池、异步执行逻辑都耦合在了 \n&#x2F;&#x2F;register() 函数中，增加了这部分业务代码的维护成本\npublic class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n    private List&lt;RegObserver&gt; regObservers &#x3D; new ArrayList&lt;&gt;();\n    &#x2F;&#x2F;实现线程池\n    private Executor executor;\n\n    public UserController(Executor executor) &#123;\n        this.executor &#x3D; executor;\n    &#125;\n\n    public void setRegObservers(List&lt;RegObserver&gt; observers) &#123;\n        regObservers.addAll(observers);\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n\n        for (RegObserver observer : regObservers) &#123;\n            executor.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    observer.handleRegSuccess(userId);\n                &#125;\n            &#125;);\n        &#125;\n\n        return userId;\n    &#125;\n&#125;</code></pre></li>\n<li><p>EventBus框架（事件总线）</p>\n<ol>\n<li><p>提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。Google Guava EventBus 就是一个比较著名的 EventBus 框架，它不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式。</p>\n</li>\n<li><p>重构后</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n\n    private EventBus eventBus;\n    private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;\n\n    public UserController() &#123;\n        &#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式\n        eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool\n                                     (DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); &#x2F;&#x2F; 异步非阻塞\n    &#125;\n\n    public void setRegObservers(List&lt;Object&gt; observers) &#123;\n        for (Object observer : observers) &#123;\n            &#x2F;&#x2F;用来注册任何类型（Object）的观察者，而在经典的观察者模式的实现中，\n            &#x2F;&#x2F;register() 函数必须接受实现了同一 Observer 接口的类对象。\n            eventBus.register(observer);\n        &#125;\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        &#x2F;&#x2F;省略输入参数的校验代码\n        &#x2F;&#x2F;省略userService.register()异常的try-catch代码\n        long userId &#x3D; userService.register(telephone, password);\n        \n\t\t&#x2F;&#x2F;用来给观察者发送信息，当我们调用post()函数发送信息的时候，并非把消息发送给\n        &#x2F;&#x2F;所有的观察者，而是发送给可匹配的观察者，即接受的消息类型是发送消息（post\n        &#x2F;&#x2F;函数定义中的event）类型的父类\n        eventBus.post(userId);\n\n        return userId;\n    &#125;\n&#125;\n\npublic class RegPromotionObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Subscribe&#x2F;&#x2F;定义能接收的消息类型\n    public void handleRegSuccess(Long userId) &#123;\n        promotionService.issueNewUserExperienceCash(userId);\n    &#125;\n&#125;\n\npublic class RegNotificationObserver &#123;\n    private NotificationService notificationService;\n\n    @Subscribe\n    public void handleRegSuccess(Long userId) &#123;\n        notificationService.sendInboxMessage(userId, &quot;...&quot;);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>@Subscribe注解：当通过 register() 函数将 DObserver 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe 注解找到 f1() 和 f2()，并且将两个函数能接收的消息类型记录下来（PMsg-&gt;f1，QMsg-&gt;f2）。当我们通过 post() 函数发送消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public DObserver &#123;\n  &#x2F;&#x2F;...省略其他属性和方法...\n  \n  @Subscribe\n  public void f1(PMsg event) &#123; &#x2F;&#x2F;... &#125;\n  \n  @Subscribe\n  public void f2(QMsg event) &#123; &#x2F;&#x2F;... &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>EventBus框架实现</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-模板模式\"><a href=\"#2-模板模式\" class=\"headerlink\" title=\"2.模板模式\"></a>2.模板模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。</p></blockquote>\n<ol>\n<li><p>代码实现：模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractClass &#123;\n    &#x2F;&#x2F;定义为final，避免子类重写\n    public final void templateMethod() &#123;\n        &#x2F;&#x2F;...\n        method1();\n        &#x2F;&#x2F;...\n        method2();\n        &#x2F;&#x2F;...\n    &#125;\n\t&#x2F;&#x2F;定义为abstract是为了强迫子类去实现\n    protected abstract void method1();\n    protected abstract void method2();\n&#125;\n\npublic class ConcreteClass1 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n\n    @Override\n    protected void method2() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class ConcreteClass2 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n\n    @Override\n    protected void method2() &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\nAbstractClass demo &#x3D; ConcreteClass1();\ndemo.templateMethod();</code></pre></li>\n<li><p>作用一：代码的复用</p>\n<ol>\n<li><p>Java InputStream：read() 函数是一个模板方法，定义了读取数据的整个流程，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class InputStream implements Closeable &#123;\n    &#x2F;&#x2F;...省略其他代码...\n\n    public int read(byte b[], int off, int len) throws IOException &#123;\n        if (b &#x3D;&#x3D; null) &#123;\n            throw new NullPointerException();\n        &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125; else if (len &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n\n        int c &#x3D; read();\n        if (c &#x3D;&#x3D; -1) &#123;\n            return -1;\n        &#125;\n        b[off] &#x3D; (byte)c;\n\n        int i &#x3D; 1;\n        try &#123;\n            for (; i &lt; len ; i++) &#123;\n                c &#x3D; read();\n                if (c &#x3D;&#x3D; -1) &#123;\n                    break;\n                &#125;\n                b[off + i] &#x3D; (byte)c;\n            &#125;\n        &#125; catch (IOException ee) &#123;\n        &#125;\n        return i;\n    &#125;\n\t&#x2F;&#x2F;抽象方法\n    public abstract int read() throws IOException;\n&#125;\n\npublic class ByteArrayInputStream extends InputStream &#123;\n    &#x2F;&#x2F;...省略其他代码...\n\n    @Override\n    public synchronized int read() &#123;\n        return (pos &lt; count) ? (buf[pos++] &amp; 0xff) : -1;\n    &#125;\n&#125;</code></pre></li>\n<li><p>Java AbstractList：addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现直接抛出了 UnsupportedOperationException 异常。前提是，如果子类不重写是不能使用的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;\n    rangeCheckForAdd(index);\n    boolean modified &#x3D; false;\n    for (E e : c) &#123;\n        add(index++, e);\n        modified &#x3D; true;\n    &#125;\n    return modified;\n&#125;\n\npublic void add(int index, E element) &#123;\n    throw new UnsupportedOperationException();\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>作用二：框架的扩展</p>\n<ol>\n<li><p>Java Servlet：</p>\n<ol>\n<li><p>使用比较底层的 Servlet 来开发 Web 项目也不难。我们只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法，来分别处理 get 和 post 请求。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doPost(req, resp);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        resp.getWriter().write(&quot;Hello World.&quot;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>在配置文件 web.xml 中做如下配置。Tomcat、Jetty 等 Servlet 容器在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;servlet&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n    &lt;servlet-class&gt;com.xzg.cd.HelloServlet&lt;&#x2F;servlet-class&gt;\n&lt;&#x2F;servlet&gt;\n\n&lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;\n    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;servlet-mapping&gt;</code></pre></li>\n<li><p>当我们在浏览器中输入网址（比如，<a href=\"http://127.0.0.1:8080/hello\">http://127.0.0.1:8080/hello</a> ）的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p>\n</li>\n<li><p>HttpServlet的service()函数就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就相当于 Servlet 框架提供了一个扩展点（doGet()、doPost() 方法），让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void service(ServletRequest req, ServletResponse res)\n    throws ServletException, IOException\n&#123;\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &amp;&amp;\n          res instanceof HttpServletResponse)) &#123;\n        throw new ServletException(&quot;non-HTTP request or response&quot;);\n    &#125;\n    request &#x3D; (HttpServletRequest) req;\n    response &#x3D; (HttpServletResponse) res;\n    service(request, response);\n&#125;\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp)\n    throws ServletException, IOException\n&#123;\n    String method &#x3D; req.getMethod();\n    if (method.equals(METHOD_GET)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        if (lastModified &#x3D;&#x3D; -1) &#123;\n            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason\n            &#x2F;&#x2F; to go through further expensive logic\n            doGet(req, resp);\n        &#125; else &#123;\n            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince &lt; lastModified) &#123;\n                &#x2F;&#x2F; If the servlet mod time is later, call doGet()\n                &#x2F;&#x2F; Round down to the nearest second for a proper compare\n                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            &#125; else &#123;\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            &#125;\n        &#125;\n    &#125; else if (method.equals(METHOD_HEAD)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    &#125; else if (method.equals(METHOD_POST)) &#123;\n        doPost(req, resp);\n    &#125; else if (method.equals(METHOD_PUT)) &#123;\n        doPut(req, resp);\n    &#125; else if (method.equals(METHOD_DELETE)) &#123;\n        doDelete(req, resp);\n    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;\n        doOptions(req,resp);\n    &#125; else if (method.equals(METHOD_TRACE)) &#123;\n        doTrace(req,resp);\n    &#125; else &#123;\n        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);\n        Object[] errArgs &#x3D; new Object[1];\n        errArgs[0] &#x3D; method;\n        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>JUnit TestCase：</p>\n<ol>\n<li><p>JUnit 框架也通过模板模式提供了一些功能扩展点（setUp()、tearDown() 等），让框架用户可以在这些扩展点上扩展功能。</p>\n</li>\n<li><p>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class TestCase extends Assert implements Test &#123;\n    public void runBare() throws Throwable &#123;\n        Throwable exception &#x3D; null;\n        setUp();\n        try &#123;\n            runTest();\n        &#125; catch (Throwable running) &#123;\n            exception &#x3D; running;\n        &#125; finally &#123;\n            try &#123;\n                tearDown();\n            &#125; catch (Throwable tearingDown) &#123;\n                if (exception &#x3D;&#x3D; null) exception &#x3D; tearingDown;\n            &#125;\n        &#125;\n        if (exception !&#x3D; null) throw exception;\n    &#125;\n\n    &#x2F;**\n  * Sets up the fixture, for example, open a network connection.\n  * This method is called before a test is executed.\n  *&#x2F;\n    protected void setUp() throws Exception &#123;\n    &#125;\n\n    &#x2F;**\n  * Tears down the fixture, for example, close a network connection.\n  * This method is called after a test is executed.\n  *&#x2F;\n    protected void tearDown() throws Exception &#123;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>回调（Callback）</p>\n<ol>\n<li><p>同步回调：相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ICallback &#123;\n    void methodToCallback();\n&#125;\n\npublic class BClass &#123;\n    public void process(ICallback callback) &#123;\n        &#x2F;&#x2F;...\n        callback.methodToCallback();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class AClass &#123;\n    public static void main(String[] args) &#123;\n        BClass b &#x3D; new BClass();\n        \n        &#x2F;&#x2F;使用包裹了回调函数的类对象，我们简称为回调对象\n        &#x2F;&#x2F;A实现了methodToCallback()，并且调用process()，\n        &#x2F;&#x2F;process()函数又调用了methodToCallback()\n        \n        b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象\n            @Override\n            public void methodToCallback() &#123;\n                System.out.println(&quot;Call back me.&quot;);\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>异步回调：通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p>\n</li>\n<li><p>应用一：JdbcTemplate，Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。</p>\n<ol>\n<li><p>JdbcTemlate使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdbcTemplateDemo &#123;\n    private JdbcTemplate jdbcTemplate;\n\n    public User queryUser(long id) &#123;\n        String sql &#x3D; &quot;select * from user where id&#x3D;&quot;+id;\n        return jdbcTemplate.query(sql, new UserRowMapper()).get(0);\n    &#125;\n\n    class UserRowMapper implements RowMapper&lt;User&gt; &#123;\n        public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;\n            User user &#x3D; new User();\n            user.setId(rs.getLong(&quot;id&quot;));\n            user.setName(rs.getString(&quot;name&quot;));\n            user.setTelephone(rs.getString(&quot;telephone&quot;));\n            return user;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;\n    return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));\n&#125;\n\n@Override\npublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;\n    Assert.notNull(sql, &quot;SQL must not be null&quot;);\n    Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);\n    if (logger.isDebugEnabled()) &#123;\n        logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;);\n    &#125;\n\t&#x2F;&#x2F;回调，实现了StatementCallback\n    class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;\n        @Override\n        public T doInStatement(Statement stmt) throws SQLException &#123;\n            ResultSet rs &#x3D; null;\n            try &#123;\n                rs &#x3D; stmt.executeQuery(sql);\n                ResultSet rsToUse &#x3D; rs;\n                if (nativeJdbcExtractor !&#x3D; null) &#123;\n                    rsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);\n                &#125;\n                return rse.extractData(rsToUse);\n            &#125;\n            finally &#123;\n                JdbcUtils.closeResultSet(rs);\n            &#125;\n        &#125;\n        @Override\n        public String getSql() &#123;\n            return sql;\n        &#125;\n    &#125;\n\n    return execute(new QueryStatementCallback());\n&#125;\n\n@Override\npublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;\n    Assert.notNull(action, &quot;Callback object must not be null&quot;);\n\n    Connection con &#x3D; DataSourceUtils.getConnection(getDataSource());\n    Statement stmt &#x3D; null;\n    try &#123;\n        Connection conToUse &#x3D; con;\n        if (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;\n            this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;\n            conToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);\n        &#125;\n        stmt &#x3D; conToUse.createStatement();\n        applyStatementSettings(stmt);\n        Statement stmtToUse &#x3D; stmt;\n        if (this.nativeJdbcExtractor !&#x3D; null) &#123;\n            stmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);\n        &#125;\n        T result &#x3D; action.doInStatement(stmtToUse);\n        handleWarnings(stmt);\n        return result;\n    &#125;\n    catch (SQLException ex) &#123;\n        &#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock\n        &#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.\n        JdbcUtils.closeStatement(stmt);\n        stmt &#x3D; null;\n        DataSourceUtils.releaseConnection(con, getDataSource());\n        con &#x3D; null;\n        throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);\n    &#125;\n    finally &#123;\n        JdbcUtils.closeStatement(stmt);\n        DataSourceUtils.releaseConnection(con, getDataSource());\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>应用二：setClickListner()，异步回调，往 setOnClickListener() 函数中注册好回调函数之后，并不需要等待回调函数执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Button button &#x3D; (Button)findViewById(R.id.button);\nbutton.setOnClickListener(new OnClickListener() &#123;\n    @Override\n    public void onClick(View v) &#123;\n        System.out.println(&quot;I am clicked.&quot;);\n    &#125;\n&#125;);</code></pre></li>\n<li><p>应用三：addShutdownHook，异步调用</p>\n<ol>\n<li><p>JVM的Runtime.addShutdownHook(Thread hook)，当程序关闭时，JVM会自动调用Hook代码（Callback 更侧重语法机制的描述，Hook 更加侧重应用场景的描述。）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ShutdownHookDemo &#123;\n\n    private static class ShutdownHook extends Thread &#123;\n        public void run() &#123;\n            System.out.println(&quot;I am called during shutting down.&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runtime.getRuntime().addShutdownHook(new ShutdownHook());\n    &#125;\n\n&#125;</code></pre></li>\n<li><p>当应用程序关闭的时候，JVM 会调用这个类的 runHooks() 方法，创建多个线程，并发地执行多个 Hook。我们在注册完 Hook 之后，并不需要等待 Hook 执行完成，所以，这也算是一种异步回调。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Runtime &#123;\n    public void addShutdownHook(Thread hook) &#123;\n        SecurityManager sm &#x3D; System.getSecurityManager();\n        if (sm !&#x3D; null) &#123;\n            sm.checkPermission(new RuntimePermission(&quot;shutdownHooks&quot;));\n        &#125;\n        ApplicationShutdownHooks.add(hook);\n    &#125;\n&#125;\n\nclass ApplicationShutdownHooks &#123;\n    &#x2F;* The set of registered hooks *&#x2F;\n    private static IdentityHashMap&lt;Thread, Thread&gt; hooks;\n    static &#123;\n        hooks &#x3D; new IdentityHashMap&lt;&gt;();\n    &#125; catch (IllegalStateException e) &#123;\n        hooks &#x3D; null;\n    &#125;\n\n\n    static synchronized void add(Thread hook) &#123;\n        if(hooks &#x3D;&#x3D; null)\n            throw new IllegalStateException(&quot;Shutdown in progress&quot;);\n\n        if (hook.isAlive())\n            throw new IllegalArgumentException(&quot;Hook already running&quot;);\n\n        if (hooks.containsKey(hook))\n            throw new IllegalArgumentException(&quot;Hook previously registered&quot;);\n\n        hooks.put(hook, hook);\n    &#125;\n\n    static void runHooks() &#123;\n        Collection&lt;Thread&gt; threads;\n        synchronized(ApplicationShutdownHooks.class) &#123;\n            threads &#x3D; hooks.keySet();\n            hooks &#x3D; null;\n        &#125;\n\n        for (Thread hook : threads) &#123;\n            hook.start();\n        &#125;\n        for (Thread hook : threads) &#123;\n            while (true) &#123;\n                try &#123;\n                    hook.join();\n                    break;\n                &#125; catch (InterruptedException ignored) &#123;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>模板模式VS回调，在代码实现上，回调相对于模板模式会更加灵活</p>\n<ul>\n<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-策略模式\"><a href=\"#3-策略模式\" class=\"headerlink\" title=\"3.策略模式\"></a>3.策略模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。</p></blockquote>\n<ol>\n<li><p>主要用于解耦策略的定义、创建、使用这三部分</p>\n<ol>\n<li><p>策略的定义：基于接口而非实现编程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Strategy &#123;\n    void algorithmInterface();\n&#125;\n\npublic class ConcreteStrategyA implements Strategy &#123;\n    @Override\n    public void  algorithmInterface() &#123;\n        &#x2F;&#x2F;具体的算法...\n    &#125;\n&#125;\n\npublic class ConcreteStrategyB implements Strategy &#123;\n    @Override\n    public void  algorithmInterface() &#123;\n        &#x2F;&#x2F;具体的算法...\n    &#125;\n&#125;</code></pre></li>\n<li><p>策略的创建：对客户端封装策略创建细节（策略无状态就先创建，有状态就每次返回新创建的策略对象）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;无状态\npublic class StrategyFactory &#123;\n    private static final Map&lt;String, Strategy&gt; strategies &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        strategies.put(&quot;A&quot;, new ConcreteStrategyA());\n        strategies.put(&quot;B&quot;, new ConcreteStrategyB());\n    &#125;\n\n    public static Strategy getStrategy(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n        &#125;\n        return strategies.get(type);\n    &#125;\n&#125;\n&#x2F;&#x2F;有状态\npublic class StrategyFactory &#123;\n    public static Strategy getStrategy(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n        &#125;\n\n        if (type.equals(&quot;A&quot;)) &#123;\n            return new ConcreteStrategyA();\n        &#125; else if (type.equals(&quot;B&quot;)) &#123;\n            return new ConcreteStrategyB();\n        &#125;\n\n        return null;\n    &#125;\n&#125;</code></pre></li>\n<li><p>策略的使用：运行时（配置、用户输入、计算结果等）动态确定选用哪种策略</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 策略接口：EvictionStrategy\n&#x2F;&#x2F; 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...\n&#x2F;&#x2F; 策略工厂：EvictionStrategyFactory\npublic class UserCache &#123;\n    private Map&lt;String, User&gt; cacheData &#x3D; new HashMap&lt;&gt;();\n    private EvictionStrategy eviction;\n\n    public UserCache(EvictionStrategy eviction) &#123;\n        this.eviction &#x3D; eviction;\n    &#125;\n\n    &#x2F;&#x2F;...\n&#125;\n\n&#x2F;&#x2F; 运行时动态确定，根据配置文件的配置决定使用哪种策略\npublic class Application &#123;\n    public static void main(String[] args) throws Exception &#123;\n        EvictionStrategy evictionStrategy &#x3D; null;\n        Properties props &#x3D; new Properties();\n        props.load(new FileInputStream(&quot;.&#x2F;config.properties&quot;));\n        String type &#x3D; props.getProperty(&quot;eviction_type&quot;);\n        evictionStrategy &#x3D; EvictionStrategyFactory.getEvictionStrategy(type);\n        UserCache userCache &#x3D; new UserCache(evictionStrategy);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 非运行时动态确定，在代码中指定使用哪种策略\n&#x2F;&#x2F;策略模式退化成”面向对象的多态特性”或“基于接口而非实现编程原则”\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;...\n        EvictionStrategy evictionStrategy &#x3D; new LruEvictionStrategy();\n        UserCache userCache &#x3D; new UserCache(evictionStrategy);\n        &#x2F;&#x2F;...\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>避免分支判断逻辑：借助查表法来替代分支判断</p>\n<ol>\n<li><p>重构前</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class OrderService &#123;\n    public double discount(Order order) &#123;\n        double discount &#x3D; 0.0;\n        OrderType type &#x3D; order.getType();\n        if (type.equals(OrderType.NORMAL)) &#123; &#x2F;&#x2F; 普通订单\n            &#x2F;&#x2F;...省略折扣计算算法代码\n        &#125; else if (type.equals(OrderType.GROUPON)) &#123; &#x2F;&#x2F; 团购订单\n            &#x2F;&#x2F;...省略折扣计算算法代码\n        &#125; else if (type.equals(OrderType.PROMOTION)) &#123; &#x2F;&#x2F; 促销订单\n            &#x2F;&#x2F;...省略折扣计算算法代码\n        &#125;\n        return discount;\n    &#125;\n&#125;</code></pre></li>\n<li><p>重构后</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 策略的定义\npublic interface DiscountStrategy &#123;\n    double calDiscount(Order order);\n&#125;\n&#x2F;&#x2F; 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy类代码...\n\n&#x2F;&#x2F; 策略的创建\npublic class DiscountStrategyFactory &#123;\n    private static final Map&lt;OrderType, DiscountStrategy&gt; strategies &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());\n        strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());\n        strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());\n    &#125;\n\n    public static DiscountStrategy getDiscountStrategy(OrderType type) &#123;\n        return strategies.get(type);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 策略的使用\npublic class OrderService &#123;\n    public double discount(Order order) &#123;\n        OrderType type &#x3D; order.getType();\n        DiscountStrategy discountStrategy &#x3D; DiscountStrategyFactory.getDiscountStrategy(type);\n        return discountStrategy.calDiscount(order);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>应用：实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔（文件可能很大）</p>\n<ol>\n<li><p>重构前</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n            quickSort(filePath);\n        &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n            externalSort(filePath);\n        &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n            concurrentExternalSort(filePath);\n        &#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n            mapreduceSort(filePath);\n        &#125;\n    &#125;\n\n    private void quickSort(String filePath) &#123;\n        &#x2F;&#x2F; 快速排序\n    &#125;\n\n    private void externalSort(String filePath) &#123;\n        &#x2F;&#x2F; 外部排序\n    &#125;\n\n    private void concurrentExternalSort(String filePath) &#123;\n        &#x2F;&#x2F; 多线程外部排序\n    &#125;\n\n    private void mapreduceSort(String filePath) &#123;\n        &#x2F;&#x2F; 利用MapReduce多机排序\n    &#125;\n&#125;\n\npublic class SortingTool &#123;\n    public static void main(String[] args) &#123;\n        Sorter sorter &#x3D; new Sorter();\n        sorter.sortFile(args[0]);\n    &#125;\n&#125;</code></pre></li>\n<li><p>第一次重构后：基于接口而非实现编程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ISortAlg &#123;\n    void sort(String filePath);\n&#125;\n\npublic class QuickSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class ExternalSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class ConcurrentExternalSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class MapReduceSort implements ISortAlg &#123;\n    @Override\n    public void sort(String filePath) &#123;\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        ISortAlg sortAlg;\n        if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n            sortAlg &#x3D; new QuickSort();\n        &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n            sortAlg &#x3D; new ExternalSort();\n        &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n            sortAlg &#x3D; new ConcurrentExternalSort();\n        &#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n            sortAlg &#x3D; new MapReduceSort();\n        &#125;\n        sortAlg.sort(filePath);\n    &#125;\n&#125;</code></pre></li>\n<li><p>第二次重构后：工厂模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SortAlgFactory &#123;\n    private static final Map&lt;String, ISortAlg&gt; algs &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        algs.put(&quot;QuickSort&quot;, new QuickSort());\n        algs.put(&quot;ExternalSort&quot;, new ExternalSort());\n        algs.put(&quot;ConcurrentExternalSort&quot;, new ConcurrentExternalSort());\n        algs.put(&quot;MapReduceSort&quot;, new MapReduceSort());\n    &#125;\n\n    public static ISortAlg getSortAlg(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            throw new IllegalArgumentException(&quot;type should not be empty.&quot;);\n        &#125;\n        return algs.get(type);\n    &#125;\n&#125;\n\npublic class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        ISortAlg sortAlg;\n        if (fileSize &lt; 6 * GB) &#123; &#x2F;&#x2F; [0, 6GB)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;QuickSort&quot;);\n        &#125; else if (fileSize &lt; 10 * GB) &#123; &#x2F;&#x2F; [6GB, 10GB)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;);\n        &#125; else if (fileSize &lt; 100 * GB) &#123; &#x2F;&#x2F; [10GB, 100GB)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;);\n        &#125; else &#123; &#x2F;&#x2F; [100GB, ~)\n            sortAlg &#x3D; SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;);\n        &#125;\n        sortAlg.sort(filePath);\n    &#125;\n&#125;</code></pre></li>\n<li><p>第三次重构后：用表移除分支判断</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Sorter &#123;\n    private static final long GB &#x3D; 1000 * 1000 * 1000;\n    private static final List&lt;AlgRange&gt; algs &#x3D; new ArrayList&lt;&gt;();\n    static &#123;\n        algs.add(new AlgRange(0, 6*GB, SortAlgFactory.getSortAlg(&quot;QuickSort&quot;)));\n        algs.add(new AlgRange(6*GB, 10*GB, SortAlgFactory.getSortAlg(&quot;ExternalSort&quot;)));\n        algs.add(new AlgRange(10*GB, 100*GB, SortAlgFactory.getSortAlg(&quot;ConcurrentExternalSort&quot;)));\n        algs.add(new AlgRange(100*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(&quot;MapReduceSort&quot;)));\n    &#125;\n\n    public void sortFile(String filePath) &#123;\n        &#x2F;&#x2F; 省略校验逻辑\n        File file &#x3D; new File(filePath);\n        long fileSize &#x3D; file.length();\n        ISortAlg sortAlg &#x3D; null;\n        for (AlgRange algRange : algs) &#123;\n            if (algRange.inRange(fileSize)) &#123;\n                sortAlg &#x3D; algRange.getAlg();\n                break;\n            &#125;\n        &#125;\n        sortAlg.sort(filePath);\n    &#125;\n\n    private static class AlgRange &#123;\n        private long start;\n        private long end;\n        private ISortAlg alg;\n\n        public AlgRange(long start, long end, ISortAlg alg) &#123;\n            this.start &#x3D; start;\n            this.end &#x3D; end;\n            this.alg &#x3D; alg;\n        &#125;\n\n        public ISortAlg getAlg() &#123;\n            return alg;\n        &#125;\n\n        public boolean inRange(long size) &#123;\n            return size &gt;&#x3D; start &amp;&amp; size &lt; end;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-职责链模式\"><a href=\"#4-职责链模式\" class=\"headerlink\" title=\"4.职责链模式\"></a>4.职责链模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。</p></blockquote>\n<ol>\n<li><p>实现一</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Handler &#123;\n    protected Handler successor &#x3D; null;\n\n    public void setSuccessor(Handler successor) &#123;\n        this.successor &#x3D; successor;\n    &#125;\n\n    public final void handle() &#123;\n        &#x2F;&#x2F;如果没有handled判断，则可以全部处理一遍\n        boolean handled &#x3D; doHandle();\n        if (successor !&#x3D; null &amp;&amp; !handled) &#123;\n            successor.handle();\n        &#125;\n    &#125;\n\n    protected abstract boolean doHandle();\n&#125;\n\npublic class HandlerA extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; HandlerChain和Application代码不变</code></pre></li>\n<li><p>实现二</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IHandler &#123;\n    boolean handle();\n&#125;\n\npublic class HandlerA implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerChain &#123;\n    private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();\n\n    public void addHandler(IHandler handler) &#123;\n        this.handlers.add(handler);\n    &#125;\n\n    public void handle() &#123;\n        for (IHandler handler : handlers) &#123;\n            boolean handled &#x3D; handler.handle();\n            if (handled) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        HandlerChain chain &#x3D; new HandlerChain();\n        chain.addHandler(new HandlerA());\n        chain.addHandler(new HandlerB());\n        chain.handle();\n    &#125;\n&#125;</code></pre></li>\n<li><p>应用：敏感词过滤</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface SensitiveWordFilter &#123;\n    boolean doFilter(Content content);\n&#125;\n\npublic class SexyWordFilter implements SensitiveWordFilter &#123;\n    @Override\n    public boolean doFilter(Content content) &#123;\n        boolean legal &#x3D; true;\n        &#x2F;&#x2F;...\n        return legal;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; PoliticalWordFilter、AdsWordFilter类代码结构与SexyWordFilter类似\n\npublic class SensitiveWordFilterChain &#123;\n    private List&lt;SensitiveWordFilter&gt; filters &#x3D; new ArrayList&lt;&gt;();\n\n    public void addFilter(SensitiveWordFilter filter) &#123;\n        this.filters.add(filter);\n    &#125;\n\n    &#x2F;&#x2F; return true if content doesn&#39;t contain sensitive words.\n    public boolean filter(Content content) &#123;\n        &#x2F;&#x2F;职责链\n        for (SensitiveWordFilter filter : filters) &#123;\n            if (!filter.doFilter(content)) &#123;\n                return false;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n&#125;\n\npublic class ApplicationDemo &#123;\n    public static void main(String[] args) &#123;\n        SensitiveWordFilterChain filterChain &#x3D; new SensitiveWordFilterChain();\n        filterChain.addFilter(new AdsWordFilter());\n        filterChain.addFilter(new SexyWordFilter());\n        filterChain.addFilter(new PoliticalWordFilter());\n\n        boolean legal &#x3D; filterChain.filter(new Content());\n        if (!legal) &#123;\n            &#x2F;&#x2F; 不发表\n        &#125; else &#123;\n            &#x2F;&#x2F; 发表\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>应用：过滤器、拦截器</p>\n<ol>\n<li><p>Servelt Filter：可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数</p>\n<ol>\n<li><p>使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LogFilter implements Filter &#123;\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#x2F;&#x2F; 在创建Filter时自动调用，\n    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）\n  &#125;\n\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    chain.doFilter(request, response);\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  &#125;\n\n  @Override\n  public void destroy() &#123;\n    &#x2F;&#x2F; 在销毁Filter时自动调用\n  &#125;\n&#125;\n\n&#x2F;&#x2F; 在web.xml配置文件中如下配置：\n&lt;filter&gt;\n  &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;\n  &lt;filter-class&gt;com.xzg.cd.LogFilter&lt;&#x2F;filter-class&gt;\n&lt;&#x2F;filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;logFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n&lt;&#x2F;filter-mapping&gt;</code></pre></li>\n<li><p>FilterChain处理方式（Tomcat）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class ApplicationFilterChain implements FilterChain &#123;\n    private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter\n    private int n; &#x2F;&#x2F;filter的个数\n    private ApplicationFilterConfig[] filters;\n    private Servlet servlet;\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response) &#123;\n        if (pos &lt; n) &#123;\n            ApplicationFilterConfig filterConfig &#x3D; filters[pos++];\n            Filter filter &#x3D; filterConfig.getFilter();\n            filter.doFilter(request, response, this);\n            &#x2F;&#x2F;递归调用，实现前后双向拦截\n            &#x2F;&#x2F;System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n            &#x2F;&#x2F;chain.doFilter(request, response);\n    \t\t&#x2F;&#x2F;System.out.println(&quot;拦截发送给客户端的响应.&quot;);            \n        &#125; else &#123;\n            &#x2F;&#x2F; filter都处理完毕后，执行servlet\n            servlet.service(request, response);\n        &#125;\n    &#125;\n\n    public void addFilter(ApplicationFilterConfig filterConfig) &#123;\n        for (ApplicationFilterConfig filter:filters)\n            if (filter&#x3D;&#x3D;filterConfig)\n                return;\n\n        if (n &#x3D;&#x3D; filters.length) &#123;&#x2F;&#x2F;扩容\n            ApplicationFilterConfig[] newFilters &#x3D; new ApplicationFilterConfig[n + INCREMENT];\n            System.arraycopy(filters, 0, newFilters, 0, n);\n            filters &#x3D; newFilters;\n        &#125;\n        filters[n++] &#x3D; filterConfig;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>Spring Interceptor<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/febaa9220cb9ad2f0aafd4e5c3c19868-165668658181335.jpg\" alt=\"img\"></p>\n<ol>\n<li><p>使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LogInterceptor implements HandlerInterceptor &#123;\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;\n        System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n        return true; &#x2F;&#x2F; 继续后续的处理\n    &#125;\n\n    @Override\n    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;\n        System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n    &#125;\n\n    @Override\n    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;\n        System.out.println(&quot;这里总是被执行.&quot;);\n    &#125;\n&#125;\n\n&#x2F;&#x2F;在Spring MVC配置文件中配置interceptors\n&lt;mvc:interceptors&gt;\n    &lt;mvc:interceptor&gt;\n        &lt;mvc:mapping path&#x3D;&quot;&#x2F;*&quot;&#x2F;&gt;\n            &lt;bean class&#x3D;&quot;com.xzg.cd.LogInterceptor&quot; &#x2F;&gt;\n                &lt;&#x2F;mvc:interceptor&gt;\n                    &lt;&#x2F;mvc:interceptors&gt;</code></pre></li>\n<li><p>实现：在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HandlerExecutionChain &#123;\n    private final Object handler;\n    private HandlerInterceptor[] interceptors;\n\n    public void addInterceptor(HandlerInterceptor interceptor) &#123;\n        initInterceptorList().add(interceptor);\n    &#125;\n\n    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                if (!interceptor.preHandle(request, response, this.handler)) &#123;\n                    triggerAfterCompletion(request, response, null);\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                interceptor.postHandle(request, response, this.handler, mv);\n            &#125;\n        &#125;\n    &#125;\n\n    void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)\n        throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                try &#123;\n                    interceptor.afterCompletion(request, response, this.handler, ex);\n                &#125; catch (Throwable ex2) &#123;\n                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-状态模式\"><a href=\"#5-状态模式\" class=\"headerlink\" title=\"5.状态模式\"></a>5.状态模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一般用来实现状态机，而状态机常用在游戏、工作流引擎等系统开发中</p></blockquote>\n<ol>\n<li><p>有限状态机（Finite State Machine，FSM），有三个组成部分：状态（State）、事件（Event）、动作（Action）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum State &#123;\n    SMALL(0),\n    SUPER(1),\n    FIRE(2),\n    CAPE(3);\n\n    private int value;\n\n    private State(int value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public int getValue() &#123;\n        return this.value;\n    &#125;\n&#125;\n\npublic class MarioStateMachine &#123;\n    private int score;\n    private State currentState;\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; State.SMALL;\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public void obtainCape() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public void meetMonster() &#123;\n        &#x2F;&#x2F;TODO\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState;\n    &#125;\n&#125;\n\npublic class ApplicationDemo &#123;\n    public static void main(String[] args) &#123;\n        MarioStateMachine mario &#x3D; new MarioStateMachine();\n        mario.obtainMushRoom();\n        int score &#x3D; mario.getScore();\n        State state &#x3D; mario.getCurrentState();\n        System.out.println(&quot;mario score: &quot; + score + &quot;; state: &quot; + state);\n    &#125;\n&#125;</code></pre></li>\n<li><p>状态机实现方式一：分支逻辑法，参照状态转移图，直接将每一个状态转移翻译成代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MarioStateMachine &#123;\n    private int score;\n    private State currentState;\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; State.SMALL;\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        if (currentState.equals(State.SMALL)) &#123;\n            this.currentState &#x3D; State.SUPER;\n            this.score +&#x3D; 100;\n        &#125;\n    &#125;\n\n    public void obtainCape() &#123;\n        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;\n            this.currentState &#x3D; State.CAPE;\n            this.score +&#x3D; 200;\n        &#125;\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        if (currentState.equals(State.SMALL) || currentState.equals(State.SUPER) ) &#123;\n            this.currentState &#x3D; State.FIRE;\n            this.score +&#x3D; 300;\n        &#125;\n    &#125;\n\n    public void meetMonster() &#123;\n        if (currentState.equals(State.SUPER)) &#123;\n            this.currentState &#x3D; State.SMALL;\n            this.score -&#x3D; 100;\n            return;\n        &#125;\n\n        if (currentState.equals(State.CAPE)) &#123;\n            this.currentState &#x3D; State.SMALL;\n            this.score -&#x3D; 200;\n            return;\n        &#125;\n\n        if (currentState.equals(State.FIRE)) &#123;\n            this.currentState &#x3D; State.SMALL;\n            this.score -&#x3D; 300;\n            return;\n        &#125;\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState;\n    &#125;\n&#125;</code></pre></li>\n<li><p>状态机实现方式二：查表法<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220620131509850-165668658181336.png\" alt=\"image-20220620131509850\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum Event &#123;\n    GOT_MUSHROOM(0),\n    GOT_CAPE(1),\n    GOT_FIRE(2),\n    MET_MONSTER(3);\n\n    private int value;\n\n    private Event(int value) &#123;\n        this.value &#x3D; value;\n    &#125;\n\n    public int getValue() &#123;\n        return this.value;\n    &#125;\n&#125;\n\npublic class MarioStateMachine &#123;\n    private int score;\n    private State currentState;\n\n    private static final State[][] transitionTable &#x3D; &#123;\n        &#123;SUPER, CAPE, FIRE, SMALL&#125;,\n        &#123;SUPER, CAPE, FIRE, SMALL&#125;,\n        &#123;CAPE, CAPE, CAPE, SMALL&#125;,\n        &#123;FIRE, FIRE, FIRE, SMALL&#125;\n    &#125;;\n\n    private static final int[][] actionTable &#x3D; &#123;\n        &#123;+100, +200, +300, +0&#125;,\n        &#123;+0, +200, +300, -100&#125;,\n        &#123;+0, +0, +0, -200&#125;,\n        &#123;+0, +0, +0, -300&#125;\n    &#125;;\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; State.SMALL;\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        executeEvent(Event.GOT_MUSHROOM);\n    &#125;\n\n    public void obtainCape() &#123;\n        executeEvent(Event.GOT_CAPE);\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        executeEvent(Event.GOT_FIRE);\n    &#125;\n\n    public void meetMonster() &#123;\n        executeEvent(Event.MET_MONSTER);\n    &#125;\n\n    private void executeEvent(Event event) &#123;\n        int stateValue &#x3D; currentState.getValue();\n        int eventValue &#x3D; event.getValue();\n        this.currentState &#x3D; transitionTable[stateValue][eventValue];\n        this.score +&#x3D; actionTable[stateValue][eventValue];\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState;\n    &#125;\n\n&#125;</code></pre></li>\n<li><p>状态机实现方式三：状态模式，通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;所有状态类的接口，定义了所有的事件\npublic interface IMario &#123; \n    State getName();\n    &#x2F;&#x2F;以下是定义的事件\n    void obtainMushRoom();\n    void obtainCape();\n    void obtainFireFlower();\n    void meetMonster();\n&#125;\n\npublic class SmallMario implements IMario &#123;\n    private MarioStateMachine stateMachine;\n\n    public SmallMario(MarioStateMachine stateMachine) &#123;\n        this.stateMachine &#x3D; stateMachine;\n    &#125;\n\n    @Override\n    public State getName() &#123;\n        return State.SMALL;\n    &#125;\n\n    @Override\n    public void obtainMushRoom() &#123;\n        stateMachine.setCurrentState(new SuperMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 100);\n    &#125;\n\n    @Override\n    public void obtainCape() &#123;\n        stateMachine.setCurrentState(new CapeMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 200);\n    &#125;\n\n    @Override\n    public void obtainFireFlower() &#123;\n        stateMachine.setCurrentState(new FireMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 300);\n    &#125;\n\n    @Override\n    public void meetMonster() &#123;\n        &#x2F;&#x2F; do nothing...\n    &#125;\n&#125;\n\npublic class SuperMario implements IMario &#123;\n    private MarioStateMachine stateMachine;\n\n    public SuperMario(MarioStateMachine stateMachine) &#123;\n        this.stateMachine &#x3D; stateMachine;\n    &#125;\n\n    @Override\n    public State getName() &#123;\n        return State.SUPER;\n    &#125;\n\n    @Override\n    public void obtainMushRoom() &#123;\n        &#x2F;&#x2F; do nothing...\n    &#125;\n\n    @Override\n    public void obtainCape() &#123;\n        stateMachine.setCurrentState(new CapeMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 200);\n    &#125;\n\n    @Override\n    public void obtainFireFlower() &#123;\n        stateMachine.setCurrentState(new FireMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() + 300);\n    &#125;\n\n    @Override\n    public void meetMonster() &#123;\n        stateMachine.setCurrentState(new SmallMario(stateMachine));\n        stateMachine.setScore(stateMachine.getScore() - 100);\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 省略CapeMario、FireMario类...\npublic class MarioStateMachine &#123;\n    private int score;\n    private IMario currentState; &#x2F;&#x2F; 不再使用枚举来表示状态\n\n    public MarioStateMachine() &#123;\n        this.score &#x3D; 0;\n        this.currentState &#x3D; new SmallMario(this);\n    &#125;\n\n    public void obtainMushRoom() &#123;\n        this.currentState.obtainMushRoom();\n    &#125;\n\n    public void obtainCape() &#123;\n        this.currentState.obtainCape();\n    &#125;\n\n    public void obtainFireFlower() &#123;\n        this.currentState.obtainFireFlower();\n    &#125;\n\n    public void meetMonster() &#123;\n        this.currentState.meetMonster();\n    &#125;\n\n    public int getScore() &#123;\n        return this.score;\n    &#125;\n\n    public State getCurrentState() &#123;\n        return this.currentState.getName();\n    &#125;\n\n    public void setScore(int score) &#123;\n        this.score &#x3D; score;\n    &#125;\n\n    public void setCurrentState(IMario currentState) &#123;\n        this.currentState &#x3D; currentState;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"6-迭代器（游标）模式\"><a href=\"#6-迭代器（游标）模式\" class=\"headerlink\" title=\"6.迭代器（游标）模式\"></a>6.迭代器（游标）模式</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，用来遍历容器</p></blockquote>\n<ol>\n<li><p>实现：针对继承自List接口的两个类ArrayList和LinkerList，设计实现对应的迭代器，继承自Iterator接口的ArrayIterator和ListIterator</p>\n<ol>\n<li>迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法。</li>\n<li>待遍历的容器对象通过依赖注入传递到迭代器类中。</li>\n<li>容器通过 iterator() 方法来创建迭代器。</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;接口定义\npublic interface Iterator&lt;E&gt; &#123;\n    boolean hasNext();\n    void next();\n    E currentItem();\n&#125;\npublic interface List&lt;E&gt; &#123;\n    Iterator iterator();\n    &#x2F;&#x2F;...省略其他接口函数...\n&#125;\n\npublic class ArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    private int cursor;\n    private ArrayList&lt;E&gt; arrayList;\n\n    public ArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n        this.cursor &#x3D; 0;\n        this.arrayList &#x3D; arrayList;\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        return cursor !&#x3D; arrayList.size(); &#x2F;&#x2F;注意这里，cursor在指向最后一个元素的时候，hasNext()仍旧返回true。\n    &#125;\n\n    @Override\n    public void next() &#123;\n        cursor++;\n    &#125;\n\n    @Override\n    public E currentItem() &#123;\n        if (cursor &gt;&#x3D; arrayList.size()) &#123;\n            throw new NoSuchElementException();\n        &#125;\n        return arrayList.get(cursor);\n    &#125;\n&#125;\n\npublic class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    &#x2F;&#x2F;...\n    public Iterator iterator() &#123;\n        return new ArrayIterator(this);\n    &#125;\n    &#x2F;&#x2F;...省略其他代码\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ArrayList&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n        names.add(&quot;xzg&quot;);\n        names.add(&quot;wang&quot;);\n        names.add(&quot;zheng&quot;);\n\n        &#x2F;&#x2F;Iterator&lt;String&gt; iterator &#x3D; new ArrayIterator(names);\n        Iterator&lt;String&gt; iterator &#x3D; names.iterator();\n        \n        while (iterator.hasNext()) &#123;\n            System.out.println(iterator.currentItem());\n            iterator.next();\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>优势：</p>\n<ol>\n<li>首先，对于类似数组和链表这样的数据结构，遍历方式比较简单，直接使用 for 循环来遍历就足够了。但是，对于复杂的数据结构（比如树、图）来说，<strong>有各种复杂的遍历方式</strong>。比如，树有前中后序、按层遍历，图有深度优先、广度优先遍历等等。如果由客户端代码来实现这些遍历算法，势必增加开发成本，而且容易写错。如果将这部分遍历的逻辑写到容器类中，也会导致容器类代码的复杂性。</li>\n<li>其次，将游标指向的当前位置等信息，存储在迭代器类中，每个迭代器独享游标信息。这样，我们就可以创建多个不同的迭代器，<strong>同时对同一个容器进行遍历而互不影响</strong>。</li>\n<li>最后，容器和迭代器都提供了抽象的接口，方便我们在开发的时候，<strong>基于接口而非具体的实现编程</strong>。当需要切换新的遍历算法的时候，比如，从前往后遍历链表切换成从后往前遍历链表，客户端代码只需要将迭代器类从 LinkedIterator 切换为 ReversedLinkedIterator 即可，其他代码都不需要修改。除此之外，添加新的遍历算法，我们只需要扩展新的迭代器类，也更符合开闭原则。</li>\n</ol>\n</li>\n<li><p>未决行为</p>\n<ol>\n<li><p>在遍历的同时增删集合元素</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo &#123; \n    public static void main(String[] args) &#123; \n        List names &#x3D; new ArrayList&lt;&gt;(); \n        names.add(&quot;a&quot;); \n        names.add(&quot;b&quot;); \n        names.add(&quot;c&quot;); \n        names.add(&quot;d&quot;); \n        Iterator iterator &#x3D; names.iterator(); \n        iterator.next();\n        \n        &#x2F;&#x2F;会使得元素移位，最后游标指向c而不是b\n        names.remove(&quot;a&quot;); \n        \n        &#x2F;&#x2F;也会使元素移位，\n        &#x2F;&#x2F;names.add(0, &quot;x&quot;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>如何应对：</p>\n<ol>\n<li><p>一种是遍历的时候不允许增删元素（难实现）</p>\n</li>\n<li><p>另一种是增删元素之后让遍历报错：modCount记录集合被修改的次数，</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayIterator implements Iterator &#123;\n    private int cursor;\n    private ArrayList arrayList;\n    &#x2F;&#x2F;记录遍历开始时ModCount\n    private int expectedModCount;\n\n    public ArrayIterator(ArrayList arrayList) &#123;\n        this.cursor &#x3D; 0;\n        this.arrayList &#x3D; arrayList;\n        this.expectedModCount &#x3D; arrayList.modCount;\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        checkForComodification();\n        return cursor &lt; arrayList.size();\n    &#125;\n\n    @Override\n    public void next() &#123;\n        checkForComodification();\n        cursor++;\n    &#125;\n\n    @Override\n    public Object currentItem() &#123;\n        checkForComodification();\n        return arrayList.get(cursor);\n    &#125;\n\n    private void checkForComodification() &#123;\n        if (arrayList.modCount !&#x3D; expectedModCount)\n            throw new ConcurrentModificationException();\n    &#125;\n&#125;\n\n&#x2F;&#x2F;代码示例\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        List&lt;String&gt; names &#x3D; new ArrayList&lt;&gt;();\n        names.add(&quot;a&quot;);\n        names.add(&quot;b&quot;);\n        names.add(&quot;c&quot;);\n        names.add(&quot;d&quot;);\n\n        Iterator&lt;String&gt; iterator &#x3D; names.iterator();\n        iterator.next();\n        names.remove(&quot;a&quot;);\n        iterator.next();&#x2F;&#x2F;抛出ConcurrentModificationException异常\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>遍历的同时安全地删除集合元素：Java语言的Iterator定义了一个remove()操作，安全的删除游标指向的前一个元素，而且一个next()函数之后，只能跟着最多一个remove()操作，多次调用remove()会报错</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayList&lt;E&gt; &#123;\n    transient Object[] elementData;\n    private int size;\n\n    public Iterator&lt;E&gt; iterator() &#123;\n        return new Itr();\n    &#125;\n\n    private class Itr implements Iterator&lt;E&gt; &#123;\n        int cursor;       &#x2F;&#x2F; index of next element to return\n        &#x2F;&#x2F;用来记录游标指向的前一个元素\n        int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such\n        int expectedModCount &#x3D; modCount;\n\n        Itr() &#123;&#125;\n\n        public boolean hasNext() &#123;\n            return cursor !&#x3D; size;\n        &#125;\n\n        @SuppressWarnings(&quot;unchecked&quot;)\n        public E next() &#123;\n            checkForComodification();\n            int i &#x3D; cursor;\n            if (i &gt;&#x3D; size)\n                throw new NoSuchElementException();\n            Object[] elementData &#x3D; ArrayList.this.elementData;\n            if (i &gt;&#x3D; elementData.length)\n                throw new ConcurrentModificationException();\n            cursor &#x3D; i + 1;\n            return (E) elementData[lastRet &#x3D; i];\n        &#125;\n\n        public void remove() &#123;\n            if (lastRet &lt; 0)\n                throw new IllegalStateException();\n            checkForComodification();\n\n            try &#123;\n                ArrayList.this.remove(lastRet);\n                cursor &#x3D; lastRet;\n                lastRet &#x3D; -1;\n                expectedModCount &#x3D; modCount;\n            &#125; catch (IndexOutOfBoundsException ex) &#123;\n                throw new ConcurrentModificationException();\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>应用：支持快照功能的迭代器</p>\n<ol>\n<li><p>需求</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(3);\nlist.add(8);\nlist.add(2);\n\nIterator&lt;Integer&gt; iter1 &#x3D; list.iterator();&#x2F;&#x2F;snapshot: 3, 8, 2\nlist.remove(new Integer(2));&#x2F;&#x2F;list：3, 8\nIterator&lt;Integer&gt; iter2 &#x3D; list.iterator();&#x2F;&#x2F;snapshot: 3, 8\nlist.remove(new Integer(3));&#x2F;&#x2F;list：8\nIterator&lt;Integer&gt; iter3 &#x3D; list.iterator();&#x2F;&#x2F;snapshot: 3\n\n&#x2F;&#x2F; 输出结果：3 8 2\nwhile (iter1.hasNext()) &#123;\n    System.out.print(iter1.next() + &quot; &quot;);\n&#125;\nSystem.out.println();\n\n&#x2F;&#x2F; 输出结果：3 8\nwhile (iter2.hasNext()) &#123;\n    System.out.print(iter1.next() + &quot; &quot;);\n&#125;\nSystem.out.println();\n\n&#x2F;&#x2F; 输出结果：8\nwhile (iter3.hasNext()) &#123;\n    System.out.print(iter1.next() + &quot; &quot;);\n&#125;\nSystem.out.println();</code></pre></li>\n<li><p>API总览</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    &#x2F;&#x2F; TODO: 成员变量、私有函数等随便你定义\n\n    @Override\n    public void add(E obj) &#123;\n        &#x2F;&#x2F;TODO: 由你来完善\n    &#125;\n\n    @Override\n    public void remove(E obj) &#123;\n        &#x2F;&#x2F; TODO: 由你来完善\n    &#125;\n\n    @Override\n    public Iterator&lt;E&gt; iterator() &#123;\n        return new SnapshotArrayIterator(this);\n    &#125;\n&#125;\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    &#x2F;&#x2F; TODO: 成员变量、私有函数等随便你定义\n\n    @Override\n    public boolean hasNext() &#123;\n        &#x2F;&#x2F; TODO: 由你来完善\n    &#125;\n\n    @Override\n    public E next() &#123;&#x2F;&#x2F;返回当前元素，并且游标后移一位\n        &#x2F;&#x2F; TODO: 由你来完善\n    &#125;\n&#125;</code></pre></li>\n<li><p>解决方案一：定义一个成员变量snapshot来存储快照，增加内存的消耗，但Java的拷贝是浅拷贝（只拷贝对象的引用）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    private int cursor;\n    private ArrayList&lt;E&gt; snapshot;\n\n    public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n        this.cursor &#x3D; 0;\n        this.snapshot &#x3D; new ArrayList&lt;&gt;();\n        this.snapshot.addAll(arrayList);\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        return cursor &lt; snapshot.size();\n    &#125;\n\n    @Override\n    public E next() &#123;\n        E currentItem &#x3D; snapshot.get(cursor);\n        cursor++;\n        return currentItem;\n    &#125;\n&#125;</code></pre></li>\n<li><p>解决方案二：标记删除</p>\n<ol>\n<li>在容器中，为每个元素保存两个时间戳，一个是添加时间戳 <code>addTimestamp</code>，一个是删除时间戳 <code>delTimestamp</code>。当元素被加入到集合中的时候，我们将 <code>addTimestamp</code> 设置为当前时间，将 <code>delTimestamp</code> 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将 <code>delTimestamp</code> 更新为当前时间，表示已经被删除。</li>\n<li>同时，每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足 <code>addTimestamp&lt;snapshotTimestamp&lt;delTimestamp</code>的元素才是属于这个迭代器的快照。</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ArrayList&lt;E&gt; implements List&lt;E&gt; &#123;\n    private static final int DEFAULT_CAPACITY &#x3D; 10;\n\n    private int actualSize; &#x2F;&#x2F;不包含标记删除元素\n    private int totalSize; &#x2F;&#x2F;包含标记删除元素\n\n    private Object[] elements;\n    private long[] addTimestamps;\n    private long[] delTimestamps;\n\n    public ArrayList() &#123;\n        this.elements &#x3D; new Object[DEFAULT_CAPACITY];\n        this.addTimestamps &#x3D; new long[DEFAULT_CAPACITY];\n        this.delTimestamps &#x3D; new long[DEFAULT_CAPACITY];\n        this.totalSize &#x3D; 0;\n        this.actualSize &#x3D; 0;\n    &#125;\n\n    @Override\n    public void add(E obj) &#123;\n        elements[totalSize] &#x3D; obj;\n        addTimestamps[totalSize] &#x3D; System.currentTimeMillis();\n        delTimestamps[totalSize] &#x3D; Long.MAX_VALUE;\n        totalSize++;\n        actualSize++;\n    &#125;\n\n    @Override\n    public void remove(E obj) &#123;\n        for (int i &#x3D; 0; i &lt; totalSize; ++i) &#123;\n            if (elements[i].equals(obj)) &#123;\n                delTimestamps[i] &#x3D; System.currentTimeMillis();\n                actualSize--;\n            &#125;\n        &#125;\n    &#125;\n\n    public int actualSize() &#123;\n        return this.actualSize;\n    &#125;\n\n    public int totalSize() &#123;\n        return this.totalSize;\n    &#125;\n\n    public E get(int i) &#123;\n        if (i &gt;&#x3D; totalSize) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return (E)elements[i];\n    &#125;\n\n    public long getAddTimestamp(int i) &#123;\n        if (i &gt;&#x3D; totalSize) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return addTimestamps[i];\n    &#125;\n\n    public long getDelTimestamp(int i) &#123;\n        if (i &gt;&#x3D; totalSize) &#123;\n            throw new IndexOutOfBoundsException();\n        &#125;\n        return delTimestamps[i];\n    &#125;\n&#125;\n\npublic class SnapshotArrayIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;\n    private long snapshotTimestamp;\n    private int cursorInAll; &#x2F;&#x2F; 在整个容器中的下标，而非快照中的下标\n    private int leftCount; &#x2F;&#x2F; 快照中还有几个元素未被遍历\n    private ArrayList&lt;E&gt; arrayList;\n\n    public SnapshotArrayIterator(ArrayList&lt;E&gt; arrayList) &#123;\n        this.snapshotTimestamp &#x3D; System.currentTimeMillis();\n        this.cursorInAll &#x3D; 0;\n        this.leftCount &#x3D; arrayList.actualSize();;\n        this.arrayList &#x3D; arrayList;\n\n        justNext(); &#x2F;&#x2F; 先跳到这个迭代器快照的第一个元素\n    &#125;\n\n    @Override\n    public boolean hasNext() &#123;\n        return this.leftCount &gt;&#x3D; 0; &#x2F;&#x2F; 注意是&gt;&#x3D;, 而非&gt;\n    &#125;\n\n    @Override\n    public E next() &#123;\n        E currentItem &#x3D; arrayList.get(cursorInAll);\n        justNext();\n        return currentItem;\n    &#125;\n\n    private void justNext() &#123;\n        while (cursorInAll &lt; arrayList.totalSize()) &#123;\n            long addTimestamp &#x3D; arrayList.getAddTimestamp(cursorInAll);\n            long delTimestamp &#x3D; arrayList.getDelTimestamp(cursorInAll);\n            if (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) &#123;\n                leftCount--;\n                break;\n            &#125;\n            cursorInAll++;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"7-访问者模式\"><a href=\"#7-访问者模式\" class=\"headerlink\" title=\"7.访问者模式\"></a>7.<del>访问者模式</del></h4><ol>\n<li>访问者模式访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。</li>\n<li>对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。除此之外，我们还讲到 Double Disptach。如果某种语言支持 Double Dispatch，那就不需要访问者模式了。</li>\n<li>正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。</li>\n</ol>\n<h4 id=\"8-备忘录模式\"><a href=\"#8-备忘录模式\" class=\"headerlink\" title=\"8.备忘录模式\"></a>8.<del>备忘录模式</del></h4><ol>\n<li>备忘录模式备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。</li>\n<li>备忘录模式的应用场景也比较明确和有限，主要用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。</li>\n<li>对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。</li>\n</ol>\n<h4 id=\"9-命令模式\"><a href=\"#9-命令模式\" class=\"headerlink\" title=\"9.命令模式\"></a>9.<del>命令模式</del></h4><ol>\n<li>命令模式命令模式在平时工作中并不常用，你稍微了解一下就可以。</li>\n<li>落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。</li>\n<li>命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等，这才是命令模式能发挥独一无二作用的地方。</li>\n</ol>\n<h4 id=\"10-解释器模式\"><a href=\"#10-解释器模式\" class=\"headerlink\" title=\"10.解释器模式\"></a>10.<del>解释器模式</del></h4><ol>\n<li>解释器模式解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。</li>\n<li>要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。</li>\n<li>解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</li>\n</ol>\n<h4 id=\"11-中介模式\"><a href=\"#11-中介模式\" class=\"headerlink\" title=\"11.中介模式\"></a>11.<del>中介模式</del></h4><ol>\n<li>中介模式中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</li>\n<li>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。</li>\n</ol>\n<h1 id=\"Distributed-System\"><a href=\"#Distributed-System\" class=\"headerlink\" title=\"Distributed System\"></a>Distributed System</h1><h2 id=\"1-分布式系统概述\"><a href=\"#1-分布式系统概述\" class=\"headerlink\" title=\"1.分布式系统概述\"></a>1.分布式系统概述</h2><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221208165538910.png\" alt=\"image-20221208165538910\"></p>\n<h3 id=\"1-分布式协调与同步\"><a href=\"#1-分布式协调与同步\" class=\"headerlink\" title=\"1.分布式协调与同步\"></a>1.分布式协调与同步</h3><h4 id=\"1-分布式互斥：排他性的资源访问方式\"><a href=\"#1-分布式互斥：排他性的资源访问方式\" class=\"headerlink\" title=\"1.分布式互斥：排他性的资源访问方式\"></a>1.分布式互斥：排他性的资源访问方式</h4><ol>\n<li>集中式算法：有一个协调者来约束大家按顺序使用排他性资源</li>\n<li>分布式算法：先征求其他人的意见，其他人都不同的时候可以使用</li>\n<li>令牌环算法：组成令牌环结构，拿到令牌的可以访问临界资源</li>\n<li>两层结构分布式令牌环：例如广域网一个令牌环，每个局域网内还有一个令牌环</li>\n</ol>\n<h4 id=\"2-分布式选举：选出集群的主节点\"><a href=\"#2-分布式选举：选出集群的主节点\" class=\"headerlink\" title=\"2.分布式选举：选出集群的主节点\"></a>2.分布式选举：选出集群的主节点</h4><ol>\n<li>Bully算法：<ol>\n<li>在所有活着的节点中，选取ID最大的节点作为主节点</li>\n<li>选举过程<ol>\n<li>集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息（竞选成功），宣誓自己的主权；</li>\n<li>如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送 Election 消息（用于发起选举），并等待其他节点的回复；若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息（应答Election消息），则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；</li>\n<li>若接收到来自比自己 ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；</li>\n<li>若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。</li>\n</ol>\n</li>\n<li>应用：MongoDB的副本集故障转移功能，MongoDB 的分布式选举中，采用节点的最后操作时间戳来表示 ID，时间戳最新的节点其 ID 最大，也就是说时间戳最新的、活着的节点是主节点。</li>\n</ol>\n</li>\n<li>Raft算法：<ol>\n<li>少数服从多数，获得投票最多的节点成为主节点</li>\n<li>选举过程<ol>\n<li>初始化时，所有节点均为 Follower 状态（Leader的跟随着）。</li>\n<li>开始选主时，所有节点的状态由 Follower 转化为 Candidate（候选者，可以被选为新Leader），并向其他节点发送选举请求。</li>\n<li>其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的是，在每一轮选举中，一个节点只能投出一张票。</li>\n<li>若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader（主节点）其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。</li>\n<li>当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。</li>\n</ol>\n</li>\n<li>应用：Google 开源的 Kubernetes，擅长容器管理与调度，为了保证可靠性，通常会部署 3 个节点用于数据备份。这 3 个节点中，有一个会被选为主，其他节点作为备。Kubernetes 的选主采用的是开源的 etcd 组件。而，etcd 的集群管理器 etcds，是一个高可用、强一致性的服务发现存储仓库，就是采用了 Raft 算法来实现选主和一致性的。</li>\n</ol>\n</li>\n<li>ZAB算法：<ol>\n<li>Zookeeper实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。</li>\n<li>选举基础<ol>\n<li>节点的三种角色：Leader，主节点；Follower，跟随者节点；Observer，观察者，无投票权。</li>\n<li>节点的四个状态：<ul>\n<li>Looking 状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。</li>\n<li>Leading 状态，即领导者状态，表示已经选出主，且当前节点为 Leader。</li>\n<li>Following 状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为 Following，表示对 Leader 的追随。</li>\n<li>Observing 状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。</li>\n</ul>\n</li>\n<li>每个节点都有唯一的三元组：<code>(server_id, server_zxID, epoch)</code>，其中 server_id 表示本节点的唯一 ID；server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大；epoch 表示当前选取轮数，一般用逻辑时钟表示。</li>\n</ol>\n</li>\n<li>选举过程（3个Server的集群）：==server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader。==<ol>\n<li>第一步：当系统刚启动时，3 个服务器当前投票均为第一轮投票，即 epoch=1，且 zxID 均为 0。此时每个服务器都推选自己，并将选票信息<code>&lt;epoch, vote_id, vote_zxID&gt;</code> 广播出去。</li>\n<li>第二步：根据判断规则，由于 3 个 Server 的 epoch、zxID 都相同，因此比较 server_id，较大者即为推选对象，因此 Server 1 和 Server 2 将 vote_id 改为 3，更新自己的投票箱并重新广播自己的投票。</li>\n<li>第三步：此时系统内所有服务器都推选了 Server 3，因此 Server 3 当选 Leader，处于 Leading 状态，向其他服务器发送心跳包并维护连接；Server1 和 Server2 处于 Following 状态。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-分布式共识：存异求同\"><a href=\"#3-分布式共识：存异求同\" class=\"headerlink\" title=\"3.分布式共识：存异求同\"></a>3.分布式共识：存异求同</h4><ol>\n<li>多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程</li>\n<li>PoW（Proof-of-Work，工作量证明，区块链）：以每个节点或服务器的计算能力（即“算力”）来竞争记账权的机制，因此是一种使用工作量证明机制的共识算法。也就是说，谁的计算力强、工作能力强，谁获得记账权的可能性就越大。</li>\n<li>PoS（Proof-of-Stake，权益证明，以太坊）：由系统权益（每个节点占有货币的数量和时间）代替算力来决定区块记账权，拥有的权益越大获得记账权的概率就越大</li>\n<li>DPoS（Delegated Proof of Stake，委托权益证明，比特股和Steem）：类似股份制公司的董事会制度，普通股民虽然拥有股权，但进不了董事会，他们可以投票选举代表（受托人）代他们做决策。DPoS 是由被社区选举的可信帐户（受托人，比如得票数排行前 101 位）来拥有记账权</li>\n</ol>\n<h4 id=\"4-分布式事务：\"><a href=\"#4-分布式事务：\" class=\"headerlink\" title=\"4.分布式事务：\"></a>4.分布式事务：</h4><ol>\n<li>就是在分布式系统中运行的事务，由多个本地事务组合而成</li>\n<li>ACID理论和BASE理论</li>\n<li>基于XA协议的二阶段提交协议方法（ACID）<ol>\n<li>XA是一个分布式事务协议，规定了事务管理器和资源管理器接口。事务管理器相当于协调者，负责各个本地资源的提交和回滚；而资源管理器就是分布式事务的参与者，通常由数据库实现，比如 Oracle、DB2 等商业数据库都实现了 XA 接口</li>\n<li>基于 XA 协议的二阶段提交方法中，二阶段提交协议（Two-phase Commit Protocol，2PC），用于保证分布式系统中事务提交时的数据一致性，是 XA 在全局事务中用于协调多个资源的机制。执行过程如下：<ol>\n<li>投票（Voting）：在这一阶段，协调者（Coordinator，即事务管理器）会向事务的参与者（Cohort，即本地资源管理器）发起执行操作的 CanCommit 请求，并等待参与者的响应。参与者接收到请求后，会执行请求中的事务操作，将操作信息记录到事务日志中但不提交（即不会修改数据库中的数据），待参与者执行成功，则向协调者发送“Yes”消息，表示同意操作；若不成功，则发送“No”消息，表示终止操作。</li>\n<li>提交（Commit）：当所有的参与者都返回了操作结果后，系统进入了第二阶段提交阶段。在提交阶段，协调者会根据所有参与者返回的信息向参与者发送 DoCommit（提交）或 DoAbort（取消）指令。具体规则如下：<ul>\n<li>若协调者从参与者那里收到的都是“Yes”消息，则向参与者发送“DoCommit”消息。参与者收到“DoCommit”消息后，完成剩余的操作（比如修改数据库中的数据）并释放资源（整个事务过程中占用的资源），然后向协调者返回“HaveCommitted”消息；</li>\n<li>若协调者从参与者收到的消息中包含“No”消息，则向所有参与者发送“DoAbort”消息。此时投票阶段发送“Yes”消息的参与者，则会根据之前执行操作时的事务日志对操作进行回滚，就好像没有执行过请求操作一样，然后所有参与者会向协调者发送“HaveCommitted”消息；</li>\n<li>协调者接收到来自所有参与者的“HaveCommitted”消息后，就意味着整个事务结束了。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>三阶段提交协议方法（ACID）<ol>\n<li>为了更好地处理两阶段提交的同步阻塞和数据不一致问题，三阶段提交引入了超时机制和准备阶段。</li>\n<li>提交过程<ol>\n<li>第一，CanCommit 阶段。协调者向参与者发送请求操作（CanCommit 请求），询问参与者是否可以执行事务提交操作，然后等待参与者的响应；参与者收到 CanCommit 请求之后，回复 Yes，表示可以顺利执行事务；否则回复 No。</li>\n<li>第二，PreCommit 阶段。<ol>\n<li>如果所有参与者回复的都是“Yes”，那么协调者就会执行事务的预执行：协调者向参与者发送 PreCommit 请求，进入预提交阶段。参与者接收到 PreCommit 请求后执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中。如果参与者成功执行了事务操作，则返回 ACK 响应，同时开始等待最终指令。</li>\n<li>假如任何一个参与者向协调者发送了“No”消息，或者等待超时之后，协调者都没有收到参与者的响应，就执行中断事务的操作：协调者向所有参与者发送“Abort”消息。参与者收到“Abort”消息之后，或超时后仍未收到协调者的消息，执行事务的中断操作。</li>\n</ol>\n</li>\n<li>第三，DoCommit 阶段。<ol>\n<li>执行提交阶段：若协调者接收到所有参与者发送的 Ack 响应，则向所有参与者发送 DoCommit 消息，开始执行阶段。参与者接收到 DoCommit 消息之后，正式提交事务。完成事务提交之后，释放所有锁住的资源，并向协调者发送 Ack 响应。协调者接收到所有参与者的 Ack 响应之后，完成事务。</li>\n<li>事务中断阶段：协调者向所有参与者发送 Abort 请求。参与者接收到 Abort 消息之后，利用其在 PreCommit 阶段记录的 Undo 信息执行事务的回滚操作，释放所有锁住的资源，并向协调者发送 Ack 消息。协调者接收到参与者反馈的 Ack 消息之后，执行事务的中断，并结束事务。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>基于分布式消息的最终一致性方法（BASE）<ol>\n<li>将事务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件，数据库或消息队列中，再通过业务规划进行失败重试。</li>\n<li>采用消息传递机制，并使用异步通信的方式，避免了通信阻塞，从而增加系统的吞吐量。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-分布式锁：\"><a href=\"#5-分布式锁：\" class=\"headerlink\" title=\"5.分布式锁：\"></a>5.分布式锁：</h4><ol>\n<li>与普通锁不同的是，分布式锁是指分布式环境下，系统部署在多个机器中，实现多进程分布式互斥的一种锁。为了保证多个进程能看到锁，锁被存在公共存储（比如 Redis、Memcached、数据库等三方存储中），以实现多个进程并发访问同一个临界资源，同一时刻只有一个进程可访问共享资源，确保数据的一致性。</li>\n<li>基于关系型数据库实现分布式锁：首先创建一张表用于记录共享资源信息，然后通过操作该表的数据来实现共享资源信息的修改。当我们要锁住某个资源时，就在该表中增加一条记录，想要释放锁的时候就删除这条记录。数据库对共享资源做了唯一性约束，如果有多个请求被同时提交到数据库的话，数据库会保证只有一个操作可以成功，操作成功的那个线程就获得了访问共享资源的锁，可以进行操作。</li>\n<li>基于缓存实现分布式锁；<ol>\n<li>基于缓存，也就是说把数据存放在计算机内存中，不需要写入磁盘，减少了 IO 读写</li>\n<li>Redis 通常可以使用 setnx(key, value) 函数来实现分布式锁。key 和 value 就是基于缓存的分布式锁的两个属性，其中 key 表示锁 id，value = currentTime + timeOut，表示当前时间 + 超时时间。也就是说，某个进程获得 key 这把锁后，如果在 value 的时间内未释放锁，系统就会主动释放锁。setnx 函数的返回值有 0 和 1：<ol>\n<li>返回 1，说明该服务器获得锁，setnx 将 key 对应的 value 设置为当前时间 + 锁的有效时间。</li>\n<li>返回 0，说明其他服务器已经获得了锁，进程不能进入临界区。该服务器可以不断尝试 setnx 操作，以获得锁。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>基于 ZooKeeper 实现分布式锁<ol>\n<li>ZooKeeper 基于树形数据存储结构实现分布式锁，来解决多个进程同时访问同一临界资源时，数据的一致性问题。ZooKeeper 的树形数据存储结构主要由 4 种节点构成：<ul>\n<li>持久节点（PERSISTENT）。这是默认的节点类型，一直存在于 ZooKeeper 中。</li>\n<li>持久顺序节点（PERSISTENT_SEQUENTIAL）。在创建节点时，ZooKeeper 根据节点创建的时间顺序对节点进行编号命名。</li>\n<li>临时节点（EPHEMERAL）。当客户端与 Zookeeper 连接时临时创建的节点。与持久节点不同，当客户端与 ZooKeeper 断开连接后，该进程创建的临时节点就会被删除。</li>\n<li>临时顺序节点（EPHEMERAL_SEQUENTIAL）。就是按时间顺序编号的临时节点。</li>\n</ul>\n</li>\n<li>举例：以电商售卖吹风机的场景为例。假设用户 A、B、C 同时在 11 月 11 日的零点整提交了购买吹风机的请求，ZooKeeper 会采用如下方法来实现分布式锁：<ol>\n<li>在与该方法对应的持久节点 shared_lock 的目录下，为每个进程创建一个临时顺序节点。吹风机就是一个拥有 shared_lock 的目录，当有人买吹风机时，会为他创建一个临时顺序节点。</li>\n<li>每个进程获取 shared_lock 目录下的所有临时节点列表，注册 Watcher，用于监听子节点变更的信息。当监听到自己的临时节点是顺序最小的，则可以使用共享资源。</li>\n<li>每个节点确定自己的编号是否是 shared_lock 下所有子节点中最小的，若最小，则获得锁。例如，用户 A 的订单最先到服务器，因此创建了编号为 1 的临时顺序节点 LockNode1。该节点的编号是持久节点目录下最小的，因此获取到分布式锁，可以访问临界资源，从而可以购买吹风机。若本进程对应的临时节点编号不是最小的，则分为两种情况：<ol>\n<li>本进程为读请求，如果比自己序号小的节点中有写请求，则等待；</li>\n<li>本进程为写请求，如果比自己序号小的节点中有请求，则等待。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-分布式资源管理与负载调度\"><a href=\"#2-分布式资源管理与负载调度\" class=\"headerlink\" title=\"2.分布式资源管理与负载调度\"></a>2.分布式资源管理与负载调度</h3><h4 id=\"1-集中式结构（Master-Slave架构）\"><a href=\"#1-集中式结构（Master-Slave架构）\" class=\"headerlink\" title=\"1.集中式结构（Master/Slave架构）\"></a>1.集中式结构（Master/Slave架构）</h4><ol>\n<li>集中式结构就是，由一台或多台服务器组成中央服务器，系统内的所有数据都存储在中央服务器中，系统内所有的业务也均先由中央服务器处理。多个节点服务器与中央服务器连接，并将自己的信息汇报给中央服务器，由中央服务器统一进行资源和任务调度：中央服务器根据这些信息，将任务下达给节点服务器；节点服务器执行任务，并将结果反馈给中央服务器。</li>\n<li>Google Borg<ol>\n<li>Borg是Google 内部使用的集群管理系统，采用了典型的集中式结构，负责提交、调度、开始、重启和管理 Google 运行在其上的所有应用</li>\n<li>在 Borg 中，一个集群称为一个 Cell，每个 Cell 里面有一个 Leader，称为 BorgMaster，即为中央服务器；其他服务器为节点服务器或从服务器，被称为 Borglet。<ol>\n<li>BorgMaster：它由两个进程组成，一个是 Borgmaster 主进程，一个是独立的 scheduler 进程：<ol>\n<li>主进程处理客户端的 RPC 请求，比如任务的执行状态更新或者查询等；同时，管理系统中所有实体的状态（比如，服务器、任务等），并负责和 Borglet 通信。</li>\n<li>scheduler 进程负责任务调度，通过任务对资源的需求以及当前 Borglet 所在服务器的资源情况进行匹配，为任务寻找一个合适的节点服务器执行。</li>\n</ol>\n</li>\n<li>Borglet：它是运行在每个节点机器的一个 agent，负责任务的拉起、停止、重启等，并管理和收集本服务器资源，将任务的状态、服务器状态等信息上报给 BorgMaster。而 BorgMaster 会周期性地轮询每个 Borglet，以获取节点服务器的状态和资源信息等。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Kubernetes<ol>\n<li>Kubernetes 是 Google 开源的容器集群管理系统，是 Borg 的一个开源版本。Kubernetes 是用于自动部署、扩展和管理容器化应用程序的开源系统。其核心是，在集群的节点上运行容器化应用，可以进行自动化容器操作，包括部署、调度和在节点间弹性伸缩等。</li>\n<li>Kubernetes 也是典型的集中式结构，一个 Kubernetes 集群，主要由 Master 节点和 Worker 节点组成，以及客户端命令行工具 kubectl 和其他附加项。<ol>\n<li>Master 节点。它运行在中心服务器上，Master 节点由 API Server、Scheduler、Cluster State Store 和 Control Manger Server 组成，负责对集群进行调度管理。<ul>\n<li>API Server：是所有 REST 命令的入口，负责处理 REST 的操作，确保它们生效，并执行相关业务逻辑。</li>\n<li>Scheduler：根据容器需要的资源以及当前 Worker 节点所在节点服务器的资源信息，自动为容器选择合适的节点服务器。</li>\n<li>Cluster State Store：集群状态存储，默认采用 etcd，etcd 是一个分布式 key-value 存储，主要用来做共享配置和服务发现。</li>\n<li>Control Manager：负责整个集群的编排管理。它监视集群中节点的离开和加入，将集群的当前状态与 etcd 中存储的所需状态进行核对。比方说，当某个节点发生故障，它会在其它节点上增加新的 Pod 以匹配所需的副本数。</li>\n</ul>\n</li>\n<li>Worker 节点。它作为真正的工作节点，运行在从节点服务器，包括 kubelet 和 kube-proxy 核心组件，负责运行业务应用的容器。<ol>\n<li>kubelet：用于通过命令行与 API Server 进行交互，根据接收到的请求对 Worker 节点进行操作。也就是说，通过与 API Server 进行通信，接收 Master 节点根据调度策略发出的请求或命令，在 Worker 节点上管控容器（Pod），并管控容器的运行状态（比如，重新启动出现故障的 Pod）等。Pod 是 Kubernetes 的最小工作单元，每个 Pod 包含一个或多个容器。</li>\n<li>kube-proxy：负责为容器（Pod）创建网络代理 / 负载平衡服务，从 API Server 获取所有 Server 信息，并根据 Server 信息创建代理服务，这种代理服务称之为 Service。Kube-proxy 主要负责管理 Service 的访问入口，即实现集群内的 Pod 客户端访问 Service，或者是集群外访问 Service，具有相同服务的一组 Pod 可抽象为一个 Service。每个 Service 都有一个虚拟 IP 地址（VIP）和端口号供客户端访问。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Apache Mesos<ol>\n<li>Apache 旗下的开源分布式资源管理框架 Mesos被称为是分布式系统的内核，最初由加州大学伯克利分校的 AMPLab 开发，后在 Twitter 得到广泛使用。Mesos 只负责底层资源的管理和分配，并不涉及存储、任务调度等功能，因此 Mesos Master 对接的是 Spark、Hadoop、Marathon 等框架，用户的任务需要提交到这些框架上。也正因为此，Mesos 的任务调度框架是双层结构。</li>\n<li>在 Mesos 中，一个集群包括 Mesos Master 和多个 Mesos Agent。其中，Mesos Master 运行在中央服务器，Mesos Agent 运行在节点服务器上。<ol>\n<li>Mesos Master 负责收集和管理所有 Agent 所在服务器的资源和状态，并且对接 Spark、Hadoop 等框架，将集群中服务器的资源信息告知给这些框架，以便这些框架进行任务资源匹配和调度。</li>\n<li>Mesos Agent 负责任务的拉起、停止、重启等，并负责收集所在服务器的资源 (比如 CPU、内存等) 信息和状态，上报给 Mesos Master。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-非集中式结构（分布式架构）\"><a href=\"#2-非集中式结构（分布式架构）\" class=\"headerlink\" title=\"2.非集中式结构（分布式架构）\"></a>2.非集中式结构（分布式架构）</h4><ol>\n<li>Akka集群（JVM使用了）<ol>\n<li>Akka 是一个开发库和运行环境，用于构建可扩展的、弹性的、快速响应的应用程序。Akka 框架是基于 Actor 模型实现的，采用了Gossip协议</li>\n<li>Akka 集群的两个重点是数据传输和集群组建及管理<ol>\n<li>在 Akka 集群中，节点是对等的，也就是说每个节点是可以并发处理的，因此必然存在数据传输和一致性的问题。Akka 集群主要采用的是谁的时间戳最新（也就是数据最新），就以谁为准的原则。</li>\n<li>集群创建<ol>\n<li>如果本节点为首种子节点，则把自己加入到集群列表中，即以自己为中心构建集群；</li>\n<li>如果本节点为种子节点，则向首种子节点请求加入集群，当首种子节点回复同意消息后，可以加入集群，否则不可加入集群；</li>\n<li>如果本节点为普通节点，则可以向任一种子节点（包括首种子节点）请求加入集群，收到同意后，则加入集群，否则不可加入集群。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Redis集群<ol>\n<li>Redis 是一个开源的、包含多种数据结构的高性能 Key-value 数据库</li>\n<li>Redis 集群中不存在中央节点，是典型的去中心化结构，每个节点均可与其他节点通信。所有节点均可负责存储数据、记录集群的状态（包括键值到正确节点的映射），客户端可以访问或连接到任一节点上。</li>\n</ol>\n</li>\n<li>Cassandra集群<ol>\n<li>Cassandra 集群的系统架构是基于一致性哈希的完全 P2P 结构，没有 Master 的概念，所有节点都是同样的角色，彻底避免了因为单点问题导致的系统不稳定。Cassandra 集群节点间的状态同步，也是通过 Gossip 协议来进行 P2P 通信的。</li>\n<li>在 Cassandra 集群中，每次客户端可以向集群中的任意一个节点请求数据，接收到请求的节点将 key 值进行哈希操作，找出在一致性哈希环上是哪些节点应该存储这个数据，然后将请求转发到相应节点上，并将查询结果反馈返回给客户端。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-单体调度\"><a href=\"#3-单体调度\" class=\"headerlink\" title=\"3.单体调度\"></a>3.单体调度</h4><ol>\n<li>分布式系统中的单体调度是指，一个集群中只有一个节点运行调度进程，该节点对集群中的其他节点具有访问权限，可以对其他节点的资源信息、节点状态等进行统一管理，同时根据用户下发的任务对资源的需求，在调度器中进行任务与资源匹配，然后根据匹配结果将任务指派给合适的节点。单体调度器拥有全局资源视图和全局任务，可以很容易地实现对任务的约束并实施全局性的调度策略。</li>\n<li>Borg调度设计：Scheduler组件，Scheduler 负责任务的调度，当用户提交一个作业给 BorgMaster 后，BorgMaster 会把该作业保存到 Paxos 仓库中，并将这个作业的所有任务加入等待队列中。调度器扫描任务等待队列，根据预定义的调度算法，将队列中的任务分配到满足作业需求且有足够资源的计算节点上。</li>\n<li>Borg调度算法：<ol>\n<li>可行性检查：找到一组可以运行任务的机器</li>\n<li>评分：从可行的机器中选择一个合适的机器，其中常见的评分算法包括最差匹配（尽可能平均分配）和最佳匹配（尽可能塞满每一个）</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-两层调度\"><a href=\"#4-两层调度\" class=\"headerlink\" title=\"4.两层调度\"></a>4.两层调度</h4><ol>\n<li>为了提升调度效率并支持多种类型的任务，把资源和任务分开调度，也就是说一层调度器只负责资源管理和分配，另外一层调度器负责任务与资源的匹配呢。</li>\n<li>两层调度结构对应的就是两层调度器，资源的使用状态同时由中央调度器和第二层调度器管理，中央调度器从整体上进行资源的管理与分配，将资源分配到第二层调度器；再由第二层调度器负责将资源与具体的任务配对，因此第二层调度可以有多个调度器，以支持不同的任务类型。</li>\n<li><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220624211133674.png\" alt=\"image-20220624211133674\"></li>\n</ol>\n<h4 id=\"5-共享状态调度\"><a href=\"#5-共享状态调度\" class=\"headerlink\" title=\"5.共享状态调度\"></a>5.共享状态调度</h4><ol>\n<li>沿袭了单体调度器的模式，通过将单体调度器分解为多个调度器，每个调度器都有全局的资源状态信息，从而实现最优的任务调度，提供了更好的可扩展性。也就是说，这种调度架构在支持多种任务类型的同时，还能拥有全局的资源状态信息。要做到这一点，这种调度架构的多个调度器需要共享集群状态，包括资源状态和任务状态等。</li>\n<li><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220624211446579.png\" alt=\"image-20220624211446579\"></li>\n</ol>\n<h3 id=\"3-分布式计算技术\"><a href=\"#3-分布式计算技术\" class=\"headerlink\" title=\"3.分布式计算技术\"></a>3.分布式计算技术</h3><h4 id=\"1-MapReduce\"><a href=\"#1-MapReduce\" class=\"headerlink\" title=\"1.MapReduce\"></a>1.MapReduce</h4><ol>\n<li>抽象模型：MapReduce 分为 Map 和 Reduce 两个核心阶段，其中 Map 对应“分”，即把复杂的任务分解为若干个“简单的任务”执行；Reduce 对应着“合”，即对 Map 阶段的结果进行汇总</li>\n</ol>\n<h4 id=\"2-Stream\"><a href=\"#2-Stream\" class=\"headerlink\" title=\"2.Stream\"></a>2.Stream</h4><ol>\n<li>流计算强调的是实时性，数据一旦产生就会被立即处理，当一条数据被处理完成后，会序列化存储到缓存中，然后立刻通过网络传输到下一个节点，由下一个节点继续处理，而不是像 MapReduce 那样，等到缓存写满才开始处理、传输。为了保证数据的实时性，在流计算中，不会存储任何数据，就像水流一样滚滚向前。</li>\n<li>处理流程<ol>\n<li>提交流式计算作业：流式计算作业是一种常驻计算服务（如天气预报），预先定义计算逻辑，并提交到流计算系统中，系统在整个运行期间处理逻辑不可更改，数据不存储。</li>\n<li>加载流式数据进行流计算：一旦启动将一直处于等待事件触发的状态，一旦有小批量数据进入流式数据存储，系统会立刻执行计算逻辑并迅速得到结果</li>\n<li>持续输出计算结果：在得到小批量计算结果后，立刻将结果数据写入在线/批量系统，无需等待整体数据的计算结果</li>\n</ol>\n</li>\n<li>Storm<ol>\n<li>Storm集群上有两种节点，主节点和工作节点<ol>\n<li>Nimbus 是整个 Storm 集群的主守护进程，以唯一实例的方式运行在主节点上。它负责把任务分配和分发给集群的工作节点，并监控这些任务的执行情况。当某个节点故障时，它会重新分配该故障节点上的任务到其它节点。</li>\n<li>Supervisor 是 Storm 集群里工作守护进程，每个工作节点都存在一个这样的实例。它通过 Zookeeper 与 Nimbus 守护进程进行通信。在接受到 Nimbus 分配的任务后，它会为每个任务启动单独的工作进程。</li>\n</ol>\n</li>\n<li>Storm 为进行数据流（数据流是一个无界序列，是在分布式环境中并行创建、处理的一组元组）转换提供了基本组件 Spout 和 Bolt。 Spout 和 Bolt 有用户自定义的接口，用于运行特定应用程序的逻辑。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-Actor\"><a href=\"#3-Actor\" class=\"headerlink\" title=\"3.Actor\"></a>3.Actor</h4><ol>\n<li>Actor 类似于一个“黑盒”对象，封装了自己的状态和行为，使得其他 Actor 无法直接观察到它的状态，调用它的行为。多个 Actor 之间通过消息进行通信，这种消息类似于电子邮箱中的邮件。Actor 接收到消息之后，才会根据消息去执行计算操作</li>\n<li>Actor模型的三要素是状态、行为和消息<ol>\n<li>状态（State）。Actor 的状态指的是，Actor 组件本身的信息，相当于 OOP 对象中的属性。Actor 的状态会受 Actor 自身行为的影响，且只能被自己修改。</li>\n<li>行为（Behavior）。Actor 的行为指的是，Actor 的计算处理操作，相当于 OOP 对象中的成员函数。Actor 之间不能直接调用其他 Actor 的计算逻辑。Actor 只有收到消息才会触发自身的计算行为。</li>\n<li>消息（Mail）。Actor 的消息以邮件形式在多个 Actor 之间通信传递，每个 Actor 会有一个自己的邮箱（MailBox），用于接收来自其他 Actor 的消息，因此 Actor 模型中的消息也称为邮件。一般情况下，对于邮箱里面的消息，Actor 是按照消息达到的先后顺序（FIFO）进行读取和处理的。</li>\n</ol>\n</li>\n<li>处理流程<ol>\n<li>Actor1 和 Actor3 先后向 Actor2 发送消息，消息被依次放入 Actor2 的 MailBox 队列的队尾 ;</li>\n<li>Actor2 从 MailBox 队列的队首依次取出消息执行相应的操作，由于 Actor1 先把消息发送给 Actor2，因此 Actor2 先处理 Actor1 的消息；</li>\n<li>Actor2 处理完 Actor1 的消息后，更新内部状态，并且向其他 Actor 发送消息，然后处理 Actor3 发送的消息。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-流水线\"><a href=\"#4-流水线\" class=\"headerlink\" title=\"4.流水线\"></a>4.流水线</h4><ol>\n<li>将一个大任务拆分位多个步骤执行，不同的步骤可以采用不同的进程执行，这使得不同任务可以并行执行，从而提高了系统效率</li>\n<li>流水线计算模式的原理：TensorFlow 运用了流水线模式对输入数据进行预处理，因此称为输入流水线（TensorFlow Training Input Pipelines）。其数据输入流水线主要包含 3 个步骤<ol>\n<li>提取（Extract）。通过多种途径读取数据，比如内存、本地的 HDD 或 SSD、远程的 HDFS、GCS 等。数据的种类也有很多，比如图像数据、文本数据、视频数据等。</li>\n<li>转换（Transform）。使用 CPU 处理器对输入的数据进行解析以及预处理操作，包括混合重排（shuffling）、批处理（batching）, 以及一些特定的转换。比如图像解压缩和扩充、文本矢量化、视频时序采样等。</li>\n<li>加载（Load）。将转换后的数据加载到执行机器学习模型的加速器设备上，比如 GPU 或 TPU。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-分布式通信技术\"><a href=\"#4-分布式通信技术\" class=\"headerlink\" title=\"4.分布式通信技术\"></a>4.分布式通信技术</h3><h4 id=\"1-远程调用\"><a href=\"#1-远程调用\" class=\"headerlink\" title=\"1.远程调用\"></a>1.远程调用</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>因为基于HTTP请求，不适用于有低时延要求的大规模分布式系统，需要更底层的网络协议</p></blockquote>\n<ol>\n<li>远程过程调用（Remote Procedure Call）：封装底层细节，使得远程过程调用和调用一次本地服务没什么不同</li>\n<li>Dubbo：<ol>\n<li>在引入服务注册中心（简化调用关系，从而减少通信量）的基础上，又加入了监控中心组件（用来监控服务的调用情况，以方便进行服务治理）</li>\n<li>工作流程<ol>\n<li>服务提供方将自身提供的服务注册到服务注册中心；</li>\n<li>服务调用方需要向注册中心预订调用服务的提供方地址列表；</li>\n<li>服务注册中心将服务对应的提供方地址列表返回给调用方；</li>\n<li>服务调用方根据服务地址信息进行远程服务调用；</li>\n<li>服务调用方和服务提供方定时向监控中心发送服务调用次数及调用时间等信息。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>远程方法调用（Remote Method Invocation）<ol>\n<li>RMI 是一个用于实现 RPC 的 Java API，能够让本地 Java 虚拟机上运行的对象调用远程方法如同调用本地方法，隐藏通信细节。RMI 可以说是 RPC 的一种具体形式，其原理与 RPC 基本一致，唯一不同的是 RMI 是基于对象的，充分利用了面向对象的思想去实现整个过程，其本质就是一种基于对象的 RPC 实现。（典型框架有EJB，企业级JavaBean）</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-发布订阅\"><a href=\"#2-发布订阅\" class=\"headerlink\" title=\"2.发布订阅\"></a>2.发布订阅</h4><ol>\n<li>发布订阅的三要素是生产者、消费者和消息中心，生产者负责产生数据放到消息中心，消费者向消息中心订阅自己感兴趣的消息，当发布者推送数据到消息中心后，消息中心根据消费者订阅情况将相关数据推送给对应的订阅者。</li>\n<li>在分布式通信领域中，消息系统一般有两种典型的模式：<ol>\n<li>点对点（P2P Point to Point）：生产者将消息发送到消息中心，然后消费者从消息中心取出对应的消息进行消费。消息被消费后，消息中心不再存储该消息，因此其他消费者无法再消费该消息。也就是说，点对点模式虽然支持多个消费者，但一个消息只能被一个消费者消费，不允许重复消费。</li>\n<li>发布订阅（Pub/Sub Publish/Subscribe）：生产者可以发送消息到消息中心，而消息中心通常以主题（Topic）进行划分，每条消息都会有相应的主题，消息会被存储到自己所属的主题中，订阅该主题的所有消费者均可获得该消息进行消费。</li>\n</ol>\n</li>\n<li>Kafka<ol>\n<li>架构包括：生产者（Producer）、消费者（Consumer）、消息中心（Broker）</li>\n<li>Zookeeper集群：<ol>\n<li>用来协调和管理Broker和Consumer，实现了 Broker 和 Consumer 的解耦，并为系统提供可靠性保证。</li>\n<li>ZooKeeper 中会存储一些元数据信息，比如对于 Broker，会存储主题对应哪些分区（Partition），每个分区的存储位置等；对于 Consumer，会存储消费组（Consumer Group）中包含哪些 Consumer，每个 Consumer 会负责消费哪些分区等。<ol>\n<li>Partition（分区）：在 Kafka 中，为了解决消息存储的负载均衡和系统可靠性问题，所以引入了主题和分区的概念。其中，主题是一个逻辑概念，指的是消息类型或数据类型，就好比电子论文案例所讲的分布式是一个主题。而分区是针对主题而言的，指的是一个主题的内容可以被划分成多个集合，分布在不同的 Broker 上，不同的 Broker 在不同的节点上。这里的集合就是分区，其中同一个分区只属于一个 Broker。</li>\n<li>Consumer Group（消费组）：Kafka 中的消费组，指的是多个消费者的一个集合。一个消费组中的消费者共同消费主题消息，并且主题中每个消息只可以由消费组中的某一个消费者进行消费。在消息过多的情况下，单个消费者消费能力有限时，会导致消费效率过低，从而导致 Broker 存储溢出，丢弃一部分消息。Kafka 为了解决这个问题，所以引入了消费组。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-消息队列\"><a href=\"#3-消息队列\" class=\"headerlink\" title=\"3.消息队列\"></a>3.消息队列</h4><ol>\n<li>队列是一种具有先进先出特点的数据结构，消息队列是基于队列实现的，存储具有特定格式的消息数据，比如定义一个包含消息类型、标志消息唯一性的 ID、消息内容的一个结构体作为消息数据的特定格式。消息以特定格式放入这个队列的尾部后可以直接返回，并不需要系统马上处理，之后会有其他进程从队列头部开始读取消息，按照消息放入的顺序逐一处理。</li>\n<li>RocketMQ消息队列原理及工作机制<ol>\n<li>RokcetMQ 共包括 NameServer Cluster、Producer Cluster、Broker Cluster 和 Consumer Cluster 共 4 部分。<ol>\n<li>NameServer Cluster，指的是名字服务器集群。这个集群的功能与 Kafka 中引入的 ZooKeeper 类似，提供分布式服务的协同和管理功能，在 RocketMQ 中主要是管理 Broker 的信息，包括有哪些 Broker、Broker 的地址和状态等，以方便生产者获取 Broker 信息发布消息，以及订阅者根据 Broker 信息获取消息。</li>\n<li>Producer Cluster，指的是生产者集群，负责接收用户数据，然后将数据发布到消息队列中心 Broker Cluster。好处如下：<ol>\n<li>一是，多个 Producer 可以并发接收用户的输入数据，提升业务处理效率；</li>\n<li>二是，考虑到可靠性问题，如果只有一个 Producer 接收用户输入数据，当这个 Producer 故障后，整个业务就无法运行了。</li>\n</ol>\n</li>\n<li>Consumer Cluster，指的是消费者集群，负责从 Broker 中获取消息进行消费。Consumer 以集群方式进行部署的好处是，提升消费者的消费能力，以避免消息队列中心存储溢出，消息被丢弃。</li>\n<li>Broker Cluster，指的是 Broker 集群，负责存储 Producer Cluster 发布的数据，以方便消费者进行消费。Broker Cluster 中的每个 Broker 都进行了主从设计，即每个 Broker 分为 Broker Master 和 Broker Slave，Master 既可以写又可以读，Slave 不可以写只可以读。每次 Broker Master 会把接收到的消息同步给 Broker Slave，以实现数据备份。一旦 Broker Master 崩溃了，就可以切换到 Broker Slave 继续提供服务。这种设计的好处是，提高了系统的可靠性。</li>\n</ol>\n</li>\n<li>工作流程<ol>\n<li>首先启动 NameServer，然后启动 Broker。Broker 启动后，会主动找 NameServer 建立连接，并将自己的信息注册到 NameServer 上。注册完毕后，Broker 会周期性地给 NameServer 发送心跳包，比如每隔 1s 发送一次，以告知 NameServer 自己还活着；心跳包里还可以包括 Broker 当前存储的数据信息，也就是说 Broker 可以周期性地向 NameServer 更新自己的数据信息，以保证 NameServer 上存储的数据是最新的。</li>\n<li>创建主题，并确定这个主题的数据放入哪些 Broker 中。</li>\n<li>当 Producer 生产消息发送到主题时，需要先到 NameServer 查询该主题存放在哪些 Broker 中，获取到相关 Broker 信息后，将消息发送给这些 Broker 进行存储。</li>\n<li>Consumer 要从主题消费消息，也需要首先到 NameServer 查询一下该主题的消息存储在哪些 Broker 上，然后去相应的 Broker 获取消息进行消费。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-分布式数据存储\"><a href=\"#5-分布式数据存储\" class=\"headerlink\" title=\"5.分布式数据存储\"></a>5.分布式数据存储</h3><h4 id=\"1-CAP理论\"><a href=\"#1-CAP理论\" class=\"headerlink\" title=\"1.CAP理论\"></a>1.CAP理论</h4><ol>\n<li>保CA弃P：MySQL</li>\n<li>保CP弃A：Redis、HBase、Zookeeper<ol>\n<li>Zookeeper：当出现网络分区时，如果其中一个分区的节点数大于集群总节点数的一半，那么这个分区可以再选出一个 Leader，仍然对用户提供服务，但在选出 Leader 之前，不能正常为用户提供服务；如果形成的分区中，没有一个分区的节点数大于集群总节点数的一半，那么系统不能正常为用户提供服务，必须待网络恢复后，才能正常提供服务。</li>\n</ol>\n</li>\n<li>保AP弃C：CoachDB、Eureka、Cassandra、DynamoDB，多用于查询网站</li>\n</ol>\n<h4 id=\"2-分布式存储系统三要素\"><a href=\"#2-分布式存储系统三要素\" class=\"headerlink\" title=\"2.分布式存储系统三要素\"></a>2.分布式存储系统三要素</h4><ol>\n<li>分布式存储系统：将用户需要存储的数据根据某种规则存储到不同的机器上，当用户想要获取指定数据时，再按照规则到存储数据的机器里获取</li>\n<li>顾客生产和消费数据：根据数据的特征可以被划分为三类：<ol>\n<li>结构化：指关系模型数据，其特征是数据关联较大、格式固定。一般采用分布式关系数据库进行存储和查询</li>\n<li>半结构化：指非关系模型的，有基本固定结构模式的数据，其特征是数据之间关系比较简单。一般采用键值对形式来表示，比如 HTML 文档可以将标签设置为 key，标签对应的内容可以设置为 value，因此一般采用分布式键值系统进行存储和使用。</li>\n<li>非结构化：没有固定模式的数据，其特征是数据之间关联不大。比如文本数据就是一种非结构化数据。这种数据可以存储到文档中，通过 ElasticSearch（一个分布式全文搜索引擎）等进行检索。</li>\n</ol>\n</li>\n<li>导购确定数据位置：<ol>\n<li>数据分片技术：分布式存储系统按照一定的规则将数据存储到相对应的存储节点中，或者到相对应的存储节点中获取想要的数据</li>\n<li>数据复制技术：缓解单点压力，将数据进行备份，以使得多个节点存储该数据</li>\n</ol>\n</li>\n<li>货架存储数据：<ol>\n<li>分布式数据库，通过表格来存储结构化数据，方便查找。常用的分布式数据库有 MySQL Sharding、Microsoft SQL Azure、Google Spanner、Alibaba OceanBase 等。</li>\n<li>分布式键值系统，通过键值对来存储半结构化数据。常用的分布式键值系统有 Redis、Memcache 等，可用作缓存系统。</li>\n<li>分布式存储系统，通过文件、块、对象等来存储非结构化数据。常见的分布式存储系统有 Ceph、GFS、HDFS、Swift 等。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-数据分布方式\"><a href=\"#3-数据分布方式\" class=\"headerlink\" title=\"3.数据分布方式\"></a>3.数据分布方式</h4><ol>\n<li>哈希（一步，Redis）：首先确定一个哈希函数，然后通过计算得到对应的存储节点</li>\n<li>一致性哈希（两步，Cassandra）：<ol>\n<li>将存储节点和数据都映射到一个首尾相连的哈希环上，存储节点可以根据 IP 地址进行哈希，数据通常通过顺时针方向寻找的方式，来确定自己所属的存储节点，即从数据映射在环上的位置开始，顺时针方向找到的第一个存储节点</li>\n<li>这种改进可以很好地解决哈希方法存在的稳定性问题。当节点加入或退出时，仅影响该节点在哈希环上顺时针相邻的后继节点。</li>\n</ol>\n</li>\n<li>带有限负载的一致性哈希（Google Cloud Pub/Sub、HAProxy）：给每个存储节点设置了一个存储上限值来控制存储节点添加或移除造成的数据不均匀。当数据按照一致性哈希算法找到相应的存储节点时，要先判断该存储节点是否达到了存储上限；如果已经达到了上限，则需要继续寻找该存储节点顺时针方向之后的节点进行存储</li>\n<li>带虚拟节点的一致性哈希（Memcached）：根据每个节点的性能，为每个节点划分不同数量的虚拟节点，并将这些虚拟节点映射到哈希环中，然后再按照一致性哈希算法进行数据映射和存储</li>\n</ol>\n<h4 id=\"4-分布式数据复制技术\"><a href=\"#4-分布式数据复制技术\" class=\"headerlink\" title=\"4.分布式数据复制技术\"></a>4.分布式数据复制技术</h4><ol>\n<li>如何让主备数据库保持一致的技术，主要有三类：</li>\n<li>同步复制技术（MySQL集群的全复制模式）：当用户请求更新数据时，主数据库必须要同步到备数据库之后才可给用户返回，即如果主数据库没有同步到备数据库，用户的更新操作会一直阻塞。这种方式保证了数据的强一致性，但牺牲了系统的可用性。</li>\n<li>异步复制技术（MySQL集群的数据复制模式）：当用户请求更新数据时，主数据库处理完请求后可直接给用户响应，而不必等待备数据库完成同步，即备数据库会异步进行数据的同步，用户的更新操作不会因为备数据库未完成数据同步而导致阻塞。显然，这种方式保证了系统的可用性，但牺牲了数据的一致性。</li>\n<li>半同步复制技术：用户发出写请求后，主数据库会执行写操作，并给备数据库发送同步请求，但主数据库不用等待所有备数据库回复数据同步成功便可响应用户，也就是说主数据库可以等待一部分备数据库同步完成后响应用户写操作执行成功<ol>\n<li>一种是，当主数据库收到多个备数据库中的某一个回复数据同步成功后，便可给用户响应写操作完成；（MySQL集群一主多备下，也支持半同步复制模式）</li>\n<li>另一种是，主数据库等超过一半节点（包括主数据库）回复数据更新成功后，再给用户响应写操作成功。（Zookeeper、Azure的Cloud SQL Server、Kubernetes 中保存集群所有网络配置和对象状态信息的 Etcd 组件）</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-分布式数据缓存技术\"><a href=\"#5-分布式数据缓存技术\" class=\"headerlink\" title=\"5.分布式数据缓存技术\"></a>5.分布式数据缓存技术</h4><ol>\n<li>分布式缓存就是指在分布式环境或系统下，把一些热门数据存储到离用户近、离应用近的位置，并尽量存储到更快的设备，以减少远程数据传输的延迟，让用户和应用可以很快访问到想要的数据。</li>\n<li>Redis：Redis 集群是一个典型的去中心化结构，每个节点都负责一部分数据的存储，同时，每个节点还会进行主备设计来提高 Redis 的可靠性，与缓存有关的三个特性：<ol>\n<li>支持多数据结构：Redis 是一个基于内存的 key-value 数据库，为了方便支持多应用的缓存，比如缓存文本类型、数据库的查询结果（字段与字段对应的值）等等，支持的数据结构不仅有简单的 k／v 类型，还可以支持 List、Set、Hash 等复杂类型的存储。</li>\n<li>支持持久化：持久化是指，将数据从内存这种易失性存储设备中写入磁盘，从而让数据永久保存。Redis 中存储的数据虽然是基于内存的，但它也提供了持久化的机制，主要有两种方式：RDB 和 AOF。<ol>\n<li>RDB（Redis DataBase），也称快照方式，简单来说就是 Redis 会定时将内存中的数据备份到磁盘中，形成一个快照，比如每天保存一下过去一周的数据。这样当节点出现故障时，可以根据快照恢复到不同版本的数据。这种方式有一个明显的缺点，是会造成数据丢失，即当节点出现故障时，新数据可能还未备份到磁盘中。</li>\n<li>AOF（Append Only File）的出现主要弥补了 RDB 数据不一致的问题，记录下 Redis 中所有的更新操作。<ul>\n<li>AOF_FSYNC_NO （不同步），即不会自动触发写操作的同步；</li>\n<li>AOF_FSYNC_EVERYSEC （每秒同步），即每隔一秒都会将写操作同步到磁盘；</li>\n<li>AOF_FSYNC_ALWAYS （每次写都同步），即每次发生写操作会立即同步到磁盘。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>主备同步：</li>\n</ol>\n</li>\n<li>Memcached</li>\n</ol>\n<h3 id=\"6-分布式高可靠\"><a href=\"#6-分布式高可靠\" class=\"headerlink\" title=\"6.分布式高可靠\"></a>6.分布式高可靠</h3><h4 id=\"1-负载均衡\"><a href=\"#1-负载均衡\" class=\"headerlink\" title=\"1.负载均衡\"></a>1.负载均衡</h4><ol>\n<li>轮询策略（Dubbo、Nginx）：轮询策略是一种实现简单，却很常用的负载均衡策略，核心思想是服务器轮流处理用户请求，以尽可能使每个服务器处理的请求数相同。轮询策略主要包括顺序轮询和加权轮询。（Nginx默认的负载均衡策略就是一种改进的加权轮询策略）</li>\n<li>随机策略（Dubbo）：当用户请求到来时，会随机发到某个服务节点进行处理，可以采用随机函数实现。这里，随机函数的作用就是，让请求尽可能分散到不同节点，防止所有请求放到同一节点或少量几个节点上。</li>\n<li>哈希和一致性哈希（Redis、Memcached、Cassandra）：哈希函数设置合理的话，负载会比较均衡。而且，相同 key 的请求会落在同一个服务节点上，可以用于有状态请求的场景。除此之外，带虚拟节点的一致性哈希策略还可以解决服务器节点异构的问题。</li>\n</ol>\n<h4 id=\"2-流量控制\"><a href=\"#2-流量控制\" class=\"headerlink\" title=\"2.流量控制\"></a>2.流量控制</h4><ol>\n<li>漏桶策略（Sentinel、Jaeger）：无论用户请求有多少，无论请求速率有多大，“漏桶”都会接收下来，但从漏桶里出来的请求是固定速率的，保证服务器可以处理得游刃有余。当“漏桶”因为容量限制放不下更多的请求时，就会选择丢弃部分请求。这种思路其实就是一种“宽进严出”的策略。</li>\n<li>令牌桶策略（Guava的RateLimiter）：有一个固定容量的存放令牌的桶，我们以固定速率向桶里放入令牌，桶满时会丢弃多出的令牌。每当请求到来时，必须先到桶里取一个令牌才可被服务器处理，也就是说只有拿到了令牌的请求才会被服务器处理。</li>\n</ol>\n<h4 id=\"3-故障隔离\"><a href=\"#3-故障隔离\" class=\"headerlink\" title=\"3.故障隔离\"></a>3.故障隔离</h4><ol>\n<li>采用一定的策略，以实现当某个模块故障时，不会影响其他模块继续提供服务，以保证整个系统的可用性。所以说，故障隔离，可以避免分布式系统出现大规模的故障，甚至是瘫痪，降低损失。在分布式系统中，要实现故障隔离，通常需要在进行系统设计时，提前对可能出现的故障进行预防，以使得在出现故障后能实现故障隔离。此外，由于是提前设计预防的，因此故障隔离还可以帮助我们快速定位故障点。主要有两个维度：以功能模块为粒度、以资源为粒度</li>\n<li>线程级隔离：使用不同的线程池处理不同的请求任务。当某种请求任务出现故障时，负责其他请求任务的线程池不会受到影响，即会继续提供服务，从而实现故障的隔离</li>\n<li>进程级隔离：将系统按照功能分为不同的进程，分布到相同或不同的机器中。如果系统的进程分布到不同机器上的话，从资源的角度来看，也可以说成是主机级的故障隔离。因为从另一个层面看，系统确实分布到了不同机器上，当某个机器出现故障时，不会对其他机器造成影响。</li>\n<li>资源隔离（微服务）：将分布式系统的所有资源分成几个部分，每部分资源负责一个模块，这样系统各个模块就不会争抢资源，即资源之间互不干扰。这种方式不仅可以提高硬件资源利用率，也便于系统的维护与管理，可以大幅提升系统性能。</li>\n</ol>\n<h4 id=\"4-故障恢复\"><a href=\"#4-故障恢复\" class=\"headerlink\" title=\"4.故障恢复\"></a>4.故障恢复</h4><ol>\n<li>故障类型<ol>\n<li>节点故障<ol>\n<li>一类是硬件故障，比如机器硬盘损坏、内存接触不良等；</li>\n<li>另一类是软件故障，比如由于请求过多，超过服务器处理能力上限，导致无法处理，又或者是机器被攻击，导致机器瘫痪等。</li>\n</ol>\n</li>\n<li>网络故障：路由器故障、DNS故障、网络线路断裂</li>\n</ol>\n</li>\n<li>故障检测<ol>\n<li>基于历史心跳信息预测故障的策略：φ 值故障检测，通常会设置一个阈值Ф，若当前心跳计算得到的 φ≥Ф，则判断心跳超时，否则心跳未超时</li>\n</ol>\n</li>\n<li>故障恢复<ol>\n<li>单节点故障：对于单节点故障问题，往往采取主备策略，即当主节点故障后，从备节点中选出一个作为新的主节点，以继续提供服务。</li>\n<li>网络故障：而对于网络故障问题的解决方案，简单来说就是 C、A、P 选择的问题，即在分布式系统的可用性和数据一致性之间做权衡。根据不同的应用场景，选择不同的解决方案。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"2-分布式架构文章\"><a href=\"#2-分布式架构文章\" class=\"headerlink\" title=\"2.分布式架构文章\"></a>2.分布式架构文章</h2><h3 id=\"1-Distributed-systems-theory-for-the-distributed-systems-engineer\"><a href=\"#1-Distributed-systems-theory-for-the-distributed-systems-engineer\" class=\"headerlink\" title=\"1.Distributed systems theory for the distributed systems engineer\"></a>1.<a href=\"https://www.the-paper-trail.org/post/2014-08-09-distributed-systems-theory-for-the-distributed-systems-engineer/\">Distributed systems theory for the distributed systems engineer</a></h3><h4 id=\"1-Book\"><a href=\"#1-Book\" class=\"headerlink\" title=\"1.Book\"></a>1.Book</h4><ol>\n<li>Distributed Systems for fun and profit（入门）</li>\n<li>Designing Data Intensive Application（实践）</li>\n<li>Distributed Systems: Principles and Paradigms（原理）</li>\n<li>Scable Web Architecture and Distributed Systems（应用）</li>\n<li>Notes on distributed systems for young bloods（教训）</li>\n<li>the fallacies of distributed computing （谬论）</li>\n</ol>\n<p>==You should Know==</p>\n<ul>\n<li>安全属性：任何坏的事情都不会发生，例如不会返回不一致的值</li>\n<li>活性属性：好事终会发生，例如每个系统调用最后都会逐渐返回</li>\n</ul>\n<h4 id=\"2-Failure-and-Time\"><a href=\"#2-Failure-and-Time\" class=\"headerlink\" title=\"2.Failure and Time\"></a>2.Failure and Time</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>构建分布式系统的许多困难都是因为：1.进程会失败，2.无法告知已经做了什么</p></blockquote>\n<ul>\n<li><p>失败层次模型：Byzantine failures ⊃ authentification detectable byzantine failures（不改值） ⊃ performance failures（不准时到） ⊃ omission failures（回复无限晚） ⊃ crash failures（停止响应） ⊃ fail-stop failures（可检测）前面的failure出现，也可以假设后面的出现</p>\n</li>\n<li><p>决定事情发展的先后顺序：</p>\n<ul>\n<li><p><strong>Vector clocks</strong>：</p>\n<ul>\n<li><p>向量钟是一个在分布式系统中确定事件的并行顺序或者检测因果关系违规的数据结构，通常一个包含N个进程的向量钟是一个N个逻辑钟（logical clock）的array/vector，并且一个进程一个时钟，每个进程保存一个全局时钟数组最大可能值的副本</p>\n</li>\n<li><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220418152353235.png\" alt=\"image-20220418152353235\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><strong>FLP</strong> result：在异步环境中，如果节点间的网络延迟没有上限，只要有一个恶意的节点存在，就没有算法能在有限的时间内达成共识。</p>\n</li>\n<li><p>不同的时间模型：</p>\n<ul>\n<li>同步、部分同步、异步</li>\n</ul>\n</li>\n<li><p>错误检测：</p>\n<ul>\n<li><p>基本属性</p>\n<ul>\n<li><p>完整性Completeness：在每个崩溃的进程都被部分或所有正确的进程永久怀疑之后存在一段时间</p>\n<ul>\n<li>强一致：需要所有正确的进程来怀疑故障</li>\n<li>弱一致：只需要一个正确的过程来怀疑故障</li>\n</ul>\n</li>\n<li><p>准确性Accuracy：在一些正确的进程永远不会被任何正确的进程所怀疑之后存在一度时间</p>\n</li>\n</ul>\n</li>\n<li><p>Dynamo（Pinging）</p>\n<ul>\n<li>算法思想：一个节点将询问其它节点是否存活，如果其他节点及时回复，则认为他们存活</li>\n<li>不保证失败检测延时，且对消息丢失不敏感</li>\n<li>只对一定大小的系统非常有用</li>\n</ul>\n</li>\n<li><p>Gossip（Heartbeat）</p>\n<ul>\n<li>算法思想：一个节点定期向外广播本节点依旧存活的信息，为了提高效率，通过肩驮或者引用其他网络消息</li>\n<li>很短的失败检测延时，但对消息丢失很敏感</li>\n<li>具有可伸缩性和可扩展性，使得它成为具有弱一致性模型和大型系统的理想选择</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-The-basic-tension-of-fault-tolerance\"><a href=\"#3-The-basic-tension-of-fault-tolerance\" class=\"headerlink\" title=\"3.The basic tension of fault tolerance\"></a>3.The basic tension of fault tolerance</h4><ul>\n<li><p>quorum技术</p>\n<ul>\n<li>法定人数（quorum）是分布式事务为了被允许在分布式系统中执行操作而必须获得的最小投票数</li>\n<li>基于quorum的投票可以确保单副本可串行性的控制方法，以及在存在网络分区的情况下确保事务原子性的提交方法</li>\n</ul>\n</li>\n<li><p>共识协议：</p>\n<ul>\n<li><p>定义在一个分布式系统中让一系列节点都同意某些事（值，操作，决定）</p>\n</li>\n<li><p>三种属性：Agreement（都同意）,Validity（值有效）,Termination（能结束）</p>\n</li>\n<li><p>2PC：只能决定是否接受，不能决定取什么值，且只能是二值变量（低延迟，脆弱）</p>\n<ul>\n<li>Step1：Contact every participant, suggest a value and gather their responses（每个人都可以当组织者）</li>\n<li>Step2：If everyone agrees, contact every participant again to let them know. Otherwise, contact every participant to abort the consensus.</li>\n<li>Tolerance to failures:<ul>\n<li>step1中任何节点出错都能处理，当step2处理一般时，若组织者出错，则有参与者充当协调员来充当组织者，协调员也崩溃了则有恢复节点去接管</li>\n<li>如果事务可以随时回滚，那么协议可以在节点超时时恢复，但如果协议必须将任何提交决策视为永久性的，那么错误的失败可能会使整个事情陷入停顿。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>3PC：高可用。网络分区后不可用</p>\n<ul>\n<li>把step2拆开：准备提交阶段和提交/中止阶段</li>\n<li>恢复节点可以确定是已提交阶段还是未提交阶段</li>\n</ul>\n</li>\n<li><p>Paxos：</p>\n<ul>\n<li><p>PROPOSERS:</p>\n<ol>\n<li>Submit a proposal numbered <em>n</em> to a majority of acceptors. Wait for a majority of acceptors to reply.</li>\n<li>If the majority reply ‘agree’, they will also send back the value of any proposals they have already accepted. Pick one of these values, and send a ‘commit’ message with the proposal number and the value. If no values have already been accepted, use your own. If instead a majority reply ‘reject’, or fail to reply, abandon the proposal and start again.</li>\n<li>If a majority reply to your commit request with an ‘accepted’ message, consider the protocol terminated. Otherwise, abandon the proposal and start again.</li>\n</ol>\n</li>\n<li><p>ACCEPTORS:</p>\n<ol>\n<li>Once a proposal is received, compare its number to the highest numbered proposal you have already agreed to. If the new proposal is higher, reply ‘agree’ with the value of any proposals you have already accepted. If it is lower, reply ‘reject’, along with the sequence number of the highest proposal.</li>\n<li>When a ‘commit’ message is received, accept it if a) the value is the same as any previously accepted proposal and b) its sequence number is the highest proposal number you have agreed to. Otherwise, reject it.</li>\n</ol>\n</li>\n<li><p>Failure tolerance：</p>\n<ul>\n<li><p>一半节点失效也可以运行，应付f个失败只需要提供2f+1个acceptors，Properser失败可以有另一个新Proposer接管，</p>\n</li>\n<li><p>A failure mode</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/duelling-proposers.png\" alt=\"img\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>最终一致性：</p>\n<ul>\n<li>以较弱的系统行为保证为代价来避免这种tension</li>\n<li>Dynamo</li>\n<li>Life Beyond Transactions</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-Basic-primitives\"><a href=\"#4-Basic-primitives\" class=\"headerlink\" title=\"4.Basic primitives\"></a>4.Basic primitives</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一些分布式系统的构建模块</p></blockquote>\n<ul>\n<li>Leader election <ul>\n<li>Bully algorithm：在同步分布式系统中从分布式计算进程中动态选举coordinator（未失败的进程中具有最高进程ID）<ol>\n<li>If P has the highest process ID, it sends a Victory message to all other processes and becomes the new Coordinator. Otherwise, P broadcasts an Election message to all other processes with higher process IDs than itself.</li>\n<li>If P receives no Answer after sending an Election message, then it broadcasts a Victory message to all other processes and becomes the Coordinator.</li>\n<li>If P receives an Answer from a process with a higher ID, it sends no further messages for this election and waits for a Victory message. (If there is no Victory message after a period of time, it restarts the process at the beginning.)</li>\n<li>If P receives an Election message from another process with a lower ID it sends an Answer message back and starts the election process at the beginning, by sending an Election message to higher-numbered processes.</li>\n<li>If P receives a Coordinator message, it treats the sender as the coordinator.</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>Consistent snapshotting <ul>\n<li>Distributed Snapshots: Determining Global States of a Distributed System</li>\n</ul>\n</li>\n<li>Consensus <ul>\n<li>2PC、Paxos</li>\n</ul>\n</li>\n<li>Distributed state machine replication <ul>\n<li>一种通过复制服务器并且协调客户端与服务器副本交互的实现容错服务的方法<br>1. </li>\n</ul>\n</li>\n<li>Broadcast - delivering messages to more than one node at once<ul>\n<li><a href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.3.4709&rep=rep1&type=pdf\">Atomic broadcast</a> - can you deliver a message to all nodes in a group, or none?</li>\n<li>Gossip (<a href=\"http://bitsavers.informatik.uni-stuttgart.de/pdf/xerox/parc/techReports/CSL-89-1_Epidemic_Algorithms_for_Replicated_Database_Maintenance.pdf\">the classic paper</a>)</li>\n<li><a href=\"https://www.cs.cornell.edu/courses/cs614/2003sp/papers/BSS91.pdf\">Causal multicast</a> (but also consider the enjoyable <a href=\"https://www.cs.rice.edu/~alc/comp520/papers/Cheriton_Skeen.pdf\">back</a>-and-<a href=\"https://www.cs.princeton.edu/courses/archive/fall07/cos518/papers/catocs-limits-response.pdf\">forth</a> between Birman and Cheriton).</li>\n</ul>\n</li>\n<li>Chain replication (a neat way of ensuring consistency and ordering of writes by organizing nodes into a virtual linked list).<ul>\n<li>The <a href=\"http://www.cs.cornell.edu/home/rvr/papers/OSDI04.pdf\">original paper</a></li>\n<li><a href=\"https://www.usenix.org/legacy/event/usenix09/tech/full_papers/terrace/terrace.pdf\">A set of improvements</a> for read-mostly workloads</li>\n<li><a href=\"https://pdfs.semanticscholar.org/6b14/dd57eaf8122dbc29d08e50749661d4602e53.pdf\">An experiential report</a> by <a href=\"https://twitter.com/slfritchie\">@slfritchie</a></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-Fundamental-Results\"><a href=\"#5-Fundamental-Results\" class=\"headerlink\" title=\"5.Fundamental Results\"></a>5.Fundamental Results</h4><ul>\n<li><p>如果在进程间丢失信息，就不能实现一致性存储并响应所有请求（CAP定理）</p>\n</li>\n<li><p>共识是不可能以下面这样的方式实现的</p>\n<ul>\n<li>总是正确的</li>\n<li>即使一台机器在异步系统中发生故障并出现停止响应</li>\n</ul>\n</li>\n<li><p>一般来说，不到两轮消息就不可能达成共识</p>\n</li>\n<li><p>原子广播（Atomic broadcast）和共识一样难，如果你解决了原子广播，你就解决了共识</p>\n</li>\n</ul>\n<h4 id=\"6-CALM-amp-CDRT\"><a href=\"#6-CALM-amp-CDRT\" class=\"headerlink\" title=\"6.CALM &amp; CDRT\"></a>6.CALM &amp; CDRT</h4><ol>\n<li>CALM:<ol>\n<li>全称为：Consistency As Logical Monotonicity（逻辑单调性的一致性），当且仅当问题是单调时，问题才具有一致的，无需协调的分布式实现</li>\n<li>CALM定理是为了避免分布式事务机制中的协调机制，视图实现如同没有红绿灯的交通路口，需要程序员对业务问题进行设计，保证问题的单调性，也就是说，输出结果与输入数据的之间数据没有关联关系，输入数据的前后顺序不会影响输出结果，典型案例如CRDT</li>\n</ol>\n</li>\n<li>CRDT:<ol>\n<li>全称为：Conflict-free replicated data type（无冲突的复制数据类型），在网络中多计算机之间被复制的数据结构，并且副本之间可以独立和同时更新，副本之间无需协调，在数学上总是有可能解决可能出现的不一致。</li>\n<li>有两种方法可以提供强大的最终一致性：<ol>\n<li>operation-based CDRTs：传输操作，例如对整数+20或者-10操作，操作不是幂等的</li>\n<li>state-based CDRTs：传输整个状态，所有被一个函数合并，这个函数是可交换的、关联的和幂等的。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-Fallacies-of-Distributed-Computing-Explained\"><a href=\"#2-Fallacies-of-Distributed-Computing-Explained\" class=\"headerlink\" title=\"2.Fallacies of Distributed Computing Explained\"></a>2.<a href=\"https://pages.cs.wisc.edu/~zuyu/files/fallacies.pdf\">Fallacies of Distributed Computing Explained</a></h3><ol>\n<li>网络是稳定的<ol>\n<li>infrastructure side：硬件与软件冗余、权衡失败的风险和所需投资</li>\n<li>software side：线路上丢失请求响应消息</li>\n</ol>\n</li>\n<li>网络传输的延迟是零<ol>\n<li>进行更少的系统调用，并假设你有足够的带宽，使得每次调用移动更多的数据</li>\n<li>Ajax：允许用户使用消化数据所花费的空闲时间来检索更多的数据，但仍需考虑延迟问题 </li>\n</ol>\n</li>\n<li>网络的带宽是无穷大<ol>\n<li>有更新的更占带宽的程序，例如视频</li>\n<li>丢包：传输更大的数据可以容忍更高的丢包率</li>\n</ol>\n</li>\n<li>网络是安全的<ol>\n<li>从第一天，从架构级别开始就需要考虑安全问题</li>\n<li>执行威胁建模并且评估安全风险</li>\n</ol>\n</li>\n<li>网络的拓扑不会改变<ol>\n<li>不要依赖于特定的端点或路由</li>\n<li>可能希望提供位置透明度或者发现服务</li>\n</ol>\n</li>\n<li>只有一个系统管理员<ol>\n<li>有专门的工具来监控正在运行的实例</li>\n<li>在更新时确定系统不同部分是否同步运行</li>\n</ol>\n</li>\n<li>传输数据的成本为零<ol>\n<li>代码转为二进制、系统设备</li>\n</ol>\n</li>\n<li>整个网络是同构的<ol>\n<li>必须假设互用性将会在不久被使用</li>\n<li>不依赖于单一协议，可以考虑XML</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-Notes-on-Distributed-Systems-for-Young-Bloods\"><a href=\"#3-Notes-on-Distributed-Systems-for-Young-Bloods\" class=\"headerlink\" title=\"3.Notes on Distributed Systems for Young Bloods\"></a>3.<a href=\"https://www.somethingsimilar.com/2013/01/14/notes-on-distributed-systems-for-young-bloods/\">Notes on Distributed Systems for Young Bloods</a></h3><ol>\n<li>Choose id spaces wisely. </li>\n<li>Extract services.</li>\n</ol>\n<ul>\n<li>分布式系统之所以复杂，就是因为它太容易出错了。这意味着，你要把处理错误的代码当成正常功能的代码来处理。</li>\n<li>开发一个健壮的分布式系统的成本是单体系统的几百倍甚至几万倍。这意味着，我们要自己开发一个，需要能力很强的开发人员。</li>\n<li>非常健壮的开源的分布式系统并不多，或者说基本没有。这意味着，如果你要用开源的，那么你需要 hold 得住其源码。</li>\n<li>管理或是协调多个服务或机器是非常难的。这意味着，我们要去读很多很多的分布式系统的论文，利用CAP理论评判系统。</li>\n<li>在分布式环境下，出了问题是很难 debug 的。这意味着，我们需要非常好的监控和跟踪系统，还需要经常做演练和测试，并且通过功能特性来迭代而不是直接迭代大版本。</li>\n<li>在分布式环境下，你需要更科学地分析和统计。这意味着，我们要用 P90 这样的统计指标，而不是平均值，我们还需要做容量计划和评估。</li>\n<li>在分布式环境下，需要应用服务化，可以保证部分可用。这意味着，我们需要一个服务开发框架，比如 SOA 或微服务。</li>\n<li>在分布式环境下，故障不可怕，可怕的是影响面过大，时间过长。这意味着，我们需要花时间来开发我们的自动化运维平台。</li>\n<li>在分布式环境下，利用数据局部性原理，并且不总把缓存写回磁盘，合理的安排索引，后期可以更多的选择。</li>\n</ul>\n<h3 id=\"4-Scalable-Web-Architecture-and-Distributed-Systems\"><a href=\"#4-Scalable-Web-Architecture-and-Distributed-Systems\" class=\"headerlink\" title=\"4.Scalable Web Architecture and Distributed Systems\"></a>4.<a href=\"http://www.aosabook.org/en/distsys.html\">Scalable Web Architecture and Distributed Systems</a></h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>图片托管应用：功能性需求：写图片到服务器、请求一个图片。非功能性需求：图片数量可扩展、下载需要低延迟、上传的图片一直存在、系统应易于维护、系统具有高性价比</p></blockquote>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/imageHosting1.jpg\" alt=\"Figure 1.1\"></p>\n<h4 id=\"Web分布式系统设计的原则\"><a href=\"#Web分布式系统设计的原则\" class=\"headerlink\" title=\"Web分布式系统设计的原则\"></a>Web分布式系统设计的原则</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在一般情况下，一个设计可能会牺牲其中的一个或几个原则</p></blockquote>\n<ol>\n<li>**可用性(Availability)**：网站的响应时间对许多公司的名声和正常运作都非常的关键。对一些大型在线零售站点来说，即使是几分钟的不可访问都会导致上万元的收入损失，因此将系统设计得持续可访问，并在失效后可恢复，既是一个业务需求，也是一个技术需求。分布式系统的高可用性要求仔细考虑关键组件的冗余，部分系统失效后的恢复，以及问题发生后降低影响。</li>\n<li>**性能(Performance)**：网站性能是绝大多数网站重点考虑的。网站的速度不仅影响着用户使用的满意度，还影响着搜索引擎排名，与收入和顾客保留直接相关。因此，创建一个响应迅速、延迟低的优化系统非常重要。</li>\n<li>**可靠性(Reliability)**：一个系统需要是可靠的，例如请求的数据会一直返回相同的结果，而在数据改变或更新后，同样的请求应当返回新的数据。需要让用户知道，如果一些东西写入或存入了系统，会一直存留，在未来取回时仍然存在。</li>\n<li>**可扩展性(Scalability)**：对于大型分布式系统而言，系统大小只是需要考虑可扩展性的一个方面。系统的可扩展性通常是指应对大量负载的能力，提高这一能力同样重要。可扩展性还可以用来指代系统的多个不同参数：可以处理多少额外的流量；存储容量是否容易添加；甚至是可以多处理多少事务。</li>\n<li>**可管理性(Manageablity)**：设计容易管理的系统是另一个重要的考虑。系统的可管理性即操作（维护与升级）的可扩展性。可管理性需要考虑的事情包括诊断与理解发生的问题的容易程度，更新和修改的容易程度，以及系统运行的简单程度。（即，系统是否没有错误和异常地持续运行？）</li>\n<li>**成本(Cost)**：成本是一个重要因素。显然，成本包括硬件和软件的花费，但考虑系统部署和维护的花费也很重要。系统开发时间、运行消耗甚至是培训成本都应该被考虑进来。成本应当包括所有者的全部花费。</li>\n</ol>\n<h4 id=\"服务（Service）\"><a href=\"#服务（Service）\" class=\"headerlink\" title=\"服务（Service）\"></a>服务（Service）</h4><ol>\n<li>当考虑可扩展性系统设计时，对功能进行解耦，并将系统的每一个部分各自考虑成具有清晰定义的接口的服务，会很有帮助。即==面向服务的架构(Service-Oriented Architecture, SOA)==，每一个服务都有它自己清晰的功能环境，和这个环境之外的任何事物的交互都通过抽象的接口（特别是其他服务的公开API）进行</li>\n<li>==在我们的例子中==<ol>\n<li>首先将上传和检索图片的请求分解成两个服务，即==读写分离==<ul>\n<li>问题1：写入比读出慢</li>\n<li>问题2：Web服务器可维护的同时连接数有上限，主要是写连接的问题</li>\n</ul>\n</li>\n<li>其它解决：Flickr解决这个读/写问题的方法是将将用户分布到不同的==shard==上。每个shard只能处理一小部分的用户，在用户数量增长时，将更多的shard加入集群中</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"冗余（Redundancy）\"><a href=\"#冗余（Redundancy）\" class=\"headerlink\" title=\"冗余（Redundancy）\"></a>冗余（Redundancy）</h4><ol>\n<li>为了优雅地处理失效问题，一个Web架构必须有服务和数据的冗余。同样的原则也适用于服务。如果有一个应用的核心功能，保证有多个拷贝或多个版本在同时运行，可以免于单个服务结点失效的危害。<ol>\n<li>在系统中如果有两个相同实例在运行，当其中一个失效或退化，系统可以==故障转移(failover)==到另一个健康的拷贝上。</li>\n<li>或者创建一个==无共享架构(shared-nothing architecture)==，在这个架构中，每个节点都独立于其他节点运行，没有中央调度服务器，也没有和其他节点协调进行的活动</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"分区（Partition）\"><a href=\"#分区（Partition）\" class=\"headerlink\" title=\"分区（Partition）\"></a>分区（Partition）</h4><ol>\n<li>数据集可能会有很大，导致单个服务器装不下；也可能是一个操作需要太多的计算资源，降低了性能，导致必须增加容量。在这样的情况下你有两种选择：垂直分区或是水平分区。<ol>\n<li>垂直扩展：在一个服务器上加更多的磁盘驱动、更换更快的CPU、增加更多的内存</li>\n<li>水平扩展：增加更多的结点。通过将更多的数据存在其它服务器上，或者将操作或负载分离到其它节点上。最常见的技术就是将服务分解为多个分区(partition)，或是多个shard。<ul>\n<li>问题1：数据局部性：当数据不在本地时，服务器需要耗时来在网络上请求</li>\n<li>问题2：不一致性：当有多个服务访问同一共享资源时，可能产生竞争条件</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"故障处理（handing-failure）\"><a href=\"#故障处理（handing-failure）\" class=\"headerlink\" title=\"故障处理（handing  failure）\"></a>故障处理（handing  failure）</h4><h4 id=\"数据访问组件\"><a href=\"#数据访问组件\" class=\"headerlink\" title=\"数据访问组件\"></a>数据访问组件</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>因为数据访问比对服务（内存）的访问慢，所以需要缓存、代理、索引和负载均衡器等策略使数据访问变得更快</p></blockquote>\n<ol>\n<li><p>缓存：利用局部性原理：最近请求过的数据很可能会被再次请求。（==Redis==）可以在请求层节点插入缓存，也可以将缓存扩展到多个节点上，但同一个请求可能发往不同的结点，这会增加缓存不命中的次数，解决办法如下：</p>\n<ol>\n<li>全局缓存：所有节点使用相同的单一缓存空间，</li>\n<li>分布式缓存：每个节点都拥有一部分缓存数据，通常用一个全局唯一的散列函数分割，分布式缓存的缺点是补救缺失结点。</li>\n</ol>\n</li>\n<li><p>代理：代理服务器是一个硬件/软件的中间片，从客户端接收请求，并转播到后端服务器。代理通常用来过滤请求和记录请求，有时候也用来变换请求（通过增加/删除头部，加密/解密，或是压缩）。</p>\n<ol>\n<li><p>想象一下在多个结点上有对同一个数据（叫它littleB）的请求，且这个数据不在缓存中。如果请求是通过代理发送，那么所有的请求就会被压缩成一个，这意味着我们只需要从磁盘上读一次littleB。这个设计会带来一些开销，因为每个请求的延迟会稍高，并且一些请求可能会因为要和相似的请求合并而有轻微的延期。但这种做法在高负载，尤其是一些数据被一次又一次地请求的情况下，会大幅提升性能。这和缓存很像，但与缓存将数据/文档存储起来不同，代理是优化对文档的请求或调用，充当这些客户的代理人。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/collapseRequests.png\" alt=\"Figure 1.14\"></p>\n</li>\n<li><p>另一个使用请求的很好方式是不仅仅压缩对同一个数据的请求，还压缩对原存储中相距很近（在磁盘上连续）的数据的请求。使用这个策略最大化了请求的数据局部性，可以降低请求延迟。例如，我们有一堆结点请求B的一部分：B1，B2，等。我们可以将设定代理识别空间局部性，将它们压缩为同一个请求，只返回bigB，这样就极大地减小了从数据源读的次数。（见图1.15）。这可以在你从TB级的数据中随机访问时减少很多请求时间！代理还在高负载或是缓存空间有限时非常有用，因为它们能一次处理一批数据。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/collapseRequestsSpatial.png\" alt=\"Figure 1.15\"></p>\n</li>\n</ol>\n</li>\n<li><p>索引：通过增加存储开销和写操作时间（因为你必须同时写数据和更新索引）来换取更快的读。</p>\n<ol>\n<li>多层索引</li>\n<li>倒排索引</li>\n</ol>\n</li>\n<li><p>负载均衡器：负载均衡器每个架构上的首要部分，将负载分布到负责请求服务的结点上，这使系统中多个结点可以透明地服务同一个功能。（==Nginx==）</p>\n<ol>\n<li>会话粘性：浏览器缓存、cookie、URL重写</li>\n<li>反向代理：根据请求的类型不同发往不同的结点</li>\n<li>测试结点健康度：如果一个结点不响应或过载了，可以从处理请求的池中移除，利用系统中不同结点的冗余。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"队列：对写数据的高效管理\"><a href=\"#队列：对写数据的高效管理\" class=\"headerlink\" title=\"队列：对写数据的高效管理\"></a>队列：对写数据的高效管理</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>RabbitMQ、Zookeeper、Redis</p></blockquote>\n<ol>\n<li>一个任务来到后，被添加到队列中，结点在它们有容量处理任务的时候从队列中取出下一个。</li>\n<li>队列使客户可以用异步的方式工作，提供了一个对客户请求和响应策略上的抽象。在异步系统中，客户请求一个任务，服务端响应一个消息，确认任务收到，然后客户就可以周期性检查任务状态，只在任务完成之后请求结果。在客户等待异步请求完成时，它可以随意进行其他工作，甚至是发送其他服务的异步请求。后者是队列和消息在分布式系统中应用的例子。</li>\n</ol>\n<h3 id=\"5-The-twelve-factor-app\"><a href=\"#5-The-twelve-factor-app\" class=\"headerlink\" title=\"5.The twelve-factor app\"></a>5.<a href=\"https://12factor.net/zh_cn/\">The twelve-factor app</a></h3><p>==12-Factor为构建如下的SaaS应用提供了方法论：==</p>\n<ul>\n<li>使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入项目</li>\n<li>和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性</li>\n<li>适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源</li>\n<li>将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发</li>\n<li>可以在工具、架构和开发流程不发生明显变化的前提下实现扩展</li>\n</ul>\n<ol>\n<li><p><strong>基准代码：一份基准代码，多份部署</strong></p>\n<p>​        基准代码使用Git和Code Repo来管理，基准代码和应用之间总是保持一一对应的关系。一旦有多个基准代码，就是一个分布式系统，分布式系统中的每一个组件都是一个应用；当有多个应用共享一份代码时，可以将共享代码拆分为独立的类库。尽管每个应用只对应一份基准代码，但可以同时存在多份部署（包括不同版本的预发布）。</p>\n</li>\n<li><p><strong>依赖：显示声明依赖关系</strong></p>\n<p>​        应用程序不会隐式依赖系统级的类库，通过<strong>依赖清单</strong>确切地声明所有依赖项，在运行过程中通过<strong>依赖隔离</strong>工具来确保程序不会调用系统中存在但清单中未声明的依赖项，并且这一做法会统一到应用和开发环境，显示声明依赖的优点之一是为新进开发者简化了环境配置流程。</p>\n<p>​        应用程序不会隐式依赖某些系统工具，如果应用必须使用某些系统工具，那么这些工具应该被包含在应用之中。</p>\n</li>\n<li><p><strong>配置：在环境中存储配置</strong></p>\n<p>​        应用的配置（数据库的配置、第三方证书）在不同部署（预发布、生产环境、开发环境）间会有很大差异，因此推荐将应用的配置存储于环境变量中，因为环境变量方便修改，且不动一行代码。</p>\n<p>​        一方面，按部署分组成development、test、production环境。另一方面，环境变量的粒度要足够小，且相对独立，他们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。</p>\n</li>\n<li><p><strong>后端服务：把后端服务当作附加资源</strong></p>\n<p>​        后端服务是指程序运行所需要的通过网络调用的各种服务，如本地服务（数据库、消息队列系统、缓存系统等），第三方发布和管理的服务（STMP邮件发送服务、数据收集服务、数据存储服务）。</p>\n<p>​        应用程序通过一个url或者其它存储在配置中的服务定位/服务证书来获取服务，应用程序将每个不同的后端服务当作一份资源，这些资源和它们附属的部署保持松耦合，即不改变代码就可以更改服务，部署可以按需加载或卸载资源。</p>\n</li>\n<li><p><strong>构建、发布、运行：严格分离构建和运行</strong></p>\n<p>​        基准代码转化为一份部署需要三个阶段：<strong>构建阶段</strong>将代码仓库转化为可执行包、<strong>发布阶段</strong>将构建的结果和当前部署所需配置相结合、<strong>运行阶段</strong>针对选定的发布版本在执行环境中启动一系列应用程序进程。</p>\n<p>​        部署工具通常提供发布管理工具，可以回退至较旧的发布版本。每一个发布的版本必须对应一个唯一的发布ID，发布的版本一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p>\n<p>​        新的代码在部署之前，需要开发人员触发构建操作，但运行阶段可以自动进行。此外运行阶段应该保持尽可能少的模块，减少故障发生是引发的问题，但构建阶段可以相对复杂一些，因为错误信息能立刻展示在开发人员面前，从而被妥善处理。</p>\n</li>\n<li><p><strong>进程：以一个或多个无状态进程运行应用</strong></p>\n<p>​        应用的进程必须无状态且无共享，任何需要持久化的数据都要存储在后端服务内，比如数据库，内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存。粘性session不好，session中的数据应该保存在带有过期时间的缓存中。</p>\n</li>\n<li><p><strong>端口绑定：通过端口绑定提供服务</strong></p>\n<p>​        互联网应用有时会运行于服务器的容器之内，例如Java运行于Tomat。应用程序应该完全自我加载，而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用通过端口绑定来提供服务，并监听发送至该端口的请求。</p>\n<p>​        通常的思路是将网络服务器类库通过依赖声明载入应用，如Java的Jetty。完全由客户端，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。HTTP并不是唯一一个可以由端口绑定提供的服务，其实所有服务器软件都可以通过进程绑定端口来等待请求，这也就意味着一个应用可以成为另一个应用的后端服务，调用方将服务方提供的响应URL当作资源存入配置以备将来调用</p>\n</li>\n<li><p><strong>并发：通过进程模型进行扩展</strong></p>\n<p>​        任何计算机程序，一旦启动，就会生成一个或多个进程，例如：在程序启动之初JVM提供了一个超级进程，并通过多线程实现内部的开发管理。</p>\n<p>​        通过借鉴Unix守护进程模型，把不同的工作分配给不同的进程类型，例如：常驻的后台工作交给worker进程负责，应用进程具备无共享、水平分区的特性，所以添加并发会变得简单。应用进程不需要守护进程，而是借助操作系统的进程管理器（systemd、分布式的进程管理云平台）,来管理输出流，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p>\n</li>\n<li><p><strong>易处理：快速启动和优雅终止可最大化健壮性</strong></p>\n<p>​        应用进程是易处理的，意味着它们可以瞬间开启或停止。这有利于快速、弹性的伸缩应用，迅速部署变化的代码和配置，稳健的部署应用。</p>\n<p>​        进程应当追求最小启动时间，并且一旦接受终止信号就会优雅的终止。对于<strong>网络进程</strong>，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出，此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。对于<strong>worker进程</strong>来说，优雅终止是指将当前任务退回队列，此类型的进程所隐含的要求是可重复执行， 这主要由将结果包装进事务或是使幂等来实现。</p>\n<p>​        进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。</p>\n</li>\n<li><p><strong>开发环境与线上环境等价：尽可能的保持开发、预发布、线上环境相同</strong></p>\n<p>​        减少部署所需时间，开发人员密切参与部署过程，尽量保证开发环境以及线上环境的一致性。不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p>\n</li>\n<li><p><strong>日志：把日志当作事件流</strong></p>\n<p>​        日志使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。日志应该是事件流的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。</p>\n<p>​        不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。</p>\n</li>\n<li><p><strong>管理进程：后台管理任务当作一次性进程运行</strong></p>\n<p>​        进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务。一次性管理进程应该和正常的常驻进程使用同样的环境。这些管理进程和任何其他的进程一样使用相同的代码和配置，基于某个发布版本运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p>\n</li>\n</ol>\n<h2 id=\"3-实践\"><a href=\"#3-实践\" class=\"headerlink\" title=\"3.实践\"></a>3.实践</h2><h3 id=\"1-系统设计总览\"><a href=\"#1-系统设计总览\" class=\"headerlink\" title=\"1.系统设计总览\"></a>1.<a href=\"https://github.com/donnemartin/system-design-primer\">系统设计总览</a></h3><h4 id=\"1-扩展性\"><a href=\"#1-扩展性\" class=\"headerlink\" title=\"1.扩展性\"></a>1.扩展性</h4><ol>\n<li><a href=\"https://www.youtube.com/watch?v=-W9F__D3oY4\">可扩展性视频</a><ol>\n<li>垂直扩展</li>\n<li>水平扩展</li>\n<li>缓存</li>\n<li>负载均衡</li>\n<li>数据库复制</li>\n<li>数据库分区</li>\n</ol>\n</li>\n<li>可扩展性文章（<a href=\"http://www.lecloud.net/tagged/scalability/chrono%EF%BC%89\">http://www.lecloud.net/tagged/scalability/chrono）</a><ol>\n<li>克隆：每个服务器包含相同的代码仓库，并且不再本地磁盘缓存任何用户相关的数据，这些数据都被存在类似于Redis这样的中心化的仓库中，但会引发数据部署不一致的问题</li>\n<li>数据库：从一开始反范式化（不用Joins），并且用类似于MongoDB这样的NoSQL数据库，并在应用层来实现连接操作，但依旧会越来越慢</li>\n<li>缓存：添加缓存层，缓存许多对象而不是缓存查询结果，即先用class处理数据再缓存类实例，而且可以通过异步访问提高访问速度</li>\n<li>异步：<ol>\n<li>提起做好时间密集型的工作：动态内容-&gt;静态内容</li>\n<li>特殊需求必须处理：通过类似与RabbitMQ的消息队列</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-权衡与取舍\"><a href=\"#2-权衡与取舍\" class=\"headerlink\" title=\"2.权衡与取舍\"></a>2.权衡与取舍</h4><ol>\n<li><p>Performance VS Scalability</p>\n<p>性能表现在单个用户访问的快慢，可扩展性是指在资源扩展时性能所增长的比例，对于上线的服务可扩展性指的是为冗余加资源不会导致性能下降</p>\n</li>\n<li><p>Latency VS thoughtput</p>\n<p>延迟指的是执行操作/运算d饿到结果所花费的时间，吞吐量指的是单位时间执行此类操作？运算的数量</p>\n</li>\n<li><p>Availability VS Consistency</p>\n<ol>\n<li>CAP理论<ol>\n<li>一致性：每次访问都能得到最新的数据，但会得到错误响应</li>\n<li>可用性：每次访问都能收到非错响应，但不保证获取最新数据</li>\n<li>分区容错性：在任意分区网络故障的情况下，系统仍能继续运行</li>\n</ol>\n</li>\n<li>CP：等待分区节点的响应可能会导致延时响应，用在：业务需要原子读写</li>\n<li>AP：响应节点上数据可能不是最新的，当分区解析完，写入操作可能需要时间来传播，如果业务需求允许最终一致性，或当由外部故障时要求系统继续运行</li>\n</ol>\n</li>\n<li><p>一致性模式（Weak、Eventual、Strong）</p>\n<ol>\n<li>弱一致性：在写入之后，访问不一定能看到。在视频聊天、实时多人游戏用的多</li>\n<li>最终一致性：再写入后，访问最终能看到写入数据（通常在数毫秒内），数据被异步复制。用在DNS，Emil，在高可用系统中效果不错</li>\n<li>强一致性：在写入后，访问立即可见，数据被同步复制。用在文件系统和关系型数据库</li>\n</ol>\n</li>\n<li><p>可用性模式</p>\n<ol>\n<li>故障切换（Fail-over）：增加硬件增加复杂性、会丢失数据<ol>\n<li>工作到备用切换（Active-passive）：工作服务器周期发信号给备用服务器，多信号中断，则备用服务器切换为工作服务器的IP地址，并恢复服务。也称为主从切换</li>\n<li>双工作切换（Active-active）：双方都管控流量，分散负载。也成为主主切换</li>\n</ol>\n</li>\n<li>复制（Replication）：见数据库主从复制和主主复制</li>\n</ol>\n</li>\n<li><p>可用性指标</p>\n<ol>\n<li><p>99.9% availability - three 9s</p>\n<table>\n<thead>\n<tr>\n<th>Duration</th>\n<th>Acceptable downtime</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Downtime per year</td>\n<td>8h 45min 57s</td>\n</tr>\n<tr>\n<td>Downtime per month</td>\n<td>43m 49.7s</td>\n</tr>\n<tr>\n<td>Downtime per week</td>\n<td>10m 4.8s</td>\n</tr>\n<tr>\n<td>Downtime per day</td>\n<td>1m 26.4s</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>99.99% availability - four 9s</p>\n<table>\n<thead>\n<tr>\n<th>Duration</th>\n<th>Acceptable downtime</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Downtime per year</td>\n<td>52min 35.7s</td>\n</tr>\n<tr>\n<td>Downtime per month</td>\n<td>4m 23s</td>\n</tr>\n<tr>\n<td>Downtime per week</td>\n<td>1m 5s</td>\n</tr>\n<tr>\n<td>Downtime per day</td>\n<td>8.6s</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-Domain-name-system\"><a href=\"#3-Domain-name-system\" class=\"headerlink\" title=\"3.Domain name system\"></a>3.Domain name system</h4><ol>\n<li>把域名转换成IP地址，分层次结构</li>\n<li>缺陷：<ol>\n<li>虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟。</li>\n<li>虽然它们通常由政府，网络服务提供商和大公司管理，但 DNS 服务管理仍可能是复杂的。</li>\n<li>DNS 服务最近遭受DDoS 攻击。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-Content-delivery-network\"><a href=\"#4-Content-delivery-network\" class=\"headerlink\" title=\"4.Content delivery network\"></a>4.Content delivery network</h4><ol>\n<li>内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，CDN 的 DNS 解析会告知客户端连接哪台服务器。</li>\n<li>CDN推送：当你服务器上的内容变动时，推送CDN接受新内容并重写URL。内容只有在更新或更改时才推送，流量最小化，但存储最大化。（上传整个数据）</li>\n<li>CDN拉取：当第一个用户请求该资源时，从服务器上拉去资源。将内容先留在自己的服务其上并更改URL，直到内容被缓存在CDN上为止。（取下来一部分）</li>\n<li>缺陷<ol>\n<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>\n<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>\n<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-Load-Balancer\"><a href=\"#5-Load-Balancer\" class=\"headerlink\" title=\"5.Load Balancer\"></a>5.Load Balancer</h4><ol>\n<li>将传入的请求分发到应用服务器和数据库等计算资源，并返回给恰当的客户端。主要为了：防止请求进入不好的服务器、防止资源过载、帮助消除单一的故障点</li>\n<li>通常会设置多个LB，以免发生故障，并基于多种方式来路由流量<ol>\n<li>随机</li>\n<li>最少负载</li>\n<li>Session/cookie</li>\n<li>轮询调度或加权轮询调度</li>\n<li>四层负载均衡：根据IP，执行NAT来向上游服务器转发网络数据包</li>\n<li>七层负载均衡：根据请求头、cookie等来决定如何分发，送给特定的服务器</li>\n</ol>\n</li>\n<li>水平扩展：负载均衡器帮助水平扩展，提高性能和可用性</li>\n<li>缺陷<ol>\n<li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li>\n<li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li>\n<li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-Reverse-proxy-Web-server\"><a href=\"#6-Reverse-proxy-Web-server\" class=\"headerlink\" title=\"6.Reverse proxy(Web server)\"></a>6.Reverse proxy(Web server)</h4><ol>\n<li>反向代理时一种可以集中调用内部服务，并提供统一接口给公共客户的web服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端</li>\n<li>优势：<ol>\n<li>增加安全性</li>\n<li>提高可扩展性和灵活性</li>\n<li>压缩服务器响应</li>\n<li>直接返回命中的缓存结果</li>\n<li>直接提供静态内容</li>\n</ol>\n</li>\n<li>缺陷<ol>\n<li>引入反向代理会增加系统的复杂度。</li>\n<li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如故障转移）会进一步增加复杂度。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"7-Platform-Layer（应用层）\"><a href=\"#7-Platform-Layer（应用层）\" class=\"headerlink\" title=\"7.Platform Layer（应用层）\"></a>7.Platform Layer（应用层）</h4><ol>\n<li>将web层和应用层分离，可以独立缩放和配置这两层，添加新的API只需要添加应用层服务器，而不需要改变web服务器</li>\n<li>单一职责原则：提倡小型的，自治的服务共同合作，小团队通过提供小型的服务，可以更激进地计划增长</li>\n<li>==微服务==：可以描述为一些列可以独立部署的小型的，模块化服务，每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标</li>\n<li>==服务发现==：像Consul、Etcd和Zookeeper这样的系统可以通过追踪注册名、地址、端口等信息来帮助服务互相发现对方。Health checks可以帮助确认服务的完整性和是否经常使用一个HTTP路径。Consul和Etcd都有一个内建的key-value存储用来存储配置信息和其他的共享信息。</li>\n<li>缺陷：<ol>\n<li>添加由多个松耦合服务组成的应用层，从架构、运营、流程等层面来讲将非常不同（相对于单体系统）。</li>\n<li>微服务会增加部署和运营的复杂度。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"8-1-RDBMS\"><a href=\"#8-1-RDBMS\" class=\"headerlink\" title=\"8-1.RDBMS\"></a>8-1.RDBMS</h4><ol>\n<li><p>ACID特性</p>\n</li>\n<li><p>扩展技术：</p>\n<ol>\n<li><p>master-slave replication：主库同时负责读写，并复制写入到若干从库，从库只负责读</p>\n</li>\n<li><p>master-master replication：两个主库都负责读写，写入时互相协调，难以保证一致性</p>\n</li>\n<li><p>federation(联合)：联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：论坛、用户和产品，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。效率低。</p>\n</li>\n<li><p>sharding(分片)：分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。会带类复杂的SQL查询</p>\n</li>\n<li><p>denormalization(非规范化)：试图以写入性能为代价来换取读取性能 ，在多个表中冗余数据副本，以避免高成本的联结操作</p>\n</li>\n<li><p>SQL tuning(调优)：利用基准测试和性能分析可以得到以下优化方案</p>\n<ol>\n<li><p>改进模式</p>\n<ul>\n<li>为了实现快速访问，MySQL 在磁盘上用连续的块存储数据。</li>\n<li>使用<code>CHAR</code>类型存储固定长度的字段，不要用<code>VARCHAR</code>。<ul>\n<li><code>CHAR</code> 在快速、随机访问时效率很高。如果使用 <code>VARCHAR</code>，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾。</li>\n</ul>\n</li>\n<li>使用 <code>TEXT</code> 类型存储大块的文本，例如博客正文。<code>TEXT</code> 还允许布尔搜索。使用 <code>TEXT</code> 字段需要在磁盘上存储一个用于定位文本块的指针。</li>\n<li>使用 <code>INT</code> 类型存储高达 2^32 或 40 亿的较大数字。</li>\n<li>使用 <code>DECIMAL</code> 类型存储货币可以避免浮点数表示错误。</li>\n<li>避免使用 <code>BLOBS</code> 存储实际对象，而是用来存储存放对象的位置。</li>\n<li><code>VARCHAR(255)</code> 是以 8 位数字存储的最大字符数，在某些关系型数据库中，最大限度地利用字节。</li>\n<li>在适用场景中设置 <code>NOT NULL</code> 约束来提高搜索性能。</li>\n</ul>\n</li>\n<li><p>使用正确的索引</p>\n<ul>\n<li>你正查询（<code>SELECT</code>、<code>GROUP BY</code>、<code>ORDER BY</code>、<code>JOIN</code>）的列如果用了索引会更快。</li>\n<li>索引通常表示为自平衡的 <a href=\"https://en.wikipedia.org/wiki/B-tree\">B 树</a>，可以保持数据有序，并允许在对数时间内进行搜索，顺序访问，插入，删除操作。</li>\n<li>设置索引，会将数据存在内存中，占用了更多内存空间。</li>\n<li>写入操作会变慢，因为索引需要被更新。</li>\n<li>加载大量数据时，禁用索引再加载数据，然后重建索引，这样也许会更快。</li>\n</ul>\n</li>\n<li><p>避免高成本的联结操作</p>\n<ul>\n<li>有性能需要，可以进行非规范化。</li>\n</ul>\n</li>\n<li><p>分割数据表</p>\n<ul>\n<li>将热点数据拆分到单独的数据表中，可以有助于缓存。</li>\n</ul>\n</li>\n<li><p>调优查询缓存</p>\n<ul>\n<li>在某些情况下，查询缓存可能会导致性能问题。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"8-2-NoSQL\"><a href=\"#8-2-NoSQL\" class=\"headerlink\" title=\"8-2.NoSQL\"></a>8-2.NoSQL</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>NoSQL is a collection of data items represented in a <strong>key-value store</strong>, <strong>document store</strong>, <strong>wide column store</strong>, or a <strong>graph database</strong>. Data is denormalized, and joins are generally done in the application code. 大多数NoSQL无法实现真正符合ACID的事务，支持最终一致性</p></blockquote>\n<ol>\n<li>BASE特性<ol>\n<li>Basically available：系统保证可用性</li>\n<li>Soft state：即使没有输入，系统状态也可能随时间变化</li>\n<li>Eventual consistency：经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入</li>\n</ol>\n</li>\n<li>key-value store：O(1)的读写，用内存或SSD存储数据，性能很高，通常用于存储简单数据模型或频繁修改的数据</li>\n<li>document store：将文档抽象为键-值存储，文档存储了指定对象的全部信息，基于底层实现，文档可以根据集合、标签、元数据或者文件夹组织。尽管不同文档可以被组织在一起或者分成一组，但相互之间可能具有完全不同的字段。</li>\n<li>wide column store：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/n16iOGk.png\" alt=\"img\"><ol>\n<li>抽象模型：嵌套的 <code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</li>\n<li>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</li>\n<li>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</li>\n</ol>\n</li>\n<li>graph database<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/fNcl65g.png\" alt=\"img\"><ol>\n<li>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</li>\n</ol>\n</li>\n</ol>\n<p>==SQL or NoSQL==</p>\n<ol>\n<li>选取SQL的原因：结构化数据、严格的模式、关系型数据、需要复杂的连接操作、事务、清晰的扩展模式、通过索引进行查询非常快、社区资源丰富</li>\n<li>选取NoSQL的原因：半结构化数据、动态或灵活的模式、非关系型数据、不需要复杂的联结操作、存储TB或PB级别的数据、高数据密集的工作负载、IOPS高吞吐量</li>\n<li>适合NoSQL的示例数据：埋点数据和日志数据、排行榜或得分数据、类似购物车的临时数据、频繁访问的热表、元数据或查找表</li>\n</ol>\n<h4 id=\"9-缓存\"><a href=\"#9-缓存\" class=\"headerlink\" title=\"9.缓存\"></a>9.缓存</h4><ol>\n<li>客户端缓存：缓存可以位于客户端（操作系统或者浏览器）、服务端或者不同的缓存层</li>\n<li>CDN缓存：CDN也被视为一种缓存</li>\n<li>Web服务器缓存：反向代理和缓存可以直接提供静态和动态内容，Web服务器同样也可以缓存请求，返回相应的结果而不必连接应用服务器</li>\n<li>数据库缓存：数据库的默认配置中通常包含缓存级别，调整配置，在不同情况下使用不同的模式可以进一步提高性能</li>\n<li>应用缓存：基于内存的缓存比如Reids是应用程序和数据存储之间的一种键值存储。</li>\n<li>数据库查询级别的缓存：将查询语句的哈希值与查询结果存储在缓存中，会遇到以下问题：<ol>\n<li>很难用复杂的查询删除已缓存结果</li>\n<li>如果一条数据比如表中某数据的一项被改变，则需要删除所有可能包含已更改项的缓存</li>\n</ol>\n</li>\n<li>对象级别的缓存：将数据视为对象，就像对待你的应用代码一样。让应用程序将数据从数据库中组合到类实例或数据结构中：<ol>\n<li>如果对象的基础数据已更改，那么从缓存中删掉这个对象</li>\n<li>允许异步处理：workers通过使用最新的缓存对象来组装对象</li>\n<li>建议缓存的内容：用户会话、完全渲染的Web页面、活动流、用户图数据</li>\n</ol>\n</li>\n<li>何时更新缓存<ol>\n<li>缓存模式：首先从缓存中查找记录，如果所需数据不在缓存中，则从数据库中加载所需内容，并将查询结果存储到缓存中（Memcached）</li>\n<li>直写模式：应用向缓存中添加或更新数据，缓存同步地写入数据存储，返回所需内容</li>\n<li>回写模式：在缓存中增加或者更新条目，异步写入数据，提高写入性能</li>\n<li>刷新：可以将缓存配置成在到期之前自动刷新最近访问过的内容，如果缓存可以准确预测将来可能请求哪些数据，那么刷新可能会导致延迟与读取时间的降低</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"10-异步\"><a href=\"#10-异步\" class=\"headerlink\" title=\"10.异步\"></a>10.异步</h4><ol>\n<li>消息队列：消息队列接受、保留和传递信息，不阻塞用户操作，作业在后台处理。如RabbitMQ</li>\n<li>任务队列：当任务队列接收任务及其相关数据，运行它们，然后传递其结果。它们可以支持调度，并可用于在后台运行计算密集型作业</li>\n<li>背压：如果队列开始明显增长，那么队列的大小可能会超过内存大小，导致高速缓存未命中。背压可以通过限制队列大小，从而使得队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将的到服务器忙或HTTP503状态码，以便稍后重试。</li>\n<li>缺陷：简单的计算和实时工作流等用例可能更适用于同步操作，因为引入队列可能会增加延迟和复杂性。</li>\n</ol>\n<h3 id=\"2-互联网架构模板\"><a href=\"#2-互联网架构模板\" class=\"headerlink\" title=\"2.互联网架构模板\"></a>2.互联网架构模板</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220515144706935-20221123130531656.png\" alt=\"image-20220515144706935\"></p>\n<h4 id=\"1-存储层\"><a href=\"#1-存储层\" class=\"headerlink\" title=\"1.存储层\"></a>1.存储层</h4><ol>\n<li><p>SQL</p>\n<ol>\n<li>Oracle太贵，使用开源的MySQL</li>\n<li>性能要求越来越高，将数据拆分到多个数据库实例，将这部分功能（数据如何拆分和组合）独立成中间件，例如百度的DBProxy、淘宝的TDDL、MySQL的MySQL Router</li>\n<li>SQL服务器越来越多，每个业务都有自己的SQL集群，资源浪费而且维护成本高，在SQL集群上构建SQL存储平台，以对业务透明的形式提供资源分配、数据备份、迁移、容灾、读写分离、分库分表等一系列操作，例如淘宝的UMP系统</li>\n</ol>\n</li>\n<li><p>NoSQL</p>\n<ol>\n<li>在数据结构上和性能上来弥补MySQL的不足，而且NoSQL一般自己本身就提供集群功能</li>\n<li>NoSQL发展到一定规模后，通常都会在NoSQL集群的基础上在实现统一存储平台，主要有以下几种功能：<ul>\n<li>资源动态按需动态分配：例如同一台 Memcache 服务器，可以根据内存利用率，分配给多个业务使用。</li>\n<li>资源自动化管理：例如新业务只需要申请多少 Memcache 缓存空间就可以了，无需关注具体是哪些 Memcache 服务器在为自己提供服务。</li>\n<li>故障自动化处理：例如某台 Memcache 服务器挂掉后，有另外一台备份 Memcache 服务器能立刻接管缓存请求，不会导致丢失很多缓存数据。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>小文件存储</p>\n<ol>\n<li>小文件具有：数据小，数量巨大，访问量大的特点</li>\n<li>由于大数据的火爆，可以选用在开源方案（HBase、Hadoop）的基础上封装一个小文件存储平台，例如淘宝的TFS、京东JFS</li>\n</ol>\n</li>\n<li><p>大文件存储</p>\n<ol>\n<li><p>互联网行业的大文件主要分为两类：</p>\n<ol>\n<li>业务上的大数据：Youtube的视频、电影网站的电影</li>\n<li>海量的日志数据：各种访问日志、操作日志、用户轨迹日志等</li>\n</ol>\n</li>\n<li><p>著名的有：Google的三篇大数据论文、Yahoo开源的Hadoop系列（HDFS、HBase），因为对照论文实现的成本太高，所以一般使用开源方案，例如：Hadoop、HBase、Storm、Hive等，或者基于开源方案封装成大数据平台：淘宝的云梯系统、腾讯的TDW系统</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220515161918001.png\" alt=\"image-20220515161918001\" style=\"zoom:50%;\" /></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-开发层和服务层\"><a href=\"#2-开发层和服务层\" class=\"headerlink\" title=\"2.开发层和服务层\"></a>2.开发层和服务层</h4><ol>\n<li><p>开发框架：优选成熟的框架，避免盲目追逐新技术，公司内大多使用统一的开发框架，例如：Java的SSM、Ruby的Ruby on Rails、PHP的ThinkPHP、Python的Django</p>\n</li>\n<li><p>Web服务器：使用开源方案，主要和开发语言相关，例如：通用的Apache、Java的Tomcat、Python/PHP的Nginx</p>\n</li>\n<li><p>容器：传统的虚拟化技术是虚拟机，解决了跨平台的问题，但太厚重，Docker的容器技术，随软没有跨平台、但启动快、几乎不占资源。Docker推动了自动化运维和微服务设计</p>\n</li>\n<li><p>配置中心：集中管理各个系统的配置，检查方便、协作效率高，配置中心相当于备份了系统的配置，能够快速搭建环境</p>\n</li>\n<li><p>服务中心：主要是为了解决上面提到的跨系统依赖的“配置”和“调度问题，一般有两种实现方式：</p>\n<ul>\n<li><p>服务名字系统：类似于DNS，将Service名称解析为host+port+接口名称</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220515163654555.png\" alt=\"image-20220515163654555\" style=\"zoom:50%;\" /></li>\n<li><p>服务总线系统：类似于总线，由总线系统完成调用，服务请求方不需要直接和服务提供方交互</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220515163756504.png\" alt=\"image-20220515163756504\" style=\"zoom:50%;\" /></li>\n<li><p>两者的对比：</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220515163827519.png\" alt=\"image-20220515163827519\" style=\"zoom:50%;\" /></li>\n</ul>\n</li>\n<li><p>消息队列</p>\n<ol>\n<li>互联网业务的一个特点就是快，这就要求很多业务处理采用异步的方式</li>\n<li>消息队列可以简化系统间的依赖，使得增加新的消息生产者变的简单，开源方案有：RocketMQ、Kafka、ActiveMQ</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-网络层\"><a href=\"#3-网络层\" class=\"headerlink\" title=\"3.网络层\"></a>3.网络层</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为了满足互联网的高性能和高可用</p></blockquote>\n<ol>\n<li>负载均衡<ol>\n<li>DNS：一般用来实现地理级别的均衡，但缺点式缓存时间长、不够灵活，可以尝试HTTP-DNS的功能，即使用一个HTTP协议实现一个私有DNS</li>\n<li>Nginx、LVS、F5：用于同一地点内机器级别的负载均衡，其中Nginx是软件的7层负载均衡、LVS是内核的4层负载均衡、F5是硬件的4层负载均衡</li>\n</ol>\n</li>\n<li>CDN：将内容缓存在离用户最近的地方，用户访问缓存的内容而不是站点实时的内容，大多从CDN服务商购买CDN服务即可</li>\n<li>多机房：单机房难以保证业务的高可用，多机房设计最核心的因素就是如何处理时延带来的影响</li>\n<li>多中心：以多机房为前提，更复杂，重点在于保证：数据一致性和数据事务性</li>\n</ol>\n<h4 id=\"4-用户层和业务层\"><a href=\"#4-用户层和业务层\" class=\"headerlink\" title=\"4.用户层和业务层\"></a>4.用户层和业务层</h4><ol>\n<li>用户管理：<ol>\n<li>通过互联网将众多分散的用户连接起来</li>\n<li>单点登录（SSO）：多个子系统不可能每个都管理这么庞大的用户，所以需要单点登录，实现手段主要有：cookie、JSONP、token等，目前最成熟的开源方案是CAS架构</li>\n<li>授权登录：当业务做大成了平台后，开放成为了促进业务进一步发展的手段，需要允许第三方应用接入，由此引出授权登录，现在最流行的授权登录就是OAuth2.0</li>\n<li>虽然用户量巨大，但是因为不同用户间登录基本没有关系，可以使用一个简单的负载均衡就能轻松应对</li>\n</ol>\n</li>\n<li>消息推送：<ol>\n<li>消息推送的不同路径，分为短信、邮件、站内信、App推送。除了App，不同的途径基本上调用不同的API即可完成，技术上没有什么难度，例如：短信需要依赖运营商的短信接口、邮件需要依赖邮件服务商的邮件接口、站内信是系统提供的消息通知功能。</li>\n<li>App主要分为iOS和Android推送，iOS系统比较规范和封闭，基本上只能使用苹果的APNS；Android在国内大厂会自己实现一套消息推送机制</li>\n<li>消息推送主要包括三个功能：<ul>\n<li>海量设备和用户管理﻿﻿：消息推送的设备数量众多，存储和管理这些设备是比较复杂的；同时，为了针对不同用户进行不同的业务推广，还需要收集用户的一些信息，简单来说就是将用户和设备关联起来，需要提取用户特征对用户进行分类或者打标签等。</li>\n<li>连接保活：﻿﻿要想推送消息必须有连接通道，但是应用又不可能一直在前台运行，大部分设备为了省电省流量等原因都会限制应用后台运行，限制应用后台运行后连接通道可能就被中断了，导致消息无法及时的送达。连接保活是整个消息推送设计中细节和黑科技最多的地方，例如应用互相拉起、找手机厂商开白名单等。</li>\n<li>消息管理﻿﻿：实际业务运营过程中，并不是每个消息都需要发送给每个用户，而是可能根据用户的特征，选择一些用户进行消息推送。由于用户特征变化很大，各种排列组合都有可能，将消息推送给哪些用户这部分的逻辑要设计得非常灵活，才能支撑花样繁多的业务需求，具体的设计方案可以采取规则引擎之类的微内核架构技术。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>存储云、图片云<ol>\n<li>互联网业务场景中，用户会上传多种类型的文件数据，例如微信用户发朋友圈时上传图片，微博用户发微博时上传图片、视频，优酷用户上传视频，淘宝卖家上传商品图片等，这些文件具备几个典型特点：数据量大、文件体积小、访问有时效性</li>\n<li>通过CDN+小文件存储来实现，或直接购买云服务</li>\n</ol>\n</li>\n<li>业务层技术<ol>\n<li>互联网的业务千差万别，不同的业务分解下来有不同的系统，所以业务层没有办法提炼一些公共的系统或者组件。抛开业务上的差异，各个互联网业务发展最终面临的问题都是类似的：业务复杂度越来越高。也就是说，业务层面对的主要技术挑战是“复杂度”。复杂度越来越高的一个主要原因就是系统越来越庞大，业务越来越多。幸运的是，面对业务层的技术挑战，我们都可以通过“拆”，化整为零、分而治之，将整体复杂性分散到多个子业务或者子系统里面去。具体拆的方式你可以查看专栏前面可扩展架构模式部分的分层架构、微服务、微内核等。</li>\n<li>随着子系统数量越来越多，如果达到几百上千，另外一个复杂度问题又会凸显出来：子系统数量太多，已经没有人能够说清楚业务的调用流程了，出了问题排查也会特别复杂。此时应该怎么处理呢，总不可能又将子系统合成大系统吧？最终答案还是“合”，正所谓“合久必分、分久必合”，但合的方式不一样，此时采取的“合”的方式是按照“高内聚、低耦合”的原则，将职责关联比较强的子系统合成一个虚拟业务域，然后通过网关对外统一呈现，类似于设计模式中的 Facade 模式。</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-平台层\"><a href=\"#5-平台层\" class=\"headerlink\" title=\"5.平台层\"></a>5.平台层</h4><ol>\n<li><p>运维平台</p>\n<ol>\n<li>运维平台核心的职责分为四大块：配置、部署、监控、应急，每个职责对应系统生命周期的一个阶段，如下所示：<ol>\n<li>配置：主要负责资源的管理。例如，机器管理、IP 地址管理、虚拟机管理等。</li>\n<li>部署：主要负责将系统发布到线上。例如，包管理、灰度发布管理、回滚等。</li>\n<li>监控：主要负责收集系统上线运行后的相关数据并进行监控，以便及时发现问题。</li>\n<li>应急：主要负责系统出故障后的处理。例如，停止程序、下线故障机器、切换 IP 等。</li>\n</ol>\n</li>\n<li>运维平台的核心要素式：标准化、平台化、自动化、可视化。</li>\n</ol>\n</li>\n<li><p>测试平台</p>\n<ol>\n<li><p>测试平台核心的职责当然就是测试了，包括单元测试、集成测试、接口测试、性能测试等，都可以在测试平台来完成。测试平台的核心目的是提升测试效率，从而提升产品质量，其设计关键就是自动化</p>\n</li>\n<li><p>架构如图：</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220515225443138.png\" alt=\"image-20220515225443138\" style=\"zoom: 50%;\" />\n\n<ol>\n<li>用例管理：测试自动化的主要手段就是通过脚本或者代码来进行测试，例如单元测试用例是代码、接口测试用例可以用 Python 来写、可靠性测试用例可以用 Shell 来写。为了能够重复执行这些测试用例，测试平台需要将用例管理起来，管理的维度包括业务、系统、测试类型、用例代码。例如，网购业务的订单系统的接口测试用例。</li>\n<li>资源管理：测试用例要放到具体的运行环境中才能真正执行，运行环境包括硬件（服务器、手机、平板电脑等）、软件（操作系统、数据库、Java 虚拟机等）、业务系统（被测试的系统）。除了性能测试，一般的自动化测试对性能要求不高，所以为了提升资源利用率，大部分的测试平台都会使用虚拟技术来充分利用硬件资源，如虚拟机、Docker 等技术。</li>\n<li>任务管理：任务管理的主要职责是将测试用例分配到具体的资源上执行，跟踪任务的执行情况。任务管理是测试平台设计的核心，它将测试平台的各个部分串联起来从而完成自动化测试。</li>\n<li>数据管理：测试任务执行完成后，需要记录各种相关的数据（例如，执行时间、执行结果、用例执行期间的 CPU、内存占用情况等）</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>数据平台</p>\n<ol>\n<li><p>数据：数据平台的核心职责主要包括三部分：数据管理、数据分析和数据应用</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220515230000403.png\" alt=\"image-20220515230000403\" style=\"zoom:50%;\" /></li>\n<li><p>数据管理数据管理包含数据采集、数据存储、数据访问和数据安全四个核心职责，是数据平台的基础功能。</p>\n<ol>\n<li>数据采集：从业务系统搜集各类数据。例如，日志、用户行为、业务数据等，将这些数据传送到数据平台。</li>\n<li>数据存储：将从业务系统采集的数据存储到数据平台，用于后续数据分析。</li>\n<li>数据访问：负责对外提供各种协议用于读写数据。例如，SQL、Hive、Key-Value 等读写协议。</li>\n<li>数据安全：通常情况下数据平台都是多个业务共享的，部分业务敏感数据需要加以保护，防止被其他业务读取甚至修改，因此需要设计数据安全策略来保护数据。</li>\n</ol>\n</li>\n<li><p>数据分析数据分析包括数据统计、数据挖掘、机器学习、深度学习等几个细分领域。</p>\n<ol>\n<li>数据统计：根据原始数据统计出相关的总览数据。例如，PV、UV、交易额等。</li>\n<li>数据挖掘：数据挖掘这个概念本身含义可以很广，为了与机器学习和深度学习区分开，这里的数据挖掘主要是指传统的数据挖掘方式。例如，有经验的数据分析人员基于数据仓库构建一系列规则来对数据进行分析从而发现一些隐含的规律、现象、问题等，经典的数据挖掘案例就是沃尔玛的啤酒与尿布的关联关系的发现。</li>\n<li>机器学习、深度学习：机器学习和深度学习属于数据挖掘的一种具体实现方式，由于其实现方式与传统的数据挖掘方式差异较大，因此数据平台在实现机器学习和深度学习时，需要针对机器学习和深度学习独立进行设计。</li>\n</ol>\n</li>\n<li><p>数据应用数据应用很广泛，既包括在线业务，也包括离线业务。例如，推荐、广告等属于在线应用，报表、欺诈检测、异常检测等属于离线应用。数据应用能够发挥价值的前提是需要有“大数据”，只有当数据的规模达到一定程度，基于数据的分析、挖掘才能发现有价值的规律、现象、问题等。如果数据没有达到一定规模，通常情况下做好数据统计就足够了，尤其是很多初创企业，无须一开始就参考 BAT 来构建自己的数据平台。</p>\n</li>\n</ol>\n</li>\n<li><p>管理平台</p>\n<ol>\n<li>管理平台的核心职责就是权限管理，无论是业务系统（例如，淘宝网）、中间件系统（例如，消息队列 Kafka），还是平台系统（例如，运维平台），都需要进行管理。如果每个系统都自己来实现权限管理，效率太低，重复工作很多，因此需要统一的管理平台来管理所有的系统的权限。权限管理主要分为两部分：身份认证、权限控制<ol>\n<li>身份认证：确定当前的操作人员身份，防止非法人员进入系统。例如，不允许匿名用户进入系统。为了避免每个系统都自己来管理用户，通常情况下都会使用企业账号来做统一认证和登录。</li>\n<li>权限控制：根据操作人员的身份确定操作权限，防止未经授权的人员进行操作。例如，不允许研发人员进入财务系统查看别人的工资。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-服务端高并发分布式架构演进之路\"><a href=\"#3-服务端高并发分布式架构演进之路\" class=\"headerlink\" title=\"3.服务端高并发分布式架构演进之路\"></a>3.<a href=\"https://segmentfault.com/a/1190000018626163\">服务端高并发分布式架构演进之路</a></h3><h4 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h4><p>本文以淘宝作为例子，介绍从一百个到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。<strong>（特别说明：本文以淘宝为例仅仅是为了便于说明演进过程可能遇到的问题，并非是淘宝真正的技术演进路径）</strong></p>\n<h4 id=\"2-基本概念\"><a href=\"#2-基本概念\" class=\"headerlink\" title=\"2. 基本概念\"></a>2. 基本概念</h4><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍：</p>\n<ul>\n<li><strong>分布式</strong><br>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上</li>\n<li><strong>高可用</strong><br>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性</li>\n<li><strong>集群</strong><br>一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性</li>\n<li><strong>负载均衡</strong><br>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的</li>\n<li><strong>正向代理和反向代理</strong><br>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</li>\n</ul>\n<h4 id=\"3-架构演进\"><a href=\"#3-架构演进\" class=\"headerlink\" title=\"3. 架构演进\"></a>3. 架构演进</h4><h5 id=\"3-1-单机架构\"><a href=\"#3-1-单机架构\" class=\"headerlink\" title=\"3.1 单机架构\"></a>3.1 单机架构</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHnQ.png\" alt=\"clipboard.png\"></p>\n<p>以淘宝作为例子。在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。浏览器往<a href=\"http://www.taobao.com发起请求时,首先经过dns服务器(域名系统)把域名转换为实际ip地址10.102.4.1,浏览器转而访问该ip对应的tomcat./\">www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务</strong></p></blockquote>\n<h5 id=\"3-2-第一次演进：Tomcat与数据库分开部署\"><a href=\"#3-2-第一次演进：Tomcat与数据库分开部署\" class=\"headerlink\" title=\"3.2 第一次演进：Tomcat与数据库分开部署\"></a>3.2 第一次演进：Tomcat与数据库分开部署</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHnF.png\" alt=\"clipboard.png\"></p>\n<p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>随着用户数的增长，并发读写数据库成为瓶颈</strong></p></blockquote>\n<h5 id=\"3-3-第二次演进：引入本地缓存和分布式缓存\"><a href=\"#3-3-第二次演进：引入本地缓存和分布式缓存\" class=\"headerlink\" title=\"3.3 第二次演进：引入本地缓存和分布式缓存\"></a>3.3 第二次演进：引入本地缓存和分布式缓存</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHo5.png\" alt=\"clipboard.png\"></p>\n<p>在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢</strong></p></blockquote>\n<h5 id=\"3-4-第三次演进：引入反向代理实现负载均衡\"><a href=\"#3-4-第三次演进：引入反向代理实现负载均衡\" class=\"headerlink\" title=\"3.4 第三次演进：引入反向代理实现负载均衡\"></a>3.4 第三次演进：引入反向代理实现负载均衡</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqjM7.png\" alt=\"clipboard.png\"></p>\n<p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈</strong></p></blockquote>\n<h5 id=\"3-5-第四次演进：数据库读写分离\"><a href=\"#3-5-第四次演进：数据库读写分离\" class=\"headerlink\" title=\"3.5 第四次演进：数据库读写分离\"></a>3.5 第四次演进：数据库读写分离</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqjPI.png\" alt=\"clipboard.png\"></p>\n<p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能</strong></p></blockquote>\n<h5 id=\"3-6-第五次演进：数据库按业务分库\"><a href=\"#3-6-第五次演进：数据库按业务分库\" class=\"headerlink\" title=\"3.6 第五次演进：数据库按业务分库\"></a>3.6 第五次演进：数据库按业务分库</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqknA.png\" alt=\"clipboard.png\"></p>\n<p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>随着用户数的增长，单机的写库会逐渐会达到性能瓶颈</strong></p></blockquote>\n<h5 id=\"3-7-第六次演进：把大表拆分为小表\"><a href=\"#3-7-第六次演进：把大表拆分为小表\" class=\"headerlink\" title=\"3.7 第六次演进：把大表拆分为小表\"></a>3.7 第六次演进：把大表拆分为小表</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqjUO.png\" alt=\"clipboard.png\"></p>\n<p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。</p>\n<p>这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库，但是这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的，如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等，这种架构其实是MPP（大规模并行处理）架构的一类实现。</p>\n<p>目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等，不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景，这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回，也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈</strong></p></blockquote>\n<h5 id=\"3-8-第七次演进：使用LVS或F5来使多个Nginx负载均衡\"><a href=\"#3-8-第七次演进：使用LVS或F5来使多个Nginx负载均衡\" class=\"headerlink\" title=\"3.8 第七次演进：使用LVS或F5来使多个Nginx负载均衡\"></a>3.8 第七次演进：使用LVS或F5来使多个Nginx负载均衡</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqkrJ.png\" alt=\"clipboard.png\"></p>\n<p>由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器，当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。</p>\n<p>此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat，在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同</strong></p></blockquote>\n<h5 id=\"3-9-第八次演进：通过DNS轮询实现机房间的负载均衡\"><a href=\"#3-9-第八次演进：通过DNS轮询实现机房间的负载均衡\" class=\"headerlink\" title=\"3.9 第八次演进：通过DNS轮询实现机房间的负载均衡\"></a>3.9 第八次演进：通过DNS轮询实现机房间的负载均衡</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqkuH.png\" alt=\"clipboard.png\"></p>\n<p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。当用户访问<a href=\"http://www.taobao.com时,dns服务器会使用轮询策略或其他策略,来选择某个ip供用户访问.此方式能实现机房间的负载均衡,至此,系统可做到机房级别的水平扩展,千万级到亿级的并发量都可通过增加机房来解决,系统入口处的请求并发量不再是问题./\">www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡，至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</a></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求</strong></p></blockquote>\n<h5 id=\"3-10-第九次演进：引入NoSQL数据库和搜索引擎等技术\"><a href=\"#3-10-第九次演进：引入NoSQL数据库和搜索引擎等技术\" class=\"headerlink\" title=\"3.10 第九次演进：引入NoSQL数据库和搜索引擎等技术\"></a>3.10 第九次演进：引入NoSQL数据库和搜索引擎等技术</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHtd.png\" alt=\"clipboard.png\"></p>\n<p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢，对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决，对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。</p>\n<p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难</strong></p></blockquote>\n<h5 id=\"3-11-第十次演进：大应用拆分为小应用\"><a href=\"#3-11-第十次演进：大应用拆分为小应用\" class=\"headerlink\" title=\"3.11 第十次演进：大应用拆分为小应用\"></a>3.11 第十次演进：大应用拆分为小应用</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHzB.png\" alt=\"clipboard.png\"></p>\n<p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级</strong></p></blockquote>\n<h5 id=\"3-12-第十一次演进：复用的功能抽离成微服务\"><a href=\"#3-12-第十一次演进：复用的功能抽离成微服务\" class=\"headerlink\" title=\"3.12 第十一次演进：复用的功能抽离成微服务\"></a>3.12 第十一次演进：复用的功能抽离成微服务</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHAs.png\" alt=\"clipboard.png\"></p>\n<p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理，这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱</strong></p></blockquote>\n<h5 id=\"3-13-第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异\"><a href=\"#3-13-第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异\" class=\"headerlink\" title=\"3.13 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异\"></a>3.13 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHBi.png\" alt=\"clipboard.png\"></p>\n<p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题，此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难</strong></p></blockquote>\n<h5 id=\"3-14-第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理\"><a href=\"#3-14-第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理\" class=\"headerlink\" title=\"3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理\"></a>3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHBG.png\" alt=\"clipboard.png\"></p>\n<p>目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。</p>\n<p>在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能，大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在3.14节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低</strong></p></blockquote>\n<h5 id=\"3-15-第十四次演进：以云平台承载系统\"><a href=\"#3-15-第十四次演进：以云平台承载系统\" class=\"headerlink\" title=\"3.15 第十四次演进：以云平台承载系统\"></a>3.15 第十四次演进：以云平台承载系统</h5><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/bVbqHDy.png\" alt=\"clipboard.png\"></p>\n<p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题，在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p>\n<p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体，在之上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用，用户不需要关系应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。在云平台中会涉及如下几个概念：</p>\n<ul>\n<li><strong>IaaS：</strong>基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</li>\n<li><strong>PaaS：</strong>平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</li>\n<li><strong>SaaS：</strong>软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>至此，以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案，但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论</strong></p></blockquote>\n<h4 id=\"4-架构设计总结\"><a href=\"#4-架构设计总结\" class=\"headerlink\" title=\"4. 架构设计总结\"></a>4. 架构设计总结</h4><ul>\n<li><strong>架构的调整是否必须按照上述演变路径进行？</strong><br>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进，在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</li>\n<li><strong>对于将要实施的系统，架构应该设计到什么程度？</strong><br>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</li>\n<li><strong>服务端架构和大数据架构有什么区别？</strong><br>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术，如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</li>\n<li><strong>有没有一些架构设计的原则？</strong><ul>\n<li>N+1设计。系统中的每个组件都应做到没有单点故障；</li>\n<li>回滚设计。确保系统可以向前兼容，在系统升级时应能有办法回滚版本；</li>\n<li>禁用设计。应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；</li>\n<li>监控设计。在设计阶段就要考虑监控的手段；</li>\n<li>多活数据中心设计。若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；</li>\n<li>采用成熟的技术。刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；</li>\n<li>资源隔离设计。应避免单一业务占用全部资源；</li>\n<li>架构应能水平扩展。系统只有做到能水平扩展，才能有效避免瓶颈问题；</li>\n<li>非核心则购买。非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；</li>\n<li>使用商用硬件。商用硬件能有效降低硬件故障的机率；</li>\n<li>快速迭代。系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；</li>\n<li>无状态设计。服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-高性能架构\"><a href=\"#4-高性能架构\" class=\"headerlink\" title=\"4.高性能架构\"></a>4.高性能架构</h3><h4 id=\"1-数据库集群\"><a href=\"#1-数据库集群\" class=\"headerlink\" title=\"1.数据库集群\"></a>1.数据库集群</h4><ol>\n<li>读写分离<ol>\n<li>原理：将数据库读写操作分散到不同的节点上，将访问压力分散到集群中的多个节点，但是没有分散存储压力</li>\n<li>基本实现：<ul>\n<li>数据库服务器搭建主从集群，一主一从，一主多从等</li>\n<li>数据库主机负责读写操作，从机只负责读操作</li>\n<li>数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据</li>\n<li>业务服务器将写操作发给数据库主机，将读操作发给数据库从机</li>\n</ul>\n</li>\n<li>主从复制延迟：（MySQL可能达到1秒）<ul>\n<li>写操作后的读操作指定发给数据库主服务器（对业务侵入和影响大）</li>\n<li>读从机失败后再读一次主机（增加主机的读操作压力）</li>\n<li>关键业务读写操作全部指向主机，非关键业务采用读写分离</li>\n</ul>\n</li>\n<li>分配机制：（实现机制）<ul>\n<li>程序代码封装（Taobao Distributed Data Layer）：在代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理（实现简单，但不通用，故障情况下主从切换需要修改配置并重启）</li>\n<li>中间件封装（MySQL Router）：独立出一套系统出来，实现读写操作分离和数据库服务器连接的管理，对于业务服务器来说，访问中间件和访问数据库没有区别（支持多种编程语言，实现复杂，性能要求高，可以探测数据库服务器的主从切换）</li>\n</ul>\n</li>\n</ol>\n</li>\n<li>分库分表<ol>\n<li>原理：按照业务模块将数据分散到不同的数据库服务器，既可以分散访问压力，又可以分散存储压力</li>\n<li>问题：无法使用SQL的join查询、无法通过事务统一修改、成本高（一般单台数据库服务器可以支撑10万用户量级的业务）</li>\n<li>分表：<ol>\n<li>垂直分表：表记录相同但包含不同的列，适合将表中某些不常用且占了大量空间的列拆分出去</li>\n<li>水平分表：表的列相同但包含不同的行，适合表行数特别大的表，当数据量达到千万级别时就需要警觉，会引入如下复杂性<ul>\n<li>路由：水平分表后，某条数据具体数据哪个切分后的子表，需要增加路由算法进行计算，常见的路由算法有：<ul>\n<li>范围路由：选取有序的数据列作为路由的条件，不同分段分散到不同的数据库表中</li>\n<li>Hash路由：选取某个列或几个列组合的值进行Hash运算，然后根据Hash结果分散到不同的数据库表中</li>\n<li>配置路由：用一张独立的路由表来记录路由信息，设计简单，使用灵活，扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了</li>\n</ul>\n</li>\n<li>join：需要在业务代码或数据库中间件进行多次join操作，然后将结果合并</li>\n<li>count()：多个count()结果相加、记录数表（新建一张表，插入删除成功都更新次表）</li>\n<li>order by：只能由业务代码或者数据库中间件分别查询每个子表中的数据，然后汇总进行排序</li>\n</ul>\n</li>\n<li>实现：和数据库读写分离类似，分库分表具体的实现方式也是程序代码封装和中间件封装</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-NoSQL\"><a href=\"#2-NoSQL\" class=\"headerlink\" title=\"2.NoSQL\"></a>2.NoSQL</h4><ol>\n<li>K-V存储：解决关系数据库无法存储数据结构的问题，但只能保证隔离性和一致性无法保证隔离性和一致性，==Redis==</li>\n<li>文档数据库：解决关系数据库强schema约束的问题，一般存储JSON格式的数据，适合电商和游戏这类业务场景，无法保证事务性，无法实现join操作，==MongoDB==</li>\n<li>列式数据库：解决关系数据库大数据场景下的I/O问题，业务同时读取多个列时效率高（不需读出整行数据），能够一次性完成对一行中的多个列的写操作，大多应用于大数据分析和统计场景，==HBase==</li>\n<li>全文搜索引擎：解决关系数据库的全文搜索性能问题，==Elasticsearch==<ol>\n<li>原理：倒排索引，建立单词到文档的索引，根据关键词来查询文档内容</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-缓存：使用程序代码实现或中间件来实现\"><a href=\"#3-缓存：使用程序代码实现或中间件来实现\" class=\"headerlink\" title=\"3.缓存：使用程序代码实现或中间件来实现\"></a>3.缓存：使用程序代码实现或中间件来实现</h4><ol>\n<li><p>缓存穿透：缓存没有发挥作用（存储数据不存在、缓存数据生成耗费大量时间或资源）</p>\n</li>\n<li><p>缓存雪崩：当缓存失效（过期）后引起系统性能急剧下降的情况</p>\n<ol>\n<li><p>更新锁机制：</p>\n<p>​        对缓存更新操作进行加锁保护，保证只有一个线程能够进行缓存更新，未能获取更新锁的线程要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</p>\n<p>​        对于采用分布式集群的业务系统，由于存在几十上百台服务器，即使单台服务器只有一个线程更新缓存，但几十上百台服务器一起算下来也会有几十上百个线程同时来更新缓存，同样存在雪崩的问题。因此分布式集群的业务系统要实现更新锁机制，需要用到分布式锁，如 ZooKeeper。</p>\n</li>\n<li><p>后台更新机制：</p>\n<p>​        由后台线程来更新缓存，而不是由业务线程来更新缓存，缓存本身的有效期设置为永久，后台线程定时更新缓存。</p>\n<p>​        当缓存系统内存不够时，会“踢掉”一些缓存数据，从缓存被“踢掉”到下一次定时更新缓存的这段时间内，业务线程读取缓存返回空值，而业务线程本身又不会去更新缓存，因此业务上看到的现象就是数据丢了，解决方式有：</p>\n<ul>\n<li>后台线程除了定时更新缓存，还要频繁地去读取缓存，如果发现缓存被“踢了”就立刻更新缓存</li>\n<li>业务线程发现缓存失效后，通过消息队列发送一条消息通知后台线程更新缓存</li>\n</ul>\n</li>\n<li><p>缓存热点：</p>\n<p>​        缓存热点的解决方案就是复制多份缓存副本，将请求分散到多个缓存服务器上，减轻缓存热点导致的单台缓存服务器压力。</p>\n<p>​        缓存副本设计有一个细节需要注意，就是不同的缓存副本不要设置统一的过期时间，否则就会出现所有缓存副本同时生成同时失效的情况，从而引发缓存雪崩效应。正确的做法是设定一个过期时间范围，不同的缓存副本的过期时间是指定范围内的随机值。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-单服务器\"><a href=\"#4-单服务器\" class=\"headerlink\" title=\"4.单服务器\"></a>4.单服务器</h4><ol>\n<li><p><strong>PPC</strong></p>\n<ol>\n<li>全称为Process per connection，即每次有新的连接就新建一个进程取专门处理这个连接的请求，实现简单，适合服务器的连接数没那么多的情况，如数据库服务器</li>\n<li>缺点：fork代价高、父子进程通信复杂（IPC）、支持的并发连接数量有限</li>\n<li>prefork：用来解决fork代价高使得用户访问时感觉响应较慢的问题，系统在启动的时候预先创建好进程，然后才开始接收用户的请求</li>\n</ol>\n</li>\n<li><p><strong>TPC</strong></p>\n<ol>\n<li>全称Thread per connection，即每次有新的连接就新建一个线程去专门处理这个连接的请求，解决fork代价高和进程通信复杂的问题</li>\n<li>缺点：高并发时还是有性能问题、进程间的互斥和共享复杂又引入死锁问题、多线程会互相影响</li>\n<li>prethread：预先创建线程。然后才开始接受用户的请求，常见的实现方式有以下几种<ul>\n<li>主进程accept，然后将连接交给某个线程处理</li>\n<li>子线程都尝试去accpet，最终只有一个线程accept成功</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Reactor（Dispatcher模式）</strong></p>\n<ol>\n<li><p>I/O多路复用+线程池</p>\n</li>\n<li><p>Reactor模式三种实现</p>\n<ul>\n<li><p>单Reactor单进程/线程：实现简单、无多核CPU优势、Handler 在处理某个连接上的业务时，整个进程无法处理其他连接的事件，==Redis==，C语言一般单进程，Java一般单线程</p>\n<ul>\n<li>Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。</li>\n<li>如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。</li>\n<li>如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的 Handler）来进行响应。</li>\n<li>Handler 会完成 read-&gt; 业务处理 -&gt;send 的完整业务流程。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/c2fafab3yybd83e97027b3e3f987f9c0.jpg\" alt=\"img\"></p>\n</li>\n<li><p>单Reactor多线程：充分利用多核CPU，但多线程数据共享和访问比较复杂，Reactor 承担所有事件的监听和响应，只在主线程中运行，瞬间高并发时会成为性能瓶颈。</p>\n<ul>\n<li>主线程中，Reactor 对象通过 select 监控连接事件，收到事件后通过 dispatch 进行分发。</li>\n<li>如果是连接建立的事件，则由 Acceptor 处理，Acceptor 通过 accept 接受连接，并创建一个 Handler 来处理连接后续的各种事件。</li>\n<li>如果不是连接建立事件，则 Reactor 会调用连接对应的 Handler（第 2 步中创建的 Handler）来进行响应。</li>\n<li>Handler 只负责响应事件，不进行业务处理；Handler 通过 read 读取到数据后，会发给 Processor 进行业务处理。</li>\n<li>Processor 会在独立的子线程中完成真正的业务处理，然后将响应结果发给主进程的 Handler 处理；Handler 收到响应后通过 send 将响应结果返回给 client。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/73a2d97c63c143a01b2e671942024fda.jpg\" alt=\"img\"></p>\n</li>\n<li><p>多Reactor多进程/线程：==Nginx 采用多 Reactor 多进程，多 Reactor 多线程的实现有 Memcache 和 Netty==</p>\n<ul>\n<li>父进程中 mainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 接收，将新的连接分配给某个子进程。</li>\n<li>子进程的 subReactor 将 mainReactor 分配的连接加入连接队列进行监听，并创建一个 Handler 用于处理连接的各种事件。</li>\n<li>当有新的事件发生时，subReactor 会调用连接对应的 Handler（即第 2 步中创建的 Handler）来进行响应。</li>\n<li>Handler 完成 read→业务处理→send 的完整业务流程。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/6cfe3c8785623f93da18ce3390e524ba.jpg\" alt=\"img\"></p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p><strong>Proactor</strong>：</p>\n<ol>\n<li><p>Reactor 可以理解为“来了事件我通知你，你来处理”，而 Proactor 可以理解为“来了事件我来处理，处理完了我通知你”</p>\n</li>\n<li><p>方案：</p>\n<ul>\n<li>Proactor Initiator 负责创建 Proactor 和 Handler，并将 Proactor 和 Handler 都通过 Asynchronous Operation Processor 注册到内核。</li>\n<li>Asynchronous Operation Processor 负责处理注册请求，并完成 I/O 操作。</li>\n<li>Asynchronous Operation Processor 完成 I/O 操作后通知 Proactor。</li>\n<li>Proactor 根据不同的事件类型回调不同的 Handler 进行业务处理。</li>\n<li>Handler 完成业务处理，Handler 也可以注册新的 Handler 到内核进程。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/f431b2674eb0881df6a1d1f77a3729fe.jpg\" alt=\"img\"></p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-集群负载均衡\"><a href=\"#5-集群负载均衡\" class=\"headerlink\" title=\"5.集群负载均衡\"></a>5.集群负载均衡</h4><ol>\n<li><p>出现原因：高性能集群的复杂性主要体现在需要增加一个负载均衡器，以及为任务选择一个合适的任务分配算法，但负载均衡不只是为了计算单元的负载达到均衡状态</p>\n</li>\n<li><p>负载均衡分类</p>\n<ol>\n<li>DNS负载均衡：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dbb61acde016acb2f57212d627d2732f.jpg\" alt=\"img\" style=\"zoom: 33%;\" /><ul>\n<li>一般用来实现地理级别的均衡，本质是DNS解析同一域名可以返回不同的IP地址，例如北京的用户访问北京的机房、南方的用户访问深圳的机房</li>\n<li>优点是：简单、成本低，就近访问提升访问速度；缺点有：更新不及时（DNS缓存的时间比较长）、扩展性差（无法对DNS负载均衡进行更改）、分配策略比较简单</li>\n</ul>\n</li>\n<li>硬件负载均衡：<ul>\n<li>通过单独的硬件设备来实现负载均衡功能，可以理解为一个用于负载均衡的基础网络设备</li>\n<li>优点是：功能强大、性能强大、稳定性高、支持安全防护，缺点有：价格昂贵、扩展能力差</li>\n</ul>\n</li>\n<li>软件负载均衡：<ul>\n<li>通过负载均衡软件来实现负载均衡功能，常见的有Nginx是软件的7层负载均衡、LVS是Linux内核的4层负载均衡，4层和7层区别就在于协议和灵活性</li>\n<li>优点是简单、便宜、灵活，缺点是：性能一般、功能没有硬件负载均衡那么强大、一般不具备防火墙和防DDoS攻击等安全功能</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>负载均衡典型架构：DNS负载均衡用于实现地理级别的负载均衡；硬件负载均衡用来实现集群级别的负载均衡；软件负载均衡用来实现机器级别的负载均衡<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/79f371ecbf74818e2a34b4a31664668d.png\" alt=\"img\"></p>\n</li>\n<li><p>算法：</p>\n<ol>\n<li><p>分类：</p>\n<ul>\n<li>任务平分类：负载均衡系统将收到的任务平均分配给服务器进行处理，这里的“平均”可以是绝对数量的平均，也可以是比例或者权重上的平均。</li>\n<li>负载均衡类：负载均衡系统根据服务器的负载来进行分配，这里的负载并不一定是通常意义上我们说的“CPU 负载”，而是系统当前的压力，可以用 CPU 负载来衡量，也可以用连接数、I/O 使用率、网卡吞吐量等来衡量系统的压力。</li>\n<li>性能最优类：负载均衡系统根据服务器的响应时间来进行任务分配，优先将新任务分配给响应最快的服务器。</li>\n<li>Hash 类：负载均衡系统根据任务中的某些关键信息进行 Hash 运算，将相同 Hash 值的请求分配到同一台服务器上。常见的有源地址 Hash、目标地址 Hash、session id hash、用户 ID Hash 等。</li>\n</ul>\n</li>\n<li><p>轮询：</p>\n<ol>\n<li>负载均衡系统收到请求后，按照顺序轮流分配到服务器上</li>\n<li>只要服务器在运行，运行状态是不关注的</li>\n</ol>\n</li>\n<li><p>加权轮询：</p>\n<ol>\n<li>负载均衡系统根据服务器权重进行任务分配，这里的权重一般是根据硬件配置进行静态配置的，采用动态的方式计算会更加契合业务，但复杂度也会更高</li>\n<li>解决不同服务器处理能力有差异的问题</li>\n</ol>\n</li>\n<li><p>负载最低优先</p>\n<ol>\n<li>负载均衡系统将任务分配给当前负载最低的服务器</li>\n<li>不同指标：<ul>\n<li>LVS 这种 4 层网络负载均衡设备，可以以“连接数”来判断服务器的状态，服务器连接数越大，表明服务器压力越大。</li>\n<li>Nginx 这种 7 层网络负载系统，可以以“HTTP 请求数”来判断服务器状态（Nginx 内置的负载均衡算法不支持这种方式，需要进行扩展）。</li>\n<li>如果我们自己开发负载均衡系统，可以根据业务特点来选择指标衡量系统压力。如果是 CPU 密集型，可以以“CPU 负载”来衡量系统压力；如果是 I/O 密集型，可以以“I/O 负载”来衡量系统压力。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>性能最优类</p>\n<ol>\n<li>负载最低优先类算法是站在服务器的角度来进行分配的，而性能最优优先类算法则是站在客户端的角度来进行分配的，优先将任务分配给处理速度最快的服务器，通过这种方式达到最快响应客户端的目的。</li>\n<li>复杂度<ul>\n<li>负载均衡系统需要收集和分析每个服务器每个任务的响应时间，在大量任务处理的场景下，这种收集和统计本身也会消耗较多的性能。</li>\n<li>为了减少这种统计上的消耗，可以采取采样的方式来统计，即不统计所有任务的响应时间，而是抽样统计部分任务的响应时间来估算整体任务的响应时间。采样统计虽然能够减少性能消耗，但使得复杂度进一步上升，因为要确定合适的采样率，采样率太低会导致结果不准确，采样率太高会导致性能消耗较大，找到合适的采样率也是一件复杂的事情。</li>\n<li>无论是全部统计还是采样统计，都需要选择合适的周期：是 10 秒内性能最优，还是 1 分钟内性能最优，还是 5 分钟内性能最优……没有放之四海而皆准的周期，需要根据实际业务进行判断和选择，这也是一件比较复杂的事情，甚至出现系统上线后需要不断地调优才能达到最优设计。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>Hash类</p>\n<ol>\n<li><strong>源地址 Hash：</strong>将来源于同一个源 IP 地址的任务分配给同一个服务器进行处理，适合于存在事务、会话的业务。例如，当我们通过浏览器登录网上银行时，会生成一个会话信息，这个会话是临时的，关闭浏览器后就失效。网上银行后台无须持久化会话信息，只需要在某台服务器上临时保存这个会话就可以了，但需要保证用户在会话存在期间，每次都能访问到同一个服务器，这种业务场景就可以用源地址 Hash 来实现。</li>\n<li><strong>ID Hash：</strong>将某个 ID 标识的业务分配到同一个服务器中进行处理，这里的 ID 一般是临时性数据的 ID（如 session id）。例如，上述的网上银行登录的例子，用 session id hash 同样可以实现同一个会话期间，用户每次都是访问到同一台服务器的目的。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-高可用架构\"><a href=\"#5-高可用架构\" class=\"headerlink\" title=\"5.高可用架构\"></a>5.高可用架构</h3><h4 id=\"1-CAP理论-1\"><a href=\"#1-CAP理论-1\" class=\"headerlink\" title=\"1.CAP理论\"></a>1.CAP理论</h4><h4 id=\"2-FMEA方法\"><a href=\"#2-FMEA方法\" class=\"headerlink\" title=\"2.FMEA方法\"></a>2.FMEA方法</h4><ol>\n<li>FMEA（Failure mode and effects analysis，故障模式与影响分析），FMEA 是一种在各行各业都有广泛应用的可用性分析方法，通过对系统范围内潜在的故障模式加以分析，并按照严重程度进行分类，以确定失效对于系统的最终影响。在软件架构设计领域，FMEA 并不能指导我们如何做架构设计，而是当我们设计出一个架构后，再使用 FMEA 对这个架构进行分析，看看架构是否还存在某些可用性的隐患。</li>\n<li>在架构设计领域，FMEA 的具体分析方法是：<ol>\n<li>给出初始的架构设计图。</li>\n<li>假设架构中某个部件发生故障。</li>\n<li>分析此故障对系统功能造成的影响。</li>\n<li>根据分析结果，判断架构是否需要进行优化。</li>\n</ol>\n</li>\n<li>FMEA 分析表<ol>\n<li>功能点：从用户角度看的，例如登录、注册</li>\n<li>故障模式：系统会出现什么样的故障，包括故障点和故障形式，不需要给出具体原因，只需要给出故障现象，并且尽量精确量化，例如MySQL响应时间达到3秒</li>\n<li>故障影响：当发生故障模式中米哦啊书的故障时，功能点具体会受到什么影响，例如：20%的用户无法登录</li>\n<li>严重程度：站在业务的角度对应的故障的影响程度，一般分为：致命/高/中/低/无，严重程度按照公式（严重程度=功能点重要程度*故障影响范围*功能点受损程度）进行评估，例如：<ol>\n<li>致命：超过 70% 用户无法登录。</li>\n<li>高：超过 30% 的用户无法登录。</li>\n<li>中：所有用户登录时间超过 5 秒、所有用户都无法修改资料。</li>\n<li>低：10% 的用户登录时间超过 5 秒、20% 的用户无法修改头像。</li>\n</ol>\n</li>\n<li>故障原因：将故障模式未列出的故障原因列出，因为：不同的故障原因发生概率不相同、检测手段和处理措施不一样</li>\n<li>故障概率：某个具体故障原因发生的概率，一般分为：高、中、低三档，要注意如下几点<ol>\n<li>硬件：随着使用时间的推移，故障概率会越来越高</li>\n<li>开源系统自研系统：成熟的开源系统bug率低，刚发布的开源系统bug率会高一些</li>\n</ol>\n</li>\n<li>风险程度：综合严重程度和故障概率来一起判断某个故障的最终等级（风险程度=严重程度*故障概率），有可能某个故障影响非常严重，但其概率很低，最终来看风险程度就很低</li>\n<li>已有措施：针对具体的故障原因，系统现在是否提供了某些措施来应对，包括检测告警、容错、自恢复等</li>\n<li>规避措施：为了降低故障发生概率而做的一些事情<ol>\n<li>技术手段：为了避免MogoDB丢失数据，在MySQL中冗余一份</li>\n<li>管理手段：为了降低磁盘坏道的概率，强制统一更换服务时间超过俩年的磁盘</li>\n</ol>\n</li>\n<li>解决措施：为了解决问题而做的一些事情：<ol>\n<li>为了解决密码暴力破解，增加密码重试次数限制</li>\n<li>为了解决拖库导致数据泄露，将数据库中的敏感数据加密保存</li>\n<li>为了解决非法访问，增加白名单控制</li>\n</ol>\n</li>\n<li>后续规划：综合前面的分析，就可以看出哪些故障我们目前还缺乏对应的措施，哪些已有措施还不够，针对这些不足的地方，再结合风险程度进行排序，给出后续的改进规划。这些规划既可以是技术手段，也可以是管理手段；可以是规避措施，也可以是解决措施。同时需要考虑资源的投入情况，优先将风险程度高的系统隐患解决。例如：<ol>\n<li>地震导致机房业务中断：这个故障模式就无法解决，只能通过备份中心规避，尽量减少影响；而机柜断电导致机房业务中断：可以通过将业务机器分散在不同机柜来规避。‘敏感数据泄露：这个故障模式可以通过数据库加密的技术手段来解决。</li>\n<li>MongoDB 断电丢数据：这个故障模式可以通过将数据冗余一份在 MySQL 中，在故障情况下重建数据来规避影响。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-存储高可用架构\"><a href=\"#3-存储高可用架构\" class=\"headerlink\" title=\"3.存储高可用架构\"></a>3.存储高可用架构</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>本质：通过将数据复制到多个存储设备，以数据冗余的方式来实现高可用</p></blockquote>\n<ol>\n<li><p>双机架构</p>\n<ol>\n<li><p>主备复制</p>\n<ol>\n<li><p>实现：几乎所有存储系统都支持，例如：MySQL、Redis、MongoDB等，内部的后台管理系统使用的多，例如学生管理系统</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509093219632.png\" alt=\"image-20220509093219632\" style=\"zoom: 50%;\" /></li>\n<li><p>优点：</p>\n<ol>\n<li>对于客户端来说，不需要感知备机的存在，即使灾难恢复后，原来的备机被人工修改为主机后，对于客户端来说，只是认为主机的地址换了而已，无须知道是原来的备机升级为主机。</li>\n<li>对于主机和备机来说，双方只需要进行数据复制即可，无须进行状态判断和主备切换这类复杂的操作。</li>\n</ol>\n</li>\n<li><p>缺点：</p>\n<ol>\n<li>备机仅仅只为备份，并没有提供读写操作，硬件成本上有浪费。</li>\n<li>故障后需要人工干预，无法自动恢复。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>主从复制</p>\n<ol>\n<li><p>实现：写少读多的业务使用的比较多。例如，论坛、BBS、新闻网站这类业务</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509093621763.png\" alt=\"image-20220509093621763\" style=\"zoom:50%;\" /></li>\n<li><p>优点</p>\n<ol>\n<li>主从复制在主机故障时，读操作相关的业务可以继续运行。</li>\n<li>主从复制架构的从机提供读操作，发挥了硬件的性能。</li>\n</ol>\n</li>\n<li><p>缺点</p>\n<ol>\n<li>客户端需要感知主从关系，并将不同的操作发给不同的机器进行处理，复杂度比主备复制要高。</li>\n<li>从机提供读业务，如果主从复制延迟比较大，业务会因为数据不一致出现问题。</li>\n<li>故障时需要人工干预。</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>双机切换（主备/主从切换）</p>\n<ol>\n<li><p>设计：</p>\n<ol>\n<li><p>系统自动决定主机角色，并完成角色切换</p>\n</li>\n<li><p>主备间状态判断</p>\n<ul>\n<li>状态传递的渠道：是相互间互相连接，还是第三方仲裁？</li>\n<li>状态检测的内容：例如机器是否掉电、进程是否存在、响应是否缓慢等。</li>\n</ul>\n</li>\n<li><p>切换决策</p>\n<ul>\n<li>切换时机：什么情况下备机应该升级为主机？是机器掉电后备机才升级，还是主机上的进程不存在就升级，还是主机响应时间超过 2 秒就升级，还是 3 分钟内主机连续重启 3 次就升级等。</li>\n<li>切换策略：原来的主机故障恢复后，要再次切换，确保原来的主机继续做主机，还是原来的主机故障恢复后自动成为新的备机？</li>\n<li>自动程度：切换是完全自动的，还是半自动的？例如，系统判断当前需要切换，但需要人工做最终的确认操作（例如，单击一下“切换”按钮）。</li>\n</ul>\n</li>\n<li><p>数据冲突解决</p>\n<p>​        当原有故障的主机恢复后，新旧主机之间可能存在数据冲突。例如，用户在旧主机上新增了一条 ID 为 100 的数据，这个数据还没有复制到旧的备机，此时发生了切换，旧的备机升级为新的主机，用户又在新的主机上新增了一条 ID 为 100 的数据，当旧的故障主机恢复后，这两条 ID 都为 100 的数据，应该怎么处理？</p>\n</li>\n</ol>\n</li>\n<li><p>常见架构</p>\n<ol>\n<li><p>互连式</p>\n<ol>\n<li><p>实现</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509094344465.png\" alt=\"image-20220509094344465\" style=\"zoom:50%;\" /></li>\n<li><p>缺点：如果状态传递的通道本身有故障（例如，网线被人不小心踢掉了），那么备机也会认为主机故障了从而将自己升级为主机，而此时主机并没有故障，最终就可能出现两个主机。虽然可以通过增加多个通道来增强状态传递的可靠性，但这样做只是降低了通道故障概率而已，不能从根本上解决这个缺点，而且通道越多，后续的状态决策会更加复杂，因为对备机来说，可能从不同的通道收到了不同甚至矛盾的状态信息。</p>\n</li>\n</ol>\n</li>\n<li><p>中介式</p>\n<ol>\n<li><p>实现</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509094723105.png\" alt=\"image-20220509094723105\" style=\"zoom:50%;\" /></li>\n<li><p>优点</p>\n<ol>\n<li>连接管理更简单：主备机无须再建立和管理多种类型的状态传递连接通道，只要连接到中介即可，实际上是降低了主备机的连接管理复杂度。</li>\n<li>状态决策更简单：主备机的状态决策简单了，无须考虑多种类型的连接通道获取的状态信息如何决策的问题，只需要按照下面简单的算法即可完成状态决策。<ul>\n<li>无论是主机还是备机，初始状态都是备机，并且只要与中介断开连接，就将自己降级为备机，因此可能出现双备机的情况。</li>\n<li>主机与中介断连后，中介能够立刻告知备机，备机将自己升级为主机。</li>\n<li>如果是网络中断导致主机与中介断连，主机自己会降级为备机，网络恢复后，旧的主机以新的备机身份向中介上报自己的状态。</li>\n<li>如果是掉电重启或者进程重启，旧的主机初始状态为备机，与中介恢复连接后，发现已经有主机了，保持自己备机状态不变。</li>\n<li>主备机与中介连接都正常的情况下，按照实际的状态决定是否进行切换。例如，主机响应时间超过 3 秒就进行切换，主机降级为备机，备机升级为主机即可。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>缺点：如果中介自己宕机了，整个系统就进入了双备的状态，写操作相关的业务就不可用了。–Zookeeper已解决</p>\n</li>\n</ol>\n</li>\n<li><p>模拟式</p>\n<ol>\n<li><p>实现：主备机之间并不传递任何状态数据，而是备机模拟成一个客户端，向主机发起模拟的读写操作，根据读写操作的响应情况来判断主机的状态</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509095629849.png\" alt=\"image-20220509095629849\" style=\"zoom:50%;\" /></li>\n<li><p>优点：实现更加简单，因为省去了状态传递通道的建立和管理工作</p>\n</li>\n<li><p>缺点：模拟式读写操作获取的状态信息只有响应信息（例如，HTTP 404，超时、响应时间超过 3 秒等），没有互连式那样多样（除了响应信息，还可以包含 CPU 负载、I/O 负载、吞吐量、响应时间等），基于有限的状态来做状态决策，可能出现偏差</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>主主复制</p>\n<ol>\n<li><p>实现：两台机器都是主机，互相将数据复制给对方，客户端可以任意挑选其中一台机器进行读写操作</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509100011572.png\" alt=\"image-20220509100011572\" style=\"zoom:50%;\" /></li>\n<li><p>如果采取主主复制架构，必须保证数据能够双向复制，而很多数据是不能双向复制的。主主复制架构对数据的设计有严格的要求，一般适合于那些临时性、可丢失、可覆盖的数据场景。例如，用户登录产生的 session 数据（可以重新登录生成）、用户行为的日志数据（可以丢失）、论坛的草稿数据（可以丢失）等</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>集群和分区</p>\n<ol>\n<li><p>数据集群</p>\n<ol>\n<li><p>数据集中集群：数据集中集群与主备、主从这类架构相似，我们也可以称数据集中集群为 1 主多备或者 1 主多从。无论是 1 主 1 从、1 主 1 备，还是 1 主多备、1 主多从，数据都只能往主机中写，而读操作可以参考主备、主从架构进行灵活多变，见Zookeeper的ZAB算法</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509101652476.png\" alt=\"image-20220509101652476\" style=\"zoom:50%;\" /></li>\n<li><p>数据分散集群：数据分散集群指多个服务器组成一个集群，每台服务器都会负责存储一部分数据；同时，为了提升硬件利用率，每台服务器又会备份一部分数据。数据分散集群中的每台服务器都可以处理读写请求，因此不存在数据集中集群中负责写的主机那样的角色。但在数据分散集群中，必须有一个角色来负责执行数据分配算法，这个角色可以是独立的一台服务器，也可以是集群自己选举出的一台服务器。如果是集群服务器选举出来一台机器承担数据分区分配的职责，则这台服务器一般也会叫作主机，但我们需要知道这里的“主机”和数据集中集群中的“主机”，其职责是有差异的。见Hadoop或Elasticsearch</p>\n</li>\n</ol>\n</li>\n<li><p>数据分区</p>\n<ol>\n<li><p>我们需要基于地理级别的故障来设计高可用架构</p>\n</li>\n<li><p>数据量：数据量越大，分区规则会越复杂</p>\n</li>\n<li><p>分区规则：地理位置有近有远，因此可以得到不同的分区规则，包括洲际分区、国家分区、城市分区。具体采取哪种或者哪几种规则，需要综合考虑业务范围、成本等因素</p>\n</li>\n<li><p>复制规则：</p>\n<ol>\n<li><p>集中式：</p>\n<ol>\n<li><p>实现：存在一个总的备份中心，所有的分区都将数据备份到备份中心</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509103404311.png\" alt=\"image-20220509103404311\" style=\"zoom:50%;\" /></li>\n<li><p>优缺点：</p>\n<ul>\n<li>设计简单，各分区之间并无直接联系，可以做到互不影响。</li>\n<li>扩展容易，如果要增加第四个分区（例如，武汉分区），只需要将武汉分区的数据复制到西安备份中心即可，其他分区不受影响。</li>\n<li>成本较高，需要建设一个独立的备份中心。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>互备式:</p>\n<ol>\n<li><p>实现：互备式备份指每个分区备份另外一个分区的数据</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509103442123.png\" alt=\"image-20220509103442123\" style=\"zoom:50%;\" /></li>\n<li><p>优缺点：</p>\n<ul>\n<li>设计比较复杂，各个分区除了要承担业务数据存储，还需要承担备份功能，相互之间互相关联和影响。</li>\n<li>扩展麻烦，如果增加一个武汉分区，则需要修改广州分区的复制指向武汉分区，然后将武汉分区的复制指向北京分区。而原有北京分区已经备份了的广州分区的数据怎么处理也是个难题，不管是做数据迁移，还是广州分区历史数据保留在北京分区，新数据备份到武汉分区，无论哪种方式都很麻烦。</li>\n<li>成本低，直接利用已有的设备。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>独立式：</p>\n<ol>\n<li><p>实现：独立式备份指每个分区自己有独立的备份中心、</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509103612491.png\" alt=\"image-20220509103612491\" style=\"zoom:50%;\" /></li>\n<li><p>优缺点：</p>\n<ul>\n<li>设计简单，各分区互不影响。</li>\n<li>扩展容易，新增加的分区只需要搭建自己的备份中心即可。</li>\n<li>成本高，每个分区需要独立的备份中心，备份中心的场地成本是主要成本，因此独立式比集中式成本要高很多。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-计算高可用架构\"><a href=\"#4-计算高可用架构\" class=\"headerlink\" title=\"4.计算高可用架构\"></a>4.计算高可用架构</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过冗余来规避部分故障的风险，单台服务器是无论如何都达不到这个目标的。所以需要通过增加更多服务器来达到计算高可用</p></blockquote>\n<ol>\n<li><p>主备</p>\n<ol>\n<li><p>实现</p>\n<ul>\n<li>主机执行所有计算任务。例如，读写数据、执行操作等。</li>\n<li>当主机故障（例如，主机宕机）时，任务分配器不会自动将计算任务发送给备机，此时系统处于不可用状态。</li>\n<li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续将任务发送给主机。</li>\n<li>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将备机升为主机，然后让任务分配器将任务发送给新的主机（即原来的备机）；同时，为了继续保持主备架构，需要人工增加新的机器作为备机。</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509104343286.png\" alt=\"image-20220509104343286\" style=\"zoom:50%;\" /></li>\n<li><p>优缺点：主备架构的优点就是简单，主备机之间不需要进行交互，状态判断和切换操作由人工执行，系统实现很简单。而缺点正好也体现在“人工操作”这点上，因为人工操作的时间不可控，可能系统已经发生问题了，但维护人员还没发现，等了 1 个小时才发现。发现后人工切换的操作效率也比较低，可能需要半个小时才完成切换操作，而且手工操作过程中容易出错。例如，修改配置文件改错了、启动了错误的程序等</p>\n</li>\n</ol>\n</li>\n<li><p>主从</p>\n<ol>\n<li><p>实现</p>\n<ul>\n<li>正常情况下，主机执行部分计算任务（如图中的“计算任务 A”），备机执行部分计算任务（如图中的“计算任务 B”）。</li>\n<li>当主机故障（例如，主机宕机）时，任务分配器不会自动将原本发送给主机的任务发送给从机，而是继续发送给主机，不管这些任务执行是否成功。</li>\n<li>如果主机能够恢复（不管是人工恢复还是自动恢复），任务分配器继续按照原有的设计策略分配任务，即计算任务 A 发送给主机，计算任务 B 发送给从机。</li>\n<li>如果主机不能够恢复（例如，机器硬盘损坏，短时间内无法恢复），则需要人工操作，将原来的从机升级为主机（一般只是修改配置即可），增加新的机器作为从机，新的从机准备就绪后，任务分配器继续按照原有的设计策略分配任务。</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509104538030.png\" alt=\"image-20220509104538030\" style=\"zoom:50%;\" /></li>\n<li><p>优缺点：优点：主从架构的从机也执行任务，发挥了从机的硬件性能。缺点：主从架构需要将任务分类，任务分配器会复杂一些。</p>\n</li>\n</ol>\n</li>\n<li><p>集群</p>\n<ol>\n<li><p>对称集群（负载均衡集群）：</p>\n<ul>\n<li>正常情况下，任务分配器采取某种策略（随机、轮询等）将计算任务分配给集群中的不同服务器。</li>\n<li>当集群中的某台服务器故障后，任务分配器不再将任务分配给它，而是将任务分配给其他服务器执行。</li>\n<li>当故障的服务器恢复后，任务分配器重新将任务分配给它执行。</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509104956152.png\" alt=\"image-20220509104956152\" style=\"zoom:33%;\" /></li>\n<li><p>非对称集群：非对称集群中不同服务器的角色是不同的，不同角色的服务器承担不同的职责。以 Master-Slave 为例，部分任务是 Master 服务器才能执行，部分任务是 Slave 服务器才能执行。</p>\n<ul>\n<li>集群会通过某种方式来区分不同服务器的角色。例如，通过 ZAB 算法选举，或者简单地取当前存活服务器中节点 ID 最小的服务器作为 Master 服务器。</li>\n<li>任务分配器将不同任务发送给不同服务器。例如，图中的计算任务 A 发送给 Master 服务器，计算任务 B 发送给 Slave 服务器。</li>\n<li>当指定类型的服务器故障时，需要重新分配角色。例如，Master 服务器故障后，需要将剩余的 Slave 服务器中的一个重新指定为 Master 服务器；如果是 Slave 服务器故障，则并不需要重新分配角色，只需要将故障服务器从集群剔除即可。</li>\n</ul>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509105012149.png\" alt=\"image-20220509105012149\" style=\"zoom:33%;\" /></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-业务高可用架构\"><a href=\"#5-业务高可用架构\" class=\"headerlink\" title=\"5.业务高可用架构\"></a>5.业务高可用架构</h4><ol>\n<li><p>异地多活架构（用来解决系统级故障）</p>\n<ol>\n<li>定义：异地就是指地理位置上不同的地方，多活就是不同地理位置的系统都能提供业务服务。例如：共享单车、滴滴出行、支付宝、微信这类业务，需要做异地多活，这类业务系统中断后，对用户的影响很大。</li>\n<li>用途：用来应对系统级的故障，例如机器宕机、机房故障和网络故障等问题</li>\n<li>架构模式：同城异区、跨城异地、跨国异地</li>\n</ol>\n</li>\n<li><p>跨城异地多活设计技巧：</p>\n<ol>\n<li>保证核心业务的异地多活</li>\n<li>保证核心数据最终一致性</li>\n<li>采用多种手段同步数据</li>\n<li>只保证绝大部分用户的异地多活</li>\n</ol>\n</li>\n<li><p>跨城异地多活设计流程：</p>\n<ol>\n<li><p>业务分级：按照一定的标准将业务进行分级，挑选出核心的业务，只为核心业务设计异地多活，降低方案整体复杂度和实现成本。常见的分级标准有下面几种：</p>\n<ol>\n<li>访问量大的业务</li>\n<li>核心业务</li>\n<li>产生大量收入的业务</li>\n</ol>\n</li>\n<li><p>数据分类：挑选出核心业务后，需要对核心业务相关的数据进一步分析，目的在于识别所有的数据及数据特征，这些数据特征会影响后面的方案设计。常见的数据特征分析维度有：</p>\n<ol>\n<li>数据量：这里的数据量包括总的数据量和新增、修改、删除的量</li>\n<li>唯一性：唯一性指数据是否要求多个异地机房产生的同类数据必须保证唯一，数据的唯一性影响业务的多活设计，如果数据不需要唯一，那就说明两个地方都产生同类数据是可能的；如果数据要求必须唯一，要么只能一个中心点产生数据，要么需要设计一个数据唯一生成的算法</li>\n<li>实时性：实时性指如果在 A 机房修改了数据，要求多长时间必须同步到 B 机房</li>\n<li>可丢失性：可丢失性指数据是否可以丢失</li>\n<li>可恢复性：可恢复性指数据丢失后，是否可以通过某种手段进行恢复，如果数据可以恢复，至少说明对业务的影响不会那么大，这样可以相应地降低异地多活架构设计的复杂度</li>\n</ol>\n</li>\n<li><p>数据同步</p>\n<ol>\n<li>存储系统同步：这是最常用也是最简单的同步方式。例如，使用 MySQL 的数据主从数据同步、主主数据同步。</li>\n<li>消息队列同步：采用独立消息队列进行数据同步，常见的消息队列有 Kafka、ActiveMQ、RocketMQ 等。消息队列同步适合无事务性或者无时序性要求的数据</li>\n<li>重复生成：数据不同步到异地机房，每个机房都可以生成数据，这个方案适合于可以重复生成的数据。例如，登录产生的 cookie、session 数据、缓存数据等</li>\n</ol>\n</li>\n<li><p>异常处理</p>\n<ol>\n<li><p>多通道同步：多通道同步的含义是采取多种方式来进行数据同步，其中某条通道故障的情况下，系统可以通过其他方式来进行同步，这种方式可以应对同步通道处故障的情况</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509170216279.png\" alt=\"image-20220509170216279\" style=\"zoom:33%;\" /></li>\n<li><p>同步和访问结合：这里的访问指异地机房通过系统的接口来进行数据访问。例如业务部署在异地两个机房 A 和 B，B 机房的业务系统通过接口来访问 A 机房的系统获取账号信息</p>\n<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220509170231490.png\" alt=\"image-20220509170231490\" style=\"zoom:33%;\" /></li>\n<li><p>日志记录：日志记录主要用于用户故障恢复后对数据进行恢复，其主要方式是每个关键操作前后都记录相关一条日志，然后将日志保存在一个独立的地方，当故障恢复后，拿出日志跟数据进行对比，对数据进行修复。常见的日志保存方式有：</p>\n<ol>\n<li>服务器上保存日志，数据库中保存数据，这种方式可以应对单台数据库服务器故障或者宕机的情况。</li>\n<li>本地独立系统保存日志，这种方式可以应对某业务服务器和数据库同时宕机的情况。例如，服务器和数据库部署在同一个机架，或者同一个电源线路上，就会出现服务器和数据库同时宕机的情况。</li>\n<li>日志异地保存，这种方式可以应对机房宕机的情况。</li>\n</ol>\n</li>\n<li><p>用户补偿</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>接口级故障</p>\n<ol>\n<li><p>表现为：系统没宕机、网络没中断、但业务却出现问题了，例如业务响应缓慢、大量访问超时和大量访问出现异常</p>\n</li>\n<li><p>出现原因：</p>\n<ol>\n<li>内部原因：程序bug导致死循环、某个接口导致数据库慢查询、程序逻辑不完善导致耗尽内存等</li>\n<li>外部原因：黑客攻击、促销或者抢购引入超出平时几倍甚至几十倍的用户、第三方系统大量请求、第三方系统响应缓慢等</li>\n<li>解决接口级故障的核心思想和异地多活一样：优先保证核心业务、优先保证绝大部分用户</li>\n</ol>\n</li>\n<li><p>常见应对方式：</p>\n<ol>\n<li><p>降级：降级指系统将某些业务或者接口的功能降低，可以是只提供部分功能，也可以是完全停掉所有功能，常见的实现降级的方式：</p>\n<ol>\n<li>系统后门降级：系统提供一个降级URL，当访问这个URL时，就相当于执行降级指令。实现成本低，但需要一台一台去操作</li>\n<li>独立系统降级：将降级操作独立到一个单独的系统中，实现复杂的权限管理、批量操作等功能</li>\n</ol>\n</li>\n<li><p>熔断：按照规则停掉外部接口的访问，防止某些外部接口故障导致自己的系统处理能力急剧下降或者出故障。==降级是应对系统自身的故障，而熔断是应对外部系统故障==。熔断机制有两个关键点：一是需要有一个统一的API调用层，二是阈值的设计</p>\n</li>\n<li><p>限流：降级是从系统功能优先级的角度考虑如何应对故障，而限流是从用户访问压力的角度来考虑如何应对故障，限流指只允许系统能够承受的访问量进来，超出系统访问能力的请求将被丢弃，常见的限流方式可以分为两类：</p>\n<ol>\n<li>基于请求限流：从外部访问的请求角度来考虑限流，常见的方式有两种：<ul>\n<li>限制总量：也就是限制某个指标的累计上限</li>\n<li>限制时间量：限制一段时间内某个指标的上限</li>\n</ul>\n</li>\n<li>基于资源限流：从内部考虑，找到系统内部影响性能的关键资源，对其使用上限进行限制，常见的内部资源包括连接数、文件句柄、线程数和请求队列</li>\n</ol>\n<p>==限流算法==：</p>\n<ol>\n<li>时间窗：会限制一定时间窗口内的请求量或者资源消耗量，根据实现方式又可以细分为固定时间窗和滑动时间窗</li>\n<li>桶算法：用一个虚拟的桶来临时存储一些东西，根据桶里面放的东西，又可以细分为漏桶（消息队列）和令牌桶</li>\n</ol>\n</li>\n<li><p>排队：实际上是限流的一个变种，限流是直接拒绝用户，排队是让用户等待一段时间，例如Kafka</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"6-分布式数据存储与分析\"><a href=\"#6-分布式数据存储与分析\" class=\"headerlink\" title=\"6.分布式数据存储与分析\"></a>6.分布式数据存储与分析</h3><h4 id=\"1-大数据技术的来龙去脉\"><a href=\"#1-大数据技术的来龙去脉\" class=\"headerlink\" title=\"1.大数据技术的来龙去脉\"></a>1.大数据技术的来龙去脉</h4><ol>\n<li><p>三架马车和基础设施</p>\n<ol>\n<li>存储-GFS<ol>\n<li>核心功能：存储数据（分布式文件系统）、并发写入（顺序写入）</li>\n<li>缺陷：缺乏高可用性、“至少一次”的弱一致性</li>\n</ol>\n</li>\n<li>计算-MapReduce<ol>\n<li>核心功能：数据本地化的并行计算、系统容错和自动恢复</li>\n<li>缺陷：计算模型简单、海量硬盘读写</li>\n</ol>\n</li>\n<li>在线服务-Bigtable<ol>\n<li>核心功能：在线服务、高性能随机读写、自动调度和分片</li>\n<li>缺陷：缺少Schema、缺少跨行事务</li>\n</ol>\n</li>\n<li>Chubby锁服务：实现了Paxos算法，保障数据一致性的分布式锁</li>\n<li>Thrift序列化：数据怎么序列化、分布式系统之间怎么通信（RPC）</li>\n</ol>\n</li>\n<li><p>OLAP和OLTP数据库</p>\n<ol>\n<li>MapReduce的发展方向<ol>\n<li>编程模型：通过一门DSL，进一步降低写MapReduce的门槛（Pig、<strong>Hive</strong>）</li>\n<li>执行引擎：延时高，没法当成交互式系统来给数据分析师使用，于是有了<strong>Dremel</strong>这个交互式查询引擎的论文，采用数据列存储+并行数据库的方式</li>\n<li>多轮迭代问题：每一个MapReduce都需要读写一次硬盘，浪费了很多的硬盘读写，于是有了<strong>Spark</strong>，通过把数据放在内存而不是硬盘里，大大提升了分布式数据计算性能</li>\n</ol>\n</li>\n<li>Bigtable的发展方向<ol>\n<li>事务问题和Schema问题，<strong>Megastore</strong>在Bigtable之上，实现了类SQL的接口，提供了Schema，以及简单的跨行事务，弥补了关系型数据库的特性</li>\n<li>异地多活和跨数据中心问题，<strong>Spanner</strong>能做到全局一致性</li>\n</ol>\n</li>\n<li><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220520140826783.png\" alt=\"image-20220520140826783\"></li>\n</ol>\n</li>\n<li><p>实时数据处理的抽象进化</p>\n<ol>\n<li>从MapReduce到Dremel，虽然查询数据的时间大大缩短了，但是计算的数据仍然是固定的、预先确定的，这样系统往往有着数分钟到数小时的数据延时，所以为了解决这个问题，流式数据处理就走上了舞台</li>\n<li>流批协同：Lambda架构，S4，Strom</li>\n<li>流批一体：Kappa架构，Kafka</li>\n<li>流式数据处理模型：Dataflow模型，Flink，Apache Beam</li>\n<li><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220520142209445.png\" alt=\"image-20220520142209445\" style=\"zoom:50%;\" /></li>\n</ol>\n</li>\n<li><p>论文脉络<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/a898bc57b976a8a6e10b84507c4ce81f.jpg\" alt=\"img\"></p>\n</li>\n<li><p>知识地图<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/928e1c25e9b4332d9d897b40de8a972d.jpg\" alt=\"img\"></p>\n</li>\n<li><p>具体技术栈</p>\n<h4 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>分布式文件存储系统</p></blockquote>\n<h5 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h5><h5 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>资源管理、调度和分配</p></blockquote>\n<h5 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h5><h4 id=\"Hive（离线）\"><a href=\"#Hive（离线）\" class=\"headerlink\" title=\"Hive（离线）\"></a>Hive（离线）</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>把SQL语言翻译成MapReduce程序</p></blockquote>\n<h4 id=\"Spark（实时）\"><a href=\"#Spark（实时）\" class=\"headerlink\" title=\"Spark（实时）\"></a>Spark（实时）</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>实时通用计算，替代MapReduce</p></blockquote>\n<h4 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>消息队列，异步、解耦、消峰</p></blockquote>\n<h4 id=\"Flink（Kafka2-0-）\"><a href=\"#Flink（Kafka2-0-）\" class=\"headerlink\" title=\"Flink（Kafka2.0?）\"></a>Flink（Kafka2.0?）</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>实时流式计算</p></blockquote>\n</li>\n</ol>\n<h4 id=\"2-分布式数据存储\"><a href=\"#2-分布式数据存储\" class=\"headerlink\" title=\"2.分布式数据存储\"></a>2.分布式数据存储</h4><ol>\n<li>Google系<ol>\n<li>GFS</li>\n<li>Colossus</li>\n<li>Bigtable<ol>\n<li>Chubby</li>\n<li>Thrift</li>\n<li>LSM-Tree</li>\n</ol>\n</li>\n<li>Megastore</li>\n<li>Spanner</li>\n<li>Dapper</li>\n<li>F1</li>\n<li>Borg</li>\n</ol>\n</li>\n<li>FaceBook：DynamoDB</li>\n<li>Amazon：Aurora</li>\n</ol>\n<h4 id=\"3-数据分析\"><a href=\"#3-数据分析\" class=\"headerlink\" title=\"3.数据分析\"></a>3.数据分析</h4><ol>\n<li>OLAP<ol>\n<li>MapReduce</li>\n<li>Hive</li>\n<li>Dremel</li>\n</ol>\n</li>\n<li>流式实时数据处理<ol>\n<li>Storm</li>\n<li>S4</li>\n<li>Kafka</li>\n<li>Kappa Architecture</li>\n<li>Dataflow</li>\n<li>Flink</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-资源调度\"><a href=\"#4-资源调度\" class=\"headerlink\" title=\"4.资源调度\"></a>4.资源调度</h4><ol>\n<li>Raft</li>\n<li>Borg</li>\n<li>Omega</li>\n<li>Kubernetes</li>\n</ol>\n<h4 id=\"5-新三驾马车\"><a href=\"#5-新三驾马车\" class=\"headerlink\" title=\"5.新三驾马车\"></a>5.新三驾马车</h4><ol>\n<li>Caffeine - Towards uniformed representation and acceleration for deep convolutional neural networks</li>\n<li>Pregel - A System for Large-Scale Graph Processing</li>\n<li>Dremel - Interactive Analysis of Web-Scale Datasets</li>\n</ol>\n<h1 id=\"Spring-Family\"><a href=\"#Spring-Family\" class=\"headerlink\" title=\"Spring Family\"></a>Spring Family</h1><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20221208162332072.png\" alt=\"image-20221208162332072\"></p>\n<h2 id=\"Spring-Framework\"><a href=\"#Spring-Framework\" class=\"headerlink\" title=\"Spring Framework\"></a>Spring Framework</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Spring是一套项目，其中最核心的是容器模块（modules of the core container），其中包括一个配置模型和一个依赖注入机制。Spring还包括消息传递、事务数据、持久化、和网络（Spring MVC、Spring WebFlux）。</p></blockquote>\n<h3 id=\"1-IOC-Container\"><a href=\"#1-IOC-Container\" class=\"headerlink\" title=\"1.IOC Container\"></a>1.IOC Container</h3><h4 id=\"1-概述-1\"><a href=\"#1-概述-1\" class=\"headerlink\" title=\"1.概述\"></a>1.概述</h4><ol>\n<li>原理：进程可以仅通过构造器参数、工厂方法参数、从工厂方法构造或返回对象实例后设置的属性来简单的定义进程的依赖。然后当创建bean的时候容器注入这些依赖。</li>\n<li>BeanFactory：通过 <code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包实现。<code>BeanFactory</code>接口提供了一种给高级配置机制，能够管理任何类型的对象，<code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，并添加了AOP特性、Event publication、应用层特性上下文（如：<code>WebApplicationContext</code>）</li>\n<li>Bean：在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。bean是由Spring IoC容器实例化、组装和管理的对象，否则，bean只是应用程序中的众多对象之一。bean以及bean之间的依赖关系反映在容器使用的配置元数据中。</li>\n</ol>\n<h4 id=\"2-Container\"><a href=\"#2-Container\" class=\"headerlink\" title=\"2.Container\"></a>2.Container</h4><ol>\n<li><p>概述：</p>\n<ol>\n<li><code>org.springframework.context.ApplicationContext</code>接口用于Spring IoC容器并且负责bean的实例化、配置、组装，容器通过读取配置元数据来获取关于要实例化、配置、组装哪些对象的指令。配置元数据可以是XML文件、Java注解、Java代码。</li>\n<li><code>ApplicationContext</code>接口的实现主要有：<code>ClassPathXmlApplicationContext</code>和 <code>FileSystemXmlApplicationContext</code></li>\n<li>一些概念：<ol>\n<li>POJO：plain old java objects简单的Java对象，一般用在数据层映射到数据库表的类，类的属性与表字段一一对应<ol>\n<li>POJO持久化之后==〉PO，persistent object，增加了一些getter、setter方法</li>\n<li>POJO传输过程中==〉DTO，data transfer object，比如一张表有100个字段，对应的PO有100个属性，但view层只需要10个字段，所以依靠只有10个属性的DTO来传输数据给client，可以提高性能</li>\n<li>POJO用作表示层==〉VO，view object，用于页面展示</li>\n</ol>\n</li>\n<li>DAO：data access object数据访问对象，用来封装对数据库的访问（CRUD），可以把POJO持久化为PO，用PO组装出VO、DTO</li>\n<li>BO：Business Object，即业务对象。一般用在业务层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递。</li>\n<li>controller层：控制请求url用哪个service层逻辑</li>\n<li>service层：带有业务逻辑的数据访问API</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>配置元数据：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans\n                           https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n\n    &lt;!-- services.xml --&gt;\n    &lt;bean id&#x3D;&quot;petStore&quot; \n          class&#x3D;&quot;org.springframework.samples.jpetstore.services.PetStoreServiceImpl&quot;&gt;\n        &lt;property name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDao&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;itemDao&quot; ref&#x3D;&quot;itemDao&quot;&#x2F;&gt;\n        &lt;!-- additional collaborators and configuration for this bean go here --&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- daos.xml --&gt;\n     &lt;bean id&#x3D;&quot;accountDao&quot;\n        class&#x3D;&quot;org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao&quot;&gt;\n        &lt;!-- additional collaborators and configuration for this bean go here --&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;itemDao&quot; \n          class&#x3D;&quot;org.springframework.samples.jpetstore.dao.jpa.JpaItemDao&quot;&gt;\n        &lt;!-- additional collaborators and configuration for this bean go here --&gt;\n    &lt;&#x2F;bean&gt;\n\n    &lt;!-- more bean definitions for data access objects go here --&gt;    \n\n&lt;&#x2F;beans&gt;</code></pre></li>\n<li><p>安装容器：<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</code>，将配置文件加载到一起的方法：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;beans&gt;\n    &lt;import resource&#x3D;&quot;services.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;resources&#x2F;messageSource.xml&quot;&#x2F;&gt;\n    &lt;import resource&#x3D;&quot;&#x2F;resources&#x2F;themeSource.xml&quot;&#x2F;&gt;\n\n    &lt;bean id&#x3D;&quot;bean1&quot; class&#x3D;&quot;...&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;bean2&quot; class&#x3D;&quot;...&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;</code></pre></li>\n<li><p>使用容器：后者使用<code>@Autowired</code>注解进行依赖注入</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; create and configure beans\nApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);\n\n&#x2F;&#x2F; retrieve configured instance\nPetStoreService service &#x3D; context.getBean(&quot;petStore&quot;, PetStoreService.class);\n\n&#x2F;&#x2F; use configured instance\nList&lt;String&gt; userList &#x3D; service.getUsernameList();</code></pre></li>\n</ol>\n<h4 id=\"3-Bean\"><a href=\"#3-Bean\" class=\"headerlink\" title=\"3.Bean\"></a>3.Bean</h4><ol>\n<li><p>概述：bean定义：包限定类名、行为方式（范围、生命周期回调）、依赖的其它bean的引用、其他配置（池的大小限制、管理连接池的bean中使用的连接数）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Property</th>\n<th align=\"left\">Explained in…</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Class</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class\">Instantiating Beans</a></td>\n</tr>\n<tr>\n<td align=\"left\">Name</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname\">Naming Beans</a></td>\n</tr>\n<tr>\n<td align=\"left\">Scope</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes\">Bean Scopes</a></td>\n</tr>\n<tr>\n<td align=\"left\">Constructor arguments</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators\">Dependency Injection</a></td>\n</tr>\n<tr>\n<td align=\"left\">Properties</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators\">Dependency Injection</a></td>\n</tr>\n<tr>\n<td align=\"left\">Autowiring mode</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire\">Autowiring Collaborators</a></td>\n</tr>\n<tr>\n<td align=\"left\">Lazy initialization mode</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lazy-init\">Lazy-initialized Beans</a></td>\n</tr>\n<tr>\n<td align=\"left\">Initialization method</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean\">Initialization Callbacks</a></td>\n</tr>\n<tr>\n<td align=\"left\">Destruction method</td>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean\">Destruction Callbacks</a></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>命名bean（Naming Beans）</p>\n<ol>\n<li>一个bean只有一个标识符，且必须在容器中是唯一的，如果需要其他的标识符，则被认为是别名（aliases），xml文件中用id属性标识，用name属性指定别名，命名规则为小写字母开头和驼峰命名</li>\n<li>在别处指定别名<code>&lt;alias name=&quot;fromName&quot; alias=&quot;toName&quot;/&gt;</code></li>\n</ol>\n</li>\n<li><p>实例化bean（Instantiating Beans）</p>\n<ol>\n<li><p>bean定义本质上是创建一个或多个对象的方法，当被访问到时，容器会查看bean的命名和定义来创建实际对象（class属性对应的类）</p>\n</li>\n<li><p>通过构造器实例化：当使用构造方法创建bean时，所有普通类都可以被Spring使用并兼容（一般为仅有默认空参构造和gettet、setter方法的类），正在开发的类不需要实现任何特定的接口或以特定的方式进行编码，只需指定bean类就足够了，但根据该特定bean的IoC类型需要一个默认空参的构造方法</p>\n</li>\n<li><p>通过静态工厂方法实例化：在定义使用静态工厂方法从创建的bean时，使用<code>class</code>属性来指定包含静态工厂方法的类，并使用名为<code>factory-method</code>的属性来指定工厂方法本身的名称。这种bean定义的用途之一是在遗留代码中调用静态工厂</p>\n<ol>\n<li><p>xml配置：<code>&lt;bean id=&quot;clientService&quot;    class=&quot;examples.ClientService&quot;    factory-method=&quot;createInstance&quot;/&gt;</code></p>\n</li>\n<li><p>使用：一个可与上面的bean定义一起工作的类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ClientService &#123;\n    private static ClientService clientService &#x3D; new ClientService();\n    private ClientService() &#123;&#125;\n\n    public static ClientService createInstance() &#123;\n        return clientService;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>通过实例工厂方法实例化：与通过静态工厂方法进行实例化类似，使用实例工厂方法进行实例化从容器中调用现有bean的非静态方法来创建新bean。<code>class</code>属性需要为空，并在<code>factory-bean</code>属性中指定当前（或父级或祖先）容器中的bean名称（包含要调用以创建对象的实例方法），使用<code>factory-method</code>属性设置工厂方法本身的名称</p>\n<ol>\n<li><p>xml文件</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;\n&lt;bean id&#x3D;&quot;serviceLocator&quot; class&#x3D;&quot;examples.DefaultServiceLocator&quot;&gt;\n    &lt;!-- inject any dependencies required by this locator bean --&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;clientService&quot;\n    factory-bean&#x3D;&quot;serviceLocator&quot;\n    factory-method&#x3D;&quot;createClientServiceInstance&quot;&#x2F;&gt;\n\n&lt;bean id&#x3D;&quot;accountService&quot;\n    factory-bean&#x3D;&quot;serviceLocator&quot;\n    factory-method&#x3D;&quot;createAccountServiceInstance&quot;&#x2F;</code></pre></li>\n<li><p>相关类：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DefaultServiceLocator &#123;\n\n    private static ClientService clientService &#x3D; new ClientServiceImpl();\n    private static AccountService accountService &#x3D; new AccountServiceImpl();\n\n    public ClientService createClientServiceInstance() &#123;\n        return clientService;\n    &#125;\n\n    public AccountService createAccountServiceInstance() &#123;\n        return accountService;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>确定bean的运行时类型：对指定bean名称的<code>BeanFactory.getType</code>调用</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"4-Dpendencies\"><a href=\"#4-Dpendencies\" class=\"headerlink\" title=\"4.Dpendencies\"></a>4.Dpendencies</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何从多个独立的bean定义到完全实现的应用程序</p></blockquote>\n<ol>\n<li><p>依赖注入</p>\n<ol>\n<li><p>定义：通过定义需要的依赖，并将这些依赖注入到bean中，这个过程是直接构造实例的逆过程。可以使得代码更简洁，更方便测试。对强制依赖项使用构造函数，对可选依赖使用setter方法。</p>\n</li>\n<li><p>基于构造器的依赖注入：通过容器调用具有多个参数的构造函数来完成，每个参数代表一个依赖项，构造器可以有多个参数，<code>&lt;constructor-arg ....../&gt;</code></p>\n<ol>\n<li><p>xml</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;\n    &lt;!-- constructor injection using the nested ref element --&gt;\n    &lt;constructor-arg&gt;\n        &lt;ref bean&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;\n    &lt;&#x2F;constructor-arg&gt;\n    &lt;!-- constructor injection using the neater ref attribute --&gt;\n    &lt;constructor-arg ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;\n    &lt;constructor-arg type&#x3D;&quot;int&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;anotherExampleBean&quot; class&#x3D;&quot;examples.AnotherBean&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;yetAnotherBean&quot; class&#x3D;&quot;examples.YetAnotherBean&quot;&#x2F;&gt;</code></pre></li>\n<li><p>java</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ExampleBean &#123;\n\n    private AnotherBean beanOne;\n    private YetAnotherBean beanTwo;\n    private int i;\n\n    public ExampleBean(\n        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) &#123;\n        this.beanOne &#x3D; anotherBean;\n        this.beanTwo &#x3D; yetAnotherBean;\n        this.i &#x3D; i;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>基于Setter的依赖注入：是通过容器在调用无参构造函数来实例化bean后调用bean上的settet方法来完成的</p>\n<ol>\n<li><p>xml</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;exampleBean&quot; class&#x3D;&quot;examples.ExampleBean&quot;&gt;\n    &lt;!-- setter injection using the nested ref element --&gt;\n    &lt;property name&#x3D;&quot;beanOne&quot;&gt;\n        &lt;ref bean&#x3D;&quot;anotherExampleBean&quot;&#x2F;&gt;\n    &lt;&#x2F;property&gt;\n    &lt;!-- setter injection using the neater ref attribute --&gt;\n    &lt;property name&#x3D;&quot;beanTwo&quot; ref&#x3D;&quot;yetAnotherBean&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;integerProperty&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n&lt;bean id&#x3D;&quot;anotherExampleBean&quot; class&#x3D;&quot;examples.AnotherBean&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;yetAnotherBean&quot; class&#x3D;&quot;examples.YetAnotherBean&quot;&#x2F;&gt;</code></pre></li>\n<li><p>java</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ExampleBean &#123;\n\n    private AnotherBean beanOne;\n    private YetAnotherBean beanTwo;\n    private int i;\n\n    public void setBeanOne(AnotherBean beanOne) &#123;\n        this.beanOne &#x3D; beanOne;\n    &#125;\n\n    public void setBeanTwo(YetAnotherBean beanTwo) &#123;\n        this.beanTwo &#x3D; beanTwo;\n    &#125;\n\n    public void setIntegerProperty(int i) &#123;\n        this.i &#x3D; i;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>一般都用xml、注解（<code>@controller</code>、<code>@Component</code>）、<code>@Bean</code>，</p>\n</li>\n</ol>\n</li>\n<li><p>依赖注入处理流程：</p>\n<ol>\n<li>通过所有bean的元数据的描述构造并初始化<code>ApplicationContext</code></li>\n<li>对每一个bean，它的依赖关系以属性、构造函数或静态工厂方法的参数的形式表示，并在实际创建bean时提供给bean</li>\n<li>每个属性或构造函数参数都是要设置的值的实际定义，或是对容器中另一个bean的引用</li>\n<li>作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型</li>\n</ol>\n</li>\n<li><p>其他细节</p>\n<ol>\n<li><p>Straight Values（原语、字符串） <code>&lt;property/&gt;</code> 的<code>value</code>属性</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;myDataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;\n    &lt;!-- results in a setDriverClassName(String) call --&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;misterkaoli&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p>内嵌bean</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;outer&quot; class&#x3D;&quot;...&quot;&gt;\n    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;\n    &lt;property name&#x3D;&quot;target&quot;&gt;\n        &lt;bean class&#x3D;&quot;com.example.Person&quot;&gt; &lt;!-- this is the inner bean --&gt;\n            &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;Fiona Apple&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;25&quot;&#x2F;&gt;\n        &lt;&#x2F;bean&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n<li><p>集合</p>\n</li>\n<li><p>P命名空间、C命名空间</p>\n</li>\n</ol>\n</li>\n<li><p>延迟初始化bean：单例bean常常会很早初始化，当不需要提前初始化bean来验证错误时，可以将bean定义标记为延迟初始化来防止单例bean的预实例化。lazy bean不会被太早实例化，not.lazy bean会被很早实例化</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;lazy&quot; class&#x3D;&quot;com.something.ExpensiveToCreateBean&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean name&#x3D;&quot;not.lazy&quot; class&#x3D;&quot;com.something.AnotherBean&quot;&#x2F;&gt;</code></pre></li>\n<li><p>自动装配</p>\n<ol>\n<li>自动装配的四种模式<ul>\n<li><code>no</code>：不自动装配，bean引用必须有ref元素定义</li>\n<li><code>byName</code>：按属性名自动装配，Spring寻找与需要自动装配的属性同名的bean，例如有setMaster()方法的bean会去找名为master的bean定义</li>\n<li><code>byType</code>：如果容器中恰好存在一个属性类型的bean，则让属性自动装配；如果存在多个，则需要使用byType自动装配</li>\n<li><code>constructor</code>：与byType类似，但适用于构造函数参数，如果容器中没有一个构造函数参数类型的bean，则会引发致命错误</li>\n</ul>\n</li>\n<li>推荐在项目中一直使用自动装配，否则会混淆，自动装配设施无法使用注释样式配置，例如<code>@Autowired</code></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"5-Bean-Scopes\"><a href=\"#5-Bean-Scopes\" class=\"headerlink\" title=\"5.Bean Scopes\"></a>5.Bean Scopes</h4><ol>\n<li><p>概览：后四个仅在web相关的Spring <code>ApplicationContext</code>生效</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Scope</th>\n<th align=\"left\">Description</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton\">singleton</a></td>\n<td align=\"left\">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype\">prototype</a></td>\n<td align=\"left\">Scopes a single bean definition to any number of object instances.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request\">request</a></td>\n<td align=\"left\">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session\">session</a></td>\n<td align=\"left\">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application\">application</a></td>\n<td align=\"left\">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>.</td>\n</tr>\n<tr>\n<td align=\"left\"><a href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope\">websocket</a></td>\n<td align=\"left\">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>.</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>singleton：<code>&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;singleton&quot;/&gt;</code></p>\n</li>\n<li><p>prototype：<code>&lt;bean id=&quot;accountService&quot; class=&quot;com.something.DefaultAccountService&quot; scope=&quot;prototype&quot;/&gt;</code></p>\n</li>\n<li><p>web相关：</p>\n<ol>\n<li><p>初始化配置</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--启动服务器时，通过监听器加载spring运行环境--&gt;\n  &lt;listener&gt;\n    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;\n  &lt;&#x2F;listener&gt;\n&lt;!--将HTTP请求对象绑定到为该请求提供服务的线程--&gt;\n  &lt;filter&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;&#x2F;filter-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;encoding&lt;&#x2F;param-name&gt;\n      &lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;\n    &lt;&#x2F;init-param&gt;\n  &lt;&#x2F;filter&gt;\n  &lt;filter-mapping&gt;\n    &lt;filter-name&gt;CharacterEncodingFilter&lt;&#x2F;filter-name&gt;\n    &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;\n  &lt;&#x2F;filter-mapping&gt;</code></pre></li>\n<li><p>通过注解来定义scope</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"6-Container-Extension-Points\"><a href=\"#6-Container-Extension-Points\" class=\"headerlink\" title=\"6.Container Extension Points\"></a>6.Container Extension Points</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Spring可以通过插入特殊集成接口的实现来扩展IoC容器</p></blockquote>\n<ol>\n<li><p><code>BeanPostProcessor</code></p>\n<ol>\n<li><p>通过实现其提供的回调方法，来提供定制的实例化逻辑、依赖解析逻辑。可以在Spring容器完成实例化、配置和初始化bean之后，<code>BeanPostProcessor</code>实例开始进行自己的工作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface BeanPostProcessor &#123;\n    @Nullable\n    default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;return bean;&#125;\n    @Nullable\n    default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;return bean;&#125;\n&#125;</code></pre></li>\n<li><p>AOP自动代理就是<code>BeanPostProcessor</code>的实现，在系统启动的时候就全加载好</p>\n</li>\n<li><p>使用：通过实现<code>BeanPostProcessor</code>接口的方法，并注册成bean，来在其它bean初始化的前后进行定制操作，一个例子是：Spring的实现类<code>AutowiredAnnotationBeanPostProcessor</code></p>\n</li>\n</ol>\n</li>\n<li><p><code>BeanFactoryPostProcessor</code></p>\n<ol>\n<li><p>与<code>BeanPostProcessor</code>的一个主要区别是<code>BeanFactoryPostProcessor</code>对bean配置元数据进行操作，也就是说IoC容器允许<code>BeanFactoryPostProcessor</code>读取配置元数据，并可能在容器实例化除<code>BeanFactoryPostProcessor</code>实例之外的任何bean之前更改它</p>\n</li>\n<li><p>Spring中预定义的：</p>\n<ol>\n<li><p><code>PropertyOverrideConfigurer</code></p>\n</li>\n<li><p><code>PropertySourcesPlaceholderConfigurer</code>：可以使用标准Java属性格式将bean定义中的属性值外化到单独的文件中，例如可以不用改xml就可以自定义数据库的URL和密码。在运行时，<code>PropertySourcesPlaceholderConfigurer</code>应用于替换DataSource的某些属性的元数据，真实值来自外部的<code>jdbc.properties</code>文件</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!--加载properties文件--&gt;\n&lt;context:property-placeholder location&#x3D;&quot;classpath*:jdbc.properties&quot;&#x2F;&gt;\n&lt;!--数据源--&gt;\n&lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><code>FactoryBean</code></p>\n</li>\n</ol>\n<h4 id=\"7-基于注解的容器配置\"><a href=\"#7-基于注解的容器配置\" class=\"headerlink\" title=\"7.基于注解的容器配置\"></a>7.基于注解的容器配置</h4><ol>\n<li><p>可以将post-processor注册为单独的bean，也可以在xml中加<code>&lt;context:annotation-config/&gt;</code>，这个元素隐式注册了：</p>\n<ul>\n<li><code>ConfigurationClassPostProcessor</code></li>\n<li><code>AutowiredAnnotationBeanPostProcessor</code></li>\n<li><code>CommonAnnotationBeanPostProcessor</code></li>\n<li><code>PersistenceAnnotationBeanPostProcessor</code></li>\n<li><code>EventListenerMethodProcessor</code></li>\n</ul>\n</li>\n<li><p><del><code>@Required</code></del>：用于bean属性setter方法，相关属性必须通过bean定义中显示属性值或自动装配来填充。（需要提前将<code>RequiredAnnotationBeanPostProcessor</code>注册为bean），Spring5.1弃用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SimpleMovieLister &#123;\n    private MovieFinder movieFinder;\n    @Required\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@Autowired</code>：原理见自动装配</p>\n<ol>\n<li><p>用在构造函数上，Spring4.3开始不再需要，但如果有多个构造函数则需要使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n    private final CustomerPreferenceDao customerPreferenceDao;\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>用于传统的setter方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SimpleMovieLister \n    private MovieFinder movieFinder;\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>用于字段，甚至可以将其与构造函数混用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n    @Autowired\n    private MovieCatalog movieCatalog;\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p><code>@Primary</code>表示当多个bean成为自动装配的候选者时，应该优先考虑特定的bean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MovieConfiguration &#123;\n\n    @Bean\n    @Primary\n    public MovieCatalog firstMovieCatalog() &#123; ... &#125;\n\n    @Bean\n    public MovieCatalog secondMovieCatalog() &#123; ... &#125;\n    &#x2F;&#x2F; ...\n&#125;\npublic class MovieRecommender &#123;\n\t&#x2F;&#x2F;自动装配firstMovieCatalog\n    @Autowired\n    private MovieCatalog movieCatalog;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@Qualifier</code>：可以将限定符值与特定参数相关联，缩小类型匹配的范围，以便为每个参数选择特定的bean：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog,\n                        CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog &#x3D; movieCatalog;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@Resource</code>：采用名称属性，默认将该值解释为要注入的bean名称，如果没有明确指定名称，如果是字段，则采用字段名称，如果是setter方法，则采用bean属性名称</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n    @Resource(name&#x3D;&quot;myMovieFinder&quot;) \n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n&#125;</code></pre></li>\n<li><p><code>@Value</code>：通常用于注入外部化属性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class MovieRecommender &#123;\n\n    private final String catalog;\n    &#x2F;&#x2F;application.properties中有catalog.name&#x3D;MovieCatalog\n    &#x2F;&#x2F;catalog的值就为MovieCatalog\n    public MovieRecommender(@Value(&quot;$&#123;catalog.name&#125;&quot;) String catalog) &#123;\n        this.catalog &#x3D; catalog;\n    &#125;\n&#125;\n&#x2F;&#x2F;还需以下配置\n@Configuration\n@PropertySource(&quot;classpath:application.properties&quot;)\npublic class AppConfig &#123; &#125;</code></pre></li>\n<li><p><code>@PostConstruct</code>&amp;<code>@PreDestroy</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CachingMovieLister &#123;\n\n    @PostConstruct\n    public void populateMovieCache() &#123;\n        &#x2F;&#x2F; populates the movie cache upon initialization...\n    &#125;\n\n    @PreDestroy\n    public void clearMovieCache() &#123;\n        &#x2F;&#x2F; clears the movie cache upon destruction...\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"8-基于Java的容器配置\"><a href=\"#8-基于Java的容器配置\" class=\"headerlink\" title=\"8.基于Java的容器配置\"></a>8.基于Java的容器配置</h4><ol>\n<li><p><code>@Compoent</code>：</p>\n<ol>\n<li><p>任何满足存储库角色（DAO）的类的标记，用途是异常的自动翻译，类似的其它原型注解有：<code>@Controller（表示层）</code>、<code>@Service（服务层）</code>、<code>@Repository（持久层）</code>，尽量不选<code>@Component</code>而选后面那三个</p>\n</li>\n<li><p>Spring能自动检测原型类，并使用<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例，要自动检测这些类并注册相应的bean，需要将<code>@ComponentScan(basePackages = &quot;org.example&quot;)</code>添加到<code>@Configuration</code>类中</p>\n</li>\n<li><p>用<code>@Component</code>定义bean元数据：将bean定义元数据贡献给容器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class FactoryMethodComponent &#123;\n    @Bean\t&#x2F;&#x2F;表示工厂方法和其它bean定义属性\n    @Qualifier(&quot;public&quot;)\n    public TestBean publicInstance() &#123;\n        return new TestBean(&quot;publicInstance&quot;);\n    &#125;\n\n    public void doWork() &#123;\n        &#x2F;&#x2F; Component method implementation omitted\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p><code>@Configuration</code></p>\n<ol>\n<li><p>用<code>@Configuration</code>注释一个类表明一个对象时bean定义的来源，此外，<code>Configuration</code>类允许通过调用同一类中的其它<code>@Bean</code>方法来定义bean间的依赖关系</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class AppConfig &#123;\n    @Bean\n    public MyService myService() &#123;\n        return new MyServiceImpl();\n    &#125;\n&#125;\n&#x2F;&#x2F;与下面xml语句相同：\n&#x2F;&#x2F;&lt;beans&gt;\n&#x2F;&#x2F;    &lt;bean id&#x3D;&quot;myService&quot; class&#x3D;&quot;com.acme.services.MyServiceImpl&quot;&#x2F;&gt;\n&#x2F;&#x2F;&lt;&#x2F;beans&gt;</code></pre></li>\n<li><p>当<code>@Configuration</code>类作为输入提供时，<code>@Configuration</code>类本身被注册为bean定义，并且类中所有声明的<code>@Bean</code>方法也被注册为bean定义，使用<code>AnnotationConfigApplicationContext</code>访问</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n    MyService myService &#x3D; ctx.getBean(MyService.class);\n    myService.doStuff();\n&#125;</code></pre></li>\n<li></li>\n</ol>\n</li>\n<li><p><code>@Bean</code></p>\n<ol>\n<li><p>用于表示一个方法实例化、配置和初始化一个由IoC容器管理的新对象，与<code>&lt;beans/&gt;</code>元素的作用相同。可以使用此方法来制定为方法返回值的类型的<code>ApplicationContext</code>中注册bean定义。可以和任何Spring的<code>@Component</code>一起使用，但是通常与<code>@Configuration</code>bean一起使用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class AppConfig &#123;\n    @Bean&#x2F;&#x2F;默认情况，bean名称与方法名称相同\n    public TransferServiceImpl transferService() &#123;\n        return new TransferServiceImpl();\n    &#125;\n    &#x2F;&#x2F;可以有任意数量的参数来描述构建该bean所需的依赖项\n    &#x2F;&#x2F;@Bean\n    &#x2F;&#x2F; public TransferService transferService(AccountRepository accountRepository) &#123;\n    &#x2F;&#x2F;     return new TransferServiceImpl(accountRepository);\n    &#x2F;&#x2F;&#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p><code>@Import</code>：</p>\n<ol>\n<li><p>从另一个配置类加载<code>@Bean</code>定义：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class ServiceConfig &#123;\n    @Bean\n    public TransferService transferService(AccountRepository accountRepository) &#123;\n        return new TransferServiceImpl(accountRepository);\n    &#125;\n&#125;\n@Configuration\npublic class RepositoryConfig &#123;\n    @Bean\n    public AccountRepository accountRepository(DataSource dataSource) &#123;\n        return new JdbcAccountRepository(dataSource);\n    &#125;\n&#125;\n@Configuration\n@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)\npublic class SystemTestConfig &#123;\n    @Bean\n    public DataSource dataSource() &#123;\n        &#x2F;&#x2F; return new DataSource\n    &#125;\n&#125;\npublic static void main(String[] args) &#123;\n    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SystemTestConfig.class);\n    &#x2F;&#x2F; everything wires up across configuration classes...\n    TransferService transferService &#x3D; ctx.getBean(TransferService.class);\n    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);\n&#125;</code></pre></li>\n<li><p>自动装配</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class ServiceConfig &#123;\n    @Autowired\n    private AccountRepository accountRepository;\n    @Bean\n    public TransferService transferService() &#123;\n        return new TransferServiceImpl(accountRepository);\n    &#125;\n&#125;\n\n@Configuration\npublic class RepositoryConfig &#123;\n    &#x2F;&#x2F;bean仅定义一个构造函数，则无需指定指定@Autowired\n    private final DataSource dataSource;\n    public RepositoryConfig(DataSource dataSource) &#123;\n        this.dataSource &#x3D; dataSource;\n    &#125;\n    @Bean\n    public AccountRepository accountRepository() &#123;\n        return new JdbcAccountRepository(dataSource);\n    &#125;\n&#125;\n@Configuration\n@Import(&#123;ServiceConfig.class, RepositoryConfig.class&#125;)\npublic class SystemTestConfig &#123;\n    @Bean\n    public DataSource dataSource() &#123;\n        &#x2F;&#x2F; return new DataSource\n    &#125;\n&#125;\npublic static void main(String[] args) &#123;\n    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(SystemTestConfig.class);\n    &#x2F;&#x2F; everything wires up across configuration classes...\n    TransferService transferService &#x3D; ctx.getBean(TransferService.class);\n    transferService.transfer(100.00, &quot;A123&quot;, &quot;C456&quot;);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-AOP\"><a href=\"#2-AOP\" class=\"headerlink\" title=\"2.AOP\"></a>2.AOP</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>面向切面编程通过提供另一种思考程序结构的方式来补充面向对象编程，提供了中间件解决方案</p></blockquote>\n<h4 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><ol>\n<li>Aspect：跨多个类的关注点的模块化，例如事务管理</li>\n<li>Join point：程序执行过程中的一个点，例如方法的执行和异常的处理</li>\n<li>Advice：Aspect在特定的Join point采取的行动，包括around、before、after（running、throwing、finally）</li>\n<li>pointcut：匹配连接点的谓词，Advice和pointcut表达式相关联，并在任何与pointcut匹配的join point运行，例如执行具有特定名称的方法</li>\n<li>Introduction：代表一个类型声明额外的方法或字段，例如可以使用introduction让bean实现isModified接口，来简化缓存</li>\n<li>Target object：An object being advised by one or more aspects，即被代理对象</li>\n<li>AOP proxy：由AOP框架创建的对象，用于实现aspect</li>\n<li>Weaving：将apsects和其他应用程序类型或对象链接以创建建议对象</li>\n</ol>\n<h4 id=\"2-AspectJ\"><a href=\"#2-AspectJ\" class=\"headerlink\" title=\"2.@AspectJ\"></a>2.<code>@AspectJ</code></h4><ol>\n<li><p>配置启用<code>@AspectJ</code>支持</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n@EnableAspectJAutoProxy\npublic class AppConfig &#123;\n\n&#125;</code></pre></li>\n<li><p>声明一个切面（aspect）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Aspect\npublic class NotVeryUsefulAspect &#123;\n\n&#125;</code></pre></li>\n<li><p>声明一个切点（pointcut），有很多方式，详见文档</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;名为anyOldTransfer的切入点，与任何名为transfer的方法执行相匹配\n@Pointcut(&quot;execution(* transfer(..))&quot;) &#x2F;&#x2F; the pointcut expression\nprivate void anyOldTransfer() &#123;&#125; &#x2F;&#x2F; the pointcut signature</code></pre></li>\n<li><p>声明一个建议（advice）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Aspect\npublic class BeforeExample &#123;\n    @Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)\n    public void doAccessCheck() &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n@Aspect\npublic class AfterReturningExample &#123;\n    @AfterReturning(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)\n    public void doAccessCheck() &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;\n@Aspect\npublic class AroundExample &#123;\n    @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;)\n    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;\n        &#x2F;&#x2F; start stopwatch\n        Object retVal &#x3D; pjp.proceed();\n        &#x2F;&#x2F; stop stopwatch\n        return retVal;\n    &#125;\n&#125;</code></pre></li>\n<li><p>例子</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Aspect\npublic class ConcurrentOperationExecutor implements Ordered &#123;\n\n    private static final int DEFAULT_MAX_RETRIES &#x3D; 2;\n\n    private int maxRetries &#x3D; DEFAULT_MAX_RETRIES;\n    private int order &#x3D; 1;\n\n    public void setMaxRetries(int maxRetries) &#123;\n        this.maxRetries &#x3D; maxRetries;\n    &#125;\n\n    public int getOrder() &#123;\n        return this.order;\n    &#125;\n\n    public void setOrder(int order) &#123;\n        this.order &#x3D; order;\n    &#125;\n\n    @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;)\n    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;\n        int numAttempts &#x3D; 0;\n        PessimisticLockingFailureException lockFailureException;\n        do &#123;\n            numAttempts++;\n            try &#123;\n                return pjp.proceed();\n            &#125;\n            catch(PessimisticLockingFailureException ex) &#123;\n                lockFailureException &#x3D; ex;\n            &#125;\n        &#125; while(numAttempts &lt;&#x3D; this.maxRetries);\n        throw lockFailureException;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"3-Data-Access\"><a href=\"#3-Data-Access\" class=\"headerlink\" title=\"3.Data Access\"></a>3.Data Access</h3><h4 id=\"1-Transaction-Management\"><a href=\"#1-Transaction-Management\" class=\"headerlink\" title=\"1.Transaction Management\"></a>1.Transaction Management</h4><ol>\n<li><p>事务抽象，其余的去实现如下方法</p>\n<ol>\n<li><p>imperative transaction management </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface PlatformTransactionManager extends TransactionManager &#123;\n    TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;\n    void commit(TransactionStatus status) throws TransactionException;\n    void rollback(TransactionStatus status) throws TransactionException;\n&#125;</code></pre></li>\n<li><p>reactive transaction management</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ReactiveTransactionManager extends TransactionManager &#123;\n    Mono&lt;ReactiveTransaction&gt; getReactiveTransaction(TransactionDefinition definition) throws TransactionException;\n    Mono&lt;Void&gt; commit(ReactiveTransaction status) throws TransactionException;\n    Mono&lt;Void&gt; rollback(ReactiveTransaction status) throws TransactionException;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>声明式事务管理（Declarative）</p>\n<ol>\n<li>开启事务注解的方式：<code>@EnableTransactionManagement</code></li>\n<li><code>@Transactional</code>：<ul>\n<li>transactionManager</li>\n<li>==propagation==<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220710093829564.png\" alt=\"image-20220710093829564\"></li>\n<li>isolation<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220710093852764.png\" alt=\"image-20220710093852764\"></li>\n<li>timeout</li>\n<li>readOnly</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>编程式事务管理（Programmatic）</p>\n<ol>\n<li><p>TransactionTemplate</p>\n<ol>\n<li>TransactionCallback</li>\n<li>TransactionCallbackWithoutResult</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\n@Slf4j\npublic class ProgrammaticTransactionDemoApplication implements CommandLineRunner &#123;\n    @Autowired\n    private TransactionTemplate transactionTemplate;\n    @Autowired\n    private JdbcTemplate jdbcTemplate;\n    \n    public static void main(String[] args) &#123;\n        SpringApplication.run(ProgrammaticTransactionDemoApplication.class, args);\n    &#125;\n    @Override\n    public void run(String... args) throws Exception &#123;\n        transactionTemplate.execute(new TransactionCallbackWithoutResult() &#123;\n            @Override\n            protected void doInTransactionWithoutResult(TransactionStatus transactionStatus) &#123;\n                jdbcTemplate.execute(&quot;INSERT INTO FOO (ID, BAR) VALUES (1, &#39;aaa&#39;)&quot;);\n                transactionStatus.setRollbackOnly();\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>TransactionOperation</p>\n</li>\n<li><p>PlatformTransactionManager</p>\n<ol>\n<li>可以传入TransactionDefinition进行定义</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-JDBC\"><a href=\"#2-JDBC\" class=\"headerlink\" title=\"2.JDBC\"></a>2.JDBC</h4><ol>\n<li><p>包层次结构</p>\n<ul>\n<li><code>org.springframework.jdbc.core</code>：<code>JdbcTemplate</code>、simple子包中<code>simpleJdbcInsert</code>、<code>SimpleJdbcCal</code>l类、namedparam子包中<code>NamedParameterJdbcTemplate</code></li>\n<li><code>org.springframework.jdbc.datasource</code>：DataSource类、embedded子包中内嵌数据库的支持（HSQL、H2、Derby）</li>\n<li><code>org.springframework.jdbc.object</code>：关系数据库的查询、更新、存储程序</li>\n<li><code>org.springframework.jdbc.support</code>：<code>SQLException</code>、一些工具类</li>\n</ul>\n</li>\n<li><p>JDBC Processing</p>\n<ol>\n<li><p>JdbcTemplate</p>\n<ol>\n<li><p>可以处理资源的创建和释放，主要用于运行数据库的查询、更新、存储，对ResultSet实例执行迭代并提取返回的参数值，捕获JDBC异常并翻译成通用的。方法有：query、queryForObject、queryForList、update、execute</p>\n</li>\n<li><p>Querying</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;返回整数\nint countOfActorsNamedJoe &#x3D; this.jdbcTemplate.queryForObject(\n        &quot;select count(*) from t_actor where first_name &#x3D; ?&quot;, Integer.class, &quot;Joe&quot;);\n&#x2F;&#x2F;返回String\nString lastName &#x3D; this.jdbcTemplate.queryForObject(\n        &quot;select last_name from t_actor where id &#x3D; ?&quot;,String.class, 1212L);\n&#x2F;&#x2F;返回 single domain对象\nActor actor &#x3D; jdbcTemplate.queryForObject(\n        &quot;select first_name, last_name from t_actor where id &#x3D; ?&quot;,\n        (resultSet, rowNum) -&gt; &#123;\n            Actor newActor &#x3D; new Actor();\n            newActor.setFirstName(resultSet.getString(&quot;first_name&quot;));\n            newActor.setLastName(resultSet.getString(&quot;last_name&quot;));\n            return newActor;\n        &#125;,\n        1212L);\n&#x2F;&#x2F;返回链表\nList&lt;Actor&gt; actors &#x3D; this.jdbcTemplate.query(\n        &quot;select first_name, last_name from t_actor&quot;,\n        (resultSet, rowNum) -&gt; &#123;\n            Actor actor &#x3D; new Actor();\n            actor.setFirstName(resultSet.getString(&quot;first_name&quot;));\n            actor.setLastName(resultSet.getString(&quot;last_name&quot;));\n            return actor;\n        &#125;);</code></pre></li>\n<li><p>Updating</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;插入\nthis.jdbcTemplate.update(\n        &quot;insert into t_actor (first_name, last_name) values (?, ?)&quot;,\n        &quot;Leonor&quot;, &quot;Watling&quot;);\n&#x2F;&#x2F;更新\nthis.jdbcTemplate.update(\n        &quot;update t_actor set last_name &#x3D; ? where id &#x3D; ?&quot;,\n        &quot;Banjo&quot;, 5276L);\n&#x2F;&#x2F;删除\nthis.jdbcTemplate.update(\n        &quot;delete from t_actor where id &#x3D; ?&quot;,\n        Long.valueOf(actorId));</code></pre></li>\n<li><p>execute可执行一切SQL语句：<code>this.jdbcTemplate.execute(&quot;create table mytable (id integer, name varchar(100))&quot;);</code></p>\n</li>\n<li><p>最佳实践</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Repository \npublic class JdbcCorporateEventDao implements CorporateEventDao &#123;\n    private JdbcTemplate jdbcTemplate;\n    @Autowired \n    public void setDataSource(DataSource dataSource) &#123;\n        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource); \n    &#125;\n    \n    public void doExecute() &#123;\n        this.jdbcTemplate.execute(\n            &quot;create table mytable (id integer, name varchar(100))&quot;);\n    &#125;\n    \n    public int getCount() &#123;\n        return this.jdbcTemplate.queryForObject(\n            &quot;select count(*) from mytable&quot;, Integer.class);\n    &#125;\n&#125;\n&#x2F;&#x2F;取回自动递增的key\nfinal String INSERT_SQL &#x3D; &quot;insert into my_test (name) values(?)&quot;;\nfinal String name &#x3D; &quot;Rob&quot;;\nKeyHolder keyHolder &#x3D; new GeneratedKeyHolder();\njdbcTemplate.update(connection -&gt; &#123;\n    PreparedStatement ps &#x3D; connection.prepareStatement(INSERT_SQL, new String[] &#123; &quot;id&quot; &#125;);\n    ps.setString(1, name);\n    return ps;\n&#125;, keyHolder);\n&#x2F;&#x2F; keyHolder.getKey() now contains the generated key</code></pre></li>\n</ol>\n</li>\n<li><p>NamedParameterJdbcTemplate：对JdbcTemplate的一层封装，简化有参数的SQL</p>\n</li>\n<li><p>SQLExceptionTranslator：翻译<code>SQLException</code>和<code>org.sf.dao.DataAccessException</code>的接口，其中一个默认实现是<code>SQLErrorCodeSQLExceptionTranslator</code>，可以解析错误码。Spring会将数据操作的异常转换为<code>DataAccessException</code>，无论使用何种数据访问方式，都能使用一样的异常</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator &#123;\n\n    protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) &#123;\n        if (sqlEx.getErrorCode() &#x3D;&#x3D; -12345) &#123;\n            return new DeadlockLoserDataAccessException(task, sqlEx);\n        &#125;\n        return null;\n    &#125;\n&#125;\n&#x2F;&#x2F;注入方法：\nCustomSQLErrorCodesTranslator tr &#x3D; new CustomSQLErrorCodesTranslator();\nthis.jdbcTemplate.setExceptionTranslator(tr);</code></pre></li>\n</ol>\n</li>\n<li><p>Database Connections</p>\n<ol>\n<li><p>DataSource：</p>\n<ol>\n<li><p>连接工厂，使得一个容器或者一个框架从应用代码中隐藏连接池和事务管理问题，业务开发人员不再需要知道连接数据库的信息。</p>\n</li>\n<li><p>如果是JDBC，那么可以通过JNDI（通过配置而不是放在一起的单一url）来获得数据源；也可以配置数据库连接池（HikariCP/druid）。</p>\n<ul>\n<li>HikariCP：Spring原生支持，性能强，字节码级别优化、大量小改进，但功能少。相关配置见文档：<a href=\"https://github.com/brettwooldridge/HikariCP\">https://github.com/brettwooldridge/HikariCP</a></li>\n<li>druid：功能多，内置强大的监控功能，SQL放注入，内置加密配置。相关配置见文档<a href=\"https://github.com/alibaba/druid/wiki/FAQ\">https://github.com/alibaba/druid/wiki/FAQ</a></li>\n</ul>\n</li>\n<li><p>DriverManagerDataSource和SimpleDriverDataSource仅应该用在测试的时候：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DriverManagerDataSource dataSource &#x3D; new DriverManagerDataSource();\ndataSource.setDriverClassName(&quot;org.hsqldb.jdbcDriver&quot;);\ndataSource.setUrl(&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:&quot;);\ndataSource.setUsername(&quot;sa&quot;);\ndataSource.setPassword(&quot;&quot;);</code></pre></li>\n</ol>\n</li>\n<li><p>DataSourceUtils：提供一些静态方法去从JNDI获得连接和关闭连接，支持线程绑定的连接，比如DataSourceTransactionManager</p>\n</li>\n<li><p>配置多数据源（二选一）</p>\n<ol>\n<li><p>配置@Primary类型的Bean</p>\n</li>\n<li><p>排除SpringBoot的三个自动配置类，自己实现相关配置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\n@ConfigurationProperties(&quot;foo.datasource&quot;)\npublic DataSourceProperties fooDataSourceProperties() &#123;\n    return new DataSourceProperties();\n&#125;\n\n@Bean\npublic DataSource fooDataSource() &#123;\n    DataSourceProperties dataSourceProperties &#x3D; fooDataSourceProperties();\n    log.info(&quot;foo datasource: &#123;&#125;&quot;, dataSourceProperties.getUrl());\n    return dataSourceProperties.initializeDataSourceBuilder().build();\n&#125;\n\n@Bean\n@Resource\npublic PlatformTransactionManager fooTxManager(DataSource fooDataSource) &#123;\n    return new DataSourceTransactionManager(fooDataSource);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Batch Operations：通过组织成批处理，可以限制与数据库的连接往返次数</p>\n<ol>\n<li><p>通过实现<code>BatchPreparedStatementSetter</code>接口的<code>setValues</code>和<code>getBatchSize</code>方法来实现，通过<code>InterruptibleBatchPreparedStatementSetter</code>来在输入用完的时候中断一个批处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdbcActorDao implements ActorDao &#123;\n    private JdbcTemplate jdbcTemplate;\n    \n    public void setDataSource(DataSource dataSource) &#123;\n        this.jdbcTemplate &#x3D; new JdbcTemplate(dataSource);\n    &#125;\n\n    public int[] batchUpdate(final List&lt;Actor&gt; actors) &#123;\n        return this.jdbcTemplate.batchUpdate(\n                &quot;update t_actor set first_name &#x3D; ?, last_name &#x3D; ? where id &#x3D; ?&quot;,\n                new BatchPreparedStatementSetter() &#123;\n                    &#x2F;&#x2F;给准备好的语句传递参数\n                    public void setValues(PreparedStatement ps, int i) throws SQLException &#123;\n                        Actor actor &#x3D; actors.get(i);\n                        ps.setString(1, actor.getFirstName());\n                        ps.setString(2, actor.getLastName());\n                        ps.setLong(3, actor.getId().longValue());\n                    &#125;\n                    &#x2F;&#x2F;batch的尺寸\n                    public int getBatchSize() &#123;\n                        return actors.size();\n                    &#125;\n                &#125;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>NamedParameterJdbcTemplate</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdbcActorDao implements ActorDao &#123;\n    private NamedParameterTemplate namedParameterJdbcTemplate;\n\n    public void setDataSource(DataSource dataSource) &#123;\n        this.namedParameterJdbcTemplate &#x3D; new NamedParameterJdbcTemplate(dataSource);\n    &#125;\n\n    public int[] batchUpdate(List&lt;Actor&gt; actors) &#123;\n        return this.namedParameterJdbcTemplate.batchUpdate(\n                &quot;update t_actor set first_name &#x3D; :firstName, last_name &#x3D; :lastName where id &#x3D; :id&quot;,\n                SqlParameterSourceUtils.createBatch(actors));\n    &#125;\n\n    &#x2F;&#x2F; ... additional methods\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>SimpleJdbc和SimpleJdbcCall利用通过JDBC取回的数据库元数据简化配置</p>\n</li>\n<li><p>SpringBoot的自动配置：</p>\n<ul>\n<li><code>DataSourceAutoConfiguration</code>配置DataSource</li>\n<li><code>DataSourceTransactionManagerAutoConfiguration</code>配置DataSourceTransactionManager</li>\n<li><code>JdbcTemplateAutoConfiguration</code>配置JdbcTemplate</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3-O-R-Mapping\"><a href=\"#3-O-R-Mapping\" class=\"headerlink\" title=\"3.O/R Mapping\"></a>3.O/R Mapping</h4><h5 id=\"1-JPA\"><a href=\"#1-JPA\" class=\"headerlink\" title=\"1.JPA\"></a>1.JPA</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Java Persistence API，为对象关系映射提供了一种基于POJO的持久化模型，简化数据持久化代码的开发工作，为Java社区屏蔽不同持久化API的差异</p></blockquote>\n<ol>\n<li><p>常用注解：</p>\n<ol>\n<li>实体：<ul>\n<li><code>@Entity</code>：定义实体</li>\n<li>``@MappedSuperclass`：有多个实体的类，有一个父类，可以在父类上标注</li>\n<li><code>@Table(name)</code>：name即表名，将实体和表关联起来</li>\n</ul>\n</li>\n<li>主键：<ul>\n<li><code>@Id</code>：比较主键</li>\n<li><code>@GeneratedValue(strategy, generator)</code>：自增序列、自动生成，标注生成策略和生成器</li>\n<li><code>@SequenceGenerator(name,sequenceName)</code>：指明用的是一个什么样的序列</li>\n</ul>\n</li>\n<li>映射：<ul>\n<li><code>@Column(name, nullable, length, insertable, updatable)</code></li>\n<li><code>@JoinTable(name)</code>、<code>@JoinColumn(name)</code>：用来做关联用的</li>\n</ul>\n</li>\n<li>关系：<ul>\n<li><code>@OneToOne</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>、<code>@MangToMany</code></li>\n<li><code>@OrderBy</code></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>操作数据库（声明<code>@EnableJpaRepositories</code>）</p>\n<ol>\n<li><p>继承Repository&lt;T,ID&gt;接口</p>\n<ul>\n<li><p>CrudRepository&lt;T,ID&gt;</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; &#123;\n\t&lt;S extends T&gt; S save(S entity);\n\t&lt;S extends T&gt; Iterable&lt;S&gt; saveAll(Iterable&lt;S&gt; entities);\n\tOptional&lt;T&gt; findById(ID id);\n\tboolean existsById(ID id);\n\tIterable&lt;T&gt; findAll();\n\tIterable&lt;T&gt; findAllById(Iterable&lt;ID&gt; ids);\n\tlong count();\n\tvoid deleteById(ID id);\n\tvoid delete(T entity);\n\tvoid deleteAll(Iterable&lt;? extends T&gt; entities);\n\tvoid deleteAll();\n&#125;</code></pre></li>\n<li><p>PagingAndSortingRepository&lt;T,ID&gt;</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@NoRepositoryBean\npublic interface BaseRepository&lt;T, Long&gt; extends PagingAndSortingRepository&lt;T, Long&gt; &#123;\n    List&lt;T&gt; findTop3ByOrderByUpdateTimeDescIdAsc();\n&#125;\npublic interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; &#123;\n\n  Iterable&lt;T&gt; findAll(Sort sort);\n\n  Page&lt;T&gt; findAll(Pageable pageable);\n&#125;</code></pre></li>\n<li><p>JpaRepository&lt;T,ID&gt;</p>\n</li>\n</ul>\n</li>\n<li><p>定义查询：通过名字生成对应的查询方法</p>\n<ul>\n<li>根据方法名<ul>\n<li>find…By…. / read…By… / query…By… / get…By…</li>\n<li>count…By…</li>\n<li>….OrderBy…[Asc / Desc]</li>\n<li>And / Or / IgnoreCase</li>\n<li>Top / First / Distinct</li>\n</ul>\n</li>\n<li>分页查询<ul>\n<li>PagingAndSortingRepository&lt;T，ID&gt;</li>\n<li>Pageable / Sort</li>\n<li>Slice&lt;T&gt;/ Page&lt;T&gt;</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>底层原理</p>\n<ol>\n<li><p>Repository Bean是如何创建的</p>\n<ul>\n<li><p>repository的<code>BeanDefinition</code>的注册：</p>\n<ul>\n<li>JpaRepositoriesRegistrar</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class JpaRepositoriesRegistrar extends RepositoryBeanDefinitionRegistrarSupport &#123;\n    JpaRepositoriesRegistrar() &#123;\n    &#125;\n\t&#x2F;&#x2F;激活@EnableJpaRepositories\n    protected Class&lt;? extends Annotation&gt; getAnnotation() &#123;\n        return EnableJpaRepositories.class;\n    &#125;\n\t&#x2F;&#x2F;返回了JpaRepositoryConfigExtension\n    protected RepositoryConfigurationExtension getExtension() &#123;\n        return new JpaRepositoryConfigExtension();\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>RepositoryBeanDefinitionRegistrarSupport.registerBeanDefinitions<ul>\n<li>取得registry和extension相关信息，并调用<code>delegate.registerRepositoriesIn(registry, extension);</code>将BeanDefinition注册到注册中心。方法内部，使用<code>RepositoryBeanDefinitionBuilder</code> 依据<code>DefaultRepositoryConfiguration</code>创建，注意此时创建的<code>BeanDefinition</code>的beanClass是<code>JpaRepositoryFactoryBean</code></li>\n<li>注册Repository Bean（类型是JpaRepositoryFactoryBean）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建repository：</p>\n<ul>\n<li><code>RepositoryFactoryBeanSupport.afterPropertiesSet</code>首先创建了一个数据仓库工厂（JpaRepositoryFactory）。然后调用工厂的<code>getRepository</code>方法，实际逻辑还是他（<code>JpaRepositoryFactory</code>）的父类<code>RepositoryFactorySupport</code>中。最核心的是使用了spring aop的动态代理生成了repository实例。</li>\n<li>注意<code>JpaRepositoryFactory</code>的<code>getRepositoryBaseClass</code>方法硬编码为<code>SimpleJpaRepository</code>,这个类实现了常见的CURD操作。</li>\n</ul>\n</li>\n<li><p>通过<code>RepositoryConfigurationExtensionSupport.getRepositoryConfigurations</code>取得所有Repository的配置</p>\n</li>\n<li><p>通过<code>JpaRepositoryFactory.getTargetRepository</code>创建了实际的Repository的bean</p>\n</li>\n</ul>\n</li>\n<li><p>接口中的方法是如何被解释的</p>\n<ul>\n<li>RepositoryFactorySupport.getRepository添加了Advice<ul>\n<li>DefaultMethodInvokingMethodInterceptor</li>\n<li>QueryExecutorMethodInterceptor</li>\n</ul>\n</li>\n<li>AbstractJpaQuery.execute执行具体的查询</li>\n<li>语法解析在Part中</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"2-Lombok\"><a href=\"#2-Lombok\" class=\"headerlink\" title=\"2.Lombok\"></a>2.Lombok</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>能够自动嵌入IDE和构建工具，提升开发效率</p></blockquote>\n<ul>\n<li>@Getter / @Setter</li>\n<li>@ToString</li>\n<li>@NoArgsConstructor / @RequiredArgsConstructor / @AllArgsConstructor</li>\n<li>@Data</li>\n<li>@Builder</li>\n<li>@Slf4j / @CommonsLog / @Log4j2</li>\n</ul>\n<h5 id=\"3-MyBatis\"><a href=\"#3-MyBatis\" class=\"headerlink\" title=\"3.MyBatis\"></a>3.MyBatis</h5><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>持久层框架，支持定制化SQL、存储过程和高级映射。免除了几乎所有的JDBC代码及相关配置，可以通过注解来配置和映射原始类型、接口和Java POJO为数据库中的记录</p></blockquote>\n<ol>\n<li><p>基础使用</p>\n<ol>\n<li><p>添加jar包依赖，编写配置</p>\n<ol>\n<li><p>xml</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">mybatis.mapper-locations &#x3D; classpath* : mapper&#x2F;**&#x2F;*.xml\nmybatis.type-aliases-package &#x3D;类型别名的包名\nmybatis.type-handlers-package &#x3D; TypeHandler扫描包名\nmybatis.configuration.map-underscore-to-camel-case &#x3D; true</code></pre></li>\n<li><p>注解</p>\n<ul>\n<li>@MapperScan配置扫描位置，添加在Application上，值为mapper的包名</li>\n<li>@Mapper定义接口，添加在定义的mapper接口上</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>Mapper的定义和扫描</p>\n</li>\n</ol>\n</li>\n<li><p>MyBatis Generator</p>\n<ol>\n<li><p>MyBatis代码生成器，根据数据库表生成相关代码：POJO、Mapper接口、SQL Map XML</p>\n</li>\n<li><p>产生的代码：</p>\n<ol>\n<li>匹配table接口的类，包括：<ul>\n<li>a class to match the primary key of the table (if there is a primary key)</li>\n<li>a class to match the non-primary key fields of the table (except BLOB fields)</li>\n<li>a class to include the BLOB fields of a table (if the table has BLOB fields)</li>\n<li>a class to enable dynamic selects, updates, and deletes</li>\n</ul>\n</li>\n<li>MBG为每个table生成的SQL包括：<ul>\n<li>insert</li>\n<li>update by primary key</li>\n<li>update by example (using a dynamic where clause)</li>\n<li>delete by primary key</li>\n<li>delete by example (using a dynamic where clause)</li>\n<li>select by primary key</li>\n<li>select by example (using a dynamic where clause)</li>\n<li>count by example</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>生成方式：</p>\n<ol>\n<li><p>通过XML配置文件在Java代码中运行MBG，<a href=\"http://mybatis.org/generator/configreference/xmlconfig.html\">生成配置见官网</a></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void generateArtifacts() throws Exception &#123;\n    List&lt;String&gt; warnings &#x3D; new ArrayList&lt;String&gt;();\n    boolean overwrite &#x3D; true;\n    File configFile &#x3D; new File(&quot;generatorConfig.xml&quot;);\n    ConfigurationParser cp &#x3D; new ConfigurationParser(warnings);\n    Configuration config &#x3D; cp.parseConfiguration(configFile);\n    DefaultShellCallback callback &#x3D; new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator &#x3D; new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n&#125;</code></pre></li>\n<li><p>通过Java配置代码在Java代码中运行MBG</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void generateArtifacts() throws Exception &#123;\n    List&lt;String&gt; warnings &#x3D; new ArrayList&lt;String&gt;();\n    boolean overwrite &#x3D; true;\n    Configuration config &#x3D; new Configuration();\n\n    &#x2F;&#x2F;   ... fill out the config object as appropriate...\n\n    DefaultShellCallback callback &#x3D; new DefaultShellCallback(overwrite);\n    MyBatisGenerator myBatisGenerator &#x3D; new MyBatisGenerator(config, callback, warnings);\n    myBatisGenerator.generate(null);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>MyBatis PageHelper</p>\n<ol>\n<li><p>用来做分页，支持多种数据库和多种分页方式，官方网站：<a href=\"https://pagehelper.github.io/\">https://pagehelper.github.io/</a></p>\n</li>\n<li><p>使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;第一种，RowBounds方式的调用\nList&lt;Country&gt; list &#x3D; sqlSession.selectList(&quot;x.y.selectIf&quot;, null, new RowBounds(0, 10));\n\n&#x2F;&#x2F;第五种，参数对象\n&#x2F;&#x2F;如果 pageNum 和 pageSize 存在于 User 对象中，只要参数有值，也会被分页\n&#x2F;&#x2F;有如下 User 对象\npublic class User &#123;\n    &#x2F;&#x2F;其他fields\n    &#x2F;&#x2F;下面两个参数名和 params 配置的名字一致\n    private Integer pageNum;\n    private Integer pageSize;\n&#125;\n&#x2F;&#x2F;存在以下 Mapper 接口方法，你不需要在 xml 处理后两个参数\npublic interface CountryMapper &#123;\n    List&lt;Country&gt; selectByPageNumSize(User user);\n&#125;\n&#x2F;&#x2F;当 user 中的 pageNum!&#x3D; null &amp;&amp; pageSize!&#x3D; null 时，会自动分页\nList&lt;Country&gt; list &#x3D; countryMapper.selectByPageNumSize(user);</code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-ApplicationContext\"><a href=\"#4-ApplicationContext\" class=\"headerlink\" title=\"4.ApplicationContext\"></a>4.ApplicationContext</h3><ol>\n<li>Spring上下文常用接口<ul>\n<li>BeanFactory<ul>\n<li>DefaultListableBeanFactory</li>\n</ul>\n</li>\n<li>ApplicationContext<ul>\n<li>ClassPathXmlApplicationContext</li>\n<li>FileSystemXmlApplicationContext</li>\n<li>AnnotationConfigApplicationContext</li>\n</ul>\n</li>\n<li>WebApplicationContext</li>\n</ul>\n</li>\n<li>定义：<code>Root WebApplicationContext</code>通常包含基础设施bean，例如需要在多个Servlet实例之间共享的数据存储库和业务服务。这些bean是可被继承的，并且可以在特定于Servlet的子<code>WebApplicatioinContext</code>中被覆盖，该子<code>WebApplicationContext</code>通常包含给定Servlet的本地bean</li>\n<li>对bean做aop增强问题：<ol>\n<li>子类有则用子类的bean，子类没有则用父类的bean</li>\n<li>在父上下文开启增强，父的bean均被增强，子的bean均未被增强；在子上下文开启增强，子的bean均被增强，父的bean未被增强</li>\n<li>要想都被增强，则需要都开启aop的自动配置并且在父类上定义aop</li>\n</ol>\n</li>\n</ol>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220705160411484.png\" alt=\"image-20220705160411484\"></p>\n<h3 id=\"5-Validation\"><a href=\"#5-Validation\" class=\"headerlink\" title=\"5.Validation\"></a>5.Validation</h3><h3 id=\"6-Data-Binding\"><a href=\"#6-Data-Binding\" class=\"headerlink\" title=\"6.Data Binding\"></a>6.Data Binding</h3><h3 id=\"7-Type-Conversion\"><a href=\"#7-Type-Conversion\" class=\"headerlink\" title=\"7.Type Conversion\"></a>7.Type Conversion</h3><h3 id=\"8-Null-safety\"><a href=\"#8-Null-safety\" class=\"headerlink\" title=\"8.Null-safety\"></a>8.Null-safety</h3><h2 id=\"Spring-MVC\"><a href=\"#Spring-MVC\" class=\"headerlink\" title=\"Spring MVC\"></a>Spring MVC</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> Model：提供要展示的数据，分为Dao层和Service层。取数据和处理业务（CRUD）；View：用户界面；Controller：接收用户请求，提交给Model处理请求，并返回处理完毕后的模型View，充当调度员的工作。</p></blockquote>\n<h3 id=\"1-使用\"><a href=\"#1-使用\" class=\"headerlink\" title=\"1.使用\"></a>1.使用</h3><h4 id=\"1-定义映射关系\"><a href=\"#1-定义映射关系\" class=\"headerlink\" title=\"1.定义映射关系\"></a>1.定义映射关系</h4><ol>\n<li><p><code>@Controller</code>：标记某个类是一个控制器（URI和处理逻辑的映射），是<code>@Component</code>注解的一个特例。可以与<code>@ResponseBody</code>组合成<code>@RestController</code>。通过<code>@Indexed</code>优化（为<code>@Controller</code>等模式注解添加索引，提升应用启动性能）</p>\n</li>\n<li><p><code>@RequestMapping</code>：提供路由信息，用于将web请求映射到请求处理类，一些可选参数如下</p>\n<ul>\n<li>path和value用于指定映射路径，method用于指定请求方法（Get、POST等方法），通过<code>RequestMethod</code>来指定</li>\n<li>params指定有哪些参数，或没有哪些参数（<code>!</code>），headers用来指定请求头中有哪些参数，或没有哪些参数（<code>!</code>）</li>\n<li>consumes和produces用于限定请求与响应格式，通过<code>MediaType</code>来指定</li>\n</ul>\n</li>\n<li><p>一些快捷方式</p>\n<ol>\n<li><p><code>@RequestMapping</code></p>\n</li>\n<li><p><code>@GetMapping</code> / <code>@PostMapping</code> / <code>@PutMapping</code> / <code>@DeleteMapping</code> / <code>@PatchMapping</code></p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_JSON_VALUE,\n             produces &#x3D; MediaType.APPLICATION_JSON_UTF8_VALUE)\n@ResponseStatus(HttpStatus.CREATED)\npublic CoffeeOrder create(@RequestBody NewOrderRequest newOrder) &#123;\n    log.info(&quot;Receive new Order &#123;&#125;&quot;, newOrder);\n    Coffee[] coffeeList &#x3D; coffeeService.getCoffeeByName(newOrder.getItems())\n        .toArray(new Coffee[] &#123;&#125;);\n    return orderService.createOrder(newOrder.getCustomer(), coffeeList);\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-定义处理方法（Handler-Methods）\"><a href=\"#2-定义处理方法（Handler-Methods）\" class=\"headerlink\" title=\"2.定义处理方法（Handler Methods）\"></a>2.定义处理方法（Handler Methods）</h4><ol>\n<li><p><code>@RequestBody</code>：方法参数是一个请求体，通过<code>HttpMessageConverter</code>读取请求正文并将其反序列化Object</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)\n@ResponseBody\npublic Account handle() &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@ResponseBody</code>：方法返回一个响应体，通过<code>HttpMessageConverter</code>将返回序列化到响应正文</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(&quot;&#x2F;accounts&quot;)\npublic void handle(@RequestBody Account account) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@ResponseStatus</code>：返回的状态码，通过<code>HttpStatus</code>来指定 </p>\n</li>\n<li><p><code>@PathVariable</code>：请求URI中的变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;样例一\n@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n    &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F;样例二\n@Controller\n@RequestMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&quot;)\npublic class OwnerController &#123;\n    @GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;</code></pre></li>\n<li><p><code>@RequestParam</code>：请求URI中的参数，可以将Servlet请求参数绑定到控制器中的方法参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping\npublic String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) &#123; \n    Pet pet &#x3D; this.clinic.loadPet(petId);\n    model.addAttribute(&quot;pet&quot;, pet);\n    return &quot;petForm&quot;;\n&#125;</code></pre></li>\n<li><p><code>@MatrixVariable</code>：匹配URI中多个参数中的一个，Matrix Variable中，多个变量用<code>;</code>分隔</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; GET &#x2F;pets&#x2F;42;q&#x3D;11;r&#x3D;22\n@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;\n    &#x2F;&#x2F; petId &#x3D;&#x3D; 42\n    &#x2F;&#x2F; q &#x3D;&#x3D; 11\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"3-其它操作\"><a href=\"#3-其它操作\" class=\"headerlink\" title=\"3.其它操作\"></a>3.其它操作</h4><ol>\n<li><p>定义类型转换</p>\n<ol>\n<li><p>SpringBoot在<code>WebMvcConfiguration</code>中的<code>WebMvcAutoConfigurationAdapter</code>中有一个<code>addFormatters</code>方法，会搜索以下三种bean来添加</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void addFormatters(FormatterRegistry registry) &#123;\n    for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;\n        registry.addConverter(converter);\n    &#125;\n    for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;\n        registry.addConverter(converter);\n    &#125;\n    for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;\n        registry.addFormatter(formatter);\n    &#125;\n&#125;</code></pre></li>\n<li><p>添加自定义的Converter：可以将一种类型转换成另一种类型</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class StudentConvert implements Converter&lt;String ,Student&gt; &#123;\n\n    @Override\n    public Student convert(String text) &#123;\n        if (NumberUtils.isParsable(text)) &#123;\n            Student s &#x3D;  new Student();\n            s.setAge(Integer.parseInt(text));\n            return s;\n        &#125;\n        return new Student();\n    &#125;\n&#125;</code></pre></li>\n<li><p>添加自定义的Formatter：只能将String转换为另一种类型，比Converter优先级高</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class MoneyFormatter implements Formatter&lt;Money&gt; &#123;\n    &#x2F;**\n     * 处理 CNY 10.00 &#x2F; 10.00 形式的字符串\n     *&#x2F;\n    @Override\n    public Money parse(String text, Locale locale) throws ParseException &#123;\n        if (NumberUtils.isParsable(text)) &#123;\n            return Money.of(CurrencyUnit.of(&quot;CNY&quot;), NumberUtils.createBigDecimal(text));\n        &#125; else if (StringUtils.isNotEmpty(text)) &#123;\n            String[] split &#x3D; StringUtils.split(text, &quot; &quot;);\n            if (split !&#x3D; null &amp;&amp; split.length &#x3D;&#x3D; 2 &amp;&amp; NumberUtils.isParsable(split[1])) &#123;\n                return Money.of(CurrencyUnit.of(split[0]),\n                                NumberUtils.createBigDecimal(split[1]));\n            &#125; else &#123;\n                throw new ParseException(text, 0);\n            &#125;\n        &#125;\n        throw new ParseException(text, 0);\n    &#125;\n\n    @Override\n    public String print(Money money, Locale locale) &#123;\n        if (money &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        return money.getCurrencyUnit().getCode() + &quot; &quot; + money.getAmount();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>定义校验：通过<code>Validator</code>对绑定结果进行验证，参数添加<code>@Valid</code>注解，如果需要自己处理异常返回，则只需要添加<code>BindingResult</code>参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;实体\npublic class NewCoffeeRequest &#123;\n    @NotEmpty\n    private String name;\n    @NotNull\n    private Money price;\n    &#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;自定义检验失败处理\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D;\n             MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addCoffee(@Valid NewCoffeeRequest newCoffee,\n                        BindingResult result) &#123;\n    if (result.hasErrors()) &#123;\n        &#x2F;&#x2F; 这里先简单处理一下，后续讲到异常处理时会改\n        log.warn(&quot;Binding Errors: &#123;&#125;&quot;, result);\n        return null;\n    &#125;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;\n&#x2F;&#x2F;SpringMVC来帮助处理\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; \n             MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addCoffeeWithoutBindingResult(@Valid NewCoffeeRequest newCoffee) &#123;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;</code></pre></li>\n<li><p>Multipart上传（文件），SpringBoot自动配置<code>MultipartAutoConfiguration</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;通过文件批量创建\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.MULTIPART_FORM_DATA_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic List&lt;Coffee&gt; batchAddCoffee(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;\n    List&lt;Coffee&gt; coffees &#x3D; new ArrayList&lt;&gt;();\n    if (!file.isEmpty()) &#123;\n        BufferedReader reader &#x3D; null;\n        try &#123;\n            reader &#x3D; new BufferedReader(\n                new InputStreamReader(file.getInputStream()));\n            String str;\n            while ((str &#x3D; reader.readLine()) !&#x3D; null) &#123;\n                String[] arr &#x3D; StringUtils.split(str, &quot; &quot;);\n                if (arr !&#x3D; null &amp;&amp; arr.length &#x3D;&#x3D; 2) &#123;\n                    coffees.add(coffeeService.saveCoffee(arr[0],\n                                                         Money.of(CurrencyUnit.of(&quot;CNY&quot;),\n                                                                  NumberUtils.createBigDecimal(arr[1]))));\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            log.error(&quot;exception&quot;, e);\n        &#125; finally &#123;\n            IOUtils.closeQuietly(reader);\n        &#125;\n    &#125;\n    return coffees;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"2-运行机制DispatcherServlet\"><a href=\"#2-运行机制DispatcherServlet\" class=\"headerlink\" title=\"2.运行机制DispatcherServlet\"></a>2.运行机制DispatcherServlet</h3><h4 id=\"1-请求处理\"><a href=\"#1-请求处理\" class=\"headerlink\" title=\"1.请求处理\"></a>1.请求处理</h4><ol>\n<li><p>主要组件</p>\n<ol>\n<li>controller：定义了每个请求怎么处理</li>\n<li>xxxResolver<ul>\n<li>ViewResolver</li>\n<li>HandlerExceptionResolver</li>\n<li>MultipartResolver</li>\n</ul>\n</li>\n<li>HandlerMapping：请求怎么映射到controller</li>\n</ol>\n</li>\n<li><p>处理流程：</p>\n<ol>\n<li><p><code>doService</code>绑定一些属性：WebApplicationContext、LocaleResolver、ThemeResolver，然后进入<code>doDispatch</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Make framework objects available to handlers and view objects.\nrequest.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, \n                     getWebApplicationContext());\nrequest.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);\nrequest.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);\nrequest.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</code></pre></li>\n<li><p>处理Multipart：如果是则将请求转为MultipartHttpServletRequest</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">processedRequest &#x3D; checkMultipart(request);\nmultipartRequestParsed &#x3D; (processedRequest !&#x3D; request);</code></pre></li>\n<li><p>Handler处理：如果找到对应的Handler，执行Controller及前后置处理器逻辑</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Determine handler for the current request.\nmappedHandler &#x3D; getHandler(processedRequest);\n&#x2F;&#x2F;前置处理\nif (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;\n&#x2F;&#x2F; Actually invoke the handler.\nmv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n&#x2F;&#x2F;后置处理\nmappedHandler.applyPostHandle(processedRequest, response, mv);</code></pre></li>\n<li><p>处理返回的Model，呈现视图</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-视图解析\"><a href=\"#2-视图解析\" class=\"headerlink\" title=\"2.视图解析\"></a>2.视图解析</h4><ol>\n<li><p>ViewResolver与View接口的实现类有：<code>AbstractCachingViewResolver</code>、<code>UrlBasedViewResolver</code>、<code>FreeMarkerViewResolver</code>、<code>ContentNegotiatingViewResolver</code>、<code>InternalResourceViewResolver</code>。都是用来解析出view对象，再用view对象做呈现</p>\n</li>\n<li><p>视图解析逻辑</p>\n<ol>\n<li><p>有modelandview的视图解析逻辑：</p>\n<ol>\n<li><p>DispatcherServlet中的initStrategies()初始化了对应的ViewResolver</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void initStrategies(ApplicationContext context) &#123;\n    initMultipartResolver(context);\n    initLocaleResolver(context);\n    initThemeResolver(context);\n    initHandlerMappings(context);\n    initHandlerAdapters(context);\n    initHandlerExceptionResolvers(context);\n    initRequestToViewNameTranslator(context);\n    initViewResolvers(context);\n    initFlashMapManager(context);\n&#125;</code></pre></li>\n<li><p><code>DispatcherServlet</code>中的<code>doDispatch()</code>中的<code>processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</code>会做从视图名到视图的解析，通过<code>render</code>呈现视图，在<code>render</code>中通过<code>resolveViewName</code>解析出view对象，</p>\n</li>\n</ol>\n</li>\n<li><p>使用<code>@ResponseBody</code>的视图解析逻辑：</p>\n<ul>\n<li><p>在HandlerAdapter.handle()的中完成了Response输出</p>\n<ul>\n<li><p><code>RequestMappingHandlerAdapter</code>中的<code>handleInternal</code>中执行<code>invokeHandlerMethod()</code>，方法内设置所有<code>ReturnValueHandler</code>，之后执行方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">invocableMethod.invokeAndHandle(webRequest, mavContainer);</code></pre>\n\n<ul>\n<li><p>在这个方法中取得返回值<code>returnValue</code>，然后调用HandlerMethodReturnValueHandlerComposite.handleReturnValue()，对Handler进行处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">this.returnValueHandlers.handleReturnValue(\n\t\t\t\t\treturnValue, getReturnValueType(returnValue), mavContainer, webRequest);</code></pre>\n\n<ul>\n<li>RequestResponseBodyMethodProcessor.handleReturnValue(）中的<code>writeWithMessageConverters</code>对结果进行输出到<code>Response</code>中 </li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>常用视图（文档中的viewtechnology）</p>\n<ol>\n<li><p>配置MessageConverter：通过WebMvcConfigurer的configureMessageConverters()，SpringBoot会自动查找HttpMessageConverters进行注册</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;\n    this.messageConvertersProvider.ifAvailable((customConverters) -&gt; converters\n                                               .addAll(customConverters.getConverters()));\n&#125;</code></pre></li>\n<li><p>SpringBoot对Jackson的支持：JacksonAutoConfiguration</p>\n<ol>\n<li><p>通过<code>@JsonComponent</code>注册JSON序列化组件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;序列化\n@JsonComponent\npublic class MoneySerializer extends StdSerializer&lt;Money&gt; &#123;\n    protected MoneySerializer() &#123;\n        super(Money.class);\n    &#125;\n\n    @Override\n    public void serialize(Money money, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException &#123;\n        jsonGenerator.writeNumber(money.getAmount());\n    &#125;\n&#125;\n&#x2F;&#x2F;反序列化\n@JsonComponent\npublic class MoneyDeserializer extends StdDeserializer&lt;Money&gt; &#123;\n    protected MoneyDeserializer() &#123;\n        super(Money.class);\n    &#125;\n\n    @Override\n    public Money deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException &#123;\n        return Money.of(CurrencyUnit.of(&quot;CNY&quot;), p.getDecimalValue());\n    &#125;\n&#125;</code></pre></li>\n<li><p>Jackson2ObjectMapperBuilderCustomizer</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;转成带缩进的\n@Bean\npublic Jackson2ObjectMapperBuilderCustomizer jacksonBuilderCustomizer() &#123;\n    return builder -&gt; builder.indentOutput(true);\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>视图呈现：ModelandView、jsp、Thymeleaf</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-异常处理\"><a href=\"#3-异常处理\" class=\"headerlink\" title=\"3.异常处理\"></a>3.异常处理</h4><ol>\n<li><p>异常解析</p>\n<ol>\n<li><p>核心接口为<code>HandlerExceptionResolver</code>，实现类主要有：</p>\n<ul>\n<li><code>SimpleMappingExceptionResolver</code></li>\n<li><code>DefaultHandlerExceptionResolver</code></li>\n<li><code>ResponseStatusExceptionResolver</code>：处理加了<code>ResponseStatus</code>注解的类</li>\n<li><code>ExceptionHandlerExceptionResolver</code></li>\n</ul>\n</li>\n<li><p>异常处理方法：</p>\n<ol>\n<li><p>处理方法：<code>@ExceptionHandler</code></p>\n</li>\n<li><p>添加位置：</p>\n<ul>\n<li><p>拦截一个Controller：<code>@Controller</code>、<code>@RestController</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;验证时如果抛出FormValidationException异常\n@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_FORM_URLENCODED_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addCoffee(@Valid NewCoffeeRequest newCoffee,\n                        BindingResult result) &#123;\n    if (result.hasErrors()) &#123;\n        log.warn(&quot;Binding Errors: &#123;&#125;&quot;, result);\n        throw new FormValidationException(result);\n    &#125;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;\n&#x2F;&#x2F;定义异常处理\n@ResponseStatus(HttpStatus.BAD_REQUEST)\n@Getter\n@AllArgsConstructor\npublic class FormValidationException extends RuntimeException &#123;\n    private BindingResult result;\n&#125;</code></pre></li>\n<li><p>拦截所有Controller：``@ControllerAdvice<code>、</code>@RestControllerAdvice`</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(path &#x3D; &quot;&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_JSON_UTF8_VALUE)\n@ResponseBody\n@ResponseStatus(HttpStatus.CREATED)\npublic Coffee addJsonCoffee(@Valid @RequestBody NewCoffeeRequest newCoffee,\n                            BindingResult result) &#123;\n    if (result.hasErrors()) &#123;\n        log.warn(&quot;Binding Errors: &#123;&#125;&quot;, result);\n        throw new ValidationException(result.toString());\n    &#125;\n    return coffeeService.saveCoffee(newCoffee.getName(), newCoffee.getPrice());\n&#125;\n\n@RestControllerAdvice\npublic class GlobalControllerAdvice &#123;\n    @ExceptionHandler(ValidationException.class)\n    @ResponseStatus(HttpStatus.BAD_REQUEST)&#x2F;&#x2F;返回400\n    public Map&lt;String, String&gt; validationExceptionHandler(ValidationException exception) &#123;\n        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;message&quot;, exception.getMessage());\n        return map;\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>拦截器</p>\n</li>\n</ol>\n<p>==附加：==SpringMVC底层原理：Spring MVC框架像许多其他MVC框架一样, 以请求为驱动 , 围绕一个中心Servlet分派请求及提供其他功能，Spring的web框架围绕DispatcherServlet设计，DispatcherServlet是一个实际的Servlet (它继承自HttpServlet 基类)。 下图为SpringMVC的一个较完整的流程图，实线表示SpringMVC框架提供的技术，不需要开发者实现，虚线表示需要开发者实现。 <img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/1628316066130-165198837930612-165573602681812.png\" alt=\"1628316066130\"></p>\n<ol>\n<li><p>DispatcherServlet表示前置控制器，是整个SpringMVC的控制中心。用户发出请求，DispatcherServlet接收请求并拦截请求。</p>\n<ul>\n<li>我们假设请求的url为 : <a href=\"http://localhost:8080/SpringMVC/hello\">http://localhost:8080/SpringMVC/hello</a></li>\n<li>如上url拆分成三部分：<a href=\"http://localhost:8080服务器域名；SpringMVC部署在服务器上的web站点；hello表示控制器\">http://localhost:8080服务器域名；SpringMVC部署在服务器上的web站点；hello表示控制器</a></li>\n</ul>\n<p>通过分析，如上url表示为：请求位于服务器localhost:8080上的SpringMVC站点的hello控制器。</p>\n</li>\n<li><p>HandlerMapping为处理器映射。DispatcherServlet调用HandlerMapping,HandlerMapping根据请求url查找Handler。</p>\n</li>\n<li><p>HandlerExecution表示具体的Handler,其主要作用是根据url查找控制器，如上url被查找控制器为：hello。</p>\n</li>\n<li><p>HandlerExecution将解析后的信息传递给DispatcherServlet,如解析控制器映射等。</p>\n</li>\n<li><p>HandlerAdapter表示处理器适配器，其按照特定的规则去执行Handler。</p>\n</li>\n<li><p>Handler让具体的Controller执行。</p>\n</li>\n<li><p>Controller将具体的执行信息返回给HandlerAdapter,如ModelAndView。</p>\n</li>\n<li><p>HandlerAdapter将视图逻辑名或模型传递给DispatcherServlet。</p>\n</li>\n<li><p>DispatcherServlet调用视图解析器(ViewResolver)来解析HandlerAdapter传递的逻辑视图名。</p>\n</li>\n<li><p>视图解析器将解析的逻辑视图名传给DispatcherServlet。</p>\n</li>\n<li><p>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图。</p>\n</li>\n<li><p>最终视图呈现给用户。</p>\n</li>\n</ol>\n<h3 id=\"3-RestTemplate\"><a href=\"#3-RestTemplate\" class=\"headerlink\" title=\"3.RestTemplate\"></a>3.RestTemplate</h3><ol>\n<li><p>构建</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\npublic RestTemplate restTemplate(RestTemplateBuilder builder) &#123;\n    return builder.build();\n&#125;</code></pre></li>\n<li><p>常用方法</p>\n<ol>\n<li>GET请求<ul>\n<li>getForObject()：<code>String s = restTemplate.getForObject(coffeeUri, String.class);</code></li>\n<li>getForEntity()</li>\n</ul>\n</li>\n<li>POST请求<ul>\n<li>postForObject()：<code>Coffee response = restTemplate.postForObject(coffeeUri, request, Coffee.class);</code></li>\n<li>postForEntity()</li>\n</ul>\n</li>\n<li>PUT请求<ul>\n<li>put()</li>\n</ul>\n</li>\n<li>DELETE请求<ul>\n<li>delete()</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>构建URI</p>\n<ol>\n<li><p>构造URI：UriComponentsBuilder</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">URI uri &#x3D; UriComponentsBuilder\n\t\t\t\t.fromUriString(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;coffee&#x2F;&#123;id&#125;&quot;)\n\t\t\t\t.build(1);</code></pre></li>\n<li><p>构造相对于当前请求的URI：ServletUriComponentsBuilder</p>\n</li>\n<li><p>构造指向Controller的URI：MvcUriComponentsBuilder</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-URI设计\"><a href=\"#4-URI设计\" class=\"headerlink\" title=\"4.URI设计\"></a>4.URI设计</h3><ol>\n<li>识别资源<ol>\n<li>找到领域名词，即能用CRUD操作的名词</li>\n<li>将资源组织为集合，即集合资源；或合并为符合资源</li>\n<li>计算或处理函数</li>\n</ol>\n</li>\n<li>选择合适的资源粒度<ol>\n<li>服务端的角度：网络效率、表述的多少、客户端的易用程度</li>\n<li>客户端的角度：可缓存性、修改频率、可变性</li>\n</ol>\n</li>\n<li>设计URI<ol>\n<li>使用域及子域对资源进行合理的分组或划分</li>\n<li>在URI的路径部分使用斜杠分隔符(/)来表示资源之间的层次关系</li>\n<li>在URI的路径部分使用逗号(,)和分号(﹔)来表示非层次元素</li>\n<li>使用连字符(-)和下划线(_)来改善长路径中名称的可读性</li>\n<li>在URI的查询部分使用“与”符号(&amp;）来分隔参数</li>\n<li>在URI中避免出现文件扩展名（例如.php，.aspx和.jsp )</li>\n</ol>\n</li>\n<li>选择格式的HTTP方法和返回码<ol>\n<li>HTTP方法<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220721231848408.png\" alt=\"image-20220721231848408\"></li>\n<li>组合<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220721231905339.png\" alt=\"image-20220721231905339\"></li>\n<li>状态码<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220721231933540.png\" alt=\"image-20220721231933540\"></li>\n</ol>\n</li>\n<li>设计资源的表述<ol>\n<li>JSON<ul>\n<li>MappingJackson2HttpMessageConverter</li>\n<li>GsonHttpMessageConverter</li>\n<li>JsonbHttpMessageConverter</li>\n</ul>\n</li>\n<li>XML<ul>\n<li>MappingJackson2XmlHttpMessageConverter</li>\n<li>Jaxb2RootElementHttpMessageConverter</li>\n</ul>\n</li>\n<li>HTML</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-Spring-Session\"><a href=\"#5-Spring-Session\" class=\"headerlink\" title=\"5.Spring Session\"></a>5.Spring Session</h3><h2 id=\"Spring-Data\"><a href=\"#Spring-Data\" class=\"headerlink\" title=\"Spring Data\"></a>Spring Data</h2><h3 id=\"1-MongoDB\"><a href=\"#1-MongoDB\" class=\"headerlink\" title=\"1.MongoDB\"></a>1.MongoDB</h3><h4 id=\"1-MongoDB-1\"><a href=\"#1-MongoDB-1\" class=\"headerlink\" title=\"1.MongoDB\"></a>1.MongoDB</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>MongoDB 是一种基于分布式文件存储的文档数据库，由 C++ 语言编写，它所具备的可扩展性和灵活性可以满足您对查询和索引的需求，旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p></blockquote>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/mdb-vs-sql.png\" alt=\"Diagram illustrating the differences between MongoDB and SQL\"></p>\n<ol>\n<li><p>MongoDB中的CRUD</p>\n<ol>\n<li><p>创建数据库</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CrudInsert &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            &#x2F;&#x2F; insert code goes here\n            &#x2F;&#x2F; display the results of your operation\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>读数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">import com.mongodb.client.*;\nimport com.mongodb.client.model.Filters.*;\nimport org.bson.Document;\nimport org.bson.conversions.Bson;\npublic class CrudRead &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;planets&quot;);\n            \n            &#x2F;&#x2F; find code goes here\n            MongoCursor&lt;Document&gt; cursor &#x3D; coll.find().iterator();\n            &#x2F;&#x2F;第一种查询 eq语句\n            &#x2F;&#x2F;Bson filter &#x3D; eq(&quot;hasRings&quot;, true);\n            &#x2F;&#x2F;第二种查询 lt语句\n            &#x2F;&#x2F;Bson filter &#x3D; lt(&quot;surfaceTemperatureC.mean&quot;, 15);\n            &#x2F;&#x2F;第三种查询 and语句\n            &#x2F;&#x2F;Bson filter &#x3D; and(lt(&quot;surfaceTemperatureC.mean&quot;, 15), gt(&quot;surfaceTemperatureC.min&quot;, -100));\n            &#x2F;&#x2F;执行语句\n            &#x2F;&#x2F;MongoCursor&lt;Document&gt; cursor &#x3D; coll.find(filter).iterator();\n            \n            &#x2F;&#x2F; iterate code goes here\n            try &#123;\n                while (cursor.hasNext()) &#123;\n                    System.out.println(cursor.next().toJson());\n                &#125;\n            &#125; finally &#123;\n                cursor.close();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#123;&quot;_id&quot;: &#123;&quot;$oid&quot;: &quot;621ff30d2a3e781873fcb65c&quot;&#125;, &quot;name&quot;: &quot;Mercury&quot;, &quot;orderFromSun&quot;:1, &quot;hasRings&quot;: false, &quot;mainAtmosphere&quot;: [], &quot;surfaceTemperatureC&quot;: &#123;&quot;min&quot;: -173, &quot;max&quot;: 427, &quot;mean&quot;: 67&#125;&#125;\n&#x2F;&#x2F;...</code></pre></li>\n<li><p>插入</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CrudInsert &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;comets&quot;);\n            &#x2F;&#x2F; insert code goes here\n            List&lt;Document&gt; documents &#x3D; new ArrayList&lt;&gt;();\n            Document doc1 &#x3D; new Document(&quot;name&quot;, &quot;Halley&#39;s Comet&quot;).append(&quot;officialName&quot;, &quot;1P&#x2F;Halley&quot;).append(&quot;orbitalPeriod&quot;, 75).append(&quot;radius&quot;, 3.4175).append(&quot;mass&quot;, 2.2e14);\n            Document doc2 &#x3D; new Document(&quot;name&quot;, &quot;Wild2&quot;).append(&quot;officialName&quot;, &quot;81P&#x2F;Wild&quot;).append(&quot;orbitalPeriod&quot;, 6.41).append(&quot;radius&quot;, 1.5534).append(&quot;mass&quot;, 2.3e13);\n            Document doc3 &#x3D; new Document(&quot;name&quot;, &quot;Comet Hyakutake&quot;).append(&quot;officialName&quot;, &quot;C&#x2F;1996 B2&quot;).append(&quot;orbitalPeriod&quot;, 17000).append(&quot;radius&quot;, 0.77671).append(&quot;mass&quot;, 8.8e12);\n            \n            documents.add(doc1);\n            documents.add(doc2);\n            documents.add(doc3);\n            \n            InsertManyResult result &#x3D; coll.insertMany(documents);\n            \n            &#x2F;&#x2F; display the results of your operation\n            result.getInsertedIds().values().forEach(doc -&gt; System.out.println(doc.asObjectId().getValue()));\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>更新</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CrudUpdate &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;comets&quot;);\n            &#x2F;&#x2F; update code goes here\n            Bson filter &#x3D; Filters.empty();\n            Bson update &#x3D; Updates.mul(&quot;Radius&quot;, 1.60934);\n            UpdateResult result &#x3D; coll.updateMany(filter, update);\n            &#x2F;&#x2F; display the results of your operation\n            System.out.println(&quot;Number of documents updated: &quot; + result.getModifiedCount());\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>删除</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CrudDelete &#123;\n    public static void main(String[] args) &#123;\n        String uri &#x3D; &quot;mongodb+srv:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;cluster-url&gt;?retryWrites&#x3D;true&amp;writeConcern&#x3D;majority&quot;;\n        try (MongoClient mongoClient &#x3D; MongoClients.create(uri)) &#123;\n            &#x2F;&#x2F; database and collection code goes here\n            MongoDatabase db &#x3D; mongoClient.getDatabase(&quot;sample_guides&quot;);\n            MongoCollection&lt;Document&gt; coll &#x3D; db.getCollection(&quot;comets&quot;);\n            &#x2F;&#x2F; delete code goes here\n            Bson filter &#x3D; Filters.and(Filters.gt(&quot;OrbitalPeriod&quot;, 5), Filters.lt(&quot;OrbitalPeriod&quot;, 85));\n            DeleteResult result &#x3D; coll.deleteMany(filter);\n\n            &#x2F;&#x2F; amount deleted code goes here\n            System.out.println(&quot;Number of documents deleted: &quot; +result.getDeletedCount());\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Spring-Data相关\"><a href=\"#2-Spring-Data相关\" class=\"headerlink\" title=\"2.Spring Data相关\"></a>2.Spring Data相关</h4><ol>\n<li><p>注解</p>\n<ol>\n<li>@Document：</li>\n<li>@Id：转换成MongoDB中的object ID</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Document\npublic class Coffee &#123;\n    @Id\n    private String id;\n    private String name;\n    private Money price;\n    private Date createTime;\n    private Date updateTime;\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li><p>MongoTemplate</p>\n<ol>\n<li><p>save/remove</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Coffee saved &#x3D; mongoTemplate.save(espresso);</code></pre></li>\n<li><p>Criteria/Query/Update</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Coffee&gt; list &#x3D; mongoTemplate.find(\n    Query.query(Criteria.where(&quot;name&quot;).is(&quot;espresso&quot;)), Coffee.class);\nUpdateResult result &#x3D; mongoTemplate.updateFirst(\n    query(where(&quot;name&quot;).is(&quot;espresso&quot;)),\n    new Update().set(&quot;price&quot;, Money.ofMajor(CurrencyUnit.of(&quot;CNY&quot;), 30))\n    .currentDate(&quot;updateTime&quot;),\n    Coffee.class);</code></pre></li>\n</ol>\n</li>\n<li><p>Repository</p>\n<ol>\n<li><p>@EnableMongoRepositories</p>\n</li>\n<li><p>对应接口</p>\n<ol>\n<li><p>MongoRepository&lt;T，ID&gt;</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface CoffeeRepository extends MongoRepository&lt;Coffee, String&gt; &#123;\n    List&lt;Coffee&gt; findByName(String name);\n&#125;\n\n@SpringBootApplication\n@EnableMongoRepositories\npublic class MongoRepositoryDemoApplication implements CommandLineRunner &#123;\n\t@Autowired\n\tprivate CoffeeRepository coffeeRepository;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(MongoRepositoryDemoApplication.class, args);\n\t&#125;\n\n\t@Bean\n\tpublic MongoCustomConversions mongoCustomConversions() &#123;\n\t\treturn new MongoCustomConversions(Arrays.asList(new MoneyReadConverter()));\n\t&#125;\n\n\t@Override\n\tpublic void run(String... args) throws Exception &#123;\n\t\tCoffee espresso &#x3D; Coffee.builder()\n\t\t\t\t.name(&quot;espresso&quot;)\n\t\t\t\t.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 20.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\t\tCoffee latte &#x3D; Coffee.builder()\n\t\t\t\t.name(&quot;latte&quot;)\n\t\t\t\t.price(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 30.0))\n\t\t\t\t.createTime(new Date())\n\t\t\t\t.updateTime(new Date()).build();\n\n\t\tcoffeeRepository.insert(Arrays.asList(espresso, latte));\n\t\tcoffeeRepository.findAll(Sort.by(&quot;name&quot;))\n\t\t\t\t.forEach(c -&gt; log.info(&quot;Saved Coffee &#123;&#125;&quot;, c));\n\t\tThread.sleep(1000);\n\t\tlatte.setPrice(Money.of(CurrencyUnit.of(&quot;CNY&quot;), 35.0));\n\t\tlatte.setUpdateTime(new Date());\n\t\tcoffeeRepository.save(latte);\n\t\tcoffeeRepository.findByName(&quot;latte&quot;)\n\t\t\t\t.forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c));\n\n\t\tcoffeeRepository.deleteAll();\n\t&#125;\n&#125;</code></pre></li>\n<li><p>PagingAndSortingRepository&lt;T，ID&gt;</p>\n</li>\n<li><p>CrudRepository&lt;T，ID&gt;</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>底层原理</p>\n</li>\n</ol>\n<h3 id=\"2-Redis\"><a href=\"#2-Redis\" class=\"headerlink\" title=\"2.Redis\"></a>2.Redis</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Redis是高性能的Key-Value数据库，可以存储键（字符串）和五种不同类型（字符串、列表、集合、散列表、有序集合）的值之间的映射</p></blockquote>\n<h4 id=\"1-Redis\"><a href=\"#1-Redis\" class=\"headerlink\" title=\"1.Redis\"></a>1.Redis</h4><ol>\n<li><p>概述</p>\n<ol>\n<li><p>Redis客户端启动：中文乱码时在后面加上<code>-raw</code></p>\n<ul>\n<li><p>本地</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ redis-cli\nredis 127.0.0.1:6379&gt;\nredis 127.0.0.1:6379&gt; PING\nPONG</code></pre></li>\n<li><p>远程</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$redis-cli -h 127.0.0.1 -p 6379 -a &quot;mypass&quot;\nredis 127.0.0.1:6379&gt;\nredis 127.0.0.1:6379&gt; PING\nPONG</code></pre></li>\n</ul>\n</li>\n<li><p>redis支持的命令：<a href=\"https://redis.io/commands/\">https://redis.io/commands/</a></p>\n</li>\n<li><p>脚本：Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p>\n</li>\n<li><p>备份与恢复：<code>SAVE</code>命令用于创建当前数据库的备份，如果需要恢复数据，只需将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。</p>\n</li>\n<li><p>性能测试：<code>redis-benchmark [option] [option value]</code></p>\n</li>\n</ol>\n</li>\n<li><p>数据类型：</p>\n<ol>\n<li><p>string：最基本的类型，类型安全（可以包含任何数据），最大能存储512MB</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; SET runoob &quot;菜鸟教程&quot;\nOK\nredis 127.0.0.1:6379&gt; GET runoob\n&quot;菜鸟教程&quot;</code></pre></li>\n<li><p>hash：是一个键值对集合，是一个String类型的field和value的映射表，适合存储对象，每个 hash 可以存储 2^32 -1个键值对（40多亿）</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; HMSET runoob field1 &quot;Hello&quot; field2 &quot;World&quot;\n&quot;OK&quot;\nredis 127.0.0.1:6379&gt; HGET runoob field1\n&quot;Hello&quot;\nredis 127.0.0.1:6379&gt; HGET runoob field2\n&quot;World&quot;</code></pre></li>\n<li><p>list：简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部或者尾部，每个列表可以存储 2^32 -1个元素（40多亿）</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; lpush runoob redis\n(integer) 1\nredis 127.0.0.1:6379&gt; lpush runoob mongodb\n(integer) 2\nredis 127.0.0.1:6379&gt; lpush runoob rabbitmq\n(integer) 3\nredis 127.0.0.1:6379&gt; lrange runoob 0 10\n1) &quot;rabbitmq&quot;\n2) &quot;mongodb&quot;\n3) &quot;redis&quot;</code></pre></li>\n<li><p>set：String类型的无序集合，集合是通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)，每个集合可以存储 2^32 -1个元素（40多亿）</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; sadd runoob redis\n(integer) 1\nredis 127.0.0.1:6379&gt; sadd runoob mongodb\n(integer) 1\nredis 127.0.0.1:6379&gt; sadd runoob rabbitmq\n(integer) 1\nredis 127.0.0.1:6379&gt; sadd runoob rabbitmq\n(integer) 0\nredis 127.0.0.1:6379&gt; smembers runoob\n1) &quot;redis&quot;\n2) &quot;rabbitmq&quot;\n3) &quot;mongodb&quot;</code></pre></li>\n<li><p>zset(sorted set：有序集合)：Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; DEL runoob\nredis 127.0.0.1:6379&gt; zadd runoob 0 redis\n(integer) 1\nredis 127.0.0.1:6379&gt; zadd runoob 0 mongodb\n(integer) 1\nredis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq\n(integer) 1\nredis 127.0.0.1:6379&gt; zadd runoob 0 rabbitmq\n(integer) 0\nredis 127.0.0.1:6379&gt; ZRANGEBYSCORE runoob 0 1000\n1) &quot;mongodb&quot;\n2) &quot;rabbitmq&quot;\n3) &quot;redis&quot;</code></pre></li>\n</ol>\n</li>\n<li><p>特性</p>\n<ol>\n<li><p>Redis HyperLogLog：Redis 在 2.8.9 版本添加了 HyperLogLog 结构。Redis HyperLogLog 是用来做基数（不重复元素）统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>\n</li>\n<li><p>发布订阅 (pub/sub) ：是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。Redis 客户端可以订阅任意数量的频道</p>\n<ul>\n<li><p>订阅频道</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; SUBSCRIBE runoobChat\nReading messages... (press Ctrl-C to quit)\n1) &quot;subscribe&quot;\n2) &quot;runoobChat&quot;\n3) (integer) 1\n#待发布频道发布完后，此订阅频道会收到如下信息\n 1) &quot;message&quot;\n2) &quot;runoobChat&quot;\n3) &quot;Redis PUBLISH test&quot;\n 1) &quot;message&quot;\n2) &quot;runoobChat&quot;\n3) &quot;Learn redis by runoob.com&quot;</code></pre></li>\n<li><p>发布频道</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Redis PUBLISH test&quot;\n(integer) 1\nredis 127.0.0.1:6379&gt; PUBLISH runoobChat &quot;Learn redis by runoob.com&quot;\n(integer) 1</code></pre></li>\n</ul>\n</li>\n<li><p>事务：Redis 事务可以一次执行多个命令， 并且带有以下保证：</p>\n<ul>\n<li>批量操作在发送 EXEC 命令前被放入队列缓存。</li>\n<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li>\n<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li>\n<li>事务不是原子性的，只是打包的批量执行脚本，但是每条命令的执行是原子性的</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; MULTI\nOK\nredis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;\nQUEUED\nredis 127.0.0.1:6379&gt; GET book-name\nQUEUED\nredis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;\nQUEUED\nredis 127.0.0.1:6379&gt; SMEMBERS tag\nQUEUED\nredis 127.0.0.1:6379&gt; EXEC\n1) OK\n2) &quot;Mastering C++ in 21 days&quot;\n3) (integer) 3\n4) 1) &quot;Mastering Series&quot;\n   2) &quot;C++&quot;\n   3) &quot;Programming&quot;</code></pre></li>\n<li><p>脚本：Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 EVAL。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">redis 127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second\n1) &quot;key1&quot;\n2) &quot;key2&quot;\n3) &quot;first&quot;\n4) &quot;second&quot;</code></pre></li>\n<li><p>Stream：</p>\n<ol>\n<li>Redis 5.0 版本新增加的数据结构，主要用于消息队列（MQ，Message Queue）。Redis的发布订阅 (pub/sub)的消息无法持久化，即无法记录历史消息，如果出现网络断开、Redis 宕机等，消息就会被丢弃。而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</li>\n<li>Redis Stream的结构如下，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。每个 Stream 都有唯一的名称，它就是 Redis 的 key，在首次使用 xadd 指令追加消息时自动创建<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/en-us_image_0167982791.png\" alt=\"img\"><ul>\n<li><strong>Consumer Group</strong> ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。</li>\n<li><strong>last_delivered_id</strong> ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li>\n<li><strong>pending_ids</strong> ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。</li>\n</ul>\n</li>\n<li>相关操作</li>\n</ol>\n</li>\n<li><p>管道技术：</p>\n<ol>\n<li>Redis是一种基于客户端-服务端模型以及请求/响应协议的TCP服务。这意味着通常情况下一个请求会遵循以下步骤：<ul>\n<li>客户端向服务端发送一个查询请求，并监听Socket返回，通常是以阻塞模式，等待服务端响应。</li>\n<li>服务端处理命令，并将结果返回给客户端。</li>\n</ul>\n</li>\n<li>Redis 管道技术可以在服务端未响应时，客户端可以继续向服务端发送请求，并最终一次性读取所有服务端的响应。可以显著提高redis服务的性能</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Spring-Data相关-1\"><a href=\"#2-Spring-Data相关-1\" class=\"headerlink\" title=\"2.Spring Data相关\"></a>2.Spring Data相关</h4><ol>\n<li><p>connection to redis：无论用哪个包，都可以通过<code>RedisConnection</code>和<code>RedisConnecctionFactory</code>两个接口来取回与Redis的连接，并且屏蔽了底层的异常转换细节。</p>\n<ol>\n<li><p>Lettuce连接操作如下</p>\n<ol>\n<li><p>导入依赖</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependencies&gt;\n  &lt;!-- other dependency elements omitted --&gt;\n  &lt;dependency&gt;\n    &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;6.2.0.RELEASE&lt;&#x2F;version&gt;\n  &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;</code></pre></li>\n<li><p>创建连接工厂：工厂创建的LettuceConnection共享相同的线程安全的原生连接来做无锁非事务的操作，通过设置<code>shareNativeConnection</code>为false可以使用专用的连接。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\nclass AppConfig &#123;\n    @Bean\n    public LettuceConnectionFactory redisConnectionFactory() &#123;\n        return new LettuceConnectionFactory(new RedisStandaloneConfiguration(&quot;server&quot;, 6379));\n        \n        &#x2F;&#x2F;Lettuce集成了Netty的原生接口，可以使用Unix的socket来与Redis通信\n        &#x2F;&#x2F; return new LettuceConnectionFactory(\n        &#x2F;&#x2F;new RedisSocketConfiguration(&quot;&#x2F;var&#x2F;run&#x2F;redis.sock&quot;));\n    &#125;\n&#125;\n&#x2F;&#x2F;使用\n&#x2F;&#x2F;通过依赖注入和RedisConnection redisConnection &#x3D; redisConnectionFactory.getConnection();\n&#x2F;&#x2F;可通过redisConnection来操作Redis</code></pre></li>\n<li><p>写主读从：通过用<code>LettuceClientConfiguration</code>来配置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\nclass WriteToMasterReadFromReplicaConfiguration &#123;\n    @Bean\n    public LettuceConnectionFactory redisConnectionFactory() &#123;\n\t&#x2F;&#x2F;客户端配置\n        LettuceClientConfiguration clientConfig &#x3D; LettuceClientConfiguration.builder()\n            .readFrom(REPLICA_PREFERRED)\n            .build();\n\t&#x2F;&#x2F;服务端配置\n        RedisStandaloneConfiguration serverConfig &#x3D; new RedisStandaloneConfiguration(&quot;server&quot;, 6379);\n\n        return new LettuceConnectionFactory(serverConfig, clientConfig);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>Jedis客户端：Jedis不是线程安全的，通过JedisPool获得Jedis实例，直接使用Jedis中的方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface CoffeeRepository extends JpaRepository&lt;Coffee, Long&gt; &#123; &#125;\n\n@Service\npublic class CoffeeService &#123;\n    @Autowired\n    private CoffeeRepository coffeeRepository;\n    public List&lt;Coffee&gt; findAllCoffee() &#123;\n        return coffeeRepository.findAll();\n    &#125;\n&#125;\n\n@EnableTransactionManagement\n@SpringBootApplication\n@EnableJpaRepositories\npublic class SpringBucksApplication implements ApplicationRunner &#123;\n\t@Autowired\n\tprivate CoffeeService coffeeService;\n\t@Autowired\n\tprivate JedisPool jedisPool;\n\t@Autowired\n\tprivate JedisPoolConfig jedisPoolConfig;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(SpringBucksApplication.class, args);\n\t&#125;\n\n\t@Bean\n\t@ConfigurationProperties(&quot;redis&quot;)\n\tpublic JedisPoolConfig jedisPoolConfig() &#123;\n\t\treturn new JedisPoolConfig();\n\t&#125;\n\t@Bean(destroyMethod &#x3D; &quot;close&quot;)\n\tpublic JedisPool jedisPool(@Value(&quot;$&#123;redis.host&#125;&quot;) String host) &#123;\n\t\treturn new JedisPool(jedisPoolConfig(), host);\n\t&#125;\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception &#123;\n\t\tlog.info(jedisPoolConfig.toString());\n\n\t\ttry (Jedis jedis &#x3D; jedisPool.getResource()) &#123;\n\t\t\tcoffeeService.findAllCoffee().forEach(c -&gt; &#123;\n\t\t\t\tjedis.hset(&quot;springbucks-menu&quot;,\n\t\t\t\t\t\tc.getName(),\n\t\t\t\t\t\tLong.toString(c.getPrice().getAmountMinorLong()));\n\t\t\t&#125;);\n\n\t\t\tMap&lt;String, String&gt; menu &#x3D; jedis.hgetAll(&quot;springbucks-menu&quot;);\n\t\t\tlog.info(&quot;Menu: &#123;&#125;&quot;, menu);\n\n\t\t\tString price &#x3D; jedis.hget(&quot;springbucks-menu&quot;, &quot;espresso&quot;);\n\t\t\tlog.info(&quot;espresso - &#123;&#125;&quot;,\n\t\t\t\t\tMoney.ofMinor(CurrencyUnit.of(&quot;CNY&quot;), Long.parseLong(price)));\n\t\t&#125;\n\t&#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>Lettuce和Jedis的特性支持</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Supported Feature</th>\n<th align=\"left\">Lettuce</th>\n<th align=\"left\">Jedis</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">Standalone Connections</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Master/Replica Connections</td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">Redis Sentinel</td>\n<td align=\"left\">Master Lookup, Sentinel Authentication, Replica Reads</td>\n<td align=\"left\">Master Lookup</td>\n</tr>\n<tr>\n<td align=\"left\">Redis Cluster</td>\n<td align=\"left\">Cluster Connections, Cluster Node Connections, Replica Reads</td>\n<td align=\"left\">Cluster Connections, Cluster Node Connections</td>\n</tr>\n<tr>\n<td align=\"left\">Transport Channels</td>\n<td align=\"left\">TCP, OS-native TCP (epoll, kqueue), Unix Domain Sockets</td>\n<td align=\"left\">TCP</td>\n</tr>\n<tr>\n<td align=\"left\">Connection Pooling</td>\n<td align=\"left\">X (using <code>commons-pool2</code>)</td>\n<td align=\"left\">X (using <code>commons-pool2</code>)</td>\n</tr>\n<tr>\n<td align=\"left\">Other Connection Features</td>\n<td align=\"left\">Singleton-connection sharing for non-blocking commands</td>\n<td align=\"left\">Pipelining and Transactions mutually exclusive. Cannot use server/connection commands in pipeline/transactions.</td>\n</tr>\n<tr>\n<td align=\"left\">SSL Support</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Pub/Sub</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X</td>\n</tr>\n<tr>\n<td align=\"left\">Pipelining</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X (Pipelining and Transactions mutually exclusive)</td>\n</tr>\n<tr>\n<td align=\"left\">Transactions</td>\n<td align=\"left\">X</td>\n<td align=\"left\">X (Pipelining and Transactions mutually exclusive)</td>\n</tr>\n<tr>\n<td align=\"left\">Datatype support</td>\n<td align=\"left\">Key, String, List, Set, Sorted Set, Hash, Server, Stream, Scripting, Geo, HyperLogLog</td>\n<td align=\"left\">Key, String, List, Set, Sorted Set, Hash, Server, Scripting, Geo, HyperLogLog</td>\n</tr>\n<tr>\n<td align=\"left\">Reactive (non-blocking) API</td>\n<td align=\"left\">X</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>部署方式</p>\n<ol>\n<li><p>Sentinel 支持：是Redis的一种高可用方案</p>\n<ol>\n<li><p>通过<code>RedisSentinelConfiguration</code>来配置哨兵模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Lettuce\n@Bean\npublic RedisConnectionFactory lettuceConnectionFactory() &#123;\n    RedisSentinelConfiguration sentinelConfig &#x3D; new RedisSentinelConfiguration()\n        .master(&quot;mymaster&quot;)\n        .sentinel(&quot;127.0.0.1&quot;, 26379)\n        .sentinel(&quot;127.0.0.1&quot;, 26380);\n    return new LettuceConnectionFactory(sentinelConfig);\n&#125;\n&#x2F;&#x2F; Jedis\n@Bean\npublic RedisConnectionFactory jedisConnectionFactory() &#123;\n    RedisSentinelConfiguration sentinelConfig &#x3D; new RedisSentinelConfiguration()\n        .master(&quot;mymaster&quot;)\n        .sentinel(&quot;127.0.0.1&quot;, 26379)\n        .sentinel(&quot;127.0.0.1&quot;, 26380);\n    return new JedisConnectionFactory(sentinelConfig);\n&#125;\n&#x2F;&#x2F;使用\n</code></pre></li>\n<li><p>通过配置文件</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">spring.redis.sentinel.master: name of the master node.\nspring.redis.sentinel.nodes: Comma delimited list of host:port pairs.\nspring.redis.sentinel.username: The username to apply when authenticating with Redis Sentinel (requires Redis 6)\nspring.redis.sentinel.password: The password to apply when authenticating with Redis Sentinel</code></pre></li>\n<li><p>和其中一个哨兵直接交互：使用<code>RedisConnectionFactory.getSentinelConnection()</code>或者<code>RedisConnection.getSentinelCommands()</code>可以访问配置的第一个活跃的Sentinel</p>\n</li>\n</ol>\n</li>\n<li><p>==Redis Cluster==</p>\n<ol>\n<li>数据自动分片，分成16384个Hash Slot，在部分节点失效时有一定可用性</li>\n<li>RedisClusterConfiguration</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>RedisTemplate：封装了序列化和连接管理，提供更多的易于操作的API</p>\n<ol>\n<li><p>RedisTemplate&lt;K,V&gt;示例：<code>opsForXxx()</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class CoffeeService &#123;\n    private static final String CACHE &#x3D; &quot;springbucks-coffee&quot;;\n    @Autowired\n    private CoffeeRepository coffeeRepository;\n    @Autowired\n    private RedisTemplate&lt;String, Coffee&gt; redisTemplate;\n\n    public Optional&lt;Coffee&gt; findOneCoffee(String name) &#123;\n        &#x2F;&#x2F;获取操作\n        HashOperations&lt;String, String, Coffee&gt; hashOperations &#x3D; redisTemplate.opsForHash();\n        if (redisTemplate.hasKey(CACHE) &amp;&amp; hashOperations.hasKey(CACHE, name)) &#123;\n            &#x2F;&#x2F;name指定的数据在缓存中，则从缓存中取出\n            return Optional.of(hashOperations.get(CACHE, name));\n        &#125;\n        ExampleMatcher matcher &#x3D; ExampleMatcher.matching()\n                .withMatcher(&quot;name&quot;, exact().ignoreCase());\n        Optional&lt;Coffee&gt; coffee &#x3D; coffeeRepository.findOne(\n                Example.of(Coffee.builder().name(name).build(), matcher));\n        if (coffee.isPresent()) &#123;\n           \t&#x2F;&#x2F;加入缓存\n            hashOperations.put(CACHE, name, coffee.get());\n            &#x2F;&#x2F;设置过期时间！！！\n            redisTemplate.expire(CACHE, 1, TimeUnit.MINUTES);\n        &#125;\n        return coffee;\n    &#125;\n&#125;\n</code></pre></li>\n<li><p>StringRedisTemplate：简化操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Example &#123;\n  @Autowired\n  private StringRedisTemplate redisTemplate;\n  public void addLink(String userId, URL url) &#123;\n    redisTemplate.opsForList().leftPush(userId, url.toExternalForm());\n  &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>缓存</p>\n<ol>\n<li><p>Spring Data的缓存抽象</p>\n<ol>\n<li><p>为不同的缓存提供一层抽象  </p>\n<ol>\n<li>为Java方法增加缓存，缓存执行结果</li>\n<li>支持ConcurrentMap、EhCache、Caffeine、JCache (JSR-107)</li>\n<li>接口<ul>\n<li>org.springframework.cache.Cache</li>\n<li>org.springframework.cache.cacheManager</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>基于注解的缓存：@EnableCaching，开启缓存支持</p>\n<ul>\n<li>@Cacheable：如果方法结果已经在缓存里了，就直接在缓存中去；如果不在，就执行并将执行结果放入缓存中</li>\n<li>@CacheEvict：缓存清理</li>\n<li>@CachePut：不管执行情况，直接做缓存的设置</li>\n<li>@caching：对上面的操作进行打包，在里面放入多个操作</li>\n<li>@cacheConfig：对缓存进行设置，比如设置缓存的名字</li>\n</ul>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\n@CacheConfig(cacheNames &#x3D; &quot;coffee&quot;)\npublic class CoffeeService &#123;\n    @Autowired\n    private CoffeeRepository coffeeRepository;\n    @Cacheable\n    public List&lt;Coffee&gt; findAllCoffee() &#123;\n        return coffeeRepository.findAll();\n    &#125;\n    @CacheEvict\n    public void reloadCoffee() &#123;\n    &#125;\n&#125;\n@EnableTransactionManagement\n@SpringBootApplication\n@EnableJpaRepositories\n@EnableCaching(proxyTargetClass &#x3D; true)\npublic class SpringBucksApplication implements ApplicationRunner &#123;\n\t@Autowired\n\tprivate CoffeeService coffeeService;\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(SpringBucksApplication.class, args);\n\t&#125;\n\n\t@Override\n\tpublic void run(ApplicationArguments args) throws Exception &#123;\n\t\tlog.info(&quot;Count: &#123;&#125;&quot;, coffeeService.findAllCoffee().size());\n\t\tfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n\t\t\tcoffeeService.findAllCoffee();&#x2F;&#x2F;在缓存中读取的\n\t\t&#125;\n\t\tcoffeeService.reloadCoffee();\n        &#x2F;&#x2F;SQL查询，重新获取\n\t\tcoffeeService.findAllCoffee().forEach(c -&gt; log.info(&quot;Coffee &#123;&#125;&quot;, c.getName()));\n\t&#125;\n&#125;\n</code></pre></li>\n</ol>\n</li>\n<li><p>使用Redis作为缓存</p>\n<ol>\n<li><p>配置</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">spring.cache.type&#x3D;redis\nspring.cache.cache-names&#x3D;coffee\nspring.cache.redis.time-to-live&#x3D;5000\nspring.cache.redis.cache-null-values&#x3D;false\n\nspring.redis.host&#x3D;localhost</code></pre></li>\n<li><p>配置管理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\npublic RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123;\n\treturn RedisCacheManager.create(connectionFactory);\n&#125;\n&#x2F;&#x2F;RedisCacheManager的配置，默认无锁可选择加锁\nRedisCacheManager cm &#x3D; RedisCacheManager.builder(connectionFactory)\n\t.cacheDefaults(defaultCacheConfig())\n\t.withInitialCacheConfigurations(singletonMap(&quot;predefined&quot;, defaultCacheConfig().disableCachingNullValues()))\n\t.transactionAware()\n\t.build();\n&#x2F;&#x2F;RedisCache的配置\nRedisCacheConfiguration config &#x3D; RedisCacheConfiguration.defaultCacheConfig()\n    .entryTtl(Duration.ofSeconds(1))\n\t.disableCachingNullValues();</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-ElasticSearch\"><a href=\"#3-ElasticSearch\" class=\"headerlink\" title=\"3.ElasticSearch\"></a>3.ElasticSearch</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Elasticsearch 是一个分布式的 RESTful 搜索和分析引擎，可用来集中存储您的数据，以便您对形形色色、规模不一的数据进行搜索、索引和分析。</p></blockquote>\n<h4 id=\"1-ElasticSearch\"><a href=\"#1-ElasticSearch\" class=\"headerlink\" title=\"1.ElasticSearch\"></a>1.ElasticSearch</h4><h4 id=\"2-Spring-Data相关-2\"><a href=\"#2-Spring-Data相关-2\" class=\"headerlink\" title=\"2.Spring Data相关\"></a>2.Spring Data相关</h4><h2 id=\"Spring-Boot\"><a href=\"#Spring-Boot\" class=\"headerlink\" title=\"Spring Boot\"></a>Spring Boot</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>用来快速创建基于Spring的应用程序，不需要像Spring有很多配置，使得开发者更专注于业务</p></blockquote>\n<h3 id=\"1-概览\"><a href=\"#1-概览\" class=\"headerlink\" title=\"1.概览\"></a>1.概览</h3><h4 id=\"1-用SpringBoot开发\"><a href=\"#1-用SpringBoot开发\" class=\"headerlink\" title=\"1.用SpringBoot开发\"></a>1.用SpringBoot开发</h4><ol>\n<li><p>构建系统：</p>\n<ol>\n<li><p>用Maven或Gradle构建系统，将版本号提取的管理方法</p>\n</li>\n<li><p>Starter Dependency：直接面向功能，一站式获得所有相关依赖，定制自己的起步依赖示例如下</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;groupId&gt;geektime.spring.hello&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;geektime-spring-boot-starter&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;name&gt;geektime-spring-boot-starter&lt;&#x2F;name&gt;\n    &lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;geektime.spring.hello&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;geektime-spring-boot-autoconfigure&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;geektime.spring.hello&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;greeting&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre></li>\n<li><p>配置加载机制</p>\n<ol>\n<li><p>外化配置加载顺序：</p>\n<ol>\n<li>测试类的配置</li>\n<li>命令行参数（–server.port=9000）</li>\n<li>System.getProperties</li>\n<li>操作系统环境变量</li>\n<li>application.properties：先带profile的和jar包外的</li>\n</ol>\n</li>\n<li><p>application.properties</p>\n<ol>\n<li>位置：有默认的位置，可以通过spring.config.name等属性来更改</li>\n<li>Relaxed Binding<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220722113509695.png\" alt=\"image-20220722113509695\"></li>\n</ol>\n</li>\n<li><p>PropertySource抽象</p>\n<ol>\n<li><p>@PropertySource</p>\n</li>\n<li><p>@ConfigurationProperties</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ConfigurationProperties(prefix &#x3D; &quot;spring.jdbc&quot;)\npublic class JdbcProperties &#123;\n    private final Template template &#x3D; new Template();\n    public Template getTemplate() &#123;\n        return this.template;\n    &#125;\n    public static class Template &#123;\n        &#x2F;&#x2F;spring.jdbc.template.fetchSize属性\n        private int fetchSize &#x3D; -1;\n        private int maxRows &#x3D; -1;\n        @DurationUnit(ChronoUnit.SECONDS)\n        private Duration queryTimeout;\n        public int getFetchSize() &#123;\n            return this.fetchSize;\n        &#125;\n        public void setFetchSize(int fetchSize) &#123;\n            this.fetchSize &#x3D; fetchSize;\n        &#125;\n        public int getMaxRows() &#123;\n            return this.maxRows;\n        &#125;\n        public void setMaxRows(int maxRows) &#123;\n            this.maxRows &#x3D; maxRows;\n        &#125;\n        public Duration getQueryTimeout() &#123;\n            return this.queryTimeout;\n        &#125;\n        public void setQueryTimeout(Duration queryTimeout) &#123;\n            this.queryTimeout &#x3D; queryTimeout;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>定制PropertySource</p>\n<ul>\n<li>实现PropertySource&lt;T&gt;</li>\n<li>从Environment取得PropertySources</li>\n<li>将自己的PropertySource添加到合适的位置</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RandomValuePropertySource extends PropertySource&lt;Random&gt; &#123; \n\n\tprivate static final Log logger &#x3D; LogFactory.getLog(RandomValuePropertySource.class);\n\n\tpublic RandomValuePropertySource(String name) &#123;\n\t\tsuper(name, new Random());\n\t&#125;\n\n\tpublic RandomValuePropertySource() &#123;\n\t\tthis(RANDOM_PROPERTY_SOURCE_NAME);\n\t&#125;\n\n\t@Override\n\tpublic Object getProperty(String name) &#123;\n\t\tif (!name.startsWith(PREFIX)) &#123;\n\t\t\treturn null;\n\t\t&#125;\n\t\tif (logger.isTraceEnabled()) &#123;\n\t\t\tlogger.trace(&quot;Generating random property for &#39;&quot; + name + &quot;&#39;&quot;);\n\t\t&#125;\n\t\treturn getRandomValue(name.substring(PREFIX.length()));\n\t&#125;\n\n\tprivate Object getRandomValue(String type) &#123;\n\t\tif (type.equals(&quot;int&quot;)) &#123;\n\t\t\treturn getSource().nextInt();\n\t\t&#125;\n\t\tif (type.equals(&quot;long&quot;)) &#123;\n\t\t\treturn getSource().nextLong();\n\t\t&#125;\n\t\tString range &#x3D; getRange(type, &quot;int&quot;);\n\t\tif (range !&#x3D; null) &#123;\n\t\t\treturn getNextIntInRange(range);\n\t\t&#125;\n\t\trange &#x3D; getRange(type, &quot;long&quot;);\n\t\tif (range !&#x3D; null) &#123;\n\t\t\treturn getNextLongInRange(range);\n\t\t&#125;\n\t\tif (type.equals(&quot;uuid&quot;)) &#123;\n\t\t\treturn UUID.randomUUID().toString();\n\t\t&#125;\n\t\treturn getRandomBytes();\n\t&#125;\n&#125;\n</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>代码结构</p>\n<ol>\n<li>不适用default包，而是使用翻转域名的方式，例如：<code>com.example.project</code></li>\n<li>将application类放在根包下，代码结构如下：<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220630231418168.png\" alt=\"image-20220630231418168\" style=\"zoom:67%;\" /></li>\n</ol>\n</li>\n<li><p>配置类：</p>\n<ol>\n<li>导入附加的配置类：将<code>@Configuration</code>加到每一个类上，<code>@Import</code>能用来导入额外的配置类，可以用<code>@ComponentScan</code>来自动地提取所有Spring成分（components）</li>\n<li>导入XML配置：用<code>@Configuration</code>修饰类，相当于把该类作为Spring的xml配置文件中的<code>&lt;beans&gt;</code>，然后就可以用<code>@ImportResource</code>来载入配置文件</li>\n</ol>\n</li>\n<li><p>Beans&amp;DI</p>\n<ol>\n<li><p>可以用<code>@ComponentScan</code>找到bean，如果将application放到顶层，那么用<code>@SpringBootApplication</code>就不用再用<code>@ComponentScan</code>，而且使得应用成分（<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>, and others）都被自动注册成Spring Beans</p>\n</li>\n<li><p>使用构造器注入时候，如果一个bean有超过一个构造器，可以使用<code>@Autowired</code>来标记让Spring使用哪一个</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class MyAccountService implements AccountService &#123;\n\n    private final RiskAssessor riskAssessor;\n    private final PrintStream out;\n\n    @Autowired\n    public MyAccountService(RiskAssessor riskAssessor) &#123;\n        this.riskAssessor &#x3D; riskAssessor;\n        this.out &#x3D; System.out;\n    &#125;\n\n    public MyAccountService(RiskAssessor riskAssessor, PrintStream out) &#123;\n        this.riskAssessor &#x3D; riskAssessor;\n        this.out &#x3D; out;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>开发工具（spring-boot-devtools依赖）</p>\n<ol>\n<li><p>application.properties文件：可以配置属性，提高性能</p>\n</li>\n<li><p>自动重启：当类路径下文件有改变时，会有类加载问题</p>\n<ol>\n<li><p>日志会记录</p>\n</li>\n<li><p>资源会被重新载入，不想载入：<code>spring.devtools.restart.exclude=static/**,public/**</code></p>\n</li>\n<li><p>关闭自动重启：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\npublic class MyApplication &#123;\n    public static void main(String[] args) &#123;\n        System.setProperty(&quot;spring.devtools.restart.enabled&quot;, &quot;false&quot;);\n        SpringApplication.run(MyApplication.class, args);\n    &#125;\n&#125;</code></pre></li>\n<li><p>使用触发文件：在resource文件下新建<code>.reloadtrigger</code>文件，文件里有<code>spring.devtools.restart.trigger-file=.reloadtrigger</code>，仅在此文件被更新时，才会发生重启</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Auto-Configuration\"><a href=\"#2-Auto-Configuration\" class=\"headerlink\" title=\"2.Auto Configuration\"></a>2.Auto Configuration</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>基于添加的JAR依赖自动对Spring Boot应用程序进行配置</p></blockquote>\n<ol>\n<li><p><code>@SpringBootApplication</code>注解，包括三个特性：</p>\n<ol>\n<li><code>@EnableAutoConfiguration</code>：启动SpringBoot的自动配置机制，猜测开发者想怎样配置，比如<code>spring-boot-starter-web</code>加了Tomcat和Spring MVC，自动配置假设开发者想要开发一个web应用，并且据此设计Spring</li>\n<li><code>@ComponentScan</code>：在application所在的包启动<code>@Component</code>扫描</li>\n<li><code>@SpringBootConfiguration</code>：启动在上下文中注册额外的bean或导入额外的配置类，有助于在集成测试中进行配置检测</li>\n</ol>\n</li>\n<li><p>原理</p>\n<ol>\n<li><code>@EnableAutoConfiguration</code>导入了<code>AutoConfigurationImportSelector</code>帮助加载spring.factories中的<code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>属性</li>\n<li>条件注解<ul>\n<li>条件注解<ul>\n<li>@Conditional：Spring4.0引入</li>\n</ul>\n</li>\n<li>类条件<ul>\n<li>@ConditionalOnClass：配置了某个类时</li>\n<li>@ConditionalOnMissingClass：没有配置了某个类时</li>\n</ul>\n</li>\n<li>属性条件<ul>\n<li>@conditionalOnProperty：配置了某个属性时</li>\n</ul>\n</li>\n<li>Bean条件<ul>\n<li>@ConditionalOnBean：配置了某个Bean时</li>\n<li>@ConditionalOnMissingBean：没有配置某个Bean时</li>\n<li>@ConditionalOnSingleCandidata：上下文只有一个候选Bean，或一个Primary的Bean</li>\n</ul>\n</li>\n<li>其他条件<ul>\n<li>资源条件：@ConditionalOnResource</li>\n<li>Web应用条件：@ConditionalOnWebApplication：是Web应用</li>\n<li>Web应用条件：@ConditionalOnNotWebApplication：不是Web应用</li>\n<li>@conditionalOnExpression</li>\n<li>@Conditional0nJava</li>\n<li>@conditionalOnJndi</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>了解自动配置的情况：通过命令行添加<code>--debug</code>，可以看到执行结果，主要是通过<code>ConditionEvaluationReportLoggingListener</code>来输出 <ul>\n<li>Positive matches：匹配的自动配置</li>\n<li>Negative matches：没匹配的自动配置</li>\n<li>Exclusions：排除掉了哪些自动配置</li>\n<li>Unconditional classes：无条件配置的自动配置</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>定制</p>\n<ol>\n<li><p>编写Java Config（<code>@Configuration</code>），添加条件（<code>@Conditional</code>），定位自动配置（META-INF/spring.factories）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n@ConditionalOnClass(GreetingApplicationRunner.class)\npublic class GreetingAutoConfiguration &#123;\n    @Bean\n    @ConditionalOnMissingBean(GreetingApplicationRunner.class)\n    @ConditionalOnProperty(name &#x3D; &quot;greeting.enabled&quot;, havingValue &#x3D; &quot;true&quot;, matchIfMissing &#x3D; true)\n    public GreetingApplicationRunner greetingApplicationRunner() &#123;\n        return new GreetingApplicationRunner();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-运行监测管理\"><a href=\"#3-运行监测管理\" class=\"headerlink\" title=\"3.运行监测管理\"></a>3.运行监测管理</h4><h5 id=\"1-Actuator\"><a href=\"#1-Actuator\" class=\"headerlink\" title=\"1.Actuator\"></a>1.Actuator</h5><ol>\n<li><p>概述：依赖<code>spring-boot-starter-actuator</code>，HTTP访问<code>/actuator/\\&lt;id\\&gt;</code>，有以下配置可选</p>\n<ul>\n<li>端口与路径<ul>\n<li>management.server.address=</li>\n<li>management.server.port=</li>\n<li>management.endpoints.web.base-path=/actuator</li>\n<li>management.endpoints.web.path-mapping.&lt;id&gt;=路径</li>\n</ul>\n</li>\n<li>开启Endpoint<ul>\n<li>management.endpoint.&lt;id&gt;.enabled=true</li>\n<li>management.endpoints.enabled-by-default=false</li>\n</ul>\n</li>\n<li>暴漏Endpoint<ul>\n<li>management.endpoints.jmx.exposure.exclude=</li>\n<li>management.endpoints.jmx.exposure.include=*</li>\n<li>management.endpoints.web.exposure.exclude=</li>\n<li>management.endpoints.web.exposure.include=info,health</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>常用Endpoint</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220722133552793.png\" alt=\"image-20220722133552793\"><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220722133610708.png\" alt=\"image-20220722133610708\"></p>\n</li>\n</ol>\n<h5 id=\"2-Health-Indicator\"><a href=\"#2-Health-Indicator\" class=\"headerlink\" title=\"2.Health Indicator\"></a>2.Health Indicator</h5><ol>\n<li><p>通过<code>HealthIndicatorRegistry</code>收集信息，<code>HealthIndicator</code>实现具体检查逻辑，有以下配置项</p>\n<ul>\n<li>management.health.defaults.enabled=truelfalse</li>\n<li>management.health.&lt;id&gt;.enabled=true</li>\n<li>management.endpoint.health.show-details=never lwhen-authorizedlalways</li>\n</ul>\n</li>\n<li><p>Spring Boot自带的Health Indicator<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220722143155086.png\" alt=\"image-20220722143155086\"></p>\n</li>\n<li><p>自定义Health Indicator：实现HealthIndicator接口，根据自定义检查逻辑返回对应Health状态，其中Health中包含状态和详细描述信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class CoffeeIndicator implements HealthIndicator &#123;\n    @Autowired\n    private CoffeeService coffeeService;\n    @Override\n    public Health health() &#123;\n        long count &#x3D; coffeeService.getCoffeeCount();\n        Health health;\n        if (count &gt; 0) &#123;\n            health &#x3D; Health.up()\n                    .withDetail(&quot;count&quot;, count)\n                    .withDetail(&quot;message&quot;, &quot;We have enough coffee.&quot;)\n                    .build();\n        &#125; else &#123;\n            health &#x3D; Health.down()\n                    .withDetail(&quot;count&quot;, 0)\n                    .withDetail(&quot;message&quot;, &quot;We are out of coffee.&quot;)\n                    .build();\n        &#125;\n        return health;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h5 id=\"3-Micrometer\"><a href=\"#3-Micrometer\" class=\"headerlink\" title=\"3.Micrometer\"></a>3.Micrometer</h5><ol>\n<li><p>特性</p>\n<ol>\n<li>多维度度量，支持Tag</li>\n<li>预制大量探针，如：缓存、类加载器、GC、CPU利用率、线程池</li>\n<li>与Spring深度整合，支持多种监控系统，如Prometheus、JMX</li>\n</ol>\n</li>\n<li><p>度量指标</p>\n<ol>\n<li>核心接口为Meter，内置了一些实现，如Gauge、Timer等</li>\n<li>访问的URL<ul>\n<li>/acutator/metrics</li>\n<li>/actuator/prometheus</li>\n</ul>\n</li>\n<li>在SpringBoot 2.x中的度量项：JVM、CPU、日志、启动时间等</li>\n</ol>\n</li>\n<li><p>自定义度量指标</p>\n<ol>\n<li>通过MeterRegistry注册Meter</li>\n<li>提供MeterBinder Bean 让 Spring Boot自动绑定</li>\n<li>通过MeterFilter进行定制</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\n@Transactional\n@Slf4j\npublic class CoffeeOrderService implements MeterBinder &#123;\n    @Autowired\n    private CoffeeOrderRepository orderRepository;\n\t&#x2F;&#x2F;监控订单数\n    private Counter orderCounter &#x3D; null;\n\n    public CoffeeOrder get(Long id) &#123;\n        return orderRepository.getOne(id);\n    &#125;\n\n    public CoffeeOrder createOrder(String customer, Coffee...coffee) &#123;\n        CoffeeOrder order &#x3D; CoffeeOrder.builder()\n                .customer(customer)\n                .items(new ArrayList&lt;&gt;(Arrays.asList(coffee)))\n                .state(OrderState.INIT)\n                .build();\n        CoffeeOrder saved &#x3D; orderRepository.save(order);\n        log.info(&quot;New Order: &#123;&#125;&quot;, saved);\n        orderCounter.increment();\n        return saved;\n    &#125;\n    @Override\n    public void bindTo(MeterRegistry meterRegistry) &#123;\n        this.orderCounter &#x3D; meterRegistry.counter(&quot;order.count&quot;);\n    &#125;\n&#125;\n</code></pre></li>\n</ol>\n<h5 id=\"4-定制运行参数\"><a href=\"#4-定制运行参数\" class=\"headerlink\" title=\"4.定制运行参数\"></a>4.定制运行参数</h5><ol>\n<li><p>修改容器配置</p>\n<ol>\n<li>端口<ul>\n<li>server.port</li>\n<li>server.address</li>\n</ul>\n</li>\n<li>压缩<ul>\n<li>server.compression.enabled</li>\n<li>server.compression.min-response-size</li>\n<li>server.compression.mime-types</li>\n</ul>\n</li>\n<li>Tomcat特定配置<ul>\n<li>server.tomcat.max-connections=10000</li>\n<li>server.tomcat.max-http-post-size=2MB</li>\n<li>server.tomcat.max-swallow-size=2MB</li>\n<li>server.tomcat.max-threads=200</li>\n<li>server.tomcat.min-spare-threads=10</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>配置HTTPS支持</p>\n<ol>\n<li><p>通过参数进行配置</p>\n<ul>\n<li>server.port=8443</li>\n<li>server.ssl.*<ul>\n<li>server.ssl.key-store</li>\n<li>server.ssl.key-store-type，JKS或者PKCS12</li>\n<li>server.ssl.key-store-password=secret</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">server.port&#x3D;8443\n#springbucks.p12为整证书文件\nserver.ssl.key-store&#x3D;classpath:springbucks.p12\nserver.ssl.key-store-type&#x3D;PKCS12\nserver.ssl.key-store-password&#x3D;spring</code></pre></li>\n<li><p>Java生成证书命令：keytool -genkey -alias别名 -storetype仓库类型 -keyalg算法 -keysize长度-keystore文件名 -validity 有效期</p>\n</li>\n<li><p>客户端HTTPS支持</p>\n<ol>\n<li><p>配置HttpClient ( &gt;= 4.4 )</p>\n<ul>\n<li>SSLContextBuilder构造SSLContext</li>\n<li>setSSLHostnameverifier(new NoopHostnameVerifier())</li>\n</ul>\n</li>\n<li><p>配置RequestFactory</p>\n<ul>\n<li>HttpComponentsClientHttpRequestFactory<ul>\n<li>setHttpClient()</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\n@Slf4j\npublic class CustomerServiceApplication &#123;\n\t@Value(&quot;$&#123;security.key-store&#125;&quot;)\n\tprivate Resource keyStore;\n\t@Value(&quot;$&#123;security.key-pass&#125;&quot;)\n\tprivate String keyPass;\n\n\tpublic static void main(String[] args) &#123;\n\t\tnew SpringApplicationBuilder()\n\t\t\t\t.sources(CustomerServiceApplication.class)\n\t\t\t\t.bannerMode(Banner.Mode.OFF)\n\t\t\t\t.web(WebApplicationType.NONE)\n\t\t\t\t.run(args);\n\t&#125;\n\t@Bean\n\tpublic HttpComponentsClientHttpRequestFactory requestFactory() &#123;\n\t\tSSLContext sslContext &#x3D; null;\n\t\ttry &#123;\n\t\t\tsslContext &#x3D; SSLContextBuilder.create()\n\t\t\t\t\t&#x2F;&#x2F; 会校验证书\n\t\t\t\t\t.loadTrustMaterial(keyStore.getURL(), keyPass.toCharArray())\n\t\t\t\t\t&#x2F;&#x2F; 放过所有证书校验\n&#x2F;&#x2F;\t\t\t\t\t.loadTrustMaterial(null, (certificate, authType) -&gt; true)\n\t\t\t\t\t.build();\n\t\t&#125; catch(Exception e) &#123;\n\t\t\tlog.error(&quot;Exception occurred while creating SSLContext.&quot;, e);\n\t\t&#125;\n\n\t\tCloseableHttpClient httpClient &#x3D; HttpClients.custom()\n\t\t\t\t.evictIdleConnections(30, TimeUnit.SECONDS)\n\t\t\t\t.setMaxConnTotal(200)\n\t\t\t\t.setMaxConnPerRoute(20)\n\t\t\t\t.disableAutomaticRetries()\n\t\t\t\t.setKeepAliveStrategy(new CustomConnectionKeepAliveStrategy())\n\t\t\t\t.setSSLContext(sslContext)\n\t\t\t\t.setSSLHostnameVerifier(NoopHostnameVerifier.INSTANCE)\n\t\t\t\t.build();\n\n\t\tHttpComponentsClientHttpRequestFactory requestFactory &#x3D;\n\t\t\t\tnew HttpComponentsClientHttpRequestFactory(httpClient);\n\n\t\treturn requestFactory;\n\t&#125;\n\n\t@Bean\n\tpublic RestTemplate restTemplate(RestTemplateBuilder builder) &#123;\n\t\treturn builder\n\t\t\t\t.setConnectTimeout(Duration.ofMillis(100))\n\t\t\t\t.setReadTimeout(Duration.ofMillis(500))\n\t\t\t\t.requestFactory(this::requestFactory)\n\t\t\t\t.build();\n\t&#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>配置HTTP/2支持</p>\n<ol>\n<li>配置SSL</li>\n<li>HTTP库：OKHttp</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"5-打包成Docker镜像\"><a href=\"#5-打包成Docker镜像\" class=\"headerlink\" title=\"5.打包成Docker镜像\"></a>5.打包成Docker镜像</h5><h3 id=\"2-核心特性\"><a href=\"#2-核心特性\" class=\"headerlink\" title=\"2.核心特性\"></a>2.核心特性</h3><h4 id=\"1-SpringApplication\"><a href=\"#1-SpringApplication\" class=\"headerlink\" title=\"1.SpringApplication\"></a>1.SpringApplication</h4><ol>\n<li><strong>启动失败：</strong>如果应用启动失败，<code>FailureAnalyzers</code>将会提示错误信息并且给出修复错误的方式。如果没有<code>FailureAnalyzers</code>可以处理，仍将会有全条件报告，只需要启动<code>debug</code>属性和<code>DEBUG</code>属性，例如：<code>$ java -jar myproject-0.0.1-SNAPSHOT.jar --debug</code></li>\n<li><strong>懒加载：</strong>beans只有在需要时才会被创造，可以减少启动时间。但会推迟问题的出现，容易造成JVM内存不足，所以默认不支持，通过<code>spring.main.lazy-initialization=true</code>使用</li>\n<li><strong>可用性：</strong>当部署在平台上后，应用可以向基础设施（K8s）提供关于自己可用性的信息。并且可以把状态暴露出来用于监听或者手动更改<ol>\n<li>Liveness State：此状态用来告知内部，正在正确工作或者现在不能用但可以自行恢复，如果达不到此状态则说明应用不能恢复需要基础设施来重启它（通常不涉及外部系统，如数据库）</li>\n<li>Readiness State：此状态用来告知应用已经准备好，可以接受路由来的流量，一般发生在启动时或者流量太大时</li>\n</ol>\n</li>\n<li><strong>事件和监听：</strong><ol>\n<li>使用：用<code>SpringApplication.addListeners(…)</code>或<code>SpringApplicationBuilder.listeners(…)</code>方法，也可以创建<code>META-INF/spring.factories</code>文件，并在里面添加<code>org.springframework.context.ApplicationListener=com.example.project.MyListener</code>关键字</li>\n<li>事件按一定顺序依次被发送，有SpringApplication相关的事件和其它事件（如<code>WebServerInitializedEvent</code>），</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Externalized-Configuration\"><a href=\"#2-Externalized-Configuration\" class=\"headerlink\" title=\"2.Externalized Configuration\"></a>2.Externalized Configuration</h4><ol>\n<li><p><strong>目的：</strong>可以使得同一应用在不同环境下运行，</p>\n</li>\n<li><p><strong>使用：</strong>通过<code>@Value</code>注入beans，通过Spring的Environment抽象访问，或者通过<code>ConfigurationProperties</code>绑定到结构化对象</p>\n</li>\n<li><p><strong>特殊的属性覆盖顺序：</strong></p>\n<ol>\n<li>默认配置（以及<code>SpringApplication.setDefaultProperties</code>）</li>\n<li><code>Configuration</code>类的<code>@PropertySource</code>注解，直到上下文被刷新才会被加载进环境，所以对于一些属性来说太迟了</li>\n<li>配置文件（yaml文件同理，但会被properties覆盖）：<ol>\n<li>jar包内的<code>application.properties</code></li>\n<li>jar包内的特定应用的<code>application&#123;profile&#125;.properties</code></li>\n<li>jar包外的<code>application.properties</code></li>\n<li>jar包外的特定应用的<code>application&#123;profile&#125;.properties</code></li>\n</ol>\n</li>\n<li>操作系统环境变量、命令行参数（<code>--server.port=9000</code>）</li>\n<li>测试使用的相关属性</li>\n</ol>\n</li>\n<li><p><strong>External Application Properties：</strong></p>\n<ol>\n<li>SpringBoot可以在指定目录下自动载入<code>application.yaml</code>文件（类路径、类路径/config、当前目录、当前目录的/config子目录、第一层子目录下的/config子目录）</li>\n<li>路径可以使用通配符（*）、属性占位符（<code>$&#123;name:default&#125;</code>）、配置特定文件（<code>application-dev.properties</code>）、导入附加的数据（<code>spring.config.import=optional:file:./dev.properties</code>）、导入无扩展名文件（<code>spring.config.import=file:/etc/config/myconfig[.yaml]</code>）、使用配置树（<code>spring.config.import=optional:configtree:/etc/config/</code>）</li>\n</ol>\n</li>\n<li><p><strong>类型安全的配置属性：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ConfigurationProperties(&quot;my.service&quot;)\npublic class MyProperties &#123;\n\t&#x2F;&#x2F;my.service.enabled, with a value of false by default.\n    private boolean enabled;\n    &#x2F;&#x2F;my.service.remote-address, with a type that can be coerced from String.\n    private InetAddress remoteAddress;\n    private final Security security &#x3D; new Security();\n\t\n    &#x2F;&#x2F; getters &#x2F; setters...\n    public static class Security &#123;\n\n        &#x2F;&#x2F;my.service.security.username, with a nested &quot;security&quot; object whose \n        &#x2F;&#x2F;name is determined by the name of the property. In particular, \n        &#x2F;&#x2F;the type is not used at all there and could have been SecurityProperties.\n        private String username;\n        private String password;\n        &#x2F;&#x2F;my.service.security.roles, with a collection of String that defaults to USER.\n        private List&lt;String&gt; roles &#x3D; new ArrayList&lt;&gt;(Collections.singleton(&quot;USER&quot;));\n        \n        &#x2F;&#x2F; getters &#x2F; setters...\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"3-JSON\"><a href=\"#3-JSON\" class=\"headerlink\" title=\"3.JSON\"></a>3.JSON</h4><ol>\n<li><p>可以使用Gson、Jackson、JSON-8，但推荐使用Jackson</p>\n</li>\n<li><p>自定义序列化器和反序列化器（默认用Jackson注册），用<code>@JsonComponent</code> 注解修饰 <code>JsonSerializer</code>和 <code>JsonDeserializer</code>实现，也可以直接用在外部类上：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@JsonComponent\npublic class MyJsonComponent &#123;\n\n    public static class Serializer extends JsonSerializer&lt;MyObject&gt; &#123;\n\n        @Override\n        public void serialize(MyObject value, JsonGenerator jgen, SerializerProvider serializers) throws IOException &#123;\n            jgen.writeStartObject();\n            jgen.writeStringField(&quot;name&quot;, value.getName());\n            jgen.writeNumberField(&quot;age&quot;, value.getAge());\n            jgen.writeEndObject();\n        &#125;\n    &#125;\n\n    public static class Deserializer extends JsonDeserializer&lt;MyObject&gt; &#123;\n\n        @Override\n        public MyObject deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException &#123;\n            ObjectCodec codec &#x3D; jsonParser.getCodec();\n            JsonNode tree &#x3D; codec.readTree(jsonParser);\n            String name &#x3D; tree.get(&quot;name&quot;).textValue();\n            int age &#x3D; tree.get(&quot;age&quot;).intValue();\n            return new MyObject(name, age);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h4 id=\"4-Task-Excution-and-Scheduling\"><a href=\"#4-Task-Excution-and-Scheduling\" class=\"headerlink\" title=\"4.Task Excution and Scheduling\"></a>4.Task Excution and Scheduling</h4><ol>\n<li><p>如果上下文中缺少<code>Executor</code>，SpringBoot会自动配置一个具有合理默认值（可更改）的<code>ThreadPoolTaskExecutor</code>，可以自动关联到异步任务执行（<code>@EnableAsync</code>）和Spring MVC异步请求处理，如下：</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">#16个线程，队列容量为100，线程空闲10s后被收回\nspring.task.execution.pool.max-size&#x3D;16\nspring.task.execution.pool.queue-capacity&#x3D;100\nspring.task.execution.pool.keep-alive&#x3D;10s</code></pre></li>\n</ol>\n<h4 id=\"5-其它\"><a href=\"#5-其它\" class=\"headerlink\" title=\"5.其它\"></a>5.其它</h4><ol>\n<li><p>Profiles：是一种分离应用程序配置部分使其仅在某些环境可用的方法，任何<code>@Component</code>, <code>@Configuration</code> 或 <code>@ConfigurationProperties</code>都可以被<code>@Profile</code>标记来限制加载的时间（可以使用<code>spring.profiles.active=dev,hsqldb</code>来指定那些配置文件处于活跃状态）如下所示：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration(proxyBeanMethods &#x3D; false)\n@Profile(&quot;production&quot;)\npublic class ProductionConfiguration &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>Logging：</p>\n<ol>\n<li><p><strong>日志格式：</strong></p>\n<ul>\n<li>Log Level：ERROR、WARN、INFO、DEBUG、TRACE</li>\n<li>格式：日期和时间 日子级别 线程ID — [线程名] 类名 ：日志信息</li>\n</ul>\n</li>\n<li><p><strong>输出：</strong></p>\n<ol>\n<li>console输出：默认有ERROR、WARN、INFO级别，可以加–debug来增加DEBUG级别</li>\n<li>File输出：默认不输出到文件，需要在application.properties中设置<code>logging.file.name</code> 或 <code>logging.file.path</code>属性</li>\n<li>日志级别：通过<code>logging.level.&lt;logger-name&gt;=&lt;level&gt;</code>来指定日志级别</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Internationalization：SpringBoot支持本地化消息，以便应用程序可以满足不同语言偏好的用户，默认情况下，SpringBoot在类路径的根部目中查找资源包（<code>messages.properties</code>）的存在</p>\n</li>\n</ol>\n<h3 id=\"3-Web\"><a href=\"#3-Web\" class=\"headerlink\" title=\"3.Web\"></a>3.Web</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>通过SpringBoot内嵌的Tomcat、Jetty、Undertow、Nwtty来构建一个自给自足的HTTP服务器</p></blockquote>\n<h4 id=\"1-Servelt-Web-Application\"><a href=\"#1-Servelt-Web-Application\" class=\"headerlink\" title=\"1.Servelt Web Application\"></a>1.Servelt Web Application</h4><ol>\n<li><p>Spring MVC ：</p>\n<ol>\n<li><p>可以通过<code>@Controller</code>后<code>@RestController</code>beans来处理收到的HTTP请求，controller内的方法通过<code>@RequestMapping</code>来映射到HTTP：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;users&quot;)\npublic class MyRestController &#123;\n\n    private final UserRepository userRepository;\n\n    private final CustomerRepository customerRepository;\n\n    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) &#123;\n        this.userRepository &#x3D; userRepository;\n        this.customerRepository &#x3D; customerRepository;\n    &#125;\n\n    @GetMapping(&quot;&#x2F;&#123;userId&#125;&quot;)\n    public User getUser(@PathVariable Long userId) &#123;\n        return this.userRepository.findById(userId).get();\n    &#125;\n\n    @GetMapping(&quot;&#x2F;&#123;userId&#125;&#x2F;customers&quot;)\n    public List&lt;Customer&gt; getUserCustomers(@PathVariable Long userId) &#123;\n        return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();\n    &#125;\n\n    @DeleteMapping(&quot;&#x2F;&#123;userId&#125;&quot;)\n    public void deleteUser(@PathVariable Long userId) &#123;\n        this.userRepository.deleteById(userId);\n    &#125;\n    \n&#125;</code></pre></li>\n<li><p>功能变体WebMvc.fn将路由配置与请求的实际处理分开：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration(proxyBeanMethods &#x3D; false)\npublic class MyRoutingConfiguration &#123;\n\n    private static final RequestPredicate ACCEPT_JSON &#x3D; accept(MediaType.APPLICATION_JSON);\n\n    @Bean\n    public RouterFunction&lt;ServerResponse&gt; routerFunction(MyUserHandler userHandler) &#123;\n        return route()\n            .GET(&quot;&#x2F;&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::getUser)\n            .GET(&quot;&#x2F;&#123;user&#125;&#x2F;customers&quot;, ACCEPT_JSON, userHandler::getUserCustomers)\n            .DELETE(&quot;&#x2F;&#123;user&#125;&quot;, ACCEPT_JSON, userHandler::deleteUser)\n            .build();\n    &#125;\n\n&#125;\n\n@Component\npublic class MyUserHandler &#123;\n\n    public ServerResponse getUser(ServerRequest request) &#123;\n        &#x2F;&#x2F;...\n        return ServerResponse.ok().build();\n    &#125;\n\n    public ServerResponse getUserCustomers(ServerRequest request) &#123;\n        &#x2F;&#x2F; ...\n        return ServerResponse.ok().build();\n    &#125;\n\n    public ServerResponse deleteUser(ServerRequest request) &#123;\n        &#x2F;&#x2F;...\n        return ServerResponse.ok().build();\n    &#125;\n\n&#125;</code></pre></li>\n<li><p>支持Spring MVC自动配置、可以自动将HTTP请求和响应转换为JSON、静态内容在 <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code>)内提取、内置欢迎页（<code>index.html</code>）</p>\n</li>\n<li><p>通过查看请求路径并将其与应用程序中定义的映射匹配，将传入的HTTP请求映射到处理程序。默认不开启后缀匹配但可以使用查询参数来确保像 <code>&quot;GET /projects/spring-boot?format=json&quot;</code> 能被映射到 <code>@GetMapping(&quot;/projects/spring-boot&quot;)</code>（<code>spring.mvc.contentnegotiation.favor-parameter=true</code>）</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Spring-Security\"><a href=\"#2-Spring-Security\" class=\"headerlink\" title=\"2.Spring Security\"></a>2.Spring Security</h4><ol>\n<li>MVC Security、WebFlux Security</li>\n<li>OAuth2<ol>\n<li>Client</li>\n<li>Resource Server</li>\n<li>Authorization Server</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-Spring-Session\"><a href=\"#3-Spring-Session\" class=\"headerlink\" title=\"3.Spring Session\"></a>3.Spring Session</h4><p>可以自动配置：JDBC、Redis、MongoDB</p>\n<h3 id=\"4-Data\"><a href=\"#4-Data\" class=\"headerlink\" title=\"4.Data\"></a>4.Data</h3><h3 id=\"5-其它-1\"><a href=\"#5-其它-1\" class=\"headerlink\" title=\"5.其它\"></a>5.其它</h3><h2 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/sc2020jgt.png\" alt=\"img\"></h2><h3 id=\"1-Spring-Cloud-Alibaba\"><a href=\"#1-Spring-Cloud-Alibaba\" class=\"headerlink\" title=\"1.Spring Cloud Alibaba\"></a>1.Spring Cloud Alibaba</h3><h4 id=\"1-Nacos-Discovery\"><a href=\"#1-Nacos-Discovery\" class=\"headerlink\" title=\"1.Nacos Discovery\"></a>1.Nacos Discovery<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220724145943033.png\" alt=\"image-20220724145943033\"></h4><ol>\n<li><p>简介：可以自动将服务注册到Nacos服务端，并且能够动态地感知和刷新某个服务实例的服务列表。Nacos Discovery适配了Netflix Ribbon，可以使用RestTemplate或OpenFeign进行服务调用</p>\n</li>\n<li><p>使用：</p>\n<ol>\n<li><p>启动Nacos服务器：添加依赖，启动Nacos Server，在<code>http://ip:8848</code>查看控制台</p>\n</li>\n<li><p>将Provider服务注册到Nacos：添加依赖和配置信息，启动应用实例即可</p>\n</li>\n<li><p>通过Nacos使用Consumer服务：可以使用LoadBalanceClient和RestTemplate的方式，也可以使用带负载均衡的RestTemplate和FeignClient</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\n@EnableDiscoveryClient\npublic class NacosConsumerApp &#123;\n    @RestController\n    public class NacosController&#123;\n        @Autowired\n        private LoadBalancerClient loadBalancerClient;\n        @Autowired\n        private RestTemplate restTemplate;\n        @Value(&quot;$&#123;spring.application.name&#125;&quot;)\n        private String appName;\n\n        @GetMapping(&quot;&#x2F;echo&#x2F;app-name&quot;)\n        public String echoAppName()&#123;\n            &#x2F;&#x2F;使用 LoadBalanceClient 和 RestTemplate 结合的方式来访问\n            ServiceInstance serviceInstance &#x3D; loadBalancerClient.choose(&quot;nacos-provider&quot;);\n            String url &#x3D; String.format(&quot;http:&#x2F;&#x2F;%s:%s&#x2F;echo&#x2F;%s&quot;,\n                                       serviceInstance.getHost(),serviceInstance.getPort(),appName);\n            System.out.println(&quot;request url:&quot;+url);\n            return restTemplate.getForObject(url,String.class);\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;实例化 RestTemplate 实例\n    @Bean\n    public RestTemplate restTemplate()&#123;\n        return new RestTemplate();\n    &#125;\n    public static void main(String[] args) &#123;\n        SpringApplication.run(NacosConsumerApp.class,args);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>其它</p>\n<ol>\n<li>Nacos Discovery对外暴露的Endpoint id为<code>nacos-discovery</code>，其中包含两种属性<ul>\n<li>subscribe: 显示了当前服务有哪些服务订阅者</li>\n<li>NacosDiscoveryProperties: 当前应用 Nacos 的基础配置信息</li>\n</ul>\n</li>\n<li>配置信息：见文档</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Nacos-Config\"><a href=\"#2-Nacos-Config\" class=\"headerlink\" title=\"2.Nacos Config\"></a>2.Nacos Config</h4><ol>\n<li><p>使用</p>\n<ol>\n<li><p>Nacos Config使用DataId和Group确定一个配置，并且可以选择配置格式<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220726090433473.png\" alt=\"image-20220726090433473\"></p>\n</li>\n<li><p>服务端初始化：同Nacos Discovery，启动后，添加配置<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220726091137931.png\" alt=\"image-20220726091137931\"></p>\n</li>\n<li><p>客户端使用方式：</p>\n<ul>\n<li><p>创建标准的Spring Boot应用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\npublic class NacosConfigApplication &#123;\n\n    public static void main(String[] args) &#123;\n        ConfigurableApplicationContext applicationContext &#x3D; SpringApplication.run(ConfigApplication.class, args);\n        String userName &#x3D; applicationContext.getEnvironment().getProperty(&quot;user.name&quot;);\n        String userAge &#x3D; applicationContext.getEnvironment().getProperty(&quot;user.age&quot;);\n        System.err.println(&quot;user name :&quot;+userName+&quot;; age: &quot;+userAge);\n    &#125;\n&#125;</code></pre></li>\n<li><p>添加bootstrap.properties配置文件来配置Nacos Server地址</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\"># DataId 默认使用 &#96;spring.application.name&#96; 配置跟文件扩展名结合(配置格式默认使用 \n#properties), GROUP 不配置默认使用 DEFAULT_GROUP。因此该配置文件对应的 Nacos \n#Config 配置的 DataId 为 nacos-config.properties, GROUP 为 DEFAULT_GROUP\nspring.application.name&#x3D;nacos-config\nspring.cloud.nacos.config.server-addr&#x3D;127.0.0.1:8848</code></pre></li>\n<li><p>启动后将输出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">2018-11-02 14:24:51.638  INFO 32700 --- [main] c.a.demo.provider.ConfigApplication    : Started ConfigApplication in 14.645 seconds (JVM running for 15.139)\nuser name :nacos-config-properties; age: 90\n2018-11-02 14:24:51.688  INFO 32700 --- [-127.0.0.1:8848] s.c.a.AnnotationConfigApplicationContext : Refreshing dorg.springframework.context.annotation.AnnotationConfigApplicationContext@a8c5e74: startup date [Fri Nov 02 14:24:51 CST 2018]; root of context hierarchy</code></pre></li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>特性</p>\n<ol>\n<li>基于DataId为yaml的文件扩展名配置方式</li>\n<li>支持配置的动态更新</li>\n<li>支持profile粒度的配置</li>\n</ol>\n</li>\n<li><p>其它</p>\n<ol>\n<li>Nacos Config对外暴露的Endpoint</li>\n<li>配置信息</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-Sentinel\"><a href=\"#3-Sentinel\" class=\"headerlink\" title=\"3.Sentinel\"></a>3.Sentinel</h4><ol>\n<li><p>简介：Sentinel以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。具有完备的实时监控、广泛的开原生态、完善的SPI扩展点</p>\n</li>\n<li><p>使用：添加依赖、添加<code>@SentinelResource</code>注解来标识资源是否被限流、降级，通过配置控制台，可以获得机器发现、单机资源实时监控、集群资源汇总，以及规则管理的功能</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\npublic class Application &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(ServiceApplication.class, args);\n    &#125;\n&#125;\n\n@RestController\npublic class TestController &#123;\n\n    @GetMapping(value &#x3D; &quot;&#x2F;hello&quot;)\n    @SentinelResource(&quot;hello&quot;)&#x2F;&#x2F;hello表示资源名\n    public String hello() &#123;\n        return &quot;Hello Sentinel&quot;;\n    &#125;\n&#125;·</code></pre></li>\n<li><p>其它</p>\n<ol>\n<li><p>一些支持</p>\n<ol>\n<li>OpenFeign支持</li>\n<li>RestTemplate支持</li>\n<li>SpirngCloudGateway支持</li>\n</ol>\n</li>\n<li><p>暴漏的Endpoint</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-Spring-Cloud-Commons\"><a href=\"#2-Spring-Cloud-Commons\" class=\"headerlink\" title=\"2.Spring Cloud Commons\"></a>2.Spring Cloud Commons</h3><h4 id=\"1-Application-Context-Services\"><a href=\"#1-Application-Context-Services\" class=\"headerlink\" title=\"1.Application Context Services\"></a>1.Application Context Services</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>为应用程序的<code>ApplicationContext</code>提供实用程序和特殊服务（<code>bootstrap context</code>、<code>encryption</code>、<code>refresh scope</code>、<code>environment endpoints</code>）</p></blockquote>\n<ol>\n<li><p>Bootstrap Application Context</p>\n<ol>\n<li><p>是主application的父类，负责从外部源载入属性并且解码本地的外部属性文件的属性，可以与主上下文分离</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  application:\n    name: foo\n  cloud:\n    config:\n      uri: $&#123;SPRING_CONFIG_URI:http:&#x2F;&#x2F;localhost:8888&#125;</code></pre></li>\n<li><p>启动阶段引导加载的属性，常用配置即<code>spring.application.name=服务名</code>及其它配置中心相关</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-Common-Abstractions\"><a href=\"#2-Common-Abstractions\" class=\"headerlink\" title=\"2.Common Abstractions\"></a>2.Common Abstractions</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>是一组抽象的通用类，用于不同的SpringCloud实现，例如Spring Cloud Netflix和Spring Cloud Consul）</p></blockquote>\n<ol>\n<li><p><code>@EnableDiscoveryClient</code>：用于在<code>META-INF/spring.factories</code>中搜索<code>DiscoveryClient</code>接口和<code>ReactiveDiscoveryClient</code>的实现。发现客户端的实现向<code>spring.factories</code>中加了一个配置类，主要实现有Eureka、Consul、Zookeeper、Nacos。Spring Cloud默认提供了阻塞的和响应式的服务发现客户端，可以通过配置关闭<code>spring.cloud.discovery.enabled=false</code>。有<code>DiscoveryClient</code>的实现在classpath，就可以不加此注解。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface DiscoveryClient extends Ordered &#123;\n\tint DEFAULT_ORDER &#x3D; 0;\n\tString description();\n\tList&lt;ServiceInstance&gt; getInstances(String serviceId);\n\tList&lt;String&gt; getServices();\n\t@Override\n\tdefault int getOrder() &#123;\n\t\treturn DEFAULT_ORDER;\n\t&#125;\n&#125;</code></pre>\n\n<ol>\n<li><p>如何获得服务地址：配置类中注入<code>DiscoveryClient</code>，通过它的<code>getInstances()</code>来得到服务相关信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\n@Slf4j\npublic class CustomerRunner implements ApplicationRunner &#123;\n    @Autowired\n    private DiscoveryClient discoveryClient;\n    \n    private void showServiceInstances() &#123;\n        log.info(&quot;DiscoveryClient: &#123;&#125;&quot;, discoveryClient.getClass().getName());\n        discoveryClient.getInstances(&quot;waiter-service&quot;).forEach(s -&gt; &#123;\n            log.info(&quot;Host: &#123;&#125;, Port: &#123;&#125;&quot;, s.getHost(), s.getPort());\n        &#125;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>定制DiscoveryClient</p>\n</li>\n</ol>\n</li>\n<li><p><code>ServiceRegistry</code>：通过<code>ServiceRegistry</code>接口可以定制服务，<code>Registration</code>是一个标记接口。不同的<code>ServiceRegistry</code>实现有不同的<code>Registry</code>实现。默认<code>ServiceRegistry</code>实现自动注册运行的服务，并且提前触发<code>InstancePreRegisteredEvent</code>和<code>InstanceRegisteredEvent</code>两个事件。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ServiceRegistry&lt;R extends Registration&gt; &#123;   \n\tvoid register(R registration);\n\tvoid deregister(R registration);\n\tvoid close();\n\tvoid setStatus(R registration, String status);\n\t&lt;T&gt; T getStatus(R registration);\n&#125;\n&#x2F;&#x2F;使用示例\n@Configuration\n@EnableDiscoveryClient(autoRegister&#x3D;false)\npublic class MyConfiguration &#123;\n    private ServiceRegistry registry;\n\n    public MyConfiguration(ServiceRegistry registry) &#123;\n        this.registry &#x3D; registry;\n    &#125;\n    &#x2F;&#x2F; called through some external process, such as an event or a custom actuator endpoint\n    public void register() &#123;\n        Registration registration &#x3D; constructRegistration();\n        this.registry.register(registration);\n    &#125;\n&#125;</code></pre></li>\n<li><p><code>LoadBalancerClient</code>：使用<code>@LoadBalaced</code>注解，实现<code>ClientHttpRequestInterceptor</code>接口的<code>LoadBalancerInterceptor</code>类，其中的<code>LoadBalancerClient</code>接口的<code>execute</code>方法，具体实现有<code>RibbonLoadBalancerClient</code></p>\n<ol>\n<li><p>RestTemplate：classpath上需要有一个load-balancer实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MyConfiguration &#123;\n    @LoadBalanced\n    @Bean\n    RestTemplate restTemplate() &#123;\n        return new RestTemplate();\t&#x2F;&#x2F;RestTemplate Bean需要自己注册\n    &#125;\n&#125;\n\npublic class MyClass &#123;\n    @Autowired\n    private RestTemplate restTemplate;\n\n    public String doOtherStuff() &#123;\n        String results &#x3D; restTemplate.getForObject(&quot;http:&#x2F;&#x2F;stores&#x2F;stores&quot;, String.class);\n        return results;\n    &#125;\n&#125;</code></pre></li>\n<li><p>WebClient</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MyConfiguration &#123;\n\n    @Bean\n    @LoadBalanced\n    public WebClient.Builder loadBalancedWebClientBuilder() &#123;\n        return WebClient.builder();\n    &#125;\n&#125;\n\npublic class MyClass &#123;\n    @Autowired\n    private WebClient.Builder webClientBuilder;\n\n    public Mono&lt;String&gt; doOtherStuff() &#123;\n        return webClientBuilder.build().get().uri(&quot;http:&#x2F;&#x2F;stores&#x2F;stores&quot;)\n                        .retrieve().bodyToMono(String.class);\n    &#125;\n&#125;</code></pre></li>\n<li><p>WebFlux</p>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"3-Circuit-Breaker\"><a href=\"#3-Circuit-Breaker\" class=\"headerlink\" title=\"3.Circuit Breaker\"></a>3.Circuit Breaker</h4><h3 id=\"3-Spring-Cloud-Config\"><a href=\"#3-Spring-Cloud-Config\" class=\"headerlink\" title=\"3.Spring Cloud Config\"></a>3.Spring Cloud Config</h3><ol>\n<li><p>概述：SpringCloudConfig提供了服务侧和客户侧在分布式系统中外化配置的支持，通过配置服务器（默认是git），能有一个中心化的地方来为不同环境的应用管理外部属性。当应用程序通过部署管道从开发到测试再进入生产时，可以管理这些环境之间的配置，并确保应用程序在迁移时具备运行所需的一切。</p>\n</li>\n<li><p>Spring Cloud Config Server：提供了一个基于HTTP资源的API，使用<code>@EnableConfigServer</code></p>\n<ol>\n<li><p>Environment Repository</p>\n<ol>\n<li><p>为配置服务器存储配置数据，并为Environment对象提供服务，这个Environment是Spring域内的Environment的浅拷贝，有三个变量<code>&#123;application&#125;</code>、<code>&#123;profile&#125;</code>、<code>&#123;label&#125;</code></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  application:\n    name: foo\n  profiles:\n    active: dev,mysql</code></pre></li>\n<li><p>Git Backend：<code>EnvironmentRepository</code>的默认实现是Git客户端，要更改存储库的位置，可以在<code>applicatioin.yml</code>中设置<code>spring.cloud.config.server.git.uri</code>。为了要扩展配置服务器，并使其具有高可用性，需要让所有服务器的所有实例都执行同一个存储库，因此只有共享文件系统才能工作。相关配置见文档</p>\n</li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>其它</p>\n<ol>\n<li>健康检查：用来检查更多应用程序以及自定义配置文件和自定义标签</li>\n<li>Security：可以以任何对你有意义的方式保护你的配置服务器，SpringScurity、配置用户名和密码</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"4-Spring-Cloud-OpenFeign\"><a href=\"#4-Spring-Cloud-OpenFeign\" class=\"headerlink\" title=\"4.Spring Cloud OpenFeign\"></a>4.Spring Cloud OpenFeign</h3><ol>\n<li><p>概念</p>\n<ol>\n<li><p>Feign：声明式web服务客户端，让写web服务客户端变得更简单</p>\n</li>\n<li></li>\n</ol>\n</li>\n<li><p>使用</p>\n<ol>\n<li><p>加注解</p>\n<ul>\n<li>@EnableFeignClient</li>\n<li>@FeignClient</li>\n</ul>\n</li>\n<li><p>定义接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FeignClient(name &#x3D; &quot;waiter-service&quot;, contextId &#x3D; &quot;coffeeOrder&quot;)\npublic interface CoffeeOrderService &#123;\n    @GetMapping(&quot;&#x2F;order&#x2F;&#123;id&#125;&quot;)\n    CoffeeOrder getOrder(@PathVariable(&quot;id&quot;) Long id);\n\n    @PostMapping(path &#x3D; &quot;&#x2F;order&#x2F;&quot;, consumes &#x3D; MediaType.APPLICATION_JSON_VALUE,\n            produces &#x3D; MediaType.APPLICATION_JSON_UTF8_VALUE)\n    CoffeeOrder create(@RequestBody NewOrderRequest newOrder);\n&#125;</code></pre></li>\n<li><p>简单配置</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">feign.client.config.default.connect-timeout&#x3D;500\nfeign.client.config.default.read-timeout&#x3D;500</code></pre></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"5-Spring-Cloud-Sleuth\"><a href=\"#5-Spring-Cloud-Sleuth\" class=\"headerlink\" title=\"5.Spring Cloud Sleuth\"></a>5.Spring Cloud Sleuth</h3><ol>\n<li><p>简介：用于分布式链路追踪，它能追踪请求和消息从而可以将消息与相应的日志条目相关联，支持导出到OpenZipkin来可视化链路，追踪过程一个Trace的所有Span如下</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220726104811085.png\" alt=\"image-20220726104811085\"></p>\n</li>\n<li><p>zipkin和sleuth</p>\n</li>\n<li><p>使用</p>\n<ol>\n<li><p>span的声明周期</p>\n<ol>\n<li><p>start，开始一个span时，会记录它被分配的名称和开始时间戳；end，span完成，如果span被采样，则会被收集到Zipkin</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Start a span. If there was a span present in this thread it will become\n&#x2F;&#x2F; the &#96;newSpan&#96;&#39;s parent.\nSpan newSpan &#x3D; this.tracer.nextSpan().name(&quot;calculateTax&quot;);\ntry (Tracer.SpanInScope ws &#x3D; this.tracer.withSpan(newSpan.start())) &#123;\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can tag a span\n    newSpan.tag(&quot;taxValue&quot;, taxValue);\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can log an event on a span\n    newSpan.event(&quot;taxCalculated&quot;);\n&#125;\nfinally &#123;\n    &#x2F;&#x2F; Once done remember to end the span. This will allow collecting\n    &#x2F;&#x2F; the span to send it to a distributed tracing system e.g. Zipkin\n    newSpan.end();\n&#125;</code></pre></li>\n<li><p>continue：span继续，例如在另一个线程里</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Span spanFromThreadX &#x3D; this.tracer.nextSpan().name(&quot;calculateTax&quot;);\ntry (Tracer.SpanInScope ws &#x3D; this.tracer.withSpan(spanFromThreadX.start())) &#123;\n    executorService.submit(() -&gt; &#123;\n        &#x2F;&#x2F; Pass the span from thread X\n        Span continuedSpan &#x3D; spanFromThreadX;\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; You can tag a span\n        continuedSpan.tag(&quot;taxValue&quot;, taxValue);\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; You can log an event on a span\n        continuedSpan.event(&quot;taxCalculated&quot;);\n    &#125;).get();\n&#125;\nfinally &#123;\n    spanFromThreadX.end();\n&#125;</code></pre></li>\n<li><p>create with explicit parent：可以创建一个新span，并为其设置显示显示父级</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; let&#39;s assume that we&#39;re in a thread Y and we&#39;ve received\n&#x2F;&#x2F; the &#96;initialSpan&#96; from thread X. &#96;initialSpan&#96; will be the parent\n&#x2F;&#x2F; of the &#96;newSpan&#96;\nSpan newSpan &#x3D; null;\ntry (Tracer.SpanInScope ws &#x3D; this.tracer.withSpan(initialSpan)) &#123;\n    newSpan &#x3D; this.tracer.nextSpan().name(&quot;calculateCommission&quot;);\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can tag a span\n    newSpan.tag(&quot;commissionValue&quot;, commissionValue);\n    &#x2F;&#x2F; ...\n    &#x2F;&#x2F; You can log an event on a span\n    newSpan.event(&quot;commissionCalculated&quot;);\n&#125;\nfinally &#123;\n    &#x2F;&#x2F; Once done remember to end the span. This will allow collecting\n    &#x2F;&#x2F; the span to send it to e.g. Zipkin. The tags and events set on the\n    &#x2F;&#x2F; newSpan will not be present on the parent\n    if (newSpan !&#x3D; null) &#123;\n        newSpan.end();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>通过注解管理Spans</p>\n<ol>\n<li><p>创建新的span：@NewSpan</p>\n</li>\n<li><p>Continuing Spans：@ContinueSpan</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; method declaration\n@ContinueSpan(log &#x3D; &quot;testMethod11&quot;)\nvoid testMethod11(@SpanTag(&quot;testTag11&quot;) String param);\n&#x2F;&#x2F; method execution\nthis.testBean.testMethod11(&quot;test&quot;);\nthis.testBean.testMethod13();</code></pre></li>\n<li><p>Tag设置</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>其它</p>\n</li>\n</ol>\n<h3 id=\"6-Spring-Cloud-Stream\"><a href=\"#6-Spring-Cloud-Stream\" class=\"headerlink\" title=\"6.Spring Cloud Stream\"></a>6.Spring Cloud Stream</h3><h4 id=\"1-概览-1\"><a href=\"#1-概览-1\" class=\"headerlink\" title=\"1.概览\"></a>1.概览</h4><ol>\n<li><p>概念：用来构建消息驱动的微服务应用。</p>\n<ol>\n<li><p>application模型：应用通过和外部代理暴漏的destinations和输入输出参数来建立绑定从而与外部世界通信。绑定所需要的代理细节由特定于中间件的Binder处理</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220725115632972.png\" alt=\"image-20220725115632972\"></p>\n</li>\n<li><p>Binder抽象：通过SpringBoot配置，Binder使得应用和中间件之间的连接方式更灵活。相同的代码可以配置不同的中间件</p>\n</li>\n<li><p>pub-sub：应用间的通信模型，可以减少生产者和消费者之间通信的复杂性，不用打破现有的流就可以增加新的，降低了微服务之间的耦合程度。如下图，HTTP发布的的数据被Averages和Ingest HDFS两个微服务所订阅</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220725134737910.png\" alt=\"image-20220725134737910\"></p>\n</li>\n<li><p>消费组：为给定应用扩展多个实例也很重要，一个应用的不同实例会处在一个竞争的消费者关系中，其中只有一个实例需要处理给定的消息，通过消费组的概念来实现这个模型。订阅给定目标的所有组都会收到一份数据副本，但每个组内只会有一个成员收到此副本。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220725140722379.png\" alt=\"image-20220725140722379\"></p>\n</li>\n<li><p>分区支持：支持在给定应用程序的多个实例之间划分数据，多个生产者实例向多个消费者实例发送数据，并确保由共同特征标识的数据由同一消费者实例处理。<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220725141449689.png\" alt=\"image-20220725141449689\"></p>\n</li>\n</ol>\n</li>\n<li><p>编程模型<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220725143331869.png\" alt=\"image-20220725143331869\"></p>\n<ol>\n<li><p>Destination Binders：是提供与外部消息传递系统集成的组件，负责连接、委托（delegation）和路由与生产者消费者之间的消息、数据类型转换、调用用户代码等。</p>\n</li>\n<li><p>Bindings：外部消息传递系统和应用程序提供消息的生产者和消费者之间的桥梁，Bindings的名字有几种转换生成方式（见文档）</p>\n</li>\n<li><p>生产&amp;消费信息：</p>\n<ol>\n<li><p>概览</p>\n<ul>\n<li><p>将消息处理程序声明为Java.util.function.Function的应用程序实例，输入输出必须绑定到由提供的目标提供的destination binder暴露的公开的外部destinations</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\npublic class MyFunctionBootApp &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(MyFunctionBootApp.class);\n\t&#125;\n    &#x2F;&#x2F;默认绑定到 toUpperCase-in-0 和 toUpperCase-out-0\n\t@Bean\n\tpublic Function&lt;String, String&gt; toUpperCase() &#123;\n\t\treturn s -&gt; s.toUpperCase();\n\t&#125;\n&#125;</code></pre></li>\n<li><p>将消息处理程序声明为Java.util.function.Supplier的应用程序实例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\npublic static class SourceFromSupplier &#123;\n\t@Bean\n\tpublic Supplier&lt;Date&gt; date() &#123;\n\t\treturn () -&gt; new Date(12345L);\n\t&#125;\n&#125;</code></pre></li>\n<li><p>将消息处理程序声明为Java.util.function.Consumer的应用程序实例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\npublic static class SinkFromConsumer &#123;\n\t@Bean\n\tpublic Consumer&lt;String&gt; sink() &#123;\n\t\treturn System.out::println;\n\t&#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>Suppliers(Sources)</p>\n<ol>\n<li>不同于Functions和Consumer由事件触发，Suppliers不订阅任何in-bound目的地，所以需要其它机制触发。框架有一个默认的拉取机制，默认情况会每秒执行一次，向output目的地发送一个消息</li>\n<li>可以选择每秒触发一次、总共只触发一次、触发有限次（通过Flux）</li>\n</ol>\n</li>\n<li><p>向output发送数据</p>\n<ol>\n<li><p>标准的MVC：StreamBridge将非流应用程序和SpringCloudStream桥接</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication\n@Controller\npublic class WebSourceApplication &#123;\n\n\tpublic static void main(String[] args) &#123;\n\t\tSpringApplication.run(WebSourceApplication.class, &quot;--spring.cloud.stream.source&#x3D;toStream&quot;);\n\t&#125;\n\n\t@Autowired\n\tprivate StreamBridge streamBridge;\n\n\t@RequestMapping\n\t@ResponseStatus(HttpStatus.ACCEPTED)\n\tpublic void delegateToSupplier(@RequestBody String body) &#123;\n\t\tSystem.out.println(&quot;Sending &quot; + body);\n        &#x2F;&#x2F;第一次调用时家那个启动output bindings的创建\n\t\tstreamBridge.send(&quot;toStream-out-0&quot;, body);\n\t&#125;\n&#125;</code></pre></li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>Binders</p>\n<ol>\n<li><p>producer&amp;consumer：producer是向绑定目的地发送消息的任何组件；consumer是从绑定目的地接收消息的任何组件<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220725191034404.png\" alt=\"image-20220725191034404\"></p>\n</li>\n<li><p>Binder SPI</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Binder&lt;T, C extends ConsumerProperties, P extends ProducerProperties&gt; &#123;\n    Binding&lt;T&gt; bindConsumer(String bindingName, String group, T inboundBindTarget, C consumerProperties);\n    Binding&lt;T&gt; bindProducer(String bindingName, T outboundBindTarget, P producerProperties);\n&#125;</code></pre></li>\n<li><p>Binder Detection：</p>\n<ol>\n<li>SpringCloudStream依靠于Binder SPI的实现来执行将用户代码连接（绑定）到消息代理的任务。每个Binder实现通常连接同一种类型的消息传递系统</li>\n<li>Classpath Detection：默认依靠SpringBoot的自动配置来配置binding进程，如果classpath上发现了一个单一的Binder实现，SpringCloudStream就会自动的使用它</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h4 id=\"2-RabbitMQ\"><a href=\"#2-RabbitMQ\" class=\"headerlink\" title=\"2.RabbitMQ\"></a>2.RabbitMQ</h4><ol>\n<li>RabbitMQ Binder Overview<img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20220725192345258.png\" alt=\"image-20220725192345258\"><ol>\n<li>默认RabbitMQ Binder将每一个destination映射到一个TopicExchange，对于每个消费组，一个队列绑定到该TopicExchange，每个消费者实例有一个对应于组队列的RabbitMQ Consumer接口。对于分区了的producers和consumers，队列是分区索引的后缀，并且用这个分区索引作为路由key。对于匿名consumers有一个自动删除队列。</li>\n</ol>\n</li>\n<li>配置选项</li>\n<li></li>\n</ol>\n<h4 id=\"3-Kafka\"><a href=\"#3-Kafka\" class=\"headerlink\" title=\"3.Kafka\"></a>3.Kafka</h4><h2 id=\"Spring-Security\"><a href=\"#Spring-Security\" class=\"headerlink\" title=\"Spring Security\"></a>Spring Security</h2><h2 id=\"Test\"><a href=\"#Test\" class=\"headerlink\" title=\"Test\"></a>Test</h2><ol>\n<li>工具：Postman（后端测试）&amp;Swagger（接口文档）</li>\n<li>Spring Boot Testing<ol>\n<li>使用<code>spring-boot-starter-test</code>来测试，它包括了JUnit Jupiter、AssertJ、Hamcrest等库</li>\n<li>测试Spring应用：可以通过不依赖Spring直接用new来实例化对象或者用mock对象而不是真正的依赖项。Spring提供集成测试模块，能够直接向<code>org.springframework:spring-test</code>声明一个依赖，或者使用<code>spring-boot-starter-test</code>来传递它，详见Spring</li>\n<li>测试SpringBoot应用：<ol>\n<li>SpringBoot提供了<code>@SpringBootTest</code>注解，当需要SpringBoot的特性时，他是<code>Spring-test</code>的<code>@ContextConfiguration</code>注解的替代品，这个注解会通过<code>SpringApplication</code>创建测试中使用的应用上下文来工作，默认是不开启服务器的，但可以通过<code>webEnvironment</code>来重定义：<ul>\n<li>MOCK（默认）：加载一个Web ApplicationContext来提供一个模拟Web环境，不启动嵌入式服务器，但如果类路径上没有可用的Web环境，则此模式会回退到非Web ApplicationContext，</li>\n<li>RANDOM_PORT：加载一个<code>WebServerApplicationContext</code>并提供一个真实的Web环境。嵌入式服务器启动并侦听随机端口。</li>\n<li>DEFINED_PORT：加载一个<code>WebServerApplicationContext</code>并提供一个真实的Web环境，嵌入式服务器侦听定义的端口或默认的端口（8080）</li>\n<li>NONE：使用<code>SpringApplication</code>加载<code>ApplicationContext</code>但不提供任何Web环境</li>\n</ul>\n</li>\n<li><code>@Transactional</code>的测试，这个事务会在测试方法结束后默认回滚</li>\n<li>检测测试配置：<code>@Test</code>会自动搜索主要配置，<code>@TestConfiguration</code>类可以覆盖配置并通过<code>@Import</code>导入配置</li>\n<li>使用模拟（mock）环境测试：<code>@AutoConfigureMockMvc</code></li>\n<li>模拟和窥探Beans：<code>@MockBean</code>用于定义一个应用上下文中的一个bean的Mockito模拟</li>\n<li>Auto-configured Tests：用来自动载入测试需要的程序片段，可以选择一个@…Test注释并手动包含其它片段的@AutoConfigure…注释</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>Actuator<br>1. </li>\n</ol>\n<h2 id=\"SOA\"><a href=\"#SOA\" class=\"headerlink\" title=\"SOA\"></a>SOA</h2><h3 id=\"1-Containers-Docker\"><a href=\"#1-Containers-Docker\" class=\"headerlink\" title=\"1.Containers(Docker)\"></a>1.Containers(Docker)</h3><h3 id=\"2-Configuration-Management-Ansible\"><a href=\"#2-Configuration-Management-Ansible\" class=\"headerlink\" title=\"2.Configuration Management(Ansible)\"></a>2.Configuration Management(Ansible)</h3><h3 id=\"3-Container-Orchestration-Kubernetes\"><a href=\"#3-Container-Orchestration-Kubernetes\" class=\"headerlink\" title=\"3.Container Orchestration(Kubernetes)\"></a>3.Container Orchestration(Kubernetes)</h3><h3 id=\"4-Infrastructure-Provisioning-Terraform\"><a href=\"#4-Infrastructure-Provisioning-Terraform\" class=\"headerlink\" title=\"4.Infrastructure Provisioning(Terraform)\"></a>4.Infrastructure Provisioning(Terraform)</h3><h3 id=\"5-Service-Mesh-Istio-Consul-的\"><a href=\"#5-Service-Mesh-Istio-Consul-的\" class=\"headerlink\" title=\"5.Service Mesh(Istio/Consul)的\"></a>5.Service Mesh(Istio/Consul)的</h3><h2 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo\"></a>Demo</h2><h3 id=\"1-架构及相关技术\"><a href=\"#1-架构及相关技术\" class=\"headerlink\" title=\"1.架构及相关技术\"></a>1.架构及相关技术</h3><ol>\n<li><p>简介：使用前后端分离架构，后端基于SpringBoot框架，商城系统包括：商品展示、商品搜索、商品推荐、订单流程、用户中心模块；管理系统包括商品管理、订单管理、财务管理模块。</p>\n</li>\n<li><p>主要技术：框架方面使用SpringBoot做为应用的整体框架、SpringSecurity做为认证和授权框架、MyBatis做为ORM框架；数据存储方面使用MySQL和MongoDB分别做为SQL和NoSQL存储、使用Redis作为缓存、使用ElasticSearch做为搜索引擎、使用RabbitMQ做为消息队列、使用Druid做为数据数据库连接池；访问入口使用Nginx做为静态资源服务器、使用LogStash和Kibana进行日志的收集和查看、使用Maven和Docker打包应用。（cms_*：内容管理模块相关表、oms_*：订单管理模块相关表、pms_*：商品模块相关表）</p>\n</li>\n<li><p>架构图概览</p>\n</li>\n</ol>\n","feature":true,"text":"Basic Syntax Android、Chromium（OS用C++）、Spring /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home /Library/Java/JavaVirtualMachines/jd...","link":"","photos":[],"count_time":{"symbolsCount":"777k","symbolsTime":"11:46"},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Basic-Syntax\"><span class=\"toc-text\">Basic Syntax</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%BA%BF%E5%9B%BE\"><span class=\"toc-text\">路线图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">1.程序的本质</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">1.编程语言类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-OS%E3%80%81JVM\"><span class=\"toc-text\">2.OS、JVM</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-CPU%E6%8C%87%E4%BB%A4%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81\"><span class=\"toc-text\">3.CPU指令、汇编语言、字节码</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">4.代码的执行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">5.基础结构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">2.基本类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">1.类型转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-float\"><span class=\"toc-text\">2.float</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-char\"><span class=\"toc-text\">3.char</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%8C%85%E8%A3%85%E7%B1%BB\"><span class=\"toc-text\">4.包装类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E4%BD%8D%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">5.位运算</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-String\"><span class=\"toc-text\">6.String</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-String%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.String的实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-String%E7%9A%84%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">2.String的压缩技术</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-String%E7%9A%84%E5%B8%B8%E9%87%8F%E6%B1%A0%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">3.String的常量池技术</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7\"><span class=\"toc-text\">4.String的不可变性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-StringBuilder\"><span class=\"toc-text\">5.StringBuilder</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">3.引用类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Java%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-VS-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">1.Java类型：基本类型 VS 引用类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%EF%BC%9A%E5%80%BC%E4%BC%A0%E9%80%92-VS-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">2.参数传递：值传递 VS 引用传递</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E6%8D%AE%E5%88%A4%E7%AD%89%EF%BC%9A%E7%AD%89%E5%8F%B7-VS-equals-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">3.数据判等：等号 VS equals()方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%AE%BF%E9%97%AE%E5%AE%89%E5%85%A8%EF%BC%9A%E5%BC%95%E7%94%A8-VS-%E6%8C%87%E9%92%88\"><span class=\"toc-text\">4.访问安全：引用 VS 指针</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">4.关键字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%85%B3%E9%94%AE%E5%AD%97%E6%A6%82%E8%A7%88\"><span class=\"toc-text\">1.关键字概览</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%AF%AD%E6%B3%95%E7%B3%96\"><span class=\"toc-text\">2.语法糖</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-final\"><span class=\"toc-text\">3.final</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-static\"><span class=\"toc-text\">4.static</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">5.类和对象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AF%B9%E8%B1%A1%E5%A4%B4\"><span class=\"toc-text\">1.对象头</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AE%9E%E4%BE%8B%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">2.实例数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AF%B9%E9%BD%90%E5%A1%AB%E5%85%85\"><span class=\"toc-text\">3.对齐填充</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%8E%8B%E7%BC%A9%E7%B1%BB%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">4.压缩类指针和引用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">6.容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-JCF\"><span class=\"toc-text\">1.JCF</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-List\"><span class=\"toc-text\">2.List</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Queue\"><span class=\"toc-text\">4.Queue</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Set\"><span class=\"toc-text\">5.Set</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-Map\"><span class=\"toc-text\">6.Map</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-1-HashMap\"><span class=\"toc-text\">6-1.HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.基本原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2.哈希函数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E8%A3%85%E8%BD%BD%E5%9B%A0%E5%AD%90\"><span class=\"toc-text\">3.装载因子</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">4.动态扩容</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E9%93%BE%E8%A1%A8%E6%A0%91%E5%8C%96\"><span class=\"toc-text\">5.链表树化</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-2-LinkedHashMap\"><span class=\"toc-text\">6-2.LinkedHashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.整体结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-entrySet\"><span class=\"toc-text\">2.entrySet()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E4%BF%AE%E6%94%B9%E3%80%81%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">3.插入、删除、修改、查找</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%BA%94%E7%94%A8%EF%BC%9ALRU%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">4.应用：LRU缓存</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-Collections\"><span class=\"toc-text\">7.Collections</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-sort\"><span class=\"toc-text\">1.sort()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-binarySearch\"><span class=\"toc-text\">2.binarySearch()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-emptyXXX\"><span class=\"toc-text\">3.emptyXXX()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-synchronizedXXX\"><span class=\"toc-text\">4.synchronizedXXX()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-unmodifiable\"><span class=\"toc-text\">5.unmodifiable()</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-Iterator\"><span class=\"toc-text\">8.Iterator</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.容器的遍历方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2.实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">3.问题及解决思路</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%AE%89%E5%85%A8%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">4.安全删除元素</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">7.异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%BC%82%E5%B8%B8%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.异常使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">2.异常体系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">3.自定义异常</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">4.异常处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%BC%82%E5%B8%B8%E8%B0%83%E7%94%A8%E9%93%BE\"><span class=\"toc-text\">5.异常调用链</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%BC%82%E5%B8%B8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">6.异常实现原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E5%BC%82%E5%B8%B8%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\"><span class=\"toc-text\">7.异常性能分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E5%BC%82%E5%B8%B8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">8.异常最佳实践</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-IO\"><span class=\"toc-text\">8.IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-io%E7%B1%BB%E5%BA%93\"><span class=\"toc-text\">1.io类库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-io%E7%B1%BB%E5%BA%93%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.io类库整体结构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81\"><span class=\"toc-text\">2.输入流和输出流</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81\"><span class=\"toc-text\">3.字节流和字符流</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%8E%9F%E5%A7%8B%E5%BA%93%E5%92%8C%E8%A3%85%E9%A5%B0%E7%B1%BB%E5%BA%93\"><span class=\"toc-text\">4.原始库和装饰类库</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%88%86%E7%B1%BB%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">5.原始类分类介绍</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%B1%BB%E5%88%86%E7%B1%BB%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">6.装饰器类分类介绍</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-nio%E7%B1%BB%E5%BA%93\"><span class=\"toc-text\">2.nio类库</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-java-nio%E7%B1%BB%E5%BA%93\"><span class=\"toc-text\">1.java.nio类库</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-Java-IO%E6%A8%A1%E5%9E%8B%EF%BC%88%E7%BD%91%E7%BB%9C%EF%BC%89\"><span class=\"toc-text\">2.Java IO模型（网络）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%AF%B9%E6%AF%94java-io%E4%B8%8Ejava-nio\"><span class=\"toc-text\">3.对比java.io与java.nio</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%96%87%E4%BB%B6%EF%BC%88%E9%AB%98%E9%80%9FI-O%EF%BC%89\"><span class=\"toc-text\">3.文件（高速I&#x2F;O）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81\"><span class=\"toc-text\">1.用户态和内核态</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-I-O%E8%AF%BB%E5%86%99%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2.I&#x2F;O读写的底层实现原理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-CPU%E5%87%8F%E8%B4%9F%E7%A5%9E%E5%99%A8%E4%B9%8BDMA%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">3.CPU减负神器之DMA技术</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-mmap\"><span class=\"toc-text\">4.mmap</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">5.零拷贝</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">9.特殊语法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">1.泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">1.为什么使用泛型</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">2.泛型的基本用法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%88-%EF%BC%89\"><span class=\"toc-text\">3.泛型中的通配符（?）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4\"><span class=\"toc-text\">4.泛型中的类型擦除</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8F%8D%E5%B0%84\"><span class=\"toc-text\">2.反射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.反射的作用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%8F%8D%E5%B0%84%E7%9A%84%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">2.反射的用法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%8F%8D%E5%B0%84%E6%94%BB%E5%87%BB\"><span class=\"toc-text\">3.反射攻击</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">4.反射的作用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">5.反射的原理</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">3.注解</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">1.定义注解</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E6%A0%87%E8%AE%B0%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">2.标记注解</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E8%AF%BB%E5%8F%96%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">3.读取注解</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%B3%A8%E8%A7%A3%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.注解应用</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">4.动态代理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%88%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%89\"><span class=\"toc-text\">1.静态代理（见设计模式）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">2.动态代理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%9F%BA%E4%BA%8EJDK%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">3.基于JDK实现动态代理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%9F%BA%E4%BA%8ECGLIB%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">4.基于CGLIB实现动态代理</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">5.函数式编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">1.函数式编程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">2.函数接口</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><span class=\"toc-text\">3.Lambda表达式</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">4.方法引用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-Sream%E6%B5%81\"><span class=\"toc-text\">5.Sream流</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">多线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.线程概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BA%BF%E7%A8%8B%E7%94%B1%E6%9D%A5\"><span class=\"toc-text\">1.线程由来</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">2.线程概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">3.线程模型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">4.实现原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">5.代码实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">1.创建一个线程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">2.线程状态</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">3.线程池</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">6.线程安全</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-JMM\"><span class=\"toc-text\">2.JMM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-CPU%E7%BC%93%E5%AD%98%E5%AF%BC%E8%87%B4%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1.CPU缓存导致可见性问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E5%AF%BC%E8%87%B4%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.指令重排导致有序性问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E7%A8%8B%E7%AB%9E%E4%BA%89%E5%AF%BC%E8%87%B4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3.线程竞争导致原子性问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-volatile\"><span class=\"toc-text\">4.volatile</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-synchronized-amp-final\"><span class=\"toc-text\">5.synchronized&amp;final</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-happens-before%E8%A7%84%E5%88%99\"><span class=\"toc-text\">6.happens-before规则</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E4%BA%92%E6%96%A5%E9%94%81\"><span class=\"toc-text\">3.互斥锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Synchronized\"><span class=\"toc-text\">1.Synchronized</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Lock\"><span class=\"toc-text\">2.Lock</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-Lock\"><span class=\"toc-text\">1.Lock</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-AQS\"><span class=\"toc-text\">2.AQS</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-ReadWriteLock\"><span class=\"toc-text\">3.ReadWriteLock</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">3.无锁编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-CAS\"><span class=\"toc-text\">1.CAS</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%8E%9F%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">2.原子类</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E7%B4%AF%E5%8A%A0%E5%99%A8\"><span class=\"toc-text\">3.累加器</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-ThreadLocal\"><span class=\"toc-text\">4.ThreadLocal</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%88%E6%B4%BB%E8%B7%83%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">5.锁产生的问题（活跃性问题）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7\"><span class=\"toc-text\">4.同步工具</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">1.条件变量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%BF%A1%E5%8F%B7%E9%87%8F\"><span class=\"toc-text\">2.信号量</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Latch-amp-Barrier\"><span class=\"toc-text\">3.Latch&amp;Barrier</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">5.并发容器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%B9%B6%E5%8F%91%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">1.并发阻塞</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%88%86%E6%AE%B5%E5%8A%A0%E9%94%81\"><span class=\"toc-text\">2.分段加锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">3.写时复制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">6.线程管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">1.线程状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">2.线程池</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD\"><span class=\"toc-text\">3.线程中断</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">虚拟机</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">1.编译执行</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">1.编译链接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JIT%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">2.JIT编译</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">3.编译优化</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">2.类加载器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">1.类加载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">2.双亲委派机制</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">3.内存分区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA\"><span class=\"toc-text\">1.内存分区</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%A0%88%E5%86%85%E5%AD%98\"><span class=\"toc-text\">2.栈内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%A0%86%E5%86%85%E5%AD%98\"><span class=\"toc-text\">3.堆内存</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">4.垃圾回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90\"><span class=\"toc-text\">1.可达性分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.垃圾回收算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8\"><span class=\"toc-text\">3.垃圾回收器</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-JVM%E5%AE%9E%E6%88%98\"><span class=\"toc-text\">5.JVM实战</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-JVM%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">1.JVM性能优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JVM%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5\"><span class=\"toc-text\">2.JVM问题排查</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">新特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-jdk9%EF%BC%882017-09%EF%BC%89\"><span class=\"toc-text\">1.jdk9（2017.09）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-jdk10%EF%BC%882018-03%EF%BC%89\"><span class=\"toc-text\">2.jdk10（2018.03）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-jdk11%EF%BC%882018-09-LTS%EF%BC%89\"><span class=\"toc-text\">3.jdk11（2018.09 LTS）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-jdk12%EF%BC%882019-03%EF%BC%89\"><span class=\"toc-text\">4.jdk12（2019.03）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-jdk13%EF%BC%882019-09%EF%BC%89\"><span class=\"toc-text\">5.jdk13（2019.09）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-jdk14%EF%BC%882020-03%EF%BC%89\"><span class=\"toc-text\">6.jdk14（2020.03）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-jdk15%EF%BC%882020-09%EF%BC%89\"><span class=\"toc-text\">7.jdk15（2020.09）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-jdk16%EF%BC%882021-03%EF%BC%89\"><span class=\"toc-text\">8.jdk16（2021.03）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-jdk17%EF%BC%882021-09-LTS%EF%BC%89\"><span class=\"toc-text\">9.jdk17（2021.09 LTS）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-JVM%E5%8F%98%E5%8C%96%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">10.JVM变化总结</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Data-Structure\"><span class=\"toc-text\">Data Structure</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%A4%A7O%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%B3%95\"><span class=\"toc-text\">1.大O复杂度表示法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">2.算法思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-1%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.1贪心算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-2%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.2分治算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">2.3动态规划</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.4回溯算法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-5%E6%9E%9A%E4%B8%BE%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.5枚举算法</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BA%AF%E7%BC%96%E7%A8%8B%E9%A2%98\"><span class=\"toc-text\">1.纯编程题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">1.1 解题技巧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">1.2 解题步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">1.3 例题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%89%BE%E8%A7%84%E5%BE%8B%E9%A2%98\"><span class=\"toc-text\">2.找规律题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">2.1 解题技巧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">2.2 例题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">3.数组和链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">3.1数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">3.2链表</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">3.3题型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-3-1-%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">3.3.1 解题技巧</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97\"><span class=\"toc-text\">4.栈和队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1%E6%A0%88\"><span class=\"toc-text\">4.1栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-1-%E9%A1%BA%E5%BA%8F%E6%A0%88\"><span class=\"toc-text\">4.1.1 顺序栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-2-%E9%93%BE%E5%BC%8F%E6%A0%88\"><span class=\"toc-text\">4.1.2 链式栈</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-1-3%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.1.3经典应用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2%E9%98%9F%E5%88%97\"><span class=\"toc-text\">4.2队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-1-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">4.2.1 循环队列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-2-%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97\"><span class=\"toc-text\">4.2.2 链表队列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-2-3%E7%BB%8F%E5%85%B8%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">4.2.3经典应用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">4.3题型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-1%E7%BB%86%E5%88%86%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">4.3.1细分题型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-3-2%E4%BE%8B%E9%A2%98\"><span class=\"toc-text\">4.3.2例题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%88%86%E6%B2%BB%E5%92%8C%E9%80%92%E5%BD%92\"><span class=\"toc-text\">5.分治和递归</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">5.1概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3\"><span class=\"toc-text\">5.2重复计算问题如何解决</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3%E7%BC%96%E5%86%99%E9%80%92%E5%BD%92%E4%BB%A3%E7%A0%81%E7%9A%84%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">5.3编写递归代码的技巧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">5.4题型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">6.排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88\"><span class=\"toc-text\">6.1排序算法总览</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">6.2排序算法细节</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">归并排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89\"><span class=\"toc-text\">快速排序（重点）</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">6.3题型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">7.二分查找</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-1%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">7.1原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-1-1%E5%85%B6%E5%AE%83%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">7.1.1其它查找</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">7.2代码实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-3%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">7.3复杂度分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-4%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">7.4题型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-4-1%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">7.4.1解题技巧</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-4-2%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">7.4.2题型</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%93%88%E5%B8%8C%E8%A1%A8\"><span class=\"toc-text\">8.哈希表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">8.1基础知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-2%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%89%A9%E5%B1%95\"><span class=\"toc-text\">8.2哈希表的扩展</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-3%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">8.3题型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">9.二叉树</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">9.1二叉树的前中后序遍历</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-2%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-BST-%E7%9A%84%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">9.2二叉查找树(BST)的查找，插入，删除</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-3%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91BBST%EF%BC%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91AVL\"><span class=\"toc-text\">9.3平衡二叉查找树BBST，平衡二叉树AVL</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-4Java%E4%B8%AD%E7%9A%84TreeMap%EF%BC%8CTreeSet\"><span class=\"toc-text\">9.4Java中的TreeMap，TreeSet</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-5B%E6%A0%91%E3%80%81B-%E6%A0%91\"><span class=\"toc-text\">9.5B树、B+树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-6%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">9.6线索二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-7%E9%A2%98%E5%9E%8B%E5%A5%97%E8%B7%AF\"><span class=\"toc-text\">9.7题型套路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#10-%E5%A0%86-%E4%BD%BF%E7%94%A8%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97\"><span class=\"toc-text\">10.堆(使用优先级队列)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-1%E5%A0%86\"><span class=\"toc-text\">10.1堆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-2%E5%A0%86%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">10.2堆排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-3%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">10.3题型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#11-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%EF%BC%88Trie%E6%A0%91%EF%BC%89\"><span class=\"toc-text\">11.字符串匹配（Trie树）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-1%E5%8D%95%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9C%A8%E4%B8%BB%E4%B8%B2%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%80%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%B2\"><span class=\"toc-text\">11.1单模式串匹配算法：在主串中查找一个模式串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-2%E5%A4%9A%E6%A8%A1%E5%BC%8F%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%9A%E5%9C%A8%E4%B8%BB%E4%B8%B2%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%A4%9A%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%B2\"><span class=\"toc-text\">11.2多模式串匹配算法：在主串中查找多个模式串</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-3\"><span class=\"toc-text\">11.3</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#12-%E5%9B%9E%E6%BA%AF\"><span class=\"toc-text\">12.回溯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-1%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">12.1核心思想</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-2%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">12.2代码模板</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-3%E5%9B%9E%E6%BA%AF%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">12.3回溯相关题型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#13-%E5%9B%BE\"><span class=\"toc-text\">13.图</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-1%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">13.1基础概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-2%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">13.2存储</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-3BFS%E3%80%81DFS%EF%BC%88C%E8%AF%AD%E8%A8%80%E4%BC%AA%E7%A0%81%E7%89%88%EF%BC%89\"><span class=\"toc-text\">13.3BFS、DFS（C语言伪码版）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-4BFS%E3%80%81DFS%EF%BC%88java%E7%89%88%EF%BC%89\"><span class=\"toc-text\">13.4BFS、DFS（java版）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-5%E5%9B%BE%E4%B8%8A%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">13.5图上其他算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88PK%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">1.最小生成树（PK算法）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88DF%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">2.最短路径（DF算法）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-AOV%E7%BD%91%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">3.AOV网：拓扑排序</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-AOE%E7%BD%91\"><span class=\"toc-text\">4.AOE网</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%9C%80%E5%A4%A7%E6%B5%81-%EF%BC%8C%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">5.最大流 ，二分匹配</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-6%E9%A2%98%E5%9E%8B%E5%A5%97%E8%B7%AF\"><span class=\"toc-text\">13.6题型套路</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#14-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">14.动态规划</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">1.理论知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2.经典问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E5%9E%8B\"><span class=\"toc-text\">3.动态规划相关题型</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#15-%E5%85%B6%E5%AE%83\"><span class=\"toc-text\">15.其它</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1.海量数据处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%8C%E6%8C%87%E9%92%88\"><span class=\"toc-text\">2.双指针</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3\"><span class=\"toc-text\">3.滑动窗口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">4.前缀后缀匹配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E4%BD%8D%E8%BF%90%E7%AE%97-1\"><span class=\"toc-text\">5.位运算</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Design-Pattern\"><span class=\"toc-text\">Design Pattern</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81%E8%AF%84%E4%BB%B7%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">1.高质量代码评价原则</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F\"><span class=\"toc-text\">2.编程范式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%88C%EF%BC%89\"><span class=\"toc-text\">1.面向过程（C）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88Java%EF%BC%89\"><span class=\"toc-text\">2.面向对象（Java）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88JavaScript%EF%BC%89\"><span class=\"toc-text\">3.原型编程（JavaScript）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%88Lisp%EF%BC%89\"><span class=\"toc-text\">4.函数式编程（Lisp）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88C-%EF%BC%89\"><span class=\"toc-text\">5.泛型编程（C++）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%A7%94%E6%89%98%E6%A8%A1%E5%BC%8F%EF%BC%88Go%EF%BC%89\"><span class=\"toc-text\">6.委托模式（Go）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">3.设计原则</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1SOLID%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">3.1SOLID原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2%E5%85%B6%E5%AE%83%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">3.2其它原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E6%80%A7\"><span class=\"toc-text\">3.3代码复用性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4%E5%AE%9E%E6%88%98%EF%BC%9A%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">3.4实战：系统设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5%E5%AE%9E%E6%88%98%EF%BC%9A%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">3.5实战：框架设计</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">4.编程规范与代码重构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">1.代码重构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-20%E6%9D%A1%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83\"><span class=\"toc-text\">2.20条编程规范</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E6%88%98%EF%BC%9AID%E7%94%9F%E6%88%90%E5%99%A8\"><span class=\"toc-text\">3.实战：ID生成器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%AE%9E%E6%88%98%EF%BC%9A%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E9%87%8D%E6%9E%84\"><span class=\"toc-text\">4.实战：框架设计重构</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.创建型设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.单例模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.工厂模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.建造者模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.原型模式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.结构型设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.代理模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.桥接模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.装饰者模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.适配器模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.门面模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">6.组合模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">7.享元模式</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.行为型设计模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">1.观察者模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.模板模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3.策略模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">4.职责链模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5.状态模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88%E6%B8%B8%E6%A0%87%EF%BC%89%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">6.迭代器（游标）模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">7.访问者模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">8.备忘录模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">9.命令模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">10.解释器模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E4%B8%AD%E4%BB%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">11.中介模式</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Distributed-System\"><span class=\"toc-text\">Distributed System</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1.分布式系统概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">1.分布式协调与同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5%EF%BC%9A%E6%8E%92%E4%BB%96%E6%80%A7%E7%9A%84%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1.分布式互斥：排他性的资源访问方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%89%E4%B8%BE%EF%BC%9A%E9%80%89%E5%87%BA%E9%9B%86%E7%BE%A4%E7%9A%84%E4%B8%BB%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">2.分布式选举：选出集群的主节点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%EF%BC%9A%E5%AD%98%E5%BC%82%E6%B1%82%E5%90%8C\"><span class=\"toc-text\">3.分布式共识：存异求同</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9A\"><span class=\"toc-text\">4.分布式事务：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">5.分布式锁：</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%88%86%E5%B8%83%E5%BC%8F%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B4%9F%E8%BD%BD%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">2.分布式资源管理与负载调度</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%BB%93%E6%9E%84%EF%BC%88Master-Slave%E6%9E%B6%E6%9E%84%EF%BC%89\"><span class=\"toc-text\">1.集中式结构（Master&#x2F;Slave架构）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%9D%9E%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%BB%93%E6%9E%84%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%EF%BC%89\"><span class=\"toc-text\">2.非集中式结构（分布式架构）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%8D%95%E4%BD%93%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">3.单体调度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E4%B8%A4%E5%B1%82%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">4.两层调度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">5.共享状态调度</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">3.分布式计算技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-MapReduce\"><span class=\"toc-text\">1.MapReduce</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Stream\"><span class=\"toc-text\">2.Stream</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Actor\"><span class=\"toc-text\">3.Actor</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%B5%81%E6%B0%B4%E7%BA%BF\"><span class=\"toc-text\">4.流水线</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">4.分布式通信技术</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">1.远程调用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85\"><span class=\"toc-text\">2.发布订阅</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">3.消息队列</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">5.分布式数据存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-CAP%E7%90%86%E8%AE%BA\"><span class=\"toc-text\">1.CAP理论</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%B8%89%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">2.分布式存储系统三要素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3.数据分布方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">4.分布式数据复制技术</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">5.分布式数据缓存技术</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%8F%AF%E9%9D%A0\"><span class=\"toc-text\">6.分布式高可靠</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">1.负载均衡</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">2.流量控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%95%85%E9%9A%9C%E9%9A%94%E7%A6%BB\"><span class=\"toc-text\">3.故障隔离</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D\"><span class=\"toc-text\">4.故障恢复</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%96%87%E7%AB%A0\"><span class=\"toc-text\">2.分布式架构文章</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Distributed-systems-theory-for-the-distributed-systems-engineer\"><span class=\"toc-text\">1.Distributed systems theory for the distributed systems engineer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Book\"><span class=\"toc-text\">1.Book</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Failure-and-Time\"><span class=\"toc-text\">2.Failure and Time</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-The-basic-tension-of-fault-tolerance\"><span class=\"toc-text\">3.The basic tension of fault tolerance</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Basic-primitives\"><span class=\"toc-text\">4.Basic primitives</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Fundamental-Results\"><span class=\"toc-text\">5.Fundamental Results</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-CALM-amp-CDRT\"><span class=\"toc-text\">6.CALM &amp; CDRT</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Fallacies-of-Distributed-Computing-Explained\"><span class=\"toc-text\">2.Fallacies of Distributed Computing Explained</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Notes-on-Distributed-Systems-for-Young-Bloods\"><span class=\"toc-text\">3.Notes on Distributed Systems for Young Bloods</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Scalable-Web-Architecture-and-Distributed-Systems\"><span class=\"toc-text\">4.Scalable Web Architecture and Distributed Systems</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Web%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">Web分布式系统设计的原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%EF%BC%88Service%EF%BC%89\"><span class=\"toc-text\">服务（Service）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%86%97%E4%BD%99%EF%BC%88Redundancy%EF%BC%89\"><span class=\"toc-text\">冗余（Redundancy）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E5%8C%BA%EF%BC%88Partition%EF%BC%89\"><span class=\"toc-text\">分区（Partition）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%EF%BC%88handing-failure%EF%BC%89\"><span class=\"toc-text\">故障处理（handing  failure）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">数据访问组件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97%EF%BC%9A%E5%AF%B9%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E9%AB%98%E6%95%88%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">队列：对写数据的高效管理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-The-twelve-factor-app\"><span class=\"toc-text\">5.The twelve-factor app</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">3.实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%80%BB%E8%A7%88\"><span class=\"toc-text\">1.系统设计总览</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%89%A9%E5%B1%95%E6%80%A7\"><span class=\"toc-text\">1.扩展性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%9D%83%E8%A1%A1%E4%B8%8E%E5%8F%96%E8%88%8D\"><span class=\"toc-text\">2.权衡与取舍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Domain-name-system\"><span class=\"toc-text\">3.Domain name system</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Content-delivery-network\"><span class=\"toc-text\">4.Content delivery network</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Load-Balancer\"><span class=\"toc-text\">5.Load Balancer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-Reverse-proxy-Web-server\"><span class=\"toc-text\">6.Reverse proxy(Web server)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-Platform-Layer%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89\"><span class=\"toc-text\">7.Platform Layer（应用层）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-1-RDBMS\"><span class=\"toc-text\">8-1.RDBMS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-2-NoSQL\"><span class=\"toc-text\">8-2.NoSQL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">9.缓存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E5%BC%82%E6%AD%A5\"><span class=\"toc-text\">10.异步</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BA%92%E8%81%94%E7%BD%91%E6%9E%B6%E6%9E%84%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">2.互联网架构模板</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AD%98%E5%82%A8%E5%B1%82\"><span class=\"toc-text\">1.存储层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%BC%80%E5%8F%91%E5%B1%82%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%B1%82\"><span class=\"toc-text\">2.开发层和服务层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">3.网络层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%94%A8%E6%88%B7%E5%B1%82%E5%92%8C%E4%B8%9A%E5%8A%A1%E5%B1%82\"><span class=\"toc-text\">4.用户层和业务层</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%B9%B3%E5%8F%B0%E5%B1%82\"><span class=\"toc-text\">5.平台层</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%AB%98%E5%B9%B6%E5%8F%91%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF\"><span class=\"toc-text\">3.服务端高并发分布式架构演进之路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. 概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">2. 基本概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B\"><span class=\"toc-text\">3. 架构演进</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-1-%E5%8D%95%E6%9C%BA%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">3.1 单机架构</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-2-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9ATomcat%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BC%80%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">3.2 第一次演进：Tomcat与数据库分开部署</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-3-%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98\"><span class=\"toc-text\">3.3 第二次演进：引入本地缓存和分布式缓存</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-4-%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E5%BC%95%E5%85%A5%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">3.4 第三次演进：引入反向代理实现负载均衡</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-5-%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">3.5 第四次演进：数据库读写分离</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-6-%E7%AC%AC%E4%BA%94%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8C%89%E4%B8%9A%E5%8A%A1%E5%88%86%E5%BA%93\"><span class=\"toc-text\">3.6 第五次演进：数据库按业务分库</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-7-%E7%AC%AC%E5%85%AD%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E6%8A%8A%E5%A4%A7%E8%A1%A8%E6%8B%86%E5%88%86%E4%B8%BA%E5%B0%8F%E8%A1%A8\"><span class=\"toc-text\">3.7 第六次演进：把大表拆分为小表</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-8-%E7%AC%AC%E4%B8%83%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BD%BF%E7%94%A8LVS%E6%88%96F5%E6%9D%A5%E4%BD%BF%E5%A4%9A%E4%B8%AANginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">3.8 第七次演进：使用LVS或F5来使多个Nginx负载均衡</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-9-%E7%AC%AC%E5%85%AB%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E9%80%9A%E8%BF%87DNS%E8%BD%AE%E8%AF%A2%E5%AE%9E%E7%8E%B0%E6%9C%BA%E6%88%BF%E9%97%B4%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">3.9 第八次演进：通过DNS轮询实现机房间的负载均衡</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-10-%E7%AC%AC%E4%B9%9D%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E5%BC%95%E5%85%A5NoSQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E7%AD%89%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">3.10 第九次演进：引入NoSQL数据库和搜索引擎等技术</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-11-%E7%AC%AC%E5%8D%81%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E5%A4%A7%E5%BA%94%E7%94%A8%E6%8B%86%E5%88%86%E4%B8%BA%E5%B0%8F%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">3.11 第十次演进：大应用拆分为小应用</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-12-%E7%AC%AC%E5%8D%81%E4%B8%80%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E5%A4%8D%E7%94%A8%E7%9A%84%E5%8A%9F%E8%83%BD%E6%8A%BD%E7%A6%BB%E6%88%90%E5%BE%AE%E6%9C%8D%E5%8A%A1\"><span class=\"toc-text\">3.12 第十一次演进：复用的功能抽离成微服务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-13-%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E5%BC%95%E5%85%A5%E4%BC%81%E4%B8%9A%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BFESB%E5%B1%8F%E8%94%BD%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B7%AE%E5%BC%82\"><span class=\"toc-text\">3.13 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-14-%E7%AC%AC%E5%8D%81%E4%B8%89%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E5%BC%95%E5%85%A5%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB%E4%B8%8E%E5%8A%A8%E6%80%81%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-15-%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%AC%A1%E6%BC%94%E8%BF%9B%EF%BC%9A%E4%BB%A5%E4%BA%91%E5%B9%B3%E5%8F%B0%E6%89%BF%E8%BD%BD%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">3.15 第十四次演进：以云平台承载系统</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">4. 架构设计总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">4.高性能架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">1.数据库集群</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-NoSQL\"><span class=\"toc-text\">2.NoSQL</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E7%BC%93%E5%AD%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%88%96%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">3.缓存：使用程序代码实现或中间件来实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%8D%95%E6%9C%8D%E5%8A%A1%E5%99%A8\"><span class=\"toc-text\">4.单服务器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E9%9B%86%E7%BE%A4%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1\"><span class=\"toc-text\">5.集群负载均衡</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">5.高可用架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-CAP%E7%90%86%E8%AE%BA-1\"><span class=\"toc-text\">1.CAP理论</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-FMEA%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.FMEA方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AD%98%E5%82%A8%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">3.存储高可用架构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%AE%A1%E7%AE%97%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">4.计算高可用架构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E4%B8%9A%E5%8A%A1%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">5.业务高可用架构</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E5%88%86%E6%9E%90\"><span class=\"toc-text\">6.分布式数据存储与分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%8A%80%E6%9C%AF%E7%9A%84%E6%9D%A5%E9%BE%99%E5%8E%BB%E8%84%89\"><span class=\"toc-text\">1.大数据技术的来龙去脉</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Hadoop\"><span class=\"toc-text\">Hadoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#HDFS\"><span class=\"toc-text\">HDFS</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Yarn\"><span class=\"toc-text\">Yarn</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#MapReduce\"><span class=\"toc-text\">MapReduce</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Hive%EF%BC%88%E7%A6%BB%E7%BA%BF%EF%BC%89\"><span class=\"toc-text\">Hive（离线）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Spark%EF%BC%88%E5%AE%9E%E6%97%B6%EF%BC%89\"><span class=\"toc-text\">Spark（实时）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Kafka\"><span class=\"toc-text\">Kafka</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Flink%EF%BC%88Kafka2-0-%EF%BC%89\"><span class=\"toc-text\">Flink（Kafka2.0?）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">2.分布式数据存储</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.数据分析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6\"><span class=\"toc-text\">4.资源调度</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E6%96%B0%E4%B8%89%E9%A9%BE%E9%A9%AC%E8%BD%A6\"><span class=\"toc-text\">5.新三驾马车</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring-Family\"><span class=\"toc-text\">Spring Family</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-Framework\"><span class=\"toc-text\">Spring Framework</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-IOC-Container\"><span class=\"toc-text\">1.IOC Container</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0-1\"><span class=\"toc-text\">1.概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Container\"><span class=\"toc-text\">2.Container</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Bean\"><span class=\"toc-text\">3.Bean</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Dpendencies\"><span class=\"toc-text\">4.Dpendencies</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Bean-Scopes\"><span class=\"toc-text\">5.Bean Scopes</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-Container-Extension-Points\"><span class=\"toc-text\">6.Container Extension Points</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">7.基于注解的容器配置</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E5%9F%BA%E4%BA%8EJava%E7%9A%84%E5%AE%B9%E5%99%A8%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">8.基于Java的容器配置</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-AOP\"><span class=\"toc-text\">2.AOP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-AspectJ\"><span class=\"toc-text\">2.@AspectJ</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Data-Access\"><span class=\"toc-text\">3.Data Access</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Transaction-Management\"><span class=\"toc-text\">1.Transaction Management</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JDBC\"><span class=\"toc-text\">2.JDBC</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-O-R-Mapping\"><span class=\"toc-text\">3.O&#x2F;R Mapping</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-JPA\"><span class=\"toc-text\">1.JPA</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-Lombok\"><span class=\"toc-text\">2.Lombok</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-MyBatis\"><span class=\"toc-text\">3.MyBatis</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-ApplicationContext\"><span class=\"toc-text\">4.ApplicationContext</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Validation\"><span class=\"toc-text\">5.Validation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Data-Binding\"><span class=\"toc-text\">6.Data Binding</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-Type-Conversion\"><span class=\"toc-text\">7.Type Conversion</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-Null-safety\"><span class=\"toc-text\">8.Null-safety</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-MVC\"><span class=\"toc-text\">Spring MVC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">1.定义映射关系</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AE%9A%E4%B9%89%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%EF%BC%88Handler-Methods%EF%BC%89\"><span class=\"toc-text\">2.定义处理方法（Handler Methods）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.其它操作</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6DispatcherServlet\"><span class=\"toc-text\">2.运行机制DispatcherServlet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86\"><span class=\"toc-text\">1.请求处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">2.视图解析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">3.异常处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-RestTemplate\"><span class=\"toc-text\">3.RestTemplate</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-URI%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">4.URI设计</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Spring-Session\"><span class=\"toc-text\">5.Spring Session</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-Data\"><span class=\"toc-text\">Spring Data</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-MongoDB\"><span class=\"toc-text\">1.MongoDB</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-MongoDB-1\"><span class=\"toc-text\">1.MongoDB</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Spring-Data%E7%9B%B8%E5%85%B3\"><span class=\"toc-text\">2.Spring Data相关</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Redis\"><span class=\"toc-text\">2.Redis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Redis\"><span class=\"toc-text\">1.Redis</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Spring-Data%E7%9B%B8%E5%85%B3-1\"><span class=\"toc-text\">2.Spring Data相关</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-ElasticSearch\"><span class=\"toc-text\">3.ElasticSearch</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ElasticSearch\"><span class=\"toc-text\">1.ElasticSearch</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Spring-Data%E7%9B%B8%E5%85%B3-2\"><span class=\"toc-text\">2.Spring Data相关</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-Boot\"><span class=\"toc-text\">Spring Boot</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%A7%88\"><span class=\"toc-text\">1.概览</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%94%A8SpringBoot%E5%BC%80%E5%8F%91\"><span class=\"toc-text\">1.用SpringBoot开发</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Auto-Configuration\"><span class=\"toc-text\">2.Auto Configuration</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%BF%90%E8%A1%8C%E7%9B%91%E6%B5%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.运行监测管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-Actuator\"><span class=\"toc-text\">1.Actuator</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-Health-Indicator\"><span class=\"toc-text\">2.Health Indicator</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-Micrometer\"><span class=\"toc-text\">3.Micrometer</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%AE%9A%E5%88%B6%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">4.定制运行参数</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E6%89%93%E5%8C%85%E6%88%90Docker%E9%95%9C%E5%83%8F\"><span class=\"toc-text\">5.打包成Docker镜像</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">2.核心特性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-SpringApplication\"><span class=\"toc-text\">1.SpringApplication</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Externalized-Configuration\"><span class=\"toc-text\">2.Externalized Configuration</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-JSON\"><span class=\"toc-text\">3.JSON</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Task-Excution-and-Scheduling\"><span class=\"toc-text\">4.Task Excution and Scheduling</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%85%B6%E5%AE%83\"><span class=\"toc-text\">5.其它</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Web\"><span class=\"toc-text\">3.Web</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Servelt-Web-Application\"><span class=\"toc-text\">1.Servelt Web Application</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Spring-Security\"><span class=\"toc-text\">2.Spring Security</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Spring-Session\"><span class=\"toc-text\">3.Spring Session</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Data\"><span class=\"toc-text\">4.Data</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%85%B6%E5%AE%83-1\"><span class=\"toc-text\">5.其它</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-Cloud\"><span class=\"toc-text\">Spring Cloud</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Spring-Cloud-Alibaba\"><span class=\"toc-text\">1.Spring Cloud Alibaba</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Nacos-Discovery\"><span class=\"toc-text\">1.Nacos Discovery</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Nacos-Config\"><span class=\"toc-text\">2.Nacos Config</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Sentinel\"><span class=\"toc-text\">3.Sentinel</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Spring-Cloud-Commons\"><span class=\"toc-text\">2.Spring Cloud Commons</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Application-Context-Services\"><span class=\"toc-text\">1.Application Context Services</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Common-Abstractions\"><span class=\"toc-text\">2.Common Abstractions</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Circuit-Breaker\"><span class=\"toc-text\">3.Circuit Breaker</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Spring-Cloud-Config\"><span class=\"toc-text\">3.Spring Cloud Config</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Spring-Cloud-OpenFeign\"><span class=\"toc-text\">4.Spring Cloud OpenFeign</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Spring-Cloud-Sleuth\"><span class=\"toc-text\">5.Spring Cloud Sleuth</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-Spring-Cloud-Stream\"><span class=\"toc-text\">6.Spring Cloud Stream</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%A7%88-1\"><span class=\"toc-text\">1.概览</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-RabbitMQ\"><span class=\"toc-text\">2.RabbitMQ</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Kafka\"><span class=\"toc-text\">3.Kafka</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Spring-Security\"><span class=\"toc-text\">Spring Security</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Test\"><span class=\"toc-text\">Test</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SOA\"><span class=\"toc-text\">SOA</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Containers-Docker\"><span class=\"toc-text\">1.Containers(Docker)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Configuration-Management-Ansible\"><span class=\"toc-text\">2.Configuration Management(Ansible)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Container-Orchestration-Kubernetes\"><span class=\"toc-text\">3.Container Orchestration(Kubernetes)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Infrastructure-Provisioning-Terraform\"><span class=\"toc-text\">4.Infrastructure Provisioning(Terraform)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Service-Mesh-Istio-Consul-%E7%9A%84\"><span class=\"toc-text\">5.Service Mesh(Istio&#x2F;Consul)的</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Demo\"><span class=\"toc-text\">Demo</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF\"><span class=\"toc-text\">1.架构及相关技术</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java并发","uid":"75ca176d6b382373bec123f05862c849","slug":"Java并发","date":"2023-04-13T23:56:43.000Z","updated":"2023-04-15T00:08:07.854Z","comments":true,"path":"api/articles/Java并发.json","keywords":null,"cover":[],"text":"Java并发1.线程 线程 线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING 线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N） Java使用用户线程模型，上层JVM...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}