{"title":"Java特性","uid":"b4296f0600f693552b5b6c6b665f6025","slug":"Java Base","date":"2023-04-13T11:25:47.000Z","updated":"2023-09-08T02:58:50.308Z","comments":true,"path":"api/articles/Java Base.json","keywords":null,"cover":[],"content":"<h1 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h1><h2 id=\"1-基础知识\"><a href=\"#1-基础知识\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h2><h3 id=\"1-关键字\"><a href=\"#1-关键字\" class=\"headerlink\" title=\"1.关键字\"></a>1.关键字</h3><ul>\n<li><code>true</code>, <code>false</code>, 和 <code>null</code> 虽然不是关键字，但它们是不能用作标识符的文字和保留字</li>\n<li>strictfp（精确浮点数，跨平台产生相同结果）、native（原生方法）</li>\n<li></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>class</th>\n<th>return</th>\n<th>byte</th>\n<th>try</th>\n<th>if</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>import</td>\n<td>public</td>\n<td>boolean</td>\n<td>cache</td>\n<td>else</td>\n</tr>\n<tr>\n<td>extends</td>\n<td>protected</td>\n<td>short</td>\n<td>finally</td>\n<td>for</td>\n</tr>\n<tr>\n<td>implements</td>\n<td>private</td>\n<td>int</td>\n<td>throw</td>\n<td>while</td>\n</tr>\n<tr>\n<td>enum</td>\n<td>==final==</td>\n<td>char</td>\n<td>throws</td>\n<td>do</td>\n</tr>\n<tr>\n<td>interface</td>\n<td>==static==</td>\n<td>long</td>\n<td>resource</td>\n<td>switch</td>\n</tr>\n<tr>\n<td>package</td>\n<td>abstract</td>\n<td>float</td>\n<td>==volatile==</td>\n<td>case</td>\n</tr>\n<tr>\n<td>new</td>\n<td>native</td>\n<td>double</td>\n<td>==synchronized==</td>\n<td>default</td>\n</tr>\n<tr>\n<td>super</td>\n<td><del>const</del></td>\n<td>void</td>\n<td>==transient==</td>\n<td>break</td>\n</tr>\n<tr>\n<td>this</td>\n<td><del>goto</del></td>\n<td>instanceof</td>\n<td>strictfp</td>\n<td>continue</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-概念辨析\"><a href=\"#2-概念辨析\" class=\"headerlink\" title=\"2.概念辨析\"></a>2.概念辨析</h3><ol>\n<li><p>值传递与引用传递</p>\n<ul>\n<li>引用类型（数组、接口、类）的数据存储在堆上，栈上存储的是堆的地址，直接更改对象对所有引用都可见，但不能像C++那样让引用指向新的对象</li>\n<li>引用数据判等：==判断两个引用是否指向同一对象，equals方法+重写的hashcode方法判断属性是否相等</li>\n</ul>\n</li>\n<li><p>深拷贝、浅拷贝、引用拷贝</p>\n<ul>\n<li><p>深拷贝与浅拷贝：深拷贝会复制整个对象，包括对象包含的内部对象；浅拷贝会在堆上创建一个新对象，但是对象内部引用类型变量只会复制引用地址，不会直接复制内部数据</p>\n</li>\n<li><p>引用拷贝：两个不同引用指向同一对象</p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Address implements Cloneable&#123;\n    private String name;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Address clone() &#123;\n        try &#123;\n            return (Address) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n\npublic class Person implements Cloneable &#123;\n    private Address address;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Person clone() &#123;\n        try &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;浅拷贝\n            Person person &#x3D; (Person) super.clone();\n            return person;\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;浅拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; true\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());\n\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;深拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@Override\npublic Person clone() &#123;\n    try &#123;\n        Person person &#x3D; (Person) super.clone();\n\t\t\t\t&#x2F;&#x2F;深拷贝\n        person.setAddress(person.getAddress().clone());\n        return person;\n    &#125; catch (CloneNotSupportedException e) &#123;\n        throw new AssertionError();\n    &#125;\n&#125;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; false\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());</code></pre></li>\n</ul>\n</li>\n<li><p>重载和重写的区别</p>\n<ul>\n<li>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理（如构造函数）；重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法（如Override）</li>\n<li>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的</li>\n</ul>\n</li>\n<li><p>接口和抽象类</p>\n<ul>\n<li>共同点：都不能被实例化、都可以包含抽象方法，都可以有默认实现方法（<code>default</code>声明，子类可不实d现）</li>\n<li>不同点：<ul>\n<li>接口主要是对API声明（参数类型、返回值类型、函数名），抽象类主要是为了代码复用</li>\n<li>一个类可以实现多个接口，但只能继承自一个抽象类</li>\n<li>接口中的成员变量只能是<code>public static final</code>类型的，不能被修改且必须有初始值，而抽象类的成员变量默认<code>default</code>，可在子类中被重新定义，也可被重新赋值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>final和static</p>\n<ul>\n<li>只有成员变量能被static、public、protected、private修饰，局部变量不行，但是两者都能被final修饰</li>\n</ul>\n</li>\n<li><p>引用类型转换：仅限于有继承关系的类之间，分为向上转换和向下转换两种</p>\n<ul>\n<li>向上转换，自动类型转换，总是可以的</li>\n<li>向下转换需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-语法糖\"><a href=\"#3-语法糖\" class=\"headerlink\" title=\"3.语法糖\"></a>3.语法糖</h3><ol>\n<li><p><strong>switch支持String与枚举</strong>：int比数、char比ascii码、字符串用hashCode()和equals()，其它如short、byte、int都需要转换为整数</p>\n</li>\n<li><p><strong>泛型和类型擦除</strong>：编译时会使用泛型做类型检查，但是当代码编译为字节码之后，泛型中的类型参数和通配符都替换为上界限（==类型擦除==）</p>\n<ul>\n<li><p>泛型遇到重载：因为都会转成父类型，所以<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>这种重载会编译失败</p>\n</li>\n<li><p>当泛型遇到catch：泛型的类型参数不能用在catch语句中，因为异常处理是由JVM在运行时刻来进行的，类型信息被擦除了，所以JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>\n</li>\n<li><p>创建对象时：不能使用new T()来创建类型参数对象，在代码编译成字节之后类型信息已经擦除，所以，在运行时，JVM无法确定具体类型，也就无法知道T是否存在无参构造函数</p>\n</li>\n<li><p>当泛型内包含静态变量：由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StaticTest&#123;\n    public static void main(String[] args)&#123;\n        GT&lt;Integer&gt; gti &#x3D; new GT&lt;Integer&gt;();\n        gti.var&#x3D;1;\n        GT&lt;String&gt; gts &#x3D; new GT&lt;String&gt;();\n        gts.var&#x3D;2;\n        System.out.println(gti.var); &#x2F;&#x2F;输出为2\n    &#125;\n&#125;\nclass GT&lt;T&gt;&#123;\n    public static int var&#x3D;0;\n    public void nothing(T x)&#123;&#125;\n&#125;</code></pre></li>\n<li><p>因为需要继承自Object，所以基本类型不可以传入类型参数，只有引用类型可以。但是有语法糖可以让<code>List&lt;int&gt;</code>中的int替换为Integer，但是开发上依旧需要为每个基本类型分别定义多个不同的函数接口</p>\n</li>\n</ul>\n</li>\n<li><p><strong>自动装箱与拆箱：原始类型byte, short, char, int, long, float, double, boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean</strong></p>\n<ul>\n<li><p>基本类型和包装类型的区别：包装类型不赋值时是null，可用于范型，占用空间大</p>\n<ul>\n<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中（JIT优化，逃逸分析，分配到栈上）</li>\n<li>基本数据类型存放在栈中是一个常见的误区！基本数据类型的成员变量如果没有被 static修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中</li>\n<li>类静态成员变量存放在方法区中！（方法区又叫静态区，跟堆一样，被所有线程共享，方法区包含所有的class和static变量）</li>\n</ul>\n</li>\n<li><p>常量池</p>\n<ul>\n<li><p>Integer等包装类使用了常量池技术，IntegerCache类（享元模式）中会缓存值为-128到127之间的Integer对象，当通过自动装箱，也就是调用valueOf()来创建Integer对象时，如果要创建的Integer对象的值在-128到127之间，会从IntegerCache中直接返回，否则才会真正调用new方法创建，详见Integer类的valueOf()（JVM也提供了方法，可以自定义缓存的最大值）</p>\n</li>\n<li><p>Byte、Short、Integer、Long这四种包装类默认创建了数值[-128,128]的相应类型的缓存数据（存放在一个Cache数组中，由static代码块直接初始化），Character创建了数值在[0，127]范围的缓存数据，Boolean直接返回True或False（<code>return (b ? TRUE : FALSE);</code>）</p>\n</li>\n<li><p>所有整型包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i1 &#x3D; 40; &#x2F;&#x2F;触发自动装箱，使用缓存中的对象\nInteger i2 &#x3D; new Integer(40); &#x2F;&#x2F;新创建的对象\nSystem.out.println(i1&#x3D;&#x3D;i2); &#x2F;&#x2F;返回false</code></pre></li>\n</ul>\n</li>\n<li><p>示例代码：项目首选基本类型，业务相关可选包装类用null表示空而不是0</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;自动装箱，语法糖，底层实现为：Integer iobj &#x3D; Integer。valueOf(12);\nInteger iobj &#x3D; 12;\n&#x2F;&#x2F;自动拆箱，语法糖，底层实现为：int i &#x3D; iobj.intValue();\nint i &#x3D; iobj;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;触发自动装箱和拆箱的几种情况&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;将基本类型数据赋值给包装类变量（包括参数传递）时，触发自动装箱\nint i1 &#x3D; 5\nInteger iobj1 &#x3D; 5;&#x2F;&#x2F;1\niobj &#x3D; i1;&#x2F;&#x2F;1\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(i1);&#x2F;&#x2F;1\n&#x2F;&#x2F;将包装类对象赋值给基本类型变量（包括参数传递）时，触发自动拆箱\nInteger iobj2&#x3D; new Integer(6);\nint i2 &#x3D; iobj2;&#x2F;&#x2F;2\n&#x2F;&#x2F;当包装类对象参与算术运算、关系运算（&lt;,&gt;）时，触发自动拆箱操作\nInteger iobj3 &#x3D; iobj1 + iobj2;\nboolean bl &#x3D; (iobj1 &lt; iobj2);\nbl &#x3D; (iobj1 &lt; 2);\n&#x2F;&#x2F;当包装类对象参与关系运算（&#x3D;&#x3D;），且另一方是基本类型数据时，触发自动拆箱操作。\nInteger iobj4 &#x3D; new Integer(123);\nbl &#x3D; (iob4 &#x3D;&#x3D; 123);</code></pre></li>\n</ul>\n</li>\n<li><p><strong>方法变长参数</strong>：String… args用一个数组实现，用foreach遍历，编译后会被转变成数组</p>\n</li>\n<li><p><strong>枚举</strong>：当我们使用enum来定义一个枚举类型的时候，编译器会自动创建一个final类型的类继承Enum类，所以枚举类型不能被继承（<code>public enum t&#123;&#125;</code> =&gt; <code>public final class T extends Enum&#123;&#125;</code>）</p>\n</li>\n<li><p>内部类：</p>\n<ul>\n<li>会独立于外部类，生成一个新的class文件，名字为外部类名$内部类名.class或外部类名$[序号].class，静态匿名内部类可访问静态成员变量+静态函数；普通匿名内部类不可访问外部函数中非final修饰的局部变量</li>\n<li>外部函数通过类似参数传递的方式，将局部变量通过值传递的方式传入到匿名内部类，这是外部函数局部变量的副本，所以如果能访问非final修饰的局部变量的话，内部类对其的更改不起作用，违反直觉，类似于形参的改变不影响实参</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface I&#123;&#125;\npublic class A&#123;\n    private class B&#123;&#125; &#x2F;&#x2F;类似于ArrayList的内部类Itr\n    private class C implements I&#123;&#125;&#x2F;&#x2F;实现外部接口的内部类\n    public class D&#123;&#125;&#x2F;&#x2F;public修饰的内部类\n\t\tpublic static class E&#123;&#125;&#x2F;&#x2F;静态内部类\n    \n    public B getB()&#123; return new B(); &#125;\n    public I getC()&#123; return new C(); &#125;\n    public D getD()&#123; return new D(); &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.B b &#x3D; a.getB();&#x2F;&#x2F;编译报错，满足封装原则\n        I c &#x3D; a.getC();&#x2F;&#x2F;可访问\n        A.D d1 &#x3D; a.getD();\n        A.D d2 &#x3D; a.new D();\n\t\t\t\tA.E e &#x3D; new A.E();&#x2F;&#x2F;静态内部类的对象可以独立于外部类单独创建\n    &#125;\n&#125;</code></pre></li>\n<li><p><strong>条件编译</strong>：if的条件是final且为false时，对应代码块不被编译，主要出于对代码优化的考虑</p>\n</li>\n<li><p><strong>断言</strong>：其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行</p>\n</li>\n<li><p><strong>数值字面量</strong>：不管是整数还是浮点数，都允许在数字之间插入任意多个下划线，为了方便阅读</p>\n</li>\n<li><p><strong>增强for循环</strong>：for-each用了普通的for循环和Iterator迭代器的hasNext()方法，在遍历过程中不能增删内部元素，会抛出异常（可以使用Iterator.remove()方法在删除当前迭代对象的同时维护索引的一致性）</p>\n</li>\n<li><p><strong>try-with-resource</strong>：在try()中写资源申请，就不用在finally中判断是否为null在关闭了，编译期帮助我们关闭了（资源类需要实现Java.lang.AutoClosale接口）</p>\n</li>\n<li><p><strong>lambda表达式</strong>：只有一个函数的接口叫做函数式接口，可以用Lambda表达式简化</p>\n<ul>\n<li><p>Lambda表达式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">(类型 a,类型 b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\n(a,b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\na-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a为输入参数\n&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;没有入参</code></pre></li>\n<li><p>方法引用：当Lambda中的逻辑已经有现成的方法实现时，可以直接使用方法引用。方法引用要求所引用的方法的参数列表的返回值，跟函数接口中未实现方法的参数列表和返回值完全一致，格式如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;对象::实例方法\n&#x2F;&#x2F;类::静态方法\n&#x2F;&#x2F;类::实例方法\npublic class FPDemo &#123;\n    public static void main(String] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n\t\t\t\t\t\t&#x2F;&#x2F;直接引用String的方法\n            .filter(((Predicate&lt;String&gt;) String::isEmpty).negate())\n            &#x2F;&#x2F; .filter(s-&gt;s.isEmpty())\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            .map(String::length)\n            &#x2F;&#x2F;.map(s-&gt;s.length())\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-进阶知识\"><a href=\"#2-进阶知识\" class=\"headerlink\" title=\"2.进阶知识\"></a>2.进阶知识</h2><h3 id=\"1-特殊语法\"><a href=\"#1-特殊语法\" class=\"headerlink\" title=\"1.特殊语法\"></a>1.特殊语法</h3><ol>\n<li><p>反射：在运行的过程中动态告知JVM去创建对象、创建方法、获取类信息（构造函数、方法、成员变量、注解），重要应用见Spring框架的依赖注入</p>\n<ul>\n<li><p>Class类：是一个存储类的信息的特殊的类，提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等</p>\n<ul>\n<li>Constructor类：用来存储构造函数的信息，如通过<code>newInstance()</code>方法来进行有参/无参构造</li>\n<li>Method类：存储方法的信息，如通过<code>invoke()</code>方法可以执行类中的对应方法</li>\n<li>Field类：用来存储成员变量的信息</li>\n</ul>\n</li>\n<li><p>获取反射的三种方法</p>\n<ul>\n<li><p>通过对象获取反射</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object obj &#x3D; new Object(); &#x2F;&#x2F; 创建一个对象\nClass&lt;?&gt; clazz &#x3D; obj.getClass(); &#x2F;&#x2F; 获取 Class 对象</code></pre></li>\n<li><p>通过类名获取反射</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.example.MyClass&quot;); &#x2F;&#x2F; 获取 Class 对象</code></pre></li>\n<li><p>通过类字面常量获取反射</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Class&lt;?&gt; clazz &#x3D; MyClass.class; &#x2F;&#x2F; 获取 Class 对象</code></pre></li>\n</ul>\n</li>\n<li><p>反射攻击：在Constructor、Method、Field类，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限<code>public void setAccessible(boolean flag)</code>，利用这个方法，可以将私有的构造函数、方法、成员变量设置为可以访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量（打破单例类只能实例化一个对象的限制的情况）</p>\n</li>\n</ul>\n</li>\n<li><p>注解：注解相当于给元素打了一个tag，任何编译器或者应用程序通过反射可以访问的代码元素，都可以用注解去标识</p>\n<ul>\n<li><p>自定义注解：通过反射来读取注解，重要应用为Spring用注解代替XML配置文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Java内建注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override &#123;\n&#125;\n\n&#x2F;&#x2F;自定义注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimit &#123;\n\tpublic enum TimeUnit &#123; SECOND,MINUTE, HOUR, DAY,MONTH&#125;\n    string apiName();\n\tint limitCount();\n\tTimeUnit timeUnit() default TimeUnit.SECOND;\n&#125;</code></pre></li>\n<li><p>元注解</p>\n<ul>\n<li>@Target：用来描述注解的使用范围（如类、接口、方法、成员变量等）</li>\n<li>@Retention：用来描述注解的可见范围、或叫生命周期（如源码可见、字节码可见、<strong>运行时可见</strong>）</li>\n<li>@Documented：表示注解信息会输出到Javadoc文档中</li>\n<li>@interface：class、interface、enum、@interface这四者是平级关系，<code>@interface</code>用来定义注解，在注解中，还可以定义一些变量，特殊的是注解使用方法来定义变量，对于只有一个变量的注解，可以将其定义为value，这样，在使用时，可以不指定变量的名称</li>\n</ul>\n</li>\n<li><p>实践应用</p>\n<ul>\n<li>替代注释：Guava提供<code>@VisibleForTesting</code>注解在方法上进行标记，这个注解只起到注释的作用，并没有实际的作用</li>\n<li>作为标记：Java中有一种特殊的接口，叫做标记接口（<code>Marker Interface</code>）。标记接口中不包含任何方法，跟注解类似，起到标记作用，比如RandomAccess、Cloneable、Serializable，可以根据标记接口判断对象是否可以执行某些操作</li>\n<li>替代XML文件<ul>\n<li><code>@Configuration</code>注解修饰的类中的<code>@Bean</code>创建首字母小写的对象</li>\n<li><code>@Component</code>注解创建同名对象，使用<code>@Autowired</code>注入对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>动态代理</p>\n<ul>\n<li>静态代理：通过实现接口或继承的方式，通过注入原始类并添加新功能的方式实现。实现简单，但会导致项目中的类成倍增加，所有相关的类都需要增加代理类，重复代码多</li>\n<li>动态代理<ul>\n<li>一般静态指的编译阶段，动态指的运行阶段。在代理模式上，静态代理指的是在编译阶段时生成代理类的字节码，动态代理指的是运行时生成代理类的字节码，且字节码只存在与内存中，并不会生成对应的class文件</li>\n<li>之所以可以实现动态代理，是因为JVM设计得非常灵活，只要是符合类的格式的字节码，都可以在运行时被JVM解析并加载，不管这个字节码是来自预先编译好的(class文件)，还是在内存中临时生成的(典型应用:动态代理)，又或者从网络加载而来的(典型应用: Applet)。这部分内容涉及到JVM的类加载机制，见JVM<ul>\n<li><p>实现方法一：利用JDK提供的类来实现（InvocationHandler接口+Proxy类）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;为UserController类实现动态代理，当为其它Controller类中的方法也添加时间统计代码时，\n&#x2F;&#x2F;可以复用CtrlProxyHandler类，并通过Proxy类的newProxyInstance()静态方法生成对应的代理类对象\npublic class CtrlProxyHandler implements InvocationHandler &#123;\n    private Object origBean;\n\n    public CtrlProxyHandler(Object origBean) &#123;\n        this.origBean &#x3D; origBean;\n    &#125;\n    @override\n    public Object invoke(Object proxy， Method method, Object[] args) throws Throwable &#123;\n        long startTime &#x3D; system.currentTimeMillis();\n        \n\t\t\t\t&#x2F;&#x2F;所有方法的调用都会变成调用invoke方法，参数为生成的代理类、要调用的方法、对应的参数\n\t\t\t\t&#x2F;&#x2F;通过Proxy类的newProxyInstance()创建的代理对象在调用方法的时候，实际会调用到实现InvocationHandler接口的类的\n\t\t\t\t&#x2F;&#x2F;invoke()方法，可以在invoke()方法中自定义处理逻辑，比如在方法执行前后做什么事情\n        Object res &#x3D; method.invoke(origBean, args);\n        \n        long costTime &#x3D; System.currentTimeMillis() - startTime;\n        System.out.printIn(origBean.getClass().getSimpleName()+&quot;#&quot;+ method.getName() + &quot; cost time: &quot; + costTime);\n        return res;\n    &#125;\n&#125;\n\npublic class JDKProxyDemo &#123;\n    public static void main(String] args) &#123;\n        UserController userController &#x3D; new UserController();\n        CtrlProxyHandler handler &#x3D; new CtrlProxyHandler(userController);\n        &#x2F;&#x2F;用Proxy的静态方法生成代理类\n        IUserController userControllerProxy &#x3D; (IUserController)Proxy.newProxyInstance\n            (handler.getClass().getClassLoader(), UserController.class.getInterfaces(), handler);\n        userControllerProxy.login(&quot;139********&quot;，&quot;*********&quot;);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p><strong>newProxyInstance函数：</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static Object newProxyInstance(\n    ClassLoader loader, Class&lt;?&gt;[]interfaces,InvocationHandler h)&#123;\n\t\t&#x2F;&#x2F;参数为：被代理的类的类加载器（上面的代码都是同一个类加载器AppClassLoader，但是如果定义了别的类加载器就需要注意）、\n\t\t&#x2F;&#x2F;被代理的类实现的所有接口、动态代理处理器（实现InvocationHandler接口，重写invoke方法）\n    \n    &#x2F;&#x2F;1)生成动态代理类\n    &#x2F;&#x2F;2)加载动态代理类\n\t\t&#x2F;&#x2F;动态代理类具有哪些方法：只跟接口有关，跟原始类没有任何关系，这也是基于JDK实现的动态代理要求原始类必须有接口定义才行\n    Class&lt;?&gt; cl&#x3D; getProxyClass0(loader, intfs);\n\n    &#x2F;&#x2F;3)实例化动态代理类对象\n    final Class&lt;?&gt;[] constructorParams &#x3D; &#123; InvocationHandler.class &#125;;\n    final Constructor&lt;?&gt; cons &#x3D; cl.getConstructor(constructorParams);\n    return cons.newlnstance(new Object]&#123;h);\n&#125;d f</code></pre>\n\n<ul>\n<li><code>ClassLoader loader</code>loader表示类加载器，用于加载动态代理类到JVM</li>\n<li><code>Class&lt;?&gt;[] interfaces</code>用于生成动态代理类，接口中的方法就是动态代理类包含的方法</li>\n<li><code>InvocationHandler h</code>用于创建（实例化）动态代理类对象</li>\n</ul>\n</li>\n<li><p>ProxyGenerator类：newProxyInstance()函数调用ProxyGenerator类(JDK提供的生成字节码的类)，按照类的字节码格式，生成动态代理类的字节码，并存储到内存（proxyClassFile）中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;生成动态代理类的名称\nfinal String proxyClassNamePrefix &#x3D; &quot;$Proxy&quot;;\nlong num &#x3D; nextUniqueNumber.getAndIncrement();\nString proxyName &#x3D; proxyPkg + proxyClassNamePrefix + num;\n\n&#x2F;&#x2F;ProxyGenerator类似字节码类库，可以生成动态代理类的字节码\nbyte[] proxyClassFile &#x3D; ProxyGenerator.generateProxyClass(\n    proxyName, interfaces, accessFlags);\ntry &#123;\n    &#x2F;&#x2F;通过JVM的类加载器来加载动态代理类\n    return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);\n&#125; \ncatch(ClassFormatError e) &#123; &#x2F;&#x2F;如果生成的动态代理类的字节码格式有误，则报错\n    throw new lllegalArgumentException(e.toString());\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>实现方法二：使用第三方的字节码类库来实现，比如CGLIB、BECL、ASM、Javassit等直接编辑字节码</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-工具类\"><a href=\"#2-工具类\" class=\"headerlink\" title=\"2.工具类\"></a>2.工具类</h3><ol>\n<li>String<ol>\n<li>String不可变的原因<ul>\n<li>final修饰的数组，数组内容是可变的<code>private final char value[];</code></li>\n<li>但是String没有暴露更改该数组的公共方法</li>\n<li>因为String类是final修饰的，所以子类无法继承，避免了子类破坏String的不可变性</li>\n</ul>\n</li>\n<li>常量池技术<ul>\n<li>String类型跟Integer等包装类类似，使用常量池技术，并且==只有使用字符串常量赋值时，才触发==，如果字符串常量在常量池中已经创建过，则直接使用已经创建的对象。用new创建的对象不在常量池中</li>\n<li>除了使用字符串常量赋值外，还可以使用intern()方法，将分配在堆上的String对象，原模原样在常量池中复制一份。当无法用字符串常量赋值，但又有大量重复字符串时，就可以使用intern()方法复制到常量池中，代码中使用常量池中的String对象，原String对象就被JVM回收掉</li>\n</ul>\n</li>\n<li>其它<ul>\n<li><code>substring()</code><ul>\n<li><code>substring(int beginIndex, int endIndex)</code>方法截取并返回下标在[beginIndex, endIndex)范围内的子串</li>\n<li>在JDK7及其以上版本中，substring()方法会生成新的String对象来存储子串，但如果传入参数正好等于字符串的长度，那么会返回字符串本身，不会创建新对象</li>\n<li>在JDK6及以前的版本，通过substring()方法获取到的子串会共享char数组，并有count和offset属性标志子串的长度和起点</li>\n</ul>\n</li>\n<li>运算符重载：C++能直接重载运算符，但Java并不支持（重载运算符是函数式编程、并且语法太复杂），但是String类却实现了加法操作String sc = sa + sb;，主要是因为String比较常用，所以延续了基本类型及其包装类的设计，这样使用起来就方便和统一</li>\n<li>StringBuilder与StringBuffer<ul>\n<li>因为String不可变，用+拼接效率低，每次都需要创建新的String对象，所以Java设计了StringBuilder</li>\n<li>StringBuilder支持修改和动态扩容，可以用append()函数拼接，可以把StringBuilder看作是char类型的ArrayList（ArrayList<Character>）</li>\n<li>在平时开发中，经常用+号连接多个字符串，实际上底层就采用StringBuilder来实现</li>\n<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code>并没有对方法进行加同步锁，所以是非线程安全的。</li>\n<li>相同情况下使用 <code>StringBuilder</code>相比使用 <code>StringBuffer</code>仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n<li></li>\n</ol>\n<h3 id=\"3-JCF框架\"><a href=\"#3-JCF框架\" class=\"headerlink\" title=\"3.JCF框架\"></a>3.JCF框架</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/JCF.png\" alt=\"JCF\"></p>\n<ol>\n<li><p>ArrayList动态扩容：在增加元素的时候要检测是否需要扩容，首先确定最小扩容量（最小是10），然后判断是否需要扩容（最小扩容量大于当前数组长度），执行grow函数进行扩容，扩容为原来的1.5倍，如果不够的话就直接使用最小扩容量来作为长度，避免多次扩容，若是1.5倍长度大于数组最大长度，则需要看最小扩容量是否大于最大容量，如果是则为MAX_VALUE否则为MAX_VALUE-8</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean add(E e) &#123;\n    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!\n    elementData[size++] &#x3D; e;\n    return true;\n&#125;\n\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;确定是否需要扩容，主要用在添加大量元素之前，减少增量分配的次数，通过提前扩容，可以提升性能&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic void ensureCapacity(int minCapacity) &#123;\n    int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n        &#x2F;&#x2F; any size if not default element table\n        ? 0\n        &#x2F;&#x2F; larger than default for default empty table. It&#39;s already\n        &#x2F;&#x2F; supposed to be at default size.\n        : DEFAULT_CAPACITY;\n\t\t&#x2F;&#x2F;如果期待最小容量大于已有的最大容量\n    if (minCapacity &gt; minExpand) &#123;\n        ensureExplicitCapacity(minCapacity);\n    &#125;\n&#125;\n&#x2F;&#x2F;得到最小扩容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) &#123;\n    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    &#125;\n    return minCapacity;\n&#125;\n&#x2F;&#x2F;得到最小扩容量，通过最小扩容量扩容\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n&#x2F;&#x2F;判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) &#123;\n    modCount++;\n\n    &#x2F;&#x2F; overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n\t\t\t\t&#x2F;&#x2F;调用grow方法进行扩容，调用此方法代表已经开始扩容了\n        grow(minCapacity);\n&#125;\nprivate void grow(int minCapacity) &#123;\n    &#x2F;&#x2F;oldCapacity为旧容量，newCapacity为新容量\n    int oldCapacity &#x3D; elementData.length;\n    &#x2F;&#x2F;将oldCapacity 右移一位，其效果相当于oldCapacity &#x2F;2，\n    &#x2F;&#x2F;我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);\n    &#x2F;&#x2F;然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity &#x3D; minCapacity;\n    &#x2F;&#x2F;再检查新容量是否超出了ArrayList所定义的最大容量，\n    &#x2F;&#x2F;若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n    &#x2F;&#x2F;如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为MAX_ARRAY_SIZE。\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity &#x3D; hugeCapacity(minCapacity);\n    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:\n    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n&#125;\n&#x2F;&#x2F;比较minCapacity和MAX_ARRAY_SIZE\nprivate static int hugeCapacity(int minCapacity) &#123;\n    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n&#125;</code></pre></li>\n<li><p>HashMap</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/LinkedHashMap.png\" alt=\"LinkedHashMap\"></p>\n<ul>\n<li><p>Set容器包括HashSet、LinkedHashSet、TreeSet，从代码实现上来说，这三个类底层分别是依赖HashMap、LinkedHashMap、TreeMap。例如：往HashSet中存储对象obj，底层将obj作为key，一个空的Object对象作为value，一并存储到HashMap中</p>\n</li>\n<li><p>底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 包含另一个“Map”的构造函数\n public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);&#x2F;&#x2F;下面会分析到这个方法\n &#125;\nfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;\n    int s &#x3D; m.size();\n    if (s &gt; 0) &#123;\n        &#x2F;&#x2F; 判断table是否已经初始化\n        if (table &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-size\n            &#x2F;&#x2F; 未初始化，s为m的实际元素个数\n            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;\n            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            &#x2F;&#x2F; 计算得到的t大于阈值，则初始化阈值\n            if (t &gt; threshold)\n                threshold &#x3D; tableSizeFor(t);\n        &#125;\n        &#x2F;&#x2F; 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s &gt; threshold)\n            resize();\n        &#x2F;&#x2F; 将m中的所有元素添加至HashMap中\n        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;\n            K key &#x3D; e.getKey();\n            V value &#x3D; e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>哈希函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final int hash(Object key) &#123;\n    int h;\n\t\t&#x2F;&#x2F;key为null的值存储在下标为0的位置，但一个HashMap只能存储一个值为null的key\n\t\t&#x2F;&#x2F;hashCode底层为JNI，定义在Object类中，根据对象在内存中的地址来计算哈希值，子类中可以重写\n\t\t&#x2F;&#x2F;h^(h&gt;&gt;&gt;16)：数组长度一般不超过2^16，所以通过将h的高16位和低16位异或，来增加参与运算的信息\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n&#x2F;&#x2F;确定插入数组时的位置，使用位操作与数组长度n进行取模计算（前提是n为2的幂次方），防止索引越界\nint index &#x3D; hash(key)&amp;(n-1); &#x2F;&#x2F; n-1为 11111，与其进行&amp;运算，相当于对n取余数\n\npublic V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;&#x2F;&#x2F; hash表不为空，待查找链表有值\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node，先查hash(key)，再查key.equals()\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;检测是否哈希冲突\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            if (first instanceof TreeNode) &#x2F;&#x2F;已经树化，进行树上的查找\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);&#x2F;&#x2F;未树化，进行链表上的遍历查找\n        &#125;\n    &#125;\n    return null;\n&#125;</code></pre></li>\n<li><p>装载因子：table大小（n）和装载因子（loadFactor）可以用默认的也可以通过构造函数传入，一般为0.75：</p>\n<ul>\n<li>权衡时间效率和空间效率之后的结果</li>\n<li>大概是[0.5,1]之间，因为小于0.5会有一半空间从来未用，当大于1时，哈希冲突的概率会大大增加，即使有链表和树化，也会影响性能</li>\n<li>因为table数组的大小n都是2的倍数，而且触发扩容的阈值threshold = n * loadfactor，所以，在[0.5,1]之间，只有0.75能使得得到的阈值一直是整数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public HashMap(int initialCapacity, float loadFactor) &#123;\n\t\t&#x2F;&#x2F;...initialCapacity和loadFactor的可行性检验代码...\n    this.loadFactor &#x3D; loadFactor;\n\t\t&#x2F;&#x2F;直接赋值的原因：此时table数组只声明未创建，其值为null，在第一次调用put()函数后，\n\t\t&#x2F;&#x2F;HashMap会先用threshold作为数组大小创建table数组，再将其重新赋值为真正的扩容阈值\n\t\t&#x2F;&#x2F;this.table &#x3D; new T[this.threshold];\n\t\t&#x2F;&#x2F;this.threshold *&#x3D; this.factor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);\n&#125;\n&#x2F;&#x2F;initialCapacity需要是2的幂次方，如果不是，需要寻找比initialCapacity大的第一个2的幂次方数\nstatic final int tableSizeFor(int cap) &#123; &#x2F;&#x2F; 1100  12 应该返回 10000\n    int n &#x3D; cap - 1; &#x2F;&#x2F; 1011\n    n |&#x3D; n &gt;&gt;&gt; 1; &#x2F;&#x2F; 0101 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 2; &#x2F;&#x2F; 0011 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 4; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 8; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 16; &#x2F;&#x2F; 0000 - 1111\n    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#x2F;&#x2F; 10000 16\n&#125;</code></pre></li>\n<li><p>动态扩容：put后，若元素个数超过<code>threshold=n*loadFactor</code>时触发（n为table大小，loadFactor为装载因子）</p>\n<ul>\n<li>HashMap的默认初始化大小为16，之后每次扩充容量为原来的2倍，如果指定了大小，也会选择2的幂次来作为初始值<ul>\n<li>因为Hashmap的容量大小是2的幂次方，所以可以通过&amp;运算来优化%运算。例如：（16 % 5 ）等价于 （16 &amp; （5 - 1））</li>\n<li>为了能把数据分配均匀，Hash值的范围是-2147483648 到 2147483647，很难碰撞，但是需要对数组取模，操作如上</li>\n</ul>\n</li>\n<li>因为容量变大，位置会发生变化，将每个节点的hash值与新的容量取模，取模操作仍可以用位运算来替代，但JDK8中优化为：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）</li>\n<li>扫描table数组中的每一条链表，根据节点的下标是否更改，将链表中的节点分配到lo链表和hi链表，lo链表中存储的是下标值未变的节点，hi链表存储的是下标值有所改变的节点。处理完一条链表后，将lo链表和hi链表分别存储到新的table数组中的对应位置</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;使用resize创建新table\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)&#x2F;&#x2F;数组中链表头不存在，初始化\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123;&#x2F;&#x2F;数组中插入位置有链表头，遍历\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;先检查第一个节点\n            e &#x3D; p;&#x2F;&#x2F;找到\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;遍历链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;没找到，新建节点\n                    p.next &#x3D; newNode(hash, key, value, null);\n\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F;树化？红黑树转换，并不会直接转换成红黑树\n                    break;\n                &#125;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#x2F;&#x2F;找到\n                    break;\n                p &#x3D; e;&#x2F;&#x2F;继续遍历\n            &#125;\n        &#125;\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;&#x2F;&#x2F;更新值\n            afterNodeAccess(e);&#x2F;&#x2F;见LinkedHashMap\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);&#x2F;&#x2F;见LinkedHashMap\n    return null;\n&#125;\n\nfinal Node&lt;K,V&gt;[] resize() &#123;\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    int newCap, newThr &#x3D; 0;\n    if (oldCap &gt; 0) &#123;\n        &#x2F;&#x2F; 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 没超过最大值，就扩充为原来的2倍\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold\n        newCap &#x3D; oldThr;\n    else &#123;\n        &#x2F;&#x2F; signifies using defaults\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    &#x2F;&#x2F; 计算新的resize上限\n    if (newThr &#x3D;&#x3D; 0) &#123;\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)\n        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab;\n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 把每个bucket都移动到新的buckets中\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                oldTab[j] &#x3D; null;\n                if (e.next &#x3D;&#x3D; null)\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123;\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        &#x2F;&#x2F; 原索引\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        &#x2F;&#x2F; 原索引+oldCap\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    &#x2F;&#x2F; 原索引放到bucket里\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    &#x2F;&#x2F; 原索引+oldCap放到bucket里\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;</code></pre></li>\n<li><p>链表树化：降低单个链表长度（jdk1.8新增的特性，1.7仅有链表）</p>\n<ul>\n<li><p>当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的大小大于等于64时，将会把链表转化为红黑树，这个过程就叫treeify（树化）</p>\n</li>\n<li><p>如果table数组长度小于64，即便链表中的节点个数大于等于8，也不会触发treeify，而是触发扩容操作，将长链表拆分为短链表</p>\n</li>\n<li><p>当红黑树中节点个数比较少时，HashMap会再将其转换回链表，因为维护红黑树的成本比较高，对于少许节点，使用链表存储更高效，红黑树转换为链表的过程，叫做untreeify，促发untreeify的场景有以下两个：</p>\n<ul>\n<li><p>删除键值对：如果红黑树满足以下结构，则会触发untreeify，这个结构的红黑树的节点个数应该处于[2,6]之间，尽管treeify的阈值是8，但untreeify的阈值是[2,6]之间的某个数，之所以不相等是为了避免频繁的插入删除操作，导致节点个数在7，8之间频繁波动</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;removeTreeNode函数中\nif (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||\n    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;\n    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small\n    return;\n&#125;</code></pre></li>\n<li><p>扩容：每一条链表都会分割为lo和hi两条，同理红黑树也会分割为lt和ht两个红黑树，lt中存储的是下标位置不变的节点，ht中存储的是下标位置变化的节点。不过，在构建lt和ht之前，会先统计属于lt和ht的节点个数lc和hc，如果lc小于等于6（UNTREEIFY_THRESHOLD静态常量），在新的table数组中，HashMap会使用链表来存储下标不变的节点，同理，如果hc小于等于6，在新的table数组中，HashMap会使用链表来存储下标改变的节点。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>红黑树是一种自平衡的二叉查找树，可以保证在最坏情况下基本动态操作的时间复杂度为O(log n)。红黑树中的每个节点都有一个颜色属性，可以是红色或黑色。红黑树满足以下5个性质。通过这些性质，红黑树可以保证在插入和删除节点时，自动调整树的结构，以保持树的平衡和性质的满足。相比于普通的二叉查找树，红黑树的平衡性更好，查找、插入和删除都具有更稳定的时间复杂度，因此在很多场景下被广泛应用。</p>\n<ul>\n<li>每个节点要么是红色，要么是黑色。</li>\n<li>根节点是黑色的。</li>\n<li>每个叶子节点（NIL节点，空节点）是黑色的。</li>\n<li>如果一个节点是红色的，则它的两个子节点都是黑色的。</li>\n<li>对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Collections</p>\n<ul>\n<li>sort()：用来对List进行排序，默认为从小到大，支持传入Comparator接口的匿名类改为降序，底层依赖Arrays<ul>\n<li>基本类型数组排序算法：JDK8及以后使用DualPivotQuickSort()，JDK7及其以前使用快排，使用不稳定排序<ul>\n<li>DualPivotQuickSort根据长度和元素类型，使用双轴快速排序算法、插入排序、计数排序、归并排序等算法来组合进行排序操作</li>\n</ul>\n</li>\n<li>对象数组排序算法：JDK8及其以后使用TimSort()，JDK7及其以前使用归并排序，使用的是稳定的排序方式<ul>\n<li>TimSort用非递归版本归并排序，归并到阈值后开始进行二分插入排序算法，即在插入时选择用二分查找来确定插入位置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>binarySearch()：用来对已排序的List容器进行二分查找，因为涉及元素比较，所以需要传入实现Comparable接口的对象或者主动传入Comparator接口的匿名类对象<ul>\n<li><code>indexedBinarySearch</code>：查找mid使用的是链表的get函数，需要从头遍历链表来得到对应值</li>\n<li><code>iteratorBinarySearch</code>：查找mid使用的是新定义的get函数，从上一次迭代器的位置（mid）开始向前或向后查找，需要遍历的范围变小了，执行效率就变高了</li>\n</ul>\n</li>\n<li>synchronizedXXX()：JCF中的容器都是非线程安全的，当要使用线程安全的容器时，首选使用JUC并发容器，但当没有合适的JUC并发容器可以使用时，可以使用Collectinos类中的synchronizedXXX()函数来创建线程安全的容器</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-IO类库\"><a href=\"#4-IO类库\" class=\"headerlink\" title=\"4.IO类库\"></a>4.IO类库</h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731153224597.png\" alt=\"image-20230731153224597\"></p>\n<ol>\n<li><p>IO类库（装饰器模式、适配器模式、工厂模式、观察者模式）</p>\n<ul>\n<li><p>明确要操作的数据是数据源还是数据目的（要读还是要写）+要操作的数据是字节还是字符（字符流比字节流多了一个字符编码转换的环节）</p>\n<ul>\n<li><p>输入（读）：InputStream （字节）、Reader（字符）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731153242182.png\" alt=\"image-20230731153242182\"></p>\n</li>\n<li><p>输出（写）：OutputStream（字节）、Writer（字符）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731153302014.png\" alt=\"image-20230731153302014\"></p>\n</li>\n<li><p>装饰器模式：实现相同接口，使用组合调用被装饰方法，并在前后增加上新的装饰方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n  void f();\n&#125;\npublic class A implements IA &#123;\n  public void f() &#123; &#x2F;&#x2F;... &#125;\n&#125;\npublic class ADecorator implements IA &#123;\n  private IA a;\n  public ADecorator(IA a) &#123;\n    this.a &#x3D; a;\n  &#125;\n  \n  public void f() &#123;\n    &#x2F;&#x2F; 功能增强代码\n    a.f();\n    &#x2F;&#x2F; 功能增强代码\n  &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;装饰器类是对原始类的增强，不能独立使用，使用方式如下&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nInputStream in &#x3D; new FileInputStream(&quot;...&quot;);\nInoutStream bin &#x3D; new BufferedInputStream(in);\nbyte[] data &#x3D; new byte[1024];\nwhile(bin.read(data) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;处理data数组\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>明确数据存在的具体设备</p>\n<ul>\n<li><p>硬盘（文件）：Filexxx（4）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">InputStream fis &#x3D; new FileInputStream(&quot;input.txt&quot;)\nwhile ((content &#x3D; fis.read()) !&#x3D; -1) &#123;\n    System.out.print((char) content);\n&#125;\n\nFileOutputStream output &#x3D; new FileOutputStream(&quot;output.txt&quot;)\nbyte[] array &#x3D; &quot;JavaGuide&quot;.getBytes();\noutput.write(array);</code></pre></li>\n<li><p>管道：Pipedxxx（4）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Java中的管道是同一个进程内的两个线程之间通信的工具&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nPipedOutputStream out &#x3D; new PipedOutputStream();\ntry &#123;\n    PipedInputStream in &#x3D; new PipedInputStream(out);\n    new Thread(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            try &#123;\n                out.write(&quot;Hi Dajunnnnnn&quot;.getBytes());\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;).start();\n    new Thread(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            byte[] buffer &#x3D; new byte[512];\n            try &#123;\n                in.read(buffer);\n                System.out.println(new String(buffer));\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;).start();\n&#125; catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;</code></pre></li>\n<li><p>内存：CharArrayxxx（字符）、Stringxxx（字符）、ByteArrayxxx（字节）</p>\n<ul>\n<li><p>在大部分情况下，直接对byte数组，char数组进行读写即可，不需要这种内存读写类</p>\n</li>\n<li><p>情境一：实现兼容，调用第三方类库中的某个函数来处理byte数组中的数据时，但这个函数的入参是InputStream类型的，那么就需要将待处理byte数组封装成ByteArrayInputStream对象，在传递给这个函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">byte[] source &#x3D; &quot;测试数据&quot;.getBytes();\nInputStream in &#x3D; new ByteArrayInputStream(source);\n&#x2F;&#x2F;用in代替source继续处理</code></pre></li>\n<li><p>情景二：编写单元测试时，这些内存读写类可以替代文件或网路，将测试数据内置于内存，准备起来更加容易</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;待测试函数\npublic int readFromFIle(InputStream inputStream)&#123;...&#125;\n\n&#x2F;&#x2F;测试代码\npublic void test_readFromFile()&#123;\n    byte[] testData &#x3D; new byte[512];\n    &#x2F;&#x2F;构建测试数据，填入testData数组\n    InputStream in &#x3D; new ByteInputStream(testData);\n    int res &#x3D; readFromFile(in);\n    &#x2F;&#x2F;assert 判断返回值是否符合预期\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>键盘/屏幕：<a href=\"http://system.in/\">System.in</a>、System.out、System.err（使用内部的<code>PrintStream</code>和<code>InputStream</code>）</p>\n<ul>\n<li>定义在System类中的静态InputStream对象</li>\n<li>定义在System类中的静态PrintStream，需要嵌套OutputStream来使用</li>\n</ul>\n</li>\n<li><p>网络：Socket</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;java.io类库并没有提供专门的类用于网络I&#x2F;O的读写，而是直接复用InputStream&#x2F;OutputStream类进行网络I&#x2F;O的读写\nSocket socket &#x3D; new Socket(&quot;127.29.2.4&quot;,8090);\nOutputStream out &#x3D; socket.getOutputStream();\nout.write(&quot;hi&quot;.getBytes());\n\nInputStream in &#x3D; socket.getInputStream();\nbyte[] data &#x3D; new byte[1024];\nwhile(in.read(data) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;do something\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>明确是否需要额外的功能</p>\n<ul>\n<li><p>需要高效（缓冲流，用来包装别的类）：Bufferedxxx（4），在内存中维护一个8192字节的缓存区</p>\n<ul>\n<li>BufferedInputStream会在内存中维护一个8192字节大小的缓存，如果缓存中没有足够的数据，那么read()函数会从I/O设备中读取8192个字节存储到缓存中，然后read()函数再从缓存中返回需要的数据量。如果缓存中有足够多的数据，read()函数直接从缓存中读取数据，而不会触发真正I/O操作，可以减少I/O操作的次数，但是如果每次请求的数据量大于等于8192字节，那么BufferedInputStream就不起作用了</li>\n<li>同理OutputStream用于缓存写入I/O设备中的数据，当积攒到一定量（默认为8192字节），再一次性将其写入I/O设备，减少I/O操作的次数，提高程序的性能</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 新建一个 BufferedInputStream 对象，需要传入一个原始类对象，通过装饰器设计模式来增加功能\nBufferedInputStream bufferedInputStream &#x3D; new BufferedInputStream(new FileInputStream(&quot;input.txt&quot;));\n&#x2F;&#x2F; 读取文件的内容并复制到 String 对象中\nString result &#x3D; new String(bufferedInputStream.readAllBytes());\nSystem.out.println(result);</code></pre></li>\n<li><p>支持基本类型数据读写：DataInputStream、DataOutStream</p>\n<ul>\n<li>DataInputStream支持将输入流中读取的数据解析为基本类型（byte、char、short、int、float、double等），DataOutputStream类支持将基本类型数据转化为字节数组写入输出流</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DataOutputStream out &#x3D; new DataOutputStream(new FileOutputStream(&quot;...&quot;));\nout.writeInt(12);\nout.writeChar(&quot;a&quot;);\nout.writeFloat(12,12f);\nout.close();\n\nDataIntputStream in &#x3D; new DataInputStream(new FileInputStream(&quot;...&quot;));\nSystem.out.println(in.readInt());\n&#x2F;&#x2F;readChar()、writeChar()也可以按字符为单位读取、写入数据，但是，DataInputStream一次只能处理一个字符，\n&#x2F;&#x2F;而字符流可以处理char数组，并且字符流提供的函数更多，功能更丰富\nSystem.out.println(in.readChar());\nSystem.out.println(in.readFloat());\nin.close();</code></pre></li>\n<li><p>支持对象读写：ObjectInputStream、ObjectOutputStream</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;ObjectOutputStream支持将对象序列化之后写入到输出流\nObjectOutputStream out &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;.&quot;));\nout.writeObject(new Person(12,&quot;Dajunnnnnn&quot;));\n&#x2F;&#x2F;ObjectInputStream支持将从输入流中读取到的数据反序列化为对象\nObjectInputStream in &#x3D; new ObjectInputStream(new FileInputStream(&quot;.&quot;));\nPerson p &#x3D; (Person) in.readObject();</code></pre></li>\n<li><p>保证数据的输出形式（打印流）：PrintStream、PrintWriter</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;PrintStream和PrintWrite可以将数据按照一定的格式，转化为字符串，写入到输出流\nPrintStream printStream &#x3D; new PrintStream(new FileOutputStream(&quot;..&quot;));\nprintStream.print(124);&#x2F;&#x2F;int-&gt;Integer-&gt;toString(),写入字符串“124”\nprintStream.print(&quot;hello %d&quot;,43);&#x2F;&#x2F;写入字符串“hello 43”</code></pre></li>\n<li><p>需要转换（字符流通向字符的桥梁）：InputStreamReader、OutputStreamWriter</p>\n<ul>\n<li>InputStreamReader可以充当InputStream的装饰器类，OutputStreamWriter可以充当OutputStream的装饰器类，它们可以将字节流转化为字符流</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">OutputStream outStream &#x3D; new FileOutputStream(&quot;&#x2F;Users&#x2F;wangzheng&#x2F;a.txt&quot;);\nOutputStreamWriter writer &#x3D; new OutputStreamWriter(outStream, &quot;gbk&quot;);\nwriter.write(&quot;王a争&quot;); &#x2F;&#x2F;按照gbk编码将字符串写入文件</code></pre></li>\n<li><p>回退（允许读取字节，然后再将它们回推到流中）：PushbackInputStream、PushbackReader</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s &#x3D; &quot;abcdefg&quot;;\ntry (ByteArrayInputStream in &#x3D; new ByteArrayInputStream(s.getBytes());\n\t\t\t\tPushbackInputStream pbin &#x3D; new PushbackInputStream(in)) &#123;\n    int n;\n    while ((n &#x3D; pbin.read()) !&#x3D; -1) &#123;\n        System.out.print((char) n);\n        if(&#39;b&#39; &#x3D;&#x3D; n) pbin.unread(&#39;U&#39;);\n    &#125;&#x2F;&#x2F;输出 abUcdefg\n&#125;</code></pre></li>\n<li><p>多个源（序列流）：SequenceInputStream</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>NIO类库（JDK1.4引入，也称：New I/O、Non-blocking I/O、Network I/O，主要用于网络编程）</p>\n<ul>\n<li><p>核心概念：java.nio中引入Channel代替Stream，并且引入新的概念：Buffer，用来存储待写入或读取的数据</p>\n<ul>\n<li><p>Buffer：在IO库中，通常使用byte数组来接收数据，分为字节流解析和字符流解析。在nio中， 将将这些部分抽离出来，封装到Buffer中，通过不同的Channel和不同的Buffer组合在一起，实现不同的IO读写需求（常见的Buffer有：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer、MappedByteBuffer）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">FileChannel channel &#x3D; FileChannel.open(Paths.get(&quot;...&quot;));\nByteBuffer buffer &#x3D; ByteBuffer.allocate(512);\nwhile(channel.read(buffer) !&#x3D; -1)&#123;\n    &#x2F;&#x2F;处理buffer中的数据data\n&#125;</code></pre></li>\n<li><p>Channel：同步（<code>FileChannel</code>、<code>DatagramChannel</code>、<code>SocketChannel</code>、<code>ServerSocketChannel</code>），异步（<code>AdynchronousFileChannel</code>、<code>AsynchronousSocketChannel</code>、<code>AsynchronousServerSocketChannel</code>）</p>\n<ul>\n<li>同步<ul>\n<li>常用的同步的Channel有：<code>FileChannel</code>（文件）、<code>DatagramChannel</code>（UDP）、<code>SocketChannel</code>（TCP）、<code>ServerSocketChannel</code>（TCP，服务器，即可以使用accept()函数监听客户端SocketChannel的连接请求）</li>\n<li>Channel既可以读也可以写，每个Channel类通过实现不同的接口组合，来支持不同的功能组合</li>\n<li>Channel有两种运行方式：阻塞（等待数据读写）和非阻塞（不等待数据读写）方式，其中除FileChannel只支持阻塞模式外，其余三个都同时支持两种方式，默认为阻塞方式，可以调用configureBlocking(false)函数将其设置为非阻塞模式，非阻塞Channel一般会配合Selector，用于实现多路复用I/O模型</li>\n</ul>\n</li>\n<li>异步<ul>\n<li>jdk7在已有Selector的情况下，进行了升级，引入了支持异步模式的Channel，主要包括：<code>AdynchronousFileChannel</code>、<code>AsynchronousSocketChannel</code>、<code>AsynchronousServerSocketChannel</code></li>\n<li>在异步模式下，Channel不再注册到Selector，而是注册到操作系统内核中，由内核来通知某个Channel可读、可写或可连接，java.nio收到通知之后，为了不阻塞主线程，会使用线程池去执行事先注册的回调函数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Selector：注册Channel到Selector，Selector隔一段时间轮询是否有Channel可读、可写、可连接</p>\n<ul>\n<li>多路复用I/O：用来解决while轮询的问题。为了实现多路复用，Unix提供了epoll库、Windows提供了iocp库、BSD提供了kequeue库，Java作为一种跨平台语言，对不同操作系统的实现进行了封装，提供了统一的Selector，可以将需要监听的Channel，调用registor()函数，注册到Selector中，Selector底层会通过轮询的方式，查看哪些Channel可读、可写、可连接等，并将其返回处理（避免手写轮询代码）</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SeverSocketChannel serverChannel &#x3D; ServerSocketChannel.open();\nserverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;,1192));\nserverChannel.configureBlocking(false);\nByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n\nSocketChannel clinetChannel &#x3D; null;\n&#x2F;&#x2F;在网络编程中，使用非阻塞模式，线程需要通过while循环，不停轮询调用read()、write()、accept()函数，\n&#x2F;&#x2F;查看是否有数据可读，是否可写，是否有客户端连接到来\nwhile(clinetChannel &#x3D;&#x3D; null)&#123;\n    clientChannel &#x3D; serverChannel.accept();\n&#125;\n\nwhile(clientChannel.read(buffer) &#x3D;&#x3D; -1);\n\nbuffer.flip();&#x2F;&#x2F;将buffer从用于读变成用于写\nwhile(buffer.hasRemaining())&#123;\n    clientChannel.write(buffer);&#x2F;&#x2F;echo,读了啥就写啥\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>Java IO模型：堆Unix5种I/O模型：阻塞I/O模型、非阻塞I/O模型、多路复用I/O模型、信号驱动I/O模型、异步I/O模型的封装</p>\n<ul>\n<li><p>阻塞I/O模型（BIO）：阻塞IO+线程，多线程+read阻塞等待</p>\n<ul>\n<li>利用阻塞模式搭配多线程来实现服务器，因为read()是阻塞函数，所以需要提前创建线程池和大量线程，来等待客户端发来的连接。如果有n个客户端连接服务器，那么服务器需要创建n+1个线程，其中n个线程用于调用read()函数，1个线程用来调用accept()函数接收连接。当线程比较多时，内存资源的消耗就会比较大。</li>\n<li>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间；在客户端连接数量不高时没问题，当面对十万甚至百万连接时会无能为力</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class BioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocket serverSocket &#x3D; new ServerSocket();\n        serverSocket.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        while (true) &#123;\n            &#x2F;&#x2F; accept()为阻塞函数，直到有连接到来才返回\n            Socket clientSocket &#x3D; serverSocket.accept();\n            &#x2F;&#x2F; 为每个客户端单独创建一个线程处理\n            new Thread(new ClientHandler(clientSocket)).start();\n        &#125;\n    &#125;\n\n    private static class ClientHandler implements Runnable &#123;\n        private Socket socket;\n        public ClientHandler(Socket socket) &#123;\n            this.socket &#x3D; socket;\n        &#125;\n\n        @Override\n        public void run() &#123;\n            byte[] data &#x3D; new byte[1024];\n            while (true) &#123; &#x2F;&#x2F;持续接收客户端发来的数据\n                try &#123;\n                    &#x2F;&#x2F; read()为阻塞函数，直到读取到数据再返回\n                    socket.getInputStream().read(data);\n                    &#x2F;&#x2F; write()为阻塞函数，全部写完成才会返回\n                    socket.getOutputStream().write(data); &#x2F;&#x2F;echo\n                &#125; catch (IOException e) &#123;\n                    &#x2F;&#x2F; log and exit\n                    break;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>非阻塞I/O模型（NIO）：Selector+非阻塞IO，注册channel（不会一直占用线程） + Selector多路复用（隔一段时间轮询，找能执行的channel）</p>\n<ul>\n<li><p>非阻塞模型利用非阻塞模式和<strong>Selector</strong>多路复用器来开发服务器，也叫做多路复用I/O模型。只有实现了SelectableChannel接口的Channel才可以注册到Selector中被监听，比如DatagramChannel、SocketChannel、ServerSocketChannel，FileChannel无法被Selector监听</p>\n</li>\n<li><p>在NioEchoServer类中，如果有n可客户端连接服务器，那么就会创建n+1个Channel，其中一个serverChannel用于接受客户端的连接，另外n个clientChannel用于与客户端进行通信。这n+1个Channel均注册到Selector中。Selector会间隔一定时间轮训这n+1个Channel，查找可连接、可读、可写的Channel，然后再进行连接、读取、写入操作</p>\n<ul>\n<li>在NIO中，主线程通常只有一个，但是可以使用Selector来管理多个Channel，实现多个连接的非阻塞读写操作。当有多个Channel需要进行IO操作时，Selector会轮询这些Channel，检查它们的状态是否可读或可写，如果有可读或可写的Channel，就将其加入到一个已选择键集合中，等待程序处理。这样，一个线程就可以同时处理多个Channel，提高了系统的并发处理能力</li>\n<li>NIO底层是用Selector、Channel和ByteBuffer来实现的。主线程在循环使用select方法进行阻塞等待，当有acceptable、readable或者writable事件发生的时候，循环就会往下走，将对应的事件交给对应的事件处理器进行处理</li>\n<li>Selector是一个可以监控多个通道（Channel）是否有数据可读或可写的对象，当一个或多个Channel准备好读或写时，Selector会通知程序进行读写操作，而不是像BIO一样阻塞等待IO操作完成</li>\n</ul>\n</li>\n<li><p>多路复用I/O模型：只需要一个线程即可，解决了阻塞I/O模型线程开销大的问题。但是如果某些clientChannel耗时比较久，那么其它clientChannel便需要阻塞，使得服务器响应的延迟变高，但可以用过线程池中取线程来处理，而不是所有的clientChannel都在一个线程中处理。跟非阻塞I/O的区别在于不管有没有数据可读，阻塞I/O模型中的每个clientSocket都会一直占用线程。而这里的多线程只会处理经过Selector筛选之后有可读数据的clientChannel，并且处理完之后就释放回线程池，线程的利用率更高</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NioEchoServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F; Selector\n        Selector selector &#x3D; Selector.open();\n\n        &#x2F;&#x2F; create serverChannel and register to selector\n        ServerSocketChannel serverChannel &#x3D; ServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        serverChannel.configureBlocking(false);&#x2F;&#x2F;非阻塞\n      \t&#x2F;&#x2F;注册\n        serverChannel.register(selector, SelectionKey.OP_ACCEPT);\n\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n        while (true) &#123;\n            int channelCount &#x3D; selector.select(); &#x2F;&#x2F;取来准备好的selector\n            if (channelCount &gt; 0) &#123;\n                Set&lt;SelectionKey&gt; keys &#x3D; selector.selectedKeys();\n                Iterator&lt;SelectionKey&gt; iterator &#x3D; keys.iterator();\n                while (iterator.hasNext()) &#123;\n                    SelectionKey key &#x3D; iterator.next();&#x2F;&#x2F;链表\n                    if (key.isAcceptable()) &#123;\n                        &#x2F;&#x2F; create clientChannel and register to selector\n                        SocketChannel clientChannel &#x3D; serverChannel.accept();\n                        clientChannel.configureBlocking(false);&#x2F;&#x2F;非阻塞\n                        clientChannel.register(selector, SelectionKey.OP_READ);\n                    &#125; else if (key.isReadable()) &#123;\n                        SocketChannel clientChannel &#x3D; (SocketChannel) key.channel();\n                        clientChannel.read(buffer);\n                        buffer.flip(); &#x2F;&#x2F;从&quot;用于读&quot;变为&quot;用于写&quot;\n                        if (buffer.hasRemaining())&#123;&#x2F;&#x2F;也可以注册到selector中\n                            clientChannel.write(buffer); &#x2F;&#x2F;echo\n                        &#125;\n                        buffer.clear(); &#x2F;&#x2F;重复利用\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>异步I/O模型（AIO）：异步IO，通过异步Channel，数据读取完成后会执行回调函数</p>\n<ul>\n<li>与NIO不同的是，AIO不需要用户线程等待IO操作完成，而是由操作系统来完成IO操作，操作系统完成IO操作后会通知用户线程处理。AIO适用于连接数较多且连接时间较长的场景，如高性能网络服务器等</li>\n<li>通过异步Channel调用accept()、read()、write()函数。当有连接建立、数据读取完成、数据写入完成时，底层会通过线程池执行对应的回调函数。这种服务器的实现方式叫做异步I/O模型</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class AioEchoServer &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        AsynchronousServerSocketChannel serverChannel &#x3D; AsynchronousServerSocketChannel.open();\n        serverChannel.bind(new InetSocketAddress(&quot;127.0.0.1&quot;, 1192));\n        &#x2F;&#x2F; 异步accept()\n        serverChannel.accept(null, new AcceptCompletionHandler(serverChannel));\n        Thread.sleep(Integer.MAX_VALUE);\n    &#125;\n\n    private static class AcceptCompletionHandler implements CompletionHandler&lt;AsynchronousSocketChannel, Object&gt; &#123;\n        private AsynchronousServerSocketChannel serverChannel;\n        public AcceptCompletionHandler(AsynchronousServerSocketChannel serverChannel) &#123;\n            this.serverChannel &#x3D; serverChannel; \n        &#125;\n\n        @Override\n        public void completed(AsynchronousSocketChannel clientChannel, Object attachment) &#123;\n            &#x2F;&#x2F; in order to accept other client&#39;s connections\n            serverChannel.accept(attachment, this);\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024);\n            &#x2F;&#x2F; 异步read()\n            clientChannel.read(buffer, buffer, new ReadCompletionHandler(clientChannel)); \n        &#125;\n\n        @Override\n        public void failed(Throwable exc, Object attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n\n    private static class ReadCompletionHandler implements CompletionHandler&lt;Integer, ByteBuffer&gt; &#123;\n        private AsynchronousSocketChannel clientChannel;\n        public ReadCompletionHandler(AsynchronousSocketChannel clientChannel) &#123;\n            this.clientChannel &#x3D; clientChannel;\n        &#125;\n\n        @Override\n        public void completed(Integer result, ByteBuffer buffer) &#123;\n            buffer.flip();\n            &#x2F;&#x2F; 异步write()。回调函数为null，写入完成就不用回调了\n            clientChannel.write(buffer, null, null); &#x2F;&#x2F; echo\n        &#125;\n\n        @Override\n        public void failed(Throwable exc, ByteBuffer attachment) &#123;\n            &#x2F;&#x2F; log exc exception\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>文件（高速IO）：上下文切换耗时（环境重置、缓存失效）、系统调用（read、write、open、close）、新技术（DMA、mmap、零拷贝）</p>\n<ul>\n<li><p>用户态和内核态</p>\n<ul>\n<li><strong>系统调用：</strong>操作系统内核包含各种操作硬件资源的系统调用，应用程序必须通过操作系统提供的系统调用才能访问硬件资源。</li>\n<li><strong>库函数：</strong>系统调用比较底层，所以Linux又提供了库函数，比如Glibc库、Posix库，对系统调用进行封装，提供更加简单易用的函数，供应用程序开发使用，比如：Glibc中的malloc()函数封装了sbrk()系统调用，fread()、fwrite()封装了read()、write()系统调用，在开发应用程序的时候，既可以使用库函数，也可以直接使用系统调用</li>\n<li><strong>Shell：</strong>Linux还提供了Shell这一程序，即命令行，Shell能在不进行编程的情况下，通过命令行中运行Shell命令或脚本，达到访问硬件的目的，比如cp拷贝文件、rm删除文件</li>\n<li><strong>用户态&amp;内核态：</strong>为避免应用程序在运行时，访问到内核所用的内存空间，操作系统将虚拟内存分为内核空间和用户空间两部分，CPU因此有内核态和用户态两种，在内核态CPU拥有最高权限，可以执行所有的机器指令并且可以访问硬件，而且内核态能访问所有虚拟内存空间，在用户态则不能</li>\n<li>上下文切换：当应用调用操作系统的系统调用时，会涉及内核态与用户态的上下文切换，主要耗时的操作有：<ul>\n<li>寄存器保存与恢复耗时：因为内核空间不使用应用程序的函数调用栈，会分配新的函数调用栈，所以在上下文切换时需要更新更多栈相关的寄存器，比如SS栈基址寄存器。除此之外，应用程序和内核程序的代码存储位置也不同，CS代码段基址寄存器也需要更新。并且更新前会保存下来原始值，以便切换回用户态之后恢复执行</li>\n<li>缓存失效带来的性能损耗：CPU有L1、L2、L3三级Cache，用于缓存将要执行的代码以及所需的内存数据，上下文切换会导致CPU缓存失效</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>IO读写底层原理</p>\n<ul>\n<li>Linux操作系统下，Java的I/O类库调用<code>open()</code>、<code>read()</code>、<code>write()</code>系统调用来实现，通过open()返回Linux下I/O设备的文件描述符，来和I/O设备建立连接。</li>\n<li>操作系统为每个文件描述符都分配一个内核读缓存区和一个内核写缓存区（数据会先被放到内核读写缓存区，读缓冲区不够时才会从磁盘读取文件，写缓冲区满时才会写入到磁盘中），内核读写缓存区只有在第一次调用read()或write()系统调用时，才会真正被分配内存空间。默认读缓冲区的大小为8192字节，写缓冲区的大小为16384字节。当然，也可以根据业务需求，通过系统调用，来重新设置，这样做的目的主要是为了减少与I/O设备的交互次数</li>\n<li>在读写完成后需要调用<code>close()</code>系统调用</li>\n</ul>\n</li>\n<li><p>新技术：DMA（替代CPU读写数据）、mmap（将大文件映射到虚拟内存地址上）、零拷贝（直接从内核读缓冲区拷贝到内核写缓冲区）</p>\n<ul>\n<li><p>DMA（Direct Memory Access）：通过在主板上安装一个叫做DMAC (DMA Controller，DMA控制器)的协处理器(或叫芯片)，协助CPU来完成I/O设备的数据读写工作（现在很多IO设备都自带DMAC）。DMAC替代CPU从设备中读取数据或向设备写入数据，通过中断通知CPU，CPU利用率提高了</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731153345790.png\" alt=\"image-20230731153345790\"></p>\n</li>\n<li><p>mmap（memory-mapped file，内存映射文件）：提高文件读写性能的有效技术，一般用于文件读写，不适用于网络这种数据未知的I/O设备</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;java.nio.FileChannel类中\npublic MappedByteBuffer map(MapMode mode , long position, long size);</code></pre>\n\n<ul>\n<li>通过将文件或文件中的某段映射到用户空间中的某段虚拟内存地址上，如果没加载到物理内存，则触发缺页中断；如果有脏页，操作系统自动写回磁盘或者调用msync()立即写回</li>\n<li>mmap相当于直接将数据在磁盘和用户空间之间互相拷贝，相对于使用read()、write()系统调用读写文件，数据拷贝次数由2次减少为1次，并且减少了内核态和用户态上下文切换的耗时，之后读写文件就像读写内存一样</li>\n<li>对于少量文件读写，使用read()、write()更合适，对于大文件的读写，一般使用mmap，并且需要一些测试来验证性能。进程间通信当两个应用程序都采用MAP_SHARED模式创建匿名的内存映射文件时，这两个应用程序会共享物理内存，一个应用程序可以读取另一个程序写入物理内存的数据，以此来实现互相通信</li>\n</ul>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int main(void)&#123;\n    char file &#x3D; &quot;&#x2F;users&#x2F;root&#x2F;in.txt&quot;;\n    int fd &#x3D; open(file, O_RDWR,0666);\n    if(fd &lt;0)&#123;\n        printf(&quot;open file failedl\\\\n&quot;);\n        return -1;\n    &#125;\n    &#x2F;&#x2F;映射文件开头(offset&#x3D;0)的512字节(length&#x3D;512)到ptr\n    size_t length &#x3D; 512;\n    int offset &#x3D; 0;\n\t\t&#x2F;&#x2F;mmap，后面就和使用fd一样了\n    char *ptr &#x3D; mmap(null, length, PROT_READ|PROT_WRITE, MAP_SHARED, fd , offset);\n    if (ptr &#x3D;&#x3D; MAP_FAILED)&#123;\n        printf(&quot;mmap failed.&quot;);\n        return -1;\n    &#125;\n    &#x2F;&#x2F;创建好内存映射文件之后，fd就没用了，可以释放了\n    close(fd);\n    \n    &#x2F;&#x2F;操作ptr就等同于读写文件\n    for (int i &#x3D; 0; i &lt; length; i++)&#123;\n        ptr[i] &#x3D; &#39;a&#39; + (length%26);\n    &#125;\n\n    for (int i &#x3D; 0; i &lt;N, i++)&#123;\n        printf(&quot;%c&quot;,ptr[i]);\n    &#125;\n    &#x2F;&#x2F;删除内存映射文件，释放占用的虚拟内存空间\n    munmap(ptr, length);\n    return 0;\n&#125;</code></pre></li>\n<li><p>零拷贝（Zero-copy）：sendfile 系统调用实现了零拷贝技术，零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运，使用零拷贝的项目有nginx、kafka</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731153403899.png\" alt=\"image-20230731153403899\"></p>\n<ul>\n<li><p>主要用于两个I/O设备之间互相传输数据，特别是将文件中的数据发送到网络或者将从网络接受的数据存储到文件这一场景中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;java.nio.FileChannel\npublic abstract long transferTo(long position,long count WritableByteChannel target);\npublic abstract long transferFrom(ReadableByteChannel src, long position,long count);</code></pre></li>\n<li><p>零拷贝不需要将数据拷贝到应用程序缓冲区，而是直接从内核读缓冲区拷贝到内核写缓冲区，应用程序只需要进行一次系统调用（执行sendfile()），就可以将文件发送到网络</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;fcntl.h&gt;\n#include &lt;sys&#x2F;sendfile.h&gt;\n#include &lt;sys&#x2F;stat.h&gt;\n#include sys&#x2F;types.h&gt;\nint main (int argc, char*argv[)&#123;\n    int read_fd;\n    int write_fd;\n    struct stat stat_buf;\n    off_t offset &#x3D; o;\n    read_fd &#x3D; open (argv[1],O_RDONLY);\n    fstat (read_fd, &amp;stat_buf) ;\n    write_fd &#x3D; open (argv[2],O_WRONLY \\\\ O_CREAT, stat_buf.st_mode);\n    sendfile (write_fd, read_fd, &amp;offset, stat_buf.st_size);\n    close(read_fd);\n    close (write_fd);\n    return 0;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-Exception体系\"><a href=\"#5-Exception体系\" class=\"headerlink\" title=\"5.Exception体系\"></a>5.Exception体系</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>相比较C语言返回错误码的方式，可以携带更多的错误信息（message、stack trace等），并且可以将业务代码和异常处理代码分离，这样代码的可读性会更好</p></blockquote>\n<ol>\n<li><p>异常体系</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230504152858261.png\" alt=\"image-20230504152858261\"></p>\n<ul>\n<li>继承自Error的异常：表示程序无法处理的严重错误，这些错误有可能导致线程或JVM终止</li>\n<li>继承自Exception的异常：也叫做受检异常（Checked Exception）或编译时异常（Compile Exception），在编写代码的时候，需要主动取捕获或者在函数定义中声明此类异常，否则编译就会报错</li>\n<li>继承自RuntimeException的异常：也叫做非受检异常（Unchecked Exception）或者运行时异常（Runtime Exception），在编写代码的时候，可以不主动取捕获和在函数定义中声明此类异常，不处理也可以通过编译</li>\n</ul>\n</li>\n<li><p>自定义异常：要么继承自Exception，要么继承自RuntimeException，但是现在一般都依赖框架来编程，受检和非受检异常大部分情况下都会被框架兜底捕获并处理，并不会直接导致程序的终止，所以从这个角度来看，继承自哪个异常均可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;受检异常的使用违反开闭原则，整条调用链都需要修改代码；非受检异常需要主动处理，但容易被遗忘\npublic class UserNotExistingException extends Exception&#123;\n    public UserNotExistingException()&#123;\n        super();\n    &#125;\n    public UserNotExistingException(String msg,Throwable cause)&#123;\n        super(msg,cause)；\n    &#125;\n    public UserNotExistingException(String msg)&#123;\n        super(msg);\n    &#125;\n    public UserNotExistingException(Throwable cause)&#123;\n        super(cause);\n    &#125;\n&#125;</code></pre></li>\n<li><p>异常处理</p>\n<ul>\n<li><p>打印调用链：在函数内部，如果某代码的异常行为，并不会导致调用此函数的上层代码出现异常行为，也就是说，上层代码并不关心被调用函数内部的这个异常，我们就可以在函数内部将这个异常捕获并打印日志记录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void f() throws LowLevelException&#123;...&#125;\n&#x2F;&#x2F;捕获后记录日志\npublic void g()&#123;\n    try&#123;\n        f();\n    &#125;catch(LowLevelException e)&#123;\n        log.warn(&quot;...&quot;,e);&#x2F;&#x2F;使用日志框架记录日志\n    &#125;\n&#125;</code></pre></li>\n<li><p>使用throws抛出异常：如果函数内部的异常行为会导致调用此函数的上层代码出现异常行为，那么，就必须让上层代码感知此异常的存在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;原封不动再抛出\n&#x2F;&#x2F;如果LowLevelException是非受检异常，则不需要再函数g()定义中声明\npublic void g() throws LowLevelException&#123;\n    f();\n&#125;</code></pre></li>\n<li><p>使用new创建新的异常：如果此异常跟函数的业务相关，上层代码在调用此函数时，知道如何处理异常，那么直接将其抛出即可；如果此异常跟业务无关，上层代码无法理解这个异常的含义，那么就需要包装成新的跟函数业务相关的异常重新抛出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;包装成新异常抛出\npublic void g()&#123;\n    try&#123;\n        f();\n    &#125;catch(LowLevelExceptioin e)&#123;\n\t\t\t\t&#x2F;&#x2F;异常调用链可以完整的描述异常发生的整个过程，但需要特别注意的是，捕获异常并包裹成新的异常抛出时，\n\t\t\t\t&#x2F;&#x2F;一定要将先前的异常通过cause参数（下面代码中的e）传递进新的异常，否则，异常调用链会断开\n        throw new HighLevelException(&quot;...&quot;,e);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>异常实现原理：异常代码块执行顺序：不管try监听的代码块有没有异常抛出，finally代码块总是被执行，并且在finally代码执行完成之后，try代码块和catch代码块中的return语句才会被执行</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230504154040061.png\" alt=\"image-20230504154040061\"></p>\n<ul>\n<li>异常表：对应于上图最后一部分的Exception table，其中from、to、target都表示字节码的行号，当行号在[from，to）之间的代码抛出type类型的异常时，JVM会跳转至target行字节码继续执行</li>\n<li>异常兜底：第50行代码开始，主要是捕获try代码块和catch代码块中未被捕获的异常，然后再执行完finally代码块之后，在原封不动的将异常抛出</li>\n<li>finally内联：JVM在生成字节码时，会将finally代码块内联（插入）到try代码块和catch代码块中的return语句之前，这样就可以实现不管程序是否抛出异常，finally代码块总是会被执行，并且再函数返回之前执行。如果finally有return语句，会提前返回</li>\n</ul>\n</li>\n<li><p>异常性能分析</p>\n<ul>\n<li><p>使用new创建异常：在堆上创建异常对象，初始化成员变量，调用异常父类Throwable中的fillInStackTrace()函数生成栈追踪信息，通过getStackTrace()函数打印stackTrace栈追踪信息（当调用层次过深时，会导致fillInStackTrace耗时高，所以在递归中不要轻易抛出异常）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;当创建异常时函数调用栈中的所有函数的信息，栈追踪信息记录了异常产生的整个函数调用链路，方便定位此异常是如何产生的\nprivate StackTraceElement[] stackTrace;\npublic final class StackTraceElement implements java.io.Serializable &#123;\n    &#x2F;&#x2F; Normally initialized by VM (public constructor added in 1.5)\n    private String declaringClass;&#x2F;&#x2F;函数所属类名\n    private String methodName;&#x2F;&#x2F;函数名\n    private String fileName;&#x2F;&#x2F;函数所属类文件名\n    private int    lineNumber;&#x2F;&#x2F;异常抛出时，函数执行到了哪一行\n    &#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;通过getStackTrace()函数，将异常的stackTrace栈追踪信息打印出来\nRuntimeException e &#x3D; new RuntimeException(&quot;oops&quot;);\nStackTraceElement[] stackTrace &#x3D; e.getStackTrace();\nfor(StackTraceElement element : stackTrace)&#123;\n    System.out.println(element);\n&#125;</code></pre></li>\n<li><p>使用throw抛出异常：当有函数抛出异常时，JVM会在底层执行栈展开（stack unwinding），依次将函数调用栈中的函数栈帧弹出，直到找到哪个函数可以捕获这个异常为止，然后JVM从这个函数继续再执行（不同于return导致的栈展开，异常导致的栈展开会有一个在函数的异常表中查找是否有可匹配的处理规则的过程，这样的查找在调用层次过深时和耗时）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;throw new RuntimeException(&quot;oops&quot;)这样一个异常抛出代码包括两个操作：创建异常和抛出异常等价于下面的两行代码\nRuntimeException e &#x3D; new RuntimeException(&quot;oops!&quot;);\nthrow e;</code></pre></li>\n<li><p>打印异常调用链</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>每个异常的stackTrace栈追踪消息都是一直到main函数的，不可以只记录生命周期内的函数，因为stackTrace栈追踪信息是在异常创建时生成的，在打印异常时，异常的声明周期未必就一定结束，所以无法只填充生命周期内所经历的函数</p></blockquote>\n<ul>\n<li><p>原封不动抛出：相当于没捕获</p>\n</li>\n<li><p>封装成新的异常抛出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try&#123;\n    &#x2F;&#x2F;...\n&#125;catch(IOException e)&#123;\n\t\t&#x2F;&#x2F;将捕获的异常通过cause参数传递给新的异常，调用链就不会断，主要调用了下面的Throwable的构造函数\n    throw new RuntimeException(&quot;oops&quot;,e);\n&#125;\n\npublic class Throwable&#123;\n    private String detailMessage;\n    private Throwable cause &#x3D; this;&#x2F;&#x2F;异常调用\n    private StackTraceElement[] stackTrace &#x3D; UNASSIGNED_STACK;\n    \n    public Throwable(String message, Throwable cause) &#123;\n        fillInStackTrace();&#x2F;&#x2F;生成stackTrace\n        detailMessage &#x3D; message;\n        this.cause &#x3D; cause;\n    &#125;\n    &#x2F;&#x2F;...\n&#125;</code></pre></li>\n<li><p>记录日志：一般在开发中使用日志框架来记录异常，异常调用链信息会输出到日志文件中，方便开发者事后查看，一般不推荐使用<code>e.pringStackTrace()</code>来打印异常日志，因为会打印到标准出错输出<code>System.err</code>中，即命令行中，这不方便保存以便反复查看</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try&#123;\n    &#x2F;&#x2F;...\n&#125;catch(IOException e)&#123;\n    log.error(&quot;...&quot;,e);\n    &#x2F;&#x2F;e.printStackTrace() 不推荐\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>异常最佳实践：对于业务异常只需要将一些有用的信息，记录在异常的detailMessage成员变量中即可，通过向构造函数的参数writableStackTrace传入false，即可禁止在创建异常的同时调用fillStackTrace()函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Throwable(String message, Throwable cause,\n                    boolean enableSuppression,\n                    boolean writableStackTrace) &#123;\n    if (writableStackTrace) &#123;\n        fillInStackTrace();\n    &#125; else &#123;\n        stackTrace &#x3D; null;\n    &#125;\n    detailMessage &#x3D; message;\n    this.cause &#x3D; cause;\n    if (!enableSuppression)\n        suppressedExceptions &#x3D; null;\n&#125;\n&#x2F;&#x2F;使用，可以解决高并发下程序中大量业务异常导致的程序变慢的问题\npublic class UserNotExistingException extends Throwable&#123;\n    public UserNotExistingException() &#123;\n        super(null,null,true,false);\n    &#125;\n\n    public UserNotExistingException(String message) &#123;\n        super(message,null,true,false);    &#125;\n\n    public UserNotExistingException(String message, Throwable cause) &#123;\n        super(message,cause,true,false);\n    &#125;\n\n    public UserNotExistingException(Throwable cause) &#123;\n        super(null,cause,true,false);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"3-附录\"><a href=\"#3-附录\" class=\"headerlink\" title=\"3.附录\"></a>3.附录</h2><h3 id=\"1-代码设计原则\"><a href=\"#1-代码设计原则\" class=\"headerlink\" title=\"1.代码设计原则\"></a>1.代码设计原则</h3><ol>\n<li><p>SOLID</p>\n<ol>\n<li><p>SRP单一职责原则：==A class or module should hava a single responsibility==</p>\n<ol>\n<li>不要设计大而全的类，要设计粒度小、功能单一的类。也就是说，如果一个类包含了两个或以上业务不相干的功能，那么他的职责就不够单一，应该被拆分成多个功能单一、粒度更细的类。</li>\n<li>要判断职责是否单一，不能脱离具体的应用场景，所以可以先写一个粗粒度的类，满足业务需求，随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个独粒度的类拆分成几个更细粒度的类，这就是所谓的==持续重构==。</li>\n<li>==技巧==：<ul>\n<li>类中的代码行数（200行内）、函数或属性过多（少于10个），会影响代码的可读性和可维护性，我们就需要对类进行拆分</li>\n<li>类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要对类进行拆分</li>\n<li>私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性</li>\n<li>比较难给类起一个合适的名字，很难用一个业务名词概括或者只能用一些笼统的Manager、Context之类的词语来命名，这就说明类的职责定义的可能不够清晰</li>\n<li>类中大量的方法都是集中操作类中的某几个属性。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>OCP开闭原则：==Software entities(modules,classes,functions) should be open for extension,but closed for modification==</p>\n<ol>\n<li><p>添加一个新功能应该是，在已有的代码基础上扩展代码（新增模块、类、方法等），而非修改已有的代码（修改模块、类、方法等）</p>\n</li>\n<li><p>指导思想：为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识，这些潜意识可能比任何开发技巧都重要。</p>\n</li>\n<li><p>==方法==：多态、依赖注入、基于接口而非实现编程、大部分设计模式（装饰、策略、模板、职责链、状态）</p>\n</li>\n</ol>\n</li>\n<li><p>LSP里式替换原则：==子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏==</p>\n<ol>\n<li>虽然从定义描述和代码实现上来看，多态和里氏替换有点类似，但他们的关注角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，它是一种代码实现的思路。而里氏替换原则是一种设计原则，是用来直到继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</li>\n<li>==按照协议来设计==：子类在设计的时候，要遵守父类的行为约定（或协议），父类定义了函数的行为约定，子类可以改变函数内部实现逻辑，但不能改变函数原有的行为约定（函数声明是实现的功能、对输入、输出、异常的约定、注释中所罗列的任何特殊说明）。</li>\n<li>==技巧==：用父类的单元测试来验证子类的代码，如果某些单元测试运行失败，就有可能违背里氏替换原则</li>\n</ol>\n</li>\n<li><p>ISP接口隔离原则：==Clients should not be forced to depend upon interfaces that they do not use==</p>\n<ol>\n<li>一组API接口集合：在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那么我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</li>\n<li>单个API接口或函数：函数的设计要功能单一，不要将多个功能逻辑在一个函数中实现。接口隔离原则跟单一职责原则有点类似，但是单一职责原则针对的是模块、类、接口的设计；而接口隔离原则相对于单一职责原则，一方面他更侧重于接口的设计，另一方面它提供了一种判断接口是否职责单一的标准（如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够指责单一）。</li>\n<li>OOP中的接口概念：拆分成小接口，而不是一个大而全的config接口</li>\n</ol>\n</li>\n<li><p>DIP依赖倒置原则：==High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.（高层模块和低层模块的划分就是，在调用链上，调用者属于高层，被调用者属于低层）==</p>\n</li>\n</ol>\n</li>\n<li><p>KISS原则：==尽量保持简单==</p>\n<ul>\n<li>不要使用同事可能不懂的技术来实现代码，例如正则表达式或编程语言中的高级语法</li>\n<li>不要重复造轮子，要善于使用已经有的工具类库</li>\n<li>不要过度优化，不要过度使用一些奇技淫巧（位运算、复杂条件语句、过于底层函数）来优化代码，牺牲代码的可读性</li>\n</ul>\n</li>\n<li><p>YAGNI原则：==You ain’t gonna need it 你不会需要它==，不要去设计当前用不到的功能，不要去编写当前用不到的代码，即不要过度设计，只需要预留好扩展点。</p>\n</li>\n<li><p>DRY原则：==Don’t repeat yourself==，不要写重复的代码。</p>\n<ul>\n<li>实现逻辑重复：尽管代码的实现逻辑是重复的，但是语义上不是重复的，可以判定它并不违反DRY原则</li>\n<li>功能语义重复：实现逻辑不重复，但语义重复，那么也就是功能重复，我们认为它违反了DRY原则</li>\n<li>代码执行重复：例如对输入校验了两次</li>\n</ul>\n</li>\n<li><p>LOD原则（Law of Demeter）：==Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.==</p>\n<ol>\n<li><p>高内聚，松耦合：</p>\n<ol>\n<li>高内聚：用来指导类本身的设计，相近的功能应该放到同一个类中，不想近的功能不要放到同一个类中，相近的功能往往会被同时更改，放到一个类中，代码容易维护</li>\n<li>低耦合：用来指导类与类之间依赖关系的设计，在代码中，类与类之间的依赖关系应该简单清晰，一个类的代码改动不会或者很少导致依赖类的代码改动</li>\n</ol>\n</li>\n<li><p>迪米特法则</p>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-JDBC连接数据库\"><a href=\"#2-JDBC连接数据库\" class=\"headerlink\" title=\"2.JDBC连接数据库\"></a>2.JDBC连接数据库</h3><ul>\n<li>加载数据库驱动程序：使用Class.forName()方法加载对应的数据库驱动程序，例如：Class.forName(“com.mysql.jdbc.Driver”);</li>\n<li>建立数据库连接：使用DriverManager.getConnection()方法建立与数据库的连接，需要指定数据库的URL、用户名和密码，例如：Connection conn = DriverManager.getConnection(“jdbc:mysql://localhost/mydatabase”, “username”, “password”);</li>\n<li>创建Statement对象：使用Connection对象的createStatement()方法创建一个Statement对象，用于执行SQL语句，例如：Statement stmt = conn.createStatement();</li>\n<li>执行SQL语句：使用Statement对象的executeQuery()或executeUpdate()方法执行SQL语句，例如：ResultSet rs = stmt.executeQuery(“SELECT * FROM mytable”);</li>\n<li>处理查询结果：如果执行的是查询语句，需要使用ResultSet对象来处理查询结果，例如：while (rs.next()) { String name = rs.getString(“name”); int age = rs.getInt(“age”); }</li>\n<li>关闭数据库连接：在程序结束时，需要使用Connection对象的close()方法关闭数据库连接，例如：conn.close();</li>\n</ul>\n<h3 id=\"3-Socket编程示例\"><a href=\"#3-Socket编程示例\" class=\"headerlink\" title=\"3.Socket编程示例\"></a>3.Socket编程示例</h3><h3 id=\"4-Collections工具类\"><a href=\"#4-Collections工具类\" class=\"headerlink\" title=\"4.Collections工具类\"></a>4.Collections工具类</h3><ul>\n<li><p>排序</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void reverse(List list)&#x2F;&#x2F;反转\nvoid shuffle(List list)&#x2F;&#x2F;随机排序\nvoid sort(List list)&#x2F;&#x2F;按自然排序的升序排序\nvoid sort(List list, Comparator c)&#x2F;&#x2F;定制排序，由Comparator控制排序逻辑\nvoid swap(List list, int i , int j)&#x2F;&#x2F;交换两个索引位置的元素\nvoid rotate(List list, int distance)&#x2F;&#x2F;旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</code></pre></li>\n<li><p>查找、替换操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int binarySearch(List list, Object key)&#x2F;&#x2F;对List进行二分查找，返回索引，注意List必须是有序的\nint max(Collection coll)&#x2F;&#x2F;根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\nint max(Collection coll, Comparator c)&#x2F;&#x2F;根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\nvoid fill(List list, Object obj)&#x2F;&#x2F;用指定的元素代替指定list中的所有元素\nint frequency(Collection c, Object o)&#x2F;&#x2F;统计元素出现次数\nint indexOfSubList(List list, List target)&#x2F;&#x2F;统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)\nboolean replaceAll(List list, Object oldVal, Object newVal)&#x2F;&#x2F;用新元素替换旧元素</code></pre></li>\n<li><p>同步控制（不推荐，多线程下应该直接使用JUC下的并发集合）：Collections提供了多个synchronizedXXX方法，该方法可以指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">synchronizedCollection(Collection&lt;T&gt;  c) &#x2F;&#x2F;返回指定 collection 支持的同步（线程安全的）collection。\nsynchronizedList(List&lt;T&gt; list)&#x2F;&#x2F;返回指定列表支持的同步（线程安全的）List。\nsynchronizedMap(Map&lt;K,V&gt; m) &#x2F;&#x2F;返回由指定映射支持的同步（线程安全的）Map。\nsynchronizedSet(Set&lt;T&gt; s) &#x2F;&#x2F;返回指定 set 支持的同步（线程安全的）set。</code></pre></li>\n</ul>\n<h3 id=\"5-其它\"><a href=\"#5-其它\" class=\"headerlink\" title=\"5.其它\"></a>5.其它</h3><ol>\n<li><p>面向对象与面向过程</p>\n<ul>\n<li>面向过程就是把问题分解成一个一个函数，然后调用函数去解决问题。而面向对象就是把这个世界抽象成一个一个对象，然后赋予这些对象一个属性，成员变量和方法，然后去调用对象的方法去解决问题，耦合性比较低</li>\n<li>面向对象可以提高代码的复用性和扩展性、出现问题可以对每个模块单独调试</li>\n</ul>\n</li>\n<li><p>序列化和反序列化</p>\n<ul>\n<li>序列化就是将数据结构或对象转换成二进制字节流的过程，反序列化就是将序列化生成的二进制字节流转换成数据结构或对象的过程<ul>\n<li>实现<code>Serializable</code>接口，即可使用JDK自带的序列化</li>\n<li><code>serialVersionUID</code>：属于版本控制的作用，反序列化时，会检查其是否和当前类的<code>serialVersionUID</code>一致，反序列化之后，<code>static</code>变量并没有被序列化，因为他是静态变量，位于方法区，反序列化时就像是默认赋予给了对象一样</li>\n</ul>\n</li>\n<li>常见应用场景：网络传输、数据库存储、对象存储到内存中</li>\n<li>不想进行序列化的变量：使用transient关键字修饰，transient可以阻止实例中那些用此关键字修饰的变量序列化，当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复<ul>\n<li><code>transient</code>只能修饰变量，不能修饰类和方法</li>\n<li><code>transient</code>修饰的变量，在反序列化后变量会被置成类型的默认值（如int会被置为0）</li>\n<li><code>static</code>变量因为不属于任何对象，所以无论有没有<code>transient</code>修饰，均不会被序列化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SPI：服务提供者的接口，如SLF4J是Java的一个日志接口，具体实现由Logback、Log4j、Log4j2 等等</p>\n</li>\n<li><p>comparable 和 Comparator 的区别</p>\n<ul>\n<li><p>Comparable接口出自java.lang包，它有一个<code>compareTo(Object obj)</code>方法用来排序</p>\n<ul>\n<li><p>一般用在自己的类声明中，在声明的过程中实现Comparable接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;通过this和参数来比较\n@Override\npublic int compareTo(Person o) &#123;\n    if (this.age &gt; o.getAge()) &#123;\n        return 1;\n    &#125;\n    if (this.age &lt; o.getAge()) &#123;\n        return -1;\n    &#125;\n    return 0;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;使用&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic static void main(String[] args) &#123;\n\t\t&#x2F;&#x2F;要么传入的key实现comparable接口，要么构造时传入的comparator接口的匿名对象\n    TreeMap&lt;Person, String&gt; pdata &#x3D; new TreeMap&lt;Person, String&gt;();\n    pdata.put(new Person(&quot;张三&quot;, 30), &quot;zhangsan&quot;);\n    pdata.put(new Person(&quot;李四&quot;, 20), &quot;lisi&quot;);\n    pdata.put(new Person(&quot;王五&quot;, 10), &quot;wangwu&quot;);\n    pdata.put(new Person(&quot;小红&quot;, 5), &quot;xiaohong&quot;);\n    &#x2F;&#x2F; 得到key的值的同时得到key所对应的值\n    Set&lt;Person&gt; keys &#x3D; pdata.keySet();\n    for (Person key : keys) &#123;\n        System.out.println(key.getAge() + &quot;-&quot; + key.getName());\n\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>Comparator接口实际上是出自java.util包，它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</p>\n<ul>\n<li><p>通过实现Comparator接口的对象，作为参数传递新的比较方法到工具类（sort方法）中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;通过传入的两个参数，确定比较规则，返回比较结果\nCollections.sort(arrayList, new Comparator&lt;Integer&gt;() &#123;\n    @Override\n    public int compare(Integer o1, Integer o2) &#123;\n        return o2.compareTo(o1);\n    &#125;\n&#125;);</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Java集合使用注意事项（阿里巴巴Java开发手册）</p>\n<ul>\n<li><p><strong>判断所有集合内部的元素是否为空，使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式：</strong><code>isEmpty()</code>方法的可读性更好，并且时间复杂度为 O(1)</p>\n</li>\n<li><p><strong>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常</strong></p>\n<ul>\n<li><code>toMap</code>方法调用了<code>Map</code>接口的<code>merge</code>方法，<code>merge</code>方法就先调用<code>Objects.requireNonNull</code>方法来判断value是否为空</li>\n</ul>\n</li>\n<li><p><strong>不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作（抛出<code>ConcurrentModificationException</code>异常，即fail-fast机制）。remove 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁</strong></p>\n<ul>\n<li><p>可以使用<code>java.util.concurrent</code>包下面的类</p>\n</li>\n<li><p>可以使用Collection的removeIf方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nfor (int i &#x3D; 1; i &lt;&#x3D; 10; ++i) &#123;\n    list.add(i);\n&#125;\nlist.removeIf(filter -&gt; filter % 2 &#x3D;&#x3D; 0); &#x2F;* 删除list中的所有偶数 *&#x2F;\nSystem.out.println(list); &#x2F;* [1, 3, 5, 7, 9] *&#x2F;</code></pre></li>\n</ul>\n</li>\n<li><p>集合去重：<strong>可以利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains()</code> 进行遍历去重或者判断包含操作</strong></p>\n<ul>\n<li>HashSet的contains方法依赖底部的HashMap，时间复杂度时时O（1）的</li>\n<li>ArrayList的contains方法是通过遍历所有元素来实现的，时间复杂度是O（n）</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Set 去重代码示例\npublic static &lt;T&gt; Set&lt;T&gt; removeDuplicateBySet(List&lt;T&gt; data) &#123;\n\n    if (CollectionUtils.isEmpty(data)) &#123;\n        return new HashSet&lt;&gt;();\n    &#125;\n    return new HashSet&lt;&gt;(data);\n&#125;\n\n&#x2F;&#x2F; List 去重代码示例\npublic static &lt;T&gt; List&lt;T&gt; removeDuplicateByList(List&lt;T&gt; data) &#123;\n\n    if (CollectionUtils.isEmpty(data)) &#123;\n        return new ArrayList&lt;&gt;();\n\n    &#125;\n    List&lt;T&gt; result &#x3D; new ArrayList&lt;&gt;(data.size());\n    for (T current : data) &#123;\n        if (!result.contains(current)) &#123;\n            result.add(current);\n        &#125;\n    &#125;\n    return result;\n&#125;</code></pre></li>\n<li><p><strong>使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String [] s&#x3D; new String[]&#123;\n    &quot;dog&quot;, &quot;lazy&quot;, &quot;a&quot;, &quot;over&quot;, &quot;jumps&quot;, &quot;fox&quot;, &quot;brown&quot;, &quot;quick&quot;, &quot;A&quot;\n&#125;;\nList&lt;String&gt; list &#x3D; Arrays.asList(s);\nCollections.reverse(list);\n&#x2F;&#x2F;没有指定类型的话会报错，new String[0]起到一个模版的作用，指定了返回参数的类型，0是为了节省空间，因为只是为了说明返回的类型\ns&#x3D;list.toArray(new String[0]);</code></pre></li>\n<li><p>使用工具类Arrays.asList把数组转换成集合时，返回的不是平常使用的ArrayList，而是Arrays的一个内部类，</p>\n<ul>\n<li>不能使用其修改集合相关的方法，它的add、remove、clear方法会抛出**<code>UnsupportedOperationException</code>**异常，该Arrays内部类里面并没有上述方法</li>\n<li>asList收到的是传入集合的地址值，而不是数据，所以get方法在参数为0的时候返回地址值，在参数为1的时候返回数组越界异常</li>\n<li>所以最好手动实现工具类，通过for循环来一个一个add进list里</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;方法一\nList list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))\n&#x2F;&#x2F;方法二\nfor循环一个一个加进去\n&#x2F;&#x2F;方法三 Stream\n\t\tInteger [] myArray &#x3D; &#123; 1, 2, 3 &#125;;\n\t\tList myList &#x3D; Arrays.stream(myArray).collect(Collectors.toList());\n\t\t&#x2F;&#x2F;基本类型也可以实现转换（依赖boxed的装箱操作）\n\t\tint [] myArray2 &#x3D; &#123; 1, 2, 3 &#125;;\n\t\tList myList &#x3D; Arrays.stream(myArray2).boxed().collect(Collectors.toList());\n&#x2F;&#x2F;方法四：使用Guava\n&#x2F;&#x2F;不可变集合\n\tList&lt;String&gt; il &#x3D; ImmutableList.of(&quot;string&quot;, &quot;elements&quot;);  &#x2F;&#x2F; from varargs\n\tList&lt;String&gt; il &#x3D; ImmutableList.copyOf(aStringArray);      &#x2F;&#x2F; from array\n&#x2F;&#x2F;可变集合\n\tList&lt;String&gt; l1 &#x3D; Lists.newArrayList(anotherListOrCollection);    &#x2F;&#x2F; from collection\n\tList&lt;String&gt; l2 &#x3D; Lists.newArrayList(aStringArray);               &#x2F;&#x2F; from array\n\tList&lt;String&gt; l3 &#x3D; Lists.newArrayList(&quot;or&quot;, &quot;string&quot;, &quot;elements&quot;); &#x2F;&#x2F; from varargs\n&#x2F;&#x2F;方法五：使用Java9的List.of方法\n\tInteger[] array &#x3D; &#123;1, 2, 3&#125;;\n\tList&lt;Integer&gt; list &#x3D; List.of(array);\n\t</code></pre></li>\n</ul>\n</li>\n<li><p>Cloneable接口实现原理</p>\n</li>\n<li></li>\n</ol>\n","text":"Java1.基础知识1.关键字 true, false, 和 null 虽然不是关键字，但它们是不能用作标识符的文字和保留字 strictfp（精确浮点数，跨平台产生相同结果）、native（原生方法） class return byte try if import public...","link":"","photos":[],"count_time":{"symbolsCount":"68k","symbolsTime":"1:02"},"categories":[],"tags":[{"name":"language","slug":"language","count":3,"path":"api/tags/language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java\"><span class=\"toc-text\">Java</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">1.基础知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">1.关键字</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90\"><span class=\"toc-text\">2.概念辨析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%AF%AD%E6%B3%95%E7%B3%96\"><span class=\"toc-text\">3.语法糖</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">2.进阶知识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">1.特殊语法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">2.工具类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-JCF%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">3.JCF框架</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-IO%E7%B1%BB%E5%BA%93\"><span class=\"toc-text\">4.IO类库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Exception%E4%BD%93%E7%B3%BB\"><span class=\"toc-text\">5.Exception体系</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%99%84%E5%BD%95\"><span class=\"toc-text\">3.附录</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">1.代码设计原则</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-JDBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93\"><span class=\"toc-text\">2.JDBC连接数据库</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Socket%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">3.Socket编程示例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">4.Collections工具类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%85%B6%E5%AE%83\"><span class=\"toc-text\">5.其它</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java并发","uid":"75ca176d6b382373bec123f05862c849","slug":"Java Concurrent","date":"2023-04-13T23:56:43.000Z","updated":"2023-08-27T08:56:19.514Z","comments":true,"path":"api/articles/Java Concurrent.json","keywords":null,"cover":[],"text":"Java并发1.线程 线程 线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING 线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N） Java使用用户线程模型，上层JVM...","link":"","photos":[],"count_time":{"symbolsCount":"63k","symbolsTime":"57 mins."},"categories":[],"tags":[{"name":"language","slug":"language","count":3,"path":"api/tags/language.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}