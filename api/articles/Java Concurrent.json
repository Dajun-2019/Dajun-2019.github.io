{"title":"Java并发","uid":"75ca176d6b382373bec123f05862c849","slug":"Java Concurrent","date":"2023-04-13T23:56:43.000Z","updated":"2023-08-05T13:48:15.381Z","comments":true,"path":"api/articles/Java Concurrent.json","keywords":null,"cover":[],"content":"<h1 id=\"Java并发\"><a href=\"#Java并发\" class=\"headerlink\" title=\"Java并发\"></a>Java并发</h1><h2 id=\"1-线程\"><a href=\"#1-线程\" class=\"headerlink\" title=\"1.线程\"></a>1.线程</h2><ol>\n<li><p>线程</p>\n<ul>\n<li><p>线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/threadModel.png\" alt=\"threadModel\"></p>\n</li>\n<li><p>线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N）</p>\n<ul>\n<li>Java使用用户线程模型，上层JVM通过协作式调度来管理这些用户线程，可以在一个线程执行过程中暂停切换到另一线程执行，底层JVM将Java线程映射到操作系统的线程，由操作系统调度和管理</li>\n<li>启动main函数时启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个（主）线程。多个线程共享进程的堆（新建的对象）和方法区资源（已加载的类信息、静态变量、常量、JIT代码），但每个线程有自己的程序计数器、虚拟机栈和本地方法栈</li>\n<li>多线程：减少了上下文的开销，提高了系统的并发能力，减弱IO与CPU的速度差；但会造成死锁、内存泄漏、线程不安全等问题</li>\n</ul>\n</li>\n<li><p>线程安全</p>\n<ul>\n<li><p>线程安全：描述的对象可以是函数也可以是类，线程安全意味者不同线程并发执行相同的函数，或者不同线程执行一个类的不同函数，因为线程切换，函数内的指令都可以任意交叉执行，最终任意执行顺序得到的结果都是相同的，符合预期的</p>\n</li>\n<li><p>临界区：可能会引起线程不安全的局部代码块，有两个特征，一是访问了共享资源、二是包含复合操作（先检查在执行、先读取再修改后写入）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;先检查再执行\npublic class Singleton &#123;\n    private static Singleton instance;\n    private Singleton()&#123;&#125;\n    public static Singleton getInstance()&#123;\n        if (instance &#x3D;&#x3D; null) &#123;\n            instance &#x3D; new Singleton();\n        &#125;\n        return instance;\n    &#125;\n&#125;\n&#x2F;&#x2F;先读取再修改后写入\npublic class Demo &#123;\n    private int count &#x3D; 0;\n    public void increment()&#123;\n        count++;\n    &#125;\n&#125;</code></pre></li>\n<li><p>同步互斥：用于保证线程安全的访问临界区资源的方法</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程创建</p>\n<ul>\n<li><p>实现Runnable接口的run()和start()；继承Thread类重写run方法和start方法，==可用Thread类的已有方法==</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;class ThreadDemo extends Thread &#123; 内容同下 &#125; \nclass RunnableDemo implements Runnable &#123;\n   private Thread t;\n   private String threadName;\n   \n   RunnableDemo( String name) &#123; threadName &#x3D; name; &#125;\n   \n   public void run() &#123;\n      &#x2F;&#x2F;线程内需要做的操作\n   &#125;\n   \n   public void start () &#123;\n      if (t &#x3D;&#x3D; null) &#123;\n         t &#x3D; new Thread (this, threadName);\n         t.start ();\n      &#125;\n   &#125;\n&#125;</code></pre></li>\n<li><p>通过Callable接口和FutureTask类创建线程，==可创建有返回值的线程（在call函数中实现）==</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CallableThreadTest implements Callable&lt;Integer&gt; &#123;\n    public static void main(String[] args)  \n    &#123;  \n        CallableThreadTest ctt &#x3D; new CallableThreadTest();  \n      \t&#x2F;&#x2F;使用FutureTask包装Callable接口的实现类\n        FutureTask&lt;Integer&gt; ft &#x3D; new FutureTask&lt;&gt;(ctt);\n        for(int i &#x3D; 0;i &lt; 100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);  \n            if(i&#x3D;&#x3D;20)  \n            &#123;  \n                new Thread(ft,&quot;有返回值的线程&quot;).start();&#x2F;&#x2F;call相当于run，但是有返回值  \n            &#125;  \n        &#125;  \n        try  \n        &#123;  \n            System.out.println(&quot;子线程的返回值：&quot;+ft.get());&#x2F;&#x2F;得到call函数的返回值   \n        &#125; catch (InterruptedException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125; catch (ExecutionException e)  \n        &#123;  \n            e.printStackTrace();  \n        &#125;  \n  \n    &#125;\n    @Override  \n    public Integer call() throws Exception  \n    &#123;  \n        int i &#x3D; 0;  \n        for(;i&lt;100;i++)  \n        &#123;  \n            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i);  \n        &#125;  \n        return i;  \n    &#125;  \n&#125;</code></pre></li>\n<li><p>==注意事项==</p>\n<ul>\n<li>直接使用Thread类的run方法：new一个Thread类，线程进入NEW状态，调用start方法，启动一个线程并使线程进入READY状态，当分配到时间片后就可以开始运行了，start会执行线程的相应准备工作，然后自动执行run方法的内容，这是真正的多线程工作，但是直接执行run方法，会把run方法当作一个main线程下的普通方法来执行，并不会在某个线程中执行它，所以这并不是多线程工作</li>\n<li>sleep与wait的区别：sleep是Thread类的静态本地方法，wait则是Object类的本地方法<ul>\n<li>sleep方法没有释放锁，wait释放了锁<ul>\n<li>wait是让获得对象锁的进程实现等待，会自动释放当前线程占有的对象锁，每个对象（Object）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对应的对象（Object）而非当前的线程（Thread）</li>\n<li>因为Sleep是让当前线程暂停执行，不涉及到对象类，所以也不需要对象锁</li>\n</ul>\n</li>\n<li>sleep常用于暂停执行，wait方法常用于线程间交互/通信</li>\n<li>wait方法被调用后，线程不会自动苏醒，需要notify方法或notifyAll方法，sleep执行完线程会自动苏醒，或者也可以使用<code>wait(long timeout)</code>超时后自动苏醒</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程池创建</p>\n<ul>\n<li><p>线程池出现的原因：因为线程过多会增加创建、调度线程的开销，所以通过线程池提前创建若干线程，一方面避免了处理任务时频繁的，创建销毁线程的开销，另一方面避免了线程数量膨胀导致的过分调度问题，并且可以集中管理线程资源，提高系统稳定性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadPoolExecutor extends AbstractExecutorService &#123;\n\n    &#x2F;**\n     * 核心线程数\n     * 当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，\n     * 也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize\n     *&#x2F;\n    private volatile int corePoolSize;\n\n    &#x2F;**\n     * 最大线程数\n     * 当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。\n     * 另外，对于无界队列，可忽略该参数\n     *&#x2F;\n    private volatile int maximumPoolSize;\n    &#x2F;**\n     * 线程存活保持时间\n     * 当线程池中线程数 超出核心线程数，且线程的空闲时间也超过 keepAliveTime时，\n     * 那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数\n     *&#x2F;\n    private volatile long keepAliveTime;\n\n    &#x2F;**\n     * 任务队列\n     * 用于传输和保存等待执行任务的阻塞队列\n     *&#x2F;\n    private final BlockingQueue&lt;Runnable&gt; workQueue;\n\n    &#x2F;**\n     * 线程工厂\n     * 用于创建新线程。threadFactory 创建的线程也是采用 new Thread() 方式，threadFactory\n     * 创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池中线程的编号\n     *&#x2F;\n    private volatile ThreadFactory threadFactory;\n\n    &#x2F;**\n     * 线程饱和策略\n     * 当线程池和队列都满了，再加入的线程会执行此策略\n     *&#x2F;\n    private volatile RejectedExecutionHandler handler;\n\n    &#x2F;**\n     * 构造方法提供了多种重载，但实际上都使用了最后一个重载 完成了实例化\n     *&#x2F;\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), defaultHandler);\n    &#125;\n\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&lt;Runnable&gt; workQueue,\n                              ThreadFactory threadFactory) &#123;\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             threadFactory, defaultHandler);\n    &#125;\n\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&lt;Runnable&gt; workQueue,\n                              RejectedExecutionHandler handler) &#123;\n        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n             Executors.defaultThreadFactory(), handler);\n    &#125;\n\n    public ThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue&lt;Runnable&gt; workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler) &#123;\n        if (corePoolSize &lt; 0 ||\n            maximumPoolSize &lt;&#x3D; 0 ||\n            maximumPoolSize &lt; corePoolSize ||\n            keepAliveTime &lt; 0)\n            throw new IllegalArgumentException();\n        if (workQueue &#x3D;&#x3D; null || threadFactory &#x3D;&#x3D; null || handler &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        this.corePoolSize &#x3D; corePoolSize;\n        this.maximumPoolSize &#x3D; maximumPoolSize;\n        this.workQueue &#x3D; workQueue;\n        this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);\n        this.threadFactory &#x3D; threadFactory;\n        this.handler &#x3D; handler;\n    &#125;\n\n    &#x2F;**\n     * 执行一个任务，但没有返回值\n     *&#x2F;\n    public void execute(Runnable command) &#123;\n        if (command &#x3D;&#x3D; null)\n            throw new NullPointerException();\n        int c &#x3D; ctl.get();\n        if (workerCountOf(c) &lt; corePoolSize) &#123;\n            if (addWorker(command, true))\n                return;\n            c &#x3D; ctl.get();\n        &#125;\n        if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;\n            int recheck &#x3D; ctl.get();\n            if (! isRunning(recheck) &amp;&amp; remove(command))\n                reject(command);\n            else if (workerCountOf(recheck) &#x3D;&#x3D; 0)\n                addWorker(null, false);\n        &#125;\n        else if (!addWorker(command, false))\n            reject(command);\n    &#125;\n\n    &#x2F;**\n     * 提交一个线程任务，有返回值。该方法继承自其父类 AbstractExecutorService，有多种重载，这是最常用的一个。\n     * 通过future.get()获取返回值（阻塞直到任务执行完）\n     *&#x2F;\n    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;\n        if (task &#x3D;&#x3D; null) throw new NullPointerException();\n        RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);\n        execute(ftask);\n        return ftask;\n    &#125;\n\n    &#x2F;**\n     * 关闭线程池，不再接收新的任务，但会把已有的任务执行完\n     *&#x2F;\n    public void shutdown() &#123;\n        final ReentrantLock mainLock &#x3D; this.mainLock;\n        mainLock.lock();\n        try &#123;\n            checkShutdownAccess();\n            advanceRunState(SHUTDOWN);\n            interruptIdleWorkers();\n            onShutdown(); &#x2F;&#x2F; hook for ScheduledThreadPoolExecutor\n        &#125; finally &#123;\n            mainLock.unlock();\n        &#125;\n        tryTerminate();\n    &#125;\n\n    &#x2F;**\n     * 立即关闭线程池，已有的任务也会被抛弃\n     *&#x2F;\n    public List&lt;Runnable&gt; shutdownNow() &#123;\n        List&lt;Runnable&gt; tasks;\n        final ReentrantLock mainLock &#x3D; this.mainLock;\n        mainLock.lock();\n        try &#123;\n            checkShutdownAccess();\n            advanceRunState(STOP);\n            interruptWorkers();\n            tasks &#x3D; drainQueue();\n        &#125; finally &#123;\n            mainLock.unlock();\n        &#125;\n        tryTerminate();\n        return tasks;\n    &#125;\n\n    public boolean isShutdown() &#123;\n        return ! isRunning(ctl.get());\n    &#125;\n&#125;</code></pre></li>\n<li><p>ThreadPoolExecutor</p>\n<ul>\n<li><p>基础</p>\n<ul>\n<li><p>继承链</p>\n<ul>\n<li><code>Executor</code>接口：声明了execute方法，使得用户不需要关注如何创建线程， 只需要传入实现了Runnable接口的线程任务类</li>\n<li><code>ExecutorService</code>接口：声明了执行一批异步生成Future的方法；声明了管控线程池的方法（关闭等方法）</li>\n<li><code>AbstractExecutorService</code>：将执行任务的流程串联起来，保证下层的实现只需关注一个执行任务的方法</li>\n<li><code>ThreadPoolExecutor</code>：实现复杂的运行部分（维护自身的生命周期、管理线程和任务）</li>\n</ul>\n</li>\n<li><p>参数：corePoolSize、maximumPoolSize、keepAliveTime、unit、workQueue、threadFactory、handler</p>\n</li>\n<li><p>运行状态</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/threadPoolExecutor.png\" alt=\"threadPoolExecutor\"></p>\n</li>\n</ul>\n</li>\n<li><p>池内线程创建过程：首先使用工厂函数针对新任务创建线程直到数量达到核心线程池数量，然后将新任务存储在工作队列中，待工作队列满了之后创建一个新线程来处理任务（没任务一段时间后会被销毁），直到总线程数量达到最大线程池数量后，后续的新任务根据拒绝策略来确定对应操作</p>\n<ul>\n<li>worker进程实现了Runnable接口继承自AQS，持有一个线程thread（通过TheradFactory来创建），一个初始化任务firstTask</li>\n<li>确定线程状态：线程池通过一张hash表来保存线程的引用，通过增删引用来控制线程的生命周期。因为使用了AQS锁来实现独占锁，根据独占锁的状态反应线程现在的执行状态</li>\n<li>worker线程增加（addWorker方法）：增加一个线程，有两个参数firstTask和core，根据core的值判断现有线程数在哪个区见</li>\n<li>worker线程的回收：线程池中的回收依赖JVM自动的回收，线程池做的工作是根据当前线程池的状态维护一定数量的线程引用，防止这部分线程倍JVM回收，当线程池决定哪些线程需要回收时，只需要将其引用消除即可</li>\n<li>worker线程执行任务：worker类中的run方法调用了<code>runWorker</code>方法来执行任务，轮询获取任务，再获取锁，直到没有任务</li>\n</ul>\n</li>\n<li><p>任务与线程的匹配：通过生产者消费者模型，缓存任务，供线程池针对任务进行线程的分配</p>\n<ul>\n<li><p>线程池使用AtomicInteger变量维护：运行状态（runState）和线程数量（workerCount）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;高三位保存runState，低29位保存workerCount\nprivate final AtomicInteger ctl &#x3D; new AtomicInteger(ctlOf(RUNNING, 0));</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>示例</p>\n<ul>\n<li><p>Executors 类 通过 ThreadPoolExecutor 封装了 4 种常用的线程池：CachedThreadPool，FixedThreadPool，ScheduledThreadPool 和 SingleThreadExecutor。其功能如下。</p>\n<ul>\n<li><p>ScheduledThreadPool：适用于执行 延时 或者 周期性 任务。</p>\n</li>\n<li><p>FixedThreadPool：它的核心线程数和最大线程数是一样的，所以可以把它看作是<strong>固定线程数</strong>的线程池，它的特点是线程池中的线程数除了初始阶段需要从 0 开始增加外，之后的线程数量就是固定的，就算任务数超过线程数，线程池也不会再创建更多的线程来处理任务，而是会把超出线程处理能力的任务放到任务队列中进行等待。而且就算任务队列满了，到了本该继续增加线程数的时候，由于它的最大线程数和核心线程数是一样的，所以也无法再增加新的线程了。</p>\n</li>\n<li><p>CachedThreadPool：可以称作可缓存线程池，它的特点在于线程数是几乎可以<strong>无限增加</strong>的（实际最大可以达到 Integer.MAX_VALUE，为 2^31-1，这个数非常大，所以基本不可能达到），而当线程闲置时还可以对线程进行回收。也就是说该线程池的线程数量不是固定不变的，当然它也有一个用于存储提交任务的队列，但这个队列是 SynchronousQueue，队列的容量为0，实际不存储任何任务，它只负责对任务进行中转和传递，所以效率比较高。适用于执行大量短生命周期的异步任务。</p>\n</li>\n<li><p>SingleThreadExecutor：它会使用唯一的线程去执行任务，原理和 FixedThreadPool 是一样的，只不过这里线程只有一个（<strong>单线程</strong>），如果线程在执行任务的过程中发生异常，线程池也会重新创建一个线程来执行后续的任务。这种线程池由于只有一个线程，所以非常适合用于所有任务都需要按被提交的顺序依次执行的场景，而前几种线程池不一定能够保障任务的执行顺序等于被提交的顺序，因为它们是多线程并行执行的。</p>\n</li>\n<li><p>SingleThreadScheduledExecutor：它实际和 ScheduledThreadPool 线程池非常相似，它只是 ScheduledThreadPool 的一个特例，内部只有一个线程。</p>\n</li>\n</ul>\n</li>\n<li><p>ThreadPoolExecutor</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadPoolExecutorDemo &#123;\n\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建一个线程池，包含5个线程\n        ThreadPoolExecutor executor &#x3D; (ThreadPoolExecutor) Executors.newFixedThreadPool(5);\n        &#x2F;&#x2F; 提交10个任务给线程池执行\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            Runnable worker &#x3D; new WorkerThread(&quot;Task &quot; + i);\n            executor.execute(worker);\n        &#125;\n        &#x2F;&#x2F; 关闭线程池\n        executor.shutdown();\n        while (!executor.isTerminated()) &#123;\n            &#x2F;&#x2F; 等待线程池中的任务执行完毕\n        &#125;\n        System.out.println(&quot;All tasks have been completed.&quot;);\n    &#125;\n&#125;\n\nclass WorkerThread implements Runnable &#123;\n    private String taskName;\n\n    public WorkerThread(String taskName) &#123;\n        this.taskName &#x3D; taskName;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot; executing &quot; + taskName);\n        try &#123;\n            &#x2F;&#x2F; 模拟执行任务需要的时间\n            Thread.sleep(1000);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n</code></pre></li>\n<li><p>Executor框架的Executors</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;1.创建\nExecutorService service &#x3D; Executors.newFixedThreadPool(10);\n&#x2F;&#x2F;2.执行\nservice.execute(new MyThread());\nservice.execute(new MyThread());\nservice.execute(new MyThread());\nservice.execute(new MyThread());\n&#x2F;&#x2F;3.关闭连接\nservice.shutdown();</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-互斥\"><a href=\"#2-互斥\" class=\"headerlink\" title=\"2.互斥\"></a>2.互斥</h2><h3 id=\"2-1synchronized\"><a href=\"#2-1synchronized\" class=\"headerlink\" title=\"2.1synchronized\"></a>2.1synchronized</h3><ol>\n<li><p>粒度：对象锁（this、newObject）、局部代码锁、类锁（Demo.class）</p>\n<ul>\n<li><p>静态synchronized方法和非静态synchronized方法之间的调用不互斥（一个是类的锁一个是实例对象的锁）</p>\n</li>\n<li><p>尽量不要使用<code>synchronized(String a)</code>，因为JVM中，字符串常量池具有缓存功能</p>\n</li>\n<li><p>构造方法不能使用 <code>synchronized</code> 关键字修饰，因为构造方法本身就属于线程安全的，不存在同步的构造方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public synchronized void add(int value) &#123;&#125; &#x2F;&#x2F;方法\nsynchronized (this)&#123;&#125; &#x2F;&#x2F;局部代码块\nsynchronized (obj1) &#123;&#125; &#x2F;&#x2F;内部的一个对象 Object obj1 &#x3D; new Object()\nsynchronized (Wallet.class) &#x2F;&#x2F;类锁</code></pre></li>\n</ul>\n</li>\n<li><p>锁类别：偏向锁（一个）、轻量级锁（不竞争）、重量级锁（竞争）</p>\n<ul>\n<li><p>通过MarkWork字段辨别锁的类别，新创建的对象处于无锁状态，随后自动变为偏向锁状态，线程可以通过CAS操作竞争偏向锁（单进程使用），竞争成功则执行完任务，执行完后锁会继续保持偏向锁状态，竞争失败则请求线程将锁升级为轻量级锁</p>\n</li>\n<li><p>升级过程先暂停（JVM的STW）持有锁进程，如其在运行synchronized代码，则升级为轻量级锁（线程交叉使用不存在竞争），否则将MarkWork设置为无锁状态（偏向锁升级代价大，不如直接升级为轻量级锁）</p>\n</li>\n<li><p>在轻量级锁状态，如果通过（自适应）自旋方式循环执行CAS操作请求锁达到一定数量仍未获得时，就申请升级为重量级锁，唤醒等待重量级锁的进程</p>\n<ul>\n<li><p>锁升级：通过CAS操作，持有锁的线程继续执行，请求锁的线程负责升级任务，包括创建Monitor锁，将自己放到Monitor锁的_cxq中，调用OS系统调用来阻塞自己</p>\n</li>\n<li><p>解锁：先检查锁标志位，如果没有升级，只需要使用CAS操作解锁即可；如果已升级为重量级锁，那么持有轻量级锁的线程去唤醒等待重量级锁的进程</p>\n</li>\n<li><p>Monitor锁（hotspot）：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class ObjectlMonitor &#123;\n    void * volatile _object;&#x2F;&#x2F;该Monitor锁所属的对象\n    void * volatile _owner;&#x2F;&#x2F;获取到该Monitor锁的线程\n    ObjectWaiter * volatile _cxq;&#x2F;&#x2F;没有获取到锁的线程暂时加入_cxq\n    ObjectWaiter * volatile _EntryList;&#x2F;&#x2F;存储等待被唤醒的线程\n    &#x2F;&#x2F;存储调用了wait()的线程，用来实现wait()、notify()线程同步功能\n\t\t&#x2F;&#x2F;wait、notify等方法也依赖于monitor对象\n    ObjectWaiter * volatile _waitSet;\n    &#x2F;&#x2F;...\n&#125;</code></pre>\n\n<ul>\n<li>多个对象通过CAS操作（底层为cmpxchg指令）竞争_owner字段，没有获取到锁的线程加入_cxq队列中等待，待锁释放先通知_EntryList队列中的线程通过CAS操作竞争_owner字段，如果_EntryList队列为空，则将_cxq队列中移到_EntryList队列（一个负责存，一个负责取，减少并发冲突）</li>\n<li>内核线程执行上述步骤没得到锁时，会调用Linux的park函数自行阻塞；阻塞线程获取到锁之后，调用unpark函数来取消对应内核线程的阻塞状态</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>锁优化</p>\n<ul>\n<li>锁消除：虚拟机在执行JIT编译时，有时会根据对代码的分析(逃逸分析)，去掉某些没有必要的锁（局部变量的锁）</li>\n<li>锁粗化：虚拟机在执行JIT编译时，有时会扩大加锁范围，将对多个小范围代码的加锁，合并一个对大范围代码的加锁（如for循环内的锁）</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-2锁\"><a href=\"#2-2锁\" class=\"headerlink\" title=\"2.2锁\"></a>2.2锁</h3><ol>\n<li><p>锁类别</p>\n<ul>\n<li>可重入锁：可以被同一个线程多次加锁的锁，即在锁没有解锁前，再次加锁，通过变量记录重入次数，JUC提供的锁都是可重入锁</li>\n<li>公平锁：线程会按照请求的先后顺序获得锁。synchronized是非公平锁（新请求可插队），ReentrantLock既支持公平锁也支持非公平锁，默认为非公平锁，通过在构造函数中添加true可声明为公平锁。非公平锁的性能比公平锁更好。ReentrantLock通过AQS（抽象队列同步器）来排队等待锁的线程</li>\n<li>可中断锁：对于synchronized来说，一个线程在阻塞等待锁时，是无法响应中断的，即不可被打断。JUC Lock接口提供了<code>lockInterruptibly()</code>函数，支持可响应中断的方式来请求锁（用于线程池，关闭正在执行的线程）</li>\n<li>非阻塞锁：JUC提供了<code>tryLock()</code>函数，支持非阻塞的方式获取锁，如果锁已经被其他线程获取，则不阻塞直接返回</li>\n<li>可超时锁：JUC提供了带参数的<code>tryLock()</code>函数，支持非阻塞获取锁的同时设置超时时间，tryLock()也可被中断，主要用于对响应时间敏感的系统，如Tomcat</li>\n<li>读写锁：为了提到并发度，可多次获得读锁，JUC提供了ReadWrite接口和其实现类<code>ReetrantReadWriteLock</code>。读锁是一种共享锁，可以被多个线程同时获取，写锁是排他锁，同时只能被一个线程获取，读写锁之间也是排他的（写优先）</li>\n<li>乐观读锁：<code>StampedLock</code>是对<code>ReadWriteLock</code>的进一步优化，提供了读锁、写锁和乐观读锁，其中的读锁和写锁与ReadWriteLock中的类似，乐观读锁是对读锁的进一步优化，在读多写少的时候，大部分读操作都不会被写操作干扰，因此连读锁都不需要加，只有验证真正有被写操作干扰的情况下，再加读锁即可</li>\n</ul>\n</li>\n<li><p>AQS</p>\n<ul>\n<li><p>抽象队列同步器，与synchronized底层的ObjectMonitor类相似，都实现了排队线程、阻塞线程和唤醒线程等功能，但只有一个队列，且基于Java语言实现，是锁实现的原理，在ReentrantLock类有体现（Sync、NofairSync、FairSync都继承自<code>AbstractQueuedSynchronizer</code>）</p>\n</li>\n<li><p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。在 CLH 同步队列中，一个节点表示一个线程，它保存着线程的引用（thread）、 当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）</p>\n</li>\n<li><p>方法</p>\n<ul>\n<li><p>AQS定义了8个模板方法，可以分为两组：独占模式（Lock）和共享模式（Semaphore）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;独占模式\npublic final void acquire(int arg) &#123; ...&#125;\npublic final void acquirelnterruptibly(int arg)throws InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)throws InterruptedException &#123; ...&#125;\npublic final boolean release(int arg) &#123; ...&#125;\n&#x2F;&#x2F;共享模式\npublic final void acquireShared(int arg) &#123; ...&#125;\npublic final void acquireSharedInterruptibly(int arg)throws InterruptedException &#123; ...&#125;\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)throws InterruptedException &#123; ...&#125;\npublic final boolean releaseShared(int arg) &#123; ...&#125;</code></pre></li>\n<li><p>AQS提供了4个抽象方法：没有声明为abstract是为了减少代码量，更灵活编写代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;独占模式\nprotected boolean tryAcquire(int arg)&#123;throw new UnsupportedOperationException();&#125;\nprotected boolean tryRelease(int arg)&#123;throw new UnsupportedOperationException();&#125;\n&#x2F;&#x2F;共享模式\nprotected int tryAcquireShared(int arg) &#123;throw new UnsupportedOperationException();&#125;\nprotected boolean tryReleaseShared(int arg) &#123;throw new UnsupportedOperationException();&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>ReetrantLock：定义了两个继承自AQS的子类：NofairSync和FairSync，分别用来实现非公平锁和公平锁，并且因为底层释放锁的逻辑相同，故又抽象出公共父类Sync</p>\n<ul>\n<li><p>Sync，NofairSync和FairSync（根据构造函数的不同使用不同的Sync实现）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReentrantLock implements Lock, java.io.Serializable &#123;\n\t  private final sync sync;\n\t  \n\t  abstract static class Sync extends AbstractQueuedSynchronizer &#123; ...&#125;\n\t  static final class NonfairSync extends Sync &#123; ...&#125;\n\t\tstatic final class FairSync extends Sync &#123; ...&#125;\n\t    \n\t\tpublic ReentrantLock()&#123;\n\t\t\t\tsync &#x3D; new NonfairSync();\n\t   &#125;\n\t\tpublic ReentrantLock(boolean fair) &#123;\n\t\t\t\tsync &#x3D; fair ? new FairSync() : new NonfairSync();\n\t   &#125;\n\t        \n\t\tpublic void lock()&#123;sync.acquire(1);&#125;\n\t\tpublic void unlock() &#123;sync.release(1);&#125;\n\t\t&#x2F;&#x2F;...省略其他方法...\n\t    &#125;\n&#125;</code></pre></li>\n<li><p>acquire：改state值，是否查看等待队列（公平/不公平），addWaiter（自旋+CAS）、acquireQueued（唤醒后竞争锁）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Sync&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic final void acquire(int arg) &#123;\n    &#x2F;&#x2F;1.调用tryAcquire去竞争获取锁，如果成功，则直接返回\n    &#x2F;&#x2F;2.调用addWaiter，将线程包裹为Node节点放入等待队列的尾部\n    &#x2F;&#x2F;3.调用acquireQueued阻塞当前线程，\n    if ( !tryAcquire(arg) &amp;&amp; acquireQueued( addWaiter(Node.EXCLUSIVE), arg ) )\n        &#x2F;&#x2F;用来处理中断，如果在等待锁的过程中，被其它线程中断，\n        &#x2F;&#x2F;则在获取锁之后，将现成的中断标记设置为true\n        selfInterrupt();\n&#125;\n\nstatic final class NonfairSync extends Sync &#123;\n    &#x2F;&#x2F;尝试获取锁，成功返回true，失败返回false。AQS用于实现锁时，acquires&#x3D;1\n    protected final boolean tryAcquire(int acquires)&#123;\n        final Thread current &#x3D; Thread.currentThread();\n        int c &#x3D; getState(); &#x2F;&#x2F;获取state值\n        if (c &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;锁没有被其他线程占用\n            if (compareAndSetstate(0,acquires)) &#123; &#x2F;&#x2F; CAS设置state值为1\n                setExclusiveOwnerThread(current);&#x2F;&#x2F; 设置exclusiveownerThread\n                return true;&#x2F;&#x2F;获取锁成功\n            &#125;\n        &#125;else if (current &#x3D;&#x3D; getExclusiveOwnerThread())&#123;&#x2F;&#x2F; 锁已被自己占用，可重入\n            int nextc &#x3D; c + acquires; &#x2F;&#x2F; state+1\n            if (nextc &lt; 0)&#x2F;&#x2F;重入次数太多，超过了int最大值，溢出为负数，此情况罕见\n                throw new Error(&quot;Maximum lock count exceeded&quot;);\n            setState(nextc); &#x2F;&#x2F; state&#x3D;state+1,state记录重入的次数，解锁的时候用\n            return true;&#x2F;&#x2F;获取锁成功\n        &#125;\n        return false;&#x2F;&#x2F;获取锁失败\n    &#125;\n&#125;\nstatic final class FairSync extends Sync &#123;\n    protected final boolean tryAcquire(int acquires) &#123;\n        final Thread current &#x3D; Thread.currentThread();\n\t\t\t\tint c &#x3D; getState();\n        if (c &#x3D;&#x3D; 0)&#123;\n            if (!hasQueuedPredecessors() &amp;&amp;&#x2F;&#x2F;等待队列中没有线程时才获取锁\n                compareAndSetstate(0, acquires))&#123;\n                setExclusiveownerThread(current);\n                return true;\n            &#125;\n        &#125;else if (current &#x3D;&#x3D; getExclusiveOwnerThread())&#123;\n            int nextc &#x3D; C + acquires;\n            if (nextc &lt; 0)\n                throw new Error(&quot;Maximum lock count exceeded&quot;);setState(nextc);\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;通过自旋和CAS操作解决往链表尾部添加节点和特殊处理链表为空所存在的线程安全问题\nprivate Node addWaiter(Node mode)&#123;\n    Node node &#x3D; new Node(Thread.currentThread(), mode);\n    &#x2F;&#x2F;自旋执行CAS操作，直到成功为止\n    for (;;) &#123;\n        Node t &#x3D; tail;\n        if (t &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;链表为空，添加虚拟头节点\n            &#x2F;&#x2F;CAS操作解决添加虚拟头节点的线程安全问题\n            if (compareAndSetHead(null, new Node()))\n                tail &#x3D; head;\n        &#125;else &#123;&#x2F;&#x2F;链表不为空\n            node.prev &#x3D; t;\n            &#x2F;&#x2F;CAS操作解决了同时往链表尾部添加节点时的线程安全问题\n            if (compareAndSetTail(t, node)) &#123;\n                t.next &#x3D; node;\n                return t;\n            &#125;\n        &#125;\n    &#125;\n    return node;\n&#125;\n\n&#x2F;&#x2F;主要有两部分逻辑，使用tryAcquire函数来竞争锁和使用park()函数来阻塞线程\n&#x2F;&#x2F;采用for循环来交替执行这两个逻辑，为了在线程被唤醒后，并不是直接获取锁，\n&#x2F;&#x2F;而是重新竞争锁，如果竞争失败，则需要再次被阻塞\nfinal boolean acquireQueued(final Node node, int arg) &#123;\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;)&#123;\n            &#x2F;&#x2F;使用tryAcquire()函数来竞争锁\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return interrupted;\n            &#125;\n            &#x2F;&#x2F;调用park()函数来阻塞线程，等待其他线程调用unpark()函数唤醒\n            if (parkAndCheckInterrupt()) interrupted &#x3D; true;\n        &#125;\n    &#125;finally &#123;\n        if (failed) cancelAcquire(node);\n    &#125;\n&#125;\nprivate final boolean parkAndChecklnterrupt() &#123;\n    LockSupport.park(this);&#x2F;&#x2F;底层也是调用JVM提供的native park()函数来实现\n    return Thread.interrupted();\n&#125;</code></pre></li>\n<li><p>release：sync和nofairsync的实现相同，state-1→<code>setExclusiveownerThread</code>(state==0)-&gt;<code>setState</code>(state != 0有重入)</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final boolean release(int arg) &#123;\n    &#x2F;&#x2F;tryRelease释放锁\n    if (tryRelease(arg)) &#123;\n        Node h &#x3D; head;\n        if (h !&#x3D; null &amp;&amp; h.waitStatus !&#x3D; 0)\n            unparkSuccessor(h);&#x2F;&#x2F;内部调用unpark()函数，唤醒链表首节点对应的线程\n        return true;\n    &#125;\n    return false;\n&#125;\n&#x2F;&#x2F;公平锁和非公平锁的实现相同\nstatic final class Sync extends AbstractQueuedSynchronizer &#123;\n    &#x2F;&#x2F;释放锁，成功返回true，失败返回false。AQS用于实现锁时，releases&#x3D;1\n    protected final boolean tryRelease(int releases)&#123;\n        int c &#x3D; getState() - releases; &#x2F;&#x2F;state-1\n        &#x2F;&#x2F;不持有锁的线程去释放锁，抛出异常\n        if (Thread.currentThread() !&#x3D; getExclusiveownerThread())\n            throw new lllegalMonitorStateException();\n        boolean free &#x3D; false;\n        if (c &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F;stat-1之后为0，解锁\n            free &#x3D; true;\n            setExclusiveownerThread(null);\n        &#125;\n        setState(c); &#x2F;&#x2F;state-1之后不为0，说明锁被重入多次，还不能解锁。\n        return free;\n    &#125;\n&#125;</code></pre></li>\n<li><p>中断机制：lockInterruptibly→acquirelnterruptibly→doAcquireInterruptibly（类似于<code>acquireQueued</code>，但对中断的响应处理不同）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void lockInterruptibly() throws InterruptedException &#123;\n    sync.acquirelnterruptibly(1);\n&#125;\n&#x2F;&#x2F;如果线程中断则抛出异常，否则。调用tryAcquire()竞争获取锁，\n&#x2F;&#x2F;获得失败后调用doAcquireInterruptibly\npublic final void acquirelnterruptibly(int arg) throws InterruptedException &#123;\n    if (Thread.interrupted()) throw new InterruptedException();\n    if (!tryAcquire(arg)) doAcquireInterruptibly(arg);\n&#125;\n&#x2F;&#x2F;与acquireQueued()函数的代码非常相似，唯一区别是对中断的响应处理不同\nprivate void doAcquireInterruptibly(int arg) throws InterruptedException &#123;\n    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n    boolean failed &#x3D; true;\n    try &#123;\n        for(;;)&#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg)) &#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return;\n            &#125;\n            if (parkAndChecklnterrupt())\n                throw new lnterruptedException(); &#x2F;&#x2F;区别:抛出异常! 阻止等待锁\n        &#125;\n    &#125;finally &#123;\n        if (failed) \n            cancelAcquire(node);&#125;\n&#125;</code></pre></li>\n<li><p>超时机制：tryLock→tryAcquireNanos→doAcquireNanos（在<code>acquireInterruptibly</code>的基础上增加了超时机制）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;ReentrantLock&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic boolean tryLock(long timeout,TimeUnit unit)\n    throws InterruptedException &#123;\n    return sync.tryAcquireNanos(1 , unit.toNanos(timeout));\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;AbstractQueueSynchronizer&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123;\n    &#x2F;&#x2F;如果线程被中断则抛出异常\n    if (Thread.interrupted()) throw new InterruptedException();\n    &#x2F;&#x2F;调用tryAcquire竞争获取锁，成功则返回，失败则调用doAcquireNanos\n    return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);\n&#125;\n&#x2F;&#x2F;在acquireInterruptibly函数基础上，添加了对超时的处理机制\nprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123;\n    if (nanosTimeout &lt;&#x3D; 0L) return false;\n    final long deadline &#x3D; System.nanoTime() + nanosTimeout;\n    final Node node &#x3D; addWaiter(Node.EXCLUSIVE);\n    boolean failed &#x3D; true;\n    try &#123;\n        for (;;)&#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head &amp;&amp; tryAcquire(arg))&#123;\n                setHead(node);\n                p.next &#x3D; null; &#x2F;&#x2F; help GC\n                failed &#x3D; false;\n                return true;\n            &#125;\n            nanosTimeout &#x3D; deadline - System.nanoTime();\n            if (nanosTimeout &lt;&#x3D; 0L) return false;\n            if(nanosTimeout &gt; spinForTimeoutThreshold)&#x2F;&#x2F;不着急阻塞，先自旋—下\n                LockSupport.parkNanos(this, nanosTimeout);&#x2F;&#x2F;超时阻塞\n            if (Thread.interrupted()) throw new InterruptedException();\n        &#125;\n    &#125;finally &#123;\n        if (failed) cancelAcquire(node);\n    &#125;\n&#125;\n&#x2F;&#x2F;为了支持超时阻塞，在阻塞线程时，doAcquireNanos调用parkNanos函数\n&#x2F;&#x2F;synchronized中park函数实现如下，parkNanos只将其中的pthread_cond_wait换成了\n&#x2F;&#x2F;pthread_cond_timewait，便可实现超时等待。\npthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER;\npthread_cond_t cond &#x3D; PTHREAD_COND_INITIALIZER;\nvoid park() &#123;\n    pthread_mutex_lock(&amp;mutex);\n    pthread_cond_wait(&amp;cond,&amp;mutex);&#x2F;&#x2F;阻塞等待其他线程发送信号\n    pthread_mutex_unlock(&amp;mutex);\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>ReadWriteLock：读锁不可以转成写锁，但在写锁释放前加读锁，在写锁释放后线程持有的锁自动从写锁降级为读锁</p>\n<ul>\n<li><p>state：低16位写锁、高16位读锁</p>\n<ul>\n<li>低16位表示，0表示没有加写锁，1表示已经加写锁，大于1表示写锁的可重入次数</li>\n<li>高16位表示，0表示没有加读锁，1表示已经加读锁，大于1表示读锁总共被获取了多少次（每个线程对读锁重入的次数相加），使用ThreadLocal变量存储重入次数</li>\n</ul>\n</li>\n<li><p>写锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected final boolean tryAcquire(int acquires) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    int w &#x3D; exclusiveCount(c);&#x2F;&#x2F;高16位的值，也就是写锁的加锁情况\n    &#x2F;&#x2F;1.已经加读锁或写锁（state!&#x3D;0）\n    if (c !&#x3D; 0) &#123;\n        &#x2F;&#x2F; 已加读锁(w&#x3D;&#x3D;0)或者当前加写锁的线程不是自己\n        if (w &#x3D;&#x3D; 0 || current !&#x3D; getExclusiveOwnerThread())\n            return false;&#x2F;&#x2F;去排队\n        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        &#x2F;&#x2F; 获取到了写锁\n        setState(c + acquires);&#x2F;&#x2F;更新写锁的重入次数\n        return true;\n    &#125;\n    &#x2F;&#x2F;2.没有加锁（state&#x3D;0）\n    if (writerShouldBlock() || !compareAndSetState(c, c + acquires))\n        return false;&#x2F;&#x2F;去排队\n    setExclusiveOwnerThread(current);\n    return true;&#x2F;&#x2F;获取了锁\n&#125;\n&#x2F;&#x2F;writerShouldBlock函数控制锁是否为公平锁，在state&#x3D;0，也就是没有加读锁和\n&#x2F;&#x2F;写锁的情况下，如果writerShouldBlock返回值为true，那么线程不尝试竞争锁，而是直接去排队，\n&#x2F;&#x2F;如果writerShouldBlock返回值是false，那么线程尝试竞争锁，失败再去排队。\n&#x2F;&#x2F;对于非公平锁，总是返回false，对于公平锁如果等待队列中有线程，则返回true</code></pre></li>\n<li><p>读锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void acquireShared(int arg) &#123;\n    if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争读锁\n        doAcquireShared(arg);&#x2F;&#x2F;竞争失败去排队\n&#125;\n&#x2F;&#x2F;返回-1表示竞争锁失败，返回1表示竞争锁成功\nprotected final int tryAcquireShared(int unused) &#123;\n    Thread current &#x3D; Thread.currentThread();\n    int c &#x3D; getState();\n    &#x2F;&#x2F;一些优化代码\n    return fullTryAcquireShared(current);\n&#125;\nfinal int fullTryAcquireShared(Thread current) &#123;\n    HoldCounter rh &#x3D; null;\n    &#x2F;&#x2F;如果state没加锁或者是加了读锁，那么线程会通过CAS操作改变state值来竞争锁;\n    &#x2F;&#x2F;如果其他线程也在竟争读锁，并且竞争成功，那么此线程就会竟争失败;\n    &#x2F;&#x2F;于是，此线程就要自旋(for循环)再次尝试去竞争读锁。\n    for (;;) &#123;\n        int c &#x3D; getState();\n        if (exclusiveCount(c) !&#x3D; 0) &#123;&#x2F;&#x2F;已加写锁\n            &#x2F;&#x2F;如果加写锁的线程不是此线程，那么读锁也加不成，直接返回-1\n            &#x2F;&#x2F;否则，读写锁支持锁降级，加了写锁的线程可以再加读锁\n            if (getExclusiveOwnerThread() !&#x3D; current)\n                return -1;\n        &#125; \n        &#x2F;&#x2F;理论上讲，如果没有加写锁，不管有没有加读锁，都可以去竞争读锁了，\n        &#x2F;&#x2F;毕竟读锁是共享锁。但是，存在两个特殊情况:\n        &#x2F;&#x2F;1.对于公平锁来说，如果等待队列不为空，并且当前线程没有持有读锁(重入加\n        &#x2F;&#x2F;锁)，那么，线程就要去排队。\n        &#x2F;&#x2F;2.对于非公平锁来说，如果等待队列中队首线程(接下来要被唤醒的）是写线\n        &#x2F;&#x2F;程，那么，线程就要去排队。这样做是为了避免请求写锁的线程迟迟获取不\n        &#x2F;&#x2F;到写锁。\n        else if (readerShouldBlock()) &#123;&#x2F;&#x2F;上述1和2情况在此时返回true      \n            if (readHolds.get().count &#x3D;&#x3D; 0)&#x2F;&#x2F;此线程没有持有读锁，不能重入\n                return -1;\n            &#x2F;&#x2F;以下是对上述代码中readHolds的解释:readHolds是ThreadLocal变量，保存\n            &#x2F;&#x2F;跟这个线程的读锁重入次数。如果重入次数为0，表示没有加读锁，返回-1去\n            &#x2F;&#x2F;排队。如果重入次数大于等于0，表示已加读锁，可以继续重入，不用排队。\n        &#125;\n        if (sharedCount(c) &#x3D;&#x3D; MAX_COUNT)\n            throw new Error(&quot;Maximum lock count exceeded&quot;);\n        &#x2F;&#x2F;CAS竞争读锁，此时有可能还有其他线程在竞争读锁或写锁\n        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;&#x2F;&#x2F;SHARED_UNIT&#x3D;1&lt;&lt;16\n            &#x2F;&#x2F;竞争读锁成功\n            readHolds.get().count++;&#x2F;&#x2F;更新线程重入次数\n            return 1;&#x2F;&#x2F;成功获取读锁\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;负责排队和等待唤醒，与之前的acquireQueued有两个不同\nprivate void doAcquireShared(int arg) &#123;\n    final Node node &#x3D; addWaiter(Node.SHARED);&#x2F;&#x2F;一：标记此线程等待的是共享锁\n    boolean failed &#x3D; true;\n    try &#123;\n        boolean interrupted &#x3D; false;\n        for (;;) &#123;\n            final Node p &#x3D; node.predecessor();\n            if (p &#x3D;&#x3D; head) &#123;\n                int r &#x3D; tryAcquireShared(arg);\n                if (r &gt;&#x3D; 0) &#123;\n                    &#x2F;&#x2F;区别二：如果下一个节点对应的线程也在等待读锁，那么顺道唤醒它\n                    &#x2F;&#x2F;线程获取到读锁之后，如果下一个节点对应的线程也在等待读锁，\n                    &#x2F;&#x2F;那么也会被唤醒。下一个节点对应的线程获取到读锁之后，又会去唤醒\n                    &#x2F;&#x2F;下下个节点对应的线程(如果下下个节点对应的线程也在等待读锁的\n                    &#x2F;&#x2F;话)。唤醒操作一直传播下去，直到遇到等待写锁的线程为止。\n                    setHeadAndPropagate(node, r);\n                    p.next &#x3D; null; &#x2F;&#x2F; help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed &#x3D; false;\n                    return;\n                &#125;\n            &#125;\n            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;\n                parkAndCheckInterrupt())\n                interrupted &#x3D; true;\n        &#125;\n    &#125; finally &#123;\n        if (failed)\n            cancelAcquire(node);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>ReentrantReadWriteLock：readerLock、writerLock、Sync、FairSync、NonfairSync</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReentrantReadWriteLock\n    implements ReadWriteLock, java.io.Serializable &#123;\n    &#x2F;&#x2F;内部类提供实现，使用NonfairSync和FairSync来编程实现读锁（ReadLock）和\n    &#x2F;&#x2F;写锁（WriteLock），均实现了Lock接口、相同的AQS、Lock接口中的所有加解锁函数\n    private final ReentrantReadWriteLock.ReadLock readerLock;\n    private final ReentrantReadWriteLock.WriteLock writerLock;\n    final Sync sync;&#x2F;&#x2F;执行所有同步机制\n    public ReentrantReadWriteLock() &#123;\n        this(false);\n    &#125;\n    public ReentrantReadWriteLock(boolean fair) &#123;\n        sync &#x3D; fair ? new FairSync() : new NonfairSync();\n        readerLock &#x3D; new ReadLock(this);\n        writerLock &#x3D; new WriteLock(this);\n    &#125;\n    public ReentrantReadWriteLock.WriteLock writeLock() &#123; return writerLock; &#125;\n    public ReentrantReadWriteLock.ReadLock  readLock()  &#123; return readerLock; &#125;\n    &#x2F;&#x2F;AQS的子类NonfairSync和FairSync的公共父类\n    abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n        abstract boolean readerShouldBlock();&#x2F;&#x2F;区分公平锁和非公平锁\n        abstract boolean writerShouldBlock();&#x2F;&#x2F;区分公平锁和非公平锁\n        &#x2F;&#x2F;以下为AQS模板方法的抽象方法的实现\n        protected final boolean tryRelease(int releases) &#123;&#125;\n        protected final boolean tryAcquire(int acquires) &#123;&#125;\n        protected final boolean tryReleaseShared(int unused) &#123;&#125;\n        protected final int tryAcquireShared(int unused) &#123;&#125;\n\n        final boolean tryWriteLock() &#123;&#125;\n        final boolean tryReadLock() &#123;&#125;      \n    &#125;\n    static final class NonfairSync extends Sync &#123;\n        final boolean writerShouldBlock() &#123;return false; &#125;\n        final boolean readerShouldBlock() &#123;return apparentlyFirstQueuedIsExclusive();&#125;\n    &#125;\n    static final class FairSync extends Sync &#123;\n        final boolean writerShouldBlock() &#123;return hasQueuedPredecessors();&#125;\n        final boolean readerShouldBlock() &#123;return hasQueuedPredecessors();&#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>StampedLock：在读写锁的基础上提供了乐观读锁。在读多写少的情况下，大部分操作都不会被写操作干扰，只有在真正被干扰的情况下再加读锁重复执行读操作</p>\n<ul>\n<li>不可重入且不支持条件变量Condition，没有实现Lock和ReadWriteLock接口，而是实现CLH锁（AQS也是基于此）<ul>\n<li>CLH锁是对自旋锁的一种改良，是一种隐式的链表队列，StampedLock通过CLH进行线程的管理，通过同步状态值state来表示锁的状态和类型</li>\n</ul>\n</li>\n<li>不可重入的原因：<code>StampedLock</code>在获取锁的时候会返回一个 long 型的数据戳，该数据戳用于稍后的锁释放参数，当前线程持有了锁再次获取锁还是会返回一个新的数据戳</li>\n<li>性能更好：StampedLock的乐观读锁允许一个写线程获取写锁，所以不会导致所有写线程阻塞，也就是当读多写少的时候，写线程有机会获取写锁，减少了线程饥饿的问题，吞吐量大大提高</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-3补充\"><a href=\"#2-3补充\" class=\"headerlink\" title=\"2.3补充\"></a>2.3补充</h3><ol>\n<li><p>关键字：volatile、synchronized、final</p>\n<ul>\n<li>volatile：每次都去主内存读取，修改立即写入内存（c语言中的volatile的意思是禁用cpu缓存）<ul>\n<li>解决可见性问题：用volatile修饰的变量，在编译成机器指令时，会加入特殊指令，使得CPU对此变量的修改立即写入内存，并通过其它CPU更新缓存数据</li>\n<li>解决有序性问题：volatile通过禁止指令重排序来解决有序性问题，并且是部分指令重排<ul>\n<li>内存屏障：JMM定义了4个细粒度的内存屏障，其底层依赖CPU提供的内存屏障指令（StoreStore、StoreLoad、LoadLoad、LoadStore）分别禁止屏障前后的写写、写读、读读、读写操作重排</li>\n<li>JMM内存模型定义部分禁止重排序的方法：volatile写操作后或者volatile读操作前会添加[StoreLoad]来防止volatile写和读的重排序，一般选择添加在写后面，因为读多写少。</li>\n</ul>\n</li>\n<li>解决原子性问题<ul>\n<li>在32位计算机上，读写64位的long或double类型数据，会执行两次内存读写操作，如果用volatile修饰，那么编译器会在两次读或写之间锁定总线指令，保证变量读写的原子性，但在64位机上就不需要了</li>\n<li>自增语句（count++）因为是对寄存器的值进行操作，但是volatile对变量只能保证立刻写入内存让所有CPU的缓存失败，所以不能影响寄存器内的值，需要synchronized关键字</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>synchronized：通过让原本并发执行的代码串行执行，并且每次加锁和释放锁，都会同步CPU缓存和内存中的数据，可以解决可见性、有序性、原子性的问题</li>\n<li>final：JMM对final的语义做了增强，禁止编译器将构造函数中对final变量的写操作，重排序到对象引用之后，也就是禁止初始化对象（构造函数中的语句）和将内存空间赋值给引用的重排序，否则在多线程环境下，一个线程可能看到final变量的两个不同的值</li>\n</ul>\n</li>\n<li><p>synchronized和volatile有什么区别（互补）</p>\n<ul>\n<li><code>volatile</code>关键字是线程同步的轻量级实现，所以性能比<code>synchronized</code>好，但是<code>volatile</code>只能用于变量而<code>synchronized</code>可以修饰方法以及代码块</li>\n<li><code>volatile</code>关键字能保证数据的可见性，但不能保证数据的原子性，<code>synchronized</code>关键字两者都能保证</li>\n<li><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而<code>synchronized</code>关键字解决的是多个线程之间访问资源的同步性</li>\n</ul>\n</li>\n<li><p>synchronized和ReentrantLock有什么区别</p>\n<ul>\n<li>相同点：两者都是可重入锁，即线程可以再次获取自己的内部锁，不可重入的此时会产生死锁</li>\n<li><code>ReentrantLock</code>属于可中断锁，获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理；<code>synchronized</code>锁属于不可中断锁，一旦线程申请了锁，就只能等到拿到锁之后才能进行其他的逻辑处理</li>\n<li><code>synchronized</code>依赖于JVM（用户不能直接看到代码）而<code>ReentrantLock</code>依赖于API（lock、unlock等方法）</li>\n<li>ReentrantLock 比 synchronized 增加了一些高级功能，如可中断锁、公平锁、可超时锁、非阻塞锁、选择性通知（锁可以绑定多个条件）<ul>\n<li>synchronized需要和wait、notify结合才能实现等待/通知机制，ReentrantLock类通过Condition接口和newCondition方法实现</li>\n<li>Condition接口可以实现多路通知功能，也就是在一个Lock对象中可以创建多个Condition实例（对象监视器），线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活</li>\n<li>在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</li>\n<li>synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题</li>\n<li>而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>非阻塞同步</p>\n<ul>\n<li><p>悲观锁（阻塞同步）：</p>\n</li>\n<li><p>乐观锁（非阻塞同步）：先进行操作，操作完成之后再判断操作是否成功，是否有并发问题，如果有则进行失败补偿，如果没有就算操作成功</p>\n</li>\n<li><p>在 Java 中应用最广泛的非阻塞同步就是 CAS。从 JDK1.5 以后，可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里的 compareAndSwapInt() 和 compareAndSwapLong() 等方法实现。通常情况下 sun.misc.Unsafe 类 对于开发者是不可见的，因此，JDK 提供了很多 CAS 包装类 简化开发者的使用，如 AtomicInteger。使用 Java 自带的 Atomic 原子类，可以避免同步锁带来的并发访问性能降低的问题，减少犯错的机会</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-同步\"><a href=\"#3-同步\" class=\"headerlink\" title=\"3.同步\"></a>3.同步</h2><h3 id=\"2-1条件变量\"><a href=\"#2-1条件变量\" class=\"headerlink\" title=\"2.1条件变量\"></a>2.1条件变量</h3><ol>\n<li><p>Object类：执行wait()或notify()前先加锁、使用while循环避免假唤醒，底层依赖ObjectMonitor</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class QueueCond&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      this.notify();&#x2F;&#x2F;通知\n    &#125;\n  &#125;\n  \n  public String get()&#123;\n    synchronized(this)&#123;&#x2F;&#x2F;加锁\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          this.wait();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>Condition接口：使用前后需要lock和unlock，使用中要while，底层依赖ConditionObject（AQS的内部类）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class QueueCondJUC&#123;\n  private List&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n  private int count &#x3D; 0;\n  private Lock lock &#x3D; new ReentrantLock();\n  private Condition condition &#x3D; lock.newCondition();\n  \n  private void put(String elem)&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      list.add(count,elem);\n      count++;&#x2F;&#x2F;更新状态变量\n      condition.signal();&#x2F;&#x2F;通知\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n  public String get()&#123;\n    lock.lock();&#x2F;&#x2F;加锁\n    try&#123;\n      while(count &lt;&#x3D; 0)&#123;&#x2F;&#x2F;检查状态变量是否满足条件\n        try&#123;\n          condition.await();&#x2F;&#x2F;等待并释放锁，被唤醒之后重新竞争获取锁\n        &#125;catch(InterruptedException e)&#123;\n          return null;\n        &#125;\n      &#125;&#x2F;&#x2F;以下为业务逻辑\n      count--;\n      return list.get(count);\n    &#125;finally&#123;\n      lock.unlock();&#x2F;&#x2F;解锁\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"2-2信号量（Semaphore）\"><a href=\"#2-2信号量（Semaphore）\" class=\"headerlink\" title=\"2.2信号量（Semaphore）\"></a>2.2信号量（Semaphore）</h3><ol>\n<li><p>Semaphore类</p>\n<ul>\n<li>信号量与锁的区别是：释放锁的线程必须持有锁，而信号量则不用。即没有调用acquire()函数的线程也可以直接调用release()函数，用来增加可用许可个数。此时，信号量不再是用来限制对临界区的并发访问，而是用来对共享资源的并发访问</li>\n<li>如果信号量中的许可个数为1，那么信号量就退化成了互斥锁；如果互斥量的许可个数大于1，信号量就可以看作是一种共享锁</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;第一组，默认一次获取或释放的许可（permit）个数为1\n  public void acquire() throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly() &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire()&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release()&#123;&#125;\n\n  &#x2F;&#x2F;第二组，默认制定一次获取或释放的许可个数\n  public void acquire(int permits) throws InterruptedException &#123;&#125;&#x2F;&#x2F;可中断获取\n  public void acquireUninterruptibly(int permits) &#123;&#125;&#x2F;&#x2F;不可中断获取\n  public boolean tryAcquire(int permits)&#123;&#125;;&#x2F;&#x2F;非阻塞获取\n  public boolean tryAcquire(int permits, long timeout, TimeUnit unit)&#x2F;&#x2F;可超时获取\n        throws InterruptedException &#123;&#125;\n  public void release(int permits)&#123;&#125;\n&#125;</code></pre></li>\n<li><p>应用：共享资源并发访问控制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class QueueSemaphore&#123;\n  private static final int Q_SIZE &#x3D; 20;\n  &#x2F;&#x2F;表示队列中的空闲位置\n  private Semaphore semaphore &#x3D; new Semaphore(Q_SIZE);\n  private list&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;(Q_SIZE);\n  private int count &#x3D; 0;\n  \n  public void put(String elem)&#123;\n    &#x2F;&#x2F;当可用许可个数为0时，线程执行put函数时会阻塞在acquireUniterruptibly()函数中\n    semaphore.acquireUniterruptibly();\n    synchronized(this)&#123;\n      list.add(count, elem);\n      count++;\n    &#125;\n  &#125;\n  public String get()&#123;\n    if(count &#x3D;&#x3D; 0) return null;\n    synchronized(this)&#123;\n      if(count &#x3D;&#x3D; 0) return null;&#x2F;&#x2F;双重检测\n      String ret &#x3D; list.get(--count);\n      semaphore.release();\n      return ret;\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>原理</p>\n<ul>\n<li>调用<code>semaphore.acquire()</code>，线程尝试获取许可证，如果 <code>state &gt;= 0</code>的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code>的值 <code>state=state-1</code>。如果 <code>state&lt;0</code>的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程</li>\n<li>调用<code>semaphore.release();</code>，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code>的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code>的值 <code>state=state-1</code>，如果 <code>state&gt;=0</code>则获取令牌成功，否则重新进入阻塞队列，挂起线程。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Semaphore implements java.io.Serializable &#123;\n  &#x2F;&#x2F;实现AQS，模版模式\n  private final Sync sync;\n  abstract static class Sync extends AbstractQueuedSynchronizer &#123;\n    Sync(int permits) &#123;setState(permits);&#125;\n    protected final boolean tryReleaseShared(int releases) &#123;&#125;\n  &#125;\n\n  static final class NonfairSync extends Sync &#123;\n    NonfairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      return nonfairTryAcquireShared(acquires);\n    &#125;\n  &#125;\n  \n  &#x2F;*\n  final int nonfairTryAcquireShared(int acquires) &#123;\n    for (;;) &#123;\n      int available &#x3D; getState();&#x2F;&#x2F;许可个数存放在state变量中\n      int remaining &#x3D; available - acquires;\n      if (remaining &lt; 0 ||\n          compareAndSetState(available, remaining))\n        return remaining;\n    &#125;\n  &#125;\n  *&#x2F;\n\n  static final class fairSync extends Sync &#123;\n    fairSync(int permits) &#123;super(permits);&#125;\n    protected int tryAcquireShared(int acquires) &#123;\n      for (;;) &#123;\n        if (hasQueuedPredecessors()) return -1;&#x2F;&#x2F;比NonfairSync多了这一行\n        int available &#x3D; getState();\n        int remaining &#x3D; available - acquires;\n        if (remaining &lt; 0 ||\n            compareAndSetState(available, remaining))\n          return remaining;\n      &#125;\n    &#125;\n  &#125;\n\n  public Semaphore(int permits) &#123;&#x2F;&#x2F;默认非公平模式\n    sync &#x3D; new NonfairSync(permits);\n  &#125;\n\n  public Semaphore(int permits, boolean fair) &#123;&#x2F;&#x2F;指定工作模式（公平&#x2F;非公平）\n    sync &#x3D; fair ? new FairSync(permits) : new NonfairSync(permits);\n  &#125;\n  &#x2F;&#x2F;暂时省略核心方法的实现\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;acquireUninterruptibly()函数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;位于Semaphore.java中\npublic void acquireUninterruptibly() &#123;\n  sync.acquireShared(1);\n&#125;\n&#x2F;&#x2F;位于AbstractQueuedSynchronizer.java中\npublic final void acquireShared(int arg) &#123;\n  if (tryAcquireShared(arg) &lt; 0)&#x2F;&#x2F;竞争获取许可，返回值&lt;0表示失败，需要排队等待许可\n    doAcquireShared(arg);&#x2F;&#x2F;排队等待许可\n&#125;\n&#x2F;&#x2F;其中tryAcquireShared()函数的代码实现位于NonfairSync和FairSync中，实现见上\n&#x2F;&#x2F;两种实现均通过自旋+CAS的方式获取许可，唯一区别是从等待队列中取还是可以插队\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;release()函数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</code></pre></li>\n</ol>\n<h3 id=\"2-3Latch-amp-Barrier\"><a href=\"#2-3Latch-amp-Barrier\" class=\"headerlink\" title=\"2.3Latch&amp;Barrier\"></a>2.3Latch&amp;Barrier</h3><ol>\n<li><p>CountDownLatch：等其他线程结束，允许count个线程阻塞在一个地方，直至所有线程的任务都执行完毕（是一次性的，不能重复使用）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class DemoJoin&#123;\n  public static void main(String[] args) throws InterruptedException&#123;\n    Thread t1 &#x3D; new Thread(new RunnableForJoin());\n    THread t2 &#x3D; new THread(new RunnableForJoin());\n    t1.start();\n    t2.start();\n    t1.join();&#x2F;&#x2F;join只用来等待线程执行结束，并且必须知道被等待线程是谁\n    t2.join();\n  &#125;\n  public static class RunnableForJoin implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;业务逻辑\n    &#125;\n  &#125;\n&#125;\npublic class DemoLatch&#123;\n  private static final CountDownLatch latch &#x3D; new CountDownLatch(2);\n  public static void main(String[] args) throws InterruptedException&#123;\n    new Thread(new RunnableForLatch()).start();\n    new Thread(new RunnbaleForLatch()).start();\n    latch.await();&#x2F;&#x2F;等待something执行完成而非等待线程结束，并且不需要知道在等谁\n    &#x2F;&#x2F;执行后续逻辑\n  &#125;\n  public static class RunnableForLatch implements Runnable&#123;\n    @Override\n    public void run()&#123;\n      &#x2F;&#x2F;do something\n      latch.countDown();\n      &#x2F;&#x2F;do otheer thing\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>CyclicBarrier：CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo&#123;\n  &#x2F;&#x2F;创建parties为10的CyclicBarrier对象，用于10个线程之间相互等待，尽管10个线程的启动（执行\n  &#x2F;&#x2F;start函数）的时间不同，但每个线程结束都会调用await函数，将paeties减一，然后检查parties\n  &#x2F;&#x2F;如果不为0，则当前线程阻塞等待，如果parties为0，则当前线程唤醒所有调用了await函数的线程。\n  private static final CyclicBarrier barrier &#x3D; new CyclicBarrier(10);\n  public static void main(String[] args)&#123;\n    for(int i&#x3D;0; i&lt;10; ++i)&#123;\n      new Thread(new Runnbale()&#123;\n        @Override\n        public void run()&#123;\n          try&#123;\n            barrier.await();\n          &#125;catch(InterruptedException e)&#123;&#x2F;&#x2F;当前线程被中断\n            e.printStackTrace();\n          &#125;catch(BrokenBarrierException e)&#123;&#x2F;&#x2F;其他线程调用await()期间被中断\n            e.printStachTrace();\n          &#125;\n          &#x2F;&#x2F;执行业务逻辑\n        &#125;\n      &#125;).start();\n    &#125;\n    &#x2F;&#x2F;主线程需要等待以上10个线程执行结束，方法有以下3种：\n    &#x2F;&#x2F;1.sleep() 2.join() 3.CountDownLatch()\n  &#125;\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"4-JUC\"><a href=\"#4-JUC\" class=\"headerlink\" title=\"4.JUC\"></a>4.JUC</h2><h3 id=\"1-并发阻塞（xxxBlockingQueue）\"><a href=\"#1-并发阻塞（xxxBlockingQueue）\" class=\"headerlink\" title=\"1.并发阻塞（xxxBlockingQueue）\"></a>1.并发阻塞（xxxBlockingQueue）</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>线程安全和支持读写阻塞，阻塞并发队列一般用于实现生产者-消费者模型</p></blockquote>\n<ol>\n<li>xxxBlockingQueue：ArrayBlockingQueue、LinkedBlockingQueue、LinkedBlockingDeque、PriorityBlockingQueue的实现原理类似，都是基于ReentrantLock锁来实现线程安全，基于Condition条件变量来实现阻塞等待<ul>\n<li>ArrayBlockingQueue：有界队列实现类，底层采用数组来实现，一旦创建容量不能改变<ul>\n<li>使用方法和普通队列类似，只不过增加了读写可阻塞，支持公平和非公平两种工作模式，默认为非公平</li>\n<li>支持读写阻塞的put和take函数（ReentrantLock+Condition）</li>\n<li>非阻塞的offer和poll函数，只通过ReentrantLock锁来保证线程安全，没有通过条件变量来实现阻塞读写</li>\n</ul>\n</li>\n<li>LinkedBlockingQueue：基于链表实现的有界阻塞并发队列，默认大小为Integer.MAX_VALUE，可以指定队列大小</li>\n<li>LinkedBlockingDeque：与LinkedBlockingQueue的区别在于，它是一个双端队列，支持两端读写操作</li>\n<li>PriorityBlockingQueue：是一个无界阻塞并发优先级队列，底层基于支持扩容的堆来实现，写操作永远不需要阻塞，只有读操作会阻塞，不可插入null值且插入对象必须可比较大小（comparable）</li>\n</ul>\n</li>\n<li>DelayQueue<ul>\n<li>延迟阻塞并发队列，底层基于PriorityQueue来实现，因为PriorityQueue支持动态扩容，所以DelayQueue为无界队列，写永远都不会阻塞，只有读会阻塞</li>\n<li>DelayQueue中存储的每个元素都必须实现Delayed接口，提供延迟被读取时间delayTime，PriorityQueue按照delayTime的大小将元素组织成最小顶堆，也就是说，堆顶的元素是delayTime最小的元素，应该最先被读取到</li>\n<li>take函数，包含两个逻辑，针对leader线程的逻辑和针对非leader线程的逻辑。当多个线程先后调用take函数，第一个线程就是leader线程，剩下的就是非leader线程。第一个线程执行读取操作完成之后，第二个线程便称为leader线程。<ul>\n<li>非leader线程直接调用await函数阻塞，等待leader线程执行完成之后调用signal来唤醒</li>\n<li>leader线程读取的是队首的元素，如果队首的元素delayTime大于0，那么leader线程会调用awaitNanos阻塞delayTime时间，当delayTime时间过去之后，leader线程自动唤醒，为了避免假唤醒（插队情况见下），leader线程会检查队首元素的delayTime是否真正变为小于等于0，如果是，则队首元素出队，调用signal唤醒第二个线程，第二个线程就成了leader线程</li>\n<li>插队情况：如果一个线程执行take函数时，如果检查发现队列不为空，并且队首元素的delayTime小于等于0，于是，不管是不是有其他线程在调用await或awaitNanos阻塞等待，这个线程都会直接读取队首元素并返回</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>较少使用<ul>\n<li>SynchronousQueue：用于两个线程之间传递数据，每个put操作必须阻塞等待take操作，队列中不存储任何元素</li>\n<li>LinkedTransferQueue：基于链表实现的无界阻塞并发队列，是LinkedBlockingQueue和SynchronousQueue的综合体，提供了transfer函数，跟SynchronousQueue的put函数的功能相同，调用transfer的线程会一直阻塞，直到数据被其他线程消费才会返回</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-分段加锁（ConcurrentHashMap）\"><a href=\"#2-分段加锁（ConcurrentHashMap）\" class=\"headerlink\" title=\"2.分段加锁（ConcurrentHashMap）\"></a>2.分段加锁（ConcurrentHashMap）</h3><ol>\n<li>原理<ul>\n<li>底层数据结构：ConcurrentHashMap底层采用数组+链表/红黑树（1.7使用分段数组+链表）</li>\n<li>实现线程安全的方式<ul>\n<li>JDK1.7的<code>ConcurrentHashMap</code>：对整个桶数组进行分割分段，每一把锁只锁其中的一部分数据，多线程访问不同段的数据就不会产生锁竞争</li>\n<li>JDK1.8的<code>ConcurrentHashMap</code>：直接用Node数组+链表/红黑树来实现，并发控制使用<code>synchronized</code>和<code>CAS</code>来操作</li>\n<li>TreeNode是存储红黑树节点，被TreeBin包装，TreeBin通过root属性维护红黑树的根节点，因为红黑树在旋转的时候，根节点可能会被它原来的子节点替换掉，在这个时间点如果有其他线程要写这颗红黑树就会产生线程不安全问题，所以在ConcurrentHashMap中TreeBin通过waiter属性维护当前使用这颗红黑树的线程，来防止其他线程的进入</li>\n</ul>\n</li>\n<li>ConcurrentHashMap比HashTable效率高的原因：ConcurrentHashMap中，table数组被分段加锁，如果table数组的大小为n，那么就对应存在n把锁，每一个链表独享一把锁，不同链表之间的操作可以多线程并行执行，互不影响，以此来提高并发性能。而HashTable使用synchronized（同一把锁）来保证线程安全，效率低，当一个线程使用put时，另一个线程既不能使用put，也不能使用get</li>\n</ul>\n</li>\n<li>ConcurrentHashMap类<ul>\n<li>HashMap、HashTable、ConcurrentHashMap<ul>\n<li>HashMap不是线程安全的：在扩容之后的resize时，如果有两个线程同时在resize，一个线程resize结束了，另一个线程才开始resize，这个时候，后开始的线程因为不知道链表结构已经被改变了，所以会继续之前的逻辑，造成链表节点环形引用</li>\n<li>HashTable和ConcurrentHashMap的区别：线程安全的实现方式不同<ul>\n<li>底层数据结构：HashTable使用数组加链表；ConcurrentHashMap底层采用数组+链表/红黑树（1.7使用分段数组+链表）</li>\n<li>实现线程安全的方式<ul>\n<li>JDK1.7的<code>ConcurrentHashMap</code>：对整个桶数组进行分割分段，每一把锁只锁其中的一部分数据，多线程访问不同段的数据就不会产生锁竞争</li>\n<li>JDK1.8的<code>ConcurrentHashMap</code>：直接用Node数组+链表/红黑树来实现，并发控制使用<code>synchronized</code>和<code>CAS</code>来操作</li>\n<li><code>HashTable</code>（同一把锁）：使用synchronized来保证线程安全，效率低，当一个线程使用put时，另一个线程既不能使用put，也不能使用get</li>\n</ul>\n</li>\n<li><code>TreeNode</code>是存储红黑树节点，被<code>TreeBin</code>包装，TreeBin通过<code>root</code>属性维护红黑树的根节点，因为红黑树在旋转的时候，根节点可能会被它原来的子节点替换掉，在这个时间点如果有其他线程要写这颗红黑树就会产生线程不安全问题，所以在<code>ConcurrentHashMap</code>中<code>TreeBin</code>通过<code>waiter</code>属性维护当前使用这颗红黑树的线程，来防止其他线程的进入</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>ConcurrentHashMap<ul>\n<li>HashTable和SynchronizedMap都通过简单的对所有方法加锁，来解决线程安全问题，SynchronziedMap的引入是为了让JCF框架的类结构更加清晰，线程安全容器和非线程安全容器相分离，线程安全容器通过统一的方式（Collections的synchronizedXXX方法）来创建</li>\n<li>JDK8版本的ConcurrentHashMap比JDK7版本的分段加锁力度更小，并发度更高，扩容方式有所不同，size实现更高效等优势</li>\n<li>ConcurrentHashMap中，table数组被分段加锁，如果table数组的大小为n，那么就对应存在n把锁，每一个链表独享一把锁，不同链表之间的操作可以多线程并行执行，互不影响，以此来提高并发性能</li>\n</ul>\n</li>\n<li>get函数的实现原理<ul>\n<li>get函数就是读操作，没有加锁的处理逻辑，get函数可以跟任何操作（读操作、写操作、树化、扩容）并行执行，并发性能极高</li>\n<li>get与其他操作没有线程安全问题，但get和扩容操作之间因为有线程安全问题，所以需要特殊处理</li>\n</ul>\n</li>\n<li>put函数的实现原理<ul>\n<li>写操作：两种加锁方式，链表为空的时候，通过CAS操作将table[index]指向写入数据对应的节点；链表不为空，先对头节点使用synchronized加锁，再执行写操作</li>\n<li>树化：写入操作完成后，如果链表中的节点个数大于等于树化阈值（默认为8），put会执行树化操作，尽管是写时复制操作，但是在树化的同时执行写入操作或扩容，会导致数据丢失，因此树化操作也需要使用synchronzied加锁</li>\n<li>扩容：扩容需要对整个table的所有链表加锁，也是通过分段加锁分段执行，对HashMap增加了两点改进<ul>\n<li>写时复制：<ul>\n<li>在创建好新的table数组之后，采用写时复制的方法，一点点复制，在全部复制完之后，才会将table引用指向新创建的table数组</li>\n<li>table会出现三种不同类型的链表，已复制未加锁链表、在复制已加锁链表、未复制未加锁链表，根据类型不同决定在那个table处理读、写、树化操作</li>\n<li>类型的标记由新节点类型<code>ForwardingNode</code>标记，此节点类型的hash值为-1。在扩容的时候，将复制完解锁前的链表头节点换成<code>ForwardingNode</code>节点，并将ForwardingNode节点中的nextTable属性指向新创建的table数组，读、写、树化table数组的某个链表时，如果头节点的hash值为-1.就在这个节点的<code>nextTable</code>属性所指向的<code>table</code>数组中重新查找对应的链表，在执行相应操作</li>\n</ul>\n</li>\n<li>复制替代搬移：扩容基于复制而非搬移实现，将老的table数组中的节点中的key、value等数据，复制一份存储在一个新创建的节点中，再将新创建的节点插入到新的table数组中</li>\n<li>多个线程共同协作完成扩容：<ul>\n<li>每个线程根据transferIndex来决定具体负责哪几个链表的复制，transferIndex初始化为table.length，多个线程通过CAS修改transferIndex共享变量，谁成功更新，谁就获得[transferIndex-stride, transferIndex)之间的stride个链表的复制权，争夺失败的线程自旋重新执行CAS</li>\n<li>执行table引用更新的线程：ConcurrentHashMap定义了一个int类型的sizeCtl变量，用来标记当前正在参与扩容的线程个数，进入和退出的线程通过CAS操作增减sizeCtl，如果变为0，那么这个线程就是最后一个线程，负责引用更新</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>size函数的实现原理<ul>\n<li>扫描统计：每次调用size函数时，都把table数组中的所有链表都遍历一遍，统计得到总的元素个数。每次扫描都需要加锁，导致并发性能降低，执行效率也非常低</li>\n<li>实时统计：ConcurrentHashMap中维护一个size成员变量，每当执行增、删元素操作时，同步更新size，无论将size设置为AtomicInteger还是通过CAS更新size，在高并发场景下，都会存在性能问题，进而影戏那个增、删操作的性能</li>\n<li>非一致性统计：借鉴LongAdder的实现思路，每个链表维护一个实时统计的cellSize，表示这个链表的节点个数，当调用size函数时，每个链表的cellSize相加即可得到元素总个数，但会导致统计结果不一致</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-写时复制（CopyOnWriteArrayList、CopyOnWriteArraySet）\"><a href=\"#3-写时复制（CopyOnWriteArrayList、CopyOnWriteArraySet）\" class=\"headerlink\" title=\"3.写时复制（CopyOnWriteArrayList、CopyOnWriteArraySet）\"></a>3.写时复制（CopyOnWriteArrayList、CopyOnWriteArraySet）</h3><ol>\n<li>主要应用于并发容器中，为了避免读操作和写操作（增、删、改）同时发生而产生的线程安全问题，写时复制将原始容器中的数据复制一份放入新创建的容器，然后对新创建的容器进行写操作，而对读操作继续在原始容器上进行，这样读写之间不会存在数据访问冲突，当写操作执行完成后，新创建的容器替代原始容器<ul>\n<li>这样读操作完全不需要加锁，写入也不会阻塞读取操作，只有写入和写入之间需要进行同步等待</li>\n</ul>\n</li>\n<li>弱一致性：CopyOnWriteArrayList源码显示，写操作的结果并非对读操作立即可见，这就导致了短暂的数据不一致，称为弱一致性，在某些业务场景下，会引发bug<ul>\n<li>解决办法：CopyOnWriteArrayList提供了用于遍历容器的迭代器</li>\n</ul>\n</li>\n<li>连续存储：JUC提供了CopyOnWriteArrayList、CopyOnWriteArraySet，却没有提供CopyOnWriteLinkedList、CopyOnWriteHashMap等其他类型的写时复制容器的原因：因为执行写操作需要复制整个数据，对于链表和哈希表来说，因为数据在内存中不是连续存储的，所以耗时非常大，写操作的性能无法满足工业级通用类对性能的要求。CopyOnWriteArrayList、CopyOnWriteArraySet底层都是基于数组来实现的，而且使用了JVM底层提供的native方法，通过C++代码中的指针实现了内存块的快速拷贝</li>\n</ol>\n<h2 id=\"5-无锁编程\"><a href=\"#5-无锁编程\" class=\"headerlink\" title=\"5.无锁编程\"></a>5.无锁编程</h2><ol>\n<li><p>CAS：CAS指的是先检查后更新这类复合操作，全称为Compare And Set或Compare And Swap。在CAS操作失败后，可以选择自旋直到CAS成功 或 执行失败处理相关的业务逻辑</p>\n</li>\n<li><p>原子类：原子类的每个操作都可以看成是原子操作，在多线程环境下，执行原子类的操作不会出现线程安全问题</p>\n</li>\n<li><p>LongAdder</p>\n<ul>\n<li><p>基本用法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CounterLongAdder&#123;\n  private LongAdder ladder &#x3D; new LongAdder();\n  \n  public void add(long value)&#123;\n    ladder.add(value);\n  &#125;\n  public long get()&#123;\n    &#x2F;&#x2F;sum用来返回累加之后的总和，高并发情况下，不能返回精确的累加值，为了高性能付出的代价\n    return ladder.sum();\n  &#125;\n&#125;</code></pre></li>\n<li><p>数据分片</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731154243291.png\" alt=\"image-20230731154243291\"></p>\n</li>\n<li><p>去伪共享：主要用于提高多线程并发执行效率，在DIsruptor高性能消息队列中也有用到</p>\n<ul>\n<li>伪共享：CPU操作缓存的最小单元是缓存行，不同CPU上的缓存行大小不同，可以为32字节、64字节或128字节。计算Cell对象大小，Cell对象头占12字节，value成员变量为long类型，占8个字节，对象头与value成员变量之间有4字节对齐填充，所以一个Cell对象占24字节，如果一个缓存行大小为64字节，那么两个Cell对象就可能存储在同一个缓存行中。当t1更改cellA的时候，会把缓存行设为无效，导致t2对cellB的缓存也会失效，t1和t2互相影响，导致缓存频繁失效</li>\n<li>为了解决伪共享的问题，可以使用<code>@Contended</code>注解。标记在类上会强制这个类的对象独占一个缓存行，不够的做对齐填充，标记在变量上的作用相同，强制这个变量独占一个缓存行</li>\n</ul>\n</li>\n<li><p>非准确求和：LongAdder中的sum()函数会累加base和cells中的Cell对象的value值，和便是最终的累加值。但这个值是不准确的。因为LongAdder在执行sum()函数时，并没有加锁，也就是说，在执行sum()的同时，有可能其他线程正在执行add()函数。所以会使得累加值不准确</p>\n</li>\n</ul>\n</li>\n<li><p>ThreadLocal（又称线程本地存储区「Thread Local Storage，简称为 TLS」）：使用ThreadLocal线程局部变量替代共享变量，以实现在不需要加锁的情况下达到线程安全。其作用域范围介于类的成员变量和函数内局部变量之间，既是线程私有的，又可以在函数之间共享，不但避免了线程安全问题，还能避免参数传递带来的代码耦合问题</p>\n<ul>\n<li><p>每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域。使用 ThreadLocal 变量 的 set(T value)方法可以将数据存入该线程本地存储区，使用 get() 方法可以获取到之前存入的值</p>\n</li>\n<li><p>实现原理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ThreadLocal&lt;T&gt; &#123;\n\n    &#x2F;**\n     * 下面的 getMap()方法 传入当前线程，获得一个ThreadLocalMap对象，说明每一个线程维护了\n     * 自己的一个 map，保证读取出来的value是自己线程的。\n     *\n     * ThreadLocalMap 是ThreadLocal静态内部类，存储value的键值就是ThreadLocal本身。\n     *\n     * 因此可以断定，每个线程维护一个ThreadLocalMap的键值对映射Map。不同线程的Map的 key值 是一样的，\n     * 都是ThreadLocal，但 value 是不同的。\n     *&#x2F;\n    public T get() &#123;\n        Thread t &#x3D; Thread.currentThread();\n        ThreadLocalMap map &#x3D; getMap(t);\n        if (map !&#x3D; null) &#123;\n            ThreadLocalMap.Entry e &#x3D; map.getEntry(this);\n            if (e !&#x3D; null) &#123;\n                @SuppressWarnings(&quot;unchecked&quot;)\n                T result &#x3D; (T)e.value;\n                return result;\n            &#125;\n        &#125;\n        return setInitialValue();\n    &#125;\n\n    public void set(T value) &#123;\n        Thread t &#x3D; Thread.currentThread();\n        ThreadLocalMap map &#x3D; getMap(t);\n        if (map !&#x3D; null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    &#125;\n&#125;</code></pre></li>\n<li></li>\n</ul>\n</li>\n<li><p>Unsafe类</p>\n<ul>\n<li><p>Unsafe对象的获取</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class Unsafe &#123;\n  &#x2F;&#x2F; 单例对象\n  private static final Unsafe theUnsafe;\n  ......\n  private Unsafe() &#123;\n  &#125;\n  @CallerSensitive\n  public static Unsafe getUnsafe() &#123;\n    Class var0 &#x3D; Reflection.getCallerClass();\n    &#x2F;&#x2F; 仅在引导类加载器&#96;BootstrapClassLoader&#96;加载时才合法，在我们去调用他的时候，因为类加载器不对，会抛出异常\n    if(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;\n      throw new SecurityException(&quot;Unsafe&quot;);\n    &#125; else &#123;\n      return theUnsafe;\n    &#125;\n  &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;正确的获取方式&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nField field &#x3D; Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);\nfield.setAccessible(true);\nreturn (Unsafe)field.get(null);</code></pre></li>\n<li><p>Unsafe功能</p>\n<ul>\n<li><p>内存操作：内存分配、调整大小、设置为指定值、内存拷贝、内存释放</p>\n<ul>\n<li>使用的是堆外内存，好处如下：<ul>\n<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。</li>\n<li>提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void memoryTest() &#123;\n    int size &#x3D; 4;\n    long addr &#x3D; unsafe.allocateMemory(size);&#x2F;&#x2F;4字节长度\n    long addr3 &#x3D; unsafe.reallocateMemory(addr, size * 2);&#x2F;&#x2F;重新分配一块8字节长度\n    System.out.println(&quot;addr: &quot;+addr);\n    System.out.println(&quot;addr3: &quot;+addr3);\n    try &#123;\n        unsafe.setMemory(null,addr ,size,(byte)1);\n        for (int i &#x3D; 0; i &lt; 2; i++) &#123;\n            unsafe.copyMemory(null,addr,null,addr3+size*i,4);\n        &#125;\n        System.out.println(unsafe.getInt(addr));\n        System.out.println(unsafe.getLong(addr3));\n    &#125;finally &#123;\n        unsafe.freeMemory(addr);\n        unsafe.freeMemory(addr3);\n    &#125;\n&#125;</code></pre></li>\n<li><p>内存屏障（例子：StampedLock）</p>\n<ul>\n<li>通过阻止编译器和CPU对代码进行重排序，内存屏障就是阻止屏障两边的指令重排序来避免编译器和硬件的不正确优化</li>\n<li>内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作</li>\n<li>主要解决：运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。但是子线程借助于主内存，通过屏障，将修改后的结果同步给了主线程，进而修改主线程中的工作空间</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前\npublic native void loadFence();\n&#x2F;&#x2F;内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前\npublic native void storeFence();\n&#x2F;&#x2F;内存屏障，禁止load、store操作重排序\npublic native void fullFence();</code></pre></li>\n<li><p>对象操作</p>\n<ul>\n<li>可以通过内存偏移量获取字段值</li>\n</ul>\n</li>\n<li><p>数据操作</p>\n</li>\n<li><p>CAS 操作</p>\n</li>\n<li><p>线程调度</p>\n</li>\n<li><p>Class 操作</p>\n<ul>\n<li>类加载：</li>\n<li>静态变量的操作方法：</li>\n</ul>\n</li>\n<li><p>系统信息：返回系统相关信息，如系统指针的大小（addressSize）、内存页的大小（pageSize）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Future类</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Future模式：异步思想的典型应用，主要用在一些执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，将耗时任务交给一个子线程来异步执行，等事情干完后，再通过Future类获取到耗时任务的执行结果</p></blockquote>\n<ul>\n<li><p>Java中Future是JUC包下的一个泛型接口，定义了5个方法，主要包括下面4个功能</p>\n<ul>\n<li>取消任务</li>\n<li>判断任务是否取消</li>\n<li>判断任务是否已经执行完成</li>\n<li>获取任务执行结果</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; V 代表了Future执行的任务返回值的类型\npublic interface Future&lt;V&gt; &#123;\n    &#x2F;&#x2F; 取消任务执行\n    &#x2F;&#x2F; 成功取消返回 true，否则返回 false\n    boolean cancel(boolean mayInterruptIfRunning);\n    &#x2F;&#x2F; 判断任务是否被取消\n    boolean isCancelled();\n    &#x2F;&#x2F; 判断任务是否已经执行完成\n    boolean isDone();\n    &#x2F;&#x2F; 获取任务执行结果\n    V get() throws InterruptedException, ExecutionException;\n    &#x2F;&#x2F; 指定时间内没有返回计算结果就抛出 TimeOutException 异常\n    V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutExceptio\n\n&#125;</code></pre></li>\n<li><p>Callable和Future有什么关系</p>\n<ul>\n<li><p>FutureTask提供了Future接口的基本实现，常用来封装Callable和Runnable，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法，可以作为任务直接被线程执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);\nFuture&lt;?&gt; submit(Runnable task);</code></pre></li>\n<li><p><code>FutureTask</code>相当于对<code>Callable</code> 进行了封装，管理着任务执行的情况，存储了 <code>Callable</code> 的 <code>call</code> 方法的任务执行结果</p>\n</li>\n</ul>\n</li>\n<li><p>CompletableFuture类</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731154145535.png\" alt=\"image-20230731154145535\"></p>\n<ul>\n<li><code>Future</code>在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code>方法为阻塞调用，Java8引入<code>CompletableFuture</code>类来解决这些缺陷</li>\n<li><code>CompletableFuture</code>同时实现了 <code>Future</code>和 <code>CompletionStage</code>接口</li>\n<li><code>CompletionStage</code>接口描述了一个异步计算的阶段，很多计算可以分成多个阶段或步骤，此时可以通过它将所有步骤组合起来，行成异步计算的流水线</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ol>\n<li><p>乐观锁和悲观锁</p>\n<ul>\n<li><p>悲观锁总是假设最坏的情况，认为共享资源每次访问的时候都会出现问题，所以每次在获取资源的时候都会上锁，如<code>synchronized</code>、<code>ReentrantLock</code>等独占锁，常用于多写场景</p>\n</li>\n<li><p>乐观锁总是假设最好的情况，认为共享资源每次访问的时候都不会出现问题，无需加锁也无需等待，所以只是在提交修改的时候去验证对应的资源是否被其他线程修改了，如JUC的atomic包下面的原子变量类使用了乐观锁的一种实现方式CAS实现的，常用于多读场景</p>\n<ul>\n<li><p>乐观锁存在哪些问题（ABA问题、循环时间长、只能保证一个共享变量的原子操作）</p>\n<ul>\n<li><p>ABA问题：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 </p>\n<p>“ABA”问题。</p>\n<ul>\n<li>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong></li>\n</ul>\n</li>\n<li><p>循环时间长：CAS经常会用到自旋操作来进行重试，如果长时间不成功，会给 CPU 带来非常大的执行开销</p>\n<ul>\n<li>如果 JVM 能支持处理器提供的 pause指令那么效率会有一定的提升，pause 指令有两个作用：<ul>\n<li>可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零</li>\n<li>可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用<code>AtomicReference</code>类把多个共享变量合并成一个共享变量来操作</p>\n</li>\n</ul>\n</li>\n<li><p>乐观锁实现方式一：版本号机制</p>\n<ul>\n<li>一般是在数据表中加上一个数据版本号 <code>version</code>字段，表示数据被修改的次数。当数据被修改时，<code>version</code>值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的<code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功</li>\n</ul>\n</li>\n<li><p>乐观锁实现方式一：CAS算法</p>\n<ul>\n<li>CAS 的全称是 Compare And Swap（比较与交换），用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新</li>\n<li>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。CAS涉及到三个操作数，当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新。<ul>\n<li><strong>V</strong> ：要更新的变量值(Var)</li>\n<li><strong>E</strong> ：预期值(Expected)</li>\n<li><strong>N</strong> ：拟写入的新值(New)</li>\n</ul>\n</li>\n<li>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Unsafe类提供了方法来实现CAS操作，内部使用C++内联汇编来实现\n&#x2F;**\n\t*  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  *&#x2F;\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n\npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线程暂停的四种方法</p>\n<ul>\n<li><code>join</code>：线程A在运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行</li>\n<li><code>sleep</code><strong><strong>：</strong></strong>使用当前正在执行的线程休眠millis秒，线程处于阻塞状态</li>\n<li><code>yield</code>：当前正在执行的线程暂停一次，允许其他线程执行，不阻塞，线程进入就绪状态，如果没有其他等待执行的线程，这个时候当前线程就会马上恢复执行</li>\n<li><code>stop</code>：强迫线程停止执行，已过时，不推荐使用</li>\n</ul>\n</li>\n<li><p><strong>把ArrayList变成线程安全有哪些方法</strong></p>\n<ul>\n<li>使用<code>Collections.synchronizedList()</code>方法将ArrayList转换为线程安全的list，会通过在访问方法上添加synchronized方法来保证线程安全</li>\n<li>使用CopyOnWriteArrayList类来替代ArrayList，通过写时复制机制来保证写操作的线程安全性，在读操作时不需要添加锁，提高读取效率</li>\n<li>使用Lock接口来实现同步，可以用ReentrantLock类来实现对ArrayList的同步操作，该类提供了与synchronized类似的功能，但是提供了更灵活的操作，如trylock()</li>\n<li>使用读写锁，用ReentrantReadWriteLock类来实现对ArrayList的读写操作的同步，该类提供了读锁和写锁两种锁，多个线程可以同时获取读锁，但是只有一个线程可以获取写锁，写操作前先获取写锁</li>\n</ul>\n</li>\n</ol>\n","text":"Java并发1.线程 线程 线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING 线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N） Java使用用户线程模型，上层JVM...","link":"","photos":[],"count_time":{"symbolsCount":"59k","symbolsTime":"54 mins."},"categories":[],"tags":[{"name":"language","slug":"language","count":3,"path":"api/tags/language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">Java并发</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">1.线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BA%92%E6%96%A5\"><span class=\"toc-text\">2.互斥</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1synchronized\"><span class=\"toc-text\">2.1synchronized</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2%E9%94%81\"><span class=\"toc-text\">2.2锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3%E8%A1%A5%E5%85%85\"><span class=\"toc-text\">2.3补充</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">3.同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">2.1条件变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88Semaphore%EF%BC%89\"><span class=\"toc-text\">2.2信号量（Semaphore）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3Latch-amp-Barrier\"><span class=\"toc-text\">2.3Latch&amp;Barrier</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-JUC\"><span class=\"toc-text\">4.JUC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B9%B6%E5%8F%91%E9%98%BB%E5%A1%9E%EF%BC%88xxxBlockingQueue%EF%BC%89\"><span class=\"toc-text\">1.并发阻塞（xxxBlockingQueue）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%88%86%E6%AE%B5%E5%8A%A0%E9%94%81%EF%BC%88ConcurrentHashMap%EF%BC%89\"><span class=\"toc-text\">2.分段加锁（ConcurrentHashMap）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%EF%BC%88CopyOnWriteArrayList%E3%80%81CopyOnWriteArraySet%EF%BC%89\"><span class=\"toc-text\">3.写时复制（CopyOnWriteArrayList、CopyOnWriteArraySet）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%97%A0%E9%94%81%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">5.无锁编程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95\"><span class=\"toc-text\">附录</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MySQL","uid":"838ae74e3a76757d637de803a615bfd9","slug":"MySQL","date":"2023-04-27T10:54:53.000Z","updated":"2023-08-05T14:34:50.595Z","comments":true,"path":"api/articles/MySQL.json","keywords":null,"cover":[],"text":"MySQL1.使用1.SQL语法 数据库概念：数据库（DB）、数据库管理系统（DBMS）、数据库系统（软件+数据库+DBA）、数据库管理员（DBA）、元祖（tuple 一行）、码（列）、候选码（唯一标识元祖）、主码（主键）、外码（另一表的主键）、主属性（候选码中的属性）、非主属性...","link":"","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"database","slug":"database","count":2,"path":"api/tags/database.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java特性","uid":"b4296f0600f693552b5b6c6b665f6025","slug":"Java Base","date":"2023-04-13T11:25:47.000Z","updated":"2023-08-06T14:00:00.799Z","comments":true,"path":"api/articles/Java Base.json","keywords":null,"cover":[],"text":"Java1.基础知识1.关键字 true, false, 和 null 虽然不是关键字，但它们是不能用作标识符的文字和保留字 strictfp（精确浮点数，跨平台产生相同结果）、native（原生方法） class return byte try if import public...","link":"","photos":[],"count_time":{"symbolsCount":"68k","symbolsTime":"1:02"},"categories":[],"tags":[{"name":"language","slug":"language","count":3,"path":"api/tags/language.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}