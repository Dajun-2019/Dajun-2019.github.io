{"title":"Linux","uid":"3fe1ee3f3830128bf539e5f4ed9fbbe9","slug":"Linux","date":"2023-05-11T11:26:21.000Z","updated":"2023-06-07T13:30:10.942Z","comments":true,"path":"api/articles/Linux.json","keywords":null,"cover":null,"content":"<h1 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h1><h2 id=\"1-操作系统原理\"><a href=\"#1-操作系统原理\" class=\"headerlink\" title=\"1.操作系统原理\"></a>1.操作系统原理</h2><h3 id=\"1-进程管理\"><a href=\"#1-进程管理\" class=\"headerlink\" title=\"1.进程管理\"></a>1.进程管理</h3><ol>\n<li>概念<ul>\n<li>进程：进程是资源调度的基本单位，启动main函数就是启动一个JVM进程，main函数所在的线程是这个进程的主线程</li>\n<li>线程：线程是CPU调度的基本单位，线程间共享堆和方法去资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈</li>\n<li>协程：由编程语言创建，又称为用户态线程；协程是异步非抢占式的，需要用户自己释放使用权来切换协程；线程数量在千万级别，而协程可以达到上万级别，因为线程是多核上并行，而协程是用来实现高并发的</li>\n</ul>\n</li>\n<li>进程通信的方式：匿名管道、命名管道、信号、消息队列、共享内存、内存映射、套接字、信号量<ul>\n<li>管道<ul>\n<li>匿名管道：Unix系统最古老的通信方式，通过在内核中维护一块内核缓冲区来实现通信，Linux系统中通过<code>pipi()</code>函数创建管道，会生成两个文件描述符，分别对应读端和写端，只能用于具有亲缘关系的进程间通信</li>\n<li>命名管道：为了解决匿名管道只能在具有亲缘关系的进程间通信的问题，通过将管道和一个路径名相关联，以FIFO的文件形式存在于文件系统中，没有亲缘关系的进程也可以像操作文件一样通过命名管道进行数据交换</li>\n</ul>\n</li>\n<li>信号：Linux系统最古老的通信方式，是一种异步通信的方式，信号可以导致一个正在运行的进程被另一个正在运行的进程中断，转而处理突发事件，是事件发生时对进程的通知机制</li>\n<li>消息队列：一个消息的链表，链表中的消息有特性格式和优先级，有对应权限的进程可以对其进行读写</li>\n<li>共享内存：允许两个或多个进程共享物理内存的同一块区域（称为段），由于一个共享内存段会成为一个进程用户空间的一部分，因此这种IPC机制无需内核介入，只需要一个进程将数据复制进共享内存中即可<ul>\n<li>共享内存：不同进程间共享的一段物理内存，所有进程都可以访问共享内存中的地址，改动对所有进程可见。优点是可以直接访问速度更快；缺点是需要额外的同步机制来互斥访问</li>\n</ul>\n</li>\n<li>内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</li>\n<li>信号量：用于解决进程或线程之间并发执行是的同步问题，对信号量的操作主要有P操作和V操作</li>\n<li>Socket：对网络中不同主机上的应用进程之间进行双向通信的段点的抽象，提供了应用层进程利用网络协议交换数据的机制，用于网络中不同主机上的进程之间进行通信</li>\n</ul>\n</li>\n<li>进程调度<ul>\n<li>算法<ul>\n<li>先来先服务（FCFS）：选最早</li>\n<li>短作业/进程优先（SJF/SPF）：选最短（平均等待时间、平均周转时间最少）</li>\n<li>优先级调度：选优先级最高（净：sys&gt;users、交互&gt;非交互、I/O&gt;CPU）</li>\n<li>高相应比优先（HRRN）：响应比最高<br>（等待时间+需服务时间）/需服务时间</li>\n<li>时间片轮转（RR）：分时OS、绝对可抢占</li>\n<li>多级反馈队列：1+3+5、“UNIX”、优先级高到低、时间片小到大（上无才执行下</li>\n</ul>\n</li>\n<li>不能调度（处理中断、临界区、屏蔽中断）；剥夺与非剥夺调度（早期批处理）【在进程处于临界区时，只要不破坏临界区资源使用规则就不影响处理机调度】</li>\n<li>评估指标：CPU利用率（忙碌时间/总时间）、系统吞吐量（完成作业数/总时间）、平均周转时间（提交到完成/n=（等待+执行）/n）、带权周转时间（作业周转时间/实际运行时间，越小越好必然大于1）、等待时间（等处理机状态）、响应时间（提交请求到首次响应）</li>\n</ul>\n</li>\n<li>死锁<ul>\n<li>死锁定义：多个进程因竞争资源而造成的一种僵局（互相等待）若无外力作用，这些进程都将无法向前推进</li>\n<li>产生原因：竞争资源、进程推进非法</li>\n<li>必要条件：互斥访问临界区资源、请求和保持、不剥夺、环路等待（等待的进程成环）</li>\n<li>预防死锁：破坏互斥（资源共享使用）、破坏不剥夺、破坏请求和保持（预先静态分配）、破坏循环等待（顺序资源分配）（必要条件）</li>\n<li>避免死锁：安全状态（不一定是死锁状态）、银行家算法（必须知道将来的资源请求）、安全性算法</li>\n<li>检测死锁：利用死锁定理化简资源分配图（圆圈代表进程，框代表一类资源，一个圆代表一个该类资源，进程到资源为请求边，资源到进程为分配边）把圈都变成孤点</li>\n<li>解除死锁：资源剥夺、撤销进程、进程回退</li>\n<li>死锁检测：银行家算法<ul>\n<li>Max、Allocation、Need</li>\n<li>Work、Need、Allocation、W+A（分配一个写一行，一行一行写）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h3 id=\"2-内存管理\"><a href=\"#2-内存管理\" class=\"headerlink\" title=\"2.内存管理\"></a>2.内存管理</h3><ol>\n<li>分段、分页、段页式<ul>\n<li>分段：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息，段与段之间可以不相邻接。主要是为了程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护，反应程序的逻辑结构有利于段的共享</li>\n<li>分页：用户程序的地址空间划分为若干个固定大小的页，内存空间分成若干个物理块，页和快的大小相等，可以将任一页放在任一块中。主要用于实现虚拟内存，从而获得更大的地址空间，可以解决内存碎片，提高内存利用率</li>\n<li>段页式：段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。系统同时配置段表和页表，每个进程一张段表，没个分段一张页表，利用段表和页表进行用户地址空间到物理内存空间的映射。<ul>\n<li>段表项包括段号、页表长度、页表起始地址；页表项包括页号、块号。在进行地址转换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最终形成物理地址。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>虚拟内存和物理内存<ul>\n<li>物理内存：使用物理地址进行寻址，寻址的范围取决于CPU的地址线条数（如32位平台下寻址范围为2^32即4G），每次开启一个线程都要给4G物理内存，资源不够时没分配到资源的进程只能等待，并且资源不隔离导致数据不安全</li>\n<li>虚拟内存：让应用程序以为自己拥有连续的可用内存（连续完整的地址空间），实际上被分割成多个物理内存分片，还有部分存储在外部磁盘存储器上，在需要时进行数据交换</li>\n</ul>\n</li>\n<li>内存泄漏<ul>\n<li>程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</li>\n<li>避免内存泄漏：动态开辟内存空间、及时释放内存、使用智能指针，采用静态分析技术（LCLink、ccmalloc、Dmalloc、Electric Fence、Leaky、LeakTracer、MEMWATCH、Valgrind、KCachegrind）来进行检测</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-文件管理\"><a href=\"#3-文件管理\" class=\"headerlink\" title=\"3.文件管理\"></a>3.文件管理</h3><ol>\n<li>IO模型<ul>\n<li>同步阻塞IO（BIO）：jdk1.4之前支持<ul>\n<li>服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求，必须等待上一个请求被处理完</li>\n<li>服务端采用多线程，当accept一个请求后，开启线程进行recv，通过多个线程可以完成并发处理，但是大量的线程占用大量的内存空间，并且线程切换会带来巨大的开销</li>\n</ul>\n</li>\n<li>同步非阻塞IO（NIO）：jdk1.4之后的java.nio包<ul>\n<li>服务器accept一个请求后，加入文件描述符集合，每次轮询一遍文件描述符集合来recv数据，没有数据立即返回错误，每次轮询所有文件描述符很浪费时间</li>\n</ul>\n</li>\n<li>IO多路复用（select、poll、epoll、aio、libevent、libuv）：见下</li>\n<li>信号驱动的IO（SIGIO）</li>\n<li>异步IO（POSIX的aio_functions）<ul>\n<li>异步非阻塞IO，在进行IO操作时，不需要等待操作完成就可以进行其他操作，当操作完成后自动回调通知，jdk1.7之后java.nio包下的java.nio.channels.AsynchronousSocketChannel等。但是linux下AIO支持并不好并且相比NIO性能提升不明显，所以Netty在4.x舍弃了AIO</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Reactor模式和Proactor模式<ul>\n<li>Reactor模式：要求主线程只负责监听文件描述符上是否有事件发生，有的话立即将该事件通知工作线程，将socket可读可写事件方去请求队列，交给工作线程来处理，使用epoll实现的工作流程如下：<ul>\n<li>主线程向epoll内核事件表中注册socket上的读就绪事件</li>\n<li>可读<ul>\n<li>主线程调用<code>epoll_wait</code>等待socket上有数据可读</li>\n<li>当socket上有数据可读时，<code>epoll_wait</code>通知主线程，主线程将socket可读事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>\n</ul>\n</li>\n<li>可写<ul>\n<li>当主线程调用<code>epoll_wait</code>等待socket可写</li>\n<li>当socket可写时，<code>epoll_wait</code>通知主线程。主线程将socket可写事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket上写入服务器处理客户请求的结果</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Proactor模式</li>\n</ul>\n</li>\n<li>IO多路复用技术<ul>\n<li><p>select模型：采用轮询和遍历的方式，在客户端操作服务器时，会创建三种文件描述符（写描述符、读描述符、异常描述符），select会阻塞这三种文件描述符，等有数据可读、可写、异常或超时都会返回。然后通过遍历文件描述符集合来找到就绪的文件描述符，进行IO操作。由于每次都需要遍历所有文件描述符，所以性能随着描述符的增多而减小</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int main()&#123;\n\t&#x2F;&#x2F;socket 建立、地址设置\n\tfd_set read_fs,write_set;\n\tstruct timeval timeout;\n\tint max &#x3D; 0;&#x2F;&#x2F;用于记录最大的fd，在轮询中时刻更新\n\t&#x2F;&#x2F;初始化比特位\n\tFD_ZERO（&amp;read_fs);\n\tFD_ZERO(&amp;write_fs);\n\t\n\tint nfds &#x3D; 0;&#x2F;&#x2F;记录就绪的事件，可以减少遍历的次数\n\twhile(1）&#123;\n\t&#x2F;&#x2F;阻塞获取，每次需要把fd从用户态拷贝到内核态\n\tnfds &#x3D; select(max+1, &amp;read_fd, &amp;write_fd, NULL, &amp;timeout);\n\t&#x2F;&#x2F;每次需要遍历所有fd，判断有无读写事件发生\n\tfor(int i &#x3D; 0; i &lt;&#x3D; max &amp;&amp; nfds; ++i)&#123;\n\t\tif(i &#x3D;&#x3D; listenfd)&#123;\n\t\t\t--nfds;\n\t\t\t&#x2F;&#x2F;处理accept事件\n\t\t\tFD_SET(i, &amp;read_fd);&#x2F;&#x2F;将客户端socket加入到集合中\n\t\t&#125;\n\t\tif(FD_ISSET(i, &amp;read_fd))&#123;\n\t\t\t--nfds;\n\t\t\t&#x2F;&#x2F;处理read事件\n\t\t&#125;\n\t\tif (FD_ISSET(i, &amp;write_fd)) &#123;\n\t\t\t --nfds;\n\t     &#x2F;&#x2F; 这里处理write事件\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>poll模型：poll模型的原理与select模型基本一致，也是轮询+遍历，区别在于poll采用链表的方式来存储文件描述符，同select一样，性能随着描述符的增多而减小</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;poll.h&gt;\n&#x2F;&#x2F; 数据结构\nstruct pollfd &#123;\n    int fd;                         &#x2F;&#x2F; 需要监视的文件描述符\n    short events;                   &#x2F;&#x2F; 需要内核监视的事件\n    short revents;                  &#x2F;&#x2F; 实际发生的事件\n&#125;;\n\n&#x2F;&#x2F; API\nint poll(struct pollfd fds[], nfds_t nfds, int timeout);</code></pre></li>\n<li><p>epoll模型：采用时间通知机制来触发相关的IO操作，没有文件描述符个数的限制，从用户态拷贝到内核态只需要一次。它主要通过系统底层的函数来注册、激活文件描述符，从而触发相关的IO操作，这样大大提高了提高性能（Redis、Nginx等，1G内存大概支持10万个句柄）</p>\n<ul>\n<li><p>将轮询改成了回调，提高了CPU执行效率、没有文件描述符数量限制、性能不会随文件描述符的增加而减小，内存拷贝（利用mmap文件映射内存加速与内核空间的消息传递，减少复制开销）</p>\n</li>\n<li><p>epoll水平触发（LT）和边缘触发（ET）的区别</p>\n<ul>\n<li>Level Triggered（LT）水平触发：只要有数据就会触发，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作</li>\n<li>Edge Triggered（ET）边缘触发：只有数据到来，才触发，只会提示一次，直到下次数据流入</li>\n</ul>\n</li>\n<li><p>相关的系统调用</p>\n<ul>\n<li>epoll_create：系统启动的时候，在Linux内核里面申请一个B+树结构的文件系统，然后返回epoll对象（一个文件描述符）用来后续使用</li>\n<li>epoll_ctl：每新建一个连接的时候，会同步更新epoll对象中的文件描述符，并且绑定一个callback函数<ul>\n<li>通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0表示成功</li>\n</ul>\n</li>\n<li>epoll_wait：轮询所有的callback集合（红黑树），并触发相应的IO操作<ul>\n<li>通过此调用收集在epoll监控中已发生的事件</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;sys&#x2F;epoll.h&gt;\n\n&#x2F;&#x2F; 每一个epoll对象都有一个独立的eventpoll结构体\n&#x2F;&#x2F; 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件\n&#x2F;&#x2F; epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可\nstruct eventpoll &#123;\n    &#x2F;*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*&#x2F;\n    struct rb_root  rbr;\n    &#x2F;*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*&#x2F;\n    struct list_head rdlist;\n&#125;;\n\n&#x2F;&#x2F;在epoll中，对于每一个事件，都会建立一个epitem结构体\nstruct epitem&#123;\n    struct rb_node  rbn;&#x2F;&#x2F;红黑树节点\n    struct list_head    rdllink;&#x2F;&#x2F;双向链表节点\n    struct epoll_filefd  ffd;  &#x2F;&#x2F;事件句柄信息\n    struct eventpoll *ep;    &#x2F;&#x2F;指向其所属的eventpoll对象\n    struct epoll_event event; &#x2F;&#x2F;期待发生的事件类型\n&#125;\n\n&#x2F;&#x2F; API\nint epoll_create(int size); &#x2F;&#x2F; 内核中间加一个 eventpoll 对象，把所有需要监听的 socket 都放到 ep 对象中\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); &#x2F;&#x2F; epoll_ctl 负责把 socket 增加、删除到内核红黑树\n&#x2F;&#x2F; 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);&#x2F;&#x2F; epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Nginx的IO模型：支持多种并发模型，自动选择最高效的模型，也可以使用use指令在配置文件中显示指定某个并发模型，如下所示<ul>\n<li>select：编译时，所用平台没有更高效的并发模型时，select被自动编译</li>\n<li>poll：标准并发模型，同select一样，所用平台没有更高效的并发模型时，pol被自动编译</li>\n<li>epoll：IO多路复用，高效并发模型，Linux2.6+可以使用</li>\n<li>kequeue：IO多路复用，高效并发模型，可在 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0, and Mac OS X 平台中使用</li>\n<li>/dev/poll：高效并发模型，可在 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+, and Tru64 UNIX 5.1A+ 平台使用</li>\n<li>eventport：建议 使用/dev/poll替代</li>\n</ul>\n</li>\n<li>Redis的IO模型：Redis跑在单线程中，所有操作都是按照顺序线性执行的，为了防止IO阻塞整个Redis进程，所以使用IO多路复用技术。Redis的IO复用技术基于epoll实现，另外提供了select和kqueue的实现</li>\n</ol>\n<h2 id=\"2-网络协议\"><a href=\"#2-网络协议\" class=\"headerlink\" title=\"2.网络协议\"></a>2.网络协议</h2><h3 id=\"1-网络层\"><a href=\"#1-网络层\" class=\"headerlink\" title=\"1.网络层\"></a>1.网络层</h3><ol>\n<li><h2 id=\"IP\"><a href=\"#IP\" class=\"headerlink\" title=\"IP\"></a>IP</h2></li>\n<li><h2 id=\"路由协议：ODPF、RIP\"><a href=\"#路由协议：ODPF、RIP\" class=\"headerlink\" title=\"路由协议：ODPF、RIP\"></a>路由协议：ODPF、RIP</h2></li>\n<li><h2 id=\"数据链路层：ARP\"><a href=\"#数据链路层：ARP\" class=\"headerlink\" title=\"数据链路层：ARP\"></a>数据链路层：ARP</h2></li>\n<li><h2 id=\"应用层：DNS\"><a href=\"#应用层：DNS\" class=\"headerlink\" title=\"应用层：DNS\"></a>应用层：DNS</h2></li>\n<li><h2 id=\"应用层：DHCP\"><a href=\"#应用层：DHCP\" class=\"headerlink\" title=\"应用层：DHCP\"></a>应用层：DHCP</h2></li>\n</ol>\n<h3 id=\"2-传输层\"><a href=\"#2-传输层\" class=\"headerlink\" title=\"2.传输层\"></a>2.传输层</h3><ol>\n<li>TCP</li>\n<li>UDP</li>\n<li>QUIC</li>\n</ol>\n<h3 id=\"3-应用层\"><a href=\"#3-应用层\" class=\"headerlink\" title=\"3.应用层\"></a>3.应用层</h3><ol>\n<li>HTTP<ul>\n<li>状态码：<strong>1xx</strong>（表示目前是协议处理的中间状态，还需要后续操作）、<strong>2xx</strong>（表示成功状态）、<strong>3xx</strong>（重定向状态，资源位置发生变动，需要重新请求）、<strong>4xx</strong>（请求报文有误）、<strong>5xx</strong>（服务端发生错误）</li>\n<li>HTTP/1.1<ul>\n<li>method</li>\n<li>status codes</li>\n<li>header fields</li>\n<li>URIs</li>\n</ul>\n</li>\n<li>HTTP/2<ul>\n<li>TLS</li>\n<li>数据传输方式</li>\n</ul>\n</li>\n<li>HTTP缓存</li>\n<li>session&amp;cookie</li>\n</ul>\n</li>\n<li>HTTPS</li>\n<li>SSL/TLS</li>\n<li>DNS</li>\n<li>DHCP</li>\n<li>RPC</li>\n</ol>\n<h2 id=\"3-实践\"><a href=\"#3-实践\" class=\"headerlink\" title=\"3.实践\"></a>3.实践</h2><h3 id=\"1-Termianl\"><a href=\"#1-Termianl\" class=\"headerlink\" title=\"1.Termianl\"></a>1.Termianl</h3><ol>\n<li>目录结构：/bin：命令、/etc：系统管理所需要的配置文件和子目录、/home：用户的主目录、/lib：系统最基本的动态连接共享库、/opt：额外安装软件所摆放的目录、/root：管理员主目录、/sbin：管理员使用的命令、/tmp：存放临时文件、/usr：用户的应用程序和文件、/var：存不断扩充的文件，如日志文件</li>\n<li>命令<ul>\n<li>文件管理：ls、ll、cd、pwd、mkdir、rmdir、rm、cp、mv、touch、chown、chmod、tar、</li>\n<li>文档编辑：cat、tac、nl、more、less、head、tail、grep（文本搜索）、awk（自定义函数或正则表达式）、sed（批量编辑文本文件）</li>\n<li>进程监控：<code>su</code>、<code>sudo</code>、<code>kill</code>（<code>kill -9 pid</code>）、管道命令、<code>ps</code>（<code>ps -ef | more</code>进程信息）、<code>top</code>（实时显示进程信息）、<code>lsof</code>（查看某一文件的进程信息）、<code>free</code>（查看内存使用情况，如进程、CPU占用率、内存信息）、<code>df</code>（磁盘使用量）、<code>iostat</code>（I/O设备状态）、<code>vmstat</code>（虚拟内存状态）、du（磁盘使用情况）</li>\n<li>网络监控：<code>iperf</code>（查看带宽和网络）、<code>netstat</code>（查看占用端口的进程）、<code>traceroute</code>（数据包路径）、<code>ping</code>（测试与主机的连通性）、</li>\n<li>其它：strace、dtrace、systemtap、uname、history</li>\n</ul>\n</li>\n<li>Bash脚本</li>\n<li>Vim编辑器</li>\n<li>常见系统调用<ul>\n<li>文件管理：creat、open、close、lseek（定位）、read、write</li>\n<li>进程管理：fork、execve（执行新二进制文件）、waitpid（等待子进程结束）、clone、exit</li>\n<li>内存管理：brk、mmap（内存映射）</li>\n<li>进程间通信：<ul>\n<li>消息队列：msgget（创建队列）、msgsnd（发送消息）、msgrcv（接收消息）</li>\n<li>共享内存：shmget（创建共享内存）、shmat（将共享内存映射到内存空间）</li>\n<li>信号量：sem_wait(抢占信号量)、sem_post（释放信号量）</li>\n</ul>\n</li>\n<li>网络通信：socket、bind、connect、listen、accept</li>\n<li>信号处理：kill、signaction</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-Sockets\"><a href=\"#2-Sockets\" class=\"headerlink\" title=\"2.Sockets\"></a>2.Sockets</h3><h3 id=\"3-Processes\"><a href=\"#3-Processes\" class=\"headerlink\" title=\"3.Processes\"></a>3.Processes</h3>","feature":true,"text":"Linux1.操作系统原理1.进程管理 概念 进程：进程是资源调度的基本单位，启动main函数就是启动一个JVM进程，main函数所在的线程是这个进程的主线程 线程：线程是CPU调度的基本单位，线程间共享堆和方法去资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈 协程：由...","link":"","photos":[],"count_time":{"symbolsCount":"8.5k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux\"><span class=\"toc-text\">Linux</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.操作系统原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.进程管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">2.内存管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.文件管理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">2.网络协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">1.网络层</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IP\"><span class=\"toc-text\">IP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE%EF%BC%9AODPF%E3%80%81RIP\"><span class=\"toc-text\">路由协议：ODPF、RIP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%EF%BC%9AARP\"><span class=\"toc-text\">数据链路层：ARP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9ADNS\"><span class=\"toc-text\">应用层：DNS</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%9ADHCP\"><span class=\"toc-text\">应用层：DHCP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BC%A0%E8%BE%93%E5%B1%82\"><span class=\"toc-text\">2.传输层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%BA%94%E7%94%A8%E5%B1%82\"><span class=\"toc-text\">3.应用层</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">3.实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Termianl\"><span class=\"toc-text\">1.Termianl</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Sockets\"><span class=\"toc-text\">2.Sockets</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Processes\"><span class=\"toc-text\">3.Processes</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Spring Family","uid":"0eecce2180060832c1ffa34a76f3eb3b","slug":"Spring","date":"2023-05-06T05:09:43.000Z","updated":"2023-05-25T02:15:26.510Z","comments":true,"path":"api/articles/Spring.json","keywords":null,"cover":[],"text":"Spring1.IOC1.基础知识 BeanFactory：提供了一种高级配置，能够管理任何类型对象，BeanFactory是ApplicationContext的父接口，ApplicationContext接口的实现类主要有ClassPathXmlApplicationCont...","link":"","photos":[],"count_time":{"symbolsCount":"58k","symbolsTime":"52 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}