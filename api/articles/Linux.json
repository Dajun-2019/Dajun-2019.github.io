{"title":"Linux","uid":"3fe1ee3f3830128bf539e5f4ed9fbbe9","slug":"Linux","date":"2023-05-11T11:26:21.000Z","updated":"2023-08-01T12:28:26.787Z","comments":true,"path":"api/articles/Linux.json","keywords":null,"cover":[],"content":"<h1 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h1><h2 id=\"1-操作系统原理\"><a href=\"#1-操作系统原理\" class=\"headerlink\" title=\"1.操作系统原理\"></a>1.操作系统原理</h2><h3 id=\"1-进程管理\"><a href=\"#1-进程管理\" class=\"headerlink\" title=\"1.进程管理\"></a>1.进程管理</h3><ol>\n<li>概念<ul>\n<li>进程：进程是资源调度的基本单位，启动main函数就是启动一个JVM进程，main函数所在的线程是这个进程的主线程</li>\n<li>线程：线程是CPU调度的基本单位，线程间共享堆和方法去资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈</li>\n<li>协程：由编程语言创建，又称为用户态线程；协程是异步非抢占式的，需要用户自己释放使用权来切换协程；线程数量在千万级别，而协程可以达到上万级别，因为线程是多核上并行，而协程是用来实现高并发的</li>\n</ul>\n</li>\n<li>进程通信的方式：匿名管道、命名管道、信号、消息队列、共享内存、内存映射、套接字、信号量<ul>\n<li>管道<ul>\n<li>匿名管道：Unix系统最古老的通信方式，通过在内核中维护一块内核缓冲区来实现通信，Linux系统中通过<code>pipi()</code>函数创建管道，会生成两个文件描述符，分别对应读端和写端，只能用于具有亲缘关系的进程间通信</li>\n<li>命名管道：为了解决匿名管道只能在具有亲缘关系的进程间通信的问题，通过将管道和一个路径名相关联，以FIFO的文件形式存在于文件系统中，没有亲缘关系的进程也可以像操作文件一样通过命名管道进行数据交换</li>\n</ul>\n</li>\n<li>信号：Linux系统最古老的通信方式，是一种异步通信的方式，信号可以导致一个正在运行的进程被另一个正在运行的进程中断，转而处理突发事件，是事件发生时对进程的通知机制</li>\n<li>消息队列：一个消息的链表，链表中的消息有特性格式和优先级，有对应权限的进程可以对其进行读写</li>\n<li>共享内存：允许两个或多个进程共享物理内存的同一块区域（称为段），由于一个共享内存段会成为一个进程用户空间的一部分，因此这种IPC机制无需内核介入，只需要一个进程将数据复制进共享内存中即可<ul>\n<li>共享内存：不同进程间共享的一段物理内存，所有进程都可以访问共享内存中的地址，改动对所有进程可见。优点是可以直接访问速度更快；缺点是需要额外的同步机制来互斥访问</li>\n</ul>\n</li>\n<li>内存映射：将磁盘文件的数据映射到内存，用户通过修改内存就能修改磁盘文件</li>\n<li>信号量：用于解决进程或线程之间并发执行是的同步问题，对信号量的操作主要有P操作和V操作</li>\n<li>Socket：对网络中不同主机上的应用进程之间进行双向通信的段点的抽象，提供了应用层进程利用网络协议交换数据的机制，用于网络中不同主机上的进程之间进行通信</li>\n</ul>\n</li>\n<li>进程调度<ul>\n<li>算法<ul>\n<li>先来先服务（FCFS）：选最早</li>\n<li>短作业/进程优先（SJF/SPF）：选最短（平均等待时间、平均周转时间最少）</li>\n<li>优先级调度：选优先级最高（净：sys&gt;users、交互&gt;非交互、I/O&gt;CPU）</li>\n<li>高相应比优先（HRRN）：响应比最高<br>（等待时间+需服务时间）/需服务时间</li>\n<li>时间片轮转（RR）：分时OS、绝对可抢占</li>\n<li>多级反馈队列：1+3+5、“UNIX”、优先级高到低、时间片小到大（上无才执行下</li>\n</ul>\n</li>\n<li>不能调度（处理中断、临界区、屏蔽中断）；剥夺与非剥夺调度（早期批处理）【在进程处于临界区时，只要不破坏临界区资源使用规则就不影响处理机调度】</li>\n<li>评估指标：CPU利用率（忙碌时间/总时间）、系统吞吐量（完成作业数/总时间）、平均周转时间（提交到完成/n=（等待+执行）/n）、带权周转时间（作业周转时间/实际运行时间，越小越好必然大于1）、等待时间（等处理机状态）、响应时间（提交请求到首次响应）</li>\n</ul>\n</li>\n<li>死锁<ul>\n<li>死锁定义：多个进程因竞争资源而造成的一种僵局（互相等待）若无外力作用，这些进程都将无法向前推进</li>\n<li>产生原因：竞争资源、进程推进非法</li>\n<li>必要条件：互斥访问临界区资源、请求和保持、不剥夺、环路等待（等待的进程成环）</li>\n<li>预防死锁：破坏互斥（资源共享使用）、破坏不剥夺、破坏请求和保持（预先静态分配）、破坏循环等待（顺序资源分配）（必要条件）</li>\n<li>避免死锁：安全状态（不一定是死锁状态）、银行家算法（必须知道将来的资源请求）、安全性算法</li>\n<li>检测死锁：利用死锁定理化简资源分配图（圆圈代表进程，框代表一类资源，一个圆代表一个该类资源，进程到资源为请求边，资源到进程为分配边）把圈都变成孤点</li>\n<li>解除死锁：资源剥夺、撤销进程、进程回退</li>\n<li>死锁检测：银行家算法<ul>\n<li>Max、Allocation、Need</li>\n<li>Work、Need、Allocation、W+A（分配一个写一行，一行一行写）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>线程通信方式：Monitor、Condition<ul>\n<li>在Java中,常用的线程通信方式有两种,分别是利用<code>Monitor</code>实现线程通信、利用<code>Condition</code>实现线程通信。线程同步是线程通信的前提,所以究竟采用哪种方式实现通信,取决于线程同步的方式。</li>\n<li>如果是采用<code>synchronized</code>关键字进行同步,则需要依赖<code>Monitor</code>（同步监视器）实现线程通信，Monitor就是锁对象。在synchronized同步模式下,锁对象可以是任意的类型,所以通信方法自然就被定义在Object类中了,这些方法包括：<code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code>。一个线程通过<code>Monitor</code>调用<code>wait()</code>时,它就会释放锁并在此等待。当其他线程通过Monitor调用notify()时,则会唤醒在此等待的一个线程。当其他线程通过Monitor调用notifyAll()时,则会唤醒在此等待的所有线程。</li>\n<li>JDK 1.5新增了<code>Lock</code>接口及其实现类,提供了更为灵活的同步方式。如果是采用<code>Lock</code>对象进行同步,则需要依赖<code>Condition</code>实现线程通信，<code>Condition</code>对象是由<code>Lock</code>对象创建出来的,它依赖于<code>Lock</code>对象。<code>Condition</code>对象中定义的通信方法,与Object类中的通信方法类似,它包括<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>。通过名字就能看出它们的含义了,当通过Condition调用<code>await()</code>时当前线程释放锁并等待,当通过Condition调用<code>signal()</code>时唤醒一个等待的线程,当通过Condition调用<code>signalAll()</code>时则唤醒所有等待的线程。</li>\n<li>线程同步是基于同步队列实现的,而线程通信是基于等待队列实现的。当调用等待方法时，即将当前线程加入等待队列。当调用通知方法时,即将等待队列中的一个或多个线程转移回同步队列。因为<code>synchronized</code>只有一个<code>Monitor</code>，所以它就只有一个等待队列。而<code>Lock</code>对象可以创建出多个<code>Condition</code>，所以它拥有多个等待队列。多个等待队列带来了极大的灵活性,所以基于<code>Condition</code>的通信方式更为推荐</li>\n<li>比如，在实现生产消费模型时，生产者要通知消费者、消费者要通知生产者。相反，不应该出现生产者通知生产者、消费者通知消费者这样的情况。如果使用<code>synchronized</code>实现这个模型，由于它只有一个等待队列,所以只能把生产者和消费者加入同一个队列,这就会导致生产者通知生产者、消费者通知消费者的情况出现。采用<code>Lock</code>实现这个模型时，由于它有多个等待队列，可以有效地将这两个角色区分开，就能避免出现这样的问题。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-内存管理\"><a href=\"#2-内存管理\" class=\"headerlink\" title=\"2.内存管理\"></a>2.内存管理</h3><ol>\n<li>分段、分页、段页式<ul>\n<li>分段：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息，段与段之间可以不相邻接。主要是为了程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护，反应程序的逻辑结构有利于段的共享</li>\n<li>分页：用户程序的地址空间划分为若干个固定大小的页，内存空间分成若干个物理块，页和快的大小相等，可以将任一页放在任一块中。主要用于实现虚拟内存，从而获得更大的地址空间，可以解决内存碎片，提高内存利用率</li>\n<li>段页式：段页式存储管理方式即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。系统同时配置段表和页表，每个进程一张段表，没个分段一张页表，利用段表和页表进行用户地址空间到物理内存空间的映射。<ul>\n<li>段表项包括段号、页表长度、页表起始地址；页表项包括页号、块号。在进行地址转换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最终形成物理地址。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>虚拟内存和物理内存<ul>\n<li>物理内存：使用物理地址进行寻址，寻址的范围取决于CPU的地址线条数（如32位平台下寻址范围为2^32即4G），每次开启一个线程都要给4G物理内存，资源不够时没分配到资源的进程只能等待，并且资源不隔离导致数据不安全</li>\n<li>虚拟内存：让应用程序以为自己拥有连续的可用内存（连续完整的地址空间），实际上被分割成多个物理内存分片，还有部分存储在外部磁盘存储器上，在需要时进行数据交换</li>\n</ul>\n</li>\n<li>内存泄漏<ul>\n<li>程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</li>\n<li>避免内存泄漏：动态开辟内存空间、及时释放内存、使用智能指针，采用静态分析技术（LCLink、ccmalloc、Dmalloc、Electric Fence、Leaky、LeakTracer、MEMWATCH、Valgrind、KCachegrind）来进行检测</li>\n</ul>\n</li>\n<li>堆和栈的区别<ul>\n<li>管理方式：堆手动控制，栈由编译器自动管理</li>\n<li>空间大小：栈小于堆，栈会出现OOM问题</li>\n<li>碎片问题：堆频繁的分配和释放会造成空间不连续，利用率低，栈不会</li>\n<li>增长方向：堆是向上的（内存地址增加），栈是向下的（内存地址减小）</li>\n<li>分配方式：堆都是动态分配的，没有静态分配的堆。栈有两种分配方式：静态分配和动态分配，静态分配是编译器完成的，比如局部变量的分配；动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器实现的，无需我们手工实现</li>\n<li>分配效率：栈有寄存器、底层指令的支持，堆是由C/C++来提供的，根据算法在内存中找可用空间，所以堆的效率要比栈低的多</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h3 id=\"3-文件管理\"><a href=\"#3-文件管理\" class=\"headerlink\" title=\"3.文件管理\"></a>3.文件管理</h3><ol>\n<li>IO模型<ul>\n<li><p>同步阻塞IO（BIO）「jdk1.4之前支持」：服务端采用单线程，当accept一个请求后，在recv或send调用阻塞时，将无法accept其他请求，必须等待上一个请求被处理完；服务端采用多线程，当accept一个请求后，开启线程进行recv，通过多个线程可以完成并发处理，但是大量的线程占用大量的内存空间，并且线程切换会带来巨大的开销</p>\n<ul>\n<li>阻塞和非阻塞：数据未准备好时请求数据，等待数据就是阻塞，直接返回多次请求就是非阻塞</li>\n<li>同步与异步：同步模式由用户线程的内核态执行内核空间到用户空间的数据拷贝，异步模式由内核来执行数据拷贝执行完通知用户线程并将数据回调给用户线程</li>\n<li>阻塞读/写：执行read或send系统调用时，用户线程从用户态切换到内核态，执行用户空间拷贝到内核空间的Socket发送缓冲区之间的数据拷贝。读时如果没有数据则线程进入阻塞状态，直到有数据后唤醒线程；写时如果无法一次容纳所有的数据，则让出CPU，直到空间够用时执行写流程</li>\n</ul>\n</li>\n<li><p>同步非阻塞IO（NIO）「jdk1.4之后的java.nio包」：服务器accept一个请求后，加入文件描述符集合，每次轮询一遍文件描述符集合来recv数据，没有数据立即返回错误，每次轮询所有文件描述符很浪费时间</p>\n<ul>\n<li>阻塞IO的问题是一个线程只能处理一个连接，非阻塞IO就是为了解决这样的问题</li>\n<li>非阻塞读：当无数据时，系统调用立刻返回并带一个<code>EWOULDBLOCK</code> 或 <code>EAGAIN</code>错误，这个阶段用户线程不会阻塞也不会让出CPU，而是会继续轮训直到socket接收缓冲区中有数据为止</li>\n<li>非阻塞写：能写多少写多少，不用一次写完，写不下了返回已经写入的字节数，方便下一次轮训来写剩下的数据</li>\n</ul>\n</li>\n<li><p>IO多路复用（select、poll、epoll、aio、libevent、libuv）：见下</p>\n<ul>\n<li><p>在阻塞IO模型中一个连接就需要分配一个独立的线程去专门处理这个连接上的读写，到了IO多路复用模型中，多个连接可以复用这一个独立的线程去处理这多个连接上的读写，通过使用操作系统内核来执行轮训操作，减少系统调用和内核切换的次数</p>\n</li>\n<li><p>select：将轮询的操作交给了内核来完成，调用并阻塞在<code>select</code>系统调用上，并通过<code>select</code>将文件描述符<code>fd</code>数组（BitMap，1表示该fd上有读写事件）通过<code>select</code>系统调用传递给内核。<code>select</code>通过内核来轮询遍历<code>fd</code>数组，有数据来就设置为1否则设置为0，如果有新的数据来就将修改后的<code>fd</code>数组返回给用户线程。用户线程接触阻塞，开始遍历fd数组对值为1的scoket文件描述符发起系统调用。仍需要上下文切换和数据拷贝，还需要遍历结果，所以只能处理1000个左右的并发连接</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">&#x2F;&#x2F;select系统调用是在规定的超时时间内，监听（轮询）用户感兴趣的文件描述符集合上的可读,可写,异常三类事件\n&#x2F;&#x2F;这里的fd_set就是前边提到的fd数组，是一个BitMap结构\nint select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)\n&#x2F;&#x2F;用户线程中重新遍历fd数组的过程中，需要用到的API\nvoid FD_ZERO(fd_set *fdset)  &#x2F;&#x2F;清空指定的文件描述符集合，即让fd_set中不在包含任何文件描述符\nvoid FD_SET(int fd, fd_set *fdset)  &#x2F;&#x2F;将一个给定的文件描述符加入集合之中\nint FD_ISSET(int fd, fd_set *fdset)  &#x2F;&#x2F;检查集合中指定的文件描述符是否可以读写。用户线程遍历文件描述符集合,调用该方法检查相应的文件描述符是否IO就绪\nvoid FD_CLR(int fd, fd_set *fdset)  &#x2F;&#x2F;将一个给定的文件描述符从集合中删除</code></pre></li>\n<li><p>poll：poll相当于是改进版的select，但是工作原理基本和select没有本质的区别</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int poll(struct pollfd *fds, unsigned int nfds, int timeout)\nstruct pollfd &#123;\n    int   fd;         &#x2F;* 文件描述符 *&#x2F;\n    short events;     &#x2F;* 需要监听的事件 *&#x2F;\n    short revents;    &#x2F;* 实际发生的事件 由内核修改设置 *&#x2F;\n&#125;;  &#x2F;&#x2F;将BitMap结构改成pollfd，即没有固定长度的数组，这样就没有最大描述符数量的限制，只受限于系统文件描述符最大数量</code></pre></li>\n</ul>\n</li>\n<li><p>信号驱动的IO（SIGIO）</p>\n</li>\n<li><p>异步IO（POSIX的aio_functions）</p>\n<ul>\n<li>异步非阻塞IO，在进行IO操作时，不需要等待操作完成就可以进行其他操作，当操作完成后自动回调通知，jdk1.7之后java.nio包下的java.nio.channels.AsynchronousSocketChannel等。但是linux下AIO支持并不好并且相比NIO性能提升不明显，所以Netty在4.x舍弃了AIO</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Reactor模式和Proactor模式<ul>\n<li>Reactor模式：要求主线程只负责监听文件描述符上是否有事件发生，有的话立即将该事件通知工作线程，将socket可读可写事件方去请求队列，交给工作线程来处理，使用epoll实现的工作流程如下：<ul>\n<li>主线程向epoll内核事件表中注册socket上的读就绪事件</li>\n<li>可读<ul>\n<li>主线程调用<code>epoll_wait</code>等待socket上有数据可读</li>\n<li>当socket上有数据可读时，<code>epoll_wait</code>通知主线程，主线程将socket可读事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li>\n</ul>\n</li>\n<li>可写<ul>\n<li>当主线程调用<code>epoll_wait</code>等待socket可写</li>\n<li>当socket可写时，<code>epoll_wait</code>通知主线程。主线程将socket可写事件放入请求队列</li>\n<li>睡眠在请求队列上的某个工作线程被唤醒，它往 socket上写入服务器处理客户请求的结果</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Proactor模式</li>\n</ul>\n</li>\n<li>IO多路复用技术<ul>\n<li><p>select模型：采用轮询和遍历的方式，在客户端操作服务器时，会创建三种文件描述符（写描述符、读描述符、异常描述符），select会阻塞这三种文件描述符，等有数据可读、可写、异常或超时都会返回。然后通过遍历文件描述符集合来找到就绪的文件描述符，进行IO操作。由于每次都需要遍历所有文件描述符，所以性能随着描述符的增多而减小</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int main()&#123;\n\t&#x2F;&#x2F;socket 建立、地址设置\n\tfd_set read_fs,write_set;\n\tstruct timeval timeout;\n\tint max &#x3D; 0;&#x2F;&#x2F;用于记录最大的fd，在轮询中时刻更新\n\t&#x2F;&#x2F;初始化比特位\n\tFD_ZERO（&amp;read_fs);\n\tFD_ZERO(&amp;write_fs);\n\t\n\tint nfds &#x3D; 0;&#x2F;&#x2F;记录就绪的事件，可以减少遍历的次数\n\twhile(1）&#123;\n\t&#x2F;&#x2F;阻塞获取，每次需要把fd从用户态拷贝到内核态\n\tnfds &#x3D; select(max+1, &amp;read_fd, &amp;write_fd, NULL, &amp;timeout);\n\t&#x2F;&#x2F;每次需要遍历所有fd，判断有无读写事件发生\n\tfor(int i &#x3D; 0; i &lt;&#x3D; max &amp;&amp; nfds; ++i)&#123;\n\t\tif(i &#x3D;&#x3D; listenfd)&#123;\n\t\t\t--nfds;\n\t\t\t&#x2F;&#x2F;处理accept事件\n\t\t\tFD_SET(i, &amp;read_fd);&#x2F;&#x2F;将客户端socket加入到集合中\n\t\t&#125;\n\t\tif(FD_ISSET(i, &amp;read_fd))&#123;\n\t\t\t--nfds;\n\t\t\t&#x2F;&#x2F;处理read事件\n\t\t&#125;\n\t\tif (FD_ISSET(i, &amp;write_fd)) &#123;\n\t\t\t --nfds;\n\t     &#x2F;&#x2F; 这里处理write事件\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>poll模型：poll模型的原理与select模型基本一致，也是轮询+遍历，区别在于poll采用链表的方式来存储文件描述符，同select一样，性能随着描述符的增多而减小</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;poll.h&gt;\n&#x2F;&#x2F; 数据结构\nstruct pollfd &#123;\n    int fd;                         &#x2F;&#x2F; 需要监视的文件描述符\n    short events;                   &#x2F;&#x2F; 需要内核监视的事件\n    short revents;                  &#x2F;&#x2F; 实际发生的事件\n&#125;;\n\n&#x2F;&#x2F; API\nint poll(struct pollfd fds[], nfds_t nfds, int timeout);</code></pre></li>\n<li><p>epoll模型：采用时间通知机制来触发相关的IO操作，没有文件描述符个数的限制，从用户态拷贝到内核态只需要一次。它主要通过系统底层的函数来注册、激活文件描述符，从而触发相关的IO操作，这样大大提高了提高性能（Redis、Nginx等，1G内存大概支持10万个句柄）</p>\n<ul>\n<li><p>将轮询改成了回调，提高了CPU执行效率、没有文件描述符数量限制、性能不会随文件描述符的增加而减小，内存拷贝（利用mmap文件映射内存加速与内核空间的消息传递，减少复制开销）</p>\n</li>\n<li><p>Socket创建</p>\n<ul>\n<li>服务端线程调用<code>accept</code>后阻塞，在客户端连接并完成<code>TCP</code>三次握手之后，<code>kernel</code>创建一个对应的<code>socket</code>作为服务端与内核端通信的内核接口，并将<code>socket</code>保存在当前进程打开的文件列表（Linux内核中一切皆是文件）中管理起来</li>\n<li>进程中管理的文件列表结构：内核通过<code>fd_array</code>来进行组织管理，数组下标为文件描述符，数据中存放的是文件数据结构<code>file</code>。进程中打开的文件列表<code>fd_array</code>定义在内核数据结构<code>struct files_struct</code>中，在<code>struct fdtable</code>结构中有一个指针<code>struct file **fd</code>指向<code>fd_array</code></li>\n<li>用于封装文件元信息的内核数据结构<code>struct file</code>中的<code>private_data</code>指针指向具体的<code>Socket</code>结构。<code>struct file</code>中的<code>file_operations</code>属性定义了文件的操作函数，不同的文件类型，对应的<code>file_operations</code>是不同的，针对<code>Socket</code>文件类型，这里的<code>file_operations</code>指向<code>socket_file_ops</code>。在用户空间对<code>Socket</code>发起的读写等系统调用，进入内核首先会调用的是<code>Socket</code>对应的<code>struct file</code>中指向的<code>socket_file_ops</code>，如对<code>Socket</code>发起<code>write</code>写操作，在内核中首先被调用的就是<code>socket_file_ops</code>中定义的<code>sock_write_iter</code></li>\n<li>Socket内核结构：最先创建的是监听socket，之后另外创建新的socket专门用于客户端之间的网络通信，并将监听Socket中的Socket操作函数集合（inet_stream_ops）ops赋值到新的Socket的ops属性中。接着kernel会为已连接的socket创建file结构体并初始化，并把Socket文件操作函数集合（socket_file_ops）赋值给file中的f_ops指针。然后将struct socket中的file指针指向这个新分配申请的file结构体。然后调用socket-&gt;ops-&gt;accept，即inet_accept函数，该函数会在icsk_accept_queue（已完成三次握手）中查找是否有已经建立好的连接，如果有的话，直接从icsk_accept_queue中获取已经创建好的struct sock。并将这个struct sock对象赋值给struct socket中的sock指针（sock对象中定义了接收队列，发送队列，等待队列，数据就绪回调函数指针，内核协议栈操作函数集合）<ul>\n<li><code>inet_stream_ops</code>函数集合中存储给用户提供的接口，socket与内核协议栈之间的接口定义在<code>struct sock</code>中的<code>sk_port</code>指针上</li>\n<li><code>struct sock</code>中的等待队列中存放的是系统IO调用发生阻塞的进程<code>fd</code>，以及相应的回调函数</li>\n<li>对<code>Socket</code>发起的系统IO调用，在内核中首先会调用<code>Socket</code>的文件结构<code>struct file</code>中的<code>file_operations</code>文件操作集合，然后调用<code>struct socket</code>中的<code>ops</code>指向的<code>inet_stream_ops</code>socket操作函数，最终调用到<code>struct sock</code>中<code>sk_prot</code>指针指向的<code>tcp_prot</code>内核协议栈操作函数接口集合</li>\n</ul>\n</li>\n<li>当struct file，struct socket，struct sock这些核心的内核对象创建好之后，最后就是把socket对象对应的struct file放到进程打开的文件列表fd_array中。随后系统调用accept返回socket的文件描述符fd给用户程序。</li>\n</ul>\n</li>\n<li><p>阻塞IO中用户进程阻塞以及唤醒原理</p>\n<ul>\n<li>阻塞<ul>\n<li>首先我们在用户进程中对<code>Socket</code>进行<code>read</code>系统调用时，用户进程会从<code>用户态</code>转为<code>内核态</code></li>\n<li>在进程的<code>struct task_struct</code>结构找到<code>fd_array</code>，并根据<code>Socket</code>的文件描述符<code>fd</code>找到对应的<code>struct file</code>，调用<code>struct file</code>中的文件操作函数结合<code>file_operations</code>，<code>read</code>系统调用对应的是<code>sock_read_iter</code></li>\n<li>在<code>sock_read_iter</code>函数中找到<code>struct file</code>指向的<code>struct socket</code>，并调用<code>socket-&gt;ops-&gt;recvmsg</code>，这里我们知道调用的是<code>inet_stream_ops</code>集合中定义的<code>inet_recvmsg</code></li>\n<li>在<code>inet_recvmsg</code>中会找到<code>struct sock</code>，并调用<code>sock-&gt;skprot-&gt;recvmsg</code>,这里调用的是<code>tcp_prot</code>集合中定义的<code>tcp_recvmsg</code>函数</li>\n</ul>\n</li>\n<li>唤醒：<ul>\n<li>当软中断将<code>sk_buffer</code>放到<code>Socket</code>的接收队列上时，接着就会调用<code>数据就绪函数回调指针sk_data_ready</code>，前边我们提到，这个函数指针在初始化的时候指向了<code>sock_def_readable</code>函数</li>\n<li>在<code>sock_def_readable</code>函数中会去获取<code>socket-&gt;sock-&gt;sk_wq</code>等待队列。在<code>wake_up_common</code>函数中从等待队列<code>sk_wq</code>中找出<code>一个</code>等待项<code>wait_queue_t</code>，回调注册在该等待项上的<code>func</code>回调函数（<code>wait_queue_t-&gt;func</code>）,创建等待项<code>wait_queue_t</code>是我们提到，这里注册的回调函数是<code>autoremove_wake_function</code>，即epoll的回调函数</li>\n<li>在<code>autoremove_wake_function</code>函数中，根据等待项<code>wait_queue_t</code>上的<code>private</code>关联的<code>阻塞进程fd</code>调用<code>try_to_wake_up</code>唤醒阻塞在该<code>Socket</code>上的进程</li>\n</ul>\n</li>\n<li>相关的系统调用<ul>\n<li>epoll_create：系统启动的时候，在Linux内核里面申请一个B+树结构的文件系统，然后返回epoll对象（一个文件描述符）用来后续使用</li>\n<li>epoll_ctl：每新建一个连接的时候，会同步更新epoll对象中的文件描述符，并且绑定一个callback函数<ul>\n<li>通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0表示成功</li>\n</ul>\n</li>\n<li>epoll_wait：轮询所有的callback集合（红黑树），并触发相应的IO操作<ul>\n<li>通过此调用收集在epoll监控中已发生的事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>epoll水平触发（LT）和边缘触发（ET）的区别</p>\n<ul>\n<li>Level Triggered（LT）水平触发：只要有数据就会触发，只要这个 fd 还有数据可读，每次 epoll_wait 都会返回它的事件，提醒用户程序去操作</li>\n<li>Edge Triggered（ET）边缘触发：只有数据到来，才触发，只会提示一次，直到下次数据流入</li>\n</ul>\n</li>\n<li><p>代码示例</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;sys&#x2F;epoll.h&gt;\n\n&#x2F;&#x2F; 每一个epoll对象都有一个独立的eventpoll结构体\n&#x2F;&#x2F; 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件\n&#x2F;&#x2F; epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可\nstruct eventpoll &#123;\n    &#x2F;*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*&#x2F;\n    struct rb_root  rbr;\n    &#x2F;*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*&#x2F;\n    struct list_head rdlist;\n&#125;;\n\n&#x2F;&#x2F;在epoll中，对于每一个事件，都会建立一个epitem结构体\nstruct epitem&#123;\n    struct rb_node  rbn;&#x2F;&#x2F;红黑树节点\n    struct list_head    rdllink;&#x2F;&#x2F;双向链表节点\n    struct epoll_filefd  ffd;  &#x2F;&#x2F;事件句柄信息\n    struct eventpoll *ep;    &#x2F;&#x2F;指向其所属的eventpoll对象\n    struct epoll_event event; &#x2F;&#x2F;期待发生的事件类型\n&#125;\n\n&#x2F;&#x2F; API\nint epoll_create(int size); &#x2F;&#x2F; 内核中间加一个 eventpoll 对象，把所有需要监听的 socket 都放到 ep 对象中\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); &#x2F;&#x2F; epoll_ctl 负责把 socket 增加、删除到内核红黑树\n&#x2F;&#x2F; 当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);&#x2F;&#x2F; epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Nginx的IO模型：支持多种并发模型，自动选择最高效的模型，也可以使用use指令在配置文件中显示指定某个并发模型，如下所示<ul>\n<li>select：编译时，所用平台没有更高效的并发模型时，select被自动编译</li>\n<li>poll：标准并发模型，同select一样，所用平台没有更高效的并发模型时，pol被自动编译</li>\n<li>epoll：IO多路复用，高效并发模型，Linux2.6+可以使用</li>\n<li>kequeue：IO多路复用，高效并发模型，可在 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0, and Mac OS X 平台中使用</li>\n<li>/dev/poll：高效并发模型，可在 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+, and Tru64 UNIX 5.1A+ 平台使用</li>\n<li>eventport：建议 使用/dev/poll替代</li>\n</ul>\n</li>\n<li>Redis的IO模型：Redis跑在单线程中，所有操作都是按照顺序线性执行的，为了防止IO阻塞整个Redis进程，所以使用IO多路复用技术。Redis的IO复用技术基于epoll实现，另外提供了select和kqueue的实现</li>\n</ol>\n<h2 id=\"2-网络协议\"><a href=\"#2-网络协议\" class=\"headerlink\" title=\"2.网络协议\"></a>2.网络协议</h2><h3 id=\"1-网络层\"><a href=\"#1-网络层\" class=\"headerlink\" title=\"1.网络层\"></a>1.网络层</h3><ol>\n<li><p>IP</p>\n<ul>\n<li><p>查看IP地址：ifconfig、ip addr</p>\n<ul>\n<li>scope：如果是global，则此张网卡是可以对外开放的，可以接受各个地方的包；对于lo来说事host，说明这张网卡仅仅可以供本机相互通信</li>\n<li>lo全称是loopback，又称环回接口，往往会被分配到127.0.0.1这个地址，用于本机通信，经过内核处理后直接返回，不会再任何网络中出现。</li>\n<li>MAC地址：在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为 MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。因为MAC没有定位功能，所以需要IP地址来寻路</li>\n<li>网络设备的状态标识（net_device flags）：例如&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; ，UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。MTU1500 是指最大传输单元 MTU 为 1500，这是以太网的默认值。</li>\n<li>排队规则（qdisc pfifo_fast）：qdisc 全称是 queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。</li>\n</ul>\n</li>\n<li><p>IP地址分类方式（ 无类型域间选路（CIDR）：10.100.122.2/24 ，网络号+主机号组成，通过与掩码进行与运算来求值）</p>\n<ul>\n<li>A类地址：1.0.0.0 到126.0.0.0（私有地址10.0.0.0～10.255.255.255）</li>\n<li>B类地址：128.0.0.0到191.255.255.255（私有地址172.16.0.0～172.31.255.255）</li>\n<li>C类地址：192.0.0.0到223.255.255.255（私有地址192.168.0.0～192.168.255.255）</li>\n<li>D类组播地址用于VXLAN协议，E类留待后用</li>\n<li>0.0.0.0对应于当前主机，255.255.255.255对应于当前子网的广播地址，127.0.0.1用于环回测试（loopback test）本主机</li>\n</ul>\n</li>\n<li><p>数据报格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730115123270.png\" alt=\"image-20230730115123270\"></p>\n<ul>\n<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>\n<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>\n<li><strong>区分服务</strong> : 是一个框架和一组标准，用于支持RFC2474,RFC2475,RFC3260上不同类型的服务（即不只是尽力而为的服务，而是更好的服务）</li>\n<li><strong>总长度</strong> : 包括首部长度和数据部分长度，以字节为单位（最大为MTU一般为1500字节）</li>\n<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>\n<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP（6）、UDP（17） 等。</li>\n<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>\n<li><strong>标识</strong> : 避免数据报分片的混淆，在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>\n<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>\n<li><strong>选项字段</strong>：很多选项已经被淘汰，只有一部分被留下来放在了IPv6的扩展头部中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路由协议：ODPF、RIP</p>\n<ul>\n<li><p>配置路由</p>\n<ul>\n<li><p>路由表：决定如何转发流量，通常称为路由表，主要包含以下三项信息，目的网络、出口设备、下一跳网关。可以通过route命令和ip route命令进行查询或者配置。例如，我们设置<code>ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0</code>，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。</p>\n</li>\n<li><p>策略路由配置示例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ip rule add from 192.168.1.0&#x2F;24 table 10\n$ ip rule add from 192.168.2.0&#x2F;24 table 20\n#表示从 192.168.1.10&#x2F;24 这个网段来的，使用 table 10 中的路由表，\n#而从 192.168.2.0&#x2F;24 网段来的，使用 table20 的路由表\n$ ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2\n#下一跳有两个地方，分别是 100.100.100.1 和 200.200.200.1，权重分别为 1 比 2。</code></pre></li>\n</ul>\n</li>\n<li><p>动态路由算法：如何在网络拓扑中找到两个节点的最短路径，主要有Bellman-Ford和Dijkstra算法</p>\n<ul>\n<li><p>距离矢量路由算法（distance vector routing）：基于Bellman-Ford算法，算法思想是每个路由器都保存一个路由表，从哪出和距离，每个路由器都保存全局信息，每过一段时间将已知信息告知邻居。存在两个问题</p>\n<ul>\n<li><p>好消息（新加入路由器）传的块，坏消息（下线的路由器）传的慢</p>\n</li>\n<li><p>每次发送的时候，要发送整个全局路由表</p>\n</li>\n</ul>\n</li>\n<li><p>链路状态路由算法（link state routing），基于Dijkstra算法，算法思想是当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径</p>\n</li>\n</ul>\n</li>\n<li><p>动态路由协议</p>\n<ul>\n<li><p>基于链路状态路由算法的OSPF（Open Shortest Path First，开放式最短路径优先）：主要用于数据中心内部，又称内部网关协议（Interior Gateway Protocol IGP）。内部网关协议的重点就是找到最短路径，可以在多个路径中进行负载均衡，常被称为等价路由。常配合接入层的负载均衡LVS</p>\n</li>\n<li><p>基于距离矢量路由算法的BGP（Border Gateway Protocol，外网路由协议）：因为每个数据中心都有自己的Policy，所以有些路可以走，有些不可以走。这一个个数据中心称为自治系统AS（Autonomous System），通过边界路由器与外面世界建立联系。BGP有两类：</p>\n<ul>\n<li><p>eBGP：边界路由器之间使用eBGP广播路由</p>\n</li>\n<li><p>iBGP：使得内部路由器能够找到到达外网目的地的最好的边界路由器</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据链路层：ARP（将IP解析为MAC）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果说互联网中每一个资源都有IP地址唯一标识，那么一些网络设备都有MAC地址唯一标识，MAC类似于身份证号，IP地址类似于住址</p></blockquote>\n<ul>\n<li><p>MAC地址：6字节，地址空间约280万亿，由IEEE统一管理与分配，FF-FF-FF-FF-FF-FF为广播地址</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120415210.png\" alt=\"image-20230730120415210\"></p>\n<ul>\n<li>类型字段用于确定协议类型：<ol>\n<li>IPv4为0x0800</li>\n<li>IPv6为0x86DD</li>\n</ol>\n</li>\n<li>FCS为帧校验序列：为待检查的消息追加n为0，除以一个n+1位的生成多项式，将余数取反放到FCS中</li>\n<li>链路层MTU为1500字节</li>\n</ul>\n</li>\n<li><p>ARP协议原理：ARP表，广播问讯，单播响应</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>全称为地址解析协议，它解决的是网络层地址和链路层地址之间的转换问题，因为一个IP数据报在物理上传输的过程中，总需要知道下一跳（物理上的下一目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题</p></blockquote>\n<ul>\n<li><p>ARP表：在一个局域网内，每个网络设备都自己维护了一个ARP表，ARP表记录了某些网络设备的IP地址和MAC地址的映射关系（<code>&lt;IP, MAC, TTL&gt;</code>），其中TTL为该映射关系的生存周期（通常为20min），超时即丢弃此条目</p>\n</li>\n<li><p>同一个局域网内的MAC寻址（A「137.196.7.23」，B「137.196.7.14」）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120439734.png\" alt=\"image-20230730120439734\"></p>\n<ul>\n<li>A检索自己的ARP表，发现ARP表中无B的IP地址对应的条目，无法知道B的MAC地址</li>\n<li>A构造一个ARP查询分组，将其广播到所在的局域网中<ul>\n<li>ARP分组主要有两种，ARP查询分组和ARP响应分组，他们具有相同的格式，均包含了发送和接收的IP地址，发送和接收的MAC地址<ul>\n<li>查询分组发送的IP地址为A的IP地址，接收的IP地址为B的IP地址；发送的MAC地址为A的MAC地址，接收的MAC地址为FF-FF-FF-FF-FF-FF</li>\n<li>响应分组IP地址与查询分组相反，MAC地址也相反，但是目的MAC地址为查询分组的发送者的MAC，源MAC地址为B的MAC地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主机A构造的查询分组将在局域网内广播，每一个设备都会收到该分组，设备通过核查IP地址是否与本地相同来确定是否响应</li>\n<li>主机B收到了查询分组，构造一个ARP响应分组，该分组只有一个目的地（主机A），主机B提取IP和MAC信息，插入到ARP表中</li>\n<li>主机A收到主机B的响应分组，提取出该分组的IP地址和MAC地址，插入到ARP表中</li>\n</ul>\n</li>\n<li><p>从一个局域网到另一个局域网中的网络设备的寻址</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>路由器的每一个接口都各自维护一个ARP表</p></blockquote>\n<ul>\n<li>主机A查询ARP表，期望寻找到目标路由器（根据B的IP分析出B的子网，转发报文到该子网）的本子网接口的MAC地址</li>\n<li>主机A未能找到目标路由器的本子网接口的MAC地址，采用ARP协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同</li>\n<li>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口</li>\n<li>目标接口接收到了链路层帧，解析，根据目的IP地址，查询转发表，将该IP数据报转发到B所在的子网相连的接口上</li>\n<li>路由接口查询ARP表，寻找主机B的MAC地址，如果没找到，则采用ARP查询分组，广播问询，单播响应，获取到主机B的MAC地址，路由器接口对IP数据报重新封装成链路层帧，目标MAC地址为主机B的MAC地址，单播发送，直到目的地</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>应用层：DNS（由域名查IP，负载均衡技术，DNS解析过程如下）</p>\n<ul>\n<li>首先查缓存<ul>\n<li>浏览器缓存检查：浏览器首先搜索自身的DNS缓存（大概1000条左右），看自身缓存是否命中，或已过期</li>\n<li>操作系统缓存检查 + hosts 解析：查询操作系统的DNS缓存是否命中，可以通过<code>/etc/hosts</code>文件来设置，将任何域名解析到任何能够访问的IP地址</li>\n</ul>\n</li>\n<li>然后进行dns解析<ul>\n<li>第一步：发送域名到本地DNS服务器，查询其缓存，如果有则返回，如果没有则本地DNS服务器发送请求给根DNS服务器进行查询</li>\n<li>第二步：根域名服务器没有记录对应关系时，返回顶级域名服务器的IP；顶级域名服务器向根DNS服务器返回二级域名服务器的IP；二级域名服务器将自己缓存表中的域名和IP地址的对应关系返回给本地DNS服务器</li>\n<li>第三步：本地 DNS 服务器将获取到与域名对应的 IP 地址返回给客户端，并且将域名和 IP 地址的对应关系保存在缓存中，以备下次别的用户查询时使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>应用层：DHCP（已有MAC，获取IP）</p>\n<ol>\n<li><p>格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120144800.png\" alt=\"image-20230730120144800\"></p>\n</li>\n<li><p>原理</p>\n<ol>\n<li><p>手动配置IP相当于自己买房装修，DHCP协议相当于租房</p>\n</li>\n<li><p>新到一个城市要先找中介（DHCP服务器）租个房（IP）-Discover</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120207306.png\" alt=\"image-20230730120207306\"></p>\n</li>\n<li><p>中介（DHCP）会带你看房，可能会有多个中介带你看多个房-Offer</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120221754.png\" alt=\"image-20230730120221754\"></p>\n</li>\n<li><p>你看上其中一个房，愿意租下来-Request</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120240826.png\" alt=\"image-20230730120240826\"></p>\n</li>\n<li><p>中介说没问题，咱们签合同，租约达成-Ack</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120255346.png\" alt=\"image-20230730120255346\"></p>\n</li>\n<li><p>租约达成要广播，防止中介之间跳单</p>\n</li>\n<li><p>租约快到之前，记得续租</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>NAT：内网复用IP，NAT网关将私有IP改为公网IP</p>\n<ul>\n<li>允许多个范围内中的同一地址可以复用。专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP，内部原理就是重写通过路由器的数据包的识别信息</li>\n<li>一共有三个IPv4地址范围作为私有地址范围使用（常作为DHCP地址池）：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16</li>\n<li>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</li>\n</ul>\n</li>\n<li><p>ICMP（ping的底层实现）</p>\n<ul>\n<li><p>帧格式</p>\n<ul>\n<li><p>查询报文类型：一种主动请求并且获得主动应答的ICMP协议，在网络抓包时，称为ICMP ECHO REQUEST和CMP ECHO REPLY，比原生ICMP多个标识符和序号字段</p>\n</li>\n<li><p>差错报文类型：主要有终点不可达（3）、源抑制（4）、超时（11）、重定向（5）等</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120007920.png\" alt=\"image-20230730120007920\"></p>\n</li>\n</ul>\n</li>\n<li><p>ping原理</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730115952768.png\" alt=\"image-20230730115952768\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-传输层\"><a href=\"#2-传输层\" class=\"headerlink\" title=\"2.传输层\"></a>2.传输层</h3><ol>\n<li><p>TCP</p>\n<ul>\n<li><p>头格式</p>\n<ul>\n<li>序号：给包编号，用来解决乱序问题（将应用层的数据分块「TCP segment」，最大为MSS、MTU除去IP头和TCP头）</li>\n<li>确认序号：发出去的包应该有确认，来确定是否已经收到相应包</li>\n<li>状态位：<ul>\n<li>SYN：发起一个连接</li>\n<li>ACK：回复</li>\n<li>RST：重新连接</li>\n<li>FIN：结束连接</li>\n</ul>\n</li>\n<li>窗口大小：TCP要做流浪控制，通信双方动态约定一个窗口，保证双方都在高效处理数据</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121059129.png\" alt=\"image-20230730121059129\"></p>\n</li>\n<li><p>三次握手：<strong>保证双方都有发送和接收的能力</strong></p>\n<ul>\n<li>握手次数：一次的话，请求方不知道响应方是否已经成功接受请求；两次的话，接收方不知道发送方是否成功接受相应；三次的话，刚好双方都知晓；四次以及更多的话，已经没有特殊的意义了，所以再多的数据包都不能保证真的可靠，后续通过数据包和探活包来解决相关问题</li>\n<li>TCP包的序号问题：为了防止连接之间数据包序号的相互影响，所以序号是随时间变化的，通过数据包的序号，双方都可以知道应收的包和应发的包都是哪个</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121118741.png\" alt=\"image-20230730121118741\"></p>\n</li>\n<li><p>四次挥手</p>\n<ul>\n<li>等待2MSL：MSL是报文最大生存时间，虽然序号是重新生成的，但是为了防止左端提前结束后收到右端之前连接的数据包，所以需要等待2MSL时间。时间截止后，对于右端旧连接发送的数据包，左端将会直接发送RST，这样右端就知道左端已退出</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121140305.png\" alt=\"image-20230730121140305\"></p>\n</li>\n<li><p>滑动窗口</p>\n<ul>\n<li><p>发送端</p>\n<ul>\n<li>第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的</li>\n<li>第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉</li>\n<li>第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的</li>\n<li>第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。（区分三和四是为了流量控制）</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121154410.png\" alt=\"image-20230730121154410\"></p>\n</li>\n<li><p>接收端</p>\n<ul>\n<li>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的</li>\n<li>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量</li>\n<li>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121205446.png\" alt=\"image-20230730121205446\"></p>\n</li>\n<li><p>问题</p>\n<ul>\n<li>流量控制：在对包的确认中，同时会携带一个窗口的大小。当发送方窗口已经全发送过了，但是接受端还没接收，此时每接受到一个应答，窗口大小就减一，直到为0</li>\n<li>丢包问题<ul>\n<li>超时重传：对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。超时时间依靠自适应重传算法（Adaptive Retransmission Algorithm）</li>\n<li>超时间隔加倍：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</li>\n<li>快速重传机制：当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段</li>\n<li>SACK：这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方</li>\n</ul>\n</li>\n<li>流量控制使用什么数据结构<ul>\n<li>TCP传输协议中，流量控制是使用滑动窗口（Sliding Window）来实现的。滑动窗口是一种基于数据流的、动态调整的、可变大小的窗口，它通过协商双方的接收窗口和发送窗口大小，控制数据的传输速率。</li>\n<li>在TCP协议中，每个数据包都有一个序号，接收方通过序号来确认是否收到了正确的数据包。发送方将数据分成若干个数据段，每个数据段的大小不超过发送窗口的大小，然后将这些数据段发送给接收方。接收方会确认已经收到的数据，同时告诉发送方自己的接收窗口大小。发送方根据接收方的窗口大小，动态调整自己的发送窗口大小，从而控制数据的传输速率。</li>\n<li>滑动窗口的大小是可以动态调整的，它可以根据网络状况和双方的能力来自适应地调整，从而实现流量控制的功能。如果接收方的接收窗口变小，发送方会相应地减小自己的发送窗口，以避免过多的数据堆积在网络中导致拥塞。如果接收方的接收窗口变大，发送方会相应地增加自己的发送窗口，以提高数据传输速率。</li>\n</ul>\n</li>\n<li>TCP如何保证可靠传输<ul>\n<li>tcp的序列号可以避免乱序的问题，保证收到的tcp报文都是有序的。</li>\n<li>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</li>\n<li>TCP 针对数据包丢失的情况，会用重传机制解决。</li>\n<li>用快重传解决个别报文段的丢失问题。</li>\n<li>使用滑动窗口实现流量控制。使用接收方确认报文中的窗口字段来控制发送方发送窗口大小，进而控制发送方的发送速率，使得接收方来得及接收。</li>\n<li>使用基于窗口的拥塞控制，来尽量避免避免网络拥塞。</li>\n</ul>\n</li>\n<li>LInux的TCP连接数量最大为多少：Linux的TCP连接数量最大不能超过65535是一个常见的误解。实际上，一个TCP连接由一个五元组（协议、本地IP、本地端口、远程IP、远程端口）唯一确定12。对于服务器来说，本地端口一般是固定的，比如HTTP (80），但是远程IP和远程端口没有限制。因此，理论上服务器可以支持的TCP连接数是2的32次方（IP数）x2的16次方（端口数）x2的16次方（服多器端口数）个2</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拥塞窗口</p>\n<ul>\n<li><p>慢启动拥塞避免</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121220688.png\" alt=\"image-20230730121220688\"></p>\n</li>\n<li><p>快重传快恢复</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121235996.png\" alt=\"image-20230730121235996\"></p>\n</li>\n</ul>\n</li>\n<li><p>TCP粘包分析与处理</p>\n<ul>\n<li><p>概念</p>\n<ul>\n<li>TCP粘包现象：发送方发送的多个数据包，到接收方后粘连在一起，导致数据包不能完整的体现发送的数据（UDP有消息边界，所以不会出现粘包问题）</li>\n<li>如果一次发送的消息太小，没达到缓冲区大小，TCP会讲多个请求合并为同一个请求来发送，这就形成了粘包问题；如果一次发送的消息过大，超过了缓冲区的大小，TCP就会将其拆分为多次发送，这就是拆包问题</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/%E7%B2%98%E5%8C%85.png\" alt=\"粘包\"></p>\n</li>\n<li><p>原因：可能是发送方的原因也可能是接收方的原因</p>\n<ul>\n<li>发送方：由于TCP需要尽可能高效和可靠，所以TCP默认采用Nagle算法，以合并相连的小数据包，再一次性发送，以达到提升网络传输效率的目的。但是接收方并不晓得发送方合并数据包，而且数据包的合并在TCP协议中是没有分界线的，所以这就导致接收方不能还原其本来的数据包</li>\n<li>接收方：TCP是基于“流”的，网络传输数据的速度可能会快过接收方处理数据的速度，这时就会导致接收方在读取缓冲区时，缓冲区存在多个数据包。在TCP协议中接收方是一次读取缓冲区中的所有内容，所以不能反映原本的数据信息</li>\n<li>TCP协议是基于字节流的传输层协议，没有固定的分包边界。发送方将数据分成多个小的数据包进行传输，接收方再将这些数据包组合成完整的数据。在这个过程中，可能会出现拆包和沾包现象</li>\n<li>网络传输中的延迟和拥塞会影响数据包发送的速度和到达接收方的顺序。这可能导致数据包的拆分和组合不规律，从而出现拆包和沾包现象</li>\n<li>接收方的缓冲区大小限制。当接收方的缓冲区不足以容纳一个完整的数据包时，可能会将数据包拆分成多个部分，导致拆包现象</li>\n</ul>\n</li>\n<li><p>解决办法</p>\n<ul>\n<li>其他办法<ul>\n<li>禁用Negel算法：只能解决发送方的问题，但是TCP的传输效率变低了</li>\n<li>PUSH标志：在发送时可以设置这个标志位，通知接收方将收到的数据提交给接收进程，并不能完全解决，只能降低发生粘包的可能性</li>\n<li>发送端将每个包都封装成固定的长度、发送端在每个包的末尾使用固定的分隔符、将消息分为头部和消息体其中头部包含消息长度</li>\n<li>在应用层实现数据包的边界识别，例如通过添加包头，包头中包含数据包长度等信息，使得接收方能够准确地将数据包进行拼接</li>\n<li>使用固定长度的数据包或者特殊的分隔符，以便于接收方识别数据包的边界</li>\n<li>使用更高级的传输层协议，如WebSocket，它在TCP基础上增加了数据帧的概念，可以更好地解决拆包和沾包问题</li>\n</ul>\n</li>\n<li>Netty对粘包和拆包的处理，提供了一些解码器（Decoder）来解决粘包和吃啊包的问题<ul>\n<li>LineBasedFrameDecoder：以行为单位进行数据包的解码；</li>\n<li>DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码；</li>\n<li>FixedLengthFrameDecoder：以固定长度进行数据包的解码；</li>\n<li>LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议（最常用）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UDP</p>\n<ul>\n<li><p>头格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120927146.png\" alt=\"image-20230730120927146\"></p>\n</li>\n<li><p>使用场景</p>\n<ul>\n<li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</li>\n<li>不需要一对一沟通，建立连接，而是可以广播的应用</li>\n<li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</li>\n<li>基于UDP的协议：DHCP、HTTP3、云网络中的VXLAN、操作系统镜像的下载使用的 TFTP</li>\n<li>一些新兴改进<ul>\n<li>QUIC是Google提出的一种基于UDP改进的通信协议，在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制。主要用在网页和APP的访问</li>\n<li>直播协议多使用RTMP，丢包时会影响直播效果，所以很多直播应用都基于UDP实现了视频传输协议</li>\n<li>实时游戏领域，在异步IO机制引入之前，常采用自定义UDP来解决对海量客户端连接的策略</li>\n<li>物联网领域终端资源少，维护TCP协议代价太大，而且物联网对实时性要求也很高。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li>\n<li>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>QUIC</p>\n</li>\n</ol>\n<h3 id=\"3-应用层\"><a href=\"#3-应用层\" class=\"headerlink\" title=\"3.应用层\"></a>3.应用层</h3><ol>\n<li><p>HTTP：<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol（超文本传输协议）</p>\n<ul>\n<li>HTTP/1.1：无状态（cookie）、明文传输（SSL/TLS）、<ul>\n<li>method<ul>\n<li>GET：从服务器获取指定的资源，通过URL以ASCII格式传递参数，是安全且幂等的<ul>\n<li>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。</li>\n</ul>\n</li>\n<li>POST：根据请求负荷（报文body中）对指定的资源做出对应的处理，不是幂等的<ul>\n<li>URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</li>\n</ul>\n</li>\n<li></li>\n</ul>\n</li>\n<li>status codes<ul>\n<li><strong>1xx</strong>：表示目前是协议处理的中间状态，还需要后续操作</li>\n<li><strong>2xx</strong>：表示成功状态，报文已收到并正确处理<ul>\n<li>204：没有响应体、206：响应体不全</li>\n</ul>\n</li>\n<li><strong>3xx</strong>：重定向状态，资源位置发生变动，需要重新请求<ul>\n<li>301：永久重定向、302：暂时重定向</li>\n<li>304：内容未更改，重定向到客户端的缓存资源</li>\n</ul>\n</li>\n<li><strong>4xx</strong>：客户端错误，请求报文有误服务器无法处理<ul>\n<li>403：禁止访问资源、404资源未找到</li>\n</ul>\n</li>\n<li><strong>5xx</strong>：服务端错误，服务器在处理请求时内部发生了错误<ul>\n<li>501 Not Implemented：表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思</li>\n<li>502 Bad Gateway：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li>\n<li>503 Service Unavailable：表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>header fields<ul>\n<li>Host：客户端发送请求时，用来指定服务器的域名，可以将请求发往同一台服务器上的不同网站</li>\n<li>Content-Length ：表明本次回应的数据长度，HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</li>\n<li>Connection：客户端要求服务器使用<strong>HTTP 长连接</strong>机制（Keep-Alive），任意一端没有明确提出断开连接，则保持 TCP 连接状态</li>\n<li>Content-Type：用于服务器回应时，告诉客户端，本次数据是什么格式<code>Content-Type: text/html; Charset=utf-8</code></li>\n<li>Accept：客户端请求的时候，声明自己可以接受哪些数据格式<code>Accept: */*</code></li>\n<li>Content-Encoding：表示服务器返回的数据使用了什么压缩格式；Accept-Encodin：说明客户端可以接受哪些压缩方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTP缓存：通过将不变的请求-响应数据缓存在本地提升性能<ul>\n<li>强制缓存：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边<ul>\n<li>实现：<code>Cache-Control</code>（一个相对时间）、<code>Expires</code>（一个绝对时间），建议使用<code>Cache-Control</code><ul>\n<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>\n<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>\n<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>协商缓存：与服务端协商之后，通过协商结果来判断是否使用本地缓存<ul>\n<li>实现：使用请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段或 <code>Last-Modified</code>两种方式来实现，ETag用来唯一标识资源，Last-Modified用来记录修改时间，由于时间粒度大并且会被恶意修改，所以推荐使用ETag</li>\n<li>服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：<ul>\n<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>\n<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>性能优化<ul>\n<li>尽量避免发送 HTTP 请求：缓存</li>\n<li>在需要发送 HTTP 请求时，考虑如何减少请求次数<ul>\n<li>使用代理服务器减少重定向请求次数</li>\n<li>合并请求：使用<code>CSS Image Sprites</code>技术；使用 <code>webpack</code> 等打包工具将 js、css 等资源合并打包</li>\n<li>延迟发送请求：请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果</li>\n</ul>\n</li>\n<li>减少服务器的 HTTP 响应的数据大小：无损压缩（gzip）、有损压缩（<strong>WebP</strong>）</li>\n</ul>\n</li>\n<li>session&amp;cookie<ul>\n<li>cookie：客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地，下次向同一服务器再发起请求时被携带发送，<strong>解决HTTP无状态的问题，可以保持用户登录状态</strong></li>\n<li>session：Session是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。客户端关闭会话，或者Session超时失效时会话结束</li>\n<li>目前大多数的应用都是用Cookie实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中返回给客户端，在Cookie中记录SessionID，后续请求时传递SessionID给服务，以便后续每次请求时都可分辨你是谁</li>\n<li>区别<ul>\n<li>作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。</li>\n<li>存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。</li>\n<li>有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。</li>\n<li>隐私策略不同，Cookie存储在客户端，信息容易被窃取；Session存储在服务端，相对安全一些。</li>\n<li>存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。</li>\n</ul>\n</li>\n<li>分布式系统中的Session：会有多个服务器处理同一业务，Session存在不同服务器上会登录失败，解决方法如下<ul>\n<li>方案一：请求精确定位。也就是通过负载均衡器让来自同一IP的用户请求始终分配到同一服务上。比如，Nginx的ip_hash策略，就可以做到</li>\n<li>方案二：Session复制共享。该方案的目标就是确保所有的服务器的Session是一致的。像Tomcat等多数主流web服务器都采用了Session复制实现Session的共享</li>\n<li>方案三：基于共享缓存。该方案是通过将Session放在一个公共地方，各个服务器使用时去取即可。比如，存放在<code>Redis</code>、Memcached等缓存中间件中</li>\n</ul>\n</li>\n<li>同源策略与跨域请求<ul>\n<li>同源：协议相同、域名相同、端口相同，主要是为了保证用户信息的安全，防止恶意的网站窃取数据<ul>\n<li>恶意网站会使用用户的Cookie来伪装成用户，窃取用户信息</li>\n</ul>\n</li>\n<li>跨域请求：请求一个与自身资源不同源的资源，浏览器设置了同源策略，但是有的时候网页中需要有跨域访问，所以W3C提供了一个解决方法（跨域资源共享CORS），浏览器将CORS请求分为两部分<ul>\n<li>简单请求：浏览器直接处理</li>\n<li>预检请求：不符合简单请求条件的请求，会在正式通信之前触发一个 **<code>OPTIONS</code>**请求进行预检。服务端收到预检请求后，会根据上述附带的信息判断是否允许跨域，浏览器会根据返回的 CORS 信息判断是否继续发送真实的请求（确认后才发实际的HTTP请求）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SSL/TLS</p>\n<ul>\n<li><p>在HTTP和TCP之间，HTTPS在进行三次握手之后还要进行SSL/TLS 的握手过程，才能进行加密报文传输。解决HTTP协议明文传输导致的：窃听信息（<strong>混合加密</strong>）、篡改响应（<strong>摘要算法</strong>）、冒充网站（<strong>数字证书</strong>）</p>\n<ul>\n<li><p>混合加密：<strong>对称加密</strong>和<strong>非对称加密</strong>结合，在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</p>\n<ul>\n<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>\n<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>\n</ul>\n</li>\n<li><p>摘要算法：用摘要算法（哈希函数）来计算出内容的哈希值</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801164827410.png\" alt=\"image-20230801164827410\"></p>\n</li>\n<li><p>数字证书：将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的</p>\n</li>\n</ul>\n</li>\n<li><p>SSL/TLS 协议基本流程</p>\n<ul>\n<li>客户端向服务器索要并验证服务器的公钥，双方协商生产「会话秘钥」<ul>\n<li>即 SSL/TLS 的建立过程，也就是 TLS 握手阶段。TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法和 ECDHE 算法。</li>\n<li>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：<ul>\n<li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li>\n<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双方采用「会话秘钥」进行加密通信</li>\n<li>SSL与TLS：SSL 是洋文 “<em>Secure Sockets Layer</em>” 的缩写，中文叫做「安全套接层」。它是在上世纪 90 年代中期，由网景公司设计的。到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是 “<em>Transport Layer Security</em>” 的缩写），中文叫做 「传输层安全协议」。很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</li>\n</ul>\n</li>\n<li><p>网络攻击常见手段</p>\n<ul>\n<li><p>IP欺骗：伪造某台主机的IP地址的技术，通过IP地址的伪装使得某台主机能够伪装另一台主机，而这台主机往往具有某种特权或者被另外的主机所信任</p>\n<ul>\n<li>示例：攻击者构造TCP数据，伪装自己的IP地址，并向服务器发送一个带有RSI位的TCP数据段，服务器接收到这样的数据后，认为该IP地址发送的连接有误，会清空缓冲区中建立好的连接。这时合法用户再发送合法数据，服务器就已经没有这样的连接了，使得服务器无法对合法用户服务</li>\n<li>缓解1：入口过滤是一种数据包过滤形式，通常在网络边缘设备上实施，用于检查传入的IP数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包</li>\n<li>缓解2：一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击</li>\n</ul>\n</li>\n<li><p>洪泛攻击：DDoS、SYN Flood、UDP Flood、HTTP Flood、DNS Flood</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>DDoS（Distributed Denial of Service，分布式拒绝服务）</p></blockquote>\n<ul>\n<li><p>DDOS</p>\n<ul>\n<li>DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用<strong>欺骗和伪装</strong>的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务</li>\n<li>如何应对<ul>\n<li><strong>高防服务器：</strong>能独立硬防御50Gbps以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点，唯一缺点就是贵</li>\n<li><strong>黑名单：</strong>设置黑名单，但是会封锁正常流量，影响正常业务</li>\n<li><strong>DDoS清洗：</strong>会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong>攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量</li>\n<li><strong>CDN加速：</strong>将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SYN Flood</p>\n<ul>\n<li>互联网上最原始最经典的DDoS攻击，旨在耗尽可用服务器资源，致使服务器无法传输合法流量</li>\n<li>利用三次握手机制，通过工具或僵尸网络主机向服务器发送海量的不同源IP/不同源端口的TCP SYN报文，服务器响应了这些报文之后就会返回SYN-ACK报文，并生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务<ul>\n<li>常见形式<ul>\n<li>直接攻击：不伪造IP地址</li>\n<li>欺骗攻击：恶意用户伪造其发送的各个SYN数据包的IP地址</li>\n<li>分布式DDoS：通过僵尸网络，令每台分布式设备伪造其发送数据包的IP地址</li>\n</ul>\n</li>\n<li>服务器在返回SYN-ACK报文后，会有一个计时器Timer，如果超过时间还没有收到A的ACK消息，则重新发送一次SYN-ACK消息，直到重试超过一定次数才会放弃</li>\n<li>在短时面临海量连接时，SYN Flood攻击就形成了</li>\n</ul>\n</li>\n<li>解决办法主要是判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务<ul>\n<li>扩展积压工作队列：增加操作系统允许的最大半开连接数目，但需额外预留内存资源以处理各类新请求</li>\n<li>回收最先创建的 TCP 半开连接：在填充积压工作后覆盖最先创建的半开连接，这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效</li>\n<li>SYN Cookie：此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UDP Flood</p>\n<ul>\n<li><p><strong>UDP Flood</strong>也是一种拒绝服务攻击，将大量的用户数据报协议（<strong>UDP</strong>）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因<strong>UDP</strong>泛滥而耗尽，从而导致对合法流量的拒绝服务</p>\n</li>\n<li><p>攻击原理：当服务器在特定端口接收到 </p>\n<p>UDP</p>\n<p> 数据包时，会经过两个步骤：</p>\n<ul>\n<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序</li>\n<li>如果没有程序在该端口接收数据包，则服务器使用 <strong>ICMP</strong>（ping）数据包进行响应，以通知发送方目的地不可达</li>\n</ul>\n</li>\n<li><p>如何缓解：大多数操作系统部分限制了<strong>ICMP</strong>报文的响应速率，以中断需要 ICMP 响应的<strong>DDoS</strong>攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果<strong>UDP Flood</strong>的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈</p>\n</li>\n</ul>\n</li>\n<li><p>HTTP Flood</p>\n<ul>\n<li>HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求</li>\n<li>HTTP Flood攻击有两种：<ul>\n<li><strong>HTTP GET 攻击</strong> ：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务</li>\n<li><strong>HTTP POST 攻击</strong> ： 一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止</li>\n</ul>\n</li>\n<li>防护办法<ul>\n<li>对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击</li>\n<li>Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DNS Flood</p>\n<ul>\n<li>攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。通过中断 DNS 解析，DNS Flood攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量</li>\n<li>如何防护：DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他攻击</p>\n<ul>\n<li>TCP重置攻击<ul>\n<li>在 TCP重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断<ul>\n<li>一般客户端发现到达的报文对于相关连接不正确时，就会发送一个重置报文段，从而导致TCP连接的快速拆卸</li>\n</ul>\n</li>\n<li>一般只对长连接有效果，对于短连接而言，你还没攻击呢，人家已经完成了信息交换</li>\n</ul>\n</li>\n<li>中间人攻击</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>HTTP协议的演变</p>\n<ul>\n<li>HTTP/1.1 相比 HTTP/1.0 性能上的改进：<ul>\n<li>长连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。减少了 TCP 连接的重复建立和断开所造成的额外开销，<strong>减轻了服务器端的负载</strong></li>\n<li>管道网络传输：即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间</strong>，但不是默认开启的</li>\n<li>对头堵塞问题：如果服务端在处理某个请求时耗时比较长，那么后续的请求的处理都会被阻塞住<ul>\n<li><strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>，可以同时发多个请求但是需要响应等待服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>那 HTTP/2 相比 HTTP/1.1 性能上的改进：<ul>\n<li>安全传输：基于HTTPS</li>\n<li>头部压缩（HPACK算法）：通过在客户端和服务器同时维护一张头信息表，只传输索引号而不是重复传相同的头部</li>\n<li>二进制格式：不再是纯文本形式的报文，头信息和数据体都是二进制，并且统称为帧（frame），<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong></li>\n<li>并发传输：1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）<ul>\n<li>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的</li>\n</ul>\n</li>\n<li>服务器主动推送资源：服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li>\n</ul>\n</li>\n<li>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP<ul>\n<li>使用基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输</li>\n<li>QUIC协议<ul>\n<li>无队头阻塞：当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</li>\n<li>更快的连接建立：三次握手（ QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商）</li>\n<li>连接迁移：TCP通过四元组标识，Wi-Fi切换到4G时需要重新建立连接，而QUIC通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Web页面请求过程</p>\n<ol>\n<li>概览 ：HTTP解析URL（服务器名+路径名）并生成HTTP请求消息（Get/Post报文），通过DNS查询服务器名对应的IP地址（DNS请求-本地-根-顶级-权威），通过Socket委托Linux协议栈进行层层处理（TCP-IP-网卡驱动-物理网卡）；TCP协议填充头信息（端口、序号、确认号、状态位）进行三次握手、流量控制、拥塞控制，IP协议通过ip地址来确定路由方向，通过ARP协议根据ip地址得到MAC地址再通过MAC地址在以太网中传输数据；通过网卡驱动程序增加数据（报头、帧分节符、校验符）并将二进制数据转换成电信号，通过二层设备交换机通过MAC地址决定走哪个端口，通过三层设备路由器路由表来查询走哪个端口<ul>\n<li>在发送数据包时，如果目标主机不是本地局域网，填入的 MAC 地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现目标 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机</li>\n</ul>\n</li>\n<li>DHCP 配置主机信息<ul>\n<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>\n<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>\n<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>\n<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li>\n<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>\n<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>\n<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>\n</ul>\n</li>\n<li>ARP 解析 MAC 地址<ul>\n<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>\n<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>\n<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>\n<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>\n<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>\n<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>\n<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>\n</ul>\n</li>\n<li>DNS 解析域名<ul>\n<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>\n<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>\n<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>\n<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>\n<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>\n</ul>\n</li>\n<li>HTTP 请求页面<ul>\n<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>\n<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>\n<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>\n<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>\n<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>\n<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>网络分层</p>\n<ul>\n<li><p>TCP/IP四层协议：网络接口层、网络层、传输层、应用层</p>\n<ul>\n<li>网络接口层：MAC地址<ul>\n<li>物理层<ul>\n<li>物理信道：单工通信（无线电广播）、半双工通信（对讲机）、全双工通信（手机打电话）</li>\n<li>物理设备：交换机（连接多段网线）、调制解调器（将数字信号转换成电话线的模拟信号或光信号）</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输<ul>\n<li>广播信道：CSMA/CD协议，如同轴电缆、集线器等组成的网络</li>\n<li>点对点信道：PPP协议，如2个路由器之间的信道</li>\n</ul>\n</li>\n<li>数据链路层的3个基本问题<ul>\n<li>封装成帧：帧的数据部分就是网络层传递下来的数据包，帧的最大长度为MTU（1500字节）</li>\n<li>透明传输：完整的数据使用SOH作为开始，使用EOT作为结束，与标志相同的数据会被转义传输，到达后被还原</li>\n<li>差错检验：帧尾部有一个FCS字段，是根据数据部分和数据链路层首部计算得出的，可以用来检验接收到的消息对错</li>\n</ul>\n</li>\n<li>CSMA/CD：载波侦听多路访问/冲突检测，用来支持单用通信和半双工通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络层：IP、ARP（IP解析为MAC）、DHCP（获取IP）、ICMP（ping的底层实现）、NAT（网关内复用IP，将私有IP转换为公网IP）、OSPF和BGP（动态路由协议，确定走哪个路由器）</li>\n<li>传输层：TCP（流量控制、超时重传、拥塞控制）、UDP（实时性好传输效率高）、Socket编程</li>\n<li>应用层：HTTP协议（超文本传输协议）、FTP（文件传输协议）、DNS（将域名转换为IP地址）、SMTP（邮件传输协议）、Telnet（使用命令行与服务器通信）</li>\n</ul>\n</li>\n<li><p>OSI七层：（物理层、数据链路层）；网络层；传输层；（会话层、表示层、应用层）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801103658645.png\" alt=\"image-20230801103658645\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-实践\"><a href=\"#3-实践\" class=\"headerlink\" title=\"3.实践\"></a>3.实践</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Shell/Python脚本、网络编程、多线程编程</p></blockquote>\n<h3 id=\"1-Termianl\"><a href=\"#1-Termianl\" class=\"headerlink\" title=\"1.Termianl\"></a>1.Termianl</h3><ol>\n<li>目录结构：/bin：命令、/etc：系统管理所需要的配置文件和子目录、/home：用户的主目录、/lib：系统最基本的动态连接共享库、/opt：额外安装软件所摆放的目录、/root：管理员主目录、/sbin：管理员使用的命令、/tmp：存放临时文件、/usr：用户的应用程序和文件、/var：存不断扩充的文件，如日志文件</li>\n<li>命令<ul>\n<li>文件管理：ls、ll、cd、pwd、mkdir、rmdir、rm、cp、mv、touch、chown、chmod、tar、</li>\n<li>文档编辑：cat、tac、nl、more、less、head、tail、grep（文本搜索）、awk（自定义函数或正则表达式）、sed（批量编辑文本文件）</li>\n<li>进程监控：<code>su</code>、<code>sudo</code>、<code>kill</code>（<code>kill -9 pid</code>）、管道命令、<code>ps</code>（<code>ps -ef | more</code>进程信息）、<code>top</code>（实时显示进程信息）、<code>lsof</code>（查看某一文件的进程信息）、<code>free</code>（查看内存使用情况，如进程、CPU占用率、内存信息）、<code>df</code>（磁盘使用量）、<code>iostat</code>（I/O设备状态）、<code>vmstat</code>（虚拟内存状态）、du（磁盘使用情况）</li>\n<li>网络监控：<code>iperf</code>（查看带宽和网络）、<code>netstat</code>（查看占用端口的进程）、<code>traceroute</code>（数据包路径）、<code>ping</code>（测试与主机的连通性）、</li>\n<li>其它：strace、dtrace、systemtap、uname、history</li>\n</ul>\n</li>\n<li>Shell脚本</li>\n<li>Vim编辑器</li>\n<li>常见系统调用<ul>\n<li>文件管理：creat、open、close、lseek（定位）、read、write</li>\n<li>进程管理：fork、execve（执行新二进制文件）、waitpid（等待子进程结束）、clone、exit</li>\n<li>内存管理：brk、mmap（内存映射）</li>\n<li>进程间通信：<ul>\n<li>消息队列：msgget（创建队列）、msgsnd（发送消息）、msgrcv（接收消息）</li>\n<li>共享内存：shmget（创建共享内存）、shmat（将共享内存映射到内存空间）</li>\n<li>信号量：sem_wait(抢占信号量)、sem_post（释放信号量）</li>\n</ul>\n</li>\n<li>网络通信：socket、bind、connect、listen、accept</li>\n<li>信号处理：kill、signaction</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-Sockets\"><a href=\"#2-Sockets\" class=\"headerlink\" title=\"2.Sockets\"></a>2.Sockets</h3><ol>\n<li><p>socket 是什么？</p>\n<ul>\n<li>sock（或 socket）是操作系统内核提供的一种数据结构，用于实现网络传输功能</li>\n<li>基于不同的网络协议以及应用场景，衍生了各种类型的 sock。每个网络层协议都有相应的 sock 结构体来管理该层协议的连接状态和数据传输。各类 sock 操作硬件网卡，就实现了网络传输的功能</li>\n<li>为了将这些功能让处在用户态的应用程序使用，不但引入了 socket 层，还将各类功能的实现方式抽象成了 API 接口，供应用程序调用</li>\n<li>同时将 sock 封装成文件，应用程序就可以在用户层通过文件句柄（socket fd）来操作内核中 sock 的网络传输功能。这个 socket fd 是一个 int 类型的数字，而 socket 中文翻译叫做套接字，结合这个 socket fd，你是不是可以将其理解成：一套用于连接的数字</li>\n<li>而 socket 分 Internet socket 和 UNIX Domain socket，两者都可以用于不同主机进程间的通信和本机进程间的通信。只是前者采用的是基于 IP 协议的网络通信方式，而后者采用的是基于本地文件系统的通信方式</li>\n</ul>\n</li>\n<li><p>网络包接收流程</p>\n<ul>\n<li><p>网卡会将收到的网络数据帧通过<code>DMA</code>的方式放到环形缓冲区<code>RingBuffer</code>（环形缓冲区，满了就丢弃）中（可通过ifconfig命令查看网卡收发数据的情况），<code>DMA</code>操作完后网卡会向<code>CPU</code>发起一个硬中断，对应中断处理程序为网络数据帧创建内核数据结构<code>sk_buffer</code>（<code>sk_buffer</code>是双向链表，每一个元素是一个网络帧，网络各层之间操作相关指针而不是复制数据）并拷贝收到的网络数据帧，然后向<code>kernel</code>发起软中断请求（软中断和硬中断在同一个CPU核上）</p>\n<ul>\n<li>为了解决频繁中断带来的性能开销，Linux 2.6 版本引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是<strong>首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据</strong></li>\n<li>硬中断：先暂时屏蔽中断，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。接着，发起<strong>软中断</strong>，然后恢复刚才屏蔽的中断。</li>\n</ul>\n</li>\n<li><p>内核线程<code>ksoftirqd</code>（一个CPU一个）响应软中断请求，调用网卡驱动注册的<code>poll</code>函数，<code>poll</code>函数将<code>sk_buffer</code>中的网络数据包送到内核协议栈中注册的<code>ip_rcv</code>函数</p>\n</li>\n<li><p><code>ip_rcv</code>函数处在网络层，该函数取出IP头并判断下一跳走向，如果是本机则取出传输层协议类型（TCP或UDP），并去掉数据包的IP头，将数据包交给传输层处理（TCP协议使用<code>tcp_rcv</code>函数，UDP协议使用<code>udp_rcv</code>函数）</p>\n</li>\n<li><p><code>tcp_rcv</code>函数会去掉TCP头，根据<code>四元组（源IP、源端口、目的IP，目的端口）</code>查找对应的<code>Socket</code>，如果找到则将数据包中的数据拷贝到<code>Socket</code>中的接收缓冲区，否则发送一个目标不可达的<code>icmp</code>包</p>\n</li>\n<li><p>当程序调用<code>read</code>读取<code>Socket</code>接收缓冲区的数据时，如果接收缓冲区没有数据则会阻塞在系统调用上，知道<code>Socket</code>接收缓冲区有数据。然后<code>CPU</code>将内核空间（Socket接收缓冲区）的数据拷贝到用户空间，最后系统调用<code>read</code>返回，应用程序读取数据</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730151700051.png\" alt=\"image-20230730151700051\"></p>\n</li>\n</ul>\n</li>\n<li><p>网络包发送流程</p>\n<ul>\n<li><p>应用程序调用send发送数据，kernel首先根据fd找到对应的socket（包含各种协议栈的函数地址），然后构造<code>msghdr</code>对象封装用户要发送的数据。调用内核函数inet_sendmsg发送流程进入内核协议栈来处理，找到socket上具体协议的发送函数（TCP协议发送函数<code>tcp_sendmsg</code>，UDP协议发送函数<code>udp_sendmsg</code>）</p>\n<ul>\n<li><code>tcp_sendmsg</code>函数内部创建内核数据结构<code>sk_buffer</code>将<code>msghdr</code>中的数据拷贝到<code>sk_buffer</code>中，调用<code>tcp_write_queue_tail</code>函数获取Socket发送队列中的队尾元素，将<code>sk_buffer</code>添加到<code>socket</code>发送队列（双向链表）的尾部</li>\n<li>此时数据已经被拷贝到内核，但是因为TCP的流量控制和拥塞控制，所以数据并不会被马上发送，需要符合TCP协议的发送条件。如果没有达到发送条件则本次<code>send</code>系统调用就会直接返回，如果符合发送条件，则调用<code>tcp_write_xmit</code>内核函数，循环获取<code>socket</code>发送队列中待发送的<code>sk_buffer</code>，然后进行拥塞控制和滑动窗口管理</li>\n<li>发送网络数据的时候，涉及几次内存拷贝操作？<ul>\n<li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li>\n<li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li>\n<li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>将从socket发送队列中获取到的sk_buffer重新拷贝一份，并设置sk_buffer副本中的TCP HEADER</p>\n<ul>\n<li><p>sk_buffer 内部其实包含了网络协议中所有的 header。在设置 TCP HEADER的时候，只是把指针指向 sk_buffer的合适位置。后面再设置 IP HEADER的时候，在把指针移动一下就行，避免频繁的内存申请和拷贝，效率很高</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730150639810.png\" alt=\"image-20230730150639810\"></p>\n</li>\n<li><p>为什么不直接使用Socket发送队列中的sk_buffer而是需要拷贝一份呢？因为TCP协议是支持丢包重传的，在没有收到对端的ACK之前，这个sk_buffer是不能删除的。内核每次调用网卡发送数据的时候，实际上传递的是sk_buffer的拷贝副本，当网卡把数据发送出去后，sk_buffer拷贝副本会被释放。当收到对端的ACK之后，Socket发送队列中的sk_buffer才会被真正删除</p>\n</li>\n<li><p>为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包：sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame，通过调整 sk_buff 中 <code>data</code> 的指针来实现</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801105354758.png\" alt=\"image-20230801105354758\"></p>\n</li>\n</ul>\n</li>\n<li><p>调用ip_queue_xmit内核函数进行网络层的处理</p>\n<ul>\n<li>将<code>sk_buffer</code>中的指针移动到<code>IP头</code>位置上，设置<code>IP头</code></li>\n<li>执行<code>netfilters</code>过滤。过滤通过之后，如果数据大于 <code>MTU</code>的话，则执行分片</li>\n<li>检查<code>Socket</code>中是否有缓存路由表，如果没有的话，则查找路由项，并缓存到<code>Socket</code>中。接着在把路由表设置到<code>sk_buffer</code>中</li>\n</ul>\n</li>\n<li><p>邻居子系统</p>\n<ul>\n<li><code>邻居子系统</code>位于内核协议栈中的<code>网络层</code>和<code>网络接口层</code>之间，用于发送<code>ARP请求</code>获取<code>MAC地址</code>，然后将<code>sk_buffer</code>中的指针移动到<code>MAC头</code>位置，填充<code>MAC头</code>，此时<code>sk_buffer</code>中已经封装了一个完整的数据帧</li>\n</ul>\n</li>\n<li><p>网络设备子系统</p>\n<ul>\n<li><p>选择发送队列（<code>RingBuffer</code>），因为网卡拥有多个发送队列，所以在发送前需要选择一个发送队列</p>\n</li>\n<li><p>将<code>sk_buffer</code>添加到发送队列中</p>\n</li>\n<li><p>循环从发送队列（<code>RingBuffer</code>）中取出<code>sk_buffer</code>，调用内核函数<code>sch_direct_xmit</code>发送数据，其中会调用<code>网卡驱动程序</code>来发送数据</p>\n</li>\n</ul>\n</li>\n<li><p>无论是用户线程的内核态还是触发<code>NET_TX_SOFTIRQ</code>类型的软中断在发送数据的时候最终会调用到网卡的驱动程序函数<code>dev_hard_start_xmit</code>来发送数据。在网卡驱动程序函数<code>dev_hard_start_xmit</code>中会将<code>sk_buffer</code>映射到网卡可访问的内存 DMA 区域，最终网卡驱动程序通过<code>DMA</code>的方式将数据帧通过物理网卡发送出去</p>\n<ul>\n<li>前文a-e是用户线程的内核态在执行，占用的CPU时间是系统态时间(<code>sy</code>)，当分配给用户线程的<code>CPU quota</code>用完的时候，会触发<code>NET_TX_SOFTIRQ</code>类型的软中断，内核线程<code>ksoftirqd</code>会响应这个软中断，并执行<code>NET_TX_SOFTIRQ</code>类型的软中断注册的回调函数<code>net_tx_action</code>，在回调函数中会执行到驱动程序函数 <code>dev_hard_start_xmit</code>来发送数据</li>\n<li>从这里可以看到网络包的发送过程和接受过程是不同的，在介绍网络包的接受过程时，通过触发<code>NET_RX_SOFTIRQ</code>类型的软中断在内核线程<code>ksoftirqd</code>中执行内核网络协议栈接受数据。而在网络数据包的发送过程中是用户线程的内核态在执行内核网络协议栈，只有当线程的<code>CPU quota</code>用尽时，才触发<code>NET_TX_SOFTIRQ</code>软中断来发送数据</li>\n<li>在整个网络包的发送和接受过程中，<code>NET_TX_SOFTIRQ</code>类型的软中断只会在发送网络包时并且当用户线程的<code>CPU quota</code>用尽时，才会触发。剩下的接受过程中触发的软中断类型以及发送完数据触发的软中断类型均为<code>NET_RX_SOFTIRQ</code>。所以这就是在服务器上查看 <code>/proc/softirqs</code>，一般 <code>NET_RX</code>都要比 <code>NET_TX</code>大很多的的原因</li>\n</ul>\n</li>\n<li><p>当数据发送完毕后，还有最后一项重要的工作，就是清理工作。数据发送完毕后，网卡设备会向CPU发送一个硬中断，CPU调用网卡驱动程序注册的硬中断响应程序，在硬中断响应中触发NET_RX_SOFTIRQ类型的软中断，在软中断的回调函数igb_poll中清理释放 sk_buffer，清理网卡发送队列（RingBuffer），解除DMA映射</p>\n<ul>\n<li>无论硬中断是因为有数据要接收，还是说发送完成通知，从硬中断触发的软中断都是 <code>NET_RX_SOFTIRQ</code></li>\n<li>这里释放清理的只是<code>sk_buffer</code>的副本，真正的<code>sk_buffer</code>现在还是存放在<code>Socket</code>的发送队列中。前面在传输层处理的时候我们提到过，因为传输层需要保证可靠性，所以 <code>sk_buffer</code>其实还没有删除。它得等收到对方的 ACK 之后才会真正删除</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-Processes\"><a href=\"#3-Processes\" class=\"headerlink\" title=\"3.Processes\"></a>3.Processes</h3><h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ol>\n<li><p>网络设备</p>\n<ul>\n<li>路由器和交换机的区别<ul>\n<li><strong>工作层次不同：</strong><ul>\n<li>交换机主要工作在数据链路层（第二层）</li>\n<li>路由器工作在网络层（第三层）</li>\n</ul>\n</li>\n<li><strong>转发依据不同：</strong><ul>\n<li>交换机转发所依据的对象时：MAC地址。（物理地址）</li>\n<li>路由转发所依据的对象是：IP地址。（网络地址），因为只处理MAC地址匹配路由器的网络爆</li>\n</ul>\n</li>\n<li><strong>主要功能不同：（交换机能做的，路由都能做。）</strong><ul>\n<li>交换机主要用于组建局域网，不能分割广播域</li>\n<li>而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet，可以提供防火墙功能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>命令行</p>\n<ul>\n<li><p><code>netstat -napt</code>：查看TCP的连接状态</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801093314230.png\" alt=\"image-20230801093314230\"></p>\n</li>\n<li><p><code>route -n</code>：查看当前系统的路由表，将目的IP与掩码与操作得到的结果与Destination比较，相同则走对应的iface（网卡）</p>\n<ul>\n<li>第三条是默认网关：如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器（Gateway即对应路由器的IP地址）</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801093423564.png\" alt=\"image-20230801093423564\"></p>\n</li>\n<li><p><code>arp -a</code> 查看 ARP 缓存的内容，记录IP与MAC的映射关系</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801095015812.png\" alt=\"image-20230801095015812\"></p>\n</li>\n<li></li>\n</ul>\n</li>\n</ol>\n","text":"Linux1.操作系统原理1.进程管理 概念 进程：进程是资源调度的基本单位，启动main函数就是启动一个JVM进程，main函数所在的线程是这个进程的主线程 线程：线程是CPU调度的基本单位，线程间共享堆和方法去资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈 协程：由...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Linux\"><span class=\"toc-text\">Linux</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.操作系统原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">1.进程管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">2.内存管理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">3.文件管理</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">2.网络协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">1.网络层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BC%A0%E8%BE%93%E5%B1%82\"><span class=\"toc-text\">2.传输层</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%BA%94%E7%94%A8%E5%B1%82\"><span class=\"toc-text\">3.应用层</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">3.实践</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Termianl\"><span class=\"toc-text\">1.Termianl</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Sockets\"><span class=\"toc-text\">2.Sockets</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Processes\"><span class=\"toc-text\">3.Processes</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95\"><span class=\"toc-text\">附录</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2023-07-30T02:35:00.000Z","updated":"2023-07-31T07:43:58.492Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"text":"JVM1.编译执行 如何实现跨平台：通过不同平台的JVM实现来将相同的一个Class文件翻译成适配不同机器的机器语言用于执行，即使打包成可还行文件仍需要JVM的支持 Java程序的执行过程 JAVA源代码编译成字节码；字节码校验并把JAVA程序通过类加载器加载到JVM内存中，在加...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"26 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring Family","uid":"0eecce2180060832c1ffa34a76f3eb3b","slug":"Spring","date":"2023-05-06T05:09:43.000Z","updated":"2023-07-31T02:32:32.615Z","comments":true,"path":"api/articles/Spring.json","keywords":null,"cover":[],"text":"Spring 1.IOC1.基础知识 BeanFactory：提供了一种高级配置，能够管理任何类型对象，BeanFactory是ApplicationContext的父接口，ApplicationContext接口的实现类主要有ClassPathXmlApplicationCon...","link":"","photos":[],"count_time":{"symbolsCount":"97k","symbolsTime":"1:28"},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}