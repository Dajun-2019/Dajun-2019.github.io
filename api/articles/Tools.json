{"title":"Tools","uid":"7092a7d1e2affc5f0cb3af30af9d1e19","slug":"Tools","date":"2023-07-30T02:37:14.000Z","updated":"2023-08-02T14:22:51.114Z","comments":true,"path":"api/articles/Tools.json","keywords":null,"cover":[],"content":"<h2 id=\"1-markdown\"><a href=\"#1-markdown\" class=\"headerlink\" title=\"1.markdown\"></a>1.markdown</h2><ol>\n<li><p>框架</p>\n<ol>\n<li><p>多级标题：<code>#</code>与后面文本有一个空格，标题行前后建议空行</p>\n<table>\n<thead>\n<tr>\n<th>Markdown</th>\n<th>HTML</th>\n</tr>\n</thead>\n<tbody><tr>\n<td># Heading level 1</td>\n<td><h1>Heading level 1</h1></td>\n</tr>\n<tr>\n<td>## Heading level 2</td>\n<td><h2>Heading level 2</h2></td>\n</tr>\n<tr>\n<td>### Heading level 3</td>\n<td><h3>Heading level 3</h3></td>\n</tr>\n<tr>\n<td>#### Heading level 4</td>\n<td><h4>Heading level 4</h4></td>\n</tr>\n<tr>\n<td>##### Heading level 5</td>\n<td><h5>Heading level 5</h5></td>\n</tr>\n<tr>\n<td>###### Heading level 6</td>\n<td><h6>Heading level 6</h6></td>\n</tr>\n</tbody></table>\n</li>\n<li><p>引用</p>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">&gt; #### The quarterly results look great!\n&gt;\n&gt; - Revenue was off the chart.\n&gt; - Profits were higher than ever.\n&gt;\n&gt;  *Everything* is going according to **plan**.\n&gt;&gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.</code></pre></li>\n<li><p>段落：用一个空行分离两段文本，每一个文本段落建议不首行缩进</p>\n<table>\n<thead>\n<tr>\n<th>Markdown</th>\n<th>HTML</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>I really like using Markdown.I think I’ll use it to format all of my documents from now on.</td>\n<td><p>I really like using Markdown.</p><p>I think I’ll use it to format all of my documents from now on.</p></td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n</li>\n<li><p>文本格式</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Markdown</th>\n<th>HTML</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>加粗</td>\n<td>I just love <strong>bold text</strong>.</td>\n<td>I just love <strong>bold text</strong>.</td>\n</tr>\n<tr>\n<td>斜体</td>\n<td>Italicized text is the <em>cat’s meow</em>.</td>\n<td>Italicized text is the <em>cat’s meow</em>.</td>\n</tr>\n<tr>\n<td>加粗+斜体</td>\n<td>This text is <em><strong>really important</strong></em>.</td>\n<td>This text is <em><strong>really important</strong></em>.</td>\n</tr>\n<tr>\n<td>删除</td>\n<td>The world is flat.</td>\n<td>有可能不兼容</td>\n</tr>\n<tr>\n<td>高亮</td>\n<td>I need to highlight these ==very important words==.</td>\n<td>有可能不兼容</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>list</p>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">有序链表\n1. First item\n2. Second item\n3. Third item\n    1. Indented item\n    2. Indented item\n4. Fourth item\n无序链表\n- First item\n- Second item\n- Third item\n    - Indented item\n    - Indented item\n- Fourth item\n有序内嵌无序\n1. First item\n2. Second item\n3. Third item\n    - Indented item\n    - Indented item\n4. Fourth item</code></pre></li>\n<li><p>表格</p>\n<pre class=\"line-numbers language-markdown\" data-language=\"markdown\"><code class=\"language-markdown\">| Syntax      | Description |\n| ----------- | ----------- |\n| Header      | Title       |\n| Paragraph   | Text        |\n\n指定左右对齐\n| Syntax      | Description | Test Text     |\n| :---        |    :----:   |          ---: |\n| Header      | Title       | Here&#39;s this   |\n| Paragraph   | Text        | And more      |</code></pre></li>\n<li><p>其它</p>\n<ul>\n<li><p>代码块：看软件</p>\n</li>\n<li><p>图片：<code>![Tux, the Linux mascot](/assets/images/tux.png)</code></p>\n</li>\n<li><p>水平线：使用<code>***</code>，或者使用<code>—-</code></p>\n</li>\n<li><p>链接：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">[Duck Duck Go](&lt;https:&#x2F;&#x2F;duckduckgo.com&gt;).</code></pre>\n\n<ul>\n<li>增加光标悬停时的title：<code>[Duck Duck Go](&lt;https://duckduckgo.com&gt; &quot;The best search engine for privacy&quot;).</code></li>\n<li>URLs或Email地址：<code>&lt;https://www.markdownguide.org&gt;</code>、<code>&lt;fake@example.com&gt;</code></li>\n<li>链接内的特殊字符有的时候需要更改，如<code>[link](&lt;https://www.example.com/my%20great%20page&gt;)</code>（使用%20代替空格）</li>\n</ul>\n</li>\n<li><p>转义字符：使用<code>\\\\</code>来转义前面有特殊意义的字符</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-mermaid\"><a href=\"#2-mermaid\" class=\"headerlink\" title=\"2.mermaid\"></a>2.mermaid</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>文档地址：<a href=\"https://mermaid.js.org/intro/%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80%EF%BC%9Ahttps://github.com/mermaid-js/mermaid\">https://mermaid.js.org/intro/，代码地址：https://github.com/mermaid-js/mermaid</a></p></blockquote>\n<ol>\n<li><p>语法结构</p>\n<ul>\n<li><p>部署环境</p>\n</li>\n<li><p>会影响图标连续性的字符</p>\n<table>\n<thead>\n<tr>\n<th>Diagram Breakers</th>\n<th>Reason</th>\n<th>Solution</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Comments</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><a href=\"https://github.com/mermaid-js/mermaid/issues/1968\">https://github.com/mermaid-js/mermaid/issues/1968</a></td>\n<td>Similar to <a href=\"https://mermaid.js.org/config/directives.html\">https://mermaid.js.org/config/directives.html</a> confuses the renderer.</td>\n<td>In comments using %%, avoid using “{}”.</td>\n</tr>\n<tr>\n<td>Flow-Charts</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>‘end’</td>\n<td>The word “End” can cause Flowcharts and Sequence diagrams to break</td>\n<td>Wrap them in quotation marks to prevent breakage.</td>\n</tr>\n<tr>\n<td>Nodes inside Nodes</td>\n<td>Mermaid gets confused with nested shapes</td>\n<td>wrap them in quotation marks to prevent breaking</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>基础语法</p>\n<ul>\n<li><p>点</p>\n<ul>\n<li>可选择是否填充文本</li>\n<li>可选择节点形状：</li>\n</ul>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">flowchart TD\n    id\n    id1[This is the text in the box]\n\t\tid2(text)\n\t\tid3([text])\n\t\tid4[[text]]\n\t\tid5[(Database)]\n\t\tid6&gt;text]\n\t\tid7&#123;&#123;text&#125;&#125;\n\t\tid8[&#x2F;This is the text in the box&#x2F;]</code></pre></li>\n<li><p>边：TB（top to bottom，或TD）、BT（bottom to top）、RL（right to left）、LR（left to right）</p>\n<ul>\n<li>不可见连接，主要为了排版：<code>A ~~~ B</code></li>\n<li>加粗：<code>A ==&gt; B</code></li>\n<li>简化语法：<code>a --&gt; b &amp; c--&gt; d</code>、<code>A &amp; B--&gt; C &amp; D</code></li>\n</ul>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">flowchart TB\n\t\tsubgraph one\n    A --&gt; B\n\t\tA--&gt;|text|B\n\t\tA --- C\n\t\tA-- text ---C\n\t\tA-.-&gt;D\n\t\tA-. text .-&gt; D\n\t\tend\n\t\tsubgraph two \n\t\ta[Start] --&gt; b&#123;Is it?&#125;\n    b -- Yes --&gt; c[OK]\n    c --&gt; d[Rethink]\n    d --&gt; b\n    b -- No ----&gt; e[End]\n\t\tend\n\t\t\n\t\t</code></pre></li>\n<li><p>边的级别</p>\n<table>\n<thead>\n<tr>\n<th>Length</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Normal</td>\n<td>—</td>\n<td>—-</td>\n<td>—–</td>\n</tr>\n<tr>\n<td>Normal with arrow</td>\n<td>–&gt;</td>\n<td>—&gt;</td>\n<td>—-&gt;</td>\n</tr>\n<tr>\n<td>Thick</td>\n<td>===</td>\n<td>====</td>\n<td>=====</td>\n</tr>\n<tr>\n<td>Thick with arrow</td>\n<td>==&gt;</td>\n<td>===&gt;</td>\n<td>====&gt;</td>\n</tr>\n<tr>\n<td>Dotted</td>\n<td>-.-</td>\n<td>-..-</td>\n<td>-…-</td>\n</tr>\n<tr>\n<td>Dotted with arrow</td>\n<td>-.-&gt;</td>\n<td>-..-&gt;</td>\n<td>-…-&gt;</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Flowchart</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">graph TD;\n    A--&gt;B;\n    A--&gt;C;\n    B--&gt;D;\n    C--&gt;D;</code></pre></li>\n<li><h2 id=\"Sequence-diagram\"><a href=\"#Sequence-diagram\" class=\"headerlink\" title=\"Sequence diagram\"></a>Sequence diagram</h2><pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">sequenceDiagram\n    participant Alice\n    actor Bob\n    Alice-&gt;&gt;John: Hello John, how are you?\n    loop Healthcheck\n        John-&gt;&gt;John: Fight against hypochondria\n    end\n    Note right of John: Rational thoughts &lt;br&#x2F;&gt;prevail!\n    John--&gt;&gt;Alice: Great!\n    John-&gt;&gt;Bob: How about you?\n    Bob--&gt;&gt;John: Jolly good!</code></pre></li>\n<li><p>Class diagram</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">classDiagram\nClass01 &lt;|-- AveryLongClass : Cool\nClass03 *-- Class04\nClass05 o-- Class06\nClass07 .. Class08\nClass09 --&gt; C2 : Where am i?\nClass09 --* C3\nClass09 --|&gt; Class07\nClass07 : equals()\nClass07 : Object[] elementData\nClass01 : size()\nClass01 : int chimp\nClass01 : int gorilla\nClass08 &lt;--&gt; C2: Cool label</code></pre></li>\n<li><p>Gantt diagram</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">gantt\ndateFormat  YYYY-MM-DD\ntitle Adding GANTT diagram to mermaid\nexcludes weekdays 2014-01-10\n\nsection A section\nCompleted task            :done,    des1, 2014-01-06,2014-01-08\nActive task               :active,  des2, 2014-01-09, 3d\nFuture task               :         des3, after des2, 5d\nFuture task2               :         des4, after des3, 5d</code></pre></li>\n<li><p>GIt graph</p>\n<pre class=\"line-numbers language-mermaid\" data-language=\"mermaid\"><code class=\"language-mermaid\">gitGraph\n       commit\n       commit\n       branch develop\n       commit\n       commit\n       commit\n       checkout main\n       commit\n       commit</code></pre></li>\n</ol>\n<h2 id=\"3-Latex\"><a href=\"#3-Latex\" class=\"headerlink\" title=\"3.Latex\"></a>3.Latex</h2><blockquote>\n</blockquote>\n<ol>\n<li><p>相关工具和文档</p>\n<ul>\n<li>文档：<a href=\"https://www.latex-project.org/\">https://www.latex-project.org/</a></li>\n<li>Overleaf：网上的LaTex编辑器，不用配置本地环境，需要挂VPN否则访问慢</li>\n<li>BibDesk：用于管理文献引用的软件，可以帮助创建、编辑和组织文献数据库，并生成符合各种引用风格的参考文献列表</li>\n<li>LaTeXiT：用于生成高质量数学公式和方程的工具，允许输入LaTex代码并即时预览生成的公式，可以导出为矢量图或其他格式，方便在文档中使用</li>\n<li>TeX Live Utility：一个用于管理TeX Live发行版的使用工具，Tex Live是一个广泛使用的TeX发行版，包含了大量的TeX相关软件包和工具，Tex Live Utility允许安装、更新和删除TeX Live中的软件包，来保证当前系统与最新的TeX发行版保持同步</li>\n<li>TeXShop：是一个用于编辑和编译LaTeX文档的集成开发环境（IDE），提供了一个用户友好的界面并且可以直接从TeXShop中编译生成PDF文档</li>\n</ul>\n</li>\n<li><p>语法</p>\n<ul>\n<li>文档类（Document Class）：在LaTeX文档的开头使用<code>\\\\documentclass&#123;&#125;</code>命令指定文档的类型，例如<code>\\\\documentclass&#123;article&#125;</code>表示创建一篇文章。</li>\n<li>导言区（Preamble）：在<code>\\\\documentclass&#123;&#125;</code>命令后，<code>\\\\begin&#123;document&#125;</code>命令前的部分被称为导言区。可以在导言区中加载宏包、定义命令、设置页面布局等。</li>\n<li>章节命令：使用<code>\\\\section&#123;&#125;</code>、<code>\\\\subsection&#123;&#125;</code>、<code>\\\\subsubsection&#123;&#125;</code>等命令来创建章节标题。例如，<code>\\\\section&#123;Introduction&#125;</code>表示创建一个名为”Introduction”的章节。</li>\n<li>标题和作者：使用<code>\\\\title&#123;&#125;</code>和<code>\\\\author&#123;&#125;</code>命令设置文档的标题和作者。在导言区中，可以使用<code>\\\\maketitle</code>命令在文档的正文中生成标题和作者信息。</li>\n<li>内容和段落：LaTeX使用空行来分隔段落。可以使用<code>\\\\par</code>命令来手动分段。使用普通文本编写内容即可。</li>\n<li>数学公式：LaTeX以其强大的数学排版功能而闻名。可以使用<code>$...$</code>或<code>\\\\(...\\\\)</code>将数学表达式嵌入到文本中，也可以使用<code>$$...$$</code>或<code>\\\\[...\\\\]</code>创建独立的行间公式。LaTeX提供了丰富的数学符号和环境，如<code>\\\\frac&#123;&#125;&#123;&#125;</code>表示分数，<code>\\\\sum</code>表示求和符号等。</li>\n<li>列表：使用<code>itemize</code>环境创建无序列表，使用<code>enumerate</code>环境创建有序列表。每个列表项使用<code>\\\\item</code>命令来标记。</li>\n<li>表格：LaTeX提供了<code>tabular</code>环境来创建表格。可以指定表格的列数和每列的对齐方式，并使用<code>&amp;</code>来分隔单元格，使用<code>\\\\\\\\</code>来换行。</li>\n<li>图片和图表：使用<code>\\\\includegraphics&#123;&#125;</code>命令将图片插入到文档中。可以设置图片的大小、位置和标题。使用<code>figure</code>环境可以创建带有标题和标签的浮动图形。</li>\n<li>引用和交叉引用：使用<code>\\\\label&#123;&#125;</code>命令为章节、公式、图表等添加标签，然后使用<code>\\\\ref&#123;&#125;</code>命令进行引用。LaTeX会自动处理引用的编号和页码。</li>\n</ul>\n</li>\n<li><p>公式</p>\n<ul>\n<li><p>行内公式：使用<code>$...$</code>或者<code>\\\\(...\\\\)</code>将数学表达式嵌入到文本中。例如：<code>$E=mc^2$</code>。</p>\n</li>\n<li><p>行间公式：使用<code>$$...$$</code>或者<code>\\\\[...\\\\]</code>创建独立的行间公式。例如：<code>$$\\\\int_&#123;0&#125;^&#123;1&#125; x^2 dx$$</code>。</p>\n</li>\n<li><p>上下标：使用<code>^</code>表示上标，<code>_</code>表示下标。例如：<code>$x^2$</code>表示x的平方。</p>\n</li>\n<li><p>分式：使用<code>\\\\frac&#123;numerator&#125;&#123;denominator&#125;</code>表示分式。例如：<code>\\\\frac&#123;1&#125;&#123;2&#125;</code>表示1/2。</p>\n</li>\n<li><p>开根号：使用<code>\\\\sqrt&#123;&#125;</code>表示开根号。例如：<code>\\\\sqrt&#123;2&#125;</code>表示根号下2。</p>\n</li>\n<li><p>求和、积分符号：使用<code>\\\\sum</code>表示求和符号，使用<code>\\\\int</code>表示积分符号。例如：<code>\\\\sum_&#123;i=1&#125;^&#123;n&#125; i</code>表示从1到n的求和。</p>\n</li>\n<li><p>矩阵和数组：使用<code>matrix</code>环境创建矩阵，使用<code>array</code>环境创建数组。例如：</p>\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">复制代码\n\\\\begin&#123;matrix&#125;\n1 &amp; 2 \\\\\\\\\n3 &amp; 4 \\\\\\\\\n\\\\end&#123;matrix&#125;</code></pre></li>\n<li><p>方程组：使用<code>cases</code>环境创建方程组。例如：</p>\n<pre class=\"line-numbers language-latex\" data-language=\"latex\"><code class=\"language-latex\">复制代码\n\\\\begin&#123;cases&#125;\nx + y &#x3D; 2 \\\\\\\\\nx - y &#x3D; 1 \\\\\\\\\n\\\\end&#123;cases&#125;</code></pre></li>\n<li><p>上下限：使用<code>\\\\limits</code>来指定求和、积分等运算符的上下限。例如：<code>\\\\sum\\\\limits_&#123;i=1&#125;^&#123;n&#125; i</code>表示从1到n的求和。</p>\n</li>\n<li><p>特殊符号：LaTeX提供了许多特殊符号的命令，例如希腊字母、箭头、关系符号等。例如：<code>\\\\alpha</code>表示α，<code>\\\\rightarrow</code>表示→。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-Git\"><a href=\"#4-Git\" class=\"headerlink\" title=\"4.Git\"></a>4.Git</h2><h3 id=\"1-Git整体结构\"><a href=\"#1-Git整体结构\" class=\"headerlink\" title=\"1.Git整体结构\"></a><strong>1.Git整体结构</strong></h3><p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730103842109.png\" alt=\"image-20230730103842109\"></p>\n<ul>\n<li>工作区：电脑里能看到的目录</li>\n<li>暂存区：<code>.git</code>目录下的index文件（<code>.git/index</code>），也叫做索引（index）</li>\n<li>本地版本库：工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库</li>\n<li>远程仓库</li>\n<li>Git文件状态</li>\n<li>版本</li>\n<li>HEAD：指向master分支的一个游标，所以出现Head的地方可以用master来替换</li>\n<li>分支</li>\n</ul>\n<h3 id=\"2-常用操作\"><a href=\"#2-常用操作\" class=\"headerlink\" title=\"2.常用操作\"></a><strong>2.常用操作</strong></h3><ol>\n<li><p>查看/修改提交用户名、邮箱</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#查看$ git config --list$ git config user.name$ git config user.email#不加--global将只更改本仓库的配置$ git config --global user.name &quot;dajunnnnnn&quot;$ git config --global user.email &quot;1064049895@qq.com&quot;</code></pre></li>\n<li><p>操作流程</p>\n<ol>\n<li><p>初始化：<code>git init</code>，在执行完成 git init命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变</p>\n</li>\n<li><p>克隆：<code>git clone</code>，从现有Git仓库中拷贝项目，例如<code>git clone &lt;https://github.com/Dajun-2019/Learning.git</code>&gt;</p>\n</li>\n<li><p>暂存：<code>git add .</code>，对工作区执行此命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库（.git/objects）中的一个新对象中，而该对象的ID被记录在暂存区的文件索引中</p>\n</li>\n<li><p>提交：<code>git commit -m &quot;注释信息”</code>，暂存区的目录树写到版本库（对象库）中，master分支会做相应的更新，即master指向的目录树就是提交时暂存区的目录树</p>\n</li>\n<li><p>远端操作</p>\n<ul>\n<li>首先载入远程仓库（git clone…）、然后进入此仓库，执行<code>git remote -v</code>，输出的origin为远程地址的别名</li>\n<li>显示某个远程仓库的信息：<code>git remote show [remote]</code></li>\n<li>其他命令<ul>\n<li>添加远程版本库：<code>git remote add origin git@github.com:Dajun-2019/Learning</code></li>\n<li>删除远程仓库：<code>git remote rm name</code></li>\n<li>修改仓库名：’git remote rename old-name new_name’</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拉取：<code>git fetch origin master:temp</code>（将远程仓库（origin为别名）的master分支的代码下载到本地分支上面）</p>\n</li>\n<li><p>拉去代码并合并：<code>$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>\n</li>\n<li><p>上传远程代码并合并：<code>git push -u origin master</code>，在git中，“push -u”的意思是将本地的分支版本上传到远程合并，并且记录push到远程分支的默认值；当添加“-u”参数时，表示下次继续push的这个远端分支的时候推送命令就可以简写成“git push”</p>\n</li>\n<li><p>查看状态（git status）：查看仓库当前状态，显示有变更的文件。git status -s简介输出</p>\n</li>\n<li><p>分支操作</p>\n<ul>\n<li><p>创建分支：<code>git branch (branch name)</code></p>\n</li>\n<li><p>查看分支：<code>git branch</code></p>\n</li>\n<li><p>切换分支：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">git checkout (branch name)</code></pre>\n\n<ul>\n<li>当执行 <code>git checkout .</code>或者 <code>git checkout -- &lt;file&gt;</code>命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li>\n<li>当执行 <code>git checkout HEAD .</code>或者 <code>git checkout HEAD &lt;file&gt;</code>命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li>\n</ul>\n</li>\n<li><p>删除分支：<code>git branch -d (branch name)</code></p>\n</li>\n<li><p>合并分支：<code>git merge （branch name）</code>（branch name会被合并到主分支）</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"3-实践\"><a href=\"#3-实践\" class=\"headerlink\" title=\"3.实践\"></a><strong>3.实践</strong></h3><ol>\n<li><p>Pull Request流程</p>\n<ol>\n<li><p>把别人的代码fork到自己的仓库</p>\n</li>\n<li><p>在自己的仓库上修改后的分支，摁下New pull request按钮</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730103911316.png\" alt=\"image-20230730103911316\"></p>\n</li>\n<li><p>这时，会进入一个新页面，有Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730103924968.png\" alt=\"image-20230730103924968\"></p>\n</li>\n<li><p>填写说明，帮助别人理解你的提交，然后按下”create pull request”按钮即可</p>\n</li>\n<li><p><code>git am</code>用于将一个patch文件，合并进入当前代码（Github 对每个 PR 会自动生成一个 patch 文件），可以下载该文件，合并进本地代码，就可以在本地查看效果了</p>\n</li>\n<li><p>GitHub Flow协作流程</p>\n<ul>\n<li>克隆 / Fork 仓库：git clone …</li>\n<li>创建分支: git branch …</li>\n<li>修改代码:</li>\n<li>发起 Pull Request: git</li>\n<li>Code Review</li>\n<li>Merge 分支</li>\n<li>删除分支</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>本地仓库推送到github上的流程</p>\n<ol>\n<li>确保Github账户上已经添加了本机的SSH key</li>\n<li>在Github上创建一个新的仓库，并且复制对应链接</li>\n<li>切换到本地项目所在目录，执行git init初始化一个本地仓库</li>\n<li>关联远程库：<code>git remote add origin &lt;https://github.com/&gt;...</code></li>\n<li>进行代码合并，将远程代码下载到本地：<code>git pull --rebase origin master</code></li>\n<li>将本地项目添加到本地仓库<ul>\n<li><code>git add .</code></li>\n<li><code>git commit -m &quot;提交信息&quot;</code></li>\n<li><code>git status</code></li>\n</ul>\n</li>\n<li>推送master分支的所有内容：<code>git push -u origin master</code></li>\n<li>去github上检查仓库是否提交成功</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"5-Docker\"><a href=\"#5-Docker\" class=\"headerlink\" title=\"5.Docker\"></a>5.Docker</h2><h3 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a><strong>1.概念</strong></h3><ol>\n<li><p>docker 架构（通过docker run hello-world可以展示详细工作流程）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730103942699.png\" alt=\"image-20230730103942699\"></p>\n<ul>\n<li>命令行工具docker实际上是一个client，他会与Docker Engine里的后台服务Docker daemon通信，镜像存储在远端的Registry里，客户端不能直接访问镜像仓库</li>\n<li>Docker client可以通过build、pull、run等命令向Docker daemon发送请求，而Docker daemon则负责从远端拉去镜像、在本地存储镜像、从镜像生成容器、管理容器等功能</li>\n<li>容器化的应用：指应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行。镜像就是静态的应用容器，容器就是动态的应用镜像</li>\n</ul>\n</li>\n<li><p>隔离怎么实现的</p>\n<ul>\n<li>其实奥秘就在于 Linux 操作系统内核之中，为资源隔离提供了三种技术：namespace、cgroup、chroot，虽然这三种技术的初衷并不是为了实现容器，但它们三个结合在一起就会发生奇妙的“化学反应”</li>\n<li>namespace 是 2002 年从 Linux 2.4.19 开始出现的，和编程语言里的 namespace 有点类似，它可以创建出独立的文件系统、主机名、进程号、网络等资源空间，相当于给进程盖了一间小板房，这样就实现了系统全局资源和进程局部资源的隔离</li>\n<li>cgroup 是 2008 年从 Linux 2.6.24 开始出现的，它的全称是 Linux Control Group，用来实现对进程的 CPU、内存等资源的优先级和配额限制，相当于给进程的小板房加了一个天花板</li>\n<li>chroot 的历史则要比前面的 namespace、cgroup 要古老得多，早在 1979 年的 UNIX V7 就已经出现了，它可以更改进程的根目录，也就是限制访问文件系统，相当于给进程的小板房铺上了地砖</li>\n</ul>\n</li>\n<li><p>镜像的内部机制</p>\n<ul>\n<li><p>分层（Layer）：容器镜像内部并不是一个平坦的结构，而是由许多的镜像层组成的，每层都是只读不可修改的一组文件，相同的层可以在镜像之间共享，然后多个层像搭积木一样堆叠起来，再使用一种叫“Union FS 联合文件系统”的技术把它们合并在一起，就形成了容器最终看到的文件系统</p>\n<ul>\n<li>如果某两层有文件同名，则只能看到上层的文件，下层的就被屏蔽了，可以使用<code>docker inspect nginx:alpine</code>来查看镜像的分层信息（RootFS部分）</li>\n<li>在拉取镜像的时候，只会拉取缺少的层；在删除镜像的时候，只会删除没有未被共享的层</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730104001545.png\" alt=\"image-20230730104001545\"></p>\n</li>\n<li><p>容器与外部互联互通</p>\n<ul>\n<li><p>文件</p>\n<ul>\n<li><code>docker cp+源路径+目标路径</code> 命令可以在容器和主机之间互相拷贝文件，适合简单的数据交换，其中目标路径需要用容器名/ID来指明是那个容器的路径，示例：<code>docker cp a.txt 062:/tmp</code></li>\n<li><code>docker run -v</code>命令可以让容器和主机共享本地目录，免去了拷贝操作，提升工作效率，示例：<code>docker run -d --rm -v /tmp:/tmp redis</code>，格式为<code>宿主机路径: 容器内路径</code>，把本机的/tmp路径挂载道容器里的/tmp目录，常用于不同环境运行相同文件</li>\n</ul>\n</li>\n<li><p>网络</p>\n<ul>\n<li><p>网络分类</p>\n<ul>\n<li>host 网络模式让容器与主机共享网络栈，效率高但容易导致端口冲突，<code>docker run -d --rm --net=host nginx:alpine</code></li>\n<li>bridge 网络模式实现了一个虚拟网桥，容器和主机都在一个私有网段内互联互通，默认使用此模式</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730104018740.png\" alt=\"image-20230730104018740\"></p>\n</li>\n<li><p>docker 有一个连接系统允许将多个容器连接在一起，共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息</p>\n</li>\n<li><p>新建网络：<code>docker network create -d bridge test-net</code></p>\n<ul>\n<li>d：指定Docker网络类型，可以是bridge、overlay（用于Swarm）</li>\n</ul>\n</li>\n<li><p>连接容器</p>\n<ul>\n<li><p>运行一个容器并连接到新建的 test-net 网络:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker run -itd --name test1 --network test-net ubuntu &#x2F;bin&#x2F;bash</code></pre></li>\n<li><p>打开新的终端，再运行一个容器并加入到 test-net 网络:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker run -itd --name test2 --network test-net ubuntu &#x2F;bin&#x2F;bash</code></pre></li>\n<li><p>test1和test2可以互相ping通，二者建立了互联关系，如果有多个容器，推荐使用Docker Compose</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>网络端口映射：<code>docker run -p</code>命令可以把主机的端口号映射到容器的内部端口号，解决了潜在的端口冲突</p>\n<ul>\n<li><p>P：是容器内部端口<strong>随机</strong>映射到主机的端口</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py\n33e4523d30aaf0258915c368e66e03b49535de0ef20317d3f639d40222ba6bc0</code></pre></li>\n<li><p>p：是容器内部端口绑定到<strong>指定</strong>的主机端口，还可以附加绑定网络地址</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">$ docker run -d -p 127.0.0.1:5000:5000&#x2F;udp training&#x2F;webapp python app.py\n6779686f06f6204579c1d655dd8b2b31e8e809b245a97b2d3a8e35abe9dcd22a</code></pre></li>\n</ul>\n</li>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-常用操作-1\"><a href=\"#2-常用操作-1\" class=\"headerlink\" title=\"2.常用操作\"></a><strong>2.常用操作</strong></h3><ol>\n<li><p>安装docker服务</p>\n<ul>\n<li><p>安装docker：<code>sudo apt install -y docker.io</code></p>\n</li>\n<li><p>启动docker服务：<code>sudo service docker start</code></p>\n</li>\n<li><p>当前用户加入docker组：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sudo usermod -aG docker $&#123;USER&#125;</code></pre>\n\n<p>，</p>\n<ul>\n<li>因为操作 Docker 必须要有 root 权限，而直接使用 root 用户不够安全</li>\n<li>Docker官方推荐将当前用户加入 Docker 用户组</li>\n<li>执行完成之后，还需要退出系统（命令 exit ），再重新登录一次，这样才能让修改用户组的命令 usermod 生效</li>\n</ul>\n</li>\n<li><p>验证docker是否安装成功：<code>docker version</code>和<code>docker info</code></p>\n</li>\n</ul>\n</li>\n<li><p>docker使用</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730104038132.png\" alt=\"image-20230730104038132\"></p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730104052158.png\" alt=\"image-20230730104052158\"></p>\n<ul>\n<li><p>查看镜像/容器：</p>\n<ul>\n<li><p>查看运行的容器：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker ps</code></pre>\n\n<ul>\n<li>CONTAINER ID: 容器 ID；IMAGE: 使用的镜像；COMMAND**:** 启动容器时运行的命令；CREATED: 容器的创建时间</li>\n<li>STATUS: 容器状态，主要有7种状态：created（已创建）、restarting（重启中）、running 或 Up（运行中）、removing（迁移中）、paused（暂停）、exited（停止）、dead（死亡）</li>\n<li>PORTS: 容器的端口信息和使用的连接类型（tcp\\udp）；NAMES: 自动分配的容器名称</li>\n</ul>\n</li>\n<li><p>查看运行完毕的容器：<code>docker ps -a</code></p>\n</li>\n<li><p>查看已存储镜像的信息：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker images</code></pre>\n\n<ul>\n<li>REPOSITORY：表示镜像的仓库源，通过REPOSITORY:TAG来定义不同的镜像；TAG<strong>：</strong>镜像的标签，同一仓库可以有多个TAG，代表这个仓库的不同个版本；IMAGE ID：镜像ID；CREATED<strong>：</strong>镜像创建时间；SIZE<strong>：</strong>镜像大小</li>\n</ul>\n</li>\n<li><p>可以通过<code>docker logs 容器ID</code>来查看容器内的标准输出</p>\n</li>\n<li><p>查找镜像：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker search 镜像名</code></pre>\n\n<ul>\n<li>NAME: 镜像仓库源的名称；DESCRIPTION：镜像的描述；OFFICIAL: 是否 docker 官方发布；stars: 类似 Github 里面的 star；AUTOMATED: 自动构建</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拉取镜像：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker pull busybox</code></pre>\n\n<ul>\n<li>获取一个打包了的busybox应用的镜像，里面固化了busybox程序和它所需的完整运行环境</li>\n<li>镜像的完整名字由两个部分组成：<code>名字:标签</code>，标签（tag）是为了区分不同版本的应用而做的额外标记，可以是任意字符串，默认标签是<code>latest</code></li>\n</ul>\n</li>\n<li><p>启动镜像：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docer run+参数+镜像名&#x2F;ID+运行命令</code></pre>\n\n<p>（通过</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker run --help</code></pre>\n\n<p>来查看帮助信息）</p>\n<ul>\n<li><p>启动并执行echo输出字符串：<code>docker run busybox echo hello world</code>，提取镜像里的各种信息，运用namespace、cgroup、chroot技术创造出隔离环境，然后运行busybox的echo命令，输出字符串</p>\n</li>\n<li><p>启动镜像，离开当前操作系统，进入新系统：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker run -it arm64v8&#x2F;ubuntu &#x2F;bin&#x2F;bash</code></pre>\n\n<p>，</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">it</code></pre>\n\n<p>表示开启一个交互式操作的Shell，可以直接进入容器内部，通过exit命令或者Crtl+D退出</p>\n<ul>\n<li>t: 在新容器内指定一个伪终端或终端</li>\n<li>i: 允许对容器内的标准输入 (STDIN) 进行交互</li>\n</ul>\n</li>\n<li><p>后台运行：<code>docker run -d --name red_srv redis</code>，<code>d</code>表示让容器在后台运行，用于启动服务器程序；<code>-name</code>可以为容器起一个名字，否则会分配一个随机的名字</p>\n</li>\n<li><p>可以通过IMAGE ID进行短路操作，仅使用前几位就可定位到对应容器</p>\n</li>\n<li><p><code>docker run -d --rm redis</code>：<code>-rm</code>参数告诉Docker不保存容器，再运行完毕后就自动清除</p>\n</li>\n</ul>\n</li>\n<li><p>删除镜像：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker rmi redis</code></pre>\n\n<ul>\n<li><code>docker rm ID</code>：只会删除容器，不会删除镜像</li>\n</ul>\n</li>\n<li><p>停止容器：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker stop CONTAINER ID</code></pre>\n\n<ul>\n<li>只能通过<code>docker ps -a</code>查看已停止运行的容器，通过<code>docker start ID</code>再次启动运行</li>\n</ul>\n</li>\n<li><p>运行的容器中在执行另一程序：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">docker exec -it red_srv sh</code></pre>\n\n<p>，登陆进入Redis容器，方便查看服务的运行状态和日志。效果同docker run，但因为容器已存在，所以不会创建新容器</p>\n<ul>\n<li>进入容器：通过<code>docker exec -it 容器ID /bin/bash</code>来进入后台运行的容器，并且推出时不会导致容器终止，<code>docker attach 容器ID</code>会在退出时终止容器</li>\n</ul>\n</li>\n<li><p>导出和导入容器</p>\n<ul>\n<li>导出本地某个容器：<code>docker export 容器ID &gt; ubuntu.tar</code></li>\n<li>从容器快照文件中再导入为镜像：<code>cat docker/ubuntu.tar | docker import - test/ubuntu:v1</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>创建容器</p>\n<ul>\n<li><p>Dockerfile：一个纯文本，里面记录了一些列的构建指令，比如选择基础镜像、拷贝文件、执行脚本等，每个指令都会生成一个Layer，而Docker顺序执行这个文件的所有步骤，最终会创建出一个新的镜像出来</p>\n</li>\n<li><p>Dockerfile内部指令（不区分大小写，一条指令生成一个镜像）</p>\n<ul>\n<li><code>FROM</code>：所有Dockerfile都要从它开始，表示选择构建使用的基础镜像，相当于打地基，如果关注镜像的安全和大小，一般选择Alpine；如果关注运行的稳定性，则可以选择Ubuntu、CentOS、Debian</li>\n<li><code>CMD</code>：制定docker run启动容器时默认运行的命令</li>\n<li><code>COPY</code>：需要把开发测试产生的一一些源码、配置等文件打包进镜像里，拷贝的源文件必须是构建上下文路径，不能随意指定文件，也就是说，必须把这些文件放在一个专门的目录，然后再docker build里指定构建上下文到这个目录才行</li>\n<li><code>RUN</code>：执行任意的Shell命令，实现任意的镜像构建步骤，所有RUN指令会在每行的末尾使用续行符<code>\\\\</code>，命令之间也会用<code>&amp;&amp;</code>来连接，这样保证在逻辑上是一行（可以把这些Shell集中到一个脚本文件，然后用COPY命令拷贝进去在用RUN来执行）</li>\n<li><code>ARG</code>：用于创建变量，创建的变量只在镜像构建过程中可见，容器运行时不可见</li>\n<li><code>ENV</code>：用于创建变量，创建的变量不仅能够在构建镜像的过程中使用，在容器运行时也能够以环境变量的形式被应用程序使用</li>\n<li><code>EXPOSE</code>：用来声明容器对外服务的端口号，对现在基于Node.js、Tomcat、Nginx、Go等开发的微服务系统来说非常有用</li>\n</ul>\n</li>\n<li><p>构建镜像：<code>docker build -f Dockerfile.busybox .</code>，-f指定Dockerfile文件名，后面必须跟一个文件路径，叫做构建上下文（build‘s context），这里只是一个简单的点号，表示当前路径</p>\n<ul>\n<li><p>新的镜像暂时没有名字（<code>&lt;none&gt;</code>），可以直接使用ID来查看或运行，可以通过<code>t</code>参数来指定镜像的标签（tag），名字需要符合规范，用:分割名字和标签</p>\n</li>\n<li><p>构建上下文：docker客户端只是把构建上下文目录打包上传，这样服务器才能获得本地的这些文件，就是指定了要打包进镜像的一些依赖文件</p>\n</li>\n<li><p>为了避免目录中某些不必要文件（例如 readme/.git/.svn 等）拷贝进镜像，可以在构建上下文目录里再建立一个 .dockerignore 文件，语法与 .gitignore 类似，排除那些不需要的文件</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ cat Dockerfile #每一指令都会在镜像上创建一个新的层，每一指令的前缀都必须是大写\nFROM    centos:6.7 #指定使用哪个镜像源\nMAINTAINER      Fisher &quot;fisher@sudops.com&quot;\n#RUN 指令告诉docker 在镜像内执行命令，安装了什么\nRUN     &#x2F;bin&#x2F;echo &#39;root:123456&#39; |chpasswd\nRUN     useradd runoob\nRUN     &#x2F;bin&#x2F;echo &#39;runoob:123456&#39; |chpasswd\nRUN     &#x2F;bin&#x2F;echo -e &quot;LANG&#x3D;\\\\&quot;en_US.UTF-8\\\\&quot;&quot; &gt;&#x2F;etc&#x2F;default&#x2F;local\nEXPOSE  22\nEXPOSE  80\nCMD     &#x2F;usr&#x2F;sbin&#x2F;sshd -D</code></pre></li>\n</ul>\n</li>\n<li><p>更新已有镜像并提交：-m提交的描述信息、-a镜像作者、e218edb10161容器ID、runoob/ubuntu:v2镜像名。可以使用dockr images来查看新镜像</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker commit -m&#x3D;&quot;has update&quot; -a&#x3D;&quot;runoob&quot; e218edb10161 runoob&#x2F;ubuntu:v2\nsha256:70bf1840fd7c0d2d8ef0a42a817eb29f854c1af8f7c59fc03ac7bdee9545aff8</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-实践-1\"><a href=\"#3-实践-1\" class=\"headerlink\" title=\"3.实践\"></a><strong>3.实践</strong></h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000019462392\">Docker容器引擎</a></li>\n</ul>\n","feature":true,"text":"1.markdown 框架 多级标题：#与后面文本有一个空格，标题行前后建议空行 Markdown HTML # Heading level 1 Heading level 1 ## Heading level 2 Heading level 2 ### Heading leve...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-markdown\"><span class=\"toc-text\">1.markdown</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\">Heading level 1</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\"><span class=\"toc-text\">Heading level 2</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\">Heading level 3</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\"><span class=\"toc-text\">Heading level 4</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\"><span class=\"toc-text\">Heading level 5</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\"><span class=\"toc-text\">Heading level 6</span></a></li></ol></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-mermaid\"><span class=\"toc-text\">2.mermaid</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Sequence-diagram\"><span class=\"toc-text\">Sequence diagram</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Latex\"><span class=\"toc-text\">3.Latex</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-Git\"><span class=\"toc-text\">4.Git</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Git%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.Git整体结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.常用操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">3.实践</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-Docker\"><span class=\"toc-text\">5.Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C-1\"><span class=\"toc-text\">2.常用操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%AE%9E%E8%B7%B5-1\"><span class=\"toc-text\">3.实践</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Internet","uid":"f00c07cb09e8c5144602456ae7f0f75a","slug":"Internet","date":"2023-08-02T14:26:24.000Z","updated":"2023-08-02T14:34:34.154Z","comments":true,"path":"api/articles/Internet.json","keywords":null,"cover":[],"text":"Internet1.网络层 IP 查看IP地址：ifconfig、ip addr scope：如果是global，则此张网卡是可以对外开放的，可以接受各个地方的包；对于lo来说事host，说明这张网卡仅仅可以供本机相互通信 lo全称是loopback，又称环回接口，往往会被分配到...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2023-07-30T02:35:00.000Z","updated":"2023-08-04T08:15:04.070Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"text":"JVM1.编译执行 如何实现跨平台：通过不同平台的JVM实现来将相同的一个Class文件翻译成适配不同机器的机器语言用于执行，即使打包成可还行文件仍需要JVM的支持 Java程序的执行过程 JAVA源代码编译成字节码；字节码校验并把JAVA程序通过类加载器加载到JVM内存中，在加...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"26 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}