{"title":"Docker","uid":"a48e6dda0c21e40880cba7e763278b04","slug":"Docker","date":"2023-04-20T12:35:42.000Z","updated":"2023-04-20T13:16:47.958Z","comments":true,"path":"api/articles/Docker.json","keywords":null,"cover":[],"content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h2><ol>\n<li><p>出现背景：在个人开发环境中，需要大量的虚拟机配置不同的项目环境；在公司内部开发环境中，环境配置不可复用，测试环境与开发环境不匹配，依赖升级需要手动操作；</p>\n<ul>\n<li>Docker的口号是“Build，Ship，and Run Any App，Anywhere”</li>\n<li>Java的口号是“Write Once,Run Anywhere”</li>\n</ul>\n</li>\n<li><p>Docker基本概念</p>\n<ul>\n<li><strong>引擎：</strong>创建和管理容器的工具，通过读取镜像来生成容器，并负责从仓库拉取镜像或提交镜像到仓库中；</li>\n<li><strong>镜像：</strong>类似于虚拟机镜像，一般由一个基本操作系统环境和多个应用程序打包而成，是创建容器的模板；<ul>\n<li>采用分层存储方式，每个镜像可依赖其他镜像进行构建，每一层的镜像可被多个镜像引用，通过共享镜像层，减少镜像仓库占用空间，对于用户而言，看到的是通过<code>UnionFS</code>（联合文件系统）把相关镜像层的目录“联合”到同一个挂载点呈现出来的一个整体</li>\n<li>在拉取镜像的时候，只会拉去缺少的层，在删除镜像的时候，只会删除没有被共享的层</li>\n</ul>\n</li>\n<li><strong>容器：</strong>可看作一个简易版的Linxu系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子；</li>\n<li><strong>仓库：</strong>集中存放镜像文件的场所，分为公共仓库（Docker Hub）和私有仓库，类似于Git</li>\n<li><strong>宿主机：</strong>运行引擎的操作系统所在服务器</li>\n</ul>\n</li>\n<li><p>Docker架构（<code>Docker daemon</code>）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230420204023618.png\" alt=\"image-20230420204023618\"></p>\n<ul>\n<li>命令行工具docker实际上是一个client，他会与Docker Engine里的后台服务<code>Docker daemon</code>通信，镜像存储在远端的Registry里，客户端不能直接访问镜像仓库</li>\n<li>Docker client可以通过build、pull、run等命令向<code>Docker daemon</code>发送请求，而<code>Docker daemon</code>则负责从远端拉去镜像、在本地存储镜像、从镜像生成容器、管理容器等功能</li>\n<li>容器化的应用：指应用程序不再直接和操作系统打交道，而是封装成镜像，再交给容器环境去运行。镜像就是静态的应用容器，容器就是动态的应用镜像</li>\n</ul>\n</li>\n<li><p>Docker隔离实现：是一种应用容器引擎，结合LXC和一些其他技术来实现应用级别容器引擎</p>\n<ul>\n<li>Linux提供了<code>Namespace</code>和<code>CGroup</code>技术实现环境隔离和资源控制，其中<code>Namespace</code>是Linux提供的一种内核级别环境隔离的方法，能使一个进程和该进程创建的子进程的运行空间都与Linux的超级父进程相隔离（但只是进程的隔离，物理资源还是进程共用的）；<code>CGroup</code>技术是用来控制一个进程组群可使用的资源（CPU、内存、磁盘IO等），来实现物理资源的隔离</li>\n<li><code>Linux Container：</code>将<code>Namespace</code>和<code>CGroup</code>相结合，就能构造一个用户空间独立且限定资源的对象，这样的对象称为容器，即<code>LInux Container</code>（Linux提供的容器化技术，简称LXC）。LXC仅为一种轻量级的容器化技术，它仅能对部分资源进行限制，无法做到诸如网络限制、磁盘空间占用限制等（0.7版本取出LXC使用libcontainer，1.11开始使用runC 和 containerd）</li>\n<li>其他技术<ul>\n<li><strong>Chroot：</strong>该技术能在container里构造完整的<code>Linux文件系统</code>；虽然不能直接访问宿主机里的文件，但一般容器都通过包括一个底层的操作系统镜像来弥补</li>\n<li><strong>Veth：</strong>该技术能够在主机上虚拟出一张网卡与container里的eth0网卡进行桥接，实现容器与主机、容器之间的<code>网络通信</code>；</li>\n<li><strong>UnionFS：</strong>联合文件系统，Docker利用该技术“Copy on Write”（写的时候复制一份副本，在副本上修改）的特点实现<code>容器的快速启动和极少的资源占用</code>，Docker常用的是<code>AUFS</code></li>\n<li><strong>Iptables/netfilter：</strong>通过这两个技术实现控制container<code>网络访问策略</code>；</li>\n<li><strong>TC：</strong>该技术主要用来做<code>流量隔离，限制带宽</code>；</li>\n<li><strong>Quota：</strong>该技术用来限制<code>磁盘读写空间的大小</code>；</li>\n<li><strong>Setrlimit：</strong>该技术用来限制container中打开的<code>进程数</code>，限制<code>打开的文件个数</code>等</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Docker与虚拟化：虚拟化是依靠一层Hypervisor（软件层）来将虚拟机的指令翻译成物理硬件或宿主机操作系统能识别的指令；而Docker容器里的进程是直接与内核交互的，依靠的Linux的LXC和Chroot等技术，无需中转，几乎没有性能损耗</p>\n<ul>\n<li><p>在启动一个容器时， Docker引擎实际上只是增加了一个可写层和构造了一个Linux容器，这两者都几乎不消耗系统资源，因此Docker容器能够做到秒级启动</p>\n</li>\n<li><p>为了操作系统镜像占用空间过大的情况，针对不同的场景分别构造了不同的操作系统镜像，包括一下几种：BusyBox（测试场景）、Alpine（生产环境常用）、Debian/Ubuntu、Centos/Fedora</p>\n</li>\n<li><p>持久化存储：由于都是在可写层里的文件副本进行操作，在容器关闭是，通过以下两种方法实现持久化存储的问题</p>\n<ul>\n<li><p>把宿主机文件系统里的目录映射到容器内的目录，如下图所示。如此一来，容器内在该目录里创建的所有文件，都存储到宿主机的对应目录中，在关闭容器后，宿主机的目录依然存在，再次启动容器时还能读取到之前创建的文件，因此实现了容器的文件持久化。当然同时要明白，如果是对镜像自带文件进行了修改，由于镜像是只读的，该修改操作无法在关闭容器时保存下来，除非在修改了文件后构建一个新的镜像</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230420203947403.png\" alt=\"image-20230420203947403\"></p>\n</li>\n<li><p>把多台宿主机的磁盘目录通过网络联合为共享存储，然后把共享存储中的特定目录映射给特定的容器，如下图所示。这样容器在重启时，还是能读取到关闭前创建的文件。生产环境中常用NFS作为共享存储方案</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230420204004002.png\" alt=\"image-20230420204004002\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>容器的内部机制</p>\n<ul>\n<li><p>文件</p>\n<ul>\n<li><code>docker cp+源路径+目标路径</code> 命令可以在容器和主机之间互相拷贝文件，适合简单的数据交换，其中目标路径需要用容器名/ID来指明是那个容器的路径，示例：<code>docker cp a.txt 062:/tmp</code></li>\n<li><code>docker run -v</code>命令可以让容器和主机共享本地目录，免去了拷贝操作，提升工作效率，示例：<code>docker run -d --rm -v /tmp:/tmp redis</code>，格式为<code>宿主机路径: 容器内路径</code>，把本机的/tmp路径挂载道容器里的/tmp目录，常用于不同环境运行相同文件</li>\n</ul>\n</li>\n<li><p>网络配置</p>\n<ul>\n<li>网络分类：<ul>\n<li>host网络模式让容器与主机共享网络栈，效率高但是容易导致端口冲突，命令为<code>docker run -d --rm --net=host nginx:alpine</code></li>\n<li>bridge网络模式实现了一个虚拟网桥，容器和主机都在一个私有网段内互联互通，默认使用此模式</li>\n</ul>\n</li>\n<li>docker有一个连接系统允许将多个容器连接在一起，共享连接信息，docker连接会创建一个父子关系，其中父容器可以看到子容器的信息<ul>\n<li>新建网络：<code>docker network create -d bridge test-net</code></li>\n<li>连接容器：<ul>\n<li>运行一个容器并连接到新建的 test-net 网络: <code>$ docker run -itd --name test1 --network test-net ubuntu /bin/bash</code></li>\n<li>打开新的终端，再运行一个容器并加入到 test-net 网络:<code>$ docker run -itd --name test2 --network test-net ubuntu /bin/bash</code></li>\n<li>test1和test2可以互相ping通，二者建立了互联关系</li>\n</ul>\n</li>\n<li>如果有多个容器，推荐使用Docker Compose</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>网络端口映射：<code>docker run -p</code>命令可以把主机的端口号映射到容器的内部端口号，解决了潜在的端口冲突</p>\n<ul>\n<li>-P：是容器内部端口随机映射到主机的端口，命令为<code>docker run -d -p 5000:5000 training/webapp python app.py</code></li>\n<li>-p：是容器内部端口绑定到指定的主机端口，还可以附加绑定网络地址，命令为<code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-常用操作\"><a href=\"#2-常用操作\" class=\"headerlink\" title=\"2.常用操作\"></a>2.常用操作</h2><ol>\n<li><p>安装docker服务</p>\n<ul>\n<li>安装docker：<code>sudo apt install -y docker.io</code></li>\n<li>启动docker服务：<code>sudo service docker start</code></li>\n<li>当前用户加入docker组：<code>sudo usermod -aG docker $&#123;USER&#125;</code><ul>\n<li>因为操作 Docker 必须要有 root 权限，而直接使用 root 用户不够安全</li>\n<li>Docker官方推荐将当前用户加入 Docker 用户组</li>\n<li>执行完成之后，还需要退出系统（命令 exit ），再重新登录一次，这样才能让修改用户组的命令 usermod 生效</li>\n</ul>\n</li>\n<li>验证docker是否安装成功：<code>docker version</code>和<code>docker info</code></li>\n</ul>\n</li>\n<li><p>docker 使用</p>\n<ul>\n<li>镜像操作命令<ul>\n<li>拉取仓库：<code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code></li>\n<li>列出本地已有镜像：<code>docker images</code></li>\n<li>删除不再使用的镜像：<code>docekr rmi</code></li>\n</ul>\n</li>\n<li>容器操作命令<ul>\n<li>启动镜像：<code>docker run</code><ul>\n<li><code>-it</code>：开启一个交互式操作的Shell</li>\n<li><code>-d</code>：让容器在后台运行</li>\n<li><code>--name</code>：为容器起一个名字</li>\n<li><code>--rm</code>：不保存容器，运行完自动清除</li>\n</ul>\n</li>\n<li>列出正在运行的镜像：<code>docker ps</code></li>\n<li>在容器内执行另一个程序：<code>docker exec</code></li>\n<li>强制停止容器：<code>docker stop</code></li>\n<li>再次启动已经停止的容器：<code>docker start</code></li>\n<li>彻底删除容器：<code>docekr rm</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>镜像制作</p>\n<ul>\n<li><p>通过正在运行的容器生成新镜像：通过<code>commit</code>命令，把正在运行的容器，叠加上可写层的修改内容，生成一个新镜像。这种方法简单，但是无法直观的设置环境变量、监听端口等内容，适合简单使用的场景</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230420204337854.png\" alt=\"image-20230420204337854\"></p>\n</li>\n<li><p>通过Dockerfile文件生成新镜像：Dockerfile是一个定义了镜像创建步骤的文件，Docker引擎通过build命令读取Dockerfile，按定义的步骤来一步步构造镜像。在研发和实施环境中，通过Dockerfile 创建容器是主流做法。下面是一个Dockerfile的例子</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230420204356207.png\" alt=\"image-20230420204356207\"></p>\n<ul>\n<li><code>docker build -f Dockerfile.busybox .</code>（-f后价Dockerfile文件名，后面跟一个文件路径（构建上下文））<ul>\n<li>新的镜像暂时没有名字（<code>&lt;none&gt;</code>），可以直接使用ID来查看或运行，可以通过<code>-t</code>参数来指定镜像的标签（tag），名字需要符合规范，用:分割名字和标签</li>\n<li>构建上下文：docker客户端只是把构建上下文目录打包上传，这样服务器才能获得本地的这些文件，就是指定了要打包进镜像的一些依赖文件</li>\n<li>为了避免目录中某些不必要文件（例如 readme/.git/.svn 等）拷贝进镜像，可以在构建上下文目录里再建立一个 <code>.dockerignore</code> 文件，语法与 .gitignore 类似，排除那些不需要的文件</li>\n</ul>\n</li>\n<li>更新已有镜像并提交：-m提交的描述信息、-a镜像作者、e218edb10161容器ID、runoob/ubuntu:v2镜像名。可以使用dockr images来查看新镜像，命令为<code>docker commit -m=&quot;has update&quot; -a=&quot;runoob&quot; e218edb10161 runoob/ubuntu:v2</code></li>\n</ul>\n</li>\n<li><p>Dockerfile内部指令</p>\n<ul>\n<li><code>FROM</code>：所有Dockerfile都要从它开始，表示选择构建使用的基础镜像，相当于打地基，如果关注镜像的安全和大小，一般选择Alpine；如果关注运行的稳定性，则可以选择Ubuntu、CentOS、Debian</li>\n<li><code>CMD</code>：制定docker run启动容器时默认运行的命令</li>\n<li><code>COPY</code>：需要把开发测试产生的一一些源码、配置等文件打包进镜像里，拷贝的源文件必须是构建上下文路径，不能随意指定文件，也就是说，必须把这些文件放在一个专门的目录，然后再docker build里指定构建上下文到这个目录才行</li>\n<li><code>RUN</code>：执行任意的Shell命令，实现任意的镜像构建步骤，所有RUN指令会在每行的末尾使用续行符<code>\\\\</code>，命令之间也会用<code>&amp;&amp;</code>来连接，这样保证在逻辑上是一行（可以把这些Shell集中到一个脚本文件，然后用COPY命令拷贝进去在用RUN来执行）</li>\n<li><code>ARG</code>：用于创建变量，创建的变量只在镜像构建过程中可见，容器运行时不可见</li>\n<li><code>ENV</code>：用于创建变量，创建的变量不仅能够在构建镜像的过程中使用，在容器运行时也能够以环境变量的形式被应用程序使用</li>\n<li><code>EXPOSE</code>：用来声明容器对外服务的端口号，对现在基于Node.js、Tomcat、Nginx、Go等开发的微服务系统来说非常有用</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","feature":true,"text":"Docker1.概念 出现背景：在个人开发环境中，需要大量的虚拟机配置不同的项目环境；在公司内部开发环境中，环境配置不可复用，测试环境与开发环境不匹配，依赖升级需要手动操作； Docker的口号是“Build，Ship，and Run Any App，Anywhere” Java...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Docker\"><span class=\"toc-text\">Docker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.常用操作</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Git","uid":"221a7ad001c03569112f684b2dfdc120","slug":"Git","date":"2023-04-20T12:35:53.000Z","updated":"2023-04-20T13:16:41.898Z","comments":true,"path":"api/articles/Git.json","keywords":null,"cover":[],"text":"Git1.Git整体结构 工作区：电脑里能看到的目录 暂存区：.git目录下的index文件（.git/index），也叫做索引（index） 本地版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库 远程仓库 Git文件状态 版本 HEAD：指向master...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Java并发","uid":"75ca176d6b382373bec123f05862c849","slug":"Java并发","date":"2023-04-13T23:56:43.000Z","updated":"2023-04-20T13:16:53.771Z","comments":true,"path":"api/articles/Java并发.json","keywords":null,"cover":[],"text":"Java并发1.线程 线程 线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING 线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N） Java使用用户线程模型，上层JVM...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"language","slug":"language","count":2,"path":"api/tags/language.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}