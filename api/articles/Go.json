{"title":"Go","uid":"8aa9bb0438939ce2b4a00f1a6ea1e9e5","slug":"Go","date":"2023-05-04T04:42:41.000Z","updated":"2023-05-04T06:50:29.873Z","comments":true,"path":"api/articles/Go.json","keywords":null,"cover":[],"content":"<h1 id=\"GO\"><a href=\"#GO\" class=\"headerlink\" title=\"GO\"></a>GO</h1><h2 id=\"1-运行前准备\"><a href=\"#1-运行前准备\" class=\"headerlink\" title=\"1.运行前准备\"></a>1.运行前准备</h2><ol>\n<li><p>源码结构</p>\n<ul>\n<li>GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径</li>\n<li>GOPATH：若干工作区目录的路径。是我们自己定义的工作空间（workspace），go源码文件（.go）、归档文件（.a）、可执行文件都存在此处<ul>\n<li>go源码文件需要保存在GOPATH包含的某个工作区（目录）中的src目录下的某个代码包（目录）中，可执行文件放在该工作区的bin子目录，归档文件（.a）放在pkg子目录</li>\n<li>安装某个代码包而产生的归档文件是与这个代码包同名的</li>\n<li>构建和安装Go程序的过程：构建使用命令go build，安装使用go install。构建和安装代码的时候都会执行编译、打包等操作，并且这些操作生成的任何文件都会先保存到某个临时的目录中</li>\n</ul>\n</li>\n<li>GOBIN：GO 程序生成的可执行文件（executable file）的路径<ul>\n<li>添加<code>export PATH=$PATH:/usr/local/go/bin</code>到<code>~/.bash_profile </code>或 <code>/etc/profile</code>，然后执行<code>source ~/.bash_profile</code>或<code>source /etc/profile</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>源码文件</p>\n<ul>\n<li><p>命令源码文件：可以使用 go run 命令启动，是程序的运行入口，每个可独立运行的程序必须拥有的。可以通过构建或安装，生成与其对应的可执行入口，后者一般会与该命令源码文件的直接父目录同名。例如存在demo.go文件中的hello world示例程序，可以通过<code>go run demo.go</code>命令来执行，在标准输出（屏幕）上看到hello world。（模块化编程时，也只有一个命令源码文件）</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n\t&quot;flag&quot;&#x2F;&#x2F;专门用于接收和解析命令参数\n  &quot;fmt&quot;\n)\nvar name string\nfunc init() &#123;\n  &#x2F;&#x2F;四个参数：存命令参数值的地址、命令参数的名称、默认值、该命令参数的简短说明\n  flag.StringVar(&amp;name,&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)\n  &#x2F;&#x2F;var name &#x3D; flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)\n&#125;\nfunc main() &#123;\n  &#x2F;&#x2F;对该函数的调用必须在所有命令参数存储载体的声明（这里是对变量name的声明）和\n  &#x2F;&#x2F;设置（这里是在[2]处对flag.StringVar函数的调用）之后\n  flag.Parse()&#x2F;&#x2F;用于真正解析命令参数，并把它们的值赋给相应的变量\n  fmt.Printf(&quot;Hello, %s!\\\\n&quot;, name)\n&#125;\n\n&#x2F;&#x2F;查看参数的使用说明\n$ go run demo.go -name-&quot;Robert&quot;\n#输出\nHello,Robert!\n#查看命令源码文件的参数说明\n$ go build demo.go\n$ .&#x2F;demo --help\n#go run命令构建上述命令源码文件时临时生成的可执行文件的完整路径,即go build demo.go\nUsage of .&#x2F;demo:\n -name string\n    The greeting object. (default &quot;everyone&quot;)</code></pre></li>\n<li><p>库源码文件：库源码文件是不能被直接运行的源码文件，仅用于存放程序实体，这些程序实体可以被其他代码使用。（程序实体是变量、常量、函数、结构体和接口的统称，总是先声明再使用，程序实体的名字统称为标识符）这里的“其他代码”可以与被使用的程序实体在同一源码文件内，也可以在其他源码文件，甚至其他代码包中</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;demo.go&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npackage main\n\nimport (\n  &quot;flag&quot;\n)\n\nvar name string\n\nfunc init() &#123;\n  flag.StringVar(&amp;name, &quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)\n&#125;\n\nfunc main() &#123;\n  flag.Parse()\n  hello(name)&#x2F;&#x2F;变化位置\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;demo_lib.go&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npackage main\n\nimport &quot;fmt&quot;\n\nfunc hello(name string) &#123;\n  fmt.Printf(&quot;Hello, %s!\\\\n&quot;, name)\n&#125;</code></pre></li>\n<li><p>什么样的程序实体才可以被当前包外的代码引用</p>\n<ul>\n<li>包级私有：首字母小写的程序实体（如函数名）</li>\n<li>公开：首字母大写的程序实体（如函数名）</li>\n<li>模块级私有：通过创建internal代码包（目录名为internal）让一些程序实体仅仅能被当前模块中的其他代码引用。具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个internal包。对于其他代码包，导入该internal包都是非法的，无法通过编译</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>补充</p>\n</li>\n</ol>\n<h2 id=\"2-基础语法\"><a href=\"#2-基础语法\" class=\"headerlink\" title=\"2.基础语法\"></a>2.基础语法</h2><ol>\n<li><p>程序实体</p>\n<ul>\n<li><p>关键字</p>\n<table>\n<thead>\n<tr>\n<th>结构</th>\n<th>函数</th>\n<th>特殊</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>if</td>\n<td>import</td>\n<td>go</td>\n</tr>\n<tr>\n<td>else</td>\n<td>package</td>\n<td>select</td>\n</tr>\n<tr>\n<td>for</td>\n<td>func</td>\n<td>chan</td>\n</tr>\n<tr>\n<td>switch</td>\n<td>return</td>\n<td>range</td>\n</tr>\n<tr>\n<td>case</td>\n<td>struct</td>\n<td>map</td>\n</tr>\n<tr>\n<td>break</td>\n<td>interface</td>\n<td>const（标量）</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>type（别名）</td>\n<td>defer</td>\n</tr>\n<tr>\n<td>default</td>\n<td>var</td>\n<td>goto</td>\n</tr>\n<tr>\n<td>fallthrough</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;在声明name时，还为它赋了值，而没有显示指定name的类型，利用Go语言自身的类型推断，省去了声明\nvar name &#x3D; flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)\n&#x2F;&#x2F;短变量声明，类型推断加上语法糖，只能在函数体内部使用，用来声明一些临时的变量\nname :&#x3D; flag.String(&quot;name&quot;, &quot;everyone&quot;, &quot;The greeting object.&quot;)\nconst LENGTH int &#x3D; 10\n\nfor i :&#x3D; range numbers1 &#123;\n\tif i &#x3D;&#x3D; 3 &#123;\n\t\tnumbers1[i] |&#x3D; i\n\t&#125;\n&#125;\n\ntype struct_variable_type struct &#123;\n   member definition\n   member definition\n   ...\n   member definition\n&#125;</code></pre></li>\n<li><p>预定义标识符</p>\n<table>\n<thead>\n<tr>\n<th>整数</th>\n<th>无符号整数</th>\n<th>小数</th>\n<th>其它数</th>\n<th>函数</th>\n<th>特性</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>int</td>\n<td>uint</td>\n<td>float32</td>\n<td>uintptr</td>\n<td>append</td>\n<td>new</td>\n</tr>\n<tr>\n<td>int8</td>\n<td>uint8</td>\n<td>float64</td>\n<td>bool</td>\n<td>copy</td>\n<td>make</td>\n</tr>\n<tr>\n<td>int16</td>\n<td>uint16</td>\n<td>complex64</td>\n<td>true</td>\n<td>cap</td>\n<td>close</td>\n</tr>\n<tr>\n<td>int32</td>\n<td>uint32</td>\n<td>complex128</td>\n<td>false</td>\n<td>len</td>\n<td>iota</td>\n</tr>\n<tr>\n<td>int64</td>\n<td>uint64</td>\n<td>complex</td>\n<td>string</td>\n<td>print</td>\n<td>panic</td>\n</tr>\n<tr>\n<td></td>\n<td>byte</td>\n<td>real / imag</td>\n<td>nil</td>\n<td>println</td>\n<td>recover</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>内置函数</p>\n<ul>\n<li><code>func append(slice []Type, elems ...Type) []type</code>：在切片变量的后面追加新的数据，然后返回新的切片变量，可用使用slice接收</li>\n<li> <code>func copy(dst, src [] Type) int</code>：把slice源的数据复制到目的切片中，目的slice填满后舍弃超出的部分</li>\n<li><code>func delete(m map[Type]Type1, key Type)</code>：delete函数用于删除map中对应key的键值对，如果map中不存在该key，则什么也不做</li>\n<li><code>func new(Type) *Type</code>：用来创建某一个类型的指针型对象，返回值是一个指向新分配的type类型的零值的指针<ul>\n<li>使用new创建chan类型的指针对象，在使用之前仍然需要使用make函数来初始化chan的容量</li>\n<li>new函数创建对象与直接使用struct{}创建的对象的区别是，前者为指向对象的一个指针，后者创建的是对象引用本身</li>\n</ul>\n</li>\n<li><code>func make(t Type, size ...IntegerType) Type</code>：只能用于chan，map和切片三种类型的创建，返回值就是对象本身，这三类数据结构本身就是引用类型，必须要初始化</li>\n</ul>\n</li>\n<li><p>重声明：允许在使用短变量声明时不用理会被赋值的多个变量中是否包含旧变量</p>\n<ul>\n<li><p>由于变量的类型在其初始化时就已经确定了，所以对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误</p>\n</li>\n<li><p>变量的重声明只可能发生在某一个代码块中。如果与当前的变量重名的是外层代码块中的变量，那么就是另外一种含义了</p>\n</li>\n<li><p>变量的重声明只有在使用短变量声明时才会发生，否则也无法通过编译。如果要在此处声明全新的变量，那么就应该使用包含关键字var的声明语句，但是这时就不能与同一个代码块中的任何变量有重名了</p>\n</li>\n<li><p>被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量。这时我们才可以说对其中的旧变量进行了重声明</p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var err error\n&#x2F;&#x2F; 这里对err进行了重声明\nn, err :&#x3D; io.WriteString(os.Stdout, &quot;Hello, everyone!\\\\n&quot;)</code></pre></li>\n</ul>\n</li>\n<li><p>类型</p>\n<ul>\n<li><p>类型断言：表达式x.(T)，x代表要判断类型的值，必须是接口类型</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">var container &#x3D; []string&#123;&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;&#125;\ncontainer :&#x3D; map[int]string&#123;0: &quot;zero&quot;, 1: &quot;one&quot;, 2: &quot;two&quot;&#125;\n\n&#x2F;&#x2F;interface&#123;&#125;(container)用来把container变量的值转换为空接口值，\n&#x2F;&#x2F;interface&#123;&#125;代表空接口，任何类型都是它的实现类型，&#123;&#125;要么是空代码块，要么表示不包含任何内容的数据结构，即空的接口类型\n&#x2F;&#x2F;用于判断前者的类型是否为切片类型[]string的.([]string)\n&#x2F;&#x2F;ok是布尔类型，代表类型判断的结果，true或false。如果是true，那么被判断的值将会被自动转换为[]string类型的值，\n&#x2F;&#x2F;并赋给变量value，否则value将被赋予nil（即“空”）。\nvalue, ok :&#x3D; interface&#123;&#125;(container).([]string)</code></pre></li>\n<li><p>类型转换：语法形式是T(x)，注意事项如下：可表示范围相同就可以，可表示范围变窄时则截断高位</p>\n<ul>\n<li>整数值转换成string类型时，如果是无效的Unicode代码点，则结果是”�”（Unicode标准中定义的Replacement Character，用于替换未知的字符）组成的字符串</li>\n<li>一个值在从string类型向[]byte类型转换时代表着以 UTF-8 编码的字符串会被拆分成零散、独立的字节</li>\n<li>一个值在从string类型向[]rune类型转换时代表着字符串会被拆分成一个个 Unicode 字符</li>\n</ul>\n</li>\n<li><p>别名类型：type MyString = string，byte是uint8的别名类型，而rune是int32的别名类型</p>\n</li>\n<li><p>类型再定义：type MyString2 string，MyString2和string就是两个不同的类型了。这里的MyString2是一个新的类型，不同于其他任何类型。把string类型再定义成了另外一个类型MyString2</p>\n</li>\n<li><p>潜在类型：某个类型在本质上是哪个类型，潜在类型相同的不同类型的值之间是可以相互进行类型转换的。但这种说法对集合类的类型却不合法</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>容器</p>\n<ul>\n<li><p>数组&amp;切片：切片是引用类型，而数组是值类型</p>\n<ul>\n<li>array：长度是固定的，长度是类型的一部分，不同长度是两个不同的数组类型。数组是切片的底层结构，属于值类型，同属值类型的游基础数据结构以及结构体类型。</li>\n<li>slice：是可变长度的，切片的长度可以自动地随元素数量的增长而增长，但不会减小。切片是对数组的封装，可以看作是对数组的某个连续片段的引用（其他引用类型：字典、通道、函数）</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n  &#x2F;&#x2F; 用make声明两个不同切片\n  s1 :&#x3D; make([]int, 5)&#x2F;&#x2F;如果不指明其容量，那么它就会和长度一致\n  fmt.Printf(&quot;The length of s1: %d\\\\n&quot;, len(s1))&#x2F;&#x2F;5\n  fmt.Printf(&quot;The capacity of s1: %d\\\\n&quot;, cap(s1))&#x2F;&#x2F;5\n  fmt.Printf(&quot;The value of s1: %d\\\\n&quot;, s1)&#x2F;&#x2F;[0 0 0 0 0]\n  s2 :&#x3D; make([]int, 5, 8)&#x2F;&#x2F;切片的容量实际上代表了它的底层数组的长度，这里是8，但是只能看到5\n  fmt.Printf(&quot;The length of s2: %d\\\\n&quot;, len(s2))&#x2F;&#x2F;5\n  fmt.Printf(&quot;The capacity of s2: %d\\\\n&quot;, cap(s2))&#x2F;&#x2F;8\n  fmt.Printf(&quot;The value of s2: %d\\\\n&quot;, s2)&#x2F;&#x2F;[0 0 0 0 0]\n\t&#x2F;&#x2F;切片的容量可以看作是透过这个窗口最多可以看到的底层数组（即s3）中元素的个数，而且底层数组\n\t&#x2F;&#x2F;不变的情况下，可以向右扩展，直至底层数组的末尾\n\ts3 :&#x3D; []int&#123;1, 2, 3, 4, 5, 6, 7, 8&#125;\n\ts4 :&#x3D; s3[3:6]&#x2F;&#x2F;[3:6)\n\tfmt.Printf(&quot;The length of s4: %d\\\\n&quot;, len(s4))&#x2F;&#x2F;3\n\tfmt.Printf(&quot;The capacity of s4: %d\\\\n&quot;, cap(s4))&#x2F;&#x2F;5\n\tfmt.Printf(&quot;The value of s4: %d\\\\n&quot;, s4)&#x2F;&#x2F;[4 5 6]\n\tfmt.Println()\n\t&#x2F;&#x2F;把切片的窗口向右扩展到最大的方法\n\ts5 :&#x3D; s4[:cap(s4)]&#x2F;&#x2F;[4 5 6 7 8]\n&#125;</code></pre></li>\n<li><p>链表</p>\n<ul>\n<li><p>list包含的方法中，用于插入新元素的方法都只接受interface{ }类型的值，这些方法在内部会使用Element值，包装接受到的新元素。可以避免直接使用我们自己生成的元素，主要原因是避免链表的内部关联找到破坏</p>\n</li>\n<li><p>开箱即用：经过语句<code>var l list.List</code>声明的变量l可以直接使用，因为有延迟初始化的机制（把初始化操作延后，分散初始化操作带来的计算量和存储空间的消耗），常用方法有以下几种：</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;求长度\nfunc (l *List) Len() int &#123; return l.len &#125;\n&#x2F;&#x2F;移除元素\nfunc (l *List) Remove(e *Element) any &#123;&#125;\n&#x2F;&#x2F; 在最前&#x2F;后端插入新元素\nfunc (l *List) PushFront(v any) *Element &#123;&#125;\nfunc (l *List) PushBack(v any) *Element &#123;&#125;\n&#x2F;&#x2F;在元素之前&#x2F;后插入新元素\nfunc (l *List) InsertBefore(v any, mark *Element) *Element &#123;&#125;\nfunc (l *List) InsertAfter(v any, mark *Element) *Element &#123;&#125;\n&#x2F;&#x2F;将元素移到链表的最前&#x2F;后面\nfunc (l *List) MoveToFront(e *Element) &#123;&#125;\nfunc (l *List) MoveToBack(e *Element) &#123;&#125;\n&#x2F;&#x2F;将元素移到另一元素的前&#x2F;后面\nfunc (l *List) MoveBefore(e, mark *Element) &#123;&#125;\nfunc (l *List) MoveAfter(e, mark *Element) &#123;&#125;\n&#x2F;&#x2F;在链表后&#x2F;前插入另一链表的副本\nfunc (l *List) PushBackList(other *List) &#123;&#125;\nfunc (l *List) PushFrontList(other *List) &#123;&#125;</code></pre></li>\n<li><p>Ring和List的区别：其实List在内部就是一个循环链表。它的根元素永远不会持有任何实际的元素值，而该元素的存在就是为了连接这个循环链表的首尾两端，主要区别如下</p>\n<ul>\n<li>在创建并初始化一个Ring值的时候，可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做（也没有必要这样做）。循环链表一旦被创建，其长度是不可变的</li>\n<li>仅通过<code>var r ring.Ring</code>语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表</li>\n<li>Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>字典（map）</p>\n<ul>\n<li>键不可以是函数、字典、切片类型（需要能使用操作符==和!=），值可以是任何类型。map中不存储键的值，而是使用其hash值代表<ul>\n<li>如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型，否则在程序运行过程中会引发 panic</li>\n<li>如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典类型或切片类型</li>\n<li>如果键的类型是结构体类型，那么还要保证其中字段的类型的合法性</li>\n</ul>\n</li>\n<li>注意事项<ul>\n<li>优先考虑哪些类型作为字典的键类型：求哈希和判等操作的速度越快，越适合，优先使用数值和指针类型（因为求hash值的速度与类型的宽度成正比）</li>\n<li>在值为nil的字典上执行读/写操作：由于字典是引用类型，所以当仅声明而不初始化一个字典类型的变量的时候，它的值会是nil，除了对nil的字典添加键值对操作外，其它操作都不会跑出panic</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>程序结构</p>\n<ul>\n<li><p>函数</p>\n<ul>\n<li><p>定义方式：<code>func function_name( [parameter list] ) [return_types] &#123;...&#125;</code></p>\n<ul>\n<li><p>参数是数组并且在函数内更改了参数：原数组不会改变，所有传给函数的参数值都会被复制，函数在其内部使用的并不是参数值的原值，而是他的副本（数值）</p>\n</li>\n<li><p>参数是切片并且在函数内更改了参数：原切片会改变，对于切片、字典、通道，只会拷贝他们本身，并不会拷贝他们引用的底层数据（引用）</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func modifyComplexArray(a [3][]string) [3][]string &#123;\n\ta[1][1] &#x3D; &quot;s&quot;&#x2F;&#x2F;a和s都改变，因为是引用类型的内部\n\ta[2] &#x3D; []string&#123;&quot;o&quot;, &quot;p&quot;, &quot;q&quot;&#125;&#x2F;&#x2F;只会改变a，s不变，因为改变的是数组\n\treturn a\n&#125;</code></pre></li>\n<li><p>高阶函数：传入参数或返回参数</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">type operate func(x,y int) int\nfunc calculate(x int ,y int, op operate)(int ,error)&#123;\n  if op &#x3D;&#x3D; nil&#123;&#x2F;&#x2F;卫述语句：检查先决条件的合法性，如果未通过立即终止当前代码执行的语句\n    return 0,errors.New(&quot;invalid operation&quot;)\n  &#125;\n  return op(x, y), nil\n&#125;\n\nfunc main() &#123;\n  x, y &#x3D; 56, 78\n  op :&#x3D; func(x, y int) int&#123;\n    return x + y\n  &#125;\n  result, err &#x3D; calculate(x, y, op)\n&#125;</code></pre></li>\n<li><p>闭包：内部逻辑并不完整，有一部分逻辑需要外来标识符参与完成，而此标识在函数定义时是未知的。表面上是延迟实现部分逻辑，实际上是在动态地生成那部分程序逻辑，类似于模版方法</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;genCalculator就是高阶函数\nfunc genCalculator(op operate) calculateFunc &#123;\n  &#x2F;&#x2F;匿名的calculateFunc类型的闭包函数，内部需要op来实现，在调用时才知道是什么\n  return func(x int, y int) (int, error) &#123;\n    if op &#x3D;&#x3D; nil &#123;\n      return 0, errors.New(&quot;invalid operation&quot;)\n    &#125;\n    return op(x, y), nil\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>结构体</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; AnimalCategory 代表动物分类学中的基本分类法。\ntype AnimalCategory struct &#123;\n  kingdom string &#x2F;&#x2F; 界。\n  phylum string &#x2F;&#x2F; 门。\n  class  string &#x2F;&#x2F; 纲。\n  order  string &#x2F;&#x2F; 目。\n  family string &#x2F;&#x2F; 科。\n  genus  string &#x2F;&#x2F; 属。\n  species string &#x2F;&#x2F; 种。\n&#125;\n&#x2F;&#x2F;嵌入字段\ntype Animal struct &#123;\n  scientificName string &#x2F;&#x2F; 学名。\n  AnimalCategory    &#x2F;&#x2F; 动物基本分类。\n&#125;\n&#x2F;&#x2F;方法名为String，接受者声明为AnimalCategory类型的ac，以在其中引用到当前值的任何一个字段，或者调用\n&#x2F;&#x2F;到当前值的任何一个方法（也包括String方法自己）,相当于java的toString\nfunc (ac AnimalCategory) String() string &#123;\n  return fmt.Sprintf(&quot;%s%s%s%s%s%s%s&quot;,\n    ac.kingdom, ac.phylum, ac.class, ac.order,\n    ac.family, ac.genus, ac.species)\n&#125;\nfunc (a Animal) Category() string &#123;\n  return a.AnimalCategory.String()\n&#125;</code></pre></li>\n<li><p>接口</p>\n<ul>\n<li>无侵入式的接口实现方法：只要实现接口中的所有方法（方法签名一致+方法名一样）就一定是这个接口的实现类型（Duck typing）</li>\n<li>为接口变量赋值：当接口被赋值时，接口会获得动态值和动态类型（原来只具有静态类型），一起被存储在一个专用的数据结构中，叫做iface。iface实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用它们的途径</li>\n<li>接口之间的组合：同名的方法会产生冲突，无法通过编译，推荐使用体量较小的接口</li>\n</ul>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n    &quot;fmt&quot;\n)\n\ntype Phone interface &#123;\n    call()\n&#125;\n\ntype NokiaPhone struct &#123;\n&#125;\n\nfunc (nokiaPhone NokiaPhone) call() &#123;\n    fmt.Println(&quot;I am Nokia, I can call you!&quot;)\n&#125;\n\ntype IPhone struct &#123;\n&#125;\n\nfunc (iPhone IPhone) call() &#123;\n    fmt.Println(&quot;I am iPhone, I can call you!&quot;)\n&#125;\n\nfunc main() &#123;\n    var phone Phone\n\n    phone &#x3D; new(NokiaPhone)\n    phone.call()\n\n    phone &#x3D; new(IPhone)\n    phone.call()\n\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-进阶语法\"><a href=\"#3-进阶语法\" class=\"headerlink\" title=\"3.进阶语法\"></a>3.进阶语法</h2><ol>\n<li><p>多线程（go、chan、select）</p>\n<ul>\n<li><p>chan</p>\n<ul>\n<li><p>Go语言自带的唯一可以满足并发安全性的类型，示例如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n  &#x2F;&#x2F;chan 代表通道类型的关键字，int代表该通道类型的元素类型，3为通道容量，即通道可以缓存多少了元素值\n  &#x2F;&#x2F;通道长度为0时，称为非缓冲通道，也就是不带缓冲的通道。通道相当于先进先出的队列\n  ch1 :&#x3D; make(chan int, 3)\n  ch1 &lt;- 2&#x2F;&#x2F;接受和发送都需要&lt;-，形象的表示了元素值的传输方向\n  ch1 &lt;- 1\n  ch1 &lt;- 3\n  elem1 :&#x3D; &lt;-ch1\n  fmt.Printf(&quot;The first element received from channel ch1: %v\\\\n&quot;,elem1)&#x2F;&#x2F;2\n&#125;</code></pre></li>\n<li><p>通道的特点</p>\n<ul>\n<li>对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的</li>\n<li>发送操作和接收操作中对元素值的处理都是不可分割的，并且进通道和出通道的都是副本</li>\n<li>发送操作在完全完成之前会被阻塞。接收操作也是如此</li>\n</ul>\n</li>\n<li><p>注意事项</p>\n<ul>\n<li>针对非缓冲通道，无论是发送还是接受操作，一开始执行就会被阻塞，直到配对的操作也开始执行，才会继续传递。由此可见，非缓冲通道是在用同步的方式传递数据。也就是说，只有收发双方对接上了，数据才会被传递</li>\n<li>对于值为nil的通道，不论它的具体类型是什么，对它的发送操作和接收操作都会永久地处于阻塞状态。由于通道类型是引用类型，所以它的零值就是nil，所以不要忘记初始化通道</li>\n<li>对于一个已初始化，但并未关闭的通道来说，收发操作一定不会引发 panic。但是通道一旦关闭，再对它进行发送操作，就会引发 panic。另外，如果我们试图关闭一个已经关闭了的通道，也会引发 panic</li>\n<li>当我们把接收表达式的结果同时赋给两个变量时，第二个变量的类型就是一定bool类型。它的值如果为false就说明通道已经关闭，并且再没有元素值可取了。如果通道关闭时，里面还有元素值未被取出，那么接收表达式的第一个结果，仍会是通道中的某一个元素值，而第二个结果值一定会是true。因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的</li>\n</ul>\n</li>\n<li><p>单向通道：只能发不能收，或者只能收不能发的通道，<code>var uselessChan = make(chan&lt;- int, 1)</code>，紧挨在关键字chan右边的那个&lt;-，这表示了这个通道是单向的，并且只能发而不能收；类似的，如果这个操作符紧挨在chan的左边，那么就说明该通道只能收不能发，应用主要是约束代码行为（一般用在接口类型声明中的方法定义上，可以传入双向通道，会自动转换为单向）</p>\n</li>\n</ul>\n</li>\n<li><p>select：只能与通道联用，一般由若干个分支组成，每次执行只有一个分支的代码会被执行。分支分为两种，一种叫做候选分支，另一种叫做默认分支。候选分支总是以关键字case开头，后跟一个case表达式和一个冒号，然后我们可以从下一行开始写入当分支被选中时需要执行的语句；默认分支其实就是 default case，因为，当且仅当没有候选分支被选中时它才会被执行，所以它以关键字default开头并直接后跟一个冒号</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F; 准备好几个通道\nintChannels :&#x3D; [3]chan int&#123;\n  make(chan int, 1),\n  make(chan int, 1),\n  make(chan int, 1),\n&#125;\n&#x2F;&#x2F; 随机选择一个通道，并向它发送元素值\nindex :&#x3D; rand.Intn(3)\nfmt.Printf(&quot;The index: %d\\\\n&quot;, index)\nintChannels[index] &lt;- index\n&#x2F;&#x2F; 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。仅当select语句中的所有case表达式都被求值完毕(从上到下)后，它才会开始选择候选分支\nselect &#123;\ncase &lt;-intChannels[0]:\n  fmt.Println(&quot;The first candidate case is selected.&quot;)\ncase &lt;-intChannels[1]:\n  fmt.Println(&quot;The second candidate case is selected.&quot;)\ncase elem :&#x3D; &lt;-intChannels[2]:\n  fmt.Printf(&quot;The third candidate case is selected, the element is %d.\\\\n&quot;, elem)\ndefault:\n  fmt.Println(&quot;No candidate case is selected!&quot;)\n&#125;\n\n&#x2F;&#x2F;通过接收表达式的第二个结果值来判断通道是否已经关闭\nintChan :&#x3D; make(chan int, 1)\n&#x2F;&#x2F; 一秒后关闭通道。\ntime.AfterFunc(time.Second, func() &#123;\n  close(intChan)\n&#125;)\nselect &#123;\ncase _, ok :&#x3D; &lt;-intChan:\n  if !ok &#123;\n    fmt.Println(&quot;The candidate case is closed.&quot;)\n    break\n  &#125;\n  fmt.Println(&quot;The candidate case is selected.&quot;)\n&#125;</code></pre></li>\n<li><p>go</p>\n<ul>\n<li><p>并发模型：（G（goroutine 的缩写）、P（processor 的缩写）和 M（machine 的缩写））</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230504124519280.png\" alt=\"image-20230504124519280\"></p>\n</li>\n<li><p>Go语句执行时，Go语言运行时系统会先试图从存放空闲G的队列中获取一个G（即goroutine），如果没有才会创建一个新的，然后包装将要执行的代码，并且加入到待执行的队列中，虽然很快就能执行，但是依旧会耗时。所以在go语言本身执行完毕后，Go程序完全不会等待go函数的执行，而是立刻执行后边的语句，即异步并发地执行。在执行完主goroutine的所有go语句后，主goroutine就会结束运行</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport &quot;fmt&quot;\n\nfunc main() &#123;\n  for i :&#x3D; 0; i &lt; 10; i++ &#123;\n    go func() &#123;\n      fmt.Println(i)&#x2F;&#x2F;不会打印任何东西\n    &#125;()\n  &#125;\n&#125;\n&#x2F;&#x2F;因为主goroutine先结束，而其他goroutine内部的语句还没开始执行</code></pre></li>\n<li><p>让主goroutine等待其他goroutine：让主goroutine执行time.Sleep(time.Millisecond * 500) 或 利用通道</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n\tnum :&#x3D; 10\n  &#x2F;&#x2F;struct&#123;&#125;类似于空接口类型interface&#123;&#125;，代表既不包含任何字段也不拥有任何方法的空结构体类型\n  &#x2F;&#x2F;struct&#123;&#125;类型值的表示法只有一个，即struct&#123;&#125;&#123;&#125;，占用0字节内存空间，全局只有一份\n\tsign :&#x3D; make(chan struct&#123;&#125;, num)\n\n\tfor i :&#x3D; 0; i &lt; num; i++ &#123;\n\t\tgo func() &#123;\n\t\t\tfmt.Println(i)\n\t\t\tsign &lt;- struct&#123;&#125;&#123;&#125;\n\t\t&#125;()\n\t&#125;\n\tfor j :&#x3D; 0; j &lt; num; j++ &#123;\n\t\t&lt;-sign &#x2F;&#x2F;go语句全执行完，主goroutine才会全部不阻塞，顺利执行完\n\t&#125;\n&#125;</code></pre></li>\n<li><p>让多个goroutine按既定顺序执行</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">func main() &#123;\n  var count uint32\n  &#x2F;&#x2F;trigger函数会不断地获取一个名叫count的变量的值，并判断该值是否与参数i的值相同。如果相同，那么就\n  &#x2F;&#x2F;立即调用fn代表的函数，然后把count变量的值加1，最后显式地退出当前的循环。否则，我们就先让当前的\n  &#x2F;&#x2F;goroutine“睡眠”一个纳秒再进入下一个迭代。\n  trigger :&#x3D; func(i uint32, fn func()) &#123;\n    for &#123;\n      &#x2F;&#x2F;原子操作，count是一个信号，值总是下一个可以调用打印函数的go函数的序号\n      if n :&#x3D; atomic.LoadUint32(&amp;count); n &#x3D;&#x3D; i &#123;\n        fn()\n        atomic.AddUint32(&amp;count, 1)\n        break\n      &#125;\n      time.Sleep(time.Nanosecond)\n    &#125;\n  &#125;\n  for i :&#x3D; uint32(0); i &lt; 10; i++ &#123;\n    go func(i uint32) &#123;\n      fn :&#x3D; func() &#123;\n        fmt.Println(i)\n      &#125;\n      trigger(i, fn)\n    &#125;(i)\n  &#125;\n  &#x2F;&#x2F;让主 goroutine 最后一个运行完毕。当手动启用的 goroutine 都运行完毕之后，count的值一定会是10\n  &#x2F;&#x2F;所以把10作为了第一个参数值。又由于并不想打印这个10，所以把一个什么都不做的函数作为了第二个参数值\n  trigger(10, func() &#123;&#125;)\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>错误处理（defer）</p>\n<ul>\n<li><p>error类型是一个接口类型，也是一个Go语言的内建类型。在这个接口类型的声明中只包含一个方法Error，不接受任何参数，但会返回一个string类型的结果，作用是返回错误信息的字符串表示形式，相当于其他类型值的String方法。示例如下</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n  &quot;errors&quot;\n  &quot;fmt&quot;\n)\n&#x2F;&#x2F;用在结果列表的最后，声明一个error类型的结果\nfunc echo(request string) (response string, err error) &#123;\n  if request &#x3D;&#x3D; &quot;&quot; &#123;\n    &#x2F;&#x2F;为err赋值，返回错误信息。err的静态类型是error，动态类型是errors包中的*errorString\n    err &#x3D; errors.New(&quot;empty request&quot;)\n    return\n  &#125;\n  response &#x3D; fmt.Sprintf(&quot;echo: %s&quot;, request)\n  return\n&#125;\n\nfunc main() &#123;\n  for _, req :&#x3D; range []string&#123;&quot;&quot;, &quot;hello!&quot;&#125; &#123;\n    fmt.Printf(&quot;request: %s\\\\n&quot;, req)\n    resp, err :&#x3D; echo(req)\n    if err !&#x3D; nil &#123;\n      &#x2F;&#x2F;fmt.Printf函数如果发现被打印的值是一个error类型的值，那么就会去调用它的Error方法\n      fmt.Printf(&quot;error: %s\\\\n&quot;, err)\n      continue\n    &#125;\n    fmt.Printf(&quot;response: %s\\\\n&quot;, resp)\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>对于类型在已知范围内的一系列错误值，一般使用类型断言表达式或类型switch语句来判断；</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">&#x2F;&#x2F;os包中的几个代表错误的类型os.PathError、os.LinkError、os.SyscallError和os&#x2F;exec.Error\nfunc underlyingError(err error) error &#123;\n  switch err :&#x3D; err.(type) &#123;\n  case *os.PathError:\n    return err.Err\n  case *os.LinkError:\n    return err.Err\n  case *os.SyscallError:\n    return err.Err\n  case *exec.Error:\n    return err.Err\n  &#125;\n  return err\n&#125;</code></pre></li>\n<li><p>对于已有相应变量且类型相同的一系列错误值，一般直接使用判等操作来判断；</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">printError :&#x3D; func(i int, err error) &#123;\n  if err &#x3D;&#x3D; nil &#123;\n    fmt.Println(&quot;nil error&quot;)\n    return\n  &#125;\n  err &#x3D; underlyingError(err)&#x2F;&#x2F;得到潜在错误值\n  switch err &#123;\n  case os.ErrClosed:\n    fmt.Printf(&quot;error(closed)[%d]: %s\\\\n&quot;, i, err)\n  case os.ErrInvalid:\n    fmt.Printf(&quot;error(invalid)[%d]: %s\\\\n&quot;, i, err)\n  case os.ErrPermission:\n    fmt.Printf(&quot;error(permission)[%d]: %s\\\\n&quot;, i, err)\n  &#125;\n&#125;</code></pre></li>\n<li><p>对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来做判断。</p>\n</li>\n</ul>\n</li>\n<li><p>panic（运行时恐慌）：是一种程序异常，抛出panic时如果程序没有保护措施，就会打印出panic的详细信息，然后终止运行</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">panic: runtime error: index out of range#运行时异常，panic包含一个runtime.Error接口类型的值\n\ngoroutine 1 [running]:#表示有一个ID为1的goroutine在此panic被引发的时候正在运行\nmain.main()#表明了这个goroutine包装的go函数就是命令源码文件中的那个main函数，即此为主goroutine\n &#x2F;Users&#x2F;haolin&#x2F;GeekTime&#x2F;Golang_Puzzlers&#x2F;src&#x2F;puzzlers&#x2F;article19&#x2F;q0&#x2F;demo47.go:5 +0x3d\nexit status 2#表明这个程序是以退出状态码2结束运行的</code></pre>\n\n<ul>\n<li>从panic被引发到程序终止运行的大致过程：某行代码引发panic，从那行代码开始根据调用层级，反向依次终止函数，一直到最外层函数，即go函数/main函数，然后控制权被运行时系统收回，程序崩溃并终止运行，承载程序这次运行的进程也会随之消亡。在这个传播过程中，panic详情会逐步完善，最终打印</li>\n<li>怎么让panic包含一个值：通过内建函数panic，可以在程序运行期间报告异常，直接通过参数传入即可。如果某个值有可能会被记到日志里，那么就应该为它关联String方法。</li>\n</ul>\n</li>\n<li><p>recover：施加应对panic的保护措施，Go 语言的内建函数recover专用于恢复 panic，或者说平息运行时恐慌。recover函数无需任何参数，并且会返回一个空接口类型的值。defer语句就是被用来延迟执行代码的，延迟到该语句所在的函数即将执行结束的那一刻，无论结束执行的原因是什么。</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">package main\n\nimport (\n &quot;fmt&quot;\n &quot;errors&quot;\n)\n\nfunc main() &#123;\n fmt.Println(&quot;Enter function main.&quot;)\n defer func()&#123;&#x2F;&#x2F;类似于go语句的写法\n  fmt.Println(&quot;Enter defer function.&quot;)\n  if p :&#x3D; recover(); p !&#x3D; nil &#123;&#x2F;&#x2F;recover会返回空接口类型的结果值，如果没有panic，则值是nil\n   fmt.Printf(&quot;panic: %s\\\\n&quot;, p)\n  &#125;\n  fmt.Println(&quot;Exit defer function.&quot;)\n &#125;()\n &#x2F;&#x2F; 引发panic。\n panic(errors.New(&quot;something wrong&quot;))\n fmt.Println(&quot;Exit function main.&quot;)\n&#125;</code></pre></li>\n<li><p>defer：defer用于资源的释放，会在函数返回之前进行调用。一般采用如下模式</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">f,err :&#x3D; os.Open(filename)\nif err !&#x3D; nil &#123;\n    panic(err)\n&#125;\ndefer f.Close()</code></pre>\n\n<ul>\n<li>多条defer语句的执行顺序：在同一个函数中，defer函数调用的执行顺序与它们分别所属的defer语句的出现顺序（更严谨地说，是执行顺序）完全相反。当一个函数即将结束执行时，其中的写在最下边的defer函数调用会最先执行，其次是写在它上边、与它的距离最近的那个defer函数调用，以此类推，最上边的defer函数调用会最后一个执行。因为defer语句每次执行的时候，Go 语言会把它携带的defer函数及其参数值另行存储到一个链表中，这个链表是先进后出的，相当于栈</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>库函数</p>\n<ul>\n<li><p>strings</p>\n<ul>\n<li><p>Go使用Unicode编码规范中的UTF-8编码格式，一个string类型的值是由一系列对应的UTF-8编码值来表达。一个string类型的值可以被拆分成一个包含多个字符的序列，也可以被拆分为一个包含多个字节的序列。前者使用以rune为元素类型的切片来表示，后者则可以用一个以byte为元素类型的切片来表示。rune是Go特有的一个基本数据类型，一个值就代表一个字符（Unicode字符），它是一个int32类型的一个别名类型</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">str :&#x3D; &quot;Go爱好者&quot;\nfmt.Printf(&quot;The string: %q\\\\n&quot;, str)\n&#x2F;&#x2F;&#x3D;&gt; runes(char): [&#39;G&#39; &#39;o&#39; &#39;爱&#39; &#39;好&#39; &#39;者&#39;]\nfmt.Printf(&quot;  &#x3D;&gt; runes(char): %q\\\\n&quot;, []rune(str))\n&#x2F;&#x2F;&#x3D;&gt; runes(hex): [47 6f 7231 597d 8005]\nfmt.Printf(&quot;  &#x3D;&gt; runes(hex): %x\\\\n&quot;, []rune(str))\n&#x2F;&#x2F;&#x3D;&gt; bytes(hex): [47 6f e7 88 b1 e5 a5 bd e8 80 85]\nfmt.Printf(&quot;  &#x3D;&gt; bytes(hex): [% x]\\\\n&quot;, []byte(str))</code></pre></li>\n<li><p>使用带有range子句的for语句遍历字符串：带有range子句的for语句会先把被遍历的字符串值拆成一个字节序列，然后再试图找出这个字节序列中包含的每一个 UTF-8 编码值，或者说每一个 Unicode 字符</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">str :&#x3D; &quot;Go爱好者&quot;\nfor i, c :&#x3D; range str &#123;\n fmt.Printf(&quot;%d: %q [% x]\\\\n&quot;, i, c, []byte(string(c)))\n&#125;\n&#x2F;&#x2F;0: &#39;G&#39; [47]\n&#x2F;&#x2F;1: &#39;o&#39; [6f]\n&#x2F;&#x2F;2: &#39;爱&#39; [e7 88 b1]\n&#x2F;&#x2F;5: &#39;好&#39; [e5 a5 bd]\n&#x2F;&#x2F;8: &#39;者&#39; [e8 80 85]</code></pre></li>\n<li><p>strings包中有strings.Builder类型的WriteRune方法、strings,Reader类型的ReadRune方法</p>\n<ul>\n<li>虽然string值能通过切片操作来裁剪或者通过操作符+来拼接，但是都需要拷贝到新的内存里，但是strings.Builder类型的值有以下优势：<ul>\n<li>已存在的内容不可变，但可以拼接更多的内容：通过一个byte为元素的类型的切片来存储内容，通过一个unsafe.Pointer类型的字段来指向持有那个指向了底层字节数组的指针值。虽然可以进行任何操作，但是要求只能被拼接或完全覆盖</li>\n<li>减少了内存分配和内容拷贝的次数：容量不够或者调用Grow方法的时候才会扩容并拷贝数据</li>\n<li>可将内容重置，可重用值：通过Reset方法</li>\n</ul>\n</li>\n<li>strings.Builder类型在已被真正使用后就不可再被复制，否则会引发panic，但是可以复制指针值；并且由于其内容不是完全不可变的，所以需要使用方自行解决操作冲突和并发安全问题</li>\n<li>strings.Reader类型的值可以高效地读取字符串，因为在读取过程中，Reader值会保存已读取的字节的计数，代表着下一次读取的起始位置，所以很容易计算出下一次读取的起始索引位置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>bytes</p>\n<ul>\n<li>strings包和bytes包很多API是相似的，提供的函数的数量和功能也差别不大。主要区别是strings包主要面向Unicode字符和经过UTF-8编码的字符串，而bytes包面对的则主要是字节和字节切片，主要用途是作为字节序列的缓冲区</li>\n<li>bytes.Buffer的扩容策略：<ul>\n<li>对于处在零值状态的Buffer值来说，如果第一次扩容时的另需字节数不大于64，那么该值就会基于一个预先定义好的、长度为64的字节数组来创建内容容器。在这种情况下，这个内容容器的容量就是64。这样做的目的是为了让Buffer值在刚被真正使用的时候就可以快速地做好准备</li>\n<li>如果可以（内容容器容量与其长度之差大于或等于需要的字节数）则会在当前的内容容器之上，进行长度扩容，即通过切片操作对原有的内容容器的长度进行扩容</li>\n<li>如果内容容器剩余容量不够，那么就会用新的内容容器去替代原有的内容容器，进行扩容。如果当前内容容器的容量的一半，仍然大于或等于其现有长度（即未读字节数）再加上另需的字节数的和，那么，扩容代码就会复用现有的内容容器，并把容器中的未读内容拷贝到它的头部位置。否则就创建一个新的内容容器，新容器的容量等于原有容量的二倍再加上另需字节数的和</li>\n</ul>\n</li>\n<li>在bytes.Buffer中，Bytes方法和Next方法都可能会造成内容的泄露。原因在于，它们都把基于内容容器的切片直接返回给了方法的调用方，而且通过切片可以直接访问和操纵它的底层数组</li>\n</ul>\n</li>\n<li><p>io</p>\n<ul>\n<li><p>strings.Builder、strings.Reader和bytes.Buffer都分别实现了很多io包中的接口，io包中接口的优势是可以提供不同程序实体之间的互操作性</p>\n</li>\n<li><p>io包中的接口及其关系</p>\n<ul>\n<li><p>核心接口：io.Reader、io.Writer、io.Closer</p>\n</li>\n<li><p>io包中的简单接口共有 11 个。其中，读取操作相关的接口有 5 个，写入操作相关的接口有 4 个，而与关闭操作有关的接口只有 1 个，另外还有一个读写位置设定相关的接口。此外，io包还包含了 9 个基于这些简单接口的扩展接口</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230504124545577.png\" alt=\"image-20230504124545577\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>bufio</p>\n<ul>\n<li>bufio是buffed I/O的缩写，即实现的I/O操作都内置了缓冲区，主要的数据类型有Reader、Scanner、Writer、ReadWriter</li>\n<li>bufio.Reader类型值中的缓冲区的作用：是一个数据存储中介，介于底层读取器（初始化时传入的io.Reader）与读取方法及其调用方之间。Reader值的读取方法一般都会先从其所属值的缓冲区中读取数据。同时，在必要的时候，它们还会预先从底层读取器那里读出一部分数据，并暂存于缓冲区之中以备后用。可以降低读取方法的执行时间。（fill函数）</li>\n<li>bufio.Reader类型读取方法有哪些不同<ul>\n<li>Peek：读取并返回其缓冲区中的n个未读字节，并且它会从已读计数代表的索引位置开始读。即使它读取了缓冲区中的数据，也不会更改已读计数的值。</li>\n<li>Read：有时会把缓冲区中的未读字节，依次拷贝到其参数p代表的字节切片中，并立即根据实际拷贝的字节数增加已读计数的值<ul>\n<li>在缓冲区中还有未读字节的情况下，该方法的做法就是如此。不过，在另一些时候，其所属值的已读计数会等于已写计数，这表明：此时的缓冲区中已经没有任何未读的字节了。</li>\n<li>当缓冲区中已无未读字节时，Read方法会先检查参数p的长度是否大于或等于缓冲区的长度。如果是，那么Read方法会索性放弃向缓冲区中填充数据，转而直接从其底层读取器中读出数据并拷贝到p中。这意味着它完全跨过了缓冲区，并直连了数据供需的双方。</li>\n</ul>\n</li>\n<li>ReadSlice：先在其缓冲区的未读部分中寻找分隔符。如果未能找到，并且缓冲区未满，那么该方法会先通过调用fill方法对缓冲区进行填充，然后再次寻找，如此往复</li>\n<li>ReadBytes：会通过调用ReadSlice方法一次又一次地从缓冲区中读取数据，直至找到分隔符为止。在这个过程中，ReadSlice方法可能会因缓冲区已满而返回所有已读到的字节和相应的错误值，但ReadBytes方法总是会忽略掉这样的错误，并再次调用ReadSlice方法，这使得后者会继续填充缓冲区并在其中寻找分隔符。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>os</p>\n<ul>\n<li><p>os包中的API可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程、系统信号</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230504124617119.png\" alt=\"image-20230504124617119\"></p>\n</li>\n</ul>\n</li>\n<li><p>net</p>\n<ul>\n<li><p>网络编程底层以来socket系统调用，是一种IPC （Inter-Process Communication）方法。在syscall代码包中有一个与这个socket系统调用对应的函数，两者的函数签名基本一致，都会接受三个int类型的参数（通信域、类型、使用的协议），并返回一个可以代表文件描述符的结果</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230504124634504.png\" alt=\"image-20230504124634504\"></p>\n</li>\n<li><p>在调用net.Dial函数的时候，会为它的两个参数设定值。其中的第一个参数名为network，它决定 Go 程序在底层会创建什么样的 socket 实例，并使用什么样的协议与其他程序通信，第二个参数是address。参数network有以下可选值：tcp, tcp4, tcp6, udp, udp4, udp6, unix, unixgram, unixpacket</p>\n</li>\n<li><p>net/http代码包</p>\n<ul>\n<li><p>使用：只需要传给它一个URL就可以，http.Get函数会返回两个结果值，第一个结果值的类型是*http.Response，它是网络服务给我们传回来的响应内容的结构化表示。第二个结果值是error类型的，它代表了在创建和发送HTTP 请求，以及接收和解析 HTTP 响应的过程中可能发生的错误。http.Get函数会在内部使用缺省的 HTTP 客户端，并且调用它的Get方法以完成功能。这个缺省的 HTTP 客户端是由net/http包中的公开变量DefaultClient代表的，其类型是*http.Client</p>\n<pre class=\"line-numbers language-go\" data-language=\"go\"><code class=\"language-go\">url1 :&#x3D; &quot;&lt;http:&#x2F;&#x2F;google.cn&gt;&quot;\nfmt.Printf(&quot;Send request to %q with method GET ...\\\\n&quot;, url1)\nresp1, err :&#x3D; http.Get(url1)\nif err !&#x3D; nil &#123;\n  fmt.Printf(&quot;request sending error: %v\\\\n&quot;, err)\n&#125;\ndefer resp1.Body.Close()\nline1 :&#x3D; resp1.Proto + &quot; &quot; + resp1.Status\nfmt.Printf(&quot;The first line of response:\\\\n%s\\\\n&quot;, line1)</code></pre></li>\n<li><p>http.Client类型中的Transport字段：</p>\n<ul>\n<li>向网络服务发送 HTTP 请求，并从网络服务接收 HTTP 响应的操作过程。也就是说，该字段的方法RoundTrip应该实现单次 HTTP 事务（或者说基于 HTTP 协议的单次交互）需要的所有步骤</li>\n<li>这个字段是http.RoundTripper接口类型的，它有一个由http.DefaultTransport变量代表的缺省值（以下简称DefaultTransport）。当我们在初始化一个http.Client类型的值（以下简称Client值）的时候，如果没有显式地为该字段赋值，那么这个Client值就会直接使用DefaultTransport</li>\n<li>http.Client类型的Timeout字段，代表的正是前面所说的单次 HTTP 事务的超时时间，它是time.Duration类型的。它的零值是可用的，用于表示没有设置超时时间。</li>\n</ul>\n</li>\n<li><p>http.Server类型的ListenAndServe方法：http.Server类型与http.Client是相对应的。http.Server代表的是基于 HTTP 协议的服务端，或者说网络服务。http.Server类型的ListenAndServe方法的功能是：监听一个基于 TCP 协议的网络地址，并对接收到的 HTTP 请求进行处理。这个方法会默认开启针对网络连接的存活探测机制，以保证连接是持久的。同时，该方法会一直执行，直到有严重的错误发生或者被外界关掉。当被外界关掉时，它会返回一个由http.ErrServerClosed变量代表的错误值。</p>\n<ul>\n<li>net.Listen函数都做了哪些事情：解析参数值中包含的网络地址隐含的 IP 地址和端口号；根据给定的网络协议，确定监听的方法，并开始进行监听。</li>\n<li>http.Server类型的Serve方法是怎样接受和处理 HTTP 请求的：在一个for循环中，网络监听器的Accept方法会被不断地调用，该方法会返回两个结果值；第一个结果值是net.Conn类型的，它会代表包含了新到来的 HTTP 请求的网络连接；第二个结果值是代表了可能发生的错误的error类型值。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","text":"GO1.运行前准备 源码结构 GOROOT：Go 语言安装根目录的路径，也就是 GO 语言的安装路径 GOPATH：若干工作区目录的路径。是我们自己定义的工作空间（workspace），go源码文件（.go）、归档文件（.a）、可执行文件都存在此处 go源码文件需要保存在GOPA...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"23 mins."},"categories":[],"tags":[{"name":"language","slug":"language","count":3,"path":"api/tags/language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#GO\"><span class=\"toc-text\">GO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%BF%90%E8%A1%8C%E5%89%8D%E5%87%86%E5%A4%87\"><span class=\"toc-text\">1.运行前准备</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">2.基础语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">3.进阶语法</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Redis","uid":"a978a5e93d8e6628e9f4ee713be55be8","slug":"Redis","date":"2023-05-04T10:00:34.000Z","updated":"2023-08-21T04:00:20.237Z","comments":true,"path":"api/articles/Redis.json","keywords":null,"cover":[],"text":"Redis Redis是一个高性能（内存+Reactor+优化的数据结构）的开源键值数据库，其value支持丰富的数据类型（string、hash、set、list、zset「有序集合」），具有数据可持久化（AOF+RDB）、支持master-slave备份、读写性能高（MySQ...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[],"tags":[{"name":"database","slug":"database","count":2,"path":"api/tags/database.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MySQL","uid":"838ae74e3a76757d637de803a615bfd9","slug":"MySQL","date":"2023-04-27T10:54:53.000Z","updated":"2023-08-05T14:34:50.595Z","comments":true,"path":"api/articles/MySQL.json","keywords":null,"cover":[],"text":"MySQL1.使用1.SQL语法 数据库概念：数据库（DB）、数据库管理系统（DBMS）、数据库系统（软件+数据库+DBA）、数据库管理员（DBA）、元祖（tuple 一行）、码（列）、候选码（唯一标识元祖）、主码（主键）、外码（另一表的主键）、主属性（候选码中的属性）、非主属性...","link":"","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"database","slug":"database","count":2,"path":"api/tags/database.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}