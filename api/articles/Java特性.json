{"title":"Java特性","uid":"b4296f0600f693552b5b6c6b665f6025","slug":"Java特性","date":"2023-04-13T11:25:47.000Z","updated":"2023-04-20T13:17:00.283Z","comments":true,"path":"api/articles/Java特性.json","keywords":null,"cover":null,"content":"<h1 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h1><h2 id=\"1-关键字\"><a href=\"#1-关键字\" class=\"headerlink\" title=\"1.关键字\"></a>1.关键字</h2><ul>\n<li><code>true</code>, <code>false</code>, 和 <code>null</code> 虽然不是关键字，但它们是不能用作标识符的文字和保留字</li>\n<li>strictfp（精确浮点数，跨平台产生相同结果）、native（原生方法）</li>\n<li></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>class</th>\n<th>return</th>\n<th>byte</th>\n<th>try</th>\n<th>if</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>import</td>\n<td>public</td>\n<td>boolean</td>\n<td>cache</td>\n<td>else</td>\n</tr>\n<tr>\n<td>extends</td>\n<td>protected</td>\n<td>short</td>\n<td>finally</td>\n<td>for</td>\n</tr>\n<tr>\n<td>implements</td>\n<td>private</td>\n<td>int</td>\n<td>throw</td>\n<td>while</td>\n</tr>\n<tr>\n<td>enum</td>\n<td>==final==</td>\n<td>char</td>\n<td>throws</td>\n<td>do</td>\n</tr>\n<tr>\n<td>interface</td>\n<td>==static==</td>\n<td>long</td>\n<td>resource</td>\n<td>switch</td>\n</tr>\n<tr>\n<td>package</td>\n<td>abstract</td>\n<td>float</td>\n<td>==volatile==</td>\n<td>case</td>\n</tr>\n<tr>\n<td>new</td>\n<td>native</td>\n<td>double</td>\n<td>==synchronized==</td>\n<td>default</td>\n</tr>\n<tr>\n<td>super</td>\n<td><del>const</del></td>\n<td>void</td>\n<td>==transient==</td>\n<td>break</td>\n</tr>\n<tr>\n<td>this</td>\n<td><del>goto</del></td>\n<td>instanceof</td>\n<td>strictfp</td>\n<td>continue</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-概念辨析\"><a href=\"#2-概念辨析\" class=\"headerlink\" title=\"2.概念辨析\"></a>2.概念辨析</h2><ol>\n<li><p>值传递与引用传递</p>\n<ul>\n<li>引用类型（数组、接口、类）的数据存储在堆上，栈上存储的是堆的地址，直接更改对象对所有引用都可见，但不能像C++那样让引用指向新的对象</li>\n<li>引用数据判等：==判断两个引用是否指向同一对象，equals方法+重写的hashcode方法判断属性是否相等</li>\n</ul>\n</li>\n<li><p>深拷贝、浅拷贝、引用拷贝</p>\n<ul>\n<li><p>深拷贝与浅拷贝：深拷贝会复制整个对象，包括对象包含的内部对象；浅拷贝会在堆上创建一个新对象，但是对象内部引用类型变量只会复制引用地址，不会直接复制内部数据</p>\n</li>\n<li><p>引用拷贝：两个不同引用指向同一对象</p>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Address implements Cloneable&#123;\n    private String name;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Address clone() &#123;\n        try &#123;\n            return (Address) super.clone();\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n\npublic class Person implements Cloneable &#123;\n    private Address address;\n    &#x2F;&#x2F; 省略构造函数、Getter&amp;Setter方法\n    @Override\n    public Person clone() &#123;\n        try &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;浅拷贝\n            Person person &#x3D; (Person) super.clone();\n            return person;\n        &#125; catch (CloneNotSupportedException e) &#123;\n            throw new AssertionError();\n        &#125;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;浅拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; true\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());\n\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;深拷贝&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@Override\npublic Person clone() &#123;\n    try &#123;\n        Person person &#x3D; (Person) super.clone();\n\t\t\t\t&#x2F;&#x2F;深拷贝\n        person.setAddress(person.getAddress().clone());\n        return person;\n    &#125; catch (CloneNotSupportedException e) &#123;\n        throw new AssertionError();\n    &#125;\n&#125;\nPerson person1 &#x3D; new Person(new Address(&quot;武汉&quot;));\nPerson person1Copy &#x3D; person1.clone();\n&#x2F;&#x2F; false\nSystem.out.println(person1.getAddress() &#x3D;&#x3D; person1Copy.getAddress());</code></pre></li>\n</ul>\n</li>\n<li><p>重载和重写的区别</p>\n<ul>\n<li>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理（如构造函数）；重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，就要覆盖父类方法（如Override）</li>\n<li>如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的</li>\n</ul>\n</li>\n<li><p>接口和抽象类</p>\n<ul>\n<li>共同点：都不能被实例化、都可以包含抽象方法，都可以有默认实现方法（<code>default</code>声明，子类可不实d现）</li>\n<li>不同点：<ul>\n<li>接口主要是对API声明（参数类型、返回值类型、函数名），抽象类主要是为了代码复用</li>\n<li>一个类可以实现多个接口，但只能继承自一个抽象类</li>\n<li>接口中的成员变量只能是<code>public static final</code>类型的，不能被修改且必须有初始值，而抽象类的成员变量默认<code>default</code>，可在子类中被重新定义，也可被重新赋值</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>final和static</p>\n<ul>\n<li>只有成员变量能被static、public、protected、private修饰，局部变量不行，但是两者都能被final修饰</li>\n</ul>\n</li>\n<li><p>引用类型转换：仅限于有继承关系的类之间，分为向上转换和向下转换两种</p>\n<ul>\n<li>向上转换，自动类型转换，总是可以的</li>\n<li>向下转换需要保证转换的对象本身就是子类类型的，只不过暂时转换为了父类型，现在只是再转回去而已</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-语法糖\"><a href=\"#3-语法糖\" class=\"headerlink\" title=\"3.语法糖\"></a>3.语法糖</h2><ol>\n<li><p><strong>switch支持String与枚举</strong>：int比数、char比ascii码、字符串用hashCode()和equals()，其它如short、byte、int都需要转换为整数</p>\n</li>\n<li><p><strong>泛型和类型擦除</strong>：编译时会使用泛型做类型检查，但是当代码编译为字节码之后，泛型中的类型参数和通配符都替换为上界限（==类型擦除==）</p>\n<ul>\n<li><p>泛型遇到重载：因为都会转成父类型，所以<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>这种重载会编译失败</p>\n</li>\n<li><p>当泛型遇到catch：泛型的类型参数不能用在catch语句中，因为异常处理是由JVM在运行时刻来进行的，类型信息被擦除了，所以JVM是无法区分两个异常类型<code>MyException&lt;String&gt;</code>和<code>MyException&lt;Integer&gt;</code>的</p>\n</li>\n<li><p>创建对象时：不能使用new T()来创建类型参数对象，在代码编译成字节之后类型信息已经擦除，所以，在运行时，JVM无法确定具体类型，也就无法知道T是否存在无参构造函数</p>\n</li>\n<li><p>当泛型内包含静态变量：由于经过类型擦除，所有的泛型类实例都关联到同一份字节码上，泛型类的所有静态变量是共享的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StaticTest&#123;\n    public static void main(String[] args)&#123;\n        GT&lt;Integer&gt; gti &#x3D; new GT&lt;Integer&gt;();\n        gti.var&#x3D;1;\n        GT&lt;String&gt; gts &#x3D; new GT&lt;String&gt;();\n        gts.var&#x3D;2;\n        System.out.println(gti.var); &#x2F;&#x2F;输出为2\n    &#125;\n&#125;\nclass GT&lt;T&gt;&#123;\n    public static int var&#x3D;0;\n    public void nothing(T x)&#123;&#125;\n&#125;</code></pre></li>\n<li><p>因为需要继承自Object，所以基本类型不可以传入类型参数，只有引用类型可以。但是有语法糖可以让<code>List&lt;int&gt;</code>中的int替换为Integer，但是开发上依旧需要为每个基本类型分别定义多个不同的函数接口</p>\n</li>\n</ul>\n</li>\n<li><p><strong>自动装箱与拆箱：原始类型byte, short, char, int, long, float, double, boolean 对应的封装类为Byte, Short, Character, Integer, Long, Float, Double, Boolean</strong></p>\n<ul>\n<li><p>基本类型和包装类型的区别：包装类型不赋值时是null，可用于范型，占用空间大</p>\n<ul>\n<li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中（JIT优化，逃逸分析，分配到栈上）</li>\n<li>基本数据类型存放在栈中是一个常见的误区！基本数据类型的成员变量如果没有被 static修饰的话（不建议这么使用，应该要使用基本数据类型对应的包装类型），就存放在堆中</li>\n<li>类静态成员变量存放在方法区中！（方法区又叫静态区，跟堆一样，被所有线程共享，方法区包含所有的class和static变量）</li>\n</ul>\n</li>\n<li><p>常量池</p>\n<ul>\n<li><p>Integer等包装类使用了常量池技术，IntegerCache类（享元模式）中会缓存值为-128到127之间的Integer对象，当通过自动装箱，也就是调用valueOf()来创建Integer对象时，如果要创建的Integer对象的值在-128到127之间，会从IntegerCache中直接返回，否则才会真正调用new方法创建，详见Integer类的valueOf()（JVM也提供了方法，可以自定义缓存的最大值）</p>\n</li>\n<li><p>Byte、Short、Integer、Long这四种包装类默认创建了数值[-128,128]的相应类型的缓存数据（存放在一个Cache数组中，由static代码块直接初始化），Character创建了数值在[0，127]范围的缓存数据，Boolean直接返回True或False（<code>return (b ? TRUE : FALSE);</code>）</p>\n</li>\n<li><p>所有整型包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer i1 &#x3D; 40; &#x2F;&#x2F;触发自动装箱，使用缓存中的对象\nInteger i2 &#x3D; new Integer(40); &#x2F;&#x2F;新创建的对象\nSystem.out.println(i1&#x3D;&#x3D;i2); &#x2F;&#x2F;返回false</code></pre></li>\n</ul>\n</li>\n<li><p>示例代码：项目首选基本类型，业务相关可选包装类用null表示空而不是0</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;自动装箱，语法糖，底层实现为：Integer iobj &#x3D; Integer。valueOf(12);\nInteger iobj &#x3D; 12;\n&#x2F;&#x2F;自动拆箱，语法糖，底层实现为：int i &#x3D; iobj.intValue();\nint i &#x3D; iobj;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;触发自动装箱和拆箱的几种情况&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;将基本类型数据赋值给包装类变量（包括参数传递）时，触发自动装箱\nint i1 &#x3D; 5\nInteger iobj1 &#x3D; 5;&#x2F;&#x2F;1\niobj &#x3D; i1;&#x2F;&#x2F;1\nList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\nlist.add(i1);&#x2F;&#x2F;1\n&#x2F;&#x2F;将包装类对象赋值给基本类型变量（包括参数传递）时，触发自动拆箱\nInteger iobj2&#x3D; new Integer(6);\nint i2 &#x3D; iobj2;&#x2F;&#x2F;2\n&#x2F;&#x2F;当包装类对象参与算术运算、关系运算（&lt;,&gt;）时，触发自动拆箱操作\nInteger iobj3 &#x3D; iobj1 + iobj2;\nboolean bl &#x3D; (iobj1 &lt; iobj2);\nbl &#x3D; (iobj1 &lt; 2);\n&#x2F;&#x2F;当包装类对象参与关系运算（&#x3D;&#x3D;），且另一方是基本类型数据时，触发自动拆箱操作。\nInteger iobj4 &#x3D; new Integer(123);\nbl &#x3D; (iob4 &#x3D;&#x3D; 123);</code></pre></li>\n</ul>\n</li>\n<li><p><strong>方法变长参数</strong>：String… args用一个数组实现，用foreach遍历，编译后会被转变成数组</p>\n</li>\n<li><p><strong>枚举</strong>：当我们使用enum来定义一个枚举类型的时候，编译器会自动创建一个final类型的类继承Enum类，所以枚举类型不能被继承（<code>public enum t&#123;&#125;</code> =&gt; <code>public final class T extends Enum&#123;&#125;</code>）</p>\n</li>\n<li><p>内部类：</p>\n<ul>\n<li>会独立于外部类，生成一个新的class文件，名字为外部类名$内部类名.class或外部类名$[序号].class，静态匿名内部类可访问静态成员变量+静态函数；普通匿名内部类不可访问外部函数中非final修饰的局部变量</li>\n<li>外部函数通过类似参数传递的方式，将局部变量通过值传递的方式传入到匿名内部类，这是外部函数局部变量的副本，所以如果能访问非final修饰的局部变量的话，内部类对其的更改不起作用，违反直觉，类似于形参的改变不影响实参</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface I&#123;&#125;\npublic class A&#123;\n    private class B&#123;&#125; &#x2F;&#x2F;类似于ArrayList的内部类Itr\n    private class C implements I&#123;&#125;&#x2F;&#x2F;实现外部接口的内部类\n    public class D&#123;&#125;&#x2F;&#x2F;public修饰的内部类\n\t\tpublic static class E&#123;&#125;&#x2F;&#x2F;静态内部类\n    \n    public B getB()&#123; return new B(); &#125;\n    public I getC()&#123; return new C(); &#125;\n    public D getD()&#123; return new D(); &#125;\n&#125;\npublic class Demo&#123;\n    public static void main(String[] args)&#123;\n        A a &#x3D; new A();\n        A.B b &#x3D; a.getB();&#x2F;&#x2F;编译报错，满足封装原则\n        I c &#x3D; a.getC();&#x2F;&#x2F;可访问\n        A.D d1 &#x3D; a.getD();\n        A.D d2 &#x3D; a.new D();\n\t\t\t\tA.E e &#x3D; new A.E();&#x2F;&#x2F;静态内部类的对象可以独立于外部类单独创建\n    &#125;\n&#125;</code></pre></li>\n<li><p><strong>条件编译</strong>：if的条件是final且为false时，对应代码块不被编译，主要出于对代码优化的考虑</p>\n</li>\n<li><p><strong>断言</strong>：其实断言的底层实现就是if语言，如果断言结果为true，则什么都不做，程序继续执行，如果断言结果为false，则程序抛出AssertError来打断程序的执行</p>\n</li>\n<li><p><strong>数值字面量</strong>：不管是整数还是浮点数，都允许在数字之间插入任意多个下划线，为了方便阅读</p>\n</li>\n<li><p><strong>增强for循环</strong>：for-each用了普通的for循环和Iterator迭代器的hasNext()方法，在遍历过程中不能增删内部元素，会抛出异常（可以使用Iterator.remove()方法在删除当前迭代对象的同时维护索引的一致性）</p>\n</li>\n<li><p><strong>try-with-resource</strong>：在try()中写资源申请，就不用在finally中判断是否为null在关闭了，编译期帮助我们关闭了（资源类需要实现Java.lang.AutoClosale接口）</p>\n</li>\n<li><p><strong>lambda表达式</strong>：只有一个函数的接口叫做函数式接口，可以用Lambda表达式简化</p>\n<ul>\n<li><p>Lambda表达式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">(类型 a,类型 b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\n(a,b)-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a，b为输入参数\na-&gt;&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;a为输入参数\n&#123;语句1;语句2; ... ;return 输出;&#125;&#x2F;&#x2F;没有入参</code></pre></li>\n<li><p>方法引用：当Lambda中的逻辑已经有现成的方法实现时，可以直接使用方法引用。方法引用要求所引用的方法的参数列表的返回值，跟函数接口中未实现方法的参数列表和返回值完全一致，格式如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;对象::实例方法\n&#x2F;&#x2F;类::静态方法\n&#x2F;&#x2F;类::实例方法\npublic class FPDemo &#123;\n    public static void main(String] args) &#123;\n        List&lt;String&gt; strList &#x3D; Arrays.asList(&quot;wz-a.java&quot;, &quot;wz-b.txt&quot;, &quot;c.java&quot;);\n        strList.stream()\n\t\t\t\t\t\t&#x2F;&#x2F;直接引用String的方法\n            .filter(((Predicate&lt;String&gt;) String::isEmpty).negate())\n            &#x2F;&#x2F; .filter(s-&gt;s.isEmpty())\n            .filter(s-&gt;s.startsWith(&quot;wz-&quot;))\n            .map(String::length)\n            &#x2F;&#x2F;.map(s-&gt;s.length())\n            .forEach(l-&gt;System.out.printIn(I));&#x2F;&#x2F;输出9、8\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-特殊语法\"><a href=\"#4-特殊语法\" class=\"headerlink\" title=\"4.特殊语法\"></a>4.特殊语法</h2><ol>\n<li><p>反射：在运行的过程中动态告知JVM去创建对象、创建方法、获取类信息（构造函数、方法、成员变量、注解），重要应用见Spring框架的依赖注入</p>\n<ul>\n<li><p>Class类：是一个存储类的信息的特殊的类，提供了大量的方法，可以获取类的信息，比如获取类中的方法，获取构造函数，获取成员变量等</p>\n<ul>\n<li>Constructor类：用来存储构造函数的信息，如通过<code>newInstance()</code>方法来进行有参/无参构造</li>\n<li>Method类：存储方法的信息，如通过<code>invoke()</code>方法可以执行类中的对应方法</li>\n<li>Field类：用来存储成员变量的信息</li>\n</ul>\n</li>\n<li><p>获取反射的三种方法</p>\n<ul>\n<li><p>通过对象获取反射</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object obj &#x3D; new Object(); &#x2F;&#x2F; 创建一个对象\nClass&lt;?&gt; clazz &#x3D; obj.getClass(); &#x2F;&#x2F; 获取 Class 对象</code></pre></li>\n<li><p>通过类名获取反射</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;com.example.MyClass&quot;); &#x2F;&#x2F; 获取 Class 对象</code></pre></li>\n<li><p>通过类字面常量获取反射</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Class&lt;?&gt; clazz &#x3D; MyClass.class; &#x2F;&#x2F; 获取 Class 对象</code></pre></li>\n</ul>\n</li>\n<li><p>反射攻击：在Constructor、Method、Field类，包含一个公共的方法，能够改变构造函数、方法、成员变量的访问权限<code>public void setAccessible(boolean flag)</code>，利用这个方法，可以将私有的构造函数、方法、成员变量设置为可以访问的，这样就可以超越权限限制，在代码中访问私有的构造函数、方法和成员变量（打破单例类只能实例化一个对象的限制的情况）</p>\n</li>\n</ul>\n</li>\n<li><p>注解：注解相当于给元素打了一个tag，任何编译器或者应用程序通过反射可以访问的代码元素，都可以用注解去标识</p>\n<ul>\n<li><p>自定义注解：通过反射来读取注解，重要应用为Spring用注解代替XML配置文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;Java内建注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.SOURCE)\npublic @interface Override &#123;\n&#125;\n\n&#x2F;&#x2F;自定义注解\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface RateLimit &#123;\n\tpublic enum TimeUnit &#123; SECOND,MINUTE, HOUR, DAY,MONTH&#125;\n    string apiName();\n\tint limitCount();\n\tTimeUnit timeUnit() default TimeUnit.SECOND;\n&#125;</code></pre></li>\n<li><p>元注解</p>\n<ul>\n<li>@Target：用来描述注解的使用范围（如类、接口、方法、成员变量等）</li>\n<li>@Retention：用来描述注解的可见范围、或叫生命周期（如源码可见、字节码可见、<strong>运行时可见</strong>）</li>\n<li>@Documented：表示注解信息会输出到Javadoc文档中</li>\n<li>@interface：class、interface、enum、@interface这四者是平级关系，<code>@interface</code>用来定义注解，在注解中，还可以定义一些变量，特殊的是注解使用方法来定义变量，对于只有一个变量的注解，可以将其定义为value，这样，在使用时，可以不指定变量的名称</li>\n</ul>\n</li>\n<li><p>实践应用</p>\n<ul>\n<li>替代注释：Guava提供<code>@VisibleForTesting</code>注解在方法上进行标记，这个注解只起到注释的作用，并没有实际的作用</li>\n<li>作为标记：Java中有一种特殊的接口，叫做标记接口（<code>Marker Interface</code>）。标记接口中不包含任何方法，跟注解类似，起到标记作用，比如RandomAccess、Cloneable、Serializable，可以根据标记接口判断对象是否可以执行某些操作</li>\n<li>替代XML文件<ul>\n<li><code>@Configuration</code>注解修饰的类中的<code>@Bean</code>创建首字母小写的对象</li>\n<li><code>@Component</code>注解创建同名对象，使用<code>@Autowired</code>注入对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>动态代理（==未完待续==）</p>\n<ul>\n<li>静态代理：通过实现接口或继承的方式，通过注入原始类并添加新功能的方式实现。实现简单，但会导致项目中的类成倍增加，所有相关的类都需要增加代理类，重复代码多</li>\n<li>动态代理<ul>\n<li>一般静态指的编译阶段，动态指的运行阶段。在代理模式上，静态代理指的是在编译阶段时生成代理类的字节码，动态代理指的是运行时生成代理类的字节码，且字节码只存在与内存中，并不会生成对应的class文件</li>\n<li>之所以可以实现动态代理，是因为JVM设计得非常灵活，只要是符合类的格式的字节码，都可以在运行时被JVM解析并加载，不管这个字节码是来自预先编译好的(class文件)，还是在内存中临时生成的(典型应用:动态代理)，又或者从网络加载而来的(典型应用: Applet)。这部分内容涉及到JVM的类加载机制，见JVM<ul>\n<li>实现方法一：利用JDK提供的类来实现（InvocationHandler接口+Proxy类）</li>\n<li>实现方法二：使用第三方的字节码类库来实现，比如CGLIB、BECL、ASM、Javassit等直接编辑字节码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-工具类\"><a href=\"#5-工具类\" class=\"headerlink\" title=\"5.工具类\"></a>5.工具类</h2><h3 id=\"5-1String\"><a href=\"#5-1String\" class=\"headerlink\" title=\"5.1String\"></a>5.1String</h3><ol>\n<li>String不可变的原因<ul>\n<li>final修饰的数组，数组内容是可变的<code>private final char value[];</code></li>\n<li>但是String没有暴露更改该数组的公共方法</li>\n<li>因为String类是final修饰的，所以子类无法继承，避免了子类破坏String的不可变性</li>\n</ul>\n</li>\n<li>常量池技术<ul>\n<li>String类型跟Integer等包装类类似，使用常量池技术，并且==只有使用字符串常量赋值时，才触发==，如果字符串常量在常量池中已经创建过，则直接使用已经创建的对象。用new创建的对象不在常量池中</li>\n<li>除了使用字符串常量赋值外，还可以使用intern()方法，将分配在堆上的String对象，原模原样在常量池中复制一份。当无法用字符串常量赋值，但又有大量重复字符串时，就可以使用intern()方法复制到常量池中，代码中使用常量池中的String对象，原String对象就被JVM回收掉</li>\n</ul>\n</li>\n<li>其它<ul>\n<li><code>substring()</code><ul>\n<li><code>substring(int beginIndex, int endIndex)</code>方法截取并返回下标在[beginIndex, endIndex)范围内的子串</li>\n<li>在JDK7及其以上版本中，substring()方法会生成新的String对象来存储子串，但如果传入参数正好等于字符串的长度，那么会返回字符串本身，不会创建新对象</li>\n<li>在JDK6及以前的版本，通过substring()方法获取到的子串会共享char数组，并有count和offset属性标志子串的长度和起点</li>\n</ul>\n</li>\n<li>运算符重载：C++能直接重载运算符，但Java并不支持（重载运算符是函数式编程、并且语法太复杂），但是String类却实现了加法操作String sc = sa + sb;，主要是因为String比较常用，所以延续了基本类型及其包装类的设计，这样使用起来就方便和统一</li>\n<li>StringBuilder与StringBuffer<ul>\n<li>因为String不可变，用+拼接效率低，每次都需要创建新的String对象，所以Java设计了StringBuilder</li>\n<li>StringBuilder支持修改和动态扩容，可以用append()函数拼接，可以把StringBuilder看作是char类型的ArrayList（ArrayList<Character>）</li>\n<li>在平时开发中，经常用+号连接多个字符串，实际上底层就采用StringBuilder来实现</li>\n<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code>并没有对方法进行加同步锁，所以是非线程安全的。</li>\n<li>相同情况下使用 <code>StringBuilder</code>相比使用 <code>StringBuffer</code>仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"5-2JCF框架\"><a href=\"#5-2JCF框架\" class=\"headerlink\" title=\"5.2JCF框架\"></a>5.2JCF框架</h3><ol>\n<li><p>ArrayList动态扩容：在增加元素的时候要检测是否需要扩容，首先确定最小扩容量（最小是10），然后判断是否需要扩容（最小扩容量大于当前数组长度），执行grow函数进行扩容，扩容为原来的1.5倍，如果不够的话就直接使用最小扩容量来作为长度，避免多次扩容，若是1.5倍长度大于数组最大长度，则需要看最小扩容量是否大于最大容量，如果是则为MAX_VALUE否则为MAX_VALUE-8</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean add(E e) &#123;\n    ensureCapacityInternal(size + 1);  &#x2F;&#x2F; Increments modCount!!\n    elementData[size++] &#x3D; e;\n    return true;\n&#125;\n\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;确定是否需要扩容，主要用在添加大量元素之前，减少增量分配的次数，通过提前扩容，可以提升性能&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic void ensureCapacity(int minCapacity) &#123;\n    int minExpand &#x3D; (elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA)\n        &#x2F;&#x2F; any size if not default element table\n        ? 0\n        &#x2F;&#x2F; larger than default for default empty table. It&#39;s already\n        &#x2F;&#x2F; supposed to be at default size.\n        : DEFAULT_CAPACITY;\n\t\t&#x2F;&#x2F;如果期待最小容量大于已有的最大容量\n    if (minCapacity &gt; minExpand) &#123;\n        ensureExplicitCapacity(minCapacity);\n    &#125;\n&#125;\n&#x2F;&#x2F;得到最小扩容量\nprivate static int calculateCapacity(Object[] elementData, int minCapacity) &#123;\n    if (elementData &#x3D;&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n        return Math.max(DEFAULT_CAPACITY, minCapacity);\n    &#125;\n    return minCapacity;\n&#125;\n&#x2F;&#x2F;得到最小扩容量，通过最小扩容量扩容\nprivate void ensureCapacityInternal(int minCapacity) &#123;\n    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));\n&#125;\n&#x2F;&#x2F;判断是否需要扩容\nprivate void ensureExplicitCapacity(int minCapacity) &#123;\n    modCount++;\n\n    &#x2F;&#x2F; overflow-conscious code\n    if (minCapacity - elementData.length &gt; 0)\n\t\t\t\t&#x2F;&#x2F;调用grow方法进行扩容，调用此方法代表已经开始扩容了\n        grow(minCapacity);\n&#125;\nprivate void grow(int minCapacity) &#123;\n    &#x2F;&#x2F;oldCapacity为旧容量，newCapacity为新容量\n    int oldCapacity &#x3D; elementData.length;\n    &#x2F;&#x2F;将oldCapacity 右移一位，其效果相当于oldCapacity &#x2F;2，\n    &#x2F;&#x2F;我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，\n    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);\n    &#x2F;&#x2F;然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity &#x3D; minCapacity;\n    &#x2F;&#x2F;再检查新容量是否超出了ArrayList所定义的最大容量，\n    &#x2F;&#x2F;若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，\n    &#x2F;&#x2F;如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为MAX_ARRAY_SIZE。\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity &#x3D; hugeCapacity(minCapacity);\n    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:\n    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n&#125;\n&#x2F;&#x2F;比较minCapacity和MAX_ARRAY_SIZE\nprivate static int hugeCapacity(int minCapacity) &#123;\n    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n        MAX_ARRAY_SIZE;\n&#125;</code></pre></li>\n<li><p>HashMap</p>\n<ul>\n<li><p>Set容器包括HashSet、LinkedHashSet、TreeSet，从代码实现上来说，这三个类底层分别是依赖HashMap、LinkedHashMap、TreeMap。例如：往HashSet中存储对象obj，底层将obj作为key，一个空的Object对象作为value，一并存储到HashMap中</p>\n</li>\n<li><p>底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 包含另一个“Map”的构造函数\n public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);&#x2F;&#x2F;下面会分析到这个方法\n &#125;\nfinal void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;\n    int s &#x3D; m.size();\n    if (s &gt; 0) &#123;\n        &#x2F;&#x2F; 判断table是否已经初始化\n        if (table &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; pre-size\n            &#x2F;&#x2F; 未初始化，s为m的实际元素个数\n            float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;\n            int t &#x3D; ((ft &lt; (float)MAXIMUM_CAPACITY) ?\n                    (int)ft : MAXIMUM_CAPACITY);\n            &#x2F;&#x2F; 计算得到的t大于阈值，则初始化阈值\n            if (t &gt; threshold)\n                threshold &#x3D; tableSizeFor(t);\n        &#125;\n        &#x2F;&#x2F; 已初始化，并且m元素个数大于阈值，进行扩容处理\n        else if (s &gt; threshold)\n            resize();\n        &#x2F;&#x2F; 将m中的所有元素添加至HashMap中\n        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;\n            K key &#x3D; e.getKey();\n            V value &#x3D; e.getValue();\n            putVal(hash(key), key, value, false, evict);\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>哈希函数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final int hash(Object key) &#123;\n    int h;\n\t\t&#x2F;&#x2F;key为null的值存储在下标为0的位置，但一个HashMap只能存储一个值为null的key\n\t\t&#x2F;&#x2F;hashCode底层为JNI，定义在Object类中，根据对象在内存中的地址来计算哈希值，子类中可以重写\n\t\t&#x2F;&#x2F;h^(h&gt;&gt;&gt;16)：数组长度一般不超过2^16，所以通过将h的高16位和低16位异或，来增加参与运算的信息\n    return (key &#x3D;&#x3D; null) ? 0 : (h &#x3D; key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n&#x2F;&#x2F;确定插入数组时的位置，使用位操作与数组长度n进行取模计算（前提是n为2的幂次方），防止索引越界\nint index &#x3D; hash(key)&amp;(n-1); &#x2F;&#x2F; n-1为 11111，与其进行&amp;运算，相当于对n取余数\n\npublic V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(hash(key), key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(int hash, Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; hash]) !&#x3D; null) &#123;&#x2F;&#x2F; hash表不为空，待查找链表有值\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node，先查hash(key)，再查key.equals()\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;检测是否哈希冲突\n            return first;\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            if (first instanceof TreeNode) &#x2F;&#x2F;已经树化，进行树上的查找\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);&#x2F;&#x2F;未树化，进行链表上的遍历查找\n        &#125;\n    &#125;\n    return null;\n&#125;</code></pre></li>\n<li><p>装载因子：table大小（n）和装载因子（loadFactor）可以用默认的也可以通过构造函数传入，一般为0.75：</p>\n<ul>\n<li>权衡时间效率和空间效率之后的结果</li>\n<li>大概是[0.5,1]之间，因为小于0.5会有一半空间从来未用，当大于1时，哈希冲突的概率会大大增加，即使有链表和树化，也会影响性能</li>\n<li>因为table数组的大小n都是2的倍数，而且触发扩容的阈值threshold = n * loadfactor，所以，在[0.5,1]之间，只有0.75能使得得到的阈值一直是整数</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public HashMap(int initialCapacity, float loadFactor) &#123;\n\t\t&#x2F;&#x2F;...initialCapacity和loadFactor的可行性检验代码...\n    this.loadFactor &#x3D; loadFactor;\n\t\t&#x2F;&#x2F;直接赋值的原因：此时table数组只声明未创建，其值为null，在第一次调用put()函数后，\n\t\t&#x2F;&#x2F;HashMap会先用threshold作为数组大小创建table数组，再将其重新赋值为真正的扩容阈值\n\t\t&#x2F;&#x2F;this.table &#x3D; new T[this.threshold];\n\t\t&#x2F;&#x2F;this.threshold *&#x3D; this.factor;\n    this.threshold &#x3D; tableSizeFor(initialCapacity);\n&#125;\n&#x2F;&#x2F;initialCapacity需要是2的幂次方，如果不是，需要寻找比initialCapacity大的第一个2的幂次方数\nstatic final int tableSizeFor(int cap) &#123; &#x2F;&#x2F; 1100  12 应该返回 10000\n    int n &#x3D; cap - 1; &#x2F;&#x2F; 1011\n    n |&#x3D; n &gt;&gt;&gt; 1; &#x2F;&#x2F; 0101 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 2; &#x2F;&#x2F; 0011 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 4; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 8; &#x2F;&#x2F; 0000 - 1111\n    n |&#x3D; n &gt;&gt;&gt; 16; &#x2F;&#x2F; 0000 - 1111\n    return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#x2F;&#x2F; 10000 16\n&#125;</code></pre></li>\n<li><p>动态扩容：put后，若元素个数超过<code>threshold=n*loadFactor</code>时触发（n为table大小，loadFactor为装载因子）</p>\n<ul>\n<li>HashMap的默认初始化大小为16，之后每次扩充容量为原来的2倍，如果指定了大小，也会选择2的幂次来作为初始值<ul>\n<li>因为Hashmap的容量大小是2的幂次方，所以可以通过&amp;运算来优化%运算。例如：（16 % 5 ）等价于 （16 &amp; （5 - 1））</li>\n<li>为了能把数据分配均匀，Hash值的范围是-2147483648 到 2147483647，很难碰撞，但是需要对数组取模，操作如上</li>\n</ul>\n</li>\n<li>因为容量变大，位置会发生变化，将每个节点的hash值与新的容量取模，取模操作仍可以用位运算来替代，但JDK8中优化为：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）</li>\n<li>扫描table数组中的每一条链表，根据节点的下标是否更改，将链表中的节点分配到lo链表和hi链表，lo链表中存储的是下标值未变的节点，hi链表存储的是下标值有所改变的节点。处理完一条链表后，将lo链表和hi链表分别存储到新的table数组中的对应位置</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        n &#x3D; (tab &#x3D; resize()).length; &#x2F;&#x2F;使用resize创建新table\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)&#x2F;&#x2F;数组中链表头不存在，初始化\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123;&#x2F;&#x2F;数组中插入位置有链表头，遍历\n        Node&lt;K,V&gt; e; K k;\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp;\n            ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))&#x2F;&#x2F;先检查第一个节点\n            e &#x3D; p;&#x2F;&#x2F;找到\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n\t\t\t\t\t\t&#x2F;&#x2F;遍历链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;没找到，新建节点\n                    p.next &#x3D; newNode(hash, key, value, null);\n\t\t\t\t\t\t\t\t\t\t&#x2F;&#x2F; 如果链表元素个数大于等于TREEIFY_THRESHOLD（8）\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F;树化？红黑树转换，并不会直接转换成红黑树\n                    break;\n                &#125;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k)))) &#x2F;&#x2F;找到\n                    break;\n                p &#x3D; e;&#x2F;&#x2F;继续遍历\n            &#125;\n        &#125;\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;&#x2F;&#x2F;更新值\n            afterNodeAccess(e);&#x2F;&#x2F;见LinkedHashMap\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);&#x2F;&#x2F;见LinkedHashMap\n    return null;\n&#125;\n\nfinal Node&lt;K,V&gt;[] resize() &#123;\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    int newCap, newThr &#x3D; 0;\n    if (oldCap &gt; 0) &#123;\n        &#x2F;&#x2F; 超过最大值就不再扩充了，就只好随你碰撞去吧\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 没超过最大值，就扩充为原来的2倍\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold\n        newCap &#x3D; oldThr;\n    else &#123;\n        &#x2F;&#x2F; signifies using defaults\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    &#x2F;&#x2F; 计算新的resize上限\n    if (newThr &#x3D;&#x3D; 0) &#123;\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)\n        Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab;\n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 把每个bucket都移动到新的buckets中\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                oldTab[j] &#x3D; null;\n                if (e.next &#x3D;&#x3D; null)\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                else &#123;\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        &#x2F;&#x2F; 原索引\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        &#x2F;&#x2F; 原索引+oldCap\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    &#x2F;&#x2F; 原索引放到bucket里\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    &#x2F;&#x2F; 原索引+oldCap放到bucket里\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;</code></pre></li>\n<li><p>链表树化：降低单个链表长度（jdk1.8新增的特性，1.7仅有链表）</p>\n<ul>\n<li><p>当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的大小大于等于64时，将会把链表转化为红黑树，这个过程就叫treeify（树化）</p>\n</li>\n<li><p>如果table数组长度小于64，即便链表中的节点个数大于等于8，也不会触发treeify，而是触发扩容操作，将长链表拆分为短链表</p>\n</li>\n<li><p>当红黑树中节点个数比较少时，HashMap会再将其转换回链表，因为维护红黑树的成本比较高，对于少许节点，使用链表存储更高效，红黑树转换为链表的过程，叫做untreeify，促发untreeify的场景有以下两个：</p>\n<ul>\n<li><p>删除键值对：如果红黑树满足以下结构，则会触发untreeify，这个结构的红黑树的节点个数应该处于[2,6]之间，尽管treeify的阈值是8，但untreeify的阈值是[2,6]之间的某个数，之所以不相等是为了避免频繁的插入删除操作，导致节点个数在7，8之间频繁波动</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;removeTreeNode函数中\nif (root &#x3D;&#x3D; null || root.right &#x3D;&#x3D; null ||\n    (rl &#x3D; root.left) &#x3D;&#x3D; null || rl.left &#x3D;&#x3D; null) &#123;\n    tab[index] &#x3D; first.untreeify(map);  &#x2F;&#x2F; too small\n    return;\n&#125;</code></pre></li>\n<li><p>扩容：每一条链表都会分割为lo和hi两条，同理红黑树也会分割为lt和ht两个红黑树，lt中存储的是下标位置不变的节点，ht中存储的是下标位置变化的节点。不过，在构建lt和ht之前，会先统计属于lt和ht的节点个数lc和hc，如果lc小于等于6（UNTREEIFY_THRESHOLD静态常量），在新的table数组中，HashMap会使用链表来存储下标不变的节点，同理，如果hc小于等于6，在新的table数组中，HashMap会使用链表来存储下标改变的节点。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Collections</p>\n<ul>\n<li>sort()：用来对List进行排序，默认为从小到大，支持传入Comparator接口的匿名类改为降序，底层依赖Arrays<ul>\n<li>基本类型数组排序算法：JDK8及以后使用DualPivotQuickSort()，JDK7及其以前使用快排，使用不稳定排序<ul>\n<li>DualPivotQuickSort根据长度和元素类型，使用双轴快速排序算法、插入排序、计数排序、归并排序等算法来组合进行排序操作</li>\n</ul>\n</li>\n<li>对象数组排序算法：JDK8及其以后使用TimSort()，JDK7及其以前使用归并排序，使用的是稳定的排序方式<ul>\n<li>TimSort用非递归版本归并排序，归并到阈值后开始进行二分插入排序算法，即在插入时选择用二分查找来确定插入位置</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>binarySearch()：用来对已排序的List容器进行二分查找，因为涉及元素比较，所以需要传入实现Comparable接口的对象或者主动传入Comparator接口的匿名类对象<ul>\n<li><code>indexedBinarySearch</code>：查找mid使用的是链表的get函数，需要从头遍历链表来得到对应值</li>\n<li><code>iteratorBinarySearch</code>：查找mid使用的是新定义的get函数，从上一次迭代器的位置（mid）开始向前或向后查找，需要遍历的范围变小了，执行效率就变高了</li>\n</ul>\n</li>\n<li>synchronizedXXX()：JCF中的容器都是非线程安全的，当要使用线程安全的容器时，首选使用JUC并发容器，但当没有合适的JUC并发容器可以使用时，可以使用Collectinos类中的synchronizedXXX()函数来创建线程安全的容器</li>\n</ul>\n</li>\n<li><p>- </p>\n</li>\n</ol>\n","text":"Java1.关键字 true, false, 和 null 虽然不是关键字，但它们是不能用作标识符的文字和保留字 strictfp（精确浮点数，跨平台产生相同结果）、native（原生方法） class return byte try if import public boole...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[],"tags":[{"name":"language","slug":"language","count":2,"path":"api/tags/language.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Java\"><span class=\"toc-text\">Java</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">1.关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90\"><span class=\"toc-text\">2.概念辨析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%AF%AD%E6%B3%95%E7%B3%96\"><span class=\"toc-text\">3.语法糖</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95\"><span class=\"toc-text\">4.特殊语法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">5.工具类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1String\"><span class=\"toc-text\">5.1String</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2JCF%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">5.2JCF框架</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java并发","uid":"75ca176d6b382373bec123f05862c849","slug":"Java并发","date":"2023-04-13T23:56:43.000Z","updated":"2023-04-20T13:16:53.771Z","comments":true,"path":"api/articles/Java并发.json","keywords":null,"cover":[],"text":"Java并发1.线程 线程 线程状态：NEW、RUNNABLE（READY、RUNNING）、WAITING、BLOCKED、TERMINATED、TIME_WAITING 线程模型：内核线程（1:1）、用户线程（1:N）、混合线程（M:N） Java使用用户线程模型，上层JVM...","link":"","photos":[],"count_time":{"symbolsCount":"24k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"language","slug":"language","count":2,"path":"api/tags/language.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"SaToken","uid":"a7db680819d5984afbc70473b0c79529","slug":"SaToken","date":"2023-04-13T10:50:40.000Z","updated":"2023-04-20T13:17:10.291Z","comments":true,"path":"api/articles/SaToken.json","keywords":null,"cover":null,"text":"Sa-Token 一款开源的、轻量级的Java权限认证框架，主要解决：登陆认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权等问题 1.登陆认证 登陆流程 用户提交name+password参数，调用登录接口 &#x2F;&#x2F;&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"middleware","slug":"middleware","count":1,"path":"api/tags/middleware.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}