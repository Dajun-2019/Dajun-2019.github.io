{"title":"SpringCloud","uid":"2fdfe1e1ace8a4912a23a4cbc1c92824","slug":"SpringCloud","date":"2023-07-31T10:29:44.000Z","updated":"2023-07-31T10:53:24.069Z","comments":true,"path":"api/articles/SpringCloud.json","keywords":null,"cover":[],"content":"<h1 id=\"Spring-Cloud\"><a href=\"#Spring-Cloud\" class=\"headerlink\" title=\"Spring Cloud\"></a>Spring Cloud</h1><h2 id=\"1-Consul\"><a href=\"#1-Consul\" class=\"headerlink\" title=\"1.Consul\"></a>1.Consul</h2><ul>\n<li>特性：服务发现、健康检查、KV存储（服务配置）、多数据中心支持、安全的服务间通信（加密）</li>\n<li>配置一些依赖和端口信息，</li>\n</ul>\n<h2 id=\"2-Sleuth-Zipkin\"><a href=\"#2-Sleuth-Zipkin\" class=\"headerlink\" title=\"2.Sleuth+Zipkin\"></a>2.Sleuth+Zipkin</h2><ol>\n<li>Sleuth<ul>\n<li>用于分布式链路追踪，他能追踪请求和消息从而可以将消息与相应的日志条目相关联，支持导出到OpenZipkin来可视化链路</li>\n<li>sleuth主要功能是在分布式系统中提供追踪解决方案，并且兼容支持了<code>zipkin</code>(提供了链路追踪的可视化功能)</li>\n<li>zipkin原理：在服务调用的请求和响应中加入ID,表明上下游请求的关系。</li>\n<li>利用这些信息，可以可视化地分析服务调用链路和服务间的依赖关系。sleuth是对zipkin的封装，对应<code>Span</code>,<code>Trace</code>等信息的生成、接入http request,以及向Zipkin server发送采集信息等全部自动化完成。</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h2 id=\"3-Stream（Kafka-RabbitMQ）\"><a href=\"#3-Stream（Kafka-RabbitMQ）\" class=\"headerlink\" title=\"3.Stream（Kafka/RabbitMQ）\"></a>3.Stream（Kafka/RabbitMQ）</h2><ul>\n<li><p>RabbitMQ：消息队列</p>\n<ul>\n<li><p>流程图</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731185155045.png\" alt=\"image-20230731185155045\"></p>\n</li>\n<li><p>Barista</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731185214044.png\" alt=\"image-20230731185214044\"></p>\n<ul>\n<li><p>消息发送：注入Barista，如下使用</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731185226386.png\" alt=\"image-20230731185226386\"></p>\n</li>\n<li><p>消息消费</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731185239296.png\" alt=\"image-20230731185239296\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-Gateway\"><a href=\"#4-Gateway\" class=\"headerlink\" title=\"4.Gateway\"></a>4.Gateway</h2><ol>\n<li>概念：<ul>\n<li>Route（路由）：路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由</li>\n<li>Predicate（断言）：指的是Java 8 的 Function Predicate。 输入类型是Spring框架中的ServerWebExchange。 这使开发人员可以匹配HTTP请求中的所有内容，例如请求头或请求参数。如果请求与断言相匹配，则进行路由</li>\n<li>Filter（过滤器）：指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前后对请求进行修改</li>\n</ul>\n</li>\n<li>特性：动态路由、对路由指定Predicate（断言）和Filter（过滤器）、集成SpringCloud服务发现功能</li>\n<li>作用：对API接口进行路由，提供过滤功能（熔断、限流、重试）</li>\n</ol>\n<h2 id=\"5-OpenFeign\"><a href=\"#5-OpenFeign\" class=\"headerlink\" title=\"5.OpenFeign\"></a>5.OpenFeign</h2><ul>\n<li><p>开启feign：在要调用其他服务的服务的main上加<code>@EnableFeignClients</code></p>\n</li>\n<li><p>增加一个接口，里面定义要调用的服务的方法，使用MVC的方法</p>\n<ul>\n<li>name是要调用的服务的名字</li>\n<li>GetMapping是对应controller的URI</li>\n<li>下面是定义的方法，与被调用服务的方法相同</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731185046600.png\" alt=\"image-20230731185046600\"></p>\n</li>\n<li><p>在使用的地方通过将接口以依赖注入的方式（<code>@Autowired</code>），即可使用（依靠Spring来实例化），直接调用方法</p>\n</li>\n</ul>\n<h2 id=\"6-Resilience4j\"><a href=\"#6-Resilience4j\" class=\"headerlink\" title=\"6.Resilience4j\"></a>6.Resilience4j</h2><ul>\n<li><p>服务熔断：调用的服务访问不了的时候（返回500），就会产生熔断不再继续调用，可以定制对错误的处理</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731185008969.png\" alt=\"image-20230731185008969\"></p>\n</li>\n<li><p>服务限流</p>\n</li>\n</ul>\n<h2 id=\"7-Seata\"><a href=\"#7-Seata\" class=\"headerlink\" title=\"7.Seata\"></a>7.Seata</h2><ol>\n<li><p>分布式事务问题：微服务架构中，全局数据一致性没发保证产生的问题就是分布式事务问题</p>\n<ul>\n<li>单体应用下，数据的一致性有本地事务来保证</li>\n<li>而微服务应用，由于每个服务之间通过RPC来互相之间调用，分别使用独立的数据源，当有业务操作需要调用三个服务来完成时，每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性无法保证</li>\n</ul>\n</li>\n<li><p>Seata简介：一款开源的分布式事务解决方案，提供了AT、TCC、SAGA、XA事务模式</p>\n<ul>\n<li><p>定义一个分布式事务：可以把分布式事务理解成一个包含了若干分支事务的全局事务，全局事务主要协调所包含的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外分支事务本身就是一个满足ACID的本地事务</p>\n</li>\n<li><p>协议分布式事务处理过程的三个组件</p>\n<ul>\n<li><p>Transaction Coordinator（TC）：维护全局事务的运行状态，负责协调并驱动全局事务的提交和回滚</p>\n</li>\n<li><p>Transaction Manager（TM）：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交和全局回滚的决议</p>\n</li>\n<li><p>Resource Manager（RM）：控制分支事务，负责分支注册、状态汇报，并接收TC的指令、驱动分支事务的提交和回滚</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731184716386.png\" alt=\"image-20230731184716386\"></p>\n</li>\n</ul>\n</li>\n<li><p>典型的分布式事务过程</p>\n<ul>\n<li>TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 <code>XID</code>；</li>\n<li><code>XID</code> 在微服务调用链路的上下文中传播；</li>\n<li>RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖；</li>\n<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议；</li>\n<li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>使用</p>\n<ul>\n<li><p>下载seata-server，修改<code>conf</code>目录下的<code>file.conf</code>配置文件，主要修改自定义事务组名称，事务日志存储模式为<code>db</code>及数据库连接信息</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">service &#123;\n  #vgroup-&gt;rgroup\n  vgroup_mapping.fsp_tx_group &#x3D; &quot;default&quot; #修改事务组名称为：fsp_tx_group，和客户端自定义的名称对应\n  #only support single node\n  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;\n  #degrade current not support\n  enableDegrade &#x3D; false\n  #disable\n  disable &#x3D; false\n  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent\n  max.commit.retry.timeout &#x3D; &quot;-1&quot;\n  max.rollback.retry.timeout &#x3D; &quot;-1&quot;\n&#125;\n\n## transaction log store\nstore &#123;\n  ## store mode: file、db\n  mode &#x3D; &quot;db&quot; #修改此处将事务信息存储到数据库中\n\n  ## database store\n  db &#123;\n    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)&#x2F;BasicDataSource(dbcp) etc.\n    datasource &#x3D; &quot;dbcp&quot;\n    ## mysql&#x2F;oracle&#x2F;h2&#x2F;oceanbase etc.\n    db-type &#x3D; &quot;mysql&quot;\n    driver-class-name &#x3D; &quot;com.mysql.jdbc.Driver&quot;\n    url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;seat-server&quot; #修改数据库连接地址\n    user &#x3D; &quot;root&quot; #修改数据库用户名\n    password &#x3D; &quot;root&quot; #修改数据库密码\n    min-conn &#x3D; 1\n    max-conn &#x3D; 3\n    global.table &#x3D; &quot;global_table&quot;\n    branch.table &#x3D; &quot;branch_table&quot;\n    lock-table &#x3D; &quot;lock_table&quot;\n    query-limit &#x3D; 100\n  &#125;\n&#125;</code></pre></li>\n<li><p>由于使用了<code>db</code>模式存储事务日志，所以需要创建一个<code>seat-server</code>数据库，建表sql在<code>seata-server</code>的<code>/conf/db_store.sql</code>中；</p>\n</li>\n<li><p>修改<code>conf</code>目录下的<code>registry.conf</code>配置文件，指明注册中心为<code>nacos</code>，及修改<code>nacos</code>连接信息即可；</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">registry &#123;\n  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa\n  type &#x3D; &quot;nacos&quot; #改为nacos\n\n  nacos &#123;\n    serverAddr &#x3D; &quot;localhost:8848&quot; #改为nacos的连接地址\n    namespace &#x3D; &quot;&quot;\n    cluster &#x3D; &quot;default&quot;\n  &#125;\n&#125;</code></pre></li>\n<li><p>先启动Nacos，再使用seata-server中<code>/bin/seata-server.bat</code>文件启动seata-server</p>\n</li>\n<li><p>数据库准备</p>\n<ul>\n<li><p>创建并初始化数据库</p>\n<ul>\n<li>seat-order：存储订单的数据库；</li>\n<li>seat-storage：存储库存的数据库；</li>\n<li>seat-account：存储账户信息的数据库。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TABLE &#96;order&#96; (\n  &#96;id&#96; bigint(11) NOT NULL AUTO_INCREMENT,\n  &#96;user_id&#96; bigint(11) DEFAULT NULL COMMENT &#39;用户id&#39;,\n  &#96;product_id&#96; bigint(11) DEFAULT NULL COMMENT &#39;产品id&#39;,\n  &#96;count&#96; int(11) DEFAULT NULL COMMENT &#39;数量&#39;,\n  &#96;money&#96; decimal(11,0) DEFAULT NULL COMMENT &#39;金额&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;7 DEFAULT CHARSET&#x3D;utf8;\n\nALTER TABLE &#96;order&#96; ADD COLUMN &#96;status&#96; int(1) DEFAULT NULL COMMENT &#39;订单状态：0：创建中；1：已完结&#39; AFTER &#96;money&#96; ;\n\nCREATE TABLE &#96;storage&#96; (\n                         &#96;id&#96; bigint(11) NOT NULL AUTO_INCREMENT,\n                         &#96;product_id&#96; bigint(11) DEFAULT NULL COMMENT &#39;产品id&#39;,\n                         &#96;total&#96; int(11) DEFAULT NULL COMMENT &#39;总库存&#39;,\n                         &#96;used&#96; int(11) DEFAULT NULL COMMENT &#39;已用库存&#39;,\n                         &#96;residue&#96; int(11) DEFAULT NULL COMMENT &#39;剩余库存&#39;,\n                         PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8;\n\nINSERT INTO &#96;seat-storage&#96;.&#96;storage&#96; (&#96;id&#96;, &#96;product_id&#96;, &#96;total&#96;, &#96;used&#96;, &#96;residue&#96;) VALUES (&#39;1&#39;, &#39;1&#39;, &#39;100&#39;, &#39;0&#39;, &#39;100&#39;);\n\nCREATE TABLE &#96;account&#96; (\n  &#96;id&#96; bigint(11) NOT NULL AUTO_INCREMENT COMMENT &#39;id&#39;,\n  &#96;user_id&#96; bigint(11) DEFAULT NULL COMMENT &#39;用户id&#39;,\n  &#96;total&#96; decimal(10,0) DEFAULT NULL COMMENT &#39;总额度&#39;,\n  &#96;used&#96; decimal(10,0) DEFAULT NULL COMMENT &#39;已用余额&#39;,\n  &#96;residue&#96; decimal(10,0) DEFAULT &#39;0&#39; COMMENT &#39;剩余可用额度&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8;\n\nINSERT INTO &#96;seat-account&#96;.&#96;account&#96; (&#96;id&#96;, &#96;user_id&#96;, &#96;total&#96;, &#96;used&#96;, &#96;residue&#96;) VALUES (&#39;1&#39;, &#39;1&#39;, &#39;1000&#39;, &#39;0&#39;, &#39;1000&#39;);</code></pre></li>\n<li><p>创建日志回滚表：使用Seata还需要在每个数据库中创建日志表，建表sql在seata-server的<code>/conf/db_undo_log.sql</code>中</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731184802268.png\" alt=\"image-20230731184802268\"></p>\n</li>\n<li><p>制造一个分布式事务问题</p>\n<ul>\n<li><p>修改application.yml文件，自定义事务组的名称</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring:\n  cloud:\n    alibaba:\n      seata:\n        tx-service-group: fsp_tx_group #自定义事务组名称需要与seata-server中的对应</code></pre></li>\n<li><p>在启动类中取消数据源的自动创建</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootApplication(exclude &#x3D; DataSourceAutoConfiguration.class)\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class SeataOrderServiceApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SeataOrderServiceApplication.class, args);\n    &#125;\n\n&#125;</code></pre></li>\n<li><p>创建配置使用Seata对数据源进行代理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 使用Seata对数据源进行代理\n * Created by macro on 2019&#x2F;11&#x2F;11.\n *&#x2F;\n@Configuration\npublic class DataSourceProxyConfig &#123;\n\n    @Value(&quot;$&#123;mybatis.mapperLocations&#125;&quot;)\n    private String mapperLocations;\n\n    @Bean\n    @ConfigurationProperties(prefix &#x3D; &quot;spring.datasource&quot;)\n    public DataSource druidDataSource()&#123;\n        return new DruidDataSource();\n    &#125;\n\n    @Bean\n    public DataSourceProxy dataSourceProxy(DataSource dataSource) &#123;\n        return new DataSourceProxy(dataSource);\n    &#125;\n\n    @Bean\n    public SqlSessionFactory sqlSessionFactoryBean(DataSourceProxy dataSourceProxy) throws Exception &#123;\n        SqlSessionFactoryBean sqlSessionFactoryBean &#x3D; new SqlSessionFactoryBean();\n        sqlSessionFactoryBean.setDataSource(dataSourceProxy);\n        sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver()\n                .getResources(mapperLocations));\n        sqlSessionFactoryBean.setTransactionFactory(new SpringManagedTransactionFactory());\n        return sqlSessionFactoryBean.getObject();\n    &#125;\n\n&#125;</code></pre></li>\n<li><p>使用<code>@GlobalTransactional</code>注解开启分布式事务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.macro.cloud.service.impl;\n\nimport com.macro.cloud.dao.OrderDao;\nimport com.macro.cloud.domain.Order;\nimport com.macro.cloud.service.AccountService;\nimport com.macro.cloud.service.OrderService;\nimport com.macro.cloud.service.StorageService;\nimport io.seata.spring.annotation.GlobalTransactional;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n&#x2F;**\n * 订单业务实现类\n * Created by macro on 2019&#x2F;11&#x2F;11.\n *&#x2F;\n@Service\npublic class OrderServiceImpl implements OrderService &#123;\n\n    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(OrderServiceImpl.class);\n\n    @Autowired\n    private OrderDao orderDao;\n    @Autowired\n    private StorageService storageService;\n    @Autowired\n    private AccountService accountService;\n\n    &#x2F;**\n     * 创建订单-&gt;调用库存服务扣减库存-&gt;调用账户服务扣减账户余额-&gt;修改订单状态\n     *&#x2F;\n    @Override\n    @GlobalTransactional(name &#x3D; &quot;fsp-create-order&quot;,rollbackFor &#x3D; Exception.class)\n    public void create(Order order) &#123;\n        LOGGER.info(&quot;-------&gt;下单开始&quot;);\n        &#x2F;&#x2F;本应用创建订单\n        orderDao.create(order);\n\n        &#x2F;&#x2F;远程调用库存服务扣减库存\n        LOGGER.info(&quot;-------&gt;order-service中扣减库存开始&quot;);\n        storageService.decrease(order.getProductId(),order.getCount());\n        LOGGER.info(&quot;-------&gt;order-service中扣减库存结束:&#123;&#125;&quot;,order.getId());\n\n        &#x2F;&#x2F;远程调用账户服务扣减余额\n        LOGGER.info(&quot;-------&gt;order-service中扣减余额开始&quot;);\n        accountService.decrease(order.getUserId(),order.getMoney());\n        LOGGER.info(&quot;-------&gt;order-service中扣减余额结束&quot;);\n\n        &#x2F;&#x2F;修改订单状态为已完成\n        LOGGER.info(&quot;-------&gt;order-service中修改订单状态开始&quot;);\n        orderDao.update(order.getUserId(),0);\n        LOGGER.info(&quot;-------&gt;order-service中修改订单状态结束&quot;);\n\n        LOGGER.info(&quot;-------&gt;下单结束&quot;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>当<code>@GlobalTransactional</code>注解标记的方法内部，有某个方法超时后，整个方法都不会执行，数据库内部状态不会改变</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"8-SpringBootAdmin\"><a href=\"#8-SpringBootAdmin\" class=\"headerlink\" title=\"8.SpringBootAdmin\"></a>8.SpringBootAdmin</h2><ul>\n<li><p>正常是通过访问URL来通过输出看状态信息</p>\n</li>\n<li><p><code>SpringBootAdmin</code>第三方提供，为应用程序提供一套管理界面，集中展示<code>Actuator</code>相关的内容</p>\n</li>\n<li><p>使用：可以增加security来增加用户名和密码，并进行一些配置暴漏哪些可以直接访问</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731184934561.png\" alt=\"image-20230731184934561\"></p>\n</li>\n</ul>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2>","feature":true,"text":"Spring Cloud1.Consul 特性：服务发现、健康检查、KV存储（服务配置）、多数据中心支持、安全的服务间通信（加密） 配置一些依赖和端口信息， 2.Sleuth+Zipkin Sleuth 用于分布式链路追踪，他能追踪请求和消息从而可以将消息与相应的日志条目相关联，...","link":"","photos":[],"count_time":{"symbolsCount":"9.9k","symbolsTime":"9 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring-Cloud\"><span class=\"toc-text\">Spring Cloud</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Consul\"><span class=\"toc-text\">1.Consul</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Sleuth-Zipkin\"><span class=\"toc-text\">2.Sleuth+Zipkin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Stream%EF%BC%88Kafka-RabbitMQ%EF%BC%89\"><span class=\"toc-text\">3.Stream（Kafka&#x2F;RabbitMQ）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-Gateway\"><span class=\"toc-text\">4.Gateway</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-OpenFeign\"><span class=\"toc-text\">5.OpenFeign</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Resilience4j\"><span class=\"toc-text\">6.Resilience4j</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-Seata\"><span class=\"toc-text\">7.Seata</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-SpringBootAdmin\"><span class=\"toc-text\">8.SpringBootAdmin</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95\"><span class=\"toc-text\">附录</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"MQ","uid":"f8ef4e10e9f952ff4ed3590ecc45cea3","slug":"MQ","date":"2023-07-30T08:42:34.000Z","updated":"2023-07-30T08:44:34.863Z","comments":true,"path":"api/articles/MQ.json","keywords":null,"cover":[],"text":"基础知识 消息模型 生产者-消费者模型与发布订阅模型：生产者-消费者模型适用于单消费者的环境，当有多个消费者的时候就会产生消费者的竞争关系，所以出现了发布订阅模型，发布者将消息发送到主题（Topic，即消息容器）中，然后订阅该主题的订阅者就可以收到发送者发送的消息了 Rabbit...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}