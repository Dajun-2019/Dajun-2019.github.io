{"title":"SaToken","uid":"a7db680819d5984afbc70473b0c79529","slug":"SaToken","date":"2023-04-13T11:03:17.000Z","updated":"2023-04-15T00:08:38.471Z","comments":true,"path":"api/articles/SaToken.json","keywords":null,"cover":null,"content":"<h1 id=\"Sa-Token\"><a href=\"#Sa-Token\" class=\"headerlink\" title=\"Sa-Token\"></a>Sa-Token</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>一款开源的、轻量级的Java权限认证框架，主要解决：登陆认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权等问题</p></blockquote>\n<h2 id=\"1-登陆认证\"><a href=\"#1-登陆认证\" class=\"headerlink\" title=\"1.登陆认证\"></a>1.登陆认证</h2><ol>\n<li><p>登陆流程</p>\n<ul>\n<li><p>用户提交<code>name</code>+<code>password</code>参数，调用登录接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;示例&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@RequestMapping(&quot;doLogin&quot;)\npublic CommonResult doLogin(String name, String pwd)&#123;\n\t&#x2F;&#x2F;将用户传过来的name和pwd与数据库中的进行比对\n\tif(&quot;admin&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd))&#123;\n\t\t&#x2F;&#x2F;根据账号id，进行登陆\n\t\t&#x2F;&#x2F;id为要登陆的账号，类型建议使用long、int、String类型\n\t\tStpUtil.login(10001);\n\t\treturn CommonResult.success(&quot;登陆成功&quot;)；\n\t&#125;\n\treturn CommonResult.failed(&quot;登录失败&quot;)；\n&#125;</code></pre></li>\n<li><p>登陆成功，通过Cookie上下文返回给前端这个用户的token，该用户后续请求都带上这个token，服务器可以根据token判断此会话是否登陆成功</p>\n</li>\n<li><p>如果校验未通过，则抛出异常，告知其需要先进行登陆</p>\n</li>\n</ul>\n</li>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 登录测试 \n *&#x2F;\n@RestController\n@RequestMapping(&quot;&#x2F;acc&#x2F;&quot;)\npublic class LoginController &#123;\n\n    &#x2F;&#x2F; 测试登录  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;doLogin?name&#x3D;zhang&amp;pwd&#x3D;123456&gt;\n    @RequestMapping(&quot;doLogin&quot;)\n    public SaResult doLogin(String name, String pwd) &#123;\n        &#x2F;&#x2F; 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 \n        if(&quot;zhang&quot;.equals(name) &amp;&amp; &quot;123456&quot;.equals(pwd)) &#123;\n            StpUtil.login(10001);\n            return SaResult.ok(&quot;登录成功&quot;);\n        &#125;\n        return SaResult.error(&quot;登录失败&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 查询登录状态  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;isLogin&gt;\n    @RequestMapping(&quot;isLogin&quot;)\n    public SaResult isLogin() &#123;\n        return SaResult.ok(&quot;是否登录：&quot; + StpUtil.isLogin());\n    &#125;\n    \n    &#x2F;&#x2F; 查询 Token 信息  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;tokenInfo&gt;\n    @RequestMapping(&quot;tokenInfo&quot;)\n    public SaResult tokenInfo() &#123;\n        return SaResult.data(StpUtil.getTokenInfo());\n    &#125;\n    \n    &#x2F;&#x2F; 测试注销  ---- &lt;http:&#x2F;&#x2F;localhost:8081&#x2F;acc&#x2F;logout&gt;\n    @RequestMapping(&quot;logout&quot;)\n    public SaResult logout() &#123;\n        StpUtil.logout();\n        return SaResult.ok();\n    &#125;\n    \n&#125;</code></pre></li>\n</ol>\n<h2 id=\"2-权限认证\"><a href=\"#2-权限认证\" class=\"headerlink\" title=\"2.权限认证\"></a>2.权限认证</h2><ol>\n<li><p><code>@RestControllerAdvice</code>注解</p>\n<ul>\n<li><p>与切面有关的注解，作用范围为项目中使用了<code>@RequestMapping</code>的类</p>\n</li>\n<li><p>与<code>@ExceptionHandler</code>的组合使用：两个注解组合使用是一个全局异常处理方法，发生了对应异常后，进入<code>@ExceptionHandler</code>修饰的方法，在这里处理全局异常（打印到日志里）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;拦截全局异常&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@RestControllerAdvice\npublic class GlobalExceptionHandler &#123;\n    &#x2F;&#x2F; 全局异常拦截 \n    @ExceptionHandler\n    public SaResult handlerException(Exception e) &#123;\n        e.printStackTrace(); \n        return SaResult.error(e.getMessage());\n    &#125;\n&#125;</code></pre></li>\n<li><p>底层原理：<a href=\"https://juejin.cn/post/7025484367539470344\">https://juejin.cn/post/7025484367539470344</a></p>\n<ul>\n<li><code>ExceptionHandlerExceptionResolver</code>实现了<code>InitializingBean</code>接口的<code>afterPropertiesSet()</code>方法，方法内调用<code>initExceptionHandlerAdviceCache()</code>扫描所有带<code>@ControllerAdvice</code>注解的类放入到<code>adviceBeans</code>链表里，然后将所有<code>adviceBeans</code>转换为<code>ExceptionHandlerMethodResolver</code>，转换过程中扫描每个<code>ControllerAdvice</code>中的带<code>@ExceptionHandler</code>注解的方法，再取出带@ExceptionHandler所处理的Exception类型，以类型为key，方法为value插入到<code>mappedMethods</code>这个<code>map</code>中进行缓存，最后将<code>adviceBean</code><em>和</em><code>resolver</code>插入到<code>exceptionHandlerAdviceCache</code>中进行缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>API</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;权限认证&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; 获取：当前账号所拥有的权限集合\nStpUtil.getPermissionList();\n\n&#x2F;&#x2F; 判断：当前账号是否含有指定权限, 返回 true 或 false\nStpUtil.hasPermission(&quot;user.add&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限, 如果验证未通过，则抛出异常: NotPermissionException \nStpUtil.checkPermission(&quot;user.add&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限 [指定多个，必须全部验证通过]\nStpUtil.checkPermissionAnd(&quot;user.add&quot;, &quot;user.delete&quot;, &quot;user.get&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定权限 [指定多个，只要其一验证通过即可]\nStpUtil.checkPermissionOr(&quot;user.add&quot;, &quot;user.delete&quot;, &quot;user.get&quot;);\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;角色校验&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; 获取：当前账号所拥有的角色集合\nStpUtil.getRoleList();\n\n&#x2F;&#x2F; 判断：当前账号是否拥有指定角色, 返回 true 或 false\nStpUtil.hasRole(&quot;super-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识, 如果验证未通过，则抛出异常: NotRoleException\nStpUtil.checkRole(&quot;super-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识 [指定多个，必须全部验证通过]\nStpUtil.checkRoleAnd(&quot;super-admin&quot;, &quot;shop-admin&quot;);        \n\n&#x2F;&#x2F; 校验：当前账号是否含有指定角色标识 [指定多个，只要其一验证通过即可] \nStpUtil.checkRoleOr(&quot;super-admin&quot;, &quot;shop-admin&quot;);</code></pre></li>\n<li><p>注解鉴权</p>\n<ul>\n<li><p>注解示例</p>\n<ul>\n<li><code>@SaCheckLogin</code>: 登录校验 —— 只有登录之后才能进入该方法。</li>\n<li><code>@SaCheckRole(&quot;admin&quot;)</code>: 角色校验 —— 必须具有指定角色标识才能进入该方法。</li>\n<li><code>@SaCheckPermission(&quot;user:add&quot;)</code>: 权限校验 —— 必须具有指定权限才能进入该方法。</li>\n<li><code>@SaCheckSafe</code>: 二级认证校验 —— 必须二级认证之后才能进入该方法。</li>\n<li><code>@SaCheckBasic</code>: HttpBasic校验 —— 只有通过 Basic 认证后才能进入该方法。</li>\n<li><code>@SaIgnore</code>：忽略校验 —— 表示被修饰的方法或类无需进行注解鉴权和路由拦截器鉴权。</li>\n<li><code>@SaCheckDisable(&quot;comment&quot;)</code>：账号服务封禁校验 —— 校验当前账号指定服务是否被封禁。</li>\n</ul>\n</li>\n<li><p>注册拦截器：开启Sa-Token的全局蓝机器到项目中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册 Sa-Token 拦截器，打开注解式鉴权功能 \n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册 Sa-Token 拦截器，打开注解式鉴权功能 \n        registry.addInterceptor(new SaInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;);    \n    &#125;\n&#125;</code></pre></li>\n<li><p>使用注解鉴权</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 登录校验：只有登录之后才能进入该方法 \n@SaCheckLogin                        \n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n\n&#x2F;&#x2F; 角色校验：必须具有指定角色才能进入该方法 \n@SaCheckRole(&quot;super-admin&quot;)        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 权限校验：必须具有指定权限才能进入该方法 \n@SaCheckPermission(&quot;user-add&quot;)        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 二级认证校验：必须二级认证之后才能进入该方法 \n@SaCheckSafe()        \n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; Http Basic 校验：只有通过 Basic 认证后才能进入该方法 \n@SaCheckBasic(account &#x3D; &quot;sa:123456&quot;)\n@RequestMapping(&quot;add&quot;)\npublic String add() &#123;\n    return &quot;用户增加&quot;;\n&#125;\n\n&#x2F;&#x2F; 校验当前账号是否被封禁 comment 服务，如果已被封禁会抛出异常，无法进入方法 \n@SaCheckDisable(&quot;comment&quot;)                \n@RequestMapping(&quot;send&quot;)\npublic String send() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;\n&#x2F;&#x2F; 此接口加上了 @SaIgnore 可以游客访问 ，表示一个接口忽略认证\n@SaIgnore\n@RequestMapping(&quot;getList&quot;)\npublic SaResult getList() &#123;\n    &#x2F;&#x2F; ... \n    return SaResult.ok(); \n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-路由拦截鉴权\"><a href=\"#3-路由拦截鉴权\" class=\"headerlink\" title=\"3.路由拦截鉴权\"></a>3.路由拦截鉴权</h2><ol>\n<li><p>注册Sa-Token路由拦截器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;注册了一个基于StpUtil.checkLogin()的登陆校验拦截器，除了&#x2F;user&#x2F;doLogin接口都需要登陆才能访问\n@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册 Sa-Token 拦截器，校验规则为 StpUtil.checkLogin() 登录校验。\n        registry.addInterceptor(new SaInterceptor(handle -&gt; StpUtil.checkLogin()))\n                .addPathPatterns(&quot;&#x2F;**&quot;)\n                .excludePathPatterns(&quot;&#x2F;user&#x2F;doLogin&quot;); \n    &#125;\n&#125;</code></pre></li>\n<li><p>完整的配置方式示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SaTokenConfigure implements WebMvcConfigurer &#123;\n    &#x2F;&#x2F; 注册 Sa-Token 的拦截器\n    @Override\n    public void addInterceptors(InterceptorRegistry registry) &#123;\n        &#x2F;&#x2F; 注册路由拦截器，自定义认证规则 \n        registry.addInterceptor(new SaInterceptor(handler -&gt; &#123;\n            \n            &#x2F;&#x2F; 登录校验 -- 拦截所有路由，并排除&#x2F;user&#x2F;doLogin 用于开放登录 \n            SaRouter.match(&quot;&#x2F;**&quot;, &quot;&#x2F;user&#x2F;doLogin&quot;, r -&gt; StpUtil.checkLogin());\n\n            &#x2F;&#x2F; 角色校验 -- 拦截以 admin 开头的路由，必须具备 admin 角色或者 super-admin 角色才可以通过认证 \n            SaRouter.match(&quot;&#x2F;admin&#x2F;**&quot;, r -&gt; StpUtil.checkRoleOr(&quot;admin&quot;, &quot;super-admin&quot;));\n\n            &#x2F;&#x2F; 权限校验 -- 不同模块校验不同权限 \n            SaRouter.match(&quot;&#x2F;user&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;user&quot;));\n            SaRouter.match(&quot;&#x2F;admin&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;admin&quot;));\n            SaRouter.match(&quot;&#x2F;goods&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;goods&quot;));\n            SaRouter.match(&quot;&#x2F;orders&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;orders&quot;));\n            SaRouter.match(&quot;&#x2F;notice&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;notice&quot;));\n            SaRouter.match(&quot;&#x2F;comment&#x2F;**&quot;, r -&gt; StpUtil.checkPermission(&quot;comment&quot;));\n            \n            &#x2F;&#x2F; 甚至你可以随意的写一个打印语句\n            SaRouter.match(&quot;&#x2F;**&quot;, r -&gt; System.out.println(&quot;----啦啦啦----&quot;));\n\n            &#x2F;&#x2F; 连缀写法\n            SaRouter.match(&quot;&#x2F;**&quot;).check(r -&gt; System.out.println(&quot;----啦啦啦----&quot;));\n            \n        &#125;)).addPathPatterns(&quot;&#x2F;**&quot;);\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"4-Session会话\"><a href=\"#4-Session会话\" class=\"headerlink\" title=\"4.Session会话\"></a>4.Session会话</h2><ol>\n<li><p>Session是会话中专业的数据缓存组件，通过Session可以缓存一些高频读写的数据，提高程序性能。在Sa-Token中，Session分为三种</p>\n<ul>\n<li><code>User-Session</code>: 指的是框架为每个 账号id 分配的 Session</li>\n<li><code>Token-Session</code>: 指的是框架为每个 token 分配的 Session</li>\n<li><code>Custom-Session</code>: 指的是以一个 特定的值 作为SessionId，来分配的 Session</li>\n</ul>\n</li>\n<li><p>在Session上存取值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 写值 \nsession.set(&quot;name&quot;, &quot;zhang&quot;); \n\n&#x2F;&#x2F; 写值 (只有在此key原本无值的时候才会写入)\nsession.setDefaultValue(&quot;name&quot;, &quot;zhang&quot;);\n\n&#x2F;&#x2F; 取值\nsession.get(&quot;name&quot;);\n\n&#x2F;&#x2F; 取值 (指定默认值)\nsession.get(&quot;name&quot;, &quot;&lt;defaultValue&gt;&quot;); \n\n&#x2F;&#x2F; 取值 (若无值则执行参数方法, 之后将结果保存到此键名下,并返回此结果   若有值则直接返回, 无需执行参数方法)\nsession.get(&quot;name&quot;, () -&gt; &#123;\n            return ...;\n        &#125;);\n\n&#x2F;&#x2F; ---------- 数据类型转换： ----------\nsession.getInt(&quot;age&quot;);         &#x2F;&#x2F; 取值 (转int类型)\nsession.getLong(&quot;age&quot;);        &#x2F;&#x2F; 取值 (转long类型)\nsession.getString(&quot;name&quot;);     &#x2F;&#x2F; 取值 (转String类型)\nsession.getDouble(&quot;result&quot;);   &#x2F;&#x2F; 取值 (转double类型)\nsession.getFloat(&quot;result&quot;);    &#x2F;&#x2F; 取值 (转float类型)\nsession.getModel(&quot;key&quot;, Student.class);     &#x2F;&#x2F; 取值 (指定转换类型)\nsession.getModel(&quot;key&quot;, Student.class, &lt;defaultValue&gt;);  &#x2F;&#x2F; 取值 (指定转换类型, 并指定值为Null时返回的默认值)\n\n&#x2F;&#x2F; 是否含有某个key (返回true或false)\nsession.has(&quot;key&quot;); \n\n&#x2F;&#x2F; 删值 \nsession.delete(&#39;name&#39;);          \n\n&#x2F;&#x2F; 清空所有值 \nsession.clear();                 \n\n&#x2F;&#x2F; 获取此 Session 的所有key (返回Set&lt;String&gt;)\nsession.keys();\n\n&#x2F;&#x2F; 返回此 Session 的id \nsession.getId();                          \n\n&#x2F;&#x2F; 返回此 Session 的创建时间 (时间戳) \nsession.getCreateTime();                  \n\n&#x2F;&#x2F; 返回此 Session 会话上的底层数据对象（如果更新map里的值，请调用session.update()方法避免产生脏数据）\nsession.getDataMap();                     \n\n&#x2F;&#x2F; 将这个 Session 从持久库更新一下\nsession.update();                         \n\n&#x2F;&#x2F; 注销此 Session 会话 (从持久库删除此Session)\nsession.logout();</code></pre></li>\n</ol>\n<h2 id=\"5-框架配置\"><a href=\"#5-框架配置\" class=\"headerlink\" title=\"5.框架配置\"></a>5.框架配置</h2><pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">############## Sa-Token 配置 (文档: &lt;https:&#x2F;&#x2F;sa-token.cc&gt;) ##############\nsa-token: \n    # token名称 (同时也是cookie名称)\n    token-name: satoken\n    # token有效期，单位s 默认30天, -1代表永不过期 \n    timeout: 2592000\n    # token临时有效期 (指定时间内无操作就视为token过期) 单位: 秒\n    activity-timeout: -1\n    # 是否允许同一账号并发登录 (为true时允许一起登录, 为false时新登录挤掉旧登录) \n    is-concurrent: true\n    # 在多人登录同一账号时，是否共用一个token (为true时所有登录共用一个token, 为false时每次登录新建一个token) \n    is-share: true\n    # token风格\n    token-style: uuid\n    # 是否输出操作日志 \n    is-log: false</code></pre>\n\n<h2 id=\"6-Sa-Token集成Redis\"><a href=\"#6-Sa-Token集成Redis\" class=\"headerlink\" title=\"6.Sa-Token集成Redis\"></a>6.Sa-Token集成Redis</h2><ol>\n<li><p>Maven</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!-- Sa-Token 整合 Redis （使用 jdk 默认序列化方式） --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;cn.dev33&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;sa-token-dao-redis&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.34.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n&lt;!-- 提供Redis连接池 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;</code></pre></li>\n<li><p>配置</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">spring: \n    # redis配置 \n    redis:\n        # Redis数据库索引（默认为0）\n        database: 1\n        # Redis服务器地址\n        host: 127.0.0.1\n        # Redis服务器连接端口\n        port: 6379\n        # Redis服务器连接密码（默认为空）\n        # password: \n        # 连接超时时间\n        timeout: 10s\n        lettuce:\n            pool:\n                # 连接池最大连接数\n                max-active: 200\n                # 连接池最大阻塞等待时间（使用负值表示没有限制）\n                max-wait: -1ms\n                # 连接池中的最大空闲连接\n                max-idle: 10\n                # 连接池中的最小空闲连接\n                min-idle: 0</code></pre></li>\n</ol>\n<h2 id=\"7-前后端分离\"><a href=\"#7-前后端分离\" class=\"headerlink\" title=\"7.前后端分离\"></a>7.前后端分离</h2><ol>\n<li><p>常规Web端可以使用Cookie进行鉴权（后端控制写入、请求自动提交），但是在app、小程序等前后端分离的场景，一般没有Cookie这一功能，可以通过如下方式</p>\n<ul>\n<li><p>不能后端控制写入了，就前端自己写入。（难点在<strong>后端如何将 Token 传递到前端</strong>）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 登录接口\n@RequestMapping(&quot;doLogin&quot;)\npublic SaResult doLogin() &#123;\n    &#x2F;&#x2F; 第1步，先登录上 \n    StpUtil.login(10001);\n    &#x2F;&#x2F; 第2步，获取 Token 相关参数(tokenName和tokenValue)\n    SaTokenInfo tokenInfo &#x3D; StpUtil.getTokenInfo();\n    &#x2F;&#x2F; 第3步，返回给前端，并保存在前端\n    return SaResult.data(tokenInfo);\n&#125;</code></pre></li>\n<li><p>每次请求不能自动提交了，那就手动提交。（难点在<strong>前端如何将 Token 传递到后端</strong>，同时<strong>后端将其读取出来</strong>）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 1、首先在登录时，将tokenName和tokenValue一起存储在本地，例如：\nuni.setStorageSync(&#39;tokenName&#39;, tokenName); \nuni.setStorageSync(&#39;tokenValue&#39;, tokenValue); \n\n&#x2F;&#x2F; 2、在发起ajax的地方，获取这两个值, 并组织到head里 \nvar tokenName &#x3D; uni.getStorageSync(&#39;tokenName&#39;);    &#x2F;&#x2F; 从本地缓存读取tokenName值\nvar tokenValue &#x3D; uni.getStorageSync(&#39;tokenValue&#39;);    &#x2F;&#x2F; 从本地缓存读取tokenValue值\nvar header &#x3D; &#123;\n    &quot;content-type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;\n&#125;;\nif (tokenName !&#x3D; undefined &amp;&amp; tokenName !&#x3D; &#39;&#39;) &#123;\n    header[tokenName] &#x3D; tokenValue;\n&#125;\n\n&#x2F;&#x2F; 3、后续在发起请求时将 header 对象塞到请求头部 \nuni.request(&#123;\n    url: &#39;&lt;https:&#x2F;&#x2F;www.example.com&#x2F;request&gt;&#39;, &#x2F;&#x2F; 仅为示例，并非真实接口地址。\n    header: header,\n    success: (res) &#x3D;&gt; &#123;\n        console.log(res.data);    \n    &#125;\n&#125;);</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"8-密码加密\"><a href=\"#8-密码加密\" class=\"headerlink\" title=\"8.密码加密\"></a>8.密码加密</h2><ol>\n<li><p>封装的加密算法</p>\n<ul>\n<li><p>摘要加密（md5、sha1、sha256）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; md5加密 \nSaSecureUtil.md5(&quot;123456&quot;);\n\n&#x2F;&#x2F; sha1加密 \nSaSecureUtil.sha1(&quot;123456&quot;);\n\n&#x2F;&#x2F; sha256加密 \nSaSecureUtil.sha256(&quot;123456&quot;);</code></pre></li>\n<li><p>对称加密（AES）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 定义秘钥和明文\nString key &#x3D; &quot;123456&quot;;\nString text &#x3D; &quot;Sa-Token 一个轻量级java权限认证框架&quot;;\n\n&#x2F;&#x2F; 加密 \nString ciphertext &#x3D; SaSecureUtil.aesEncrypt(key, text);\nSystem.out.println(&quot;AES加密后：&quot; + ciphertext);\n\n&#x2F;&#x2F; 解密 \nString text2 &#x3D; SaSecureUtil.aesDecrypt(key, ciphertext);\nSystem.out.println(&quot;AES解密后：&quot; + text2);</code></pre></li>\n<li><p>非对称加密（RSA）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 定义私钥和公钥 \nString privateKey &#x3D; &quot;MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAO+wmt01pwm9lHMdq7A8gkEigk0XKMfjv+4IjAFhWCSiTeP7dtlnceFJbkWxvbc7Qo3fCOpwmfcskwUc3VSgyiJkNJDs9ivPbvlt8IU2bZ+PBDxYxSCJFrgouVOpAr8ar&#x2F;b6gNuYTi1vt3FkGtSjACFb002&#x2F;68RKUTye8&#x2F;tdcVilAgMBAAECgYA1COmrSqTUJeuD8Su9ChZ0HROhxR8T45PjMmbwIz7ilDsR1+E7R4VOKPZKW4Kz2VvnklMhtJqMs4MwXWunvxAaUFzQTTg2Fu&#x2F;WU8Y9ha14OaWZABfChMZlpkmpJW9arKmI22ZuxCEsFGxghTiJQ3tK8npj5IZq5vk+6mFHQ6aJAQJBAPghz91Dpuj+0bOUfOUmzi22obWCBncAD&#x2F;0CqCLnJlpfOoa9bOcXSusGuSPuKy5KiGyblHMgKI6bq7gcM2DWrGUCQQD3SkOcmia2s&#x2F;6i7DUEzMKaB0bkkX4Ela&#x2F;xrfV+A3GzTPv9bIBamu0VIHznuiZbeNeyw7sVo4&#x2F;GTItq&#x2F;zn2QJdBAkEA8xHsVoyXTVeShaDIWJKTFyT5dJ1TR++&#x2F;udKIcuiNIap34tZdgGPI+EM1yoTduBM7YWlnGwA9urW0mj7F9e9WIQJAFjxqSfmeg40512KP&#x2F;ed&#x2F;lCQVXtYqU7U2BfBTg8pBfhLtEcOg4wTNTroGITwe2NjL5HovJ2n2sqkNXEio6Ji0QQJAFLW1Kt80qypMqot+mHhS+0KfdOpaKeMWMSR4Ij5VfE63WzETEeWAMQESxzhavN1WOTb3&#x2F;p6icgcVbgPQBaWhGg&#x3D;&#x3D;&quot;;\nString publicKey &#x3D; &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDvsJrdNacJvZRzHauwPIJBIoJNFyjH47&#x2F;uCIwBYVgkok3j+3bZZ3HhSW5Fsb23O0KN3wjqcJn3LJMFHN1UoMoiZDSQ7PYrz275bfCFNm2fjwQ8WMUgiRa4KLlTqQK&#x2F;Gq&#x2F;2+oDbmE4tb7dxZBrUowAhW9NNv+vESlE8nvP7XXFYpQIDAQAB&quot;;\n&#x2F;&#x2F; 生成一对公钥和私钥，其中Map对象 (private&#x3D;私钥, public&#x3D;公钥)\nSystem.out.println(SaSecureUtil.rsaGenerateKeyPair());\n\n&#x2F;&#x2F; 文本\nString text &#x3D; &quot;Sa-Token 一个轻量级java权限认证框架&quot;;\n\n&#x2F;&#x2F; 使用公钥加密\nString ciphertext &#x3D; SaSecureUtil.rsaEncryptByPublic(publicKey, text);\nSystem.out.println(&quot;公钥加密后：&quot; + ciphertext);\n\n&#x2F;&#x2F; 使用私钥解密\nString text2 &#x3D; SaSecureUtil.rsaDecryptByPrivate(privateKey, ciphertext);\nSystem.out.println(&quot;私钥解密后：&quot; + text2);</code></pre></li>\n</ul>\n</li>\n</ol>\n<h2 id=\"9-多账号体系认证\"><a href=\"#9-多账号体系认证\" class=\"headerlink\" title=\"9.多账号体系认证\"></a>9.多账号体系认证</h2><ol>\n<li><p>比如一个电商系统同时有<code>user</code>表和<code>admin</code>表，两套账号都适用StpUtil类的API进行登陆鉴权，势必会发生逻辑冲突</p>\n</li>\n<li><p><code>stpLogic</code>：<code>StpUtil</code>只是对成员变量<code>stpLogic</code>的各个API包装一下进行转发，这样的实现有以下好处</p>\n<ul>\n<li><code>StpLogic</code> 类的所有函数都可以被重写，按需扩展</li>\n<li>在构造方法时随意传入一个不同的 <code>loginType</code>，就可以再造一套账号登录体系</li>\n</ul>\n</li>\n<li><p>示例</p>\n<ul>\n<li><p>对于原生<code>StpUtil</code>类，只做<code>admin账号</code>权限认证，而对于<code>user账号</code>，则新建一个权限认证类（<code>StpUserUtil.java</code>），将<code>StpUtil</code>代码全部复制到<code>StpUserUtil</code>中，更改一下他的<code>loginType</code>，其它使用方式相同</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StpUserUtil &#123;\n    \n    &#x2F;**\n     * 账号体系标识 \n     *&#x2F;\n    public static final String TYPE &#x3D; &quot;user&quot;;    &#x2F;&#x2F; 将 LoginType 从&#96;login&#96;改为&#96;user&#96; \n\n    &#x2F;&#x2F; 其它代码 ... \n\n&#125;</code></pre></li>\n<li><p>相关注解的使用：默认只支持<code>StpUtil</code>类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过type属性指定此注解校验的是我们自定义的&#96;StpUserUtil&#96;，而不是原生&#96;StpUtil&#96;\n@SaCheckLogin(type &#x3D; StpUserUtil.TYPE)\n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;</code></pre></li>\n<li><p>使用自定义注解简化前一种方式</p>\n<ul>\n<li><p>重写Sa-Token默认的注解处理器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class SaTokenConfigure &#123;\n    @Autowired\n    public void rewriteSaStrategy() &#123;\n        &#x2F;&#x2F; 重写Sa-Token的注解处理器，增加注解合并功能 \n        SaStrategy.me.getAnnotation &#x3D; (element, annotationClass) -&gt; &#123;\n            return AnnotatedElementUtils.getMergedAnnotation(element, annotationClass); \n        &#125;;\n    &#125;\n&#125;</code></pre></li>\n<li><p>自定义一个注解</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 登录认证(User版)：只有登录之后才能进入该方法 \n * &lt;p&gt; 可标注在函数、类上（效果等同于标注在此类的所有方法上） \n *&#x2F;\n@SaCheckLogin(type &#x3D; &quot;user&quot;)\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123; ElementType.METHOD, ElementType.TYPE&#125;)\npublic @interface SaUserCheckLogin &#123;\n    \n&#125;</code></pre></li>\n<li><p>使用示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用 @SaUserCheckLogin 的效果等同于使用：@SaCheckLogin(type &#x3D; &quot;user&quot;)\n@SaUserCheckLogin\n@RequestMapping(&quot;info&quot;)\npublic String info() &#123;\n    return &quot;查询用户信息&quot;;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>同端多登陆</p>\n<ul>\n<li><p>一个设备同时可以登陆两套账户，可能会发生token覆盖的问题，新登陆的token会覆盖掉旧的token</p>\n</li>\n<li><p>解决办法：更改<code>StpUserUtil</code>（前文配置的新类）的<code>TokenName</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StpUserUtil &#123;\n    \n    &#x2F;&#x2F; 使用匿名子类 重写&#96;stpLogic对象&#96;的一些方法 \n    public static StpLogic stpLogic &#x3D; new StpLogic(&quot;user&quot;) &#123;\n        &#x2F;&#x2F; 重写 StpLogic 类下的 &#96;splicingKeyTokenName&#96; 函数，返回一个与 &#96;StpUtil&#96; 不同的token名称, 防止冲突 \n        @Override\n        public String splicingKeyTokenName() &#123;\n            return super.splicingKeyTokenName() + &quot;-user&quot;;\n        &#125;\n        &#x2F;&#x2F; 同理你可以按需重写一些其它方法 ... \n    &#125;; \n    &#x2F;&#x2F; ... \n&#125;</code></pre></li>\n<li><p>再次调用 <code>StpUserUtil.login(10001)</code>进行登录授权时，token的名称将不再是 <code>satoken</code>，而是我们重写后的 <code>satoken-user</code></p>\n</li>\n</ul>\n</li>\n<li><p>不同体系不同SaTokenConfig配置：自定义的 StpUserUtil 需要使用不同 SaTokenConfig 对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StpUserUtil &#123;\n    \n    &#x2F;&#x2F; 使用匿名子类 重写&#96;stpLogic对象&#96;的一些方法 \n    public static StpLogic stpLogic &#x3D; new StpLogic(&quot;user&quot;) &#123;\n        \n        &#x2F;&#x2F; 首先自定义一个 Config 对象 \n        SaTokenConfig config &#x3D; new SaTokenConfig()\n            .setTokenName(&quot;satoken&quot;)\n            .setTimeout(2592000)\n            &#x2F;&#x2F; ... 其它set\n            ;\n        \n        &#x2F;&#x2F; 然后重写 stpLogic 配置获取方法 \n        @Override\n        public SaTokenConfig getConfig() &#123;\n            return config;\n        &#125;\n    &#125;;\n    \n    &#x2F;&#x2F; ... \n    \n&#125;</code></pre></li>\n<li><p>多账号体系下，在拦截器中给一个接口登录鉴权的方法如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 注册 Sa-Token 拦截器\n@Override\npublic void addInterceptors(InterceptorRegistry registry) &#123;\n    registry.addInterceptor(new SaInterceptor(handle -&gt; &#123;\n        \n        &#x2F;&#x2F; 如果这个接口，要求客户端登录了后台 Admin 账号才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; StpUtil.checkLogin());\n\n        &#x2F;&#x2F; 如果这个接口，要求客户端登录了前台 User 账号才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; StpUserUtil.checkLogin());\n        \n        &#x2F;&#x2F; 如果这个接口，要求客户端同时登录 Admin 和 User 账号，才能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; &#123;\n            StpUtil.checkLogin();\n            StpUserUtil.checkLogin();\n        &#125;);\n\n        &#x2F;&#x2F; 如果这个接口，要求客户端登录 Admin 和 User 账号任意一个，就能访问：\n        SaRouter.match(&quot;&#x2F;art&#x2F;getInfo&quot;).check(r -&gt; &#123;\n            if(StpUtil.isLogin() &#x3D;&#x3D; false &amp;&amp; StpUserUtil.isLogin() &#x3D;&#x3D; false) &#123;\n                throw new SaTokenException(&quot;请登录后再访问接口&quot;);\n            &#125;\n        &#125;);\n        \n    &#125;)).addPathPatterns(&quot;&#x2F;**&quot;);\n&#125;</code></pre></li>\n</ol>\n","text":"Sa-Token 一款开源的、轻量级的Java权限认证框架，主要解决：登陆认证、权限认证、单点登录、OAuth2.0、分布式Session会话、微服务网关鉴权等问题 1.登陆认证 登陆流程 用户提交name+password参数，调用登录接口 &#x2F;&#x2F;&#x2F;...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"19 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":1,"path":"api/tags/tools.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Sa-Token\"><span class=\"toc-text\">Sa-Token</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%99%BB%E9%99%86%E8%AE%A4%E8%AF%81\"><span class=\"toc-text\">1.登陆认证</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81\"><span class=\"toc-text\">2.权限认证</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E8%B7%AF%E7%94%B1%E6%8B%A6%E6%88%AA%E9%89%B4%E6%9D%83\"><span class=\"toc-text\">3.路由拦截鉴权</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-Session%E4%BC%9A%E8%AF%9D\"><span class=\"toc-text\">4.Session会话</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">5.框架配置</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-Sa-Token%E9%9B%86%E6%88%90Redis\"><span class=\"toc-text\">6.Sa-Token集成Redis</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB\"><span class=\"toc-text\">7.前后端分离</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86\"><span class=\"toc-text\">8.密码加密</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E5%A4%9A%E8%B4%A6%E5%8F%B7%E4%BD%93%E7%B3%BB%E8%AE%A4%E8%AF%81\"><span class=\"toc-text\">9.多账号体系认证</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java特性","uid":"b4296f0600f693552b5b6c6b665f6025","slug":"Java特性","date":"2023-04-13T11:25:47.000Z","updated":"2023-04-15T00:08:12.194Z","comments":true,"path":"api/articles/Java特性.json","keywords":null,"cover":null,"text":"Java1.关键字 true, false, 和 null 虽然不是关键字，但它们是不能用作标识符的文字和保留字 strictfp（精确浮点数，跨平台产生相同结果）、native（原生方法） class return byte try if import public boole...","link":"","photos":[],"count_time":{"symbolsCount":"28k","symbolsTime":"25 mins."},"categories":[],"tags":[{"name":"java","slug":"java","count":3,"path":"api/tags/java.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}