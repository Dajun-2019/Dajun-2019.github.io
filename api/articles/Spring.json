{"title":"Spring Family","uid":"0eecce2180060832c1ffa34a76f3eb3b","slug":"Spring","date":"2023-05-06T05:09:43.000Z","updated":"2023-05-25T02:15:26.510Z","comments":true,"path":"api/articles/Spring.json","keywords":null,"cover":[],"content":"<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><h2 id=\"1-IOC\"><a href=\"#1-IOC\" class=\"headerlink\" title=\"1.IOC\"></a>1.IOC</h2><h3 id=\"1-基础知识\"><a href=\"#1-基础知识\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><ol>\n<li><p>BeanFactory：提供了一种高级配置，能够管理任何类型对象，<code>BeanFactory</code>是<code>ApplicationContext</code>的父接口，<code>ApplicationContext</code>接口的实现类主要有<code>ClassPathXmlApplicationContext</code>、<code>FileSystemXmlApplicationContext</code>、<code>WebApplicationContext</code>、<code>AnnotationConfigApplicationContext</code>等，主要负责Bean的实例化、配置、组装</p>\n<ul>\n<li>安装容器：<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</code></li>\n<li></li>\n</ul>\n</li>\n<li><p>Bean：由Spring的IOC容器实例化、组装和管理的对象，一个Bean有全局唯一的name，其它的只能指定别名</p>\n<ul>\n<li><p>bean定义：Class、Name（全局唯一）、Scope、Constructor arguments、Properties、Autowiring mode、Lazy initialization mode、Lazy initialization mode、</p>\n</li>\n<li><p>生命周期</p>\n<table>\n<thead>\n<tr>\n<th><strong>Scope</strong></th>\n<th><strong>Description</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singleton</td>\n<td>(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>Scopes a single bean definition to any number of object instances.</td>\n</tr>\n<tr>\n<td>request</td>\n<td>Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition.</td>\n</tr>\n<tr>\n<td>session</td>\n<td>Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>.</td>\n</tr>\n<tr>\n<td>application</td>\n<td>Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>.</td>\n</tr>\n<tr>\n<td>websocket</td>\n<td>Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>.</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>实例化：bean定义本质上是创建一个或多个对象的方法，当被访问到时，容器会查看bean的命名和定义来创建实际对象</p>\n<ul>\n<li>通过构造方法实例化：所有普通类（默认空参构造+getter+setter）都可以被Spring使用并兼容，只需要指定bean类</li>\n<li>通过静态工厂方法实例化：使用class属性来指定包含静态工厂方法的类，并使用<code>factory-method</code>的属性来指定工厂方法本身的名称，主要用于在遗留代码中调用静态工厂来实例化bean</li>\n<li>通过实例工厂方法实例化：使用实例工厂中的非静态方法来创建新bean，使用<code>factory-bean</code>指定工厂类对应的bean，使用<code>factory-method</code>的属性来指定工厂方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>BeanPostProcessor：通过实现其提供的回调方法，来提供定制的实例化逻辑、依赖解析逻辑，<code>BeanPostProcessor</code>的两个方法分别在Bean的初始化前后执行（<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>）</p>\n<ul>\n<li>AOP自动代理类：<code>DefaultAdvisorAutoProxyCreator</code>，可以实现自动生效所有的advisor</li>\n<li>Spring自动装配的实现类：<code>AutowiredAnnotationBeanPostProcessor</code></li>\n</ul>\n</li>\n<li><p>BeanFactoryPostProcessor：与<code>BeanPostProcessor</code>的区别是<code>BeanFactoryPostProcessor</code>对bean的配置元数据进行操作，并可以在容器实例化除<code>BeanFactoryPostProcessor</code>实例之外的任何bean之前更改它</p>\n<ul>\n<li><p>从外部<code>jdbc.properties</code>文件导入<code>DataSource</code>的某些属性的元数据：<code>PropertySourcesPlaceholderConfigurer</code></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">      &lt;!--加载properties文件--&gt;\n      &lt;context:property-placeholder location&#x3D;&quot;classpath*:jdbc.properties&quot;&#x2F;&gt;\n      &lt;!--数据源--&gt;\n      &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n          &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n          &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n          &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n          &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n      &lt;&#x2F;bean&gt;</code></pre></li>\n</ul>\n</li>\n<li><p>依赖注入：通过定义需要的依赖，并将这些依赖注入到bean中，可以使得代码更简洁，更方便测试。对强制依赖项使用构造函数，对可选依赖使用setter方法</p>\n<ul>\n<li><p>依赖注入处理流程</p>\n<ul>\n<li>通过所有bean的元数据的描述构造并初始化<code>ApplicationContext</code></li>\n<li>对每一个bean，它的依赖关系以属性、构造函数或静态工厂方法的参数的形式表示，并在实际创建bean时提供给bean</li>\n<li>每个属性或构造函数参数都是要设置的值的实际定义，或是对容器中另一个bean的引用</li>\n<li>作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型</li>\n</ul>\n</li>\n<li><p>自动装配的四种模式：？</p>\n<ul>\n<li><code>no</code>：不自动装配，bean引用必须有ref元素定义</li>\n<li><code>byName</code>：按属性名自动装配，Spring寻找与需要自动装配的属性同名的bean，例如有setMaster()方法的bean会去找名为master的bean定义</li>\n<li><code>byType</code>：如果容器中恰好存在一个属性类型的bean，则让属性自动装配；如果存在多个，则需要使用byType自动装配</li>\n<li><code>constructor</code>：与byType类似，但适用于构造函数参数，如果容器中没有一个构造函数参数类型的bean，则会引发错误</li>\n</ul>\n</li>\n<li><p>延迟初始化bean：单例bean常常会很早初始化，当不需要提前初始化bean来验证错误时，可以将bean定义标记为延迟初始化来防止单例bean的预实例化。lazy bean不会被太早实例化，not.lazy bean会被很早实例化</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;lazy&quot; class&#x3D;&quot;com.something.ExpensiveToCreateBean&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean name&#x3D;&quot;not.lazy&quot; class&#x3D;&quot;com.something.AnotherBean&quot;&#x2F;&gt;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-设计模式\"><a href=\"#2-设计模式\" class=\"headerlink\" title=\"2.设计模式\"></a>2.设计模式</h3><ol>\n<li><p>单例模式：一个类在同一进程内只允许创建一个对象（或实例），通过将构造函数声明为<code>private</code>，并在内部以<code>static final</code>的方式创建对象并返回的方式实现，具体实现如下：</p>\n<ul>\n<li><p>模版代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;不支持延迟加载&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class IdGenerator&#123;\n  private AtomicLong id &#x3D; new AtomicLong(10);\n  private static final IdGenerator instance &#x3D; new IdGenerator();\n  private IdGenerator()&#123;&#125;\n  private static IdGenerator getInstance()&#123;return instance;&#125;\n  public long getId()&#123;return id.incrementAndGet();&#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;支持延迟加载（需要解决线程安全问题）&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class IdGenerator&#123;\n  private AtomicLong id &#x3D; new AtomicLong(10);\n  private static final IdGenerator instance;\n  private IdGenerator()&#123;&#125;\n  private static IdGenerator getInstance()&#123;\n    if(instance &#x3D;&#x3D; null)&#123;\n      synchronized(IdGenerator.class)&#123;\n        if(instance &#x3D;&#x3D; null)&#123;\n          instance &#x3D; new IdGenerator();\n        &#125;\n      &#125;\n    &#125;&#x2F;&#x2F;if(instance &#x3D;&#x3D; null)\n    return instance;\n  &#125;\n  public long getId()&#123;return id.incrementAndGet();&#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;有参构造&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic synchronized static Singleton getInstance(int param) &#123; \n    if (instance &#x3D;&#x3D; null) &#123; \n        instance &#x3D; new Singleton(param); \n    &#125; else if (instance.param &#x3D;&#x3D; param) &#123;\n        return instance;\n    &#125; else &#123;\n        instance &#x3D; new Singleton(paramA, paramB);\n    &#125;\n    return instance; \n&#125;\nSingleton singleton &#x3D; Singleton.getInstance(10);\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;利用静态内部类在被调用时才加载（与外部类加载时间无关）的特性来实现&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nprivate static class SingletonHolder&#123;\n  private static final IdGenerator instance &#x3D; new IdGenerator();\n&#125;\npublic static IdGenerator getInstance() &#123;\n  return SingletonHolder.instance;\n&#125;\n</code></pre></li>\n<li><p>特殊形式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;线程唯一单例实现&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nprivate static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances &#x3D; new ConcurrentHashMap&lt;&gt;();\npublic static IdGenerator getInstance() &#123;\n    Long currentThreadId &#x3D; Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;集群唯一单例实现&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;不同进程间共享同一个对象需要将单例序列化到外部共享存储区，使用时再反序列化回来，通过给对象加锁保证保证唯一性\nprivate static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);\nprivate static DistributedLock lock &#x3D; new DistributedLock();\npublic synchronized static IdGenerator getInstance()&#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n        lock.lock();\n        instance &#x3D; storage.load(IdGenerator.class);\n    &#125;\n\t\treturn instance;\n&#125;\npublic synchroinzed void freeInstance() &#123;\n    storage.save(this, IdGeneator.class);\n    instance &#x3D; null; &#x2F;&#x2F;释放对象\n    lock.unlock();\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;多例模式&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nprivate static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\nstatic &#123;\n  serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n  serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n  serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n&#125;\npublic BackendServer getInstance(long serverNo) &#123;\n  return serverInstances.get(serverNo);\n&#125;\n&#x2F;&#x2F;同一类型的只能创建一个对象，不同类型的可以创建多个对象\nprivate static final ConcurrentHashMap&lt;String, Logger&gt; instances &#x3D; new ConcurrentHashMap&lt;&gt;();\npublic static Logger getInstance(String loggerName) &#123;\n  instances.putIfAbsent(loggerName, new Logger());\n  return instances.get(loggerName);\n&#125;\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</code></pre></li>\n<li><p>Spring中的Bean默认都是singleton的，Spring通过ConcurrentHashMap实现单例注册表的特殊方式实现单例模式</p>\n<ul>\n<li>线程安全问题：尽量避免定义可变的成员变量（大部分Bean如Dao、Service都没有实例变量，是线程安全的），如果需要定义则使用ThreadLocal成员变量</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过 ConcurrentHashMap（线程安全） 实现单例注册表\nprivate final Map&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;String, Object&gt;(64);\n\npublic Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;\n        Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);\n        synchronized (this.singletonObjects) &#123;\n            &#x2F;&#x2F; 检查缓存中是否存在实例\n            Object singletonObject &#x3D; this.singletonObjects.get(beanName);\n            if (singletonObject &#x3D;&#x3D; null) &#123;\n                &#x2F;&#x2F;...省略了很多代码\n                try &#123;\n                    singletonObject &#x3D; singletonFactory.getObject();\n                &#125;\n                &#x2F;&#x2F;...省略了很多代码\n                &#x2F;&#x2F; 如果实例对象在不存在，我们注册到单例注册表中。\n                addSingleton(beanName, singletonObject);\n            &#125;\n            return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;将对象添加到单例注册表\n    protected void addSingleton(String beanName, Object singletonObject) &#123;\n            synchronized (this.singletonObjects) &#123;\n                this.singletonObjects.put(beanName, (singletonObject !&#x3D; null ? singletonObject : NULL_OBJECT));\n\n            &#125;\n        &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>工厂模式</p>\n<ul>\n<li><p>工厂方法：涉及多个if-else和复杂的对象创建语句时，将创建代码抽象出一个新的类作为对象创建的工厂，封装对象的创建过程，将对象的创建和使用相分离，统一调度。还可以利用多态去掉if分支（实现接口，简化插入），利用工厂的工厂来简化使用，符合开闭原则</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;简单实现，构造函数直接抽取出来&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class RuleConfigParserFactory &#123;\n    public static IRuleConfigParser createParser(String configFormat) &#123;\n        IRuleConfigParser parser &#x3D; null;\n        if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new JsonRuleConfigParser();\n        &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new XmlRuleConfigParser();\n        &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new YamlRuleConfigParser();\n        &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new PropertiesRuleConfigParser();\n        &#125;\n        return parser;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;多态，利用接口来满足开闭原则，适合每个对象的创建都很复杂的情况，避免设计一个大而全的工厂方法&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic interface IRuleConfigParserFactory &#123; IRuleConfigParser createParser(); &#125;\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createParser() &#123; return new JsonRuleConfigParser(); &#125;\n&#125;\n&#x2F;&#x2F;省略XmlRuleConfigParserFactory，YamlRuleConfigParserFactory，PropertiesRuleConfigParserFactory\n\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n    private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n  \t&#x2F;&#x2F;缓存，为了节省时间提前创建并缓存对象\n    static &#123;\n        cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n        cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n        cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n        cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());\n    &#125;\n\n    public static IRuleConfigParserFactory getParserFactory(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            return null;\n        &#125;\n        IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n        return parserFactory;\n    &#125;\n&#125;\n&#x2F;&#x2F;IRuleConfigParserFactory parserFactory &#x3D; \t\tRuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);&#x2F;&#x2F;利用接口接收对应类型的工厂\n&#x2F;&#x2F;IRuleConfigParser parser &#x3D; parserFactory.createParser();</code></pre></li>\n<li><p>抽象工厂：传统工厂方法类只有一种分类方式，对应的构造函数会成倍的增长，抽象工厂可以让一个工厂负责多个不同类型的对象创建，而不是只创建一类对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IConfigParserFactory &#123;\n    IRuleConfigParser createRuleParser();\n    ISystemConfigParser createSystemParser();\n    &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\n\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createRuleParser() &#123;\n        return new JsonRuleConfigParser();\n    &#125;\n\n    @Override\n    public ISystemConfigParser createSystemParser() &#123;\n        return new JsonSystemConfigParser();\n    &#125;\n&#125;\n&#x2F;&#x2F; 省略XmlConfigParserFactory、YamlConfigParserFactory和PropertiesConfigParserFactory代码</code></pre></li>\n<li><p>依赖注入（IOC、DI、Container）</p>\n<ul>\n<li>DI容器：设计思路基于工厂模式，底层相当于一个大的工厂类，负责在程序启动的时候根据配置（要创建哪些类的对象、每个对象依赖哪些对象的创建）事先创建好对象，当应用程序需要某个类对象的时候，直接从容器中获取即可。称为容器是因为框架持有一堆对象</li>\n<li>核心功能<ul>\n<li>配置解析：从配置文件中读取类对象和创建类对象的相关信息，根据配置文件创建对象，比如Spring的xml文件中的bean</li>\n<li>对象创建：通过一个工厂类，如BeansFactory来以反射的方式，在程序运行过程中动态地加载类、创建对象，不需要一次创建完所有需要的对象</li>\n<li>对象声明周期管理：单例模式（全局只有一个）、原型模式（每次都新创建一个）、懒加载（对象用到的时候再创建）<ul>\n<li>init-method：增加此配置，可以在创建对象之前调用指定方法来初始化对象</li>\n<li>destroy-method：增加此配置，可以在销毁对象之后调用指定方法来做一些清理工作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>示例：通过BeanFactory或ApplicationContext创建Bean对象，其中BeanFactory延迟注入，懒加载，在使用到Bean的时候才会注入；而ApplicationContext在容器启动的时候，一次创建了所有Bean，但是ApplicationContext扩展了BeanFactory的功能，有以下实现类<ul>\n<li><code>ClassPathXmlApplicationContext</code>，通过解析配置文件得到配置信息（BeanDefinition），根据配置信息使用BeansFactory通过反射来创建对象并返回</li>\n<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息</li>\n<li><code>XmlWebApplicationContext</code>：从 Web 系统中的 XML 文件载入上下文定义信息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>观察者模式：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p>\n<ul>\n<li><p>模版代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Subject &#123;\n    &#x2F;&#x2F;也可起名为attach\n    void registerObserver(Observer observer);\n    &#x2F;&#x2F;也可起名为detach\n    void removeObserver(Observer observer);\n    &#x2F;&#x2F;一个一个通知\n    void notifyObservers(Message message);\n&#125;\n&#x2F;&#x2F;被依赖的对象叫被观察者（Observable）；依赖的对象叫观察者（Observer）\npublic interface Observer &#123;\n    void update(Message message);\n&#125;\n&#x2F;&#x2F;Concrete：具体的\npublic class ConcreteSubject implements Subject &#123;\n    private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n\n    @Override\n    public void registerObserver(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    @Override\n    public void removeObserver(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    @Override\n    public void notifyObservers(Message message) &#123;  &#x2F;&#x2F;通知所有依赖的对象，响应通知调用对应的代码\n      \t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;同步阻塞和异步非阻塞二选一&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n      \t&#x2F;&#x2F;同步阻塞方式\n        for (Observer observer : observers) &#123;\n            observer.update(message);\n        &#125;\n      \t&#x2F;&#x2F;异步非阻塞方式，新启线程或直接引入线程池\n      \t&#x2F;&#x2F;private Executor executor &#x2F;&#x2F; 线程池\n      \tfor(Observer observer : observers) &#123;\n          executor.execute(new Runnable()&#123;\n            @Override\n            public void run()&#123;\n              observer.update(messgae);\n            &#125;\n          &#125;)\n        &#125;\n    &#125;\n&#125;\n\npublic class ConcreteObserverOne implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteObserverTwo implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n    &#125;\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ConcreteSubject subject &#x3D; new ConcreteSubject();\n        subject.registerObserver(new ConcreteObserverOne());\n        subject.registerObserver(new ConcreteObserverTwo());\n        subject.notifyObservers(new Message());\n    &#125;\n&#125;</code></pre></li>\n<li><p>EventBus框架（事件总线）：提供了观察者模式的骨架代码，如Google Guava中的EventBus，同时支持同步阻塞和异步非阻塞</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n\n    private EventBus eventBus;\n    private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;\n\n    public UserController() &#123;\n        &#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式\n        eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool\n                                     (DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); &#x2F;&#x2F; 异步非阻塞\n    &#125;\n\n    public void setRegObservers(List&lt;Object&gt; observers) &#123;\n        for (Object observer : observers) &#123;\n            &#x2F;&#x2F;用来注册任何类型（Object）的观察者，而在经典的观察者模式的实现中，\n            &#x2F;&#x2F;register() 函数必须接受实现了同一 Observer 接口的类对象。\n            eventBus.register(observer);\n        &#125;\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        long userId &#x3D; userService.register(telephone, password);\n        \n\t\t\t\t&#x2F;&#x2F;用来给观察者发送信息，当调用post()函数发送信息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的\n      \t&#x2F;&#x2F;观察者，即接受的消息类型是发送消息（post函数定义中的event）类型的父类\n        eventBus.post(userId);\n\n        return userId;\n    &#125;\n&#125;\npublic class RegPromotionObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Subscribe&#x2F;&#x2F;定义能接收的消息类型\n    public void handleRegSuccess(Long userId) &#123;\n        promotionService.issueNewUserExperienceCash(userId);\n    &#125;\n&#125;\n\npublic class RegNotificationObserver &#123;\n    private NotificationService notificationService;\n\n    @Subscribe\n    public void handleRegSuccess(Long userId) &#123;\n        notificationService.sendInboxMessage(userId, &quot;...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;@Subscribe注解：当通过 register() 函数将 Observer 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe \n&#x2F;&#x2F;注解找到 f1() 和 f2()，并且将两个函数能接收的消息类型记录下来（PMsg-&gt;f1，QMsg-&gt;f2）。当我们通过 post() 函数发送\n&#x2F;&#x2F;消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）\npublic DObserver &#123;\n  &#x2F;&#x2F;...省略其他属性和方法...\n  \n  @Subscribe\n  public void f1(PMsg event) &#123; &#x2F;&#x2F;... &#125;\n  \n  @Subscribe\n  public void f2(QMsg event) &#123; &#x2F;&#x2F;... &#125;\n&#125;</code></pre></li>\n<li><p>应用</p>\n<ul>\n<li><p>事件角色：Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p>\n<ul>\n<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li>\n<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li>\n<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>\n<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件</li>\n</ul>\n</li>\n<li><p>事件监听者和事件发布者</p>\n<ul>\n<li><p><code>ApplicationListener</code>充当了事件监听者角色，它是一个接口，只定义了一个 <code>onApplicationEvent()</code>方法来处理<code>ApplicationEvent</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.springframework.context;\nimport java.util.EventListener;\n@FunctionalInterface\npublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;\n    void onApplicationEvent(E var1);\n&#125;</code></pre></li>\n<li><p><code>ApplicationEventPublisher</code>充当了事件的发布者，它也是一个接口，<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code> 类中被实现，底层通过<code>ApplicationEventMulticaster</code>来广播出去的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FunctionalInterface\npublic interface ApplicationEventPublisher &#123;\n    default void publishEvent(ApplicationEvent event) &#123;\n        this.publishEvent((Object)event);\n    &#125;\n\n    void publishEvent(Object var1);\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>事件流程</p>\n<ul>\n<li><p>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</p>\n</li>\n<li><p>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</p>\n</li>\n<li><p>使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息</p>\n</li>\n<li><p>实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 定义一个事件,继承自ApplicationEvent并且写相应的构造函数\npublic class DemoEvent extends ApplicationEvent&#123;\n    private static final long serialVersionUID &#x3D; 1L;\n\n    private String message;\n\n    public DemoEvent(Object source,String message)&#123;\n        super(source);\n        this.message &#x3D; message;\n    &#125;\n\n    public String getMessage() &#123;\n         return message;\n          &#125;\n\n&#x2F;&#x2F; 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；\n@Component\npublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt;&#123;\n\n    &#x2F;&#x2F;使用onApplicationEvent接收消息\n    @Override\n    public void onApplicationEvent(DemoEvent event) &#123;\n        String msg &#x3D; event.getMessage();\n        System.out.println(&quot;接收到的信息是：&quot;+msg);\n    &#125;\n\n&#125;\n&#x2F;&#x2F; 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。\n@Component\npublic class DemoPublisher &#123;\n\n    @Autowired\n    ApplicationContext applicationContext;\n\n    public void publish(String message)&#123;\n        &#x2F;&#x2F;发布事件\n        applicationContext.publishEvent(new DemoEvent(this, message));\n    &#125;\n&#125;</code></pre></li>\n<li><p>结果：当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>模版模式：在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤（如Java的IO框架），复用部分已有代码</p>\n<ul>\n<li><p>代码实现：模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractClass &#123;\n    &#x2F;&#x2F;定义为final，避免子类重写\n    public final void templateMethod() &#123;\n        &#x2F;&#x2F;...\n        method1();\n        &#x2F;&#x2F;...\n        method2();\n        &#x2F;&#x2F;...\n    &#125;\n\t\t&#x2F;&#x2F;方式一：定义为abstract是为了强迫子类去实现（如InputStream的read方法）\n    protected abstract void method1();\n    protected abstract void method2();\n  \t&#x2F;&#x2F;方式二：虽然没有声明为abstract，但是抛了异常，子类不重写来处理异常就无法使用（如AbstractList的add方法）\n    public void add(int index, E element) &#123;\n      throw new UnsupportedOperationException();\n  \t&#125;\n&#125;\n\npublic class ConcreteClass1 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;&#125;\n\n    @Override\n    protected void method2() &#123;&#125;\n&#125;\n\npublic class ConcreteClass2 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;&#125;\n\n    @Override\n    protected void method2() &#123;&#125;\n&#125;\nAbstractClass demo &#x3D; ConcreteClass1();\ndemo.templateMethod();</code></pre></li>\n<li><p>框架的扩展（Java Servlet）</p>\n<ul>\n<li><p>HttpServlet：处理web应用中的get和post请求，在Tomcat、Jetty这样的Servlet容器启动的时候，会自动加载配置文件中URL和XXXServlet间的映射关系（如<code>/hello</code>对应<code>HelloServlet</code>），容器处理URL请求找到对应的servlet执行service方法（定义在父类HttpServlet中，会调用doGet和doPost方法，然后输出网页）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doPost(req, resp);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        resp.getWriter().write(&quot;Hello World.&quot;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>HttpServlet的service方法：是一个模版方法，实现了整个HTTP请求的执行流程，但其中的doGet和doPost方法可以由子类来定制实现，可以不修改Servlet框架源码的情况下将业务代码通过扩展点镶嵌到框架中执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException\n&#123;\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &amp;&amp;\n          res instanceof HttpServletResponse)) &#123;\n        throw new ServletException(&quot;non-HTTP request or response&quot;);\n    &#125;\n    request &#x3D; (HttpServletRequest) req;\n    response &#x3D; (HttpServletResponse) res;\n    service(request, response);\n&#125;\n&#x2F;&#x2F;参数类型不同\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123;\n    String method &#x3D; req.getMethod();\n    if (method.equals(METHOD_GET)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        if (lastModified &#x3D;&#x3D; -1) &#123;\n            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason\n            &#x2F;&#x2F; to go through further expensive logic\n            doGet(req, resp);\n        &#125; else &#123;\n            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince &lt; lastModified) &#123;\n                &#x2F;&#x2F; If the servlet mod time is later, call doGet()\n                &#x2F;&#x2F; Round down to the nearest second for a proper compare\n                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            &#125; else &#123;\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            &#125;\n        &#125;\n    &#125; else if (method.equals(METHOD_HEAD)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    &#125; else if (method.equals(METHOD_POST)) &#123;\n        doPost(req, resp);\n    &#125; else if (method.equals(METHOD_PUT)) &#123;\n        doPut(req, resp);\n    &#125; else if (method.equals(METHOD_DELETE)) &#123;\n        doDelete(req, resp);\n    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;\n        doOptions(req,resp);\n    &#125; else if (method.equals(METHOD_TRACE)) &#123;\n        doTrace(req,resp);\n    &#125; else &#123;\n        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);\n        Object[] errArgs &#x3D; new Object[1];\n        errArgs[0] &#x3D; method;\n        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>回调（Callback）</p>\n<ul>\n<li><p>实现：相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ICallback &#123;\n    void methodToCallback();\n&#125;\n\npublic class BClass &#123;\n    public void process(ICallback callback) &#123;\n        &#x2F;&#x2F;...\n        callback.methodToCallback();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class AClass &#123;\n    public static void main(String[] args) &#123;\n        BClass b &#x3D; new BClass();\n        &#x2F;&#x2F;使用包裹了回调函数的类对象，我们简称为回调对象\n        &#x2F;&#x2F;A实现了methodToCallback()，并且调用process()，process()函数又调用了methodToCallback()\n        b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象\n            @Override\n            public void methodToCallback() &#123;\n                System.out.println(&quot;Call back me.&quot;);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n&#x2F;&#x2F;异步回调：通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口\n&#x2F;&#x2F;（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户</code></pre></li>\n<li><p>JdbcTemplate：Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法<code>execute()</code>中，将可变的部分设计成回调<code>StatementCallback</code>，由用户来定制。<code>query()</code>函数是对<code>execute()</code>函数的二次封装，让接口用起来更加方便</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;\n    return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));\n&#125;\n\n@Override\npublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;\n    Assert.notNull(sql, &quot;SQL must not be null&quot;);\n    Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);\n    if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;); &#125;\n\t\t&#x2F;&#x2F;回调，实现了StatementCallback，由用户来定制，封装了execute模版方法\n    class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;\n        @Override\n        public T doInStatement(Statement stmt) throws SQLException &#123;\n            ResultSet rs &#x3D; null;\n            try &#123;\n                rs &#x3D; stmt.executeQuery(sql);\n                ResultSet rsToUse &#x3D; rs;\n                if (nativeJdbcExtractor !&#x3D; null) &#123;\n                    rsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);\n                &#125;\n                return rse.extractData(rsToUse);\n            &#125;\n            finally &#123;\n                JdbcUtils.closeResultSet(rs);\n            &#125;\n        &#125;\n        @Override\n        public String getSql() &#123;\n            return sql;\n        &#125;\n    &#125;\n\n    return execute(new QueryStatementCallback());\n&#125;\n\n@Override\npublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;\n    Assert.notNull(action, &quot;Callback object must not be null&quot;);\n\n    Connection con &#x3D; DataSourceUtils.getConnection(getDataSource());\n    Statement stmt &#x3D; null;\n    try &#123;\n        Connection conToUse &#x3D; con;\n        if (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;\n            this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;\n            conToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);\n        &#125;\n        stmt &#x3D; conToUse.createStatement();\n        applyStatementSettings(stmt);\n        Statement stmtToUse &#x3D; stmt;\n        if (this.nativeJdbcExtractor !&#x3D; null) &#123;\n            stmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);\n        &#125;\n        T result &#x3D; action.doInStatement(stmtToUse);\n        handleWarnings(stmt);\n        return result;\n    &#125;\n    catch (SQLException ex) &#123;\n        &#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock\n        &#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.\n        JdbcUtils.closeStatement(stmt);\n        stmt &#x3D; null;\n        DataSourceUtils.releaseConnection(con, getDataSource());\n        con &#x3D; null;\n        throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);\n    &#125;\n    finally &#123;\n        JdbcUtils.closeStatement(stmt);\n        DataSourceUtils.releaseConnection(con, getDataSource());\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;使用&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class JdbcTemplateDemo &#123;\n    private JdbcTemplate jdbcTemplate;\n\n    public User queryUser(long id) &#123;\n        String sql &#x3D; &quot;select * from user where id&#x3D;&quot;+id;\n        return jdbcTemplate.query(sql, new UserRowMapper()).get(0);\n    &#125;\n\n    class UserRowMapper implements RowMapper&lt;User&gt; &#123;\n        public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;\n            User user &#x3D; new User();\n            user.setId(rs.getLong(&quot;id&quot;));\n            user.setName(rs.getString(&quot;name&quot;));\n            user.setTelephone(rs.getString(&quot;telephone&quot;));\n            return user;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>回调与模版方法的对比，回调相对于模版模式会更加灵活</p>\n<ul>\n<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>职责链模式：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止</p>\n<ul>\n<li><p>模版代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;实现一&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic abstract class Handler &#123;\n    protected Handler successor &#x3D; null;\n\n    public void setSuccessor(Handler successor) &#123;\n        this.successor &#x3D; successor;\n    &#125;\n\n    public final void handle() &#123;\n        &#x2F;&#x2F;如果没有handled判断，则可以全部处理一遍\n        boolean handled &#x3D; doHandle();\n        if (successor !&#x3D; null &amp;&amp; !handled) &#123;\n            successor.handle();\n        &#125;\n    &#125;\n    protected abstract boolean doHandle();\n&#125;\n\npublic class HandlerA extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;实现二&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic interface IHandler &#123;\n    boolean handle();\n&#125;\n\npublic class HandlerA implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\npublic class HandlerChain &#123;\n    private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();\n\n    public void addHandler(IHandler handler) &#123;\n        this.handlers.add(handler);\n    &#125;\n\n    public void handle() &#123;\n        for (IHandler handler : handlers) &#123;\n            boolean handled &#x3D; handler.handle();\n            if (handled) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        HandlerChain chain &#x3D; new HandlerChain();\n        chain.addHandler(new HandlerA());\n        chain.addHandler(new HandlerB());\n        chain.handle();\n    &#125;\n&#125;</code></pre></li>\n<li><p>Servelt Filter：可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LogFilter implements Filter &#123;\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#x2F;&#x2F; 在创建Filter时自动调用，\n    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）\n  &#125;\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    chain.doFilter(request, response);\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  &#125;\n\n  @Override\n  public void destroy() &#123;\n    &#x2F;&#x2F; 在销毁Filter时自动调用\n  &#125;\n&#125;\n&#x2F;&#x2F; 在web.xml配置文件中添加filter相关的配置（url、相关类）\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Tomcat&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic final class ApplicationFilterChain implements FilterChain &#123;\n    private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter\n    private int n; &#x2F;&#x2F;filter的个数\n    private ApplicationFilterConfig[] filters;\n    private Servlet servlet;\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response) &#123;\n        if (pos &lt; n) &#123;\n            ApplicationFilterConfig filterConfig &#x3D; filters[pos++];\n            Filter filter &#x3D; filterConfig.getFilter();\n            filter.doFilter(request, response, this);&#x2F;&#x2F;传入this，进行递归调用，实现前后双向拦截\n            &#x2F;&#x2F;System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n            &#x2F;&#x2F;chain.doFilter(request, response);\n    \t\t\t\t&#x2F;&#x2F;System.out.println(&quot;拦截发送给客户端的响应.&quot;);            \n        &#125; else &#123;\n            &#x2F;&#x2F; filter都处理完毕后，执行servlet\n            servlet.service(request, response);\n        &#125;\n    &#125;\n\n    public void addFilter(ApplicationFilterConfig filterConfig) &#123;\n\t\t\t\t&#x2F;&#x2F;去重+扩容\n        filters[n++] &#x3D; filterConfig;\n    &#125;\n&#125;</code></pre></li>\n<li><p>Spring Interceptor：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230510141640127.png\" alt=\"image-20230510141640127\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;使用：实现HandlerInterceptor接口，重写preHandle、postHandle、afterCompletion三个方法\n&#x2F;&#x2F;原理：在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 \n&#x2F;&#x2F;HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能\npublic class HandlerExecutionChain &#123;\n    private final Object handler;\n    private HandlerInterceptor[] interceptors;\n\n    public void addInterceptor(HandlerInterceptor interceptor) &#123;\n        initInterceptorList().add(interceptor);\n    &#125;\n\n    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                if (!interceptor.preHandle(request, response, this.handler)) &#123;\n                    triggerAfterCompletion(request, response, null);\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                interceptor.postHandle(request, response, this.handler, mv);\n            &#125;\n        &#125;\n    &#125;\n\n    void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)\n        throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                try &#123;\n                    interceptor.afterCompletion(request, response, this.handler, ex);\n                &#125; catch (Throwable ex2) &#123;\n                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-原理及源码分析\"><a href=\"#3-原理及源码分析\" class=\"headerlink\" title=\"3.原理及源码分析\"></a>3.原理及源码分析</h3><p><a href=\"https://javadoop.com/post/spring-ioc\">https://javadoop.com/post/spring-ioc</a></p>\n<h2 id=\"2-AOP\"><a href=\"#2-AOP\" class=\"headerlink\" title=\"2.AOP\"></a>2.AOP</h2><h3 id=\"1-基础知识-1\"><a href=\"#1-基础知识-1\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><ol>\n<li>专有名词<ul>\n<li>Aspect：跨多个类的关注点的模块化，例如事务管理</li>\n<li>Join point：程序执行过程中的一个点，例如方法的执行和异常的处理</li>\n<li>Advice：Aspect在特定的Join point采取的行动，包括around、before、after（running、throwing、finally）</li>\n<li>pointcut：匹配连接点的谓词，Advice和pointcut表达式相关联，并在任何与pointcut匹配的join point运行，例如执行具有特定名称的方法</li>\n<li>Introduction：代表一个类型声明额外的方法或字段，例如可以使用introduction让bean实现isModified接口，来简化缓存</li>\n<li>Target object：An object being advised by one or more aspects，即被代理对象</li>\n<li>AOP proxy：由AOP框架创建的对象，用于实现aspect</li>\n<li>Weaving：将apsects和其他应用程序类型或对象链接以创建建议对象</li>\n</ul>\n</li>\n<li>使用示例<ul>\n<li>配置启用<code>@AspectJ</code>支持：增加注解<code>@EnableAspectJAutoProxy</code></li>\n<li>声明一个切面（aspect）</li>\n<li>声明一个切点（pointcut）</li>\n<li>声明一个advice</li>\n<li>使用。。。</li>\n</ul>\n</li>\n<li>对bean做aop增强问题（？）<ul>\n<li>子类有则用子类的bean，子类没有则用父类的bean</li>\n<li>在父上下文开启增强，父的bean均被增强，子的bean均未被增强；在子上下文开启增强，子的bean均被增强，父的bean未被增强</li>\n<li>要想都被增强，则需要都开启aop的自动配置并且在父类上定义aop</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-设计模式-1\"><a href=\"#2-设计模式-1\" class=\"headerlink\" title=\"2.设计模式\"></a>2.设计模式</h3><ol>\n<li><p>代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问（监控、统计、鉴权、限流、事务、幂等、日志），而非加强功能，这是它跟装饰器模式最大的不同（装饰器主要是加强已有功能）</p>\n<ul>\n<li><p>装饰器模式、代理模式、适配器模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能\n&#x2F;&#x2F;适配器模式是一种事后补救措施，增加跟原始类不同的接口，让原本因接口不兼容而不能一起工作的类可以一起工作\n&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A impelements IA &#123;\n    public void f() &#123; \n      &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class AProxy implements IA &#123;\n    private IA a;\n    public AProxy(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 新添加的代理逻辑\n        a.f();\n        &#x2F;&#x2F; 新添加的代理逻辑\n    &#125;\n&#125;\nIA a &#x3D; new AProxy(new A());\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A implements IA &#123;\n    public void f() &#123; \n      &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class ADecorator implements IA &#123;\n    private IA a;\n    public ADecorator(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 功能增强代码\n        a.f();\n        &#x2F;&#x2F; 功能增强代码\n    &#125;\n&#125;\n&#x2F;&#x2F; 类适配器: 基于继承，将不兼容ITarget接口的Adaptee类“转换”为符合ITarget接口定义的类\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n    public void fb() &#123;\n        &#x2F;&#x2F;... \n    &#125;\n    public void fc() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n&#125;\n\npublic class Adaptor extends Adaptee implements ITarget &#123;\n    public void f1() &#123;\n        super.fa();\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;</code></pre></li>\n<li><p>静态代理：有接口时实现相同的接口来实现（见前），没有接口时只能通过继承实现（见下）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class A&#123;\n    public void f() &#123; \n      &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class AProxy extends A &#123;\n    private A a;\n    public AProxy() &#123;\n        this.a &#x3D; new A();\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 新添加的代理逻辑\n        a.f();\n        &#x2F;&#x2F; 新添加的代理逻辑\n    &#125;\n&#125;\nA a &#x3D; new AProxy();</code></pre></li>\n<li><p>动态代理：不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理来替换原始类（如Spring AOP）</p>\n<ul>\n<li>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用JDK Proxy去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用Cglib生成一个被代理对象的子类来作为代理（也可以使用AspectJ，AOP属于运行时增强而AspectJ属于编译时增强，基于字节码操作）</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;动态代理类\npublic class MetricsCollectorProxy &#123;\n    private MetricsCollector metricsCollector;\n\n    public MetricsCollectorProxy() &#123;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    &#x2F;&#x2F;封装了代理类的创建\n    public Object createProxy(Object proxiedObject) &#123;\n        &#x2F;&#x2F;返回Class数组，表示Class对象引用的类所实现的所有接口\n        Class&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();\n        DynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);\n        &#x2F;&#x2F;Proxy provides static methods for creating dynamic proxy classes and instances, \n        &#x2F;&#x2F;and it is also the superclass of all dynamic proxy classes created by those \n        &#x2F;&#x2F;methods.\n        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n    &#125;\n\n    private class DynamicProxyHandler implements InvocationHandler &#123;\n        private Object proxiedObject;\n\n        public DynamicProxyHandler(Object proxiedObject) &#123;\n            this.proxiedObject &#x3D; proxiedObject;\n        &#125;\n\n        &#x2F;&#x2F;所有方法的调用都会变成调用invoke方法，参数为生成的代理类、要调用的方法、对应的参数\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            long startTimestamp &#x3D; System.currentTimeMillis();\n            Object result &#x3D; method.invoke(proxiedObject, args);\n            long endTimeStamp &#x3D; System.currentTimeMillis();\n            long responseTime &#x3D; endTimeStamp - startTimestamp;\n            String apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n            RequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);\n            metricsCollector.recordRequest(requestInfo);\n            return result;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();\nIUserController userController &#x3D; (IUserController) proxy.createProxy(new UserController());</code></pre></li>\n</ul>\n</li>\n<li><p>装饰者模式：在不改变原始类接口的情况下，对原始类的功能进行增强，并且支持多个装饰器的嵌套使用，如Java的IO类库</p>\n<ul>\n<li><p>用组合代替继承、装饰器类和原始类继承同一父类，从而可以对原始类嵌套多个装饰器类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class InputStream &#123;\n    &#x2F;&#x2F;...\n    public int read(byte b[]) throws IOException &#123; return read(b, 0, b.length); &#125;\n    public int read(byte b[], int off, int len) throws IOException &#123; &#125;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class BufferedInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n    protected BufferedInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现基于缓存的读数据接口...  \n&#125;\n\npublic class DataInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n    protected DataInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现读取基本类型数据的接口\n&#125;\nInputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nDataInputStream din &#x3D; new DataInputStream(bin);\nint data &#x3D; din.readInt();</code></pre></li>\n<li><p>为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。例如：BufferedInputStream直接使用了FilterInputStream的close()，而没有重新实现</p>\n</li>\n</ul>\n</li>\n<li><p>适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口，适配器模式主要是将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作</p>\n<ul>\n<li><p>类适配器（继承）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123;&#125;\n    public void fb() &#123;&#125;\n    public void fc() &#123;&#125;\n&#125;\n\npublic class Adaptor extends Adaptee implements ITarget &#123;\n    public void f1() &#123;\n        super.fa();\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;</code></pre></li>\n<li><p>对象适配器（组合）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123;&#125;\n    public void fb() &#123;&#125;\n    public void fc() &#123;&#125;\n&#125;\n\npublic class Adaptor implements ITarget &#123;\n    private Adaptee adaptee;\n    public Adaptor(Adaptee adaptee) &#123; this.adaptee &#x3D; adaptee; &#125;\n    public void f1() &#123; adaptee.fa(); &#125; &#x2F;&#x2F;委托给Adaptee\n    \n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    public void fc() &#123;\n        adaptee.fc();\n    &#125;\n&#125;</code></pre></li>\n<li><p>应用：封装有缺陷的接口设计、统一不同接口设计、替换依赖的外部系统、兼容老版本接口、适配不同格式的数据</p>\n<ul>\n<li>在 Spring MVC 中，<code>DispatcherServlet</code>根据请求信息调用<code>HandlerMapping</code>，解析请求对应的<code>Handler</code>。解析到对应的<code>Handler</code>（也就是我们平常说的Controller控制器）后，开始由<code>HandlerAdapter</code>适配器处理。<code>HandlerAdapter</code>作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code>作为需要适配的类（如果不使用，需要自己判断<code>handler</code>（即<code>controller</code>）的类型）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-原理及源码分析-1\"><a href=\"#3-原理及源码分析-1\" class=\"headerlink\" title=\"3.原理及源码分析\"></a>3.原理及源码分析</h3><p><a href=\"https://javadoop.com/post/spring-aop-source\">https://javadoop.com/post/spring-aop-source</a></p>\n<h2 id=\"3-Data-Access\"><a href=\"#3-Data-Access\" class=\"headerlink\" title=\"3.Data Access\"></a>3.Data Access</h2><h3 id=\"1-Transaction-Management\"><a href=\"#1-Transaction-Management\" class=\"headerlink\" title=\"1.Transaction Management\"></a>1.Transaction Management</h3><ol>\n<li>Spring的管理事务的方式<ul>\n<li><strong>编程式事务</strong>：在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助</li>\n<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>\n</ul>\n</li>\n<li>声明式事务：使用<code>@EnableTransactionManagement</code>开启事务注解，使用<code>@Transactional</code>声明事务，其有以下属性<ul>\n<li>transactionManager</li>\n<li>propagation：默认为PROPAGATION_REQUIRED<ul>\n<li><code>PROPAGATION_REQUIRED</code>：当前有服务已经开始一个事务，则加入到该事务，与其一同提交/回滚；如果当前没有事务，则新建一个事务</li>\n<li><code>PROPAGATION_SUPPORTS</code>：支持当前事务，如果当前没有事务，则以非事务方式执行，通常用于处理非原子性的非核心业务逻辑操作</li>\n<li><code>PROPAGATION_MANDATORY</code>：支持当前事务，如果当前没有事务，则抛出异常，防止上下文忘记添加事务的兜底手段，将事务需求托管给上下文</li>\n<li><code>PROPAGATION_REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起，与<code>PROPAGATION_REQUIRED</code>的区别在于前一事务回滚时（被挂起）当前事务不再需要回滚</li>\n<li><code>PROPAGATION_NOT_SUPPORTED</code>： 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，可以帮助减少前一事务的事务范围，减少回滚的影响</li>\n<li><code>PROPAGATION_NEVER</code>： 以非事务方式执行，如果当前存在事务，则抛出异常，要求上下文不能存在事务</li>\n<li><code>PROPAGATION_NESTED</code>： Nested的事务和它的父事务是相依的，它的提交是要等和它的父事务一块提交的，父事务因子事务回滚时仅回滚到savepoint点，然后继续执行另一分支</li>\n</ul>\n</li>\n<li>isolation：默认为ISOLATION_DEFAULT<ul>\n<li><code>ISOLATION_DEFAULT</code>：使用数据库默认的事务隔离级别</li>\n<li><code>ISOLATION_READ_UNCOMMITTED</code>：读未提交，一个事务可以看到另一事务未提交的数据，会产生脏读、不可重复读、幻读</li>\n<li><code>ISOLATION_READ_COMMITTED</code>：读已提交，一个事务只能看到另一事务已提交的数据，可以避免脏读，但是会产生不可重复读、幻读</li>\n<li><code>ISOLATION_REPEATABLE_READ</code>：可重复读，可以防止脏读，不可重复读，但是可能出现幻读<ul>\n<li><strong>幻读和不可重复读的侧重点是不同的，不可重复读侧重于数据修改，两次读取到的同一行数据不一样；而幻读侧重于添加或删除，两次查询返回的数据行数不同</strong></li>\n</ul>\n</li>\n<li><code>ISOLATION_SERIALIZABLE</code>：可序列化，事务顺序执行，可防止脏读，不可重复读外，还避免了幻读</li>\n</ul>\n</li>\n<li>timeout</li>\n<li>readOnly</li>\n</ul>\n</li>\n<li>事务回滚的场景<ul>\n<li>抛出unchecked exception（runtime exception）后会触发事务的回滚，对于checked异常使用try捕获就不会回滚，也可以配置spring参数让其回滚</li>\n<li>spring的事务边界是在调用业务方法之前开始的，业务方法执行完毕之后来执行commit or rollback（Spring默认取决于是否抛出runtime异常）</li>\n<li>如果抛出runtime exception并在你的业务方法中没有catch到的话，事务会回滚。一般不需要在业务方法中catch异常</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-JDBC\"><a href=\"#2-JDBC\" class=\"headerlink\" title=\"2.JDBC\"></a>2.JDBC</h3><ol>\n<li><p>包层次结构</p>\n<ul>\n<li><code>org.springframework.jdbc.core</code>：<code>JdbcTemplate</code>、simple子包中<code>simpleJdbcInsert</code>、<code>SimpleJdbcCal</code>l类、namedparam子包中<code>NamedParameterJdbcTemplate</code></li>\n<li><code>org.springframework.jdbc.datasource</code>：DataSource类、embedded子包中内嵌数据库的支持（HSQL、H2、Derby）</li>\n<li><code>org.springframework.jdbc.object</code>：关系数据库的查询、更新、存储程序</li>\n<li><code>org.springframework.jdbc.support</code>：<code>SQLException</code>、一些工具类</li>\n</ul>\n</li>\n<li><p>JDBC Processing</p>\n<ul>\n<li>JdbcTemplate：可以处理资源的创建和释放，主要用于运行数据库的查询、更新、存储，对ResultSet实例执行迭代并提取返回的参数值，捕获JDBC异常并翻译成通用的。方法有：query、queryForObject、queryForList、update、execute</li>\n<li>NamedParameterJdbcTemplate：对JdbcTemplate的一层封装，简化有参数的SQL</li>\n<li>SQLExceptionTranslator：翻译<code>SQLException</code>和<code>org.sf.dao.DataAccessException</code>的接口，其中一个默认实现是<code>SQLErrorCodeSQLExceptionTranslator</code>，可以解析错误码。Spring会将数据操作的异常转换为<code>DataAccessException</code>，无论使用何种数据访问方式，都能使用一样的异常</li>\n</ul>\n</li>\n<li><p>DataSource</p>\n<ul>\n<li><p>连接工厂，使得一个容器或者一个框架从应用代码中隐藏连接池和事务管理问题，业务开发人员不再需要知道连接数据库的信息。</p>\n</li>\n<li><p>如果是JDBC，那么可以通过JNDI（通过配置而不是放在一起的单一url）来获得数据源；也可以配置数据库连接池（HikariCP/druid）</p>\n</li>\n<li><p>DriverManagerDataSource和SimpleDriverDataSource仅应该用在测试的时候：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DriverManagerDataSource dataSource &#x3D; new DriverManagerDataSource();\ndataSource.setDriverClassName(&quot;org.hsqldb.jdbcDriver&quot;);\ndataSource.setUrl(&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:&quot;);\ndataSource.setUsername(&quot;sa&quot;);\ndataSource.setPassword(&quot;&quot;);</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-O-R-Mapping（MyBatis）\"><a href=\"#3-O-R-Mapping（MyBatis）\" class=\"headerlink\" title=\"3.O/R Mapping（MyBatis）\"></a>3.O/R Mapping（MyBatis）</h3><ol>\n<li>JPA：Java Persistence API，为对象关系映射提供了一种基于POJO的持久化模型，简化数据持久化代码的开发工作，为Java社区屏蔽不同持久化API的差异</li>\n<li>Lombok：能够自动嵌入IDE和构建工具，提升开发效率</li>\n<li>MyBatis：持久层框架，支持定制化SQL、存储过程和高级映射。免除了几乎所有的JDBC代码及相关配置，可以通过注解来配置和映射原始类型、接口和Java POJO为数据库中的记录<ul>\n<li>MyBatis：持久层框架，支持定制化SQL、存储过程和高级映射。免除了几乎所有的JDBC代码及相关配置，可以通过注解来配置和映射原始类型、接口和Java POJO为数据库中的记录</li>\n<li>MyBatis Generator：MyBatis代码生成器，根据数据库表生成相关代码：POJO、Mapper接口、SQL Map XML</li>\n<li>MyBatis PageHelper：用来做分页，支持多种数据库和多种分页方式</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-MVC\"><a href=\"#4-MVC\" class=\"headerlink\" title=\"4.MVC\"></a>4.MVC</h2><h3 id=\"1-基础知识-2\"><a href=\"#1-基础知识-2\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><ol>\n<li><p>一些专有名词</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230509181839256-20230509181858735.png\" alt=\"image-20230509181839256\"></p>\n<ul>\n<li>POJO：plain old java objects简单的Java对象，一般用在数据层映射到数据库表的类，类的属性与表字段一一对应<ul>\n<li>POJO持久化后⇒PO，persistent object，增加了一些<code>getter</code>、<code>setter</code>方法</li>\n<li>POJO传输过程中⇒DTO，data transfer object，比如一张表有100个字段，对应的PO有100个属性，但view层只需要10个字段，所以依靠只有10个属性的DTO来传输数据给client，可以提高性能</li>\n<li>POJO用作表示层⇒VO，view object，用于页面展示</li>\n</ul>\n</li>\n<li>DAO：data access object数据访问接口，用来封装对数据库的访问（CRUD），可以把POJO持久化为PO，用PO组装出VO、DTO</li>\n<li>BO：Business Object，即业务对象。一般用在业务层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递。</li>\n<li><code>controller</code>层：控制请求url用哪个service层逻辑</li>\n<li><code>service</code>层：带有业务逻辑的数据访问API</li>\n</ul>\n</li>\n<li><p>controller：<code>@Controller</code>，是<code>@Component</code>的一个特例，可与<code>@ResponseBody</code>组合成<code>@RestController</code></p>\n<ul>\n<li><p>使用<code>@RequestMapping(&quot;/brand&quot;)</code>来确定该类的顶级域名</p>\n<ul>\n<li><code>path</code>和<code>value</code>用于指定映射路径，<code>value</code>是<code>path</code>的别名</li>\n<li>method用于指定请求方法：Get、Post等，可用<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>、<code>@PatchMapping</code>替代</li>\n<li><code>params</code>指定有哪些参数，或没有哪些参数（<code>!</code>）</li>\n<li><code>headers</code>用来指定请求头中有哪些参数，或没有哪些参数（<code>!</code>）</li>\n<li><code>consumes</code>和<code>produces</code>用于限定请求与响应格式，通过<code>MediaType</code>来指定</li>\n</ul>\n</li>\n<li><p>通过依赖注入来使用Service接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate PmsBrandService demoService;</code></pre></li>\n<li><p>定义子域名和相应的处理逻辑</p>\n<ul>\n<li>抽象出通用返回对象<code>CommonResult</code>，主要有code+message+data三个属性</li>\n<li>抽象出常用的操作码属性</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;create&quot;, method &#x3D; RequestMethod.POST)\n    @ResponseBody\n    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand) &#123;\n        CommonResult commonResult;\n        int count &#x3D; demoService.createBrand(pmsBrand);\n        if (count &#x3D;&#x3D; 1) &#123;\n            commonResult &#x3D; CommonResult.success(pmsBrand);\n            LOGGER.debug(&quot;createBrand success:&#123;&#125;&quot;, pmsBrand);\n        &#125; else &#123;\n            commonResult &#x3D; CommonResult.failed(&quot;操作失败&quot;);\n            LOGGER.debug(&quot;createBrand failed:&#123;&#125;&quot;, pmsBrand);\n        &#125;\n        return commonResult;\n    &#125;</code></pre></li>\n</ul>\n</li>\n<li><p>service</p>\n<ul>\n<li><p>service接口：写实体类的增删改查等方法</p>\n</li>\n<li><p>serviceImpl：<code>@Service</code></p>\n<ul>\n<li><p>实现service接口</p>\n</li>\n<li><p>通过依赖注入，使用Mapper接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate PmsBrandMapper brandMapper;</code></pre></li>\n<li><p>使用xxxMapper接口提供的方法实现service接口中的方法</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>定义处理方法</p>\n<ul>\n<li><p><code>@RequestBody</code>：方法参数是一个请求体，通过<code>HttpMessageConverter</code>读取请求正文并将其反序列化Object</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)\n@ResponseBody\npublic Account handle() &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@ResponseBody</code>：方法返回一个响应体，通过<code>HttpMessageConverter</code>将返回序列化到响应正文</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(&quot;&#x2F;accounts&quot;)\npublic void handle(@RequestBody Account account) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@ResponseStatus</code>：返回的状态码，通过<code>HttpStatus</code>来指定</p>\n</li>\n<li><p><code>@PathVariable</code>：请求URI中的变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;样例一\n@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n    &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F;样例二\n@Controller\n@RequestMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&quot;)\npublic class OwnerController &#123;\n    @GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;</code></pre></li>\n<li><p><code>@RequestParam</code>：请求URI中的参数，可以将Servlet请求参数绑定到控制器中的方法参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping\npublic String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) &#123;\n    Pet pet &#x3D; this.clinic.loadPet(petId);\n    model.addAttribute(&quot;pet&quot;, pet);\n    return &quot;petForm&quot;;\n&#125;</code></pre></li>\n<li><p><code>@MatrixVariable</code>：匹配URI中多个参数中的一个，Matrix Variable中，多个变量用<code>;</code>分隔</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; GET &#x2F;pets&#x2F;42;q&#x3D;11;r&#x3D;22\n@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;\n    &#x2F;&#x2F; petId &#x3D;&#x3D; 42\n    &#x2F;&#x2F; q &#x3D;&#x3D; 11\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>DIspatcherServlet</p>\n<ul>\n<li><p>请求处理（<code>DispatcherServlet</code>里面）</p>\n<ul>\n<li><p>首先，调用doService方法首先绑定一些属性（应用上下文、还有一些Resolver）</p>\n</li>\n<li><p>然后，调用doDispatch方法为请求确定Handler，执行Controller前后的处理器逻辑</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Determine handler for the current request.\nmappedHandler &#x3D; getHandler(processedRequest);\n&#x2F;&#x2F;前置处理\nif (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;\n&#x2F;&#x2F; Actually invoke the handler.\nmv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n&#x2F;&#x2F;后置处理\nmappedHandler.applyPostHandle(processedRequest, response, mv);</code></pre></li>\n<li><p>最后，doDispatch中处理Handler返回的Model，呈现视图</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</code></pre></li>\n</ul>\n</li>\n<li><p>视图解析（xxxResolver）</p>\n<ul>\n<li><code>DispatcherServlet</code>中的<code>initStrategies()</code>初始化了对应的<code>ViewResolver</code></li>\n<li>前面提到的<code>processDispatchResult</code>会做从视图名到视图的解析，通过<code>render</code>呈现视图，在<code>render</code>中解析出<code>view</code>对象</li>\n</ul>\n</li>\n<li><p>异常处理：实现<code>HandlerExceptionResolver</code>接口，例如拦截所有controller</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-原理及源码分析\"><a href=\"#2-原理及源码分析\" class=\"headerlink\" title=\"2.原理及源码分析\"></a>2.原理及源码分析</h3><h2 id=\"5-Spring-Boot\"><a href=\"#5-Spring-Boot\" class=\"headerlink\" title=\"5.Spring Boot\"></a>5.Spring Boot</h2><h3 id=\"1-Annotation\"><a href=\"#1-Annotation\" class=\"headerlink\" title=\"1.Annotation\"></a>1.Annotation</h3><ol>\n<li><p><code>@Autowired</code>：原理见自动装配</p>\n<ol>\n<li><p>用在构造函数上，Spring4.3开始不再需要，但如果有多个构造函数则需要使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n    private final CustomerPreferenceDao customerPreferenceDao;\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>用于传统的setter方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SimpleMovieLister \n    private MovieFinder movieFinder;\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>用于字段，甚至可以将其与构造函数混用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n    @Autowired\n    private MovieCatalog movieCatalog;\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p><code>@Primary</code>表示当多个bean成为自动装配的候选者时，应该优先考虑特定的bean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MovieConfiguration &#123;\n\n    @Bean\n    @Primary\n    public MovieCatalog firstMovieCatalog() &#123; ... &#125;\n\n    @Bean\n    public MovieCatalog secondMovieCatalog() &#123; ... &#125;\n    &#x2F;&#x2F; ...\n&#125;\npublic class MovieRecommender &#123;\n\t&#x2F;&#x2F;自动装配firstMovieCatalog\n    @Autowired\n    private MovieCatalog movieCatalog;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@Qualifier</code>：可以将限定符值与特定参数相关联，缩小类型匹配的范围，以便为每个参数选择特定的bean：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog,\n                        CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog &#x3D; movieCatalog;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@Resource</code>：采用名称属性，默认将该值解释为要注入的bean名称，如果没有明确指定名称，如果是字段，则采用字段名称，如果是setter方法，则采用bean属性名称</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n    @Resource(name&#x3D;&quot;myMovieFinder&quot;) \n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n&#125;</code></pre></li>\n<li><p><code>@Value</code>：通常用于注入外部化属性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class MovieRecommender &#123;\n\n    private final String catalog;\n    &#x2F;&#x2F;application.properties中有catalog.name&#x3D;MovieCatalog\n    &#x2F;&#x2F;catalog的值就为MovieCatalog\n    public MovieRecommender(@Value(&quot;$&#123;catalog.name&#125;&quot;) String catalog) &#123;\n        this.catalog &#x3D; catalog;\n    &#125;\n&#125;\n&#x2F;&#x2F;还需以下配置\n@Configuration\n@PropertySource(&quot;classpath:application.properties&quot;)\npublic class AppConfig &#123; &#125;</code></pre></li>\n<li><p><code>@Compoent</code>：</p>\n<ol>\n<li><p>任何满足存储库角色（DAO）的类的标记，用途是异常的自动翻译，类似的其它原型注解有：<code>@Controller（表示层）</code>、<code>@Service（服务层）</code>、<code>@Repository（持久层）</code>，尽量不选<code>@Component</code>而选后面那三个</p>\n</li>\n<li><p>Spring能自动检测原型类，并使用<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例，要自动检测这些类并注册相应的bean，需要将<code>@ComponentScan(basePackages = &quot;org.example&quot;)</code>添加到<code>@Configuration</code>类中</p>\n</li>\n<li><p>用<code>@Component</code>定义bean元数据：将bean定义元数据贡献给容器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\npublic class FactoryMethodComponent &#123;\n    @Bean\t&#x2F;&#x2F;表示工厂方法和其它bean定义属性\n    @Qualifier(&quot;public&quot;)\n    public TestBean publicInstance() &#123;\n        return new TestBean(&quot;publicInstance&quot;);\n    &#125;\n\n    public void doWork() &#123;\n        &#x2F;&#x2F; Component method implementation omitted\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p><code>@Configuration</code></p>\n<ol>\n<li><p>用<code>@Configuration</code>注释一个类表明一个对象时bean定义的来源，此外，<code>Configuration</code>类允许通过调用同一类中的其它<code>@Bean</code>方法来定义bean间的依赖关系</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class AppConfig &#123;\n    @Bean\n    public MyService myService() &#123;\n        return new MyServiceImpl();\n    &#125;\n&#125;\n&#x2F;&#x2F;与下面xml语句相同：\n&#x2F;&#x2F;&lt;beans&gt;\n&#x2F;&#x2F;    &lt;bean id&#x3D;&quot;myService&quot; class&#x3D;&quot;com.acme.services.MyServiceImpl&quot;&#x2F;&gt;\n&#x2F;&#x2F;&lt;&#x2F;beans&gt;</code></pre></li>\n<li><p>当<code>@Configuration</code>类作为输入提供时，<code>@Configuration</code>类本身被注册为bean定义，并且类中所有声明的<code>@Bean</code>方法也被注册为bean定义，使用<code>AnnotationConfigApplicationContext</code>访问</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n    MyService myService &#x3D; ctx.getBean(MyService.class);\n    myService.doStuff();\n&#125;</code></pre></li>\n<li></li>\n</ol>\n</li>\n<li><p><code>@Bean</code></p>\n<ol>\n<li><p>用于表示一个方法实例化、配置和初始化一个由IoC容器管理的新对象，与<code>&lt;beans/&gt;</code>元素的作用相同。可以使用此方法来制定为方法返回值的类型的<code>ApplicationContext</code>中注册bean定义。可以和任何Spring的<code>@Component</code>一起使用，但是通常与<code>@Configuration</code>bean一起使用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class AppConfig &#123;\n    @Bean&#x2F;&#x2F;默认情况，bean名称与方法名称相同\n    public TransferServiceImpl transferService() &#123;\n        return new TransferServiceImpl();\n    &#125;\n    &#x2F;&#x2F;可以有任意数量的参数来描述构建该bean所需的依赖项\n    &#x2F;&#x2F;@Bean\n    &#x2F;&#x2F; public TransferService transferService(AccountRepository accountRepository) &#123;\n    &#x2F;&#x2F;     return new TransferServiceImpl(accountRepository);\n    &#x2F;&#x2F;&#125;\n&#125;</code></pre></li>\n<li></li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-AutoConfiguration\"><a href=\"#2-AutoConfiguration\" class=\"headerlink\" title=\"2.AutoConfiguration\"></a>2.AutoConfiguration</h3><ol>\n<li></li>\n</ol>\n<h3 id=\"3-SpringApplication\"><a href=\"#3-SpringApplication\" class=\"headerlink\" title=\"3.SpringApplication\"></a>3.SpringApplication</h3>","text":"Spring1.IOC1.基础知识 BeanFactory：提供了一种高级配置，能够管理任何类型对象，BeanFactory是ApplicationContext的父接口，ApplicationContext接口的实现类主要有ClassPathXmlApplicationCont...","link":"","photos":[],"count_time":{"symbolsCount":"58k","symbolsTime":"52 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":4,"path":"api/tags/tools.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring\"><span class=\"toc-text\">Spring</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-IOC\"><span class=\"toc-text\">1.IOC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">1.基础知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.设计模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.原理及源码分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-AOP\"><span class=\"toc-text\">2.AOP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1\"><span class=\"toc-text\">1.基础知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1\"><span class=\"toc-text\">2.设计模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1\"><span class=\"toc-text\">3.原理及源码分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Data-Access\"><span class=\"toc-text\">3.Data Access</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Transaction-Management\"><span class=\"toc-text\">1.Transaction Management</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-JDBC\"><span class=\"toc-text\">2.JDBC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-O-R-Mapping%EF%BC%88MyBatis%EF%BC%89\"><span class=\"toc-text\">3.O&#x2F;R Mapping（MyBatis）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-MVC\"><span class=\"toc-text\">4.MVC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2\"><span class=\"toc-text\">1.基础知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.原理及源码分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-Spring-Boot\"><span class=\"toc-text\">5.Spring Boot</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Annotation\"><span class=\"toc-text\">1.Annotation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-AutoConfiguration\"><span class=\"toc-text\">2.AutoConfiguration</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-SpringApplication\"><span class=\"toc-text\">3.SpringApplication</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Nginx","uid":"af6a277a1f79cc7652a602f9f57ed64f","slug":"Nginx","date":"2023-05-06T05:10:16.000Z","updated":"2023-05-11T04:20:34.174Z","comments":true,"path":"api/articles/Nginx.json","keywords":null,"cover":[],"text":"Nginx（未完待续）1.基础知识1.安装 通过源码安装可以指定添加（–with）或删除（–without）某些module 主要组成：二进制可执行文件（车，由各模块源码编译出的一个文件）、Nginx.conf配置文件（驾驶员，配置Nginx的行为）、access.log访问日志...","link":"","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":4,"path":"api/tags/tools.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis","uid":"a978a5e93d8e6628e9f4ee713be55be8","slug":"Redis","date":"2023-05-04T10:00:34.000Z","updated":"2023-05-06T04:34:37.474Z","comments":true,"path":"api/articles/Redis.json","keywords":null,"cover":[],"text":"Redis Redis是一个高性能（内存+Reactor+优化的数据结构）的开源键值数据库，其value支持丰富的数据类型（string、hash、set、list、zset「有序集合」），具有数据可持久化、支持master-slave备份、读写性能高（MySQL的QPS大概1w...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[],"tags":[{"name":"database","slug":"database","count":2,"path":"api/tags/database.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}