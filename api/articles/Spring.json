{"title":"Spring Family","uid":"0eecce2180060832c1ffa34a76f3eb3b","slug":"Spring","date":"2023-05-06T05:09:43.000Z","updated":"2023-09-25T12:54:34.905Z","comments":true,"path":"api/articles/Spring.json","keywords":null,"cover":[],"content":"<h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Spring框架是一个开源的Java应用程序框架，用于简化企业级Java应用程序的开发。它提供了广泛的基础设施支持，包括依赖注入（Dependency Injection）、面向切面编程（Aspect-Oriented Programming）、事务管理、数据访问、消息传递等功能，以帮助开发者构建可维护、可扩展、松散耦合的应用程序</p></blockquote>\n<h2 id=\"1-IOC\"><a href=\"#1-IOC\" class=\"headerlink\" title=\"1.IOC\"></a>1.IOC</h2><h3 id=\"1-基础知识\"><a href=\"#1-基础知识\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><ol>\n<li><p>IOC（Inversion of Control，IoC）是一种设计原则，它将应用程序的控制权从应用程序代码中转移到外部容器或框架。在IoC中，对象的创建、组装和管理不再由应用程序本身负责，而是由IoC容器或框架来完成，原理如下：</p>\n<ul>\n<li><strong>配置元数据：</strong> 应用程序的对象及其依赖关系通常通过XML配置文件或Java注解来描述</li>\n<li><strong>容器初始化及对象的管理：</strong> 应用程序启动时通过读取配置信息来初始化IOC容器。IOC容器负责实例化对象，管理对象的生命周期（初始化<code>@PostConstruct</code>、使用和销毁<code>@PreDestroy</code>），在使用时从IOC容器中获取所需要的对象（容器返回已创建和配置好的对象实例）</li>\n<li><strong>依赖注入：</strong>IOC容器负责注入对象之间的依赖关系，根据配置信息自动将依赖注入到对象中</li>\n</ul>\n</li>\n<li><p>容器启动过程：</p>\n<ul>\n<li><strong>加载配置文件或配置类：</strong> Spring容器会首先加载配置文件（如XML配置文件）或配置类（如使用Java配置的方式）。这些配置文件或类包含了Spring应用程序的配置信息，定义了需要被容器管理的Bean以及它们之间的依赖关系。</li>\n<li><strong>创建容器：</strong> 根据加载的配置信息，Spring容器会创建一个容器对象，通常是<code>ApplicationContext</code>的实例。容器的类型可以根据配置来选择，常见的包括<code>ClassPathXmlApplicationContext</code>、<code>AnnotationConfigApplicationContext</code>等。</li>\n<li><strong>扫描和注册Bean定义：</strong> Spring容器会扫描配置文件或配置类中的Bean定义，然后将这些Bean定义注册到容器中。Bean定义包括Bean的类型、作用域、初始化方法、销毁方法等信息。</li>\n<li><strong>实例化Bean：</strong> 容器根据Bean定义，实例化应用程序中所有需要被管理的Bean。这通常涉及到创建Bean的Java对象实例，并将其存储在容器的Bean工厂中。</li>\n<li><strong>依赖注入：</strong> Spring容器会处理Bean之间的依赖关系。它会查找需要注入的属性或构造函数参数，然后根据配置找到相应的Bean，将其注入到目标Bean中。</li>\n<li><strong>初始化Bean：</strong> 在Bean的生命周期中，Spring容器会调用初始化方法。这可以是通过<code>@PostConstruct</code>注解标记的方法，或者是配置中指定的初始化方法。初始化方法可以包括一些必要的配置和资源初始化。</li>\n<li><strong>应用程序运行：</strong> Spring容器启动后，应用程序可以开始运行。开发者可以通过容器获取需要的Bean，并调用它们的方法执行业务逻辑。</li>\n<li><strong>关闭容器：</strong> 当应用程序需要关闭时，开发者可以显式地关闭Spring容器。容器会执行销毁Bean的操作，包括调用<code>@PreDestroy</code>注解标记的销毁方法。</li>\n<li><strong>资源释放：</strong> 在容器关闭过程中，容器会释放占用的资源，如数据库连接、线程池等。这确保资源得到正确释放，防止资源泄漏。</li>\n</ul>\n</li>\n<li><p>BeanFactory：提供了一种高级配置，能够管理任何类型对象，<code>BeanFactory</code>是<code>ApplicationContext</code>的父接口，<code>ApplicationContext</code>接口的实现类主要有<code>ClassPathXmlApplicationContext</code>、<code>FileSystemXmlApplicationContext</code>、<code>WebApplicationContext</code>、<code>AnnotationConfigApplicationContext</code>等，主要负责Bean的实例化、配置、组装</p>\n<ul>\n<li>安装容器：<code>ApplicationContext context = new ClassPathXmlApplicationContext(&quot;services.xml&quot;, &quot;daos.xml&quot;);</code></li>\n</ul>\n</li>\n<li><p>Bean：由Spring的IOC容器实例化、组装和管理的对象，一个Bean有全局唯一的name，其它的只能指定别名</p>\n<ul>\n<li><p>bean定义：Class、Name（全局唯一）、Scope、Constructor arguments、Properties、Autowiring mode、Lazy initialization mode、Lazy initialization mode、</p>\n</li>\n<li><p>==生命周期（作用域）==</p>\n<table>\n<thead>\n<tr>\n<th><strong>Scope</strong></th>\n<th><strong>Description</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>singleton</td>\n<td>(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>\n</tr>\n<tr>\n<td>prototype</td>\n<td>Scopes a single bean definition to any number of object instances.</td>\n</tr>\n<tr>\n<td>request</td>\n<td>Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition.</td>\n</tr>\n<tr>\n<td>session</td>\n<td>Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>.</td>\n</tr>\n<tr>\n<td>application</td>\n<td>Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>.</td>\n</tr>\n<tr>\n<td>websocket</td>\n<td>Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>.</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>实例化：bean定义本质上是创建一个或多个对象的方法，当被访问到时，容器会查看bean的命名和定义来创建实际对象</p>\n<ul>\n<li>通过构造方法实例化：所有普通类（默认空参构造+getter+setter）都可以被Spring使用并兼容，只需要指定bean类</li>\n<li>通过静态工厂方法实例化：使用class属性来指定包含静态工厂方法的类，并使用<code>factory-method</code>的属性来指定工厂方法本身的名称，主要用于在遗留代码中调用静态工厂来实例化bean</li>\n<li>通过实例工厂方法实例化：使用实例工厂中的非静态方法来创建新bean，使用<code>factory-bean</code>指定工厂类对应的bean，使用<code>factory-method</code>的属性来指定工厂方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>容器扩展点</p>\n<ol>\n<li><p>BeanPostProcessor：通过实现其提供的回调方法，来提供定制的实例化逻辑、依赖解析逻辑，<code>BeanPostProcessor</code>的两个方法分别在Bean的初始化前后执行（<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>）</p>\n<ul>\n<li><p>AOP自动代理类：<code>DefaultAdvisorAutoProxyCreator</code>，可以实现自动生效所有的advisor</p>\n</li>\n<li><p>Spring自动装配的实现类：<code>AutowiredAnnotationBeanPostProcessor</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">         public interface BeanPostProcessor &#123;\n             @Nullable\n             default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;return bean;&#125;\n             @Nullable\n             default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;return bean;&#125;\n         &#125;</code></pre></li>\n</ul>\n</li>\n<li><p>BeanFactoryPostProcessor：与<code>BeanPostProcessor</code>的区别是<code>BeanFactoryPostProcessor</code>对bean的配置元数据进行操作，并可以在容器实例化除<code>BeanFactoryPostProcessor</code>实例之外的任何bean之前更改它</p>\n</li>\n</ol>\n<ul>\n<li><p>从外部<code>jdbc.properties</code>文件导入<code>DataSource</code>的某些属性的元数据：<code>PropertySourcesPlaceholderConfigurer</code></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">        &lt;!--加载properties文件--&gt;\n        &lt;context:property-placeholder location&#x3D;&quot;classpath*:jdbc.properties&quot;&#x2F;&gt;\n        &lt;!--数据源--&gt;\n        &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n            &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;$&#123;jdbc.driver&#125;&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;$&#123;jdbc.url&#125;&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;$&#123;jdbc.username&#125;&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&#x2F;&gt;\n        &lt;&#x2F;bean&gt;</code></pre></li>\n</ul>\n<ol start=\"3\">\n<li>FactoryBean</li>\n</ol>\n</li>\n<li><p>依赖注入：通过定义需要的依赖，并将这些依赖注入到bean中，可以使得代码更简洁，更方便测试。对强制依赖项使用构造函数，对可选依赖使用setter方法</p>\n<ul>\n<li><p>依赖注入处理流程</p>\n<ul>\n<li>通过所有bean的元数据的描述构造并初始化<code>ApplicationContext</code></li>\n<li>对每一个bean，它的依赖关系以属性、构造函数或静态工厂方法的参数的形式表示，并在实际创建bean时提供给bean</li>\n<li>每个属性或构造函数参数都是要设置的值的实际定义，或是对容器中另一个bean的引用</li>\n<li>作为值的每个属性或构造函数参数都从其指定格式转换为该属性或构造函数参数的实际类型</li>\n</ul>\n</li>\n<li><p>自动装配的四种模式：？</p>\n<ul>\n<li><code>no</code>：不自动装配，bean引用必须有ref元素定义</li>\n<li><code>byName</code>：按属性名自动装配，Spring寻找与需要自动装配的属性同名的bean，例如有setMaster()方法的bean会去找名为master的bean定义</li>\n<li><code>byType</code>：如果容器中恰好存在一个属性类型的bean，则让属性自动装配；如果存在多个，则需要使用byType自动装配</li>\n<li><code>constructor</code>：与byType类似，但适用于构造函数参数，如果容器中没有一个构造函数参数类型的bean，则会引发错误</li>\n</ul>\n</li>\n<li><p>延迟初始化bean：单例bean常常会很早初始化，当不需要提前初始化bean来验证错误时，可以将bean定义标记为延迟初始化来防止单例bean的预实例化。lazy bean不会被太早实例化，not.lazy bean会被很早实例化</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;bean id&#x3D;&quot;lazy&quot; class&#x3D;&quot;com.something.ExpensiveToCreateBean&quot; lazy-init&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean name&#x3D;&quot;not.lazy&quot; class&#x3D;&quot;com.something.AnotherBean&quot;&#x2F;&gt;</code></pre></li>\n</ul>\n</li>\n<li><p>自动装配原理（条件注解+依赖注入）</p>\n<ul>\n<li>首先，Spring Boot会根据classpath下的依赖以及配置文件中的设置，自动扫描并加载相应的自动配置类</li>\n<li>其次，自动配置类中使用了条件注解，根据条件判断是否要进行自动装配。条件注解可以根据一些特定的条件，如某个类是否在classpath中、某个配置是否存在等，来决定是否要进行自动装配</li>\n<li>最后，当条件满足时，自动配置类会自动注册和配置相应的Bean，将它们添加到Spring容器中。这样，在应用程序启动时，Spring Boot就会自动完成大部分配置工作，开发者无需手动配置</li>\n</ul>\n</li>\n<li><p>依赖注入</p>\n<ol>\n<li><p>注入方式</p>\n<ol>\n<li><p>Field Injection：通过Java的反射机制实现，所以private的成员也可以被注入具体的对象</p>\n<ul>\n<li>@Autowired 根据类型来注入，Spring框架提供的注解，支持自动装配、按类型查找、按名称查找</li>\n<li>@Resource 根据名字来注入，是Java EE规范中的注解由标准库提供</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\npublic class UserController &#123;\n\n    @Autowired\n    private UserService userService;\n\n&#125;</code></pre></li>\n<li><p>Constructor Injection：这种注入方式很直接，通过对象构建的时候建立关系，所以这种方式对对象创建的顺序会有要求，当然Spring会为你搞定这样的先后顺序，除非你出现循环依赖，然后就会抛出异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\npublic class UserController &#123;\n\n    private final UserService userService;\n\n    public UserController(UserService userService)&#123;\n        this.userService &#x3D; userService;\n    &#125;\n\n&#125;</code></pre></li>\n<li><p>Setter Injection：<code>Setter Injection</code>也会用到<code>@Autowired</code>注解，但使用方式与<code>Field Injection</code>有所不同，<code>Field Injection</code>是用在成员变量上，而<code>Setter Injection</code>的时候，是用在成员变量的Setter函数上。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Controller\npublic class UserController &#123;\n\n    private UserService userService;\n\n    @Autowired\n    public void setUserService(UserService userService)&#123;\n        this.userService &#x3D; userService;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>注入方式对比</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230925105247874.png\" alt=\"image-20230925105247874\"></p>\n</li>\n<li><p>推荐使用方式</p>\n<ol>\n<li><code>Constructor Injection</code>在很多方面都是优于其他两种方式的，所以<code>Constructor Injection</code>通常都是首选方案！而<code>Setter Injection</code>比起<code>Field Injection</code>来说，大部分都一样，但因为可测试性更好，所以当你要用<code>@Autowired</code>的时候，推荐使用<code>Setter Injection</code>的方式，这样IDEA也不会给出警告了。同时，也侧面反映了，可测试性的重要地位啊！</li>\n<li>依赖注入的使用上，<code>Constructor Injection</code>是首选。</li>\n<li>使用<code>@Autowired</code>注解的时候，要使用<code>Setter Injection</code>方式，这样代码更容易编写单元测试。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-设计模式\"><a href=\"#2-设计模式\" class=\"headerlink\" title=\"2.设计模式\"></a>2.设计模式</h3><ol>\n<li><p>单例模式：一个类在同一进程内只允许创建一个对象（或实例），通过将构造函数声明为<code>private</code>，并在内部以<code>static final</code>的方式创建对象并返回的方式实现，具体实现如下：</p>\n<ul>\n<li><p>模版代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;不支持延迟加载&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class IdGenerator&#123;\n  private AtomicLong id &#x3D; new AtomicLong(10);\n  private static final IdGenerator instance &#x3D; new IdGenerator();\n  private IdGenerator()&#123;&#125;\n  private static IdGenerator getInstance()&#123;return instance;&#125;\n  public long getId()&#123;return id.incrementAndGet();&#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;支持延迟加载（需要解决线程安全问题）&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class IdGenerator&#123;\n  private AtomicLong id &#x3D; new AtomicLong(10);\n  private static final IdGenerator instance;\n  private IdGenerator()&#123;&#125;\n  private static IdGenerator getInstance()&#123;\n    if(instance &#x3D;&#x3D; null)&#123;\n      synchronized(IdGenerator.class)&#123;\n        if(instance &#x3D;&#x3D; null)&#123;\n          instance &#x3D; new IdGenerator();\n        &#125;\n      &#125;\n    &#125;&#x2F;&#x2F;if(instance &#x3D;&#x3D; null)\n    return instance;\n  &#125;\n  public long getId()&#123;return id.incrementAndGet();&#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;有参构造&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic synchronized static Singleton getInstance(int param) &#123; \n    if (instance &#x3D;&#x3D; null) &#123; \n        instance &#x3D; new Singleton(param); \n    &#125; else if (instance.param &#x3D;&#x3D; param) &#123;\n        return instance;\n    &#125; else &#123;\n        instance &#x3D; new Singleton(paramA, paramB);\n    &#125;\n    return instance; \n&#125;\nSingleton singleton &#x3D; Singleton.getInstance(10);\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;利用静态内部类在被调用时才加载（与外部类加载时间无关）的特性来实现&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nprivate static class SingletonHolder&#123;\n  private static final IdGenerator instance &#x3D; new IdGenerator();\n&#125;\npublic static IdGenerator getInstance() &#123;\n  return SingletonHolder.instance;\n&#125;\n</code></pre></li>\n<li><p>特殊形式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;线程唯一单例实现&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nprivate static final ConcurrentHashMap&lt;Long, IdGenerator&gt; instances &#x3D; new ConcurrentHashMap&lt;&gt;();\npublic static IdGenerator getInstance() &#123;\n    Long currentThreadId &#x3D; Thread.currentThread().getId();\n    instances.putIfAbsent(currentThreadId, new IdGenerator());\n    return instances.get(currentThreadId);\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;集群唯一单例实现&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F;不同进程间共享同一个对象需要将单例序列化到外部共享存储区，使用时再反序列化回来，通过给对象加锁保证保证唯一性\nprivate static SharedObjectStorage storage &#x3D; FileSharedObjectStorage(&#x2F;*入参省略，比如文件地址*&#x2F;);\nprivate static DistributedLock lock &#x3D; new DistributedLock();\npublic synchronized static IdGenerator getInstance()&#123;\n    if (instance &#x3D;&#x3D; null) &#123;\n        lock.lock();\n        instance &#x3D; storage.load(IdGenerator.class);\n    &#125;\n\t\treturn instance;\n&#125;\npublic synchroinzed void freeInstance() &#123;\n    storage.save(this, IdGeneator.class);\n    instance &#x3D; null; &#x2F;&#x2F;释放对象\n    lock.unlock();\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;多例模式&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nprivate static final Map&lt;Long, BackendServer&gt; serverInstances &#x3D; new HashMap&lt;&gt;();\nstatic &#123;\n  serverInstances.put(1L, new BackendServer(1L, &quot;192.134.22.138:8080&quot;));\n  serverInstances.put(2L, new BackendServer(2L, &quot;192.134.22.139:8080&quot;));\n  serverInstances.put(3L, new BackendServer(3L, &quot;192.134.22.140:8080&quot;));\n&#125;\npublic BackendServer getInstance(long serverNo) &#123;\n  return serverInstances.get(serverNo);\n&#125;\n&#x2F;&#x2F;同一类型的只能创建一个对象，不同类型的可以创建多个对象\nprivate static final ConcurrentHashMap&lt;String, Logger&gt; instances &#x3D; new ConcurrentHashMap&lt;&gt;();\npublic static Logger getInstance(String loggerName) &#123;\n  instances.putIfAbsent(loggerName, new Logger());\n  return instances.get(loggerName);\n&#125;\n&#x2F;&#x2F;l1&#x3D;&#x3D;l2, l1!&#x3D;l3\nLogger l1 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l2 &#x3D; Logger.getInstance(&quot;User.class&quot;);\nLogger l3 &#x3D; Logger.getInstance(&quot;Order.class&quot;);</code></pre></li>\n<li><p>Spring中的Bean默认都是singleton的，Spring通过ConcurrentHashMap实现单例注册表的特殊方式实现单例模式</p>\n<ul>\n<li>线程安全问题：尽量避免定义可变的成员变量（大部分Bean如Dao、Service都没有实例变量，是线程安全的），如果需要定义则使用ThreadLocal成员变量</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过 ConcurrentHashMap（线程安全） 实现单例注册表\nprivate final Map&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;String, Object&gt;(64);\n\npublic Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) &#123;\n        Assert.notNull(beanName, &quot;&#39;beanName&#39; must not be null&quot;);\n        synchronized (this.singletonObjects) &#123;\n            &#x2F;&#x2F; 检查缓存中是否存在实例\n            Object singletonObject &#x3D; this.singletonObjects.get(beanName);\n            if (singletonObject &#x3D;&#x3D; null) &#123;\n                &#x2F;&#x2F;...省略了很多代码\n                try &#123;\n                    singletonObject &#x3D; singletonFactory.getObject();\n                &#125;\n                &#x2F;&#x2F;...省略了很多代码\n                &#x2F;&#x2F; 如果实例对象在不存在，我们注册到单例注册表中。\n                addSingleton(beanName, singletonObject);\n            &#125;\n            return (singletonObject !&#x3D; NULL_OBJECT ? singletonObject : null);\n        &#125;\n    &#125;\n    &#x2F;&#x2F;将对象添加到单例注册表\n    protected void addSingleton(String beanName, Object singletonObject) &#123;\n            synchronized (this.singletonObjects) &#123;\n                this.singletonObjects.put(beanName, (singletonObject !&#x3D; null ? singletonObject : NULL_OBJECT));\n\n            &#125;\n        &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>工厂模式</p>\n<ul>\n<li><p>工厂方法：涉及多个if-else和复杂的对象创建语句时，将创建代码抽象出一个新的类作为对象创建的工厂，封装对象的创建过程，将对象的创建和使用相分离，统一调度。还可以利用多态去掉if分支（实现接口，简化插入），利用工厂的工厂来简化使用，符合开闭原则</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;简单实现，构造函数直接抽取出来&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class RuleConfigParserFactory &#123;\n    public static IRuleConfigParser createParser(String configFormat) &#123;\n        IRuleConfigParser parser &#x3D; null;\n        if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new JsonRuleConfigParser();\n        &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new XmlRuleConfigParser();\n        &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new YamlRuleConfigParser();\n        &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;\n            parser &#x3D; new PropertiesRuleConfigParser();\n        &#125;\n        return parser;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;多态，利用接口来满足开闭原则，适合每个对象的创建都很复杂的情况，避免设计一个大而全的工厂方法&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic interface IRuleConfigParserFactory &#123; IRuleConfigParser createParser(); &#125;\npublic class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createParser() &#123; return new JsonRuleConfigParser(); &#125;\n&#125;\n&#x2F;&#x2F;省略XmlRuleConfigParserFactory，YamlRuleConfigParserFactory，PropertiesRuleConfigParserFactory\n\npublic class RuleConfigParserFactoryMap &#123; &#x2F;&#x2F;工厂的工厂\n    private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories &#x3D; new HashMap&lt;&gt;();\n  \t&#x2F;&#x2F;缓存，为了节省时间提前创建并缓存对象\n    static &#123;\n        cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());\n        cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());\n        cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());\n        cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());\n    &#125;\n\n    public static IRuleConfigParserFactory getParserFactory(String type) &#123;\n        if (type &#x3D;&#x3D; null || type.isEmpty()) &#123;\n            return null;\n        &#125;\n        IRuleConfigParserFactory parserFactory &#x3D; cachedFactories.get(type.toLowerCase());\n        return parserFactory;\n    &#125;\n&#125;\n&#x2F;&#x2F;IRuleConfigParserFactory parserFactory &#x3D; \t\tRuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);&#x2F;&#x2F;利用接口接收对应类型的工厂\n&#x2F;&#x2F;IRuleConfigParser parser &#x3D; parserFactory.createParser();</code></pre></li>\n<li><p>抽象工厂：传统工厂方法类只有一种分类方式，对应的构造函数会成倍的增长，抽象工厂可以让一个工厂负责多个不同类型的对象创建，而不是只创建一类对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface IConfigParserFactory &#123;\n    IRuleConfigParser createRuleParser();\n    ISystemConfigParser createSystemParser();\n    &#x2F;&#x2F;此处可以扩展新的parser类型，比如IBizConfigParser\n&#125;\n\npublic class JsonConfigParserFactory implements IConfigParserFactory &#123;\n    @Override\n    public IRuleConfigParser createRuleParser() &#123;\n        return new JsonRuleConfigParser();\n    &#125;\n\n    @Override\n    public ISystemConfigParser createSystemParser() &#123;\n        return new JsonSystemConfigParser();\n    &#125;\n&#125;\n&#x2F;&#x2F; 省略XmlConfigParserFactory、YamlConfigParserFactory和PropertiesConfigParserFactory代码</code></pre></li>\n<li><p>依赖注入（IOC、DI、Container）</p>\n<ul>\n<li>DI容器：设计思路基于工厂模式，底层相当于一个大的工厂类，负责在程序启动的时候根据配置（要创建哪些类的对象、每个对象依赖哪些对象的创建）事先创建好对象，当应用程序需要某个类对象的时候，直接从容器中获取即可。称为容器是因为框架持有一堆对象</li>\n<li>核心功能<ul>\n<li>配置解析：从配置文件中读取类对象和创建类对象的相关信息，根据配置文件创建对象，比如Spring的xml文件中的bean</li>\n<li>对象创建：通过一个工厂类，如BeansFactory来以反射的方式，在程序运行过程中动态地加载类、创建对象，不需要一次创建完所有需要的对象</li>\n<li>对象声明周期管理：单例模式（全局只有一个）、原型模式（每次都新创建一个）、懒加载（对象用到的时候再创建）<ul>\n<li>init-method：增加此配置，可以在创建对象之前调用指定方法来初始化对象</li>\n<li>destroy-method：增加此配置，可以在销毁对象之后调用指定方法来做一些清理工作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>示例：通过BeanFactory或ApplicationContext创建Bean对象，其中BeanFactory延迟注入，懒加载，在使用到Bean的时候才会注入；而ApplicationContext在容器启动的时候，一次创建了所有Bean，但是ApplicationContext扩展了BeanFactory的功能，有以下实现类<ul>\n<li><code>ClassPathXmlApplicationContext</code>，通过解析配置文件得到配置信息（BeanDefinition），根据配置信息使用BeansFactory通过反射来创建对象并返回</li>\n<li><code>FileSystemXmlApplication</code>：从文件系统中的 XML 文件载入上下文定义信息</li>\n<li><code>XmlWebApplicationContext</code>：从 Web 系统中的 XML 文件载入上下文定义信息</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>观察者模式：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</p>\n<ul>\n<li><p>模版代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Subject &#123;\n    &#x2F;&#x2F;也可起名为attach\n    void registerObserver(Observer observer);\n    &#x2F;&#x2F;也可起名为detach\n    void removeObserver(Observer observer);\n    &#x2F;&#x2F;一个一个通知\n    void notifyObservers(Message message);\n&#125;\n&#x2F;&#x2F;被依赖的对象叫被观察者（Observable）；依赖的对象叫观察者（Observer）\npublic interface Observer &#123;\n    void update(Message message);\n&#125;\n&#x2F;&#x2F;Concrete：具体的\npublic class ConcreteSubject implements Subject &#123;\n    private List&lt;Observer&gt; observers &#x3D; new ArrayList&lt;Observer&gt;();\n\n    @Override\n    public void registerObserver(Observer observer) &#123;\n        observers.add(observer);\n    &#125;\n\n    @Override\n    public void removeObserver(Observer observer) &#123;\n        observers.remove(observer);\n    &#125;\n\n    @Override\n    public void notifyObservers(Message message) &#123;  &#x2F;&#x2F;通知所有依赖的对象，响应通知调用对应的代码\n      \t&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;同步阻塞和异步非阻塞二选一&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n      \t&#x2F;&#x2F;同步阻塞方式\n        for (Observer observer : observers) &#123;\n            observer.update(message);\n        &#125;\n      \t&#x2F;&#x2F;异步非阻塞方式，新启线程或直接引入线程池\n      \t&#x2F;&#x2F;private Executor executor &#x2F;&#x2F; 线程池\n      \tfor(Observer observer : observers) &#123;\n          executor.execute(new Runnable()&#123;\n            @Override\n            public void run()&#123;\n              observer.update(messgae);\n            &#125;\n          &#125;)\n        &#125;\n    &#125;\n&#125;\n\npublic class ConcreteObserverOne implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverOne is notified.&quot;);\n    &#125;\n&#125;\n\npublic class ConcreteObserverTwo implements Observer &#123;\n    @Override\n    public void update(Message message) &#123;\n        &#x2F;&#x2F;TODO: 获取消息通知，执行自己的逻辑...\n        System.out.println(&quot;ConcreteObserverTwo is notified.&quot;);\n    &#125;\n&#125;\n\npublic class Demo &#123;\n    public static void main(String[] args) &#123;\n        ConcreteSubject subject &#x3D; new ConcreteSubject();\n        subject.registerObserver(new ConcreteObserverOne());\n        subject.registerObserver(new ConcreteObserverTwo());\n        subject.notifyObservers(new Message());\n    &#125;\n&#125;</code></pre></li>\n<li><p>EventBus框架（事件总线）：提供了观察者模式的骨架代码，如Google Guava中的EventBus，同时支持同步阻塞和异步非阻塞</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserController &#123;\n    private UserService userService; &#x2F;&#x2F; 依赖注入\n\n    private EventBus eventBus;\n    private static final int DEFAULT_EVENTBUS_THREAD_POOL_SIZE &#x3D; 20;\n\n    public UserController() &#123;\n        &#x2F;&#x2F;eventBus &#x3D; new EventBus(); &#x2F;&#x2F; 同步阻塞模式\n        eventBus &#x3D; new AsyncEventBus(Executors.newFixedThreadPool\n                                     (DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); &#x2F;&#x2F; 异步非阻塞\n    &#125;\n\n    public void setRegObservers(List&lt;Object&gt; observers) &#123;\n        for (Object observer : observers) &#123;\n            &#x2F;&#x2F;用来注册任何类型（Object）的观察者，而在经典的观察者模式的实现中，\n            &#x2F;&#x2F;register() 函数必须接受实现了同一 Observer 接口的类对象。\n            eventBus.register(observer);\n        &#125;\n    &#125;\n\n    public Long register(String telephone, String password) &#123;\n        long userId &#x3D; userService.register(telephone, password);\n        \n\t\t\t\t&#x2F;&#x2F;用来给观察者发送信息，当调用post()函数发送信息的时候，并非把消息发送给所有的观察者，而是发送给可匹配的\n      \t&#x2F;&#x2F;观察者，即接受的消息类型是发送消息（post函数定义中的event）类型的父类\n        eventBus.post(userId);\n\n        return userId;\n    &#125;\n&#125;\npublic class RegPromotionObserver &#123;\n    private PromotionService promotionService; &#x2F;&#x2F; 依赖注入\n\n    @Subscribe&#x2F;&#x2F;定义能接收的消息类型\n    public void handleRegSuccess(Long userId) &#123;\n        promotionService.issueNewUserExperienceCash(userId);\n    &#125;\n&#125;\n\npublic class RegNotificationObserver &#123;\n    private NotificationService notificationService;\n\n    @Subscribe\n    public void handleRegSuccess(Long userId) &#123;\n        notificationService.sendInboxMessage(userId, &quot;...&quot;);\n    &#125;\n&#125;\n&#x2F;&#x2F;@Subscribe注解：当通过 register() 函数将 Observer 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe \n&#x2F;&#x2F;注解找到 f1() 和 f2()，并且将两个函数能接收的消息类型记录下来（PMsg-&gt;f1，QMsg-&gt;f2）。当我们通过 post() 函数发送\n&#x2F;&#x2F;消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）\npublic DObserver &#123;\n  &#x2F;&#x2F;...省略其他属性和方法...\n  \n  @Subscribe\n  public void f1(PMsg event) &#123; &#x2F;&#x2F;... &#125;\n  \n  @Subscribe\n  public void f2(QMsg event) &#123; &#x2F;&#x2F;... &#125;\n&#125;</code></pre></li>\n<li><p>应用</p>\n<ul>\n<li><p>事件角色：Spring 中默认存在以下事件，他们都是对 <code>ApplicationContextEvent</code> 的实现(继承自<code>ApplicationContextEvent</code>)：</p>\n<ul>\n<li><code>ContextStartedEvent</code>：<code>ApplicationContext</code> 启动后触发的事件;</li>\n<li><code>ContextStoppedEvent</code>：<code>ApplicationContext</code> 停止后触发的事件;</li>\n<li><code>ContextRefreshedEvent</code>：<code>ApplicationContext</code> 初始化或刷新完成后触发的事件;</li>\n<li><code>ContextClosedEvent</code>：<code>ApplicationContext</code> 关闭后触发的事件</li>\n</ul>\n</li>\n<li><p>事件监听者和事件发布者</p>\n<ul>\n<li><p><code>ApplicationListener</code>充当了事件监听者角色，它是一个接口，只定义了一个 <code>onApplicationEvent()</code>方法来处理<code>ApplicationEvent</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package org.springframework.context;\nimport java.util.EventListener;\n@FunctionalInterface\npublic interface ApplicationListener&lt;E extends ApplicationEvent&gt; extends EventListener &#123;\n    void onApplicationEvent(E var1);\n&#125;</code></pre></li>\n<li><p><code>ApplicationEventPublisher</code>充当了事件的发布者，它也是一个接口，<code>publishEvent（）</code>这个方法在<code>AbstractApplicationContext</code> 类中被实现，底层通过<code>ApplicationEventMulticaster</code>来广播出去的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@FunctionalInterface\npublic interface ApplicationEventPublisher &#123;\n    default void publishEvent(ApplicationEvent event) &#123;\n        this.publishEvent((Object)event);\n    &#125;\n\n    void publishEvent(Object var1);\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>事件流程</p>\n<ul>\n<li><p>定义一个事件: 实现一个继承自 <code>ApplicationEvent</code>，并且写相应的构造函数；</p>\n</li>\n<li><p>定义一个事件监听者：实现 <code>ApplicationListener</code> 接口，重写 <code>onApplicationEvent()</code> 方法；</p>\n</li>\n<li><p>使用事件发布者发布消息: 可以通过 <code>ApplicationEventPublisher</code> 的 <code>publishEvent()</code> 方法发布消息</p>\n</li>\n<li><p>实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 定义一个事件,继承自ApplicationEvent并且写相应的构造函数\npublic class DemoEvent extends ApplicationEvent&#123;\n    private static final long serialVersionUID &#x3D; 1L;\n\n    private String message;\n\n    public DemoEvent(Object source,String message)&#123;\n        super(source);\n        this.message &#x3D; message;\n    &#125;\n\n    public String getMessage() &#123;\n         return message;\n          &#125;\n\n&#x2F;&#x2F; 定义一个事件监听者,实现ApplicationListener接口，重写 onApplicationEvent() 方法；\n@Component\npublic class DemoListener implements ApplicationListener&lt;DemoEvent&gt;&#123;\n\n    &#x2F;&#x2F;使用onApplicationEvent接收消息\n    @Override\n    public void onApplicationEvent(DemoEvent event) &#123;\n        String msg &#x3D; event.getMessage();\n        System.out.println(&quot;接收到的信息是：&quot;+msg);\n    &#125;\n\n&#125;\n&#x2F;&#x2F; 发布事件，可以通过ApplicationEventPublisher  的 publishEvent() 方法发布消息。\n@Component\npublic class DemoPublisher &#123;\n\n    @Autowired\n    ApplicationContext applicationContext;\n\n    public void publish(String message)&#123;\n        &#x2F;&#x2F;发布事件\n        applicationContext.publishEvent(new DemoEvent(this, message));\n    &#125;\n&#125;</code></pre></li>\n<li><p>结果：当调用 <code>DemoPublisher</code> 的 <code>publish()</code> 方法的时候，比如 <code>demoPublisher.publish(&quot;你好&quot;)</code> ，控制台就会打印出:<code>接收到的信息是：你好</code></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>模版模式：在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤（如Java的IO框架），复用部分已有代码</p>\n<ul>\n<li><p>代码实现：模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class AbstractClass &#123;\n    &#x2F;&#x2F;定义为final，避免子类重写\n    public final void templateMethod() &#123;\n        &#x2F;&#x2F;...\n        method1();\n        &#x2F;&#x2F;...\n        method2();\n        &#x2F;&#x2F;...\n    &#125;\n\t\t&#x2F;&#x2F;方式一：定义为abstract是为了强迫子类去实现（如InputStream的read方法）\n    protected abstract void method1();\n    protected abstract void method2();\n  \t&#x2F;&#x2F;方式二：虽然没有声明为abstract，但是抛了异常，子类不重写来处理异常就无法使用（如AbstractList的add方法）\n    public void add(int index, E element) &#123;\n      throw new UnsupportedOperationException();\n  \t&#125;\n&#125;\n\npublic class ConcreteClass1 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;&#125;\n\n    @Override\n    protected void method2() &#123;&#125;\n&#125;\n\npublic class ConcreteClass2 extends AbstractClass &#123;\n    @Override\n    protected void method1() &#123;&#125;\n\n    @Override\n    protected void method2() &#123;&#125;\n&#125;\nAbstractClass demo &#x3D; ConcreteClass1();\ndemo.templateMethod();</code></pre></li>\n<li><p>框架的扩展（Java Servlet）</p>\n<ul>\n<li><p>HttpServlet：处理web应用中的get和post请求，在Tomcat、Jetty这样的Servlet容器启动的时候，会自动加载配置文件中URL和XXXServlet间的映射关系（如<code>/hello</code>对应<code>HelloServlet</code>），容器处理URL请求找到对应的servlet执行service方法（定义在父类HttpServlet中，会调用doGet和doPost方法，然后输出网页）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServlet extends HttpServlet &#123;\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        this.doPost(req, resp);\n    &#125;\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n        resp.getWriter().write(&quot;Hello World.&quot;);\n    &#125;\n&#125;</code></pre></li>\n<li><p>HttpServlet的service方法：是一个模版方法，实现了整个HTTP请求的执行流程，但其中的doGet和doPost方法可以由子类来定制实现，可以不修改Servlet框架源码的情况下将业务代码通过扩展点镶嵌到框架中执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException\n&#123;\n    HttpServletRequest  request;\n    HttpServletResponse response;\n    if (!(req instanceof HttpServletRequest &amp;&amp;\n          res instanceof HttpServletResponse)) &#123;\n        throw new ServletException(&quot;non-HTTP request or response&quot;);\n    &#125;\n    request &#x3D; (HttpServletRequest) req;\n    response &#x3D; (HttpServletResponse) res;\n    service(request, response);\n&#125;\n&#x2F;&#x2F;参数类型不同\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123;\n    String method &#x3D; req.getMethod();\n    if (method.equals(METHOD_GET)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        if (lastModified &#x3D;&#x3D; -1) &#123;\n            &#x2F;&#x2F; servlet doesn&#39;t support if-modified-since, no reason\n            &#x2F;&#x2F; to go through further expensive logic\n            doGet(req, resp);\n        &#125; else &#123;\n            long ifModifiedSince &#x3D; req.getDateHeader(HEADER_IFMODSINCE);\n            if (ifModifiedSince &lt; lastModified) &#123;\n                &#x2F;&#x2F; If the servlet mod time is later, call doGet()\n                &#x2F;&#x2F; Round down to the nearest second for a proper compare\n                &#x2F;&#x2F; A ifModifiedSince of -1 will always be less\n                maybeSetLastModified(resp, lastModified);\n                doGet(req, resp);\n            &#125; else &#123;\n                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n            &#125;\n        &#125;\n    &#125; else if (method.equals(METHOD_HEAD)) &#123;\n        long lastModified &#x3D; getLastModified(req);\n        maybeSetLastModified(resp, lastModified);\n        doHead(req, resp);\n    &#125; else if (method.equals(METHOD_POST)) &#123;\n        doPost(req, resp);\n    &#125; else if (method.equals(METHOD_PUT)) &#123;\n        doPut(req, resp);\n    &#125; else if (method.equals(METHOD_DELETE)) &#123;\n        doDelete(req, resp);\n    &#125; else if (method.equals(METHOD_OPTIONS)) &#123;\n        doOptions(req,resp);\n    &#125; else if (method.equals(METHOD_TRACE)) &#123;\n        doTrace(req,resp);\n    &#125; else &#123;\n        String errMsg &#x3D; lStrings.getString(&quot;http.method_not_implemented&quot;);\n        Object[] errArgs &#x3D; new Object[1];\n        errArgs[0] &#x3D; method;\n        errMsg &#x3D; MessageFormat.format(errMsg, errArgs);\n        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>回调（Callback）</p>\n<ul>\n<li><p>实现：相对于普通的函数调用来说，回调是一种双向调用关系。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是“回调函数”。A 调用 B，B 反过来又调用 A，这种调用机制就叫作“回调”</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface ICallback &#123;\n    void methodToCallback();\n&#125;\n\npublic class BClass &#123;\n    public void process(ICallback callback) &#123;\n        &#x2F;&#x2F;...\n        callback.methodToCallback();\n        &#x2F;&#x2F;...\n    &#125;\n&#125;\n\npublic class AClass &#123;\n    public static void main(String[] args) &#123;\n        BClass b &#x3D; new BClass();\n        &#x2F;&#x2F;使用包裹了回调函数的类对象，我们简称为回调对象\n        &#x2F;&#x2F;A实现了methodToCallback()，并且调用process()，process()函数又调用了methodToCallback()\n        b.process(new ICallback() &#123; &#x2F;&#x2F;回调对象\n            @Override\n            public void methodToCallback() &#123;\n                System.out.println(&quot;Call back me.&quot;);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n&#x2F;&#x2F;异步回调：通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口\n&#x2F;&#x2F;（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户</code></pre></li>\n<li><p>JdbcTemplate：Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的，而是基于回调来实现的，确切地说应该是同步回调。JdbcTemplate 通过回调的机制，将不变的执行流程抽离出来，放到模板方法<code>execute()</code>中，将可变的部分设计成回调<code>StatementCallback</code>，由用户来定制。<code>query()</code>函数是对<code>execute()</code>函数的二次封装，让接口用起来更加方便</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic &lt;T&gt; List&lt;T&gt; query(String sql, RowMapper&lt;T&gt; rowMapper) throws DataAccessException &#123;\n    return query(sql, new RowMapperResultSetExtractor&lt;T&gt;(rowMapper));\n&#125;\n\n@Override\npublic &lt;T&gt; T query(final String sql, final ResultSetExtractor&lt;T&gt; rse) throws DataAccessException &#123;\n    Assert.notNull(sql, &quot;SQL must not be null&quot;);\n    Assert.notNull(rse, &quot;ResultSetExtractor must not be null&quot;);\n    if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Executing SQL query [&quot; + sql + &quot;]&quot;); &#125;\n\t\t&#x2F;&#x2F;回调，实现了StatementCallback，由用户来定制，封装了execute模版方法\n    class QueryStatementCallback implements StatementCallback&lt;T&gt;, SqlProvider &#123;\n        @Override\n        public T doInStatement(Statement stmt) throws SQLException &#123;\n            ResultSet rs &#x3D; null;\n            try &#123;\n                rs &#x3D; stmt.executeQuery(sql);\n                ResultSet rsToUse &#x3D; rs;\n                if (nativeJdbcExtractor !&#x3D; null) &#123;\n                    rsToUse &#x3D; nativeJdbcExtractor.getNativeResultSet(rs);\n                &#125;\n                return rse.extractData(rsToUse);\n            &#125;\n            finally &#123;\n                JdbcUtils.closeResultSet(rs);\n            &#125;\n        &#125;\n        @Override\n        public String getSql() &#123;\n            return sql;\n        &#125;\n    &#125;\n\n    return execute(new QueryStatementCallback());\n&#125;\n\n@Override\npublic &lt;T&gt; T execute(StatementCallback&lt;T&gt; action) throws DataAccessException &#123;\n    Assert.notNull(action, &quot;Callback object must not be null&quot;);\n\n    Connection con &#x3D; DataSourceUtils.getConnection(getDataSource());\n    Statement stmt &#x3D; null;\n    try &#123;\n        Connection conToUse &#x3D; con;\n        if (this.nativeJdbcExtractor !&#x3D; null &amp;&amp;\n            this.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) &#123;\n            conToUse &#x3D; this.nativeJdbcExtractor.getNativeConnection(con);\n        &#125;\n        stmt &#x3D; conToUse.createStatement();\n        applyStatementSettings(stmt);\n        Statement stmtToUse &#x3D; stmt;\n        if (this.nativeJdbcExtractor !&#x3D; null) &#123;\n            stmtToUse &#x3D; this.nativeJdbcExtractor.getNativeStatement(stmt);\n        &#125;\n        T result &#x3D; action.doInStatement(stmtToUse);\n        handleWarnings(stmt);\n        return result;\n    &#125;\n    catch (SQLException ex) &#123;\n        &#x2F;&#x2F; Release Connection early, to avoid potential connection pool deadlock\n        &#x2F;&#x2F; in the case when the exception translator hasn&#39;t been initialized yet.\n        JdbcUtils.closeStatement(stmt);\n        stmt &#x3D; null;\n        DataSourceUtils.releaseConnection(con, getDataSource());\n        con &#x3D; null;\n        throw getExceptionTranslator().translate(&quot;StatementCallback&quot;, getSql(action), ex);\n    &#125;\n    finally &#123;\n        JdbcUtils.closeStatement(stmt);\n        DataSourceUtils.releaseConnection(con, getDataSource());\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;使用&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic class JdbcTemplateDemo &#123;\n    private JdbcTemplate jdbcTemplate;\n\n    public User queryUser(long id) &#123;\n        String sql &#x3D; &quot;select * from user where id&#x3D;&quot;+id;\n        return jdbcTemplate.query(sql, new UserRowMapper()).get(0);\n    &#125;\n\n    class UserRowMapper implements RowMapper&lt;User&gt; &#123;\n        public User mapRow(ResultSet rs, int rowNum) throws SQLException &#123;\n            User user &#x3D; new User();\n            user.setId(rs.getLong(&quot;id&quot;));\n            user.setName(rs.getString(&quot;name&quot;));\n            user.setTelephone(rs.getString(&quot;telephone&quot;));\n            return user;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n<li><p>回调与模版方法的对比，回调相对于模版模式会更加灵活</p>\n<ul>\n<li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。</li>\n<li>回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。</li>\n<li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>职责链模式：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止</p>\n<ul>\n<li><p>模版代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;实现一&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic abstract class Handler &#123;\n    protected Handler successor &#x3D; null;\n\n    public void setSuccessor(Handler successor) &#123;\n        this.successor &#x3D; successor;\n    &#125;\n\n    public final void handle() &#123;\n        &#x2F;&#x2F;如果没有handled判断，则可以全部处理一遍\n        boolean handled &#x3D; doHandle();\n        if (successor !&#x3D; null &amp;&amp; !handled) &#123;\n            successor.handle();\n        &#125;\n    &#125;\n    protected abstract boolean doHandle();\n&#125;\n\npublic class HandlerA extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB extends Handler &#123;\n    @Override\n    protected boolean doHandle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;实现二&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic interface IHandler &#123;\n    boolean handle();\n&#125;\n\npublic class HandlerA implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\n\npublic class HandlerB implements IHandler &#123;\n    @Override\n    public boolean handle() &#123;\n        boolean handled &#x3D; false;\n        &#x2F;&#x2F;...\n        return handled;\n    &#125;\n&#125;\npublic class HandlerChain &#123;\n    private List&lt;IHandler&gt; handlers &#x3D; new ArrayList&lt;&gt;();\n\n    public void addHandler(IHandler handler) &#123;\n        this.handlers.add(handler);\n    &#125;\n\n    public void handle() &#123;\n        for (IHandler handler : handlers) &#123;\n            boolean handled &#x3D; handler.handle();\n            if (handled) &#123;\n                break;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 使用举例\npublic class Application &#123;\n    public static void main(String[] args) &#123;\n        HandlerChain chain &#x3D; new HandlerChain();\n        chain.addHandler(new HandlerA());\n        chain.addHandler(new HandlerB());\n        chain.handle();\n    &#125;\n&#125;</code></pre></li>\n<li><p>Servelt Filter：可以实现对HTTP请求的过滤功能，比如鉴权、限流、记录日志、验证参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LogFilter implements Filter &#123;\n  @Override\n  public void init(FilterConfig filterConfig) throws ServletException &#123;\n    &#x2F;&#x2F; 在创建Filter时自动调用，\n    &#x2F;&#x2F; 其中filterConfig包含这个Filter的配置参数，比如name之类的（从配置文件中读取的）\n  &#125;\n  @Override\n  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;\n    System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n    chain.doFilter(request, response);\n    System.out.println(&quot;拦截发送给客户端的响应.&quot;);\n  &#125;\n\n  @Override\n  public void destroy() &#123;\n    &#x2F;&#x2F; 在销毁Filter时自动调用\n  &#125;\n&#125;\n&#x2F;&#x2F; 在web.xml配置文件中添加filter相关的配置（url、相关类）\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;Tomcat&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\npublic final class ApplicationFilterChain implements FilterChain &#123;\n    private int pos &#x3D; 0; &#x2F;&#x2F;当前执行到了哪个filter\n    private int n; &#x2F;&#x2F;filter的个数\n    private ApplicationFilterConfig[] filters;\n    private Servlet servlet;\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response) &#123;\n        if (pos &lt; n) &#123;\n            ApplicationFilterConfig filterConfig &#x3D; filters[pos++];\n            Filter filter &#x3D; filterConfig.getFilter();\n            filter.doFilter(request, response, this);&#x2F;&#x2F;传入this，进行递归调用，实现前后双向拦截\n            &#x2F;&#x2F;System.out.println(&quot;拦截客户端发送来的请求.&quot;);\n            &#x2F;&#x2F;chain.doFilter(request, response);\n    \t\t\t\t&#x2F;&#x2F;System.out.println(&quot;拦截发送给客户端的响应.&quot;);            \n        &#125; else &#123;\n            &#x2F;&#x2F; filter都处理完毕后，执行servlet\n            servlet.service(request, response);\n        &#125;\n    &#125;\n\n    public void addFilter(ApplicationFilterConfig filterConfig) &#123;\n\t\t\t\t&#x2F;&#x2F;去重+扩容\n        filters[n++] &#x3D; filterConfig;\n    &#125;\n&#125;</code></pre></li>\n<li><p>Spring Interceptor：</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230510141640127.png\" alt=\"image-20230510141640127\"></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;使用：实现HandlerInterceptor接口，重写preHandle、postHandle、afterCompletion三个方法\n&#x2F;&#x2F;原理：在 Spring 框架中，DispatcherServlet 的 doDispatch() 方法来分发请求，它在真正的业务逻辑执行前后，执行 \n&#x2F;&#x2F;HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能\npublic class HandlerExecutionChain &#123;\n    private final Object handler;\n    private HandlerInterceptor[] interceptors;\n\n    public void addInterceptor(HandlerInterceptor interceptor) &#123;\n        initInterceptorList().add(interceptor);\n    &#125;\n\n    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; 0; i &lt; interceptors.length; i++) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                if (!interceptor.preHandle(request, response, this.handler)) &#123;\n                    triggerAfterCompletion(request, response, null);\n                    return false;\n                &#125;\n            &#125;\n        &#125;\n        return true;\n    &#125;\n\n    void applyPostHandle(HttpServletRequest request, HttpServletResponse response, ModelAndView mv) throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; interceptors.length - 1; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                interceptor.postHandle(request, response, this.handler, mv);\n            &#125;\n        &#125;\n    &#125;\n\n    void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, Exception ex)\n        throws Exception &#123;\n        HandlerInterceptor[] interceptors &#x3D; getInterceptors();\n        if (!ObjectUtils.isEmpty(interceptors)) &#123;\n            for (int i &#x3D; this.interceptorIndex; i &gt;&#x3D; 0; i--) &#123;\n                HandlerInterceptor interceptor &#x3D; interceptors[i];\n                try &#123;\n                    interceptor.afterCompletion(request, response, this.handler, ex);\n                &#125; catch (Throwable ex2) &#123;\n                    logger.error(&quot;HandlerInterceptor.afterCompletion threw exception&quot;, ex2);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-原理及源码分析\"><a href=\"#3-原理及源码分析\" class=\"headerlink\" title=\"3.原理及源码分析\"></a>3.原理及源码分析</h3><p><a href=\"https://javadoop.com/post/spring-ioc\">https://javadoop.com/post/spring-ioc</a></p>\n<h2 id=\"2-AOP\"><a href=\"#2-AOP\" class=\"headerlink\" title=\"2.AOP\"></a>2.AOP</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>默认使用基于Java的动态代理机制，即通过<code>java.lang.reflect.Proxy</code>类来生成代理对象</p></blockquote>\n<h3 id=\"1-基础知识-1\"><a href=\"#1-基础知识-1\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><ol>\n<li><p>专有名词</p>\n<ul>\n<li>Aspect：跨多个类的关注点的模块化，例如事务管理</li>\n<li>Join point：程序执行过程中的一个点，例如方法的执行和异常的处理</li>\n<li>Advice：Aspect在特定的Join point采取的行动，包括around、before、after（running、throwing、finally）</li>\n<li>pointcut：匹配连接点的谓词，Advice和pointcut表达式相关联，并在任何与pointcut匹配的join point运行，例如执行具有特定名称的方法</li>\n<li>Introduction：代表一个类型声明额外的方法或字段，例如可以使用introduction让bean实现isModified接口，来简化缓存</li>\n<li>Target object：An object being advised by one or more aspects，即被代理对象</li>\n<li>AOP proxy：由AOP框架创建的对象，用于实现aspect</li>\n<li>Weaving：将apsects和其他应用程序类型或对象链接以创建建议对象</li>\n</ul>\n</li>\n<li><p>使用示例</p>\n<ul>\n<li><p>配置启用<code>@AspectJ</code>支持：增加注解<code>@EnableAspectJAutoProxy</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">      @Configuration\n      @EnableAspectJAutoProxy\n      public class AppConfig &#123;\n      \n      &#125;</code></pre></li>\n<li><p>声明一个切面（aspect）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">      @Aspect\n      public class NotVeryUsefulAspect &#123;\n      \n      &#125;</code></pre></li>\n<li><p>声明一个切点（pointcut），有很多方式，详见文档</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;名为anyOldTransfer的切入点，与任何名为transfer的方法执行相匹配\n @Pointcut(&quot;execution(* transfer(..))&quot;) &#x2F;&#x2F; the pointcut expression\n private void anyOldTransfer() &#123;&#125; &#x2F;&#x2F; the pointcut signature</code></pre></li>\n<li><p>声明一个advice</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">      @Aspect\n      public class BeforeExample &#123;\n          @Before(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)\n          public void doAccessCheck() &#123;\n              &#x2F;&#x2F; ...\n          &#125;\n      &#125;\n      @Aspect\n      public class AfterReturningExample &#123;\n          @AfterReturning(&quot;com.xyz.myapp.CommonPointcuts.dataAccessOperation()&quot;)\n          public void doAccessCheck() &#123;\n              &#x2F;&#x2F; ...\n          &#125;\n      &#125;\n      @Aspect\n      public class AroundExample &#123;\n          @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;)\n          public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;\n              &#x2F;&#x2F; start stopwatch\n              Object retVal &#x3D; pjp.proceed();\n              &#x2F;&#x2F; stop stopwatch\n              return retVal;\n          &#125;\n      &#125;</code></pre></li>\n<li><p>例子</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">      @Aspect\n      public class ConcurrentOperationExecutor implements Ordered &#123;\n      \n          private static final int DEFAULT_MAX_RETRIES &#x3D; 2;\n      \n          private int maxRetries &#x3D; DEFAULT_MAX_RETRIES;\n          private int order &#x3D; 1;\n      \n          public void setMaxRetries(int maxRetries) &#123;\n              this.maxRetries &#x3D; maxRetries;\n          &#125;\n      \n          public int getOrder() &#123;\n              return this.order;\n          &#125;\n      \n          public void setOrder(int order) &#123;\n              this.order &#x3D; order;\n          &#125;\n      \n          @Around(&quot;com.xyz.myapp.CommonPointcuts.businessService()&quot;)\n          public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable &#123;\n              int numAttempts &#x3D; 0;\n              PessimisticLockingFailureException lockFailureException;\n              do &#123;\n                  numAttempts++;\n                  try &#123;\n                      return pjp.proceed();\n                  &#125;\n                  catch(PessimisticLockingFailureException ex) &#123;\n                      lockFailureException &#x3D; ex;\n                  &#125;\n              &#125; while(numAttempts &lt;&#x3D; this.maxRetries);\n              throw lockFailureException;\n          &#125;\n      &#125;</code></pre></li>\n</ul>\n</li>\n<li><p>对bean做aop增强问题（？）</p>\n<ul>\n<li>子类有则用子类的bean，子类没有则用父类的bean</li>\n<li>在父上下文开启增强，父的bean均被增强，子的bean均未被增强；在子上下文开启增强，子的bean均被增强，父的bean未被增强</li>\n<li>要想都被增强，则需要都开启aop的自动配置并且在父类上定义aop</li>\n</ul>\n</li>\n<li><p>原理</p>\n<ul>\n<li>代理模式：Spring AOP基于代理模式实现，主要有两种代理方式，JDK动态代理和CGLIB代理。JDK动态代理要求目标类必须实现接口，而CGLIB代理则可以针对没有实现接口的类进行代理。</li>\n<li>切面（Aspect）：切面是将横切关注点模块化的实现。切面通常包含通知（Advice）和切点（Pointcut）。通知是在特定的切点执行的动作，切点则用于定义通知应该在何处执行。</li>\n<li>连接点（Joinpoint）：连接点代表在应用程序中可以插入切面的点，如方法调用、异常处理等。</li>\n<li>织入（Weaving）：织入是将切面应用到目标对象的过程，从而创建代理对象。在Spring AOP中，织入过程发生在运行时。</li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h3 id=\"2-设计模式-1\"><a href=\"#2-设计模式-1\" class=\"headerlink\" title=\"2.设计模式\"></a>2.设计模式</h3><ol>\n<li><p>代理模式：在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问（监控、统计、鉴权、限流、事务、幂等、日志），而非加强功能，这是它跟装饰器模式最大的不同（装饰器主要是加强已有功能）</p>\n<ul>\n<li><p>装饰器模式、代理模式、适配器模式</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能\n&#x2F;&#x2F;适配器模式是一种事后补救措施，增加跟原始类不同的接口，让原本因接口不兼容而不能一起工作的类可以一起工作\n&#x2F;&#x2F; 代理模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A impelements IA &#123;\n    public void f() &#123; \n      &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class AProxy implements IA &#123;\n    private IA a;\n    public AProxy(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 新添加的代理逻辑\n        a.f();\n        &#x2F;&#x2F; 新添加的代理逻辑\n    &#125;\n&#125;\nIA a &#x3D; new AProxy(new A());\n&#x2F;&#x2F; 装饰器模式的代码结构(下面的接口也可以替换成抽象类)\npublic interface IA &#123;\n    void f();\n&#125;\npublic class A implements IA &#123;\n    public void f() &#123; \n      &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class ADecorator implements IA &#123;\n    private IA a;\n    public ADecorator(IA a) &#123;\n        this.a &#x3D; a;\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 功能增强代码\n        a.f();\n        &#x2F;&#x2F; 功能增强代码\n    &#125;\n&#125;\n&#x2F;&#x2F; 类适配器: 基于继承，将不兼容ITarget接口的Adaptee类“转换”为符合ITarget接口定义的类\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n    public void fb() &#123;\n        &#x2F;&#x2F;... \n    &#125;\n    public void fc() &#123; \n        &#x2F;&#x2F;... \n    &#125;\n&#125;\n\npublic class Adaptor extends Adaptee implements ITarget &#123;\n    public void f1() &#123;\n        super.fa();\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;</code></pre></li>\n<li><p>静态代理：有接口时实现相同的接口来实现（见前），没有接口时只能通过继承实现（见下）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class A&#123;\n    public void f() &#123; \n      &#x2F;&#x2F;... \n    &#125;\n&#125;\npublic class AProxy extends A &#123;\n    private A a;\n    public AProxy() &#123;\n        this.a &#x3D; new A();\n    &#125;\n\n    public void f() &#123;\n        &#x2F;&#x2F; 新添加的代理逻辑\n        a.f();\n        &#x2F;&#x2F; 新添加的代理逻辑\n    &#125;\n&#125;\nA a &#x3D; new AProxy();</code></pre></li>\n<li><p>动态代理：不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理来替换原始类（如Spring AOP）</p>\n<ul>\n<li>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用JDK Proxy去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用Cglib生成一个被代理对象的子类来作为代理（也可以使用AspectJ，AOP属于运行时增强而AspectJ属于编译时增强，基于字节码操作）</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;动态代理类\npublic class MetricsCollectorProxy &#123;\n    private MetricsCollector metricsCollector;\n\n    public MetricsCollectorProxy() &#123;\n        this.metricsCollector &#x3D; new MetricsCollector();\n    &#125;\n\n    &#x2F;&#x2F;封装了代理类的创建\n    public Object createProxy(Object proxiedObject) &#123;\n        &#x2F;&#x2F;返回Class数组，表示Class对象引用的类所实现的所有接口\n        Class&lt;?&gt;[] interfaces &#x3D; proxiedObject.getClass().getInterfaces();\n        DynamicProxyHandler handler &#x3D; new DynamicProxyHandler(proxiedObject);\n        &#x2F;&#x2F;Proxy provides static methods for creating dynamic proxy classes and instances, \n        &#x2F;&#x2F;and it is also the superclass of all dynamic proxy classes created by those \n        &#x2F;&#x2F;methods.\n        return Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);\n    &#125;\n\n    private class DynamicProxyHandler implements InvocationHandler &#123;\n        private Object proxiedObject;\n\n        public DynamicProxyHandler(Object proxiedObject) &#123;\n            this.proxiedObject &#x3D; proxiedObject;\n        &#125;\n\n        &#x2F;&#x2F;所有方法的调用都会变成调用invoke方法，参数为生成的代理类、要调用的方法、对应的参数\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            long startTimestamp &#x3D; System.currentTimeMillis();\n            Object result &#x3D; method.invoke(proxiedObject, args);\n            long endTimeStamp &#x3D; System.currentTimeMillis();\n            long responseTime &#x3D; endTimeStamp - startTimestamp;\n            String apiName &#x3D; proxiedObject.getClass().getName() + &quot;:&quot; + method.getName();\n            RequestInfo requestInfo &#x3D; new RequestInfo(apiName, responseTime, startTimestamp);\n            metricsCollector.recordRequest(requestInfo);\n            return result;\n        &#125;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;MetricsCollectorProxy使用举例\nMetricsCollectorProxy proxy &#x3D; new MetricsCollectorProxy();\nIUserController userController &#x3D; (IUserController) proxy.createProxy(new UserController());</code></pre></li>\n</ul>\n</li>\n<li><p>装饰者模式：在不改变原始类接口的情况下，对原始类的功能进行增强，并且支持多个装饰器的嵌套使用，如Java的IO类库</p>\n<ul>\n<li><p>用组合代替继承、装饰器类和原始类继承同一父类，从而可以对原始类嵌套多个装饰器类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class InputStream &#123;\n    &#x2F;&#x2F;...\n    public int read(byte b[]) throws IOException &#123; return read(b, 0, b.length); &#125;\n    public int read(byte b[], int off, int len) throws IOException &#123; &#125;\n    &#x2F;&#x2F;...\n&#125;\n\npublic class BufferedInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n    protected BufferedInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现基于缓存的读数据接口...  \n&#125;\n\npublic class DataInputStream extends InputStream &#123;\n    protected volatile InputStream in;\n    protected DataInputStream(InputStream in) &#123;\n        this.in &#x3D; in;\n    &#125;\n\n    &#x2F;&#x2F;...实现读取基本类型数据的接口\n&#125;\nInputStream in &#x3D; new FileInputStream(&quot;&#x2F;user&#x2F;wangzheng&#x2F;test.txt&quot;);\nInputStream bin &#x3D; new BufferedInputStream(in);\nDataInputStream din &#x3D; new DataInputStream(bin);\nint data &#x3D; din.readInt();</code></pre></li>\n<li><p>为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream。InputStream的所有的装饰器类（BufferedInputStream、DataInputStream）都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现。例如：BufferedInputStream直接使用了FilterInputStream的close()，而没有重新实现</p>\n</li>\n</ul>\n</li>\n<li><p>适配器模式：是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口，适配器模式主要是将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作</p>\n<ul>\n<li><p>类适配器（继承）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 类适配器: 基于继承\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123;&#125;\n    public void fb() &#123;&#125;\n    public void fc() &#123;&#125;\n&#125;\n\npublic class Adaptor extends Adaptee implements ITarget &#123;\n    public void f1() &#123;\n        super.fa();\n    &#125;\n\n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    &#x2F;&#x2F; 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点\n&#125;</code></pre></li>\n<li><p>对象适配器（组合）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 对象适配器：基于组合\npublic interface ITarget &#123;\n    void f1();\n    void f2();\n    void fc();\n&#125;\n\npublic class Adaptee &#123;\n    public void fa() &#123;&#125;\n    public void fb() &#123;&#125;\n    public void fc() &#123;&#125;\n&#125;\n\npublic class Adaptor implements ITarget &#123;\n    private Adaptee adaptee;\n    public Adaptor(Adaptee adaptee) &#123; this.adaptee &#x3D; adaptee; &#125;\n    public void f1() &#123; adaptee.fa(); &#125; &#x2F;&#x2F;委托给Adaptee\n    \n    public void f2() &#123;\n        &#x2F;&#x2F;...重新实现f2()...\n    &#125;\n\n    public void fc() &#123;\n        adaptee.fc();\n    &#125;\n&#125;</code></pre></li>\n<li><p>应用：封装有缺陷的接口设计、统一不同接口设计、替换依赖的外部系统、兼容老版本接口、适配不同格式的数据</p>\n<ul>\n<li>在 Spring MVC 中，<code>DispatcherServlet</code>根据请求信息调用<code>HandlerMapping</code>，解析请求对应的<code>Handler</code>。解析到对应的<code>Handler</code>（也就是我们平常说的Controller控制器）后，开始由<code>HandlerAdapter</code>适配器处理。<code>HandlerAdapter</code>作为期望接口，具体的适配器实现类用于对目标类进行适配，<code>Controller</code>作为需要适配的类（如果不使用，需要自己判断<code>handler</code>（即<code>controller</code>）的类型）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-原理及源码分析-1\"><a href=\"#3-原理及源码分析-1\" class=\"headerlink\" title=\"3.原理及源码分析\"></a>3.原理及源码分析</h3><p><a href=\"https://javadoop.com/post/spring-aop-source\">https://javadoop.com/post/spring-aop-source</a></p>\n<h2 id=\"3-Data-Access\"><a href=\"#3-Data-Access\" class=\"headerlink\" title=\"3.Data Access\"></a>3.Data Access</h2><h3 id=\"1-Transaction-Management\"><a href=\"#1-Transaction-Management\" class=\"headerlink\" title=\"1.Transaction Management\"></a>1.Transaction Management</h3><ol>\n<li>Spring的管理事务的方式<ul>\n<li><strong>编程式事务</strong>：在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助</li>\n<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>\n</ul>\n</li>\n<li>声明式事务：使用<code>@EnableTransactionManagement</code>开启事务注解，使用<code>@Transactional</code>声明事务，其有以下属性<ul>\n<li>transactionManager</li>\n<li>事务的传播特性：@Transactional注解的propagation属性，一共有七种，默认为PROPAGATION_REQUIRED<ul>\n<li><code>PROPAGATION_REQUIRED</code>：当前有服务已经开始一个事务，则加入到该事务，与其一同提交/回滚；如果当前没有事务，则新建一个事务</li>\n<li><code>PROPAGATION_SUPPORTS</code>：支持当前事务，如果当前没有事务，则以非事务方式执行，通常用于处理非原子性的非核心业务逻辑操作</li>\n<li><code>PROPAGATION_MANDATORY</code>：支持当前事务，如果当前没有事务，则抛出异常，防止上下文忘记添加事务的兜底手段，将事务需求托管给上下文</li>\n<li><code>PROPAGATION_REQUIRES_NEW</code>：新建事务，如果当前存在事务，把当前事务挂起，与<code>PROPAGATION_REQUIRED</code>的区别在于前一事务回滚时（被挂起）当前事务不再需要回滚</li>\n<li><code>PROPAGATION_NOT_SUPPORTED</code>： 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，可以帮助减少前一事务的事务范围，减少回滚的影响</li>\n<li><code>PROPAGATION_NEVER</code>： 以非事务方式执行，如果当前存在事务，则抛出异常，要求上下文不能存在事务</li>\n<li><code>PROPAGATION_NESTED</code>： Nested的事务和它的父事务是相依的，它的提交是要等和它的父事务一块提交的，父事务因子事务回滚时仅回滚到savepoint点，然后继续执行另一分支</li>\n</ul>\n</li>\n<li>事务的隔离级别：@Transactional注解的isolation属性，一共有五种，默认为ISOLATION_DEFAULT<ul>\n<li><code>ISOLATION_DEFAULT</code>：使用数据库默认的事务隔离级别</li>\n<li><code>ISOLATION_READ_UNCOMMITTED</code>：读未提交，一个事务可以看到另一事务未提交的数据，会产生脏读、不可重复读、幻读</li>\n<li><code>ISOLATION_READ_COMMITTED</code>：读已提交，一个事务只能看到另一事务已提交的数据，可以避免脏读，但是会产生不可重复读、幻读</li>\n<li><code>ISOLATION_REPEATABLE_READ</code>：可重复读，可以防止脏读，不可重复读，但是可能出现幻读<ul>\n<li><strong>幻读和不可重复读的侧重点是不同的，不可重复读侧重于数据修改，两次读取到的同一行数据不一样；而幻读侧重于添加或删除，两次查询返回的数据行数不同</strong></li>\n</ul>\n</li>\n<li><code>ISOLATION_SERIALIZABLE</code>：可序列化，事务顺序执行，可防止脏读，不可重复读外，还避免了幻读</li>\n</ul>\n</li>\n<li>timeout</li>\n<li>readOnly</li>\n</ul>\n</li>\n<li>事务回滚的场景<ul>\n<li>抛出unchecked exception（runtime exception）后会触发事务的回滚，对于checked异常使用try捕获就不会回滚，也可以配置spring参数让其回滚</li>\n<li>spring的事务边界是在调用业务方法之前开始的，业务方法执行完毕之后来执行commit or rollback（Spring默认取决于是否抛出runtime异常）</li>\n<li>如果抛出runtime exception并在你的业务方法中没有catch到的话，事务会回滚。一般不需要在业务方法中catch异常</li>\n</ul>\n</li>\n<li>事务的问题：脏读、不可重复读、幻读<ul>\n<li><strong>脏读：</strong>指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的</li>\n<li><strong>不可重复读：</strong>指在一个事务内，多次读同一数据，在这个事务还没有结束时，另外一个事务也访问该同一数据，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读</li>\n<li><strong>幻读：</strong>当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-JDBC\"><a href=\"#2-JDBC\" class=\"headerlink\" title=\"2.JDBC\"></a>2.JDBC</h3><ol>\n<li><p>包层次结构</p>\n<ul>\n<li><code>org.springframework.jdbc.core</code>：<code>JdbcTemplate</code>、simple子包中<code>simpleJdbcInsert</code>、<code>SimpleJdbcCal</code>l类、namedparam子包中<code>NamedParameterJdbcTemplate</code></li>\n<li><code>org.springframework.jdbc.datasource</code>：DataSource类、embedded子包中内嵌数据库的支持（HSQL、H2、Derby）</li>\n<li><code>org.springframework.jdbc.object</code>：关系数据库的查询、更新、存储程序</li>\n<li><code>org.springframework.jdbc.support</code>：<code>SQLException</code>、一些工具类</li>\n</ul>\n</li>\n<li><p>JDBC Processing</p>\n<ul>\n<li>JdbcTemplate：可以处理资源的创建和释放，主要用于运行数据库的查询、更新、存储，对ResultSet实例执行迭代并提取返回的参数值，捕获JDBC异常并翻译成通用的。方法有：query、queryForObject、queryForList、update、execute</li>\n<li>NamedParameterJdbcTemplate：对JdbcTemplate的一层封装，简化有参数的SQL</li>\n<li>SQLExceptionTranslator：翻译<code>SQLException</code>和<code>org.sf.dao.DataAccessException</code>的接口，其中一个默认实现是<code>SQLErrorCodeSQLExceptionTranslator</code>，可以解析错误码。Spring会将数据操作的异常转换为<code>DataAccessException</code>，无论使用何种数据访问方式，都能使用一样的异常</li>\n</ul>\n</li>\n<li><p>DataSource</p>\n<ul>\n<li><p>连接工厂，使得一个容器或者一个框架从应用代码中隐藏连接池和事务管理问题，业务开发人员不再需要知道连接数据库的信息。</p>\n</li>\n<li><p>如果是JDBC，那么可以通过JNDI（通过配置而不是放在一起的单一url）来获得数据源；也可以配置数据库连接池（HikariCP/druid）</p>\n</li>\n<li><p>DriverManagerDataSource和SimpleDriverDataSource仅应该用在测试的时候：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">DriverManagerDataSource dataSource &#x3D; new DriverManagerDataSource();\ndataSource.setDriverClassName(&quot;org.hsqldb.jdbcDriver&quot;);\ndataSource.setUrl(&quot;jdbc:hsqldb:hsql:&#x2F;&#x2F;localhost:&quot;);\ndataSource.setUsername(&quot;sa&quot;);\ndataSource.setPassword(&quot;&quot;);</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"3-O-R-Mapping（MyBatis）\"><a href=\"#3-O-R-Mapping（MyBatis）\" class=\"headerlink\" title=\"3.O/R Mapping（MyBatis）\"></a>3.O/R Mapping（MyBatis）</h3><ol>\n<li>JPA：Java Persistence API，为对象关系映射提供了一种基于POJO的持久化模型，简化数据持久化代码的开发工作，为Java社区屏蔽不同持久化API的差异</li>\n<li>Lombok：能够自动嵌入IDE和构建工具，提升开发效率</li>\n<li>MyBatis：持久层框架，支持定制化SQL、存储过程和高级映射。免除了几乎所有的JDBC代码及相关配置，可以通过注解来配置和映射原始类型、接口和Java POJO为数据库中的记录<ul>\n<li>MyBatis：持久层框架，支持定制化SQL、存储过程和高级映射。免除了几乎所有的JDBC代码及相关配置，可以通过注解来配置和映射原始类型、接口和Java POJO为数据库中的记录</li>\n<li>MyBatis Generator：MyBatis代码生成器，根据数据库表生成相关代码：POJO、Mapper接口、SQL Map XML</li>\n<li>MyBatis PageHelper：用来做分页，支持多种数据库和多种分页方式</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-MVC\"><a href=\"#4-MVC\" class=\"headerlink\" title=\"4.MVC\"></a>4.MVC</h2><h3 id=\"1-基础知识-2\"><a href=\"#1-基础知识-2\" class=\"headerlink\" title=\"1.基础知识\"></a>1.基础知识</h3><ol>\n<li><p>一些专有名词</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230509181839256-20230509181858735.png\" alt=\"image-20230509181839256\"></p>\n<ul>\n<li>POJO：plain old java objects简单的Java对象，一般用在数据层映射到数据库表的类，类的属性与表字段一一对应<ul>\n<li>POJO持久化后⇒PO，persistent object，增加了一些<code>getter</code>、<code>setter</code>方法</li>\n<li>POJO传输过程中⇒DTO，data transfer object，比如一张表有100个字段，对应的PO有100个属性，但view层只需要10个字段，所以依靠只有10个属性的DTO来传输数据给client，可以提高性能</li>\n<li>POJO用作表示层⇒VO，view object，用于页面展示</li>\n</ul>\n</li>\n<li>DAO：data access object数据访问接口，用来封装对数据库的访问（CRUD），可以把POJO持久化为PO，用PO组装出VO、DTO</li>\n<li>BO：Business Object，即业务对象。一般用在业务层，当业务比较复杂，用到比较多的业务对象时，可用BO类组合封装所有的对象一并传递。</li>\n<li><code>controller</code>层：控制请求url用哪个service层逻辑</li>\n<li><code>service</code>层：带有业务逻辑的数据访问API</li>\n<li>MVC模式<ul>\n<li>模型（Model）表示应用程序的数据和业务逻辑。它负责处理数据的读取、存储、验证以及与数据库的交互等操作。</li>\n<li>视图（View）是用户界面的呈现部分，负责展示模型中的数据给用户。它可以是一个网页、一个图形界面或者其他任何形式。</li>\n<li>控制器（Controller）充当模型和视图之间的中介，负责处理用户的请求、更新模型的状态，以及决定要显示哪个视图。它接收用户的输入，调用相应的模型方法来处理请求，并最终将结果返回给视图进行显示</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>controller：<code>@Controller</code>，是<code>@Component</code>的一个特例，可与<code>@ResponseBody</code>组合成<code>@RestController</code></p>\n<ul>\n<li><p>使用<code>@RequestMapping(&quot;/brand&quot;)</code>来确定该类的顶级域名</p>\n<ul>\n<li><code>path</code>和<code>value</code>用于指定映射路径，<code>value</code>是<code>path</code>的别名</li>\n<li>method用于指定请求方法：Get、Post等，可用<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>、<code>@PatchMapping</code>替代</li>\n<li><code>params</code>指定有哪些参数，或没有哪些参数（<code>!</code>）</li>\n<li><code>headers</code>用来指定请求头中有哪些参数，或没有哪些参数（<code>!</code>）</li>\n<li><code>consumes</code>和<code>produces</code>用于限定请求与响应格式，通过<code>MediaType</code>来指定</li>\n</ul>\n</li>\n<li><p>通过依赖注入来使用Service接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate PmsBrandService demoService;</code></pre></li>\n<li><p>定义子域名和相应的处理逻辑</p>\n<ul>\n<li>抽象出通用返回对象<code>CommonResult</code>，主要有code+message+data三个属性</li>\n<li>抽象出常用的操作码属性</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RequestMapping(value &#x3D; &quot;&#x2F;create&quot;, method &#x3D; RequestMethod.POST)\n    @ResponseBody\n    public CommonResult createBrand(@RequestBody PmsBrand pmsBrand) &#123;\n        CommonResult commonResult;\n        int count &#x3D; demoService.createBrand(pmsBrand);\n        if (count &#x3D;&#x3D; 1) &#123;\n            commonResult &#x3D; CommonResult.success(pmsBrand);\n            LOGGER.debug(&quot;createBrand success:&#123;&#125;&quot;, pmsBrand);\n        &#125; else &#123;\n            commonResult &#x3D; CommonResult.failed(&quot;操作失败&quot;);\n            LOGGER.debug(&quot;createBrand failed:&#123;&#125;&quot;, pmsBrand);\n        &#125;\n        return commonResult;\n    &#125;</code></pre></li>\n</ul>\n</li>\n<li><p>service</p>\n<ul>\n<li><p>service接口：写实体类的增删改查等方法</p>\n</li>\n<li><p>serviceImpl：<code>@Service</code></p>\n<ul>\n<li><p>实现service接口</p>\n</li>\n<li><p>通过依赖注入，使用Mapper接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Autowired\nprivate PmsBrandMapper brandMapper;</code></pre></li>\n<li><p>使用xxxMapper接口提供的方法实现service接口中的方法</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>定义处理方法</p>\n<ul>\n<li><p><code>@RequestBody</code>：方法参数是一个请求体，通过<code>HttpMessageConverter</code>读取请求正文并将其反序列化Object</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;accounts&#x2F;&#123;id&#125;&quot;)\n@ResponseBody\npublic Account handle() &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@ResponseBody</code>：方法返回一个响应体，通过<code>HttpMessageConverter</code>将返回序列化到响应正文</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PostMapping(&quot;&#x2F;accounts&quot;)\npublic void handle(@RequestBody Account account) &#123;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@ResponseStatus</code>：返回的状态码，通过<code>HttpStatus</code>来指定</p>\n</li>\n<li><p><code>@PathVariable</code>：请求URI中的变量</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;样例一\n@GetMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n    &#x2F;&#x2F; ...\n&#125;\n&#x2F;&#x2F;样例二\n@Controller\n@RequestMapping(&quot;&#x2F;owners&#x2F;&#123;ownerId&#125;&quot;)\npublic class OwnerController &#123;\n    @GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) &#123;\n        &#x2F;&#x2F; ...\n    &#125;\n&#125;</code></pre></li>\n<li><p><code>@RequestParam</code>：请求URI中的参数，可以将Servlet请求参数绑定到控制器中的方法参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping\npublic String setupForm(@RequestParam(&quot;petId&quot;) int petId, Model model) &#123;\n    Pet pet &#x3D; this.clinic.loadPet(petId);\n    model.addAttribute(&quot;pet&quot;, pet);\n    return &quot;petForm&quot;;\n&#125;</code></pre></li>\n<li><p><code>@MatrixVariable</code>：匹配URI中多个参数中的一个，Matrix Variable中，多个变量用<code>;</code>分隔</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; GET &#x2F;pets&#x2F;42;q&#x3D;11;r&#x3D;22\n@GetMapping(&quot;&#x2F;pets&#x2F;&#123;petId&#125;&quot;)\npublic void findPet(@PathVariable String petId, @MatrixVariable int q) &#123;\n    &#x2F;&#x2F; petId &#x3D;&#x3D; 42\n    &#x2F;&#x2F; q &#x3D;&#x3D; 11\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>DIspatcherServlet：首先通过一个dispatchservlet去转接请求，到handlermapping去返回一个执行链，就比如拦截器到哪个controller，返回以后就到handler适配器获取这个请求要求的controller，然后去controller这里返回一个数据或者页面modelandview，然后给前端</p>\n<ul>\n<li><p>请求处理（<code>DispatcherServlet</code>里面）</p>\n<ul>\n<li><p>首先，调用doService方法首先绑定一些属性（应用上下文、还有一些Resolver）</p>\n</li>\n<li><p>然后，调用doDispatch方法为请求确定Handler，执行Controller前后的处理器逻辑</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Determine handler for the current request.\nmappedHandler &#x3D; getHandler(processedRequest);\n&#x2F;&#x2F;前置处理\nif (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return;&#125;\n&#x2F;&#x2F; Actually invoke the handler.\nmv &#x3D; ha.handle(processedRequest, response, mappedHandler.getHandler());\n&#x2F;&#x2F;后置处理\nmappedHandler.applyPostHandle(processedRequest, response, mv);</code></pre></li>\n<li><p>最后，doDispatch中处理Handler返回的Model，呈现视图</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</code></pre></li>\n</ul>\n</li>\n<li><p>视图解析（xxxResolver）</p>\n<ul>\n<li><code>DispatcherServlet</code>中的<code>initStrategies()</code>初始化了对应的<code>ViewResolver</code></li>\n<li>前面提到的<code>processDispatchResult</code>会做从视图名到视图的解析，通过<code>render</code>呈现视图，在<code>render</code>中解析出<code>view</code>对象</li>\n</ul>\n</li>\n<li><p>异常处理：实现<code>HandlerExceptionResolver</code>接口，例如拦截所有controller</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestControllerAdvice\npublic class GlobalControllerAdvice &#123;\n    @ExceptionHandler(ValidationException.class)\n    @ResponseStatus(HttpStatus.BAD_REQUEST)&#x2F;&#x2F;返回400\n    public Map&lt;String, String&gt; validationExceptionHandler(ValidationException exception) &#123;\n        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();\n        map.put(&quot;message&quot;, exception.getMessage());\n        return map;\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li></li>\n</ol>\n<h3 id=\"2-原理及源码分析\"><a href=\"#2-原理及源码分析\" class=\"headerlink\" title=\"2.原理及源码分析\"></a>2.原理及源码分析</h3><ol>\n<li>SpringMVC 的组件<ul>\n<li>DispatcherServlet：前置控制器，负责接收 HTTP 请求并委托给 HandlerMapping、HandlerAdapter 和 ViewResolver 等组件处理。</li>\n<li>Handler：处理器，完成具体的业务逻辑，相当于 Servlet 或 Action。HandlerMapping：负责将请求映射到对应的 Handler 即控制器(Controller)。</li>\n<li>HandlerInterceptor：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。HandlerExecutionChain：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li>\n<li>HandlerAdapter：负责调用处理器方法并封装处理结果，将其传递给 DispatcherServlet。ModelAndView：装载了模型数据和视图信息，作为 Handler 的处理结果，返回给 DispatcherServlet。</li>\n<li>ViewResolver：视图解析器，负责根据视图名称解析出对应的 View，最终将渲染结果响应给客户端。</li>\n</ul>\n</li>\n<li><strong>拦截器（Interceptors）：</strong>拦截器是Spring MVC框架中的一部分，可以对特定的请求进行拦截和处理。它们通常用于处理与Web请求和响应相关的任务，如身份验证、日志记录、性能监控等。可以通过实现<code>HandlerInterceptor</code>接口来编写自定义拦截器</li>\n<li><strong>过滤器（Filters）：</strong>过滤器是Java EE标准中的一部分，用于处理Web请求和响应，作用于Servlet容器的请求处理过程，可以在请求到达Servlet之前或响应返回给客户端之前进行操作。它们通常用于执行通用的、与特定请求无关的任务，如请求参数解析、字符编码设置、跨域请求处理等。通过实现<code>javax.servlet.Filter</code>接口来编写自定义过滤器</li>\n</ol>\n<h2 id=\"5-Testing\"><a href=\"#5-Testing\" class=\"headerlink\" title=\"5.Testing\"></a>5.Testing</h2><ul>\n<li>SpringBoot提供了<code>@SpringBootTest</code>注解，当需要SpringBoot的特性时，他是Spring-test的<code>@ContextConfiguration</code>注解的替代品，这个注解会通过SpringApplication创建测试中使用的应用上下文来工作，默认是不开启服务器的，但可以通过<code>webEnvironment</code>来重定义：<ul>\n<li>MOCK（默认）：加载一个Web ApplicationContext来提供一个模拟Web环境，不启动嵌入式服务器，但如果类路径上没有可用的Web环境，则此模式会回退到非Web ApplicationContext，</li>\n<li>RANDOM_PORT：加载一个<code>WebServerApplicationContext</code>并提供一个真实的Web环境。嵌入式服务器启动并侦听随机端口。</li>\n<li>DEFINED_PORT：加载一个<code>WebServerApplicationContext</code>并提供一个真实的Web环境，嵌入式服务器侦听定义的端口或默认的端口（8080）</li>\n<li>NONE：使用<code>SpringApplication</code>加载<code>ApplicationContext</code>但不提供任何Web环境</li>\n</ul>\n</li>\n<li><code>@Transactional</code>的测试，这个事务会在测试方法结束后默认回滚</li>\n<li>检测测试配置：<code>@Test</code>会自动搜索主要配置，<code>@TestConfiguration</code>类可以覆盖配置并通过<code>@Import</code>导入配置</li>\n<li>使用模拟（mock）环境测试：<code>@AutoConfigureMockMvc</code></li>\n<li>模拟和窥探Beans：<code>@MockBean</code>用于定义一个应用上下文中的一个bean的Mockito模拟</li>\n<li>Auto-configured Tests：用来自动载入测试需要的程序片段，可以选择一个@…Test注释并手动包含其它片段的@AutoConfigure…注释</li>\n</ul>\n<h2 id=\"6-MyBatis\"><a href=\"#6-MyBatis\" class=\"headerlink\" title=\"6.MyBatis\"></a>6.MyBatis</h2><h3 id=\"1-使用\"><a href=\"#1-使用\" class=\"headerlink\" title=\"1.使用\"></a>1.使用</h3><ol>\n<li><p>与Spring整合</p>\n<ul>\n<li><p>引入依赖（org.mybatis.generator）</p>\n</li>\n<li><p>增加配置文件（generatorConfig.xml），可以根据官网的模版更改</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE generatorConfiguration\n        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;\n        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;\n\n&lt;!-- root element of a MyBatis Generator configuration file--&gt;\n&lt;generatorConfiguration&gt;\n\n    &lt;properties resource&#x3D;&quot;generator.properties&quot;&#x2F;&gt;\n&lt;!--    flat为任何表生成一个domain类，保存表中的所有字段--&gt;\n    &lt;context id&#x3D;&quot;MySQL&quot; targetRuntime&#x3D;&quot;MyBatis3&quot; defaultModelType&#x3D;&quot;flat&quot;&gt;\n        &lt;property name&#x3D;&quot;beginningDelimiter&quot; value&#x3D;&quot;&#96;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;endingDelimiter&quot; value&#x3D;&quot;&#96;&quot;&#x2F;&gt;\n        &lt;property name&#x3D;&quot;javaFileEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;\n\n        &lt;!-- 为模型生成序列化方法--&gt;\n        &lt;plugin type&#x3D;&quot;org.mybatis.generator.plugins.SerializablePlugin&quot;&#x2F;&gt;\n        &lt;!-- 为生成的Java模型创建一个toString方法 --&gt;\n        &lt;plugin type&#x3D;&quot;org.mybatis.generator.plugins.ToStringPlugin&quot;&#x2F;&gt;\n\n        &lt;!--可以自定义生成model的代码注释--&gt;\n        &lt;commentGenerator type&#x3D;&quot;com.rent.mbg.CommentGenerator&quot;&gt;\n            &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;\n            &lt;property name&#x3D;&quot;suppressAllComments&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;suppressDate&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n            &lt;property name&#x3D;&quot;addRemarkComments&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n        &lt;&#x2F;commentGenerator&gt;\n\n\n        \n        &lt;jdbcConnection driverClass&#x3D;&quot;$&#123;jdbc.driverClass&#125;&quot;\n                        connectionURL&#x3D;&quot;$&#123;jdbc.connectionURL&#125;&quot;\n                        userId&#x3D;&quot;$&#123;jdbc.userId&#125;&quot;\n                        password&#x3D;&quot;$&#123;jdbc.password&#125;&quot;&gt;\n            &lt;!--解决mysql驱动升级到8.0后不生成指定数据库代码的问题--&gt;\n            &lt;property name&#x3D;&quot;nullCatalogMeansCurrent&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;\n        &lt;&#x2F;jdbcConnection&gt;\n\n&lt;!--        &lt;javaTypeResolver &gt;--&gt;\n&lt;!--            &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;--&gt;\n&lt;!--        &lt;&#x2F;javaTypeResolver&gt;--&gt;\n\n        &lt;!--指定生成model的路径--&gt;\n        &lt;javaModelGenerator targetPackage&#x3D;&quot;com.rent.mbg.model&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;\n&lt;!--            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;--&gt;\n&lt;!--            &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;--&gt;\n        &lt;&#x2F;javaModelGenerator&gt;\n\n        &lt;!--指定生成mapper.xml的路径--&gt;\n        &lt;sqlMapGenerator targetPackage&#x3D;&quot;com.rent.mbg.mapper&quot;  targetProject&#x3D;&quot;src&#x2F;main&#x2F;resources&quot;&gt;\n&lt;!--            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;--&gt;\n        &lt;&#x2F;sqlMapGenerator&gt;\n\n        &lt;!--指定生成mapper接口的的路径--&gt;\n        &lt;javaClientGenerator type&#x3D;&quot;XMLMAPPER&quot; targetPackage&#x3D;&quot;com.rent.mbg.mapper&quot;  targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;\n&lt;!--            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;--&gt;\n        &lt;&#x2F;javaClientGenerator&gt;\n\n        &lt;table tableName&#x3D;&quot;pms_brand&quot; &gt;\n&lt;!--            &lt;property name&#x3D;&quot;useActualColumnNames&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;--&gt;\n            &lt;generatedKey column&#x3D;&quot;id&quot; sqlStatement&#x3D;&quot;MySql&quot; identity&#x3D;&quot;true&quot; &#x2F;&gt;\n&lt;!--            &lt;columnOverride column&#x3D;&quot;DATE_FIELD&quot; property&#x3D;&quot;startDate&quot; &#x2F;&gt;--&gt;\n&lt;!--            &lt;ignoreColumn column&#x3D;&quot;FRED&quot; &#x2F;&gt;--&gt;\n&lt;!--            &lt;columnOverride column&#x3D;&quot;LONG_VARCHAR_FIELD&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;--&gt;\n        &lt;&#x2F;table&gt;\n\n    &lt;&#x2F;context&gt;\n&lt;&#x2F;generatorConfiguration&gt;</code></pre></li>\n<li><p>写Generator：官网有示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; warnings &#x3D; new ArrayList&lt;String&gt;();\nboolean overwrite &#x3D; true;\nFile configFile &#x3D; new File(&quot;generatorConfig.xml&quot;);\nConfigurationParser cp &#x3D; new ConfigurationParser(warnings);\nConfiguration config &#x3D; cp.parseConfiguration(configFile);\nDefaultShellCallback callback &#x3D; new DefaultShellCallback(overwrite);\nMyBatisGenerator myBatisGenerator &#x3D; new MyBatisGenerator(config, callback, warnings);\nmyBatisGenerator.generate(null);\nfor (String warning : warnings) &#123;\n\t\tSystem.out.println(warning);\n&#125;</code></pre></li>\n<li><p>添加MyBatis的Java配置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * MyBatis配置类\n * Created by macro on 2019&#x2F;4&#x2F;8.\n *&#x2F;\n@Configuration\n@MapperScan(&quot;com.macro.mall.tiny.mbg.mapper&quot;)\npublic class MyBatisConfig &#123;\n&#125;</code></pre></li>\n<li><p>MyBatis使用XML和Annotation来配置、映射原语、映射接口、和Java POJO到数据库记录</p>\n<ul>\n<li><p>POJO：只有setter、getter、toString的简单类</p>\n</li>\n<li><p>配置数据源、编写XML文件（包含sql语句）:<a href=\"https://mybatis.org/mybatis-3/sqlmap-xml.html\">https://mybatis.org/mybatis-3/sqlmap-xml.html</a></p>\n<ul>\n<li>Mapper XML files<ul>\n<li>resultMap：how to load your objects from the database result sets.</li>\n<li>sql：A reusable chunk of SQL that can be referenced by other statements.</li>\n<li>insert：A mapped INSERT statement.</li>\n<li>update：A mapped UPDATE statement.</li>\n<li>delete：A mapped DELETE statement.</li>\n<li>select：A mapped SELECT statement.</li>\n</ul>\n</li>\n<li><strong>Dynamic SQL</strong><ul>\n<li>if：条件</li>\n<li>choose (when, otherwise)：switch选择</li>\n<li>trim (where, set)：</li>\n<li>foreach：循环</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>依据XML文件来构建<em><strong>*SqlSessionFactory*</strong></em></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String resource &#x3D; &quot;org&#x2F;mybatis&#x2F;example&#x2F;mybatis-config.xml&quot;;\nInputStream inputStream &#x3D; Resources.getResourceAsStream(resource);\nSqlSessionFactory sqlSessionFactory &#x3D;\n  new SqlSessionFactoryBuilder().build(inputStream);\n&#x2F;&#x2F;从SqlSessionFactory获得一个SqlSession\ntry (SqlSession session &#x3D; sqlSessionFactory.openSession()) &#123;\n  BlogMapper mapper &#x3D; session.getMapper(BlogMapper.class);\n  Blog blog &#x3D; mapper.selectBlog(101);\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>用于通过数据库的table信息来生成MyBatis代码，可以合并已有XML重写Java文件</p>\n<ul>\n<li><p>实体类（xxx）：table属性、get、set、toString、序列化、注释（commonGenerator）</p>\n</li>\n<li><p>映射文件（xxxMapper.xml）：具体的sql语句</p>\n</li>\n<li><p>Mapper接口（xxxMapper）：使用了xxxExample中的条件，与xxxMapper.xml中的sql语句一一对应</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long countByExample(PmsBrandExample example);&#x2F;&#x2F;按条件计数\nint deleteByExample(PmsBrandExample example);&#x2F;&#x2F;按条件删除\n\nint deleteByPrimaryKey(Long id);&#x2F;&#x2F;按主键删除\n\nint insert(PmsBrand record);&#x2F;&#x2F;插入数据，返回值为ID\n\nint insertSelective(PmsBrand record);&#x2F;&#x2F;插入数据，只插入值不为null的字段，内部动态sql判断\n\nList&lt;PmsBrand&gt; selectByExampleWithBLOBs(PmsBrandExample example);\n\nList&lt;PmsBrand&gt; selectByExample(PmsBrandExample example);&#x2F;&#x2F;按条件查询，传入null表示查询所有\n\nPmsBrand selectByPrimaryKey(Long id);&#x2F;&#x2F;按主键查询\n&#x2F;&#x2F;按条件更新值不为null的字段\nint updateByExampleSelective(@Param(&quot;record&quot;) PmsBrand record, @Param(&quot;example&quot;) PmsBrandExample example);\n&#x2F;&#x2F;BLOB：二进制大对象\nint updateByExampleWithBLOBs(@Param(&quot;record&quot;) PmsBrand record, @Param(&quot;example&quot;) PmsBrandExample example);\n&#x2F;&#x2F;按条件更新\nint updateByExample(@Param(&quot;record&quot;) PmsBrand record, @Param(&quot;example&quot;) PmsBrandExample example);\n&#x2F;&#x2F;按主键更新值不为null的字段\nint updateByPrimaryKeySelective(PmsBrand record);\n\nint updateByPrimaryKeyWithBLOBs(PmsBrand record);\n&#x2F;&#x2F;按主键更新\nint updateByPrimaryKey(PmsBrand record);</code></pre></li>\n<li><p>条件扩展类（xxxExample）：定义了一系列方法用来做条件，比如排序、去重、大于、小于、等于、模糊查询、数据在某某之间等</p>\n<ul>\n<li><code>GeneratedCriteria</code>：定义了一系列条件方法，最后都会拼接在SQL中（where语句），但是一般不使用它</li>\n<li><code>Criteria</code>：一般使用这个子类来进行操作，继承了<code>GeneratedCriteria</code>类</li>\n<li><code>Criterion</code>：将条件需要的属性抽象出来表示组成一个包装类</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>补充</p>\n<ol>\n<li><p>MyBatis中的ResultMap继承是一种非常有用的特性，它允许您创建一个ResultMap，该ResultMap可以继承另一个已经存在的ResultMap的配置，以便在不重复配置的情况下扩展或修改映射规则。这在处理复杂的查询结果映射时特别有用</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;resultMap id&#x3D;&quot;baseResultMap&quot; type&#x3D;&quot;com.example.User&quot;&gt;\n  &lt;id property&#x3D;&quot;id&quot; column&#x3D;&quot;user_id&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;username&quot; column&#x3D;&quot;user_name&quot;&#x2F;&gt;\n  &lt;result property&#x3D;&quot;email&quot; column&#x3D;&quot;user_email&quot;&#x2F;&gt;\n&lt;&#x2F;resultMap&gt;\n\n&lt;resultMap id&#x3D;&quot;extendedResultMap&quot; type&#x3D;&quot;com.example.ExtendedUser&quot; extends&#x3D;&quot;baseResultMap&quot;&gt;\n  &lt;!-- 添加额外的映射规则 --&gt;\n  &lt;result property&#x3D;&quot;phoneNumber&quot; column&#x3D;&quot;user_phone_number&quot;&#x2F;&gt;\n&lt;&#x2F;resultMap&gt;</code></pre></li>\n<li><p><code>#&#123;&#125; </code>和 <code>$&#123;&#125;</code>的区别</p>\n<ul>\n<li><code>#&#123;&#125;</code>是MyBatis中的预编译参数占位符。当使用<code>#&#123;&#125;</code>来引用参数时，MyBatis会将参数值以及它的类型安全地设置到SQL语句中，确保SQL语句是预编译的，可以防止SQL注入攻击</li>\n<li><code>$&#123;&#125;</code>是MyBatis中的字符串替换占位符。当使用<code>$&#123;&#125;</code>时，MyBatis会将参数值直接嵌入到SQL语句中，而不进行预编译。这意味着参数值会被原封不动地插入到SQL语句中，可能会导致SQL注入攻击的风险</li>\n<li>通常情况下，建议使用<code>#&#123;&#125;</code>来绑定参数，以提高安全性和预编译性。只有在必要的情况下，例如需要动态生成表名或列名时，才使用<code>$&#123;&#125;</code>。在使用<code>$&#123;&#125;</code>时，务必确保参数值是可信任的，以防止潜在的安全风险</li>\n</ul>\n</li>\n<li><p>如果在MyBatis中实体类中的属性是String类型，而数据库中的对应列是Integer类型，MyBatis会尝试进行类型转换，但会受到数据库和Java类型之间的限制和差异的影响。以下是可能发生的情况：</p>\n<ul>\n<li><strong>类型转换错误：</strong> 如果数据库中存储的值无法成功转换为String类型，或者将String类型的值转换为Integer类型时发生错误（例如，如果数据库列包含非数字字符），则会引发类型转换错误</li>\n<li><strong>数据截断：</strong> 如果数据库中的Integer值超出了String类型的范围（例如，数据库中的Integer值是很大的整数），则将导致String类型的数据截断，可能导致丢失精度</li>\n<li><strong>查询失败：</strong> 在查询时，如果使用了不匹配的类型，例如将String类型的属性与Integer类型的列进行比较，可能会导致查询失败或返回不正确的结果</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"2-设计模式-2\"><a href=\"#2-设计模式-2\" class=\"headerlink\" title=\"2.设计模式\"></a>2.设计模式</h3><ol>\n<li>工厂模式，工厂模式在 MyBatis 中的典型代表是 SqlSessionFactory</li>\n<li>建造者模式，建造者模式在 MyBatis 中的典型代表是 SqlSessionFactoryBuilder</li>\n<li>单例模式，单例模式在 MyBatis 中的典型代表是 ErrorContext</li>\n<li>适配器模式，适配器模式在 MyBatis 中的典型代表是 Log</li>\n<li>代理模式，代理模式在 MyBatis 中的典型代表是 MapperProxyFactory</li>\n<li>模板方法模式，模板方法在 MyBatis 中的典型代表是 BaseExecutor</li>\n<li>装饰器模式，装饰器模式在 MyBatis 中的典型代表是 Cache</li>\n</ol>\n<h3 id=\"3-原理分析\"><a href=\"#3-原理分析\" class=\"headerlink\" title=\"3.原理分析\"></a>3.原理分析</h3><ol>\n<li><p>MyBatis中创建了一个Mapper接口，在写一个xml文件，java的接口是要实现的，为什么这没有实现呢？</p>\n<ul>\n<li>MyBatis中的Mapper接口并不需要实现，它只是定义了一组方法签名。MyBatis会根据Mapper接口中的方法名、参数类型和返回值类型，自动生成实现方法。因此，Mapper接口中的方法不需要实现，也不需要在该接口中编写任何方法体</li>\n<li>相反，你需要编写一个与Mapper接口同名的XML文件，来实现这些方法的具体SQL操作。这样，当你在Java代码中调用Mapper接口中的方法时，MyBatis会自动将该方法映射到对应的XML文件中的SQL语句，并执行该语句</li>\n</ul>\n</li>\n<li><p>与传统的JDBC相比，MyBatis的优点</p>\n<ul>\n<li>mybatis的全局配置文件中可以设置数据库连接池，和spring整合可以配置数据库连接</li>\n<li>mybatis把sql和代码分离，提供了Mapper.xml映射文件，在映射文件中通过标签来写sql</li>\n<li>mybatis中自动完成java对象和sql中参数的映射</li>\n<li>mybatis中通过ResultSetHandler自动将结果集映射到对应的java对象中</li>\n</ul>\n</li>\n<li><p>Hibernete和MyBatis区别</p>\n<ul>\n<li>编程范式<ul>\n<li>Hibernate采用了全自动的对象关系映射（ORM）方式，它试图完全隐藏SQL操作，开发者只需要处理Java对象。它通过注解或XML文件配置实体类与数据库表的映射关系。</li>\n<li>MyBatis采用了半自动的ORM方式，开发者需要显式编写SQL语句来执行数据库操作。它通过XML或注解配置SQL语句和参数映射，但依然需要手动编写SQL。</li>\n</ul>\n</li>\n<li>性能<ul>\n<li>Hibernate在处理大量数据时可能引发性能问题，因为它需要加载整个对象图，可能会导致懒加载和性能下降</li>\n<li>MyBatis在性能方面更有优势，因为它可以针对每个查询编写优化的SQL语句，避免不必要的数据加载</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JDBC连接数据库的操作：注册JDBC驱动、打开链接执行查询（sql字符串）、输出所有结果（循环）</p>\n<ul>\n<li><p>加载数据库驱动程序：使用Class.forName()方法加载对应的数据库驱动程序，例如：Class.forName(“com.mysql.jdbc.Driver”);</p>\n</li>\n<li><p>建立数据库连接：使用DriverManager.getConnection()方法建立与数据库的连接，需要指定数据库的URL、用户名和密码，例如：Connection conn = DriverManager.getConnection(“jdbc:mysql://localhost/mydatabase”, “username”, “password”);</p>\n</li>\n<li><p>创建Statement对象：使用Connection对象的createStatement()方法创建一个Statement对象，用于执行SQL语句，例如：Statement stmt = conn.createStatement();</p>\n</li>\n<li><p>执行SQL语句：使用Statement对象的executeQuery()或executeUpdate()方法执行SQL语句，例如：ResultSet rs = stmt.executeQuery(“SELECT * FROM mytable”);</p>\n</li>\n<li><p>处理查询结果：如果执行的是查询语句，需要使用ResultSet对象来处理查询结果，例如：while (rs.next()) { String name = rs.getString(“name”); int age = rs.getInt(“age”); }</p>\n</li>\n<li><p>关闭数据库连接：在程序结束时，需要使用Connection对象的close()方法关闭数据库连接，例如：conn.close();</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.runoob.test;\n \nimport java.sql.*;\n \npublic class MySQLDemo &#123;\n \n    &#x2F;&#x2F; MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL\n    static final String JDBC_DRIVER &#x3D; &quot;com.mysql.jdbc.Driver&quot;;  \n    static final String DB_URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;RUNOOB&quot;;\n \n    &#x2F;&#x2F; MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL\n    &#x2F;&#x2F;static final String JDBC_DRIVER &#x3D; &quot;com.mysql.cj.jdbc.Driver&quot;;  \n    &#x2F;&#x2F;static final String DB_URL &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;RUNOOB?useSSL&#x3D;false&amp;allowPublicKeyRetrieval&#x3D;true&amp;serverTimezone&#x3D;UTC&quot;;\n\n \n    &#x2F;&#x2F; 数据库的用户名与密码，需要根据自己的设置\n    static final String USER &#x3D; &quot;root&quot;;\n    static final String PASS &#x3D; &quot;123456&quot;;\n \n    public static void main(String[] args) &#123;\n        Connection conn &#x3D; null;\n        Statement stmt &#x3D; null;\n        try&#123;\n            &#x2F;&#x2F; 注册 JDBC 驱动\n            Class.forName(JDBC_DRIVER);\n        \n            &#x2F;&#x2F; 打开链接\n            System.out.println(&quot;连接数据库...&quot;);\n            conn &#x3D; DriverManager.getConnection(DB_URL,USER,PASS);\n        \n            &#x2F;&#x2F; 执行查询\n            System.out.println(&quot; 实例化Statement对象...&quot;);\n            stmt &#x3D; conn.createStatement();\n            String sql;\n            sql &#x3D; &quot;SELECT id, name, url FROM websites&quot;;\n            ResultSet rs &#x3D; stmt.executeQuery(sql);\n        \n            &#x2F;&#x2F; 展开结果集数据库\n            while(rs.next())&#123;\n                &#x2F;&#x2F; 通过字段检索\n                int id  &#x3D; rs.getInt(&quot;id&quot;);\n                String name &#x3D; rs.getString(&quot;name&quot;);\n                String url &#x3D; rs.getString(&quot;url&quot;);\n    \n                &#x2F;&#x2F; 输出数据\n                System.out.print(&quot;ID: &quot; + id);\n                System.out.print(&quot;, 站点名称: &quot; + name);\n                System.out.print(&quot;, 站点 URL: &quot; + url);\n                System.out.print(&quot;\\n&quot;);\n            &#125;\n            &#x2F;&#x2F; 完成后关闭\n            rs.close();\n            stmt.close();\n            conn.close();\n        &#125;catch(SQLException se)&#123;\n            &#x2F;&#x2F; 处理 JDBC 错误\n            se.printStackTrace();\n        &#125;catch(Exception e)&#123;\n            &#x2F;&#x2F; 处理 Class.forName 错误\n            e.printStackTrace();\n        &#125;finally&#123;\n            &#x2F;&#x2F; 关闭资源\n            try&#123;\n                if(stmt!&#x3D;null) stmt.close();\n            &#125;catch(SQLException se2)&#123;\n            &#125;&#x2F;&#x2F; 什么都不做\n            try&#123;\n                if(conn!&#x3D;null) conn.close();\n            &#125;catch(SQLException se)&#123;\n                se.printStackTrace();\n            &#125;\n        &#125;\n        System.out.println(&quot;Goodbye!&quot;);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>MyBatis是一种持久化框架，它提供了一级缓存和二级缓存来提高数据库访问性能</p>\n<ul>\n<li>一级缓存：一级缓存是MyBatis的默认缓存机制，也称为本地缓存。它是一个SqlSession级别的缓存，即在同一个SqlSession内执行的多次查询可以共享一级缓存。当应用程序执行一个查询操作时，查询结果会被缓存在SqlSession的一级缓存中。如果相同的查询再次执行，MyBatis会首先检查一级缓存，如果缓存中存在对应的数据，将直接返回缓存中的结果，而不需要再次查询数据库<ul>\n<li><strong>生命周期：</strong> 一级缓存的生命周期与SqlSession相同。一旦SqlSession被关闭，一级缓存中的数据也将被清除</li>\n<li><strong>失效情况：</strong> 一级缓存会在SqlSession执行增、删、改等修改数据库操作时失效，因为这些操作可能会导致缓存中的数据不再是最新的</li>\n</ul>\n</li>\n<li>二级缓存：二级缓存是一个全局性的缓存，它可以被多个SqlSession共享。这意味着多个SqlSession可以从同一个二级缓存中获取数据，而不仅限于同一个SqlSession。 当一个查询被执行时，查询结果会被存储在二级缓存中。如果其他SqlSession执行相同的查询，它们可以从二级缓存中获取数据，而不需要访问数据库。（需要在配置文件中启用二级缓存、选择缓存实现类）<ul>\n<li><strong>生命周期：</strong> 二级缓存的生命周期与整个应用程序相同，只有当应用程序关闭时才会被清除。</li>\n<li><strong>失效情况：</strong> 二级缓存会在执行与缓存数据相关的增删改操作时失效。MyBatis提供了一些机制来配置缓存的失效策略，例如定时清除、手动清除等</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"7-Spring-Boot\"><a href=\"#7-Spring-Boot\" class=\"headerlink\" title=\"7.Spring Boot\"></a>7.Spring Boot</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>利用注解简化Spring的xml配置文件、提供自动配置功能（根据classpath中的库自动配置数据源、Web服务器、日志记录）、提供了约定大于配置的方式管理依赖（使用“Starter”模块来简化依赖的引入和版本管理）、支持内嵌多种Web容器（Tomcat、Netty、WebFlux（Reactor Netty））</p></blockquote>\n<h3 id=\"1-Annotation\"><a href=\"#1-Annotation\" class=\"headerlink\" title=\"1.Annotation\"></a>1.Annotation</h3><ul>\n<li><p><code>@SpringBootApplication</code>：默认加在主类的main方法上，可以看作是<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>注解的集合</p>\n<ul>\n<li><p><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</p>\n</li>\n<li><p><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>)注解修饰的 bean，注解默认会扫描该类所在的包下所有的类</p>\n</li>\n<li><p><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</p>\n<ul>\n<li><p>用<code>@Configuration</code>注释一个类表明一个对象时bean定义的来源，此外，<code>Configuration</code>类允许通过调用同一类中的其它<code>@Bean</code>方法来定义bean间的依赖关系</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class AppConfig &#123;\n    @Bean\n    public MyService myService() &#123;\n        return new MyServiceImpl();\n    &#125;\n&#125;\n&#x2F;&#x2F;与下面xml语句相同：\n&#x2F;&#x2F;&lt;beans&gt;\n&#x2F;&#x2F;    &lt;bean id&#x3D;&quot;myService&quot; class&#x3D;&quot;com.acme.services.MyServiceImpl&quot;&#x2F;&gt;\n&#x2F;&#x2F;&lt;&#x2F;beans&gt;</code></pre></li>\n<li><p>当<code>@Configuration</code>类作为输入提供时，<code>@Configuration</code>类本身被注册为bean定义，并且类中所有声明的<code>@Bean</code>方法也被注册为bean定义，使用<code>AnnotationConfigApplicationContext</code>访问</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">       public static void main(String[] args) &#123;\n           ApplicationContext ctx &#x3D; new AnnotationConfigApplicationContext(AppConfig.class);\n           MyService myService &#x3D; ctx.getBean(MyService.class);\n           myService.doStuff();\n       &#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Bean相关的注解：<code>@Autowired</code>、<code>@Component</code>、<code>@Repository</code>、<code>@Service</code>、<code>@Controller</code>、<code>@RestController</code>、<code>@Controller</code>、<code>@ResponseBody</code>、<code>@Scope</code>、<code>@Configuration</code>、<code>@Component</code></p>\n<ul>\n<li><p><code>@Bean</code>：用于表示一个方法实例化、配置和初始化一个由IoC容器管理的新对象，与<beans/>元素的作用相同。可以使用此方法来制定为方法返回值的类型的ApplicationContext中注册bean定义。可以和任何Spring的@Component一起使用，但是通常与@Configurationbean一起使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">     @Configuration\n     public class AppConfig &#123;\n         @Bean&#x2F;&#x2F;默认情况，bean名称与方法名称相同\n         public TransferServiceImpl transferService() &#123;\n             return new TransferServiceImpl();\n         &#125;\n         &#x2F;&#x2F;可以有任意数量的参数来描述构建该bean所需的依赖项\n         &#x2F;&#x2F;@Bean\n         &#x2F;&#x2F; public TransferService transferService(AccountRepository accountRepository) &#123;\n         &#x2F;&#x2F;     return new TransferServiceImpl(accountRepository);\n         &#x2F;&#x2F;&#125;\n     &#125;</code></pre></li>\n<li><p><code>@Autowired</code>：自动导入对象到类中，被注入进的类同样要被Spring容器管理</p>\n<ul>\n<li><p>示例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Service\npublic class UserService &#123;\n  &#x2F;&#x2F;......\n&#125;\n\n@RestController\n@RequestMapping(&quot;&#x2F;users&quot;)\npublic class UserController &#123;\n   @Autowired\n   private UserService userService;\n   &#x2F;&#x2F;......\n&#125;</code></pre></li>\n<li><p>其他</p>\n<ul>\n<li><p>用在构造函数上，Spring4.3开始不再需要，但如果有多个构造函数则需要使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n    private final CustomerPreferenceDao customerPreferenceDao;\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>用于传统的setter方法：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SimpleMovieLister\n    private MovieFinder movieFinder;\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder &#x3D; movieFinder;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p>用于字段，甚至可以将其与构造函数混用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n \n     private final CustomerPreferenceDao customerPreferenceDao;\n     @Autowired\n     private MovieCatalog movieCatalog;\n     @Autowired\n     public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n         this.customerPreferenceDao &#x3D; customerPreferenceDao;\n     &#125;\n     &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>@Component</code>,<code>@Repository</code>,<code>@Service</code>, <code>@Controller</code>：用于将类标识为可自动装配的bean</p>\n<ul>\n<li><p><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</p>\n<ul>\n<li><p>任何满足存储库角色（DAO）的类的标记，用途是异常的自动翻译，类似的其它原型注解有：<code>@Controller（表示层）</code>、<code>@Service（服务层）</code>、<code>@Repository（持久层）</code>，尽量不选<code>@Component</code>而选后面那三个</p>\n</li>\n<li><p>Spring能自动检测原型类，并使用<code>ApplicationContext</code>注册相应的<code>BeanDefinition</code>实例，要自动检测这些类并注册相应的bean，需要将<code>@ComponentScan(basePackages = &quot;org.example&quot;)</code>添加到<code>@Configuration</code>类中</p>\n</li>\n<li><p>用<code>@Component</code>定义bean元数据：将bean定义元数据贡献给容器</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">         @Component\n         public class FactoryMethodComponent &#123;\n             @Bean &#x2F;&#x2F;表示工厂方法和其它bean定义属性\n             @Qualifier(&quot;public&quot;)\n             public TestBean publicInstance() &#123;\n                 return new TestBean(&quot;publicInstance&quot;);\n             &#125;\n         \n             public void doWork() &#123;\n                 &#x2F;&#x2F; Component method implementation omitted\n             &#125;\n         &#125;</code></pre></li>\n</ul>\n</li>\n<li><p><code>@Repository</code>: 对应持久层即 Dao 层，主要用于数据库相关操作（dao层的代码注入到ServiceImpl中）</p>\n<ul>\n<li><p>使用<code>Mybatis</code>不需要<code>Repository</code>：关键在于<code>ClassPathMapperScanner</code>对指定包的扫描并且扫描过程，<code>Spring</code>本身只扫描实现类，但是<code>MyBatis</code>的扫描器扫了接口，并且为接口配了个<code>BeanDefinition</code>，其<code>BeanClass</code>是<code>MapperFactoryBean</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\n&#x2F;&#x2F;配置了MapperScan，在对应路径下扫描class文件\n@MapperScan(&#123;&quot;com.rent.mbg.mapper&quot;,&quot;com.rent.dao&quot;&#125;)\npublic class MyBatisConfig &#123;\n&#125;</code></pre></li>\n<li><p><code>MapperScannerRegistrar.registerBeanDefinitions()</code>：扫描Mapper并注册是注册BeanDefinitions到Spring中</p>\n<ul>\n<li><p>创建一个扫描器<code>ClassPathMapperScanner</code>，设置好一些属性后，执行<code>doScan()</code>方法区扫描<code>@MapperScan</code>提供的包</p>\n</li>\n<li><p><code>doScan()</code>方法调用父类<code>ClassPathBeanDefinitionScanner</code>的<code>doScan()</code>方法，也就是Spring扫描<code>BeanDefinition</code>的方法，在其中对所有候选者调用<code>isCandidateComponent()</code>方法判断是否为符合要求的<code>BeanDefinition</code>（这里有两组过滤器来过滤扫描到的资源，Spring默认的过滤器是排除掉抽象类/接口，而Mybatis的扫描器重新注册了过滤器，默认对接口放行）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;\n\t&#x2F;&#x2F;调用父类的doscan，即Spring扫描BeanDefinition方法，但是重新注册了过滤器，可以对接口放行\n  Set&lt;BeanDefinitionHolder&gt; beanDefinitions &#x3D; super.doScan(basePackages);\n\n  if (beanDefinitions.isEmpty()) &#123;\n    logger.warn(&quot;No MyBatis mapper was found in &#39;&quot; + Arrays.toString(basePackages) + &quot;&#39; package. Please check your configuration.&quot;);\n  &#125; else &#123;\n\t\t&#x2F;&#x2F;通过接口注册BeanDefinition后，在此实例化Bean对象，因为正常接口无法实例化对象\n    processBeanDefinitions(beanDefinitions);\n  &#125;\n\n  return beanDefinitions;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;processBeanDefinitions里面&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#x2F;&#x2F; the mapper interface is the original class of the bean\n&#x2F;&#x2F; but, the actual class of the bean is MapperFactoryBean\n\t\tdefinition.getConstructorArgumentValues().addGenericArgumentValue(definition.getBeanClassName()); &#x2F;&#x2F; 使用了Object[] argsToUse将String转换成了Object\n    definition.setBeanClass(this.mapperFactoryBean.getClass());</code></pre></li>\n<li><p>以<code>UserDao</code>为例，自动装配时，Spring根据注册时候的<code>BeanDefinition</code>，去工厂<code>mapperFactoryBean</code>里面扔了个<code>UserDao.class</code>参数进去，工厂的<code>getObject</code>方法返回了工厂制造的<code>userDao</code>，其实工厂的<code>getObject</code>使用的是<code>DefaultSqlSession.getMapper(Class type)</code>方法，返回的事MapperProxy代理的类，而这个代理的类的<code>invoke</code>方法并不像平常调用原始目标的 <code>method.invoke</code>，而是去找<code>MapperMethod</code>执行</p>\n</li>\n</ul>\n</li>\n<li><p>加了 <code>@Repository</code> 注解有什么影响：仅仅只能解决 Intellij 静态查找 bean 的问题，没有实际作用。即使加了注解，比如<code>@Controller</code>，<code>@Service</code> 等等，也会被 Spring 的扫描器给忽略掉，因为扫描器会过滤掉接口</p>\n</li>\n</ul>\n</li>\n<li><p><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层（<code>service</code>的实现<code>serviceImpl</code>会注入到<code>controller</code>）</p>\n</li>\n<li><p><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面</p>\n</li>\n</ul>\n</li>\n<li><p><code>@RestController</code></p>\n<ul>\n<li><code>@RestController</code>注解是<code>@Controller</code>和<code>@ResponseBody</code>的合集，表示这是个控制器bean，并且是将函数的返回值直接填入HTTP响应体中，是REST风格的控制器</li>\n<li>单独使用<code>@Controller</code>不加<code>@ResponseBody</code>的话一般是用在要返回一个视图的情况，这种情况属于比较传统的Spring MVC的应用，对应于前后端不分离的情况，<code>@Controller</code>+<code>@ResponseBody</code>返回 JSON 或 XML 形式数据，写入到HTTP响应中，提供给前端页面进行解析</li>\n</ul>\n</li>\n<li><p><code>@Scope</code></p>\n<ul>\n<li><p>声明Spring Bean的作用域，主要有四种常见的作用域：</p>\n<ul>\n<li>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</li>\n<li>prototype : 每次请求都会创建一个新的 bean 实例。</li>\n<li>request : 每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。</li>\n<li>session : 每一个 HTTP Session 会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Bean\n@Scope(&quot;singleton&quot;)\npublic Person personSingleton() &#123;\n    return new Person();\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p><code>@Configuration</code>：一般用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class AppConfig &#123;\n    @Bean\n    public TransferService transferService() &#123;\n        return new TransferServiceImpl();\n    &#125;\n\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>处理常见的 HTTP 请求类型：<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>、<code>@PatchMapping</code></p>\n<ul>\n<li><p><strong>GET</strong> ：请求从服务器获取特定资源。举个例子：<code>GET /users</code>（获取所有学生）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;等价于 @RequestMapping(value&#x3D;&quot;&#x2F;users&quot;,method&#x3D;RequestMethod.GET)\n@GetMapping(&quot;&#x2F;users&quot;)\npublic ResponseEntity&lt;List&lt;User&gt;&gt; getAllUsers() &#123;\n return userRepository.findAll();\n&#125;</code></pre></li>\n<li><p><strong>POST</strong> ：在服务器上创建一个新的资源。举个例子：<code>POST /users</code>（创建学生）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;等价于 @RequestMapping(value&#x3D;&quot;&#x2F;users&#x2F;&#123;userId&#125;&quot;,method&#x3D;RequestMethod.PUT)\n@PostMapping(&quot;&#x2F;users&quot;)\npublic ResponseEntity&lt;User&gt; createUser(@Valid @RequestBody UserCreateRequest userCreateRequest) &#123;\n return userRespository.save(userCreateRequest);\n&#125;</code></pre></li>\n<li><p><strong>PUT</strong> ：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /users/12</code>（更新编号为 12 的学生）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;等价于 @RequestMapping(value&#x3D;&quot;&#x2F;users&#x2F;&#123;userId&#125;&quot;,method&#x3D;RequestMethod.PUT)\n@PutMapping(&quot;&#x2F;users&#x2F;&#123;userId&#125;&quot;)\npublic ResponseEntity&lt;User&gt; updateUser(@PathVariable(value &#x3D; &quot;userId&quot;) Long userId,\n  @Valid @RequestBody UserUpdateRequest userUpdateRequest) &#123;\n  ......\n&#125;</code></pre></li>\n<li><p><strong>DELETE</strong> ：从服务器删除特定的资源。举个例子：<code>DELETE /users/12</code>（删除编号为 12 的学生）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;等价于 @RequestMapping(value&#x3D;&quot;&#x2F;users&#x2F;&#123;userId&#125;&quot;,method&#x3D;RequestMethod.DELETE)\n@DeleteMapping(&quot;&#x2F;users&#x2F;&#123;userId&#125;&quot;)\npublic ResponseEntity deleteUser(@PathVariable(value &#x3D; &quot;userId&quot;) Long userId)&#123;\n  ......\n&#125;</code></pre></li>\n<li><p><strong>PATCH</strong> ：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，一般是PUT不够用了之后才用 PATCH 请求去更新数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@PatchMapping(&quot;&#x2F;profile&quot;)\npublic ResponseEntity updateStudent(@RequestBody StudentUpdateRequest studentUpdateRequest) &#123;\n      studentRepository.updateDetail(studentUpdateRequest);\n      return ResponseEntity.ok().build();\n  &#125;</code></pre></li>\n</ul>\n</li>\n<li><p>前后端传值：<code>@PathVariable</code>、<code>@RequestParam</code>、<code>@RequestBody</code></p>\n<ul>\n<li><p><code>@PathVariable</code> 和 <code>@RequestParam</code>：<code>@PathVariable</code>用于获取路径参数，<code>@RequestParam</code>用于获取查询参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@GetMapping(&quot;&#x2F;klasses&#x2F;&#123;klassId&#125;&#x2F;teachers&quot;)\npublic List&lt;Teacher&gt; getKlassRelatedTeachers(\n   @PathVariable(&quot;klassId&quot;) Long klassId,\n   @RequestParam(value &#x3D; &quot;type&quot;, required &#x3D; false) String type ) &#123;\n\t&#x2F;&#x2F;...\n&#125;\n&#x2F;&#x2F;请求的url是：klasses&#x2F;123456&#x2F;teachers?type&#x3D;web\n&#x2F;&#x2F;获取到的数据就是：klassId&#x3D;123456 type&#x3D;web</code></pre></li>\n<li><p><code>@RequestBody</code></p>\n<ul>\n<li><p>用于读取Request请求（可能是POST、PUT、DELETE、GET请求）的body部分并且Content-Type为application/json，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象</p>\n</li>\n<li><p>一个请求方法只可以有一个<code>@RequestBody</code>，但是可以有多个**<code>@RequestParam</code>和<code>@PathVariable</code>**</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;发送POST请求到这个接口，并且body携带JSON数据\n&#x2F;&#x2F;&#123;&quot;userName&quot;:&quot;coder&quot;,&quot;fullName&quot;:&quot;shuangkou&quot;,&quot;password&quot;:&quot;123456&quot;&#125;\n&#x2F;&#x2F;后端就可以直接把 json 格式的数据映射到 UserRegisterRequest\n@PostMapping(&quot;&#x2F;sign-up&quot;)\npublic ResponseEntity signUp(@RequestBody @Valid UserRegisterRequest userRegisterRequest) &#123;\n  userService.save(userRegisterRequest);\n  return ResponseEntity.ok().build();\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;UserRegisterRequest&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserRegisterRequest &#123;\n    @NotBlank\n    private String userName;\n    @NotBlank\n    private String password;\n    @NotBlank\n    private String fullName;\n&#125;</code></pre></li>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>读取配置信息：<code>@Value</code>、<code>@ConfigurationProperties</code>、<code>@PropertySource</code></p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\">wuhan2020: 2020年初武汉爆发了新型冠状病毒，疫情严重，但是，我相信一切都会过去！武汉加油！中国加油！\n\nmy-profile:\n  name: Guide哥\n  email: koushuangbwcx@163.com\n\nlibrary:\n  location: 湖北武汉加油中国加油\n  books:\n    - name: 天才基本法\n      description: 二十二岁的林朝夕在父亲确诊阿尔茨海默病这天，得知自己暗恋多年的校园男神裴之即将出国深造的消息——对方考取的学校，恰是父亲当年为她放弃的那所。\n    - name: 时间的秩序\n      description: 为什么我们记得过去，而非未来？时间“流逝”意味着什么？是我们存在于时间之内，还是时间存在于我们之中？卡洛·罗韦利用诗意的文字，邀请我们思考这一亘古难题——时间的本质。\n    - name: 了不起的我\n      description: 如何养成一个新习惯？如何让心智变得更成熟？如何拥有高质量的关系？ 如何走出人生的艰难时刻？</code></pre>\n\n<ul>\n<li><p><code>@Value</code>(常用)：通常用于注入外部化属性</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;applicationConfig会被定义在application.yml中\n@Value(&quot;$&#123;wuhan2020&#125;&quot;)\nString wuhan2020;\n\n&#x2F;&#x2F;示例二\n@Component\n public class MovieRecommender &#123;\n \n     private final String catalog;\n     &#x2F;&#x2F;application.properties中有catalog.name&#x3D;MovieCatalog\n     &#x2F;&#x2F;catalog的值就为MovieCatalog\n     public MovieRecommender(@Value(&quot;$&#123;catalog.name&#125;&quot;) String catalog) &#123;\n         this.catalog &#x3D; catalog;\n     &#125;\n &#125;\n &#x2F;&#x2F;还需以下配置\n @Configuration\n @PropertySource(&quot;classpath:application.properties&quot;)\n public class AppConfig &#123; &#125;</code></pre></li>\n<li><p><code>@ConfigurationProperties</code>(常用)：通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\n@ConfigurationProperties(prefix &#x3D; &quot;library&quot;)\nclass LibraryProperties &#123;\n    @NotEmpty\n    private String location;\n    private List&lt;Book&gt; books;\n\n    @Setter\n    @Getter\n    @ToString\n    static class Book &#123;\n        String name;\n        String description;\n    &#125;\n  省略getter&#x2F;setter\n  ......\n&#125;</code></pre></li>\n<li><p><code>@PropertySource</code>：读取指定 properties 文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Component\n@PropertySource(&quot;classpath:website.properties&quot;)\n\nclass WebSite &#123;\n    @Value(&quot;$&#123;url&#125;&quot;)\n    private String url;\n\n  省略getter&#x2F;setter\n  ......\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>参数校验</p>\n<ul>\n<li><p>数据的校验的重要性就不用说了，即使在前端对数据进行校验的情况下，我们还是要对传入后端的数据再进行一遍校验，避免用户绕过浏览器直接通过一些 HTTP 工具直接向后端请求一些违法数据</p>\n<ul>\n<li><p>验证请求体</p>\n<ul>\n<li>字段上加<code>@NotNull(message = &quot;classId 不能为空&quot;)</code></li>\n<li>参数上加<code>public ResponseEntity&lt;Person&gt; getPerson(@RequestBody @Valid Person person)</code></li>\n</ul>\n</li>\n<li><p><strong>验证请求参数(Path Variables 和 Request Parameters)</strong></p>\n<ul>\n<li><p>类上加<code>@Validated</code> ****注解，告诉Spring校验方法参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@RestController\n@RequestMapping(&quot;&#x2F;api&quot;)\n@Validated\npublic class PersonController &#123;\n\n    @GetMapping(&quot;&#x2F;person&#x2F;&#123;id&#125;&quot;)\n    public ResponseEntity&lt;Integer&gt; getPersonByID(@Valid @PathVariable(&quot;id&quot;) @Max(value &#x3D; 5,message &#x3D; &quot;超过 id 的范围了&quot;) Integer id) &#123;\n        return ResponseEntity.ok().body(id);\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JSR(Java Specification Requests）是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，这样就可以在需要校验的时候进行校验了，非常方便，<em><strong>*一些常用的字段验证的注解如下*</strong></em></p>\n<ul>\n<li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li>\n<li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非空白字符</li>\n<li><code>@Null</code> 被注释的元素必须为 null</li>\n<li><code>@NotNull</code> 被注释的元素必须不为 null</li>\n<li><code>@AssertTrue</code> 被注释的元素必须为 true</li>\n<li><code>@AssertFalse</code> 被注释的元素必须为 false</li>\n<li><code>@Pattern(regex=,flag=)</code>被注释的元素必须符合指定的正则表达式</li>\n<li><code>@Email</code> 被注释的元素必须是 Email 格式。</li>\n<li><code>@Min(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>\n<li><code>@Max(value)</code>被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>\n<li><code>@DecimalMin(value)</code>被注释的元素必须是一个数字，其值必须大于等于指定的最小值</li>\n<li><code>@DecimalMax(value)</code> 被注释的元素必须是一个数字，其值必须小于等于指定的最大值</li>\n<li><code>@Size(max=, min=)</code>被注释的元素的大小必须在指定的范围内</li>\n<li><code>@Digits(integer, fraction)</code>被注释的元素必须是一个数字，其值必须在可接受的范围内</li>\n<li><code>@Past</code>被注释的元素必须是一个过去的日期</li>\n<li><code>@Future</code> 被注释的元素必须是一个将来的日期</li>\n</ul>\n</li>\n<li><p>校验的时候我们实际用的是 <strong>Hibernate Validator</strong> 框架。Hibernate Validator 是 Hibernate 团队最初的数据校验框架，Hibernate Validator 4.x 是 Bean Validation 1.0（JSR 303）的参考实现，Hibernate Validator 5.x 是 Bean Validation 1.1（JSR 349）的参考实现，目前最新版的 Hibernate Validator 6.x 是 Bean Validation 2.0（JSR 380）的参考实现。SpringBoot 项目的 spring-boot-starter-web 依赖中已经有 hibernate-validator 包，不需要引用相关依赖</p>\n<ul>\n<li>需要注意的是： <strong>所有的注解，推荐使用 JSR 注解，即<code>javax.validation.constraints</code>，而不是<code>org.hibernate.validator.constraints</code></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>全局处理Controller层异常</p>\n<ul>\n<li><code>@ControllerAdvice</code> ：注解定义全局异常处理类</li>\n<li><code>@ExceptionHandler</code> ：注解声明异常处理方法</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ControllerAdvice\n@ResponseBody\npublic class GlobalExceptionHandler &#123;\n\n    &#x2F;**\n     * 请求参数异常处理\n\t\t * 处理controller抛出的MethodArgumentNotValidException异常\n     *&#x2F;\n    @ExceptionHandler(MethodArgumentNotValidException.class)\n    public ResponseEntity&lt;?&gt; handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, HttpServletRequest request) &#123;\n       ......\n    &#125;\n&#125;</code></pre></li>\n<li><p>JPA相关</p>\n<ul>\n<li><p><code>@Entity</code>声明一个类对应一个数据库实体</p>\n</li>\n<li><p><code>@Table</code>设置表名</p>\n</li>\n<li><p><code>@Id</code>声明一个字段为主键</p>\n</li>\n<li><p><code>@GeneratedValue</code>指定主键生成策略</p>\n<ul>\n<li><code>TABLE</code>：使用一个特定的数据库表格来保存主键，持久化引擎通过关系数据库的一张特定的表格来生成主键</li>\n<li><code>SEQUENCE</code>：<em>在某些数据库中,不支持主键自增长,比如Oracle、PostgreSQL其提供了一种叫做”序列(sequence)”的机制生成主键</em></li>\n<li><code>IDENTITY</code>：<em>主键自增长</em></li>\n<li><code>AUTO</code>：把主键生成策略交给持久化引擎(persistence engine)，根据数据库在以上三种主键生成策略中选择其中一种</li>\n</ul>\n</li>\n<li><p><code>@Column</code> 声明字段</p>\n<ul>\n<li><code>@Column(name = &quot;user_name&quot;, nullable = false, length=32)</code></li>\n<li>设置字段类型并且加默认值<code>@Column(columnDefinition = &quot;tinyint(1) default 1&quot;)</code></li>\n</ul>\n</li>\n<li><p><code>@Transient</code>声明不需要与数据库映射的字段，在保存的时候不需要保存进数据库</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;************除了 @Transient关键字声明， 还可以采用下面几种方法&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;************\nstatic String secrect; &#x2F;&#x2F; not persistent because of static\nfinal String secrect &#x3D; &quot;Satish&quot;; &#x2F;&#x2F; not persistent because of final\ntransient String secrect; &#x2F;&#x2F; not persistent because of transient</code></pre></li>\n<li><p><code>@Enumerated(EnumType.STRING)</code>声明为枚举类型字段</p>\n</li>\n</ul>\n</li>\n<li><p>事务</p>\n<ul>\n<li>Exception 分为运行时异常 RuntimeException 和非运行时异常，在<code>@Transactionsl</code>注解中如果不配置<code>rollbackFor</code>属性，那么事务只会在遇到RuntimeException的时候才会回滚，加上<code>rollbackFor=Exception.class</code>，可以让事务在遇到非运行时异常时也回滚</li>\n</ul>\n</li>\n<li><p>json数据处理</p>\n<ul>\n<li><p>过滤json数据</p>\n<ul>\n<li><strong><code>@JsonIgnoreProperties</code> 作用在类上用于过滤掉特定字段不返回或者不解析</strong></li>\n<li><strong><code>@JsonIgnore</code>一般用于类的属性上，作用和上面的<code>@JsonIgnoreProperties</code> 一样</strong></li>\n</ul>\n</li>\n<li><p><code>@JsonFormat</code>一般用来格式化 json 数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@JsonFormat(shape&#x3D;JsonFormat.Shape.STRING, pattern&#x3D;&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&quot;, timezone&#x3D;&quot;GMT&quot;)\nprivate Date date;</code></pre></li>\n<li><p>使用<code>@JsonUnwrapped</code>扁平对象，声明在每一个字段上</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#123;\n    &quot;location&quot;: &#123;\n        &quot;provinceName&quot;:&quot;湖北&quot;,\n        &quot;countyName&quot;:&quot;武汉&quot;\n    &#125;,\n    &quot;personInfo&quot;: &#123;\n        &quot;userName&quot;: &quot;coder1234&quot;,\n        &quot;fullName&quot;: &quot;shaungkou&quot;\n    &#125;\n&#125;\n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;扁平化后&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\n&#123;\n  &quot;provinceName&quot;:&quot;湖北&quot;,\n  &quot;countyName&quot;:&quot;武汉&quot;,\n  &quot;userName&quot;: &quot;coder1234&quot;,\n  &quot;fullName&quot;: &quot;shaungkou&quot;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>测试相关</p>\n<ul>\n<li><p><code>@ActiveProfiles</code>一般作用于测试类上， 用于声明生效的 Spring 配置文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SpringBootTest(webEnvironment &#x3D; RANDOM_PORT)\n@ActiveProfiles(&quot;test&quot;)\n@Slf4j\npublic abstract class TestBase &#123;\n  ......\n&#125;</code></pre></li>\n<li><p><code>@Test</code>声明一个方法为测试方法</p>\n</li>\n<li><p><code>@Transactional</code>被声明的测试方法的数据会回滚，避免污染测试数据</p>\n</li>\n<li><p><strong><code>@WithMockUser</code> Spring Security 提供的，用来模拟一个真实用户，并且可以赋予权限</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Test\n@Transactional\n@WithMockUser(username &#x3D; &quot;user-id-18163138155&quot;, authorities &#x3D; &quot;ROLE_TEACHER&quot;)\nvoid should_import_student_success() throws Exception &#123;\n    ......\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>其他</p>\n<ul>\n<li><p><code>@Primary</code>表示当多个bean成为自动装配的候选者时，应该优先考虑特定的bean</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Configuration\npublic class MovieConfiguration &#123;\n\n    @Bean\n    @Primary\n    public MovieCatalog firstMovieCatalog() &#123; ... &#125;\n\n    @Bean\n    public MovieCatalog secondMovieCatalog() &#123; ... &#125;\n    &#x2F;&#x2F; ...\n&#125;\npublic class MovieRecommender &#123;\n  &#x2F;&#x2F;自动装配firstMovieCatalog\n    @Autowired\n    private MovieCatalog movieCatalog;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@Qualifier</code>：可以将限定符值与特定参数相关联，缩小类型匹配的范围，以便为每个参数选择特定的bean：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(@Qualifier(&quot;main&quot;) MovieCatalog movieCatalog,\n                        CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog &#x3D; movieCatalog;\n        this.customerPreferenceDao &#x3D; customerPreferenceDao;\n    &#125;\n    &#x2F;&#x2F; ...\n&#125;</code></pre></li>\n<li><p><code>@Resource</code>：采用名称属性，默认将该值解释为要注入的bean名称，如果没有明确指定名称，如果是字段，则采用字段名称，如果是setter方法，则采用bean属性名称</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">     public class SimpleMovieLister &#123;\n     \n         private MovieFinder movieFinder;\n         @Resource(name&#x3D;&quot;myMovieFinder&quot;)\n         public void setMovieFinder(MovieFinder movieFinder) &#123;\n             this.movieFinder &#x3D; movieFinder;\n         &#125;\n     &#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-AutoConfiguration\"><a href=\"#2-AutoConfiguration\" class=\"headerlink\" title=\"2.AutoConfiguration\"></a>2.AutoConfiguration</h3><ol>\n<li><p>SPI扩展机制（Service Provider Interface 服务提供者的接口）</p>\n<ul>\n<li><p>API</p>\n<ul>\n<li><p>示例：spring项目中，写service层代码前，会约定俗成的添加一个接口层，然后通过spring中的依赖注入（<code>@Autowired</code>）注入这个接口的实现类的实例对象，之后对于service的调用也基于接口操作（虽然有的时候一个接口只有一个实现类，但是面向接口编程可以降低耦合度、方便日后扩展、提高了代码的灵活性和可维护性）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730173055712.png\" alt=\"image-20230730173055712\"></p>\n</li>\n</ul>\n</li>\n<li><p>SPI</p>\n<ul>\n<li><p>示例：<code>slf4j</code>框架的<code>LoggerFactory</code>中的<code>findServiceProviders</code>方法返回所有<code>SLF4JServiceProvider</code>（日志服务提供者，一个接口，需要具体的提供者来实现）</p>\n</li>\n<li><p>服务调用方定义一个接口规范，可以由不同的服务提供者实现，并且，调用方通过某种机制来发现服务提供方，并通过接口调用它的能力</p>\n</li>\n<li><p>API接口是服务提供者向服务调用者提供的一个功能列表（），而SPI机制是服务调用者提供对服务的一种约束（遥控器约束所有空调只有开关等功能），服务提供者根据约束实现的服务，可以被服务调用者发现</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730173107648.png\" alt=\"image-20230730173107648\"></p>\n</li>\n</ul>\n</li>\n<li><p>SPI工作流程（<code>ServiceLoader</code>）</p>\n<ul>\n<li><p>首先通过<code>ServiceLoader</code>提供的<code>load</code>方法传入接口的<code>class</code>，返回<code>ServiceLoader</code>对象，然后遍历<code>ServiceLoader</code>对象通过接口来引用（<code>接口.getClass</code>）其中的实现类</p>\n</li>\n<li><p><code>acc</code>是一个安全管理器，通过<code>System.getSecurityManager()</code>判断并赋值，这里为null</p>\n</li>\n<li><p>ServiceLoader实现了Iterable接口，它的遍历通过Iterator()方法来实现，再Iterator()方法中，首先在一个LinkedHashMap</p>\n<p>实现的名为provider缓存中遍历，没有的时候在LazyIterator类型的懒加载的lookupIterator对象中查找</p>\n<ul>\n<li><code>hasNext</code>方法，逻辑实现为<code>hasNextService</code>方法，取出接口的实现类的全限定名放到<code>nextName</code>中</li>\n<li><code>next</code>方法，逻辑实现为<code>nextService</code>方法，通过反射加载（<code>Class.forName</code>）这个实现类，然后实例化对象（<code>newInstance</code>），最后放入之间的<code>provider</code>缓冲中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>spring.factories</code></p>\n</li>\n<li><p><code>@EnableAutoConfiguration</code></p>\n</li>\n</ol>\n<h3 id=\"3-SpringApplication\"><a href=\"#3-SpringApplication\" class=\"headerlink\" title=\"3.SpringApplication\"></a>3.SpringApplication</h3><ol>\n<li><p>从Java的main方法启动一个Spring应用的过程</p>\n<ul>\n<li><p>SpringApplication的run方法</p>\n<ul>\n<li>运行SpringApplication，创建并更新ApplicationContext<ul>\n<li>run方法中的refresh方法<ul>\n<li>初始化BeanFactory，加载Bean，注册Bean</li>\n<li>定义的一个个Bean会被转换成BeanDefinition，存在于Spring的BeanFactory中，即Bean可以理解为BeanDefinition的实例，里面保存了Bean的信息（Bean指向哪个类，是否是单例，是否懒加载，依赖了哪些Bean）</li>\n<li>refreshBeanFactory中的loadBeanDefinitions：根据配置，加载各个Bean，然后放到BeanFactory中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>记录应用启动时间</li>\n<li>声明异常链表，报告启动错误</li>\n</ul>\n</li>\n<li><p>两个结构</p>\n<ul>\n<li><p>ApplicationContext</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730172846551.png\" alt=\"image-20230730172846551\"></p>\n</li>\n<li><p>BeanFactory（Application其实就是一个<code>BeanFactory</code>，里面使用<code>DefaultListableBeanFactory</code>）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730172902197.png\" alt=\"image-20230730172902197\"></p>\n</li>\n</ul>\n</li>\n<li><p>启动步骤</p>\n<ul>\n<li><p>根据classpath创建一个<code>ApplicationContext</code></p>\n<ul>\n<li><code>ApplicationContext</code>可以从多个不同数据源读入数据，</li>\n</ul>\n</li>\n<li><p>注册一个<code>CommandLinePropertySource</code>，将命令行参数扩展成<code>Spring</code>属性</p>\n</li>\n<li><p>刷新应用上下文，载入单例类（PropertyContext）</p>\n</li>\n<li><p>触发CommandLineRunner的bean</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"4-SpringBootStarters\"><a href=\"#4-SpringBootStarters\" class=\"headerlink\" title=\"4.SpringBootStarters\"></a>4.SpringBootStarters</h3><h3 id=\"5-Actuators\"><a href=\"#5-Actuators\" class=\"headerlink\" title=\"5.Actuators\"></a>5.Actuators</h3><h2 id=\"8-Spring-Security\"><a href=\"#8-Spring-Security\" class=\"headerlink\" title=\"8.Spring Security\"></a>8.Spring Security</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Authentication（验证）、Authorization（授权）、OAuth2、JWT</p></blockquote>\n<ol>\n<li><p>SpringSecurity是一个强大的可高度定制的认证和授权框架，对于Spring应用来说它是一套Web安全标准</p>\n<ul>\n<li><p>DelegatingFilterProxy：将Filter委托给实现了Filter接口的Bean来处理</p>\n<ul>\n<li><p><code>FilterChain</code>：一个客户端向应用发送一个request，会经过一系列的Filter组成的FilterChain，最后交由Servlet来处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#123;\n\t&#x2F;&#x2F; do something before the rest of the application\n    chain.doFilter(request, response); &#x2F;&#x2F; invoke the rest of the application\n    &#x2F;&#x2F; do something after the rest of the application\n&#125;</code></pre></li>\n<li><p><code>DelegatingFilterProxy</code>：桥接Servlet container的生命周期和Spring的ApplicationContext，<code>DelegatingFilterProxy</code>能被通过标准servlet container机制来注册，但是将所有工作委托给Filter的Spring Bean，<code>FilterChainProxy</code>被包装在<code>DelegatingFilterProxy</code>中，来链接进Servlet container filter chain</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &#123;\n\t&#x2F;&#x2F; Lazily get Filter that was registered as a Spring Bean\n\t&#x2F;&#x2F; For the example in DelegatingFilterProxy delegate is an instance of Bean Filter0\n\tFilter delegate &#x3D; getFilterBean(someBeanName);\n\t&#x2F;&#x2F; delegate work to the Spring Bean\n\tdelegate.doFilter(request, response);\n&#125;</code></pre></li>\n<li><p><code>FilterChainProxy</code>是Spring Security提供的一个特殊的Filter，将Filter实例委托给<code>SecurityFilterChain</code>，通过内部的一个链表<code>filterChains</code>，来遍历（<code>doFilterInternal</code>中的<code>doFilter</code>方法）确定哪个Spring Security Filter应该被调用（在调试的时候，可以在<code>FilterChainProxy</code>加一个断点，来看所有Spring Security的Servlet）</p>\n<ul>\n<li>The <code>WebSecurity</code> is created by <code>WebSecurityConfiguration</code> to create the <code>FilterChainProxy</code> known as the Spring Security Filter Chain (<code>springSecurityFilterChain</code>).</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731102237924.png\" alt=\"image-20230731102237924\"></p>\n</li>\n<li><p>常见Filter顺序如下</p>\n<ul>\n<li>UsernamePasswordAuthenticationFilter（AbstractAuthenticationProcessingFilter）</li>\n<li>BasicAuthenticationFilter</li>\n<li>ExceptionTranslationFIlter（处理异常）</li>\n<li>FilterSecurityInterceptor</li>\n</ul>\n</li>\n<li><p>处理安全异常（未授权通过的抛出异常）</p>\n<ul>\n<li><p>The <code>ExceptionTranslationFilter</code> allows translation of <code>AccessDeniedException</code> and <code>AuthenticationException</code> into HTTP responses.（检查抛出的异常是否有<code>AccessDeniedException</code>类型的异常）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void sendStartAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain,\n\t\t\tAuthenticationException reason) throws ServletException, IOException &#123;\n\t\t&#x2F;&#x2F; SEC-112: Clear the SecurityContextHolder&#39;s Authentication, as the\n\t\t&#x2F;&#x2F; existing Authentication is no longer considered valid\n\t\tSecurityContext context &#x3D; SecurityContextHolder.createEmptyContext();\n\t\tSecurityContextHolder.setContext(context);\n\t\t&#x2F;&#x2F;保存HttpServletRequest，用来在授权成功时replay最初的request\n\t\tthis.requestCache.saveRequest(request, response);\n\t\t&#x2F;&#x2F;启动（commence）身份验证方案\n\t\t&#x2F;&#x2F;一般authenticationEntryPoint是LoginUrlAuthenticationEntryPoint的实例\n\t\tthis.authenticationEntryPoint.commence(request, response, reason);\n\t&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UsernamePasswordAuthenticationFilter</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731102301598.png\" alt=\"image-20230731102301598\"></p>\n<ul>\n<li><p>通过<code>attemptAuthentication</code>方法来返回<code>Authentication</code>对象</p>\n<ul>\n<li>从<code>request</code>创造出一个<code>Authentication</code></li>\n<li>通过username和password来生成一个token传递给request，再使用<code>ProviderManager</code>来看是否授权成功，并返回<code>Authentication</code>对象</li>\n</ul>\n</li>\n<li><p>ProviderManager：通过构建一个<code>AuthenticationProvider</code>链表，来看哪个Provider（或<code>ProviderManager</code>的父类）能处理这个<code>authentication</code></p>\n</li>\n<li><p><code>Authentication</code>对象：保存在<code>SecurityContextHolder</code>的<code>SecurityContext</code>中</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731102320717.png\" alt=\"image-20230731102320717\"></p>\n</li>\n</ul>\n</li>\n<li><p>Authorization（授权）</p>\n<ul>\n<li>所有Authorization存储在<code>GrantedAuthority</code>对象链表，代表已授权的对象。<code>GrantedAuthority</code>对象由<code>AuthenticationManager</code>插入到<code>Authorization</code>对象中，由<code>AuthorizationManager</code>读取来做出授权决策</li>\n<li>Spring Security包括一个具体的<code>GrantedAuthority</code>实现<code>SimpleGrantedAuthority</code>，允许将任何用户定义的String转换成一个<code>GrantedAuthority</code></li>\n<li><code>AccessDecisionManager</code>：Spring Security提供拦截器来控制对安全对象（方法调用或web请求）的访问，<code>AccessDecisionManager</code>在调用发生前决定是否允许调用（取代了<code>AccessDecisionManager</code> 和 <code>AccessDecisionVoter</code>）</li>\n<li>AuthorizationFilter有一个AuthorizationManager链表，每一个AuthorizationManager有两个方法<ul>\n<li>verify：做决定，调用check方法检查返回值，来看是否授权</li>\n<li>check：传递做授权所需的所有消息</li>\n</ul>\n</li>\n<li>AuthorizationManager的实现<ul>\n<li><code>RequestMatcherDelegatingAuthorizationManager</code>：匹配Request到最适合的<code>AuthorizationManager</code>进行处理</li>\n<li><code>AuthorityAuthorizationManager</code>：配置了一组给定authorities来找到当前的Authentication</li>\n<li><code>AuthenticatedAuthorizationManager</code>：用来区分anonymous、full-authenticated、remember-me的用户</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JWT是JSON WEB TOKEN的缩写，它是基于 RFC 7519 标准定义的一种可以安全传输的的JSON对象，由于使用了数字签名，所以是可信任和安全的</p>\n<ul>\n<li><p>MD5是不安全的</p>\n</li>\n<li><p>JWT的格式：header.payload.signature</p>\n<ul>\n<li><p>header中用于存放签名的生成算法，如：<code>&#123;&quot;alg&quot;: &quot;HS512&quot;&#125;</code></p>\n</li>\n<li><p>payload中用于存放用户名、token的生成时间和过期时间，如：<code>&#123;&quot;sub&quot;:&quot;admin&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125;</code></p>\n</li>\n<li><p>signature是以header和payload生成的签名，用来检测header和payload是否被篡改</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String signature &#x3D; HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret)</code></pre></li>\n</ul>\n</li>\n<li><p>实现认证和授权的原理</p>\n<ul>\n<li>用户调用登陆接口，登录成功后获取JWT的token（原来是Cookie）</li>\n<li>之后用户每次调用接口都在http的header中添加一个<code>Authorization</code>头，值为JWT的token</li>\n<li>后台程序通过对<code>Authorization</code>头中的信息的解码姐数字签名的校验来获取其中的用户信息，从而实现认证和授权</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>OAuth2</p>\n<p>- </p>\n</li>\n</ol>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ol>\n<li><p>源码知识点</p>\n<ul>\n<li>Bean解析流程</li>\n<li>BeanFactory</li>\n<li>FactoryBean</li>\n<li>ApplicationContext</li>\n<li>IOC</li>\n<li>Bean生命周期</li>\n<li>AOP</li>\n</ul>\n</li>\n<li><p>Spring给我们提供了很多扩展点</p>\n<ol>\n<li>BeanFactoryPostProcessor：允许在Spring容器实例化bean之前修改bean的定义。常用于修改bean属性或改变bean的作用域。</li>\n<li>BeanPostProcessor：可以在bean实例化、配置以及初始化之后对其进行额外处理。常用于代理bean、修改bean属性等。</li>\n<li>PropertySource：用于定义不同的属性源，如文件、数据库等，以便在Spring应用中使用。</li>\n<li>ImportSelector和ImportBeanDefinitionRegistrar：用于根据条件动态注册bean定义，实现配置类的模块化。</li>\n<li>Spring MVC中的HandlerInterceptor：用于拦截处理请求，可以在请求处理前、处理中和处理后执行特定逻辑。</li>\n<li>Spring MVC中的ControllerAdvice：用于全局处理控制器的异常、数据绑定和数据校验。</li>\n<li>Spring Boot的自动配置：通过创建自定义的自动配置类，可以实现对框架和第三方库的自动配置。</li>\n<li>自定义注解：创建自定义注解，用于实现特定功能或约定，如权限控制、日志记录等。</li>\n</ol>\n</li>\n<li><p>如果让你设计一个SpringIoc，你觉得会从哪些方面考虑这个设计？</p>\n<ol>\n<li>Bean的生命周期管理：需要设计Bean的创建、初始化、销毁等生命周期管理机制，可以考虑使用工厂模式和单例模式来实现。</li>\n<li>依赖注入：需要实现依赖注入的功能，包括属性注入、构造函数注入、方法注入等，可以考虑使用反射机制和XML配置文件来实现。</li>\n<li>Bean的作用域：需要支持多种Bean作用域，比如单例、原型、会话、请求等，可以考虑使用Map来存储不同作用域的Bean实例。</li>\n<li>AOP功能的支持：需要支持AOP功能，可以考虑使用动态代理机制和切面编程来实现。</li>\n<li>异常处理：需要考虑异常处理机制，包括Bean创建异常、依赖注入异常等，可以考虑使用try-catch机制来处理异常。</li>\n<li>配置文件加载：需要支持从不同的配置文件中加载Bean的相关信息，可以考虑使用XML、注解或者Java配置类来实现。</li>\n</ol>\n</li>\n<li><p>源码核心技术点</p>\n<ul>\n<li>Spring IOC：Bean生命周期、依赖自动注入</li>\n<li>Spring AOP：AOP源码、事务源码</li>\n<li>Spring后置处理器</li>\n<li>Spring循环依赖</li>\n<li>@Configuration、@Bean注解底层原理</li>\n<li>SpringBoot：底层源码、factories扩展机制、自动配置类、过滤机制、启动过程、第三方starter机制</li>\n</ul>\n</li>\n<li><p>循环依赖</p>\n<ul>\n<li><p>循环依赖</p>\n<ul>\n<li><p>概念</p>\n<ul>\n<li>BeanDefinition：Spring核心bean的配置信息，通过扫描注解（<code>@Compoent</code>、<code>@Service</code>、<code>@Configuration</code>）把需要的bean初始化为BeanDefinition的列表</li>\n<li>SpringBean：Spring管理的已经创建好的以后可以使用的实例</li>\n<li>Java Bean：Java通过构造函数创建的对象，Spring推断构造方法后使用反射调用构造函数创建的对象</li>\n</ul>\n</li>\n<li><p>产生原因：在框架启动时会进行bean的加载</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731103026621.png\" alt=\"image-20230731103026621\"></p>\n</li>\n<li><p>出现场景</p>\n<ul>\n<li>构造器内的循环依赖</li>\n<li>setter方式单例</li>\n<li>setter方式原型</li>\n<li>field属性循环依赖</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Spring如何解决</p>\n<ul>\n<li><p>三级缓存解决循环依赖</p>\n<ul>\n<li><p>一级缓存：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final Map&lt;String, Object&gt; singletonObjects &#x3D; new ConcurrentHashMap&lt;&gt;(256);</code></pre>\n\n<ul>\n<li>最基础的单例缓存，限制Bean在beanFactory中只存一份，即实现singleton scope</li>\n</ul>\n</li>\n<li><p>二级缓存：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">private final Map&lt;String, Object&gt; earlySingletonObjects &#x3D; new HashMap&lt;&gt;(16);</code></pre>\n\n<ul>\n<li>未初始化未填充属性提前暴露的bean</li>\n<li>当调用三级缓存里的对象工厂的getObject方法之后，getEarlyBeanReference 就会把返回值放入二级缓存，删除三级缓存，后续其他依赖该对象的Bean获取的都是同一个earlyBean，保证singleton原则</li>\n</ul>\n</li>\n<li><p>三级缓存：<code>private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16);</code></p>\n</li>\n</ul>\n</li>\n<li><p>AOP循环依赖</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SpringBootStarter的原理是什么，怎么使用的</p>\n</li>\n</ol>\n","text":"Spring Spring框架是一个开源的Java应用程序框架，用于简化企业级Java应用程序的开发。它提供了广泛的基础设施支持，包括依赖注入（Dependency Injection）、面向切面编程（Aspect-Oriented Programming）、事务管理、数据访问、...","link":"","photos":[],"count_time":{"symbolsCount":"104k","symbolsTime":"1:35"},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Spring\"><span class=\"toc-text\">Spring</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-IOC\"><span class=\"toc-text\">1.IOC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">1.基础知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">2.设计模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.原理及源码分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-AOP\"><span class=\"toc-text\">2.AOP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-1\"><span class=\"toc-text\">1.基础知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1\"><span class=\"toc-text\">2.设计模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1\"><span class=\"toc-text\">3.原理及源码分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Data-Access\"><span class=\"toc-text\">3.Data Access</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Transaction-Management\"><span class=\"toc-text\">1.Transaction Management</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-JDBC\"><span class=\"toc-text\">2.JDBC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-O-R-Mapping%EF%BC%88MyBatis%EF%BC%89\"><span class=\"toc-text\">3.O&#x2F;R Mapping（MyBatis）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-MVC\"><span class=\"toc-text\">4.MVC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2\"><span class=\"toc-text\">1.基础知识</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.原理及源码分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-Testing\"><span class=\"toc-text\">5.Testing</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-MyBatis\"><span class=\"toc-text\">6.MyBatis</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2\"><span class=\"toc-text\">2.设计模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\"><span class=\"toc-text\">3.原理分析</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-Spring-Boot\"><span class=\"toc-text\">7.Spring Boot</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Annotation\"><span class=\"toc-text\">1.Annotation</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-AutoConfiguration\"><span class=\"toc-text\">2.AutoConfiguration</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-SpringApplication\"><span class=\"toc-text\">3.SpringApplication</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-SpringBootStarters\"><span class=\"toc-text\">4.SpringBootStarters</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-Actuators\"><span class=\"toc-text\">5.Actuators</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-Spring-Security\"><span class=\"toc-text\">8.Spring Security</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95\"><span class=\"toc-text\">附录</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Linux","uid":"3fe1ee3f3830128bf539e5f4ed9fbbe9","slug":"Linux","date":"2023-05-11T11:26:21.000Z","updated":"2023-09-24T08:47:53.012Z","comments":true,"path":"api/articles/Linux.json","keywords":null,"cover":[],"text":"Linux1.进程管理 概念 fd在系统中有限制吗？可以无限申请吗：通过ulimit -n来显示当前进程的文件描述符限制数量，通过编辑或创建/etc/security/limits.conf文件来调整文件描述符限制，不可以无限申请而是需要满足系统资源限制 进程：进程是资源调度的基...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Redis","uid":"a978a5e93d8e6628e9f4ee713be55be8","slug":"Redis","date":"2023-05-04T10:00:34.000Z","updated":"2023-09-25T02:35:52.397Z","comments":true,"path":"api/articles/Redis.json","keywords":null,"cover":[],"text":"Redis Redis是一个高性能（内存+Reactor+优化的数据结构）的开源键值数据库，其value支持丰富的数据类型（string、hash、set、list、zset「有序集合」），具有数据可持久化（AOF+RDB）、支持master-slave备份、读写性能高（MySQ...","link":"","photos":[],"count_time":{"symbolsCount":"46k","symbolsTime":"42 mins."},"categories":[],"tags":[{"name":"database","slug":"database","count":2,"path":"api/tags/database.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}