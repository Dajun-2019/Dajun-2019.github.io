{"title":"DataStructure","uid":"d8c28dc067d04110f6447cc712799b2d","slug":"DataStructure","date":"2023-04-01T04:25:03.000Z","updated":"2023-06-14T02:13:57.722Z","comments":true,"path":"api/articles/DataStructure.json","keywords":null,"cover":null,"content":"<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"1-数据结构\"><a href=\"#1-数据结构\" class=\"headerlink\" title=\"1.数据结构\"></a>1.数据结构</h2><h3 id=\"1-1常用方法\"><a href=\"#1-1常用方法\" class=\"headerlink\" title=\"1.1常用方法\"></a>1.1常用方法</h3><table>\n<thead>\n<tr>\n<th>接口</th>\n<th>API</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Collection</td>\n<td>size、isEmpty、contains、toArray、add、remove、clear</td>\n</tr>\n<tr>\n<td>List</td>\n<td>get(index)、set(index)、add(index,element)、remove(index)、indexOf()、lastIndexOf()、subList(from, to)、sort</td>\n</tr>\n<tr>\n<td>Queue</td>\n<td>offer(element)、poll()、peek()</td>\n</tr>\n<tr>\n<td>Duque</td>\n<td>offerFirst(E e)、offerLast(E e)、pollFirst()、pollLast()、peekFirst()、peekLast()、push(E e)、pop()</td>\n</tr>\n<tr>\n<td>Set</td>\n<td>size、isEmpty、contains、toArray、add、remove</td>\n</tr>\n<tr>\n<td>SortedSet</td>\n<td>SortedSet<E> subSet(E fromElement, E toElement)、headSet(E toElement)、tailSet(E fromElement)、first、last</td>\n</tr>\n<tr>\n<td>Map</td>\n<td>size、isEmpty、containsKey、containsValue、get、put、remove、keySet、values、entrySet</td>\n</tr>\n<tr>\n<td>Map补</td>\n<td>getOrDefault(Object key, V defaultValue)、putIfAbsent(K key, V value)、replace(K key, V oldValue, V newValue)</td>\n</tr>\n</tbody></table>\n<h3 id=\"1-2工具类\"><a href=\"#1-2工具类\" class=\"headerlink\" title=\"1.2工具类\"></a>1.2工具类</h3><table>\n<thead>\n<tr>\n<th>类名</th>\n<th>API</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>String</td>\n<td>charAt、toCharArray、split、substring（新String）、indexOf、lastIndexOf、replace、length</td>\n</tr>\n<tr>\n<td>String补</td>\n<td>trim、toLowerCase、toUpperCase、split(String regex)、format（格式化输出，同c）</td>\n</tr>\n<tr>\n<td>StringBuilder</td>\n<td>append、toString、charAt、length、delete、replace、insert、reverse、indexOf、lastIndexOf</td>\n</tr>\n<tr>\n<td>Collections</td>\n<td>sort（list）、binarySearch、reverse、swap、fill、copy、replaceAll、emptyXXX</td>\n</tr>\n<tr>\n<td>Arrays</td>\n<td>sort、binarySearch、equals、fill、asList、copyOf、copyOfRange</td>\n</tr>\n<tr>\n<td>Math</td>\n<td>min、max、abs、sqrt(double)、pow(double, double)、ceil（上整）、floor（下整）、round（四舍五入）</td>\n</tr>\n<tr>\n<td>Math补</td>\n<td>Integer.MAX_VALUE、Integer.MIN_VALUE、</td>\n</tr>\n<tr>\n<td>Scanner</td>\n<td>next（下一String）、nextInt、nextLong、nextLine（nextInt不会洗掉换行符，需要nextLine吸掉）</td>\n</tr>\n<tr>\n<td>System.out</td>\n<td>println、print、format(“x = %d, y = %f\\n”, x, y)</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>简化代码：输入一串数字组成的字符</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 1 2 3 4 5...\nint[] nums&#x3D;Arrays.stream(scanner.nextLine().split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray();</code></pre></li>\n</ul>\n<h3 id=\"1-3补充知识\"><a href=\"#1-3补充知识\" class=\"headerlink\" title=\"1.3补充知识\"></a>1.3补充知识</h3><ol>\n<li><p>ArrayList</p>\n<ul>\n<li><p>实现特殊接口</p>\n<ul>\n<li>RandomAccess：<code>Arrays</code>的静态方法<code>binarySearch</code>会根据接口调用不同的实现方法</li>\n<li>Cloneable：使用<code>clone</code>方法，返回一个浅拷贝</li>\n</ul>\n</li>\n<li><p>底层为可动态扩容的数组（支持存储null数据）</p>\n<ul>\n<li><p>首先==确定最小扩容量==，默认最小为10，如果传入的所需容量比10大，则按传入的所需容量来扩容</p>\n</li>\n<li><p>然后==判断是否需要扩容==，如果前一阶段判定的需要容量比内部数组的长度大，则进行扩容</p>\n</li>\n<li><p>使用位移操作，将容量扩展为内部数组长度的1.5倍，如果比需要容量小，则直接使用需要容量，防止多次扩容，然后使用<code>System.arraycopy</code>来复制数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static native void arraycopy(Object src,  int  srcPos,Object dest, int destPos,int length);</code></pre></li>\n</ul>\n</li>\n<li><p>使用<code>modCount</code>：来记录容量更改的次数，每次调用<code>ensureCapacityInternal</code>就将<code>modCount</code>加1，容量不够使才改容量。用来确定迭代的过程中，是否有其他线程更改过数据，如果有人修改过，则抛出<code>ConcurrentModificationException</code>异常</p>\n</li>\n</ul>\n</li>\n<li><p>LinkedList</p>\n<ul>\n<li>可以根据引用的接口不同，使用不同方法，支持List、Queue、Deque，根据结构的不同可以调用不同的方法</li>\n<li>底层为双向链表，并且有头尾指针，支持存储null数据</li>\n</ul>\n</li>\n<li><p>ArrayDeque</p>\n<ul>\n<li>基于数组实现，性能比LinkedList好，也可用来实现栈</li>\n</ul>\n</li>\n<li><p>PriorityQueue</p>\n<ul>\n<li><p>底层依赖堆来实现（使用可变长数组），默认情况下为小顶堆，最先出队列的为当前队列中的最小值，支持Comparator接口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Queue&lt;Integer&gt; minH &#x3D; new PriorityQueue&lt;&gt;(); &#x2F;&#x2F;小顶堆，默认大小为11\nQueue&lt;Integer&gt; maxH &#x3D; new PriorityQueue&lt;&gt;((i1, i2) -&gt; i2 - i1); &#x2F;&#x2F;大顶堆，默认大小为11</code></pre></li>\n<li><p>不支持存储NULL和non-comparable对象，通过堆元素的上浮和下沉，实现了在<code>O(logn)</code>的时间复杂度内插入和删除堆顶元素</p>\n</li>\n<li><p>堆的构建过程，需要比较节点中数据的大小，所以，添加到优先级队列中的元素，需要能够比较大小，方法有两种：基于Comparable接口和基于Comparator接口，都有时则优先使用comparator，详见<code>siftUp</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void siftUp(int k, E x) &#123;\n    if (comparator !&#x3D; null)\n        siftUpUsingComparator(k, x);\n    else\n        siftUpComparable(k, x);\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>Set（HashSet、LinkedHashSet、TreeSet）</p>\n<ul>\n<li>底层实现分别为：HashMap、LinkedHashMap、TreeMap，存储对象的时候，使用对象作为key，一个空的Object对象作为value，插入到底层的Map中，不管</li>\n<li>如何检查重复：无论Set中是否已经存在了某元素，都会直接在底层进行插入，通过add方法的返回值来确定插入前是否有相同的元素</li>\n<li>应用场景：HashSet用于==不需要保证元素插入和取出顺序==的场景；LinkedHashSet用于==保证元素的插入和取出顺序满足FIFO==的场景（LinedHashMap底层使用双向有序链表+哈希表）；TreeSet用于支持对元素==自定义排序规则==的场景</li>\n</ul>\n</li>\n<li><p>HashMap（==数组+链表/红黑树==）</p>\n<ul>\n<li>底层为哈希表，对key求哈希作为hash值，包裹hash值、key和value为Node对象，作为哈希表（数组+链表）的组成节点。key不能重复，存储重复的key，新value会覆盖旧value（可以存一个key为null的键值对，但是不同key的value都可以是null）</li>\n<li>底层数组长度为2的倍数：hash函数可以使用与n-1取交替代与n取余、装载因子使用0.75使得阈值（n*0.75）一直为整数、初始化的时候选择比传入参数大的最小2的幂次方数</li>\n<li>动态扩容：默认初始化大小为16，每次超过阈值的时候就扩容为原来的2倍；扫描数组的每一条链表，根据节点下标决定是否要更改，插入到lo链表（不需改）和hi链表（需要改），处理完一条链表，将新链表插入到对应位置<ul>\n<li>新位置确定方式：如果node.hash&amp;oldCap == 0，则节点在新table数组中的下标不变；如果node.hash &amp; oldCap != 0，则节点在新table数组中的下标变为i+oldCap（i为在原数组的下标）</li>\n<li>链表树化：当某个链表中的节点个数大于等于8（TREEIFY_THRESHOLD静态常量），并且table数组的长度大于等于64时，将会把链表转化为红黑树；如果table长度不满足则触发扩容操作；如果红黑树节点数在[2，6]之间，则退化为链表</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Arrays的sort</p>\n<ul>\n<li>Collections的sort函数底层依赖的Arrays类的sort函数，如List接口中的sort的默认实现</li>\n<li>基本类型：使用==DualPivotQuickSort==，jdk7之前使用快排<ul>\n<li>对快排进行改进，选取两个pivot，通过数组的长度决定什么时候选用双轴快排、插入排序、归并排序、记数排序</li>\n</ul>\n</li>\n<li>对象数组：使用==TimSort==，jdk7之前使用归并<ul>\n<li>使用非递归版本归并排序算法，在归并排序的过程中，大的排序区间不断分解为小的待排序区间，如果带排序区间的长度小于MIN_MERGE（32），就不再继续分解，转而执行二分插入排序算法</li>\n<li>二分插入排序：将数组分为已排序区间和未排序区间，通过二分查找，查找插入位置，当找到后，通过调用System.arraycopy()函数，将插入点之后的数据整体快速后移一位，腾出位置给要插入的数据</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>String（final数组）</p>\n<ul>\n<li>String不可变的原因：内部是final修饰的数组（引用不可改但是数据可改）、没有提供更改数组的方法、String类也是final的子类无法继承，避免了子类破坏String的不变性</li>\n<li>常量池技术：使用字符串常量赋值时触发，直接复用常量池已存在的对象，也可以使用intern方法复制堆上对象到常量池并回收堆上的对象（判等的时候使用<code>equals()</code>）</li>\n<li>运算符重载：因为String比较常用，所以延续了基本类型和包装类的设计，实现了加法操作<code>String sc = sa + sb;</code>，底层使用了StringBuilder来实现（StringBuffer加了锁，是线程安全的）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-算法\"><a href=\"#2-算法\" class=\"headerlink\" title=\"2.算法\"></a>2.算法</h2><h3 id=\"2-1复杂度分析\"><a href=\"#2-1复杂度分析\" class=\"headerlink\" title=\"2.1复杂度分析\"></a>2.1复杂度分析</h3><ol>\n<li>分析方法<ul>\n<li>加法原则：总复杂度等于量级最大的那段代码的复杂度</li>\n<li>乘法原则：嵌套代码的复杂度等于嵌套内外的代码复杂度乘积</li>\n<li>其他方法：某一条语句执行的总次数；数据被访问的次数；使用递归树来分析</li>\n</ul>\n</li>\n<li>空间复杂度<ul>\n<li>不关注存储数据所需要的空间，而是关注算法所需要的额外存储消耗（循环、递归调用栈、辅助存储）</li>\n<li>由于现有题型大多以耗时为指标，所以尽可能使用==以空间换时间==的思想</li>\n</ul>\n</li>\n<li>时间复杂度<ul>\n<li>不看低阶和常数系数、加法取大、乘法取积</li>\n<li>分类：最好、最坏、平均</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-2技巧\"><a href=\"#2-2技巧\" class=\"headerlink\" title=\"2.2技巧\"></a>2.2技巧</h3><ol>\n<li><p>双指针</p>\n</li>\n<li><p>前缀和数组：原始数组不会被修改的情况下，频繁查询某个区间的累加和</p>\n</li>\n</ol>\n<ul>\n<li>前缀和数组中两个元素的差，及这段区间的累加和</li>\n<li>示例：原数组{3,5,2,-1,4,1}；前缀和数组{0,3,8,10,8,12,13}</li>\n</ul>\n<ol start=\"3\">\n<li>差分数组：频繁对原数组的某个区间的元素进行增减</li>\n</ol>\n<ul>\n<li>原理：对i→n的所有元素都加3，对j+1→n的所有元素都减3</li>\n<li>示例：原数组{8,2,6,3,1}；差分数组{8,-6,4,-3,-2}</li>\n</ul>\n<ol start=\"4\">\n<li>单调栈：满足单调性的栈结构</li>\n</ol>\n<ul>\n<li><p>插入过程：将一个元素插入单调栈时，为了维护栈的单调性，需要先弹出一些元素直到新插入的元素可以不破坏单调性</p>\n</li>\n<li><p>伪代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">insert x\nwhile !sta.empty() &amp;&amp; sta.top()&lt;x\n    sta.pop()\nsta.push(x)</code></pre></li>\n</ul>\n<ol start=\"5\">\n<li><p>并查集（Union-Find）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class UF &#123;\n    &#x2F;&#x2F; 连通分量个数\n    private int count;\n    &#x2F;&#x2F; 存储每个节点的父节点\n    private int[] parent;\n\n    &#x2F;&#x2F; n 为图中节点的个数\n    public UF(int n) &#123;\n        this.count &#x3D; n;\n        parent &#x3D; new int[n];\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            parent[i] &#x3D; i;\n        &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 将节点 p 和节点 q 连通\n    public void union(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        \n        if (rootP &#x3D;&#x3D; rootQ)\n            return;\n        \n        parent[rootQ] &#x3D; rootP;\n        &#x2F;&#x2F; 两个连通分量合并成一个连通分量\n        count--;\n    &#125;\n\n    &#x2F;&#x2F; 判断节点 p 和节点 q 是否连通\n    public boolean connected(int p, int q) &#123;\n        int rootP &#x3D; find(p);\n        int rootQ &#x3D; find(q);\n        return rootP &#x3D;&#x3D; rootQ;\n    &#125;\n\n    public int find(int x) &#123;\n        if (parent[x] !&#x3D; x) &#123;\n            parent[x] &#x3D; find(parent[x]);\n        &#125;\n        return parent[x];\n    &#125;\n\n    &#x2F;&#x2F; 返回图中的连通分量个数\n    public int count() &#123;\n        return count;\n    &#125;\n&#125;</code></pre></li>\n<li><p>快速幂：为了在O(logn)的时间内计算a^n的技巧</p>\n<ul>\n<li><p>理论依据：a^(b+c) = a^b * a^c，与二分查找思想结合可以得出a^(2b) =a^b * a^b =  (a^b) ^2</p>\n</li>\n<li><p>代码实现</p>\n<ul>\n<li><p>递归</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long binpow(long a,long b)&#123;\n  if(b &#x3D;&#x3D; 0)&#123;\n    return 1;\n  &#125;\n  long res &#x3D; binpow(a, b&#x2F;2);\n  if(b % 2 &#x3D;&#x3D; 1)&#123;\n    return res * res * a; &#x2F;&#x2F;奇数次幂\n  &#125;else&#123;\n    return res * res; &#x2F;&#x2F;偶数次幂\n  &#125;\n&#125;</code></pre></li>\n<li><p>非递归</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long binpow(long a, long b)&#123;\n  long res &#x3D; 1;\n  while(b &gt; 0)&#123;\n    if((b &amp; 1) &#x3D;&#x3D; 1)&#123; &#x2F;&#x2F;当前位为1，则需要乘二进制幂，否则跳过此次\n      res &#x3D; res * a;\n    &#125;\n    a &#x3D; a*a;\n    b &gt;&gt;&#x3D; 1;\n  &#125;\n  return res;\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p>应用</p>\n<ul>\n<li><p>计算 (x^n) mod m：取模运算不会干涉乘法，所以计算过程中直接取模就行</p>\n<ul>\n<li>另：根据费马小定理，如果m是一个质数，可以计算x^(n mod (m-1) )来加速算法过程</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long binpow(long a, long b, long m)&#123;\n  a %&#x3D; m;\n  long res &#x3D; 1;\n  while(b &gt; 0)&#123;\n    if((b &amp; 1) &#x3D;&#x3D; 1)&#123;\n      res &#x3D; res * a % m;\n    &#125;\n    a &#x3D; a * a % m;\n    b &gt;&gt;&#x3D; 1;\n  &#125;\n  return res;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>线段树</p>\n<ul>\n<li><p>目的：用来维护区间信息的数据结构，可以在O(logN)的时间复杂度内实现单点修改、区间修改、区间查询（区间求和、求区间最大值、求区间最小值）等操作</p>\n</li>\n<li><p>基本结构</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 对区间[s,t]递归建树\n&#x2F;&#x2F; int[] d &#x3D; new int[n*4];\nvoid build(int s, int t, int p)&#123;\n  if(s &#x3D;&#x3D; t)&#123;\n    d[p] &#x3D; a[s];\n    return;\n  &#125;\n  int m &#x3D; s + ((t - s) &gt;&gt; 1);\n  build(s,m,p*2);\n  build(m+1,t,p*2+1);\n  &#x2F;&#x2F;从下向上递归建树\n  d[p] &#x3D; d[p*2] + d[p*2+1];\n&#125;</code></pre></li>\n<li><p>区间查询</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int getSum(int l, int r, int s, int t, int p)&#123;\n  &#x2F;&#x2F;[l,r]为查询区间，[s,t]为当前节点包含的区间，p为当前节点的编号\n  if(l &lt;&#x3D; s &amp;&amp; t &lt;&#x3D; r)&#123;\n    return d[p]; &#x2F;&#x2F;当前区间为查询区间的子集时直接返回当前节点的和\n  &#125;\n  int m &#x3D; s + ((t-s) &gt;&gt; 1);\n  int sum &#x3D; 0;\n  &#x2F;&#x2F;左儿子与查询区间有交集，递归查询左儿子\n  if(l &lt;&#x3D; m)&#123;\n    sum +&#x3D; getSum(l, r, s, m, p*2);\n  &#125;\n  &#x2F;&#x2F;右儿子与查询区间有交集，递归查询右儿子\n  if(r &gt; m)&#123;\n    sum +&#x3D; getSum(l, r, m+1, t, p*2+1);\n  &#125;\n  return sum;\n&#125;</code></pre></li>\n<li><p>区间修改（存在标记的情况）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void update(int l, int r, int c, int s, int t, int p)&#123;\n  &#x2F;&#x2F; [l, r] 为修改区间, c 为被修改的元素的变化量, [s, t] 为当前节点包含的区间, p为当前节点的编号\n  if(l &lt;&#x3D; s &amp;&amp;  t &lt;&#x3D; r)&#123;\n    d[p] +&#x3D; (t - s + 1) * c;\n    b[p] +&#x3D; c;\n    return;\n  &#125;\n  int m &#x3D; s + ((t - s) &gt;&gt; 1);\n  if (b[p] &amp;&amp; s !&#x3D; t) &#123;\n    &#x2F;&#x2F; 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值\n    d[p * 2] +&#x3D; b[p] * (m - s + 1);\n    d[p * 2 + 1] +&#x3D; b[p] * (t - m);\n    &#x2F;&#x2F; 将标记下传给子节点\n    b[p * 2] +&#x3D; b[p];\n    b[p * 2 + 1] +&#x3D; b[p];  \n    &#x2F;&#x2F; 清空当前节点的标记\n    b[p] &#x3D; 0;                                \n  &#125;\n  if (l &lt;&#x3D; m) &#123;\n    update(l, r, c, s, m, p * 2);\n  &#125;\n  if (r &gt; m) &#123;\n    update(l, r, c, m + 1, t, p * 2 + 1);\n  &#125;\n  d[p] &#x3D; d[p * 2] + d[p * 2 + 1];\n&#125;</code></pre></li>\n<li><p>区间求和（存在标记的情况）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int getsum(int l, int r, int s, int t, int p) &#123;\n  &#x2F;&#x2F; [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号\n  if (l &lt;&#x3D; s &amp;&amp; t &lt;&#x3D; r) return d[p];\n  &#x2F;&#x2F; 当前区间为询问区间的子集时直接返回当前区间的和\n  int m &#x3D; s + ((t - s) &gt;&gt; 1);\n  if (b[p]) &#123;\n    &#x2F;&#x2F; 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值\n    d[p * 2] +&#x3D; b[p] * (m - s + 1);\n    d[p * 2 + 1] +&#x3D; b[p] * (t - m);\n    &#x2F;&#x2F; 将标记下传给子节点\n    b[p * 2] +&#x3D; b[p];\n    b[p * 2 + 1] +&#x3D; b[p];  \n    &#x2F;&#x2F; 清空当前节点的标记\n    b[p] &#x3D; 0;                                \n  &#125;\n  int sum &#x3D; 0;\n  if (l &lt;&#x3D; m) sum &#x3D; getsum(l, r, s, m, p * 2);\n  if (r &gt; m) sum +&#x3D; getsum(l, r, m + 1, t, p * 2 + 1);\n  return sum;\n&#125;</code></pre></li>\n<li><p>区间修改为某一个值而不是加上某一个值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void update(int l, int r, int c, int s, int t, int p) &#123;\n  if (l &lt;&#x3D; s &amp;&amp; t &lt;&#x3D; r) &#123;\n    d[p] &#x3D; (t - s + 1) * c, b[p] &#x3D; c;\n    return;\n  &#125;\n  int m &#x3D; s + ((t - s) &gt;&gt; 1);\n  &#x2F;&#x2F; 额外数组储存是否修改值\n  if (v[p]) &#123;\n    d[p * 2] &#x3D; b[p] * (m - s + 1), d[p * 2 + 1] &#x3D; b[p] * (t - m);\n    b[p * 2] &#x3D; b[p * 2 + 1] &#x3D; b[p];\n    v[p * 2] &#x3D; v[p * 2 + 1] &#x3D; 1;\n    v[p] &#x3D; 0;\n  &#125;\n  if (l &lt;&#x3D; m) update(l, r, c, s, m, p * 2);\n  if (r &gt; m) update(l, r, c, m + 1, t, p * 2 + 1);\n  d[p] &#x3D; d[p * 2] + d[p * 2 + 1];\n&#125;\n\nint getsum(int l, int r, int s, int t, int p) &#123;\n  if (l &lt;&#x3D; s &amp;&amp; t &lt;&#x3D; r) return d[p];\n  int m &#x3D; s + ((t - s) &gt;&gt; 1);\n  if (v[p]) &#123;\n    d[p * 2] &#x3D; b[p] * (m - s + 1), d[p * 2 + 1] &#x3D; b[p] * (t - m);\n    b[p * 2] &#x3D; b[p * 2 + 1] &#x3D; b[p];\n    v[p * 2] &#x3D; v[p * 2 + 1] &#x3D; 1;\n    v[p] &#x3D; 0;\n  &#125;\n  int sum &#x3D; 0;\n  if (l &lt;&#x3D; m) sum &#x3D; getsum(l, r, s, m, p * 2);\n  if (r &gt; m) sum +&#x3D; getsum(l, r, m + 1, t, p * 2 + 1);\n  return sum;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-3算法思想\"><a href=\"#2-3算法思想\" class=\"headerlink\" title=\"2.3算法思想\"></a>2.3算法思想</h3><ol>\n<li><p>排序</p>\n<ul>\n<li><p>基础排序算法</p>\n<ul>\n<li><p>O（n^2）</p>\n<ul>\n<li><p>冒泡排序：一对对比较，一对对交换</p>\n</li>\n<li><p>插入排序：分为已排和未排区间，取未排插入到已排。例：希尔排序</p>\n</li>\n<li><p>选择排序：分为已排和未排区间，从未排选一个最小的插入到已排的</p>\n</li>\n<li><p>希尔排序</p>\n</li>\n</ul>\n</li>\n<li><p>O（nlogn）</p>\n<ul>\n<li><p>归并排序：“分治思想”，分而治之，然后再合并</p>\n</li>\n<li><p>快速排序：选一个pivot，大的放左，小的放右</p>\n</li>\n<li><p>堆排序：先将数组原地建成一个堆，从下往上堆化，取堆顶元素，将下标n的元素放到堆顶，堆化</p>\n</li>\n<li><p>二叉排序树排序</p>\n</li>\n</ul>\n</li>\n<li><p>O（n）</p>\n<ul>\n<li><p>计数排序：例：10G数据，100个桶</p>\n</li>\n<li><p>基数排序：高考成绩排序，760个桶</p>\n</li>\n<li><p>桶排序：10万个手机号码排序，从个位开始一位位进行桶或基数排序</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>常见题型</p>\n<ul>\n<li>特殊排序：不是单纯的增减顺序，而是有一些特殊要求</li>\n<li>Top K：找到前K个大的，第K个大的……</li>\n<li>链表上的排序：数据结构由数组转换为链表，并进行排序</li>\n<li>排序预处理：排序只是问题的一部分预处理，可以运用库函数</li>\n<li>区间问题：（252题、56题） 先排序，再处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>二分查找：大部分都是变形二分查找或二分答案，代码不长，但容易写对。难点在于：确定搜索区间，循环条件，区间更新，返回值</p>\n<ul>\n<li><p>查找区间永远是闭区间[low,high]</p>\n</li>\n<li><p>循环条件永远是：low &lt;= high</p>\n</li>\n<li><p>对于low == high的情况，必要的时候特殊处理，在while内部补充退出条件</p>\n</li>\n<li><p>返回值永远是mid，而不是low，high</p>\n</li>\n<li><p>low、high的更新永远是low = mid + 1和high = mid - 1</p>\n</li>\n<li><p>对于非确定性查找，使用前后探测法，来确定搜索区间（不用while，而只更新low或high）</p>\n</li>\n<li><p>先处理命中情况，再处理在左右半部分查找的情况</p>\n</li>\n<li><p>非确定查找：第一个、最后一个、第一个大于等于、最后一个小于等于、循环数组寻找最小值、寻找峰值</p>\n</li>\n</ul>\n</li>\n<li><p>bfs</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 计算从起点 start 到终点 target 的最近距离\nint BFS(Node start, Node target) &#123;\n    Queue&lt;Node&gt; q; &#x2F;&#x2F; 核心数据结构\n    Set&lt;Node&gt; visited; &#x2F;&#x2F; 避免走回头路\n    \n    q.offer(start); &#x2F;&#x2F; 将起点加入队列\n    visited.add(start);\n    int step &#x3D; 0; &#x2F;&#x2F; 记录扩散的步数\n\n    while (q not empty) &#123;\n        int sz &#x3D; q.size();\n        &#x2F;* 将当前队列中的所有节点向四周扩散 *&#x2F;\n        for (int i &#x3D; 0; i &lt; sz; i++) &#123;\n            Node cur &#x3D; q.poll();\n            &#x2F;* 划重点：这里判断是否到达终点 *&#x2F;\n            if (cur is target)\n                return step;\n            &#x2F;* 将 cur 的相邻节点加入队列 *&#x2F;\n            for (Node x : cur.adj()) &#123;\n                if (x not in visited) &#123;\n                    q.offer(x);\n                    visited.add(x);\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;* 划重点：更新步数在这里 *&#x2F;\n        step++;\n    &#125;\n&#125;</code></pre></li>\n<li><p>dfs</p>\n<ul>\n<li><p>递归</p>\n<ul>\n<li><p>代码技巧：千万不要试图想清楚整个递和归的执行过程，实际上是进入了一个思维误区</p>\n<ul>\n<li><p>怎么发现这个问题可以用递归来做：</p>\n<ul>\n<li><p>规模更小的问题，跟规模大点的问题，解决思路相同，但规模不同</p>\n</li>\n<li><p>利用子问题的解可以组合得到原问题的解</p>\n</li>\n<li><p>存在最小子问题，可以直接返回结果，即存在递归终止条件</p>\n</li>\n</ul>\n</li>\n<li><p>递归的正确编写姿势：</p>\n<ul>\n<li>我们可以假设子问题B,C已经解决，在此基础上思考如何解决原问题A，基于此，找递推公式+终止条件，然后翻译成代码</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>时间复杂度和空间复杂度分析：</p>\n<ul>\n<li>时间复杂度：递推公式或者递归树</li>\n<li>空间复杂度：跟递归的函数调用栈最大深度成正比，即递归树的高度</li>\n</ul>\n</li>\n<li><p>解题技巧：寻找重复结构，是否能将问题结构转化成结构相同，规模更小的子问题，然后写递推公式，包括递归终止条件，然后翻译成代码</p>\n<ul>\n<li><p>原问题解决思路和子问题解决思路是否一样</p>\n</li>\n<li><p>子问题的解能否构造出原问题的解（递推公式）</p>\n</li>\n<li><p>找到最小子问题（终止条件）</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>回溯：回溯是递归的副产品，只要有递归就会有回溯，本质就是穷举+剪枝</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">result &#x3D; []\ndef backtrack(路径, 选择列表):\n    if 满足结束条件:\n        result.add(路径)\n        return\n    \n    for 选择 in 选择列表:\n        做选择\n        backtrack(路径, 选择列表)\n        撤销选择</code></pre></li>\n<li><p>dfs</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public List&lt;Integer&gt; dfs(int s,int t)&#123;\n        List&lt;Integer&gt; path &#x3D; new ArrayList&lt;&gt;();\n        path.add(s);\n        visited[s] &#x3D; true;\n        dfs_backtrack(s,t,path);\n        return resultPath;\n    &#125;\n\n    public void dfs_backtrack(int s,int t,List&lt;Integer&gt; path)&#123;\n        &#x2F;&#x2F;结束条件\n        if (s &#x3D;&#x3D; t)&#123;\n            resultPath &#x3D; new ArrayList&lt;&gt;(path);\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; adj[s].size(); i++) &#123;\n            int q &#x3D; adj[s].get(i);\n            if (!visited[q])&#123;\n                path.add(q);\n                visited[q] &#x3D; true;\n                dfs_backtrack(q,t,path);\n                path.remove(path.size()-1);\n            &#125;\n        &#125;\n    &#125;</code></pre></li>\n</ul>\n</li>\n<li><p>dp</p>\n<ul>\n<li><p>解题步骤</p>\n<ul>\n<li>可用回溯解决：使用穷举结果才能得到结果的问题（最值、可行、计数等）</li>\n<li>构建多阶段决策模型：看是否能将问题求解的过程分为多个阶段</li>\n<li>查看是否存在重复子问题：是否有多个路径到达同一状态</li>\n<li>定义状态：也就是如何记录每一阶段的不重复状态</li>\n<li>定义状态转移方程：也就是找到如何通过上一阶段的状态推导下一阶段的状态</li>\n<li>画状态转移表：辅助理解，验证正确性，确定状态转移的初始值</li>\n</ul>\n</li>\n<li><p>代码结构</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"># 自顶向下递归的动态规划\ndef dp(状态1, 状态2, ...):\n    for 选择 in 所有可能的选择:\n        # 此时的状态已经因为做了选择而改变\n        result &#x3D; 求最值(result, dp(状态1, 状态2, ...))\n    return result\n\n# 自底向上迭代的动态规划\n# 初始化 base case\ndp[0][0][...] &#x3D; base case\n# 进行状态转移\nfor 状态1 in 状态1的所有取值：\n    for 状态2 in 状态2的所有取值：\n        for ...\n            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</code></pre></li>\n<li><p>0-1背包的最值、可行、计数</p>\n<ul>\n<li><p>最值1：有n个物品，选择其中一些物品装入背包，在不超过背包最大重量限制的前提下，背包中可装物品总重量的最大值是多少</p>\n</li>\n<li><p>最值2：有n个物品，选择其中一些物品装入背包，正好装满背包所需物品最小个数（如果装不满，返回-1）</p>\n</li>\n<li><p>可行：有n个物品，选择其中一些物品装入背包，能不能正好装满背包</p>\n</li>\n<li><p>计数：有n个物品，选择其中一些物品装入背包，装满背包有多少种不同的装法</p>\n</li>\n</ul>\n</li>\n<li><p>完全背包（同一个物品可装n次）的最值、可行、计数</p>\n<ul>\n<li>背包可装物品总重量的最大值是多少</li>\n<li>是否能装满整个背包</li>\n<li>正好装满背包至少需要多少物品</li>\n<li>装满背包有多少种装法</li>\n</ul>\n</li>\n<li><p>空间优化</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-经典代码\"><a href=\"#3-经典代码\" class=\"headerlink\" title=\"3.经典代码\"></a>3.经典代码</h2><h3 id=\"1-二叉树\"><a href=\"#1-二叉树\" class=\"headerlink\" title=\"1.二叉树\"></a>1.二叉树</h3><ol>\n<li><p>构建</p>\n<ul>\n<li><p>根据数组构建节点结构</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Solution &#123;\n    static class TreeNode &#123;\n        int val;\n        TreeNode left;\n        TreeNode right;\n        public TreeNode(int x) &#123;\n            this.val &#x3D; x;\n            this.left &#x3D; null;\n            this.right &#x3D; null;\n        &#125;\n    &#125;\n    \n    &#x2F;**\n     * 根据数组构建二叉树\n     * @param arr 树的数组表示\n     * @return 构建成功后树的根节点\n     *&#x2F;\n    public TreeNode constructBinaryTree(final int[] arr) &#123;\n        &#x2F;&#x2F; 构建和原数组相同的树节点列表\n        List&lt;TreeNode&gt; treeNodeList &#x3D; arr.length &gt; 0 ? new ArrayList&lt;&gt;(arr.length) : null;\n        TreeNode root &#x3D; null;\n        &#x2F;&#x2F; 把输入数值数组，先转化为二叉树节点列表\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; null;\n            if (arr[i] !&#x3D; -1) &#123; &#x2F;&#x2F; 用 -1 表示null\n                node &#x3D; new TreeNode(arr[i]);\n            &#125;\n            treeNodeList.add(node);\n            if (i &#x3D;&#x3D; 0) &#123;\n                root &#x3D; node;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 遍历一遍，根据规则左右孩子赋值就可以了\n        &#x2F;&#x2F; 注意这里 结束规则是 i * 2 + 1 &lt; arr.length，避免空指针\n        &#x2F;&#x2F; 为什么结束规则不能是i * 2 + 2 &lt; arr.length呢?\n        &#x2F;&#x2F; 如果i * 2 + 2 &lt; arr.length 是结束条件\n        &#x2F;&#x2F; 那么i * 2 + 1这个符合条件的节点就被忽略掉了\n        &#x2F;&#x2F; 例如[2,7,9,-1,1,9,6,-1,-1,10] 这样的一个二叉树,最后的10就会被忽略掉\n        for (int i &#x3D; 0; i * 2 + 1 &lt; arr.length; i++) &#123;\n            TreeNode node &#x3D; treeNodeList.get(i);\n            if (node !&#x3D; null) &#123;\n                &#x2F;&#x2F; 线性存储转连式存储关键逻辑\n                node.left &#x3D; treeNodeList.get(2 * i + 1);\n                &#x2F;&#x2F;  再次判断下 不忽略任何一个节点\n                if(i * 2 + 2 &lt; arr.length)\n                node.right &#x3D; treeNodeList.get(2 * i + 2);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n&#125;</code></pre></li>\n<li><p>直接构建邻接表</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nArrayList&lt;Integer&gt;[] adjs &#x3D; new ArrayList[n];\nfor(int i &#x3D; 0; adjs.size(); i++)&#123;\n  adjs[i] &#x3D; new ArrayList&lt;&gt;();\n&#125;\nfor(int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;\n  adjs[father].add(son);\n&#125;</code></pre></li>\n<li><p>图的构建</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 邻接表\n&#x2F;&#x2F; graph[x] 存储 x 的所有邻居节点\nList&lt;Integer&gt;[] graph;\n\n&#x2F;&#x2F; 邻接矩阵\n&#x2F;&#x2F; matrix[x][y] 记录 x 是否有一条指向 y 的边\nboolean[][] matrix;</code></pre></li>\n</ul>\n</li>\n<li><p>递归遍历</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 前序遍历·递归·LC144_二叉树的前序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n&#x2F;&#x2F; 中序遍历·递归·LC94_二叉树的中序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        inorder(root, res);\n        return res;\n    &#125;\n\n    void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        inorder(root.left, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n        inorder(root.right, list);\n    &#125;\n&#125;\n&#x2F;&#x2F; 后序遍历·递归·LC145_二叉树的后序遍历\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; res &#x3D; new ArrayList&lt;&gt;();\n        postorder(root, res);\n        return res;\n    &#125;\n\n    void postorder(TreeNode root, List&lt;Integer&gt; list) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        postorder(root.left, list);\n        postorder(root.right, list);\n        list.add(root.val);             &#x2F;&#x2F; 注意这一句\n    &#125;\n&#125;</code></pre></li>\n<li><p>非递归遍历</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 前序遍历顺序：中-左-右，入栈顺序：中-右-左\nclass Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 中序遍历顺序: 左-中-右 入栈顺序： 左-右\nclass Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        TreeNode cur &#x3D; root;\n        while (cur !&#x3D; null || !stack.isEmpty())&#123;\n           if (cur !&#x3D; null)&#123;\n               stack.push(cur);\n               cur &#x3D; cur.left;\n           &#125;else&#123;\n               cur &#x3D; stack.pop();\n               result.add(cur.val);\n               cur &#x3D; cur.right;\n           &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n&#x2F;&#x2F; 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果\nclass Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result &#x3D; new ArrayList&lt;&gt;();\n        if (root &#x3D;&#x3D; null)&#123;\n            return result;\n        &#125;\n        Stack&lt;TreeNode&gt; stack &#x3D; new Stack&lt;&gt;();\n        stack.push(root);\n        while (!stack.isEmpty())&#123;\n            TreeNode node &#x3D; stack.pop();\n            result.add(node.val);\n            if (node.left !&#x3D; null)&#123;\n                stack.push(node.left);\n            &#125;\n            if (node.right !&#x3D; null)&#123;\n                stack.push(node.right);\n            &#125;\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;</code></pre></li>\n<li><p>层序遍历</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 102.二叉树的层序遍历\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; resList &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        &#x2F;&#x2F;checkFun01(root,0);\n        checkFun02(root);\n\n        return resList;\n    &#125;\n\n    &#x2F;&#x2F;DFS--递归方式\n    public void checkFun01(TreeNode node, Integer deep) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        deep++;\n\n        if (resList.size() &lt; deep) &#123;\n            &#x2F;&#x2F;当层级增加时，list的Item也增加，利用list的索引值进行层级界定\n            List&lt;Integer&gt; item &#x3D; new ArrayList&lt;Integer&gt;();\n            resList.add(item);\n        &#125;\n        resList.get(deep - 1).add(node.val);\n\n        checkFun01(node.left, deep);\n        checkFun01(node.right, deep);\n    &#125;\n\n    &#x2F;&#x2F;BFS--迭代方式--借助队列\n    public void checkFun02(TreeNode node) &#123;\n        if (node &#x3D;&#x3D; null) return;\n        Queue&lt;TreeNode&gt; que &#x3D; new LinkedList&lt;TreeNode&gt;();\n        que.offer(node);\n\n        while (!que.isEmpty()) &#123;\n            List&lt;Integer&gt; itemList &#x3D; new ArrayList&lt;Integer&gt;();\n            int len &#x3D; que.size();\n\n            while (len &gt; 0) &#123;\n                TreeNode tmpNode &#x3D; que.poll();\n                itemList.add(tmpNode.val);\n\n                if (tmpNode.left !&#x3D; null) que.offer(tmpNode.left);\n                if (tmpNode.right !&#x3D; null) que.offer(tmpNode.right);\n                len--;\n            &#125;\n\n            resList.add(itemList);\n        &#125;\n\n    &#125;\n&#125;</code></pre></li>\n<li><p>翻转二叉树</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;</code></pre></li>\n<li><p>二叉树的所有路径</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;DFS递归\nclass Solution &#123;\n   &#x2F;**\n     * 前后序遍历都可以\n     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）\n     *&#x2F;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        invertTree(root.left);\n        invertTree(root.right);\n        swapChildren(root);\n        return root;\n    &#125;\n\n    private void swapChildren(TreeNode root) &#123;\n        TreeNode tmp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; tmp;\n    &#125;\n&#125;\n\n&#x2F;&#x2F;BFS\nclass Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;return null;&#125;\n        ArrayDeque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        deque.offer(root);\n        while (!deque.isEmpty()) &#123;\n            int size &#x3D; deque.size();\n            while (size-- &gt; 0) &#123;\n                TreeNode node &#x3D; deque.poll();\n                swap(node);\n                if (node.left !&#x3D; null) deque.offer(node.left);\n                if (node.right !&#x3D; null) deque.offer(node.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n\n    public void swap(TreeNode root) &#123;\n        TreeNode temp &#x3D; root.left;\n        root.left &#x3D; root.right;\n        root.right &#x3D; temp;\n    &#125;\n&#125;</code></pre></li>\n<li><p>前序和后序构造二叉树</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    Map&lt;Integer, Integer&gt; map;  &#x2F;&#x2F; 方便根据数值查找位置\n    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (inBegin &gt;&#x3D; inEnd || postBegin &gt;&#x3D; postEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(postorder[postEnd - 1]);  &#x2F;&#x2F; 找到后序遍历的最后一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定后序数列的个数\n        root.left &#x3D; findNode(inorder, inBegin, rootIndex,\n                            postorder, postBegin, postBegin + lenOfLeft);\n        root.right &#x3D; findNode(inorder, rootIndex + 1, inEnd,\n                            postorder, postBegin + lenOfLeft, postEnd - 1);\n\n        return root;\n    &#125;\n&#125;</code></pre></li>\n<li><p>前序和中序构造二叉树</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    Map&lt;Integer, Integer&gt; map;\n    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; inorder.length; i++) &#123; &#x2F;&#x2F; 用map保存中序序列的数值对应位置\n            map.put(inorder[i], i);\n        &#125;\n\n        return findNode(preorder, 0, preorder.length, inorder,  0, inorder.length);  &#x2F;&#x2F; 前闭后开\n    &#125;\n\n    public TreeNode findNode(int[] preorder, int preBegin, int preEnd, int[] inorder, int inBegin, int inEnd) &#123;\n        &#x2F;&#x2F; 参数里的范围都是前闭后开\n        if (preBegin &gt;&#x3D; preEnd || inBegin &gt;&#x3D; inEnd) &#123;  &#x2F;&#x2F; 不满足左闭右开，说明没有元素，返回空树\n            return null;\n        &#125;\n        int rootIndex &#x3D; map.get(preorder[preBegin]);  &#x2F;&#x2F; 找到前序遍历的第一个元素在中序遍历中的位置\n        TreeNode root &#x3D; new TreeNode(inorder[rootIndex]);  &#x2F;&#x2F; 构造结点\n        int lenOfLeft &#x3D; rootIndex - inBegin;  &#x2F;&#x2F; 保存中序左子树个数，用来确定前序数列的个数\n        root.left &#x3D; findNode(preorder, preBegin + 1, preBegin + lenOfLeft + 1,\n                            inorder, inBegin, rootIndex);\n        root.right &#x3D; findNode(preorder, preBegin + lenOfLeft + 1, preEnd,\n                            inorder, rootIndex + 1, inEnd);\n\n        return root;\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h3 id=\"2-动态规划\"><a href=\"#2-动态规划\" class=\"headerlink\" title=\"2.动态规划\"></a>2.动态规划</h3><ol>\n<li>背包问题：0-1、完全、多重、二维费用、分组、有依赖的</li>\n<li>路径问题</li>\n<li>打家劫舍和股票买卖<ul>\n<li>一般动态规划问题，上一个阶段做了什么决策，不影响下一个阶段的决策。但是打家劫舍&amp;股票买卖这类问题，上一个阶段的决策会影响下一个阶段的决策，所以，每个阶段需要记录不同的决策对应的最值，而不是一个全局的最值</li>\n</ul>\n</li>\n<li>爬楼梯</li>\n<li>匹配问题</li>\n</ol>\n<h3 id=\"3-海量数据处理\"><a href=\"#3-海量数据处理\" class=\"headerlink\" title=\"3.海量数据处理\"></a>3.海量数据处理</h3><ul>\n<li>使用Hash取余进行分治<ul>\n<li>给定 a、b 两个文件，各存放 50 亿个 URL，每个 URL 各占 64B，内存限制是 4G。请找出 a、b 两个文件共同的 URL<ul>\n<li>首先遍历文件 a，对遍历到的 URL 求 <code>hash(URL) % 1000</code> ，根据计算结果把遍历到的 URL 存储到 a0, a1, a2, …, a999，这样每个大小约为 300MB。使用同样的方法遍历文件 b，把文件 b 中的 URL 分别存储到文件 b0, b1, b2, …, b999 中。这样处理过后，所有可能相同的 URL 都在对应的小文件中，即 a0 对应 b0, …, a999 对应 b999，不对应的小文件不可能有相同的 URL。那么接下来，我们只需要求出这 1000 对小文件中相同的 URL 就好了。接着遍历 ai( <code>i∈[0,999]</code> )，把 URL 存储到一个 HashSet 集合中。然后遍历 bi 中每个 URL，看在 HashSet 集合中是否存在，若存在，说明这就是共同的 URL，可以把这个 URL 保存到一个单独的文件中。</li>\n</ul>\n</li>\n<li>有一个 1GB 大小的文件，文件里每一行是一个词，每个词的大小不超过 16B，内存大小限制是 1MB，要求返回频数最高的 100 个词(Top 100)<ul>\n<li>首先遍历大文件，对遍历到的每个词 x，执行 <code>hash(x) % 5000</code> ，将结果为 i 的词存放到文件 ai 中。遍历结束后，我们可以得到 5000 个小文件。每个小文件的大小为 200KB 左右。如果有的小文件大小仍然超过 1MB，则采用同样的方式继续进行分解。接着统计每个小文件中出现频数最高的 100 个词。最简单的方式是使用 HashMap 来实现。其中 key 为词，value 为该词出现的频率。具体方法是：对于遍历到的词 x，如果在 map 中不存在，则执行 <code>map.put(x, 1)</code> ；若存在，则执行 <code>map.put(x, map.get(x)+1)</code> ，将该词频数加 1。上面我们统计了每个小文件单词出现的频数。接下来，我们可以通过维护一个<strong>小顶堆</strong>来找出所有词中出现频数最高的 100 个。具体方法是：依次遍历每个小文件，构建一个<strong>小顶堆</strong>，堆大小为 100。如果遍历到的词的出现次数大于堆顶词的出现次数，则用新词替换堆顶的词，然后重新调整为<strong>小顶堆</strong>，遍历结束后，小顶堆上的词就是出现频数最高的 100 个词。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>位图<ul>\n<li>在 2.5 亿个整数中找出不重复的整数<ul>\n<li>用 2 个 bit 来表示各个数字的状态：00 表示这个数字没出现过；01 表示这个数字出现过一次（即为题目所找的不重复整数）；10 表示这个数字出现了多次。那么这 232 个整数，总共所需内存为 232*2b=1GB。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。</li>\n</ul>\n</li>\n<li>给定 40 亿个不重复的没排过序的 unsigned int 型整数，然后再给定一个数，如何快速判断这个数是否在这 40 亿个整数当中<ul>\n<li>由于 unsigned int 数字的范围是 <code>[0, 1 &lt;&lt; 32)</code>，我们用 <code>1&lt;&lt;32=4,294,967,296</code> 个 bit 来表示每个数字。初始位均为 0，那么总共需要内存：4,294,967,296b≈512M。我们读取这 40 亿个整数，将对应的 bit 设置为 1。接着读取要查询的数，查看相应位是否为 1，如果为 1 表示存在，如果为 0 表示不存在。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>前缀树：常被用来统计字符串的出现次数，另外一个大的用途是字符串查找，判断是否有重复的字符串</li>\n<li>堆<ul>\n<li>有 20 个数组，每个数组有 500 个元素，并且有序排列。如何在这 20*500 个数中找出前 500 的数？<ul>\n<li>首先建立大顶堆，堆的大小为数组的个数，即为 20，把每个数组最大的值存到堆中。接着删除堆顶元素，保存到另一个大小为 500 的数组中，然后向大顶堆插入删除的元素所在数组的下一个元素。重复上面的步骤，直到删除完第 500 个元素，也即找出了最大的前 500 个数。（<strong>为了在堆中取出一个数据后，能知道它是从哪个数组中取出的，从而可以从这个数组中取下一个值，可以把数组的指针存放到堆中，对这个指针提供比较大小的方法。</strong>）</li>\n</ul>\n</li>\n<li>从 5 亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数为 第 <code>(N+1)/2</code> 个数；当样本数为偶数时，中位数为 第 <code>N/2</code> 个数与第 <code>1+N/2</code> 个数的均值。<ul>\n<li>数据量小：维护两个堆，一个大顶堆，一个小顶堆。大顶堆中最大的数小于等于小顶堆中最小的数（一个堆保存一半数）；保证这两个堆中的元素个数的差不超过 1。若数据总数为偶数，当这两个堆建好之后，中位数就是这两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。</li>\n<li>数据量大：顺序读取这 5 亿个数字，对于读取到的数字 num，如果它对应的二进制中最高位为 1，则把这个数字写到 f1 中，否则写入 f0 中。通过这一步，可以把这 5 亿个数划分为两部分，而且 f0 中的数都大于 f1 中的数（最高位是符号位）。划分之后，可以非常容易地知道中位数是在 f0 还是 f1 中。假设 f1 中有 1 亿个数，那么中位数一定在 f0 中，且是在 f0 中，从小到大排列的第 1.5 亿个数与它后面的一个数的平均值。对于 f0 可以用次高位的二进制继续将文件一分为二，如此划分下去，直到划分后的文件可以被加载到内存中，把数据加载到内存中以后直接排序，找出中位数。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-其它\"><a href=\"#3-其它\" class=\"headerlink\" title=\"3.其它\"></a>3.其它</h3><ol>\n<li><p><code>@SuppressWarnings(&quot;unchecked&quot;)</code></p>\n<ul>\n<li><p>Sometimes Java generics just doesn’t let you do what you want to, and you need to effectively tell the compiler that what you’re doing really <em>will</em> be legal at execution time.</p>\n</li>\n<li><p>可选的值</p>\n<table>\n<thead>\n<tr>\n<th>All</th>\n<th>It will suppress all warnings.</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Cast</td>\n<td>Suppress the warning while casting from a generic type to a nonqualified type or the other way around.</td>\n<td></td>\n</tr>\n<tr>\n<td>Deprecation</td>\n<td>Ignores when we’re using a deprecated(no longer important) method or type.</td>\n<td>使用了不赞成使用的类或方法时的警告</td>\n</tr>\n<tr>\n<td>divzero</td>\n<td>Suppresses division by zero warning.</td>\n<td></td>\n</tr>\n<tr>\n<td>empty</td>\n<td>Ignores warning of a statement with an empty body.</td>\n<td></td>\n</tr>\n<tr>\n<td>unchecked</td>\n<td>It doesn’t check if the data type is Object or primitive.</td>\n<td>例如使用集合时没有用泛型来指定集合保存的类型</td>\n</tr>\n<tr>\n<td>fallthrough</td>\n<td>Ignores fall-through on switch statements usually (if “break” is missing).</td>\n<td>当switch程序块直接通往下一种情况而没有break时的警告</td>\n</tr>\n<tr>\n<td>hiding</td>\n<td>It suppresses warnings relative to locals that hide variable</td>\n<td></td>\n</tr>\n<tr>\n<td>serial</td>\n<td>It makes the compiler shut up about a missing serialVersionUID.</td>\n<td>在可序列化的类上缺少serialVersionUID定义时的警告</td>\n</tr>\n<tr>\n<td>finally</td>\n<td>Avoids warnings relative to finally block that doesn’t return.</td>\n<td>任何 finally 子句不能正常完成时的警告</td>\n</tr>\n<tr>\n<td>unused</td>\n<td>To suppress warnings relative to unused code.</td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n</li>\n<li><p><code>Runtime Error Hangup</code>通常是因为程序在运行时被强制终止或意外终止导致的错误。这个错误通常出现在操作系统或程序遇到了无法处理的异常情况时。一些可能导致Runtime Error 0Hangup错误的原因包括：</p>\n<ol>\n<li>内存不足或堆栈溢出；</li>\n<li>访问无效的内存地址；</li>\n<li>文件操作失败或无效的文件指针；</li>\n<li>操作系统或其他软件的错误或冲突；</li>\n<li>程序代码错误或逻辑错误；</li>\n<li>程序被用户手动终止。</li>\n</ol>\n</li>\n<li><p>笔试系统：输入输出学习链接（<a href=\"https://ac.nowcoder.com/acm/contest/5657#question%EF%BC%89\">https://ac.nowcoder.com/acm/contest/5657#question）</a></p>\n<ul>\n<li><p>示例一：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 有些输入可能是：\n&#x2F;&#x2F; 输入一个矩阵，每行以空格分隔。\n&#x2F;&#x2F; 3 2 3\n&#x2F;&#x2F; 1 6 5\n&#x2F;&#x2F; 7 8 9\nimport java.io.*;\nimport java.util.*;\n\nclass Solution &#123;\n  public void myFunc(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arr) &#123;\n    &#x2F;&#x2F; 使用自测数据按钮时调试用，正式提交时要删掉。\n    System.out.println(arr);\n  &#125;\n&#125;\npublic class Main\n&#123;\n  public static void main(String args[])\n  &#123;\n    Scanner cin &#x3D; new Scanner(System.in);\n    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arr &#x3D; new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n    while(cin.hasNextLine())\n    &#123;\n      ArrayList&lt;Integer&gt; row &#x3D; new ArrayList&lt;Integer&gt;();\n      String line &#x3D; cin.nextLine();\n      if (line.length() &gt; 0) &#123;\n        String[] arrLine &#x3D; line.split(&quot; &quot;);\n        for (int i&#x3D;0; i&lt;arrLine.length; i++) &#123;\n          row.add(Integer.parseInt(arrLine[i]));\n        &#125;\n        arr.add(row);\n      &#125;\n    &#125;\n        \n    new Solution().myFunc(arr);\n  &#125;\n&#125;</code></pre></li>\n<li><p>示例二：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;package main\n&#x2F;&#x2F;注意不要添加包名称，否则会报错。\n&#x2F;&#x2F; 不要自定义包名称，否则会报错，即不要添加package answer之类的语句；\n&#x2F;&#x2F; 您可以写很多个类，但是必须有一个类名为Main，并且为public属性，并且Main为唯一的public class；\n&#x2F;&#x2F; Main类的里面必须包含一个名字为&#39;main&#39;的静态方法（函数），这个方法是程序的入口。\n\nimport java.io.*;\nimport java.util.*;\nclass Solution &#123;\n  public int addab(int a, int b) &#123;\n    return a+b;\n  &#125;\n&#125;\npublic class Main\n&#123;\n  public static void main(String args[])\n  &#123;\n    Scanner cin &#x3D; new Scanner(System.in);\n    int a, b;\n    while(cin.hasNextInt())\n    &#123;\n      a &#x3D; cin.nextInt();\n      b &#x3D; cin.nextInt();\n      Solution s &#x3D; new Solution();\n      int c &#x3D; s.addab(a, b);\n      System.out.println(c);\n    &#125;\n  &#125;\n&#125;</code></pre></li>\n<li><p>示例三：从在键盘上按<strong>Ctrl+Z</strong>。这样输入会读取到EOF，表示读取结束。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">while (sc.hasNextLine())&#123;\n\t\tScanner sc &#x3D; new Scanner(System.in);\n    String temp &#x3D; sc.nextLine();\n    String[] ss &#x3D; temp.trim().split(&quot; &quot;);\n    int num1 &#x3D; Integer.parseInt(ss[0]);\n    int num2 &#x3D; Integer.parseInt(ss[1]);\n    if (temp.isEmpty())&#123;\n        break;\n    &#125;\n    System.out.println(temp);\n&#125;\n\npublic class Main&#123;\n    public static void main(String[] args)&#123;\n        Scanner sc &#x3D; new Scanner(System.in);\n        int n &#x3D; sc.nextInt();\n        &#x2F;&#x2F;nextInt不会吸收掉换行符，后的nextLine会直接读取换行符，然后结束输入\n        sc.nextLine();\n        String temp &#x3D; sc.nextLine();\n        String[] data;\n        data &#x3D; temp.trim().split(&quot; &quot;);\n        Arrays.sort(data);\n        for(int i &#x3D; 0; i &lt; n; i++)&#123;\n            System.out.print(data[i]);\n            if(i !&#x3D; n-1)&#123;\n                System.out.print(&quot; &quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ol>\n","text":"数据结构1.数据结构1.1常用方法 接口 API Collection size、isEmpty、contains、toArray、add、remove、clear List get(index)、set(index)、add(index,element)、remove(inde...","link":"","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"32 mins."},"categories":[],"tags":[{"name":"algorithm","slug":"algorithm","count":1,"path":"api/tags/algorithm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1.数据结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1.1常用方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2%E5%B7%A5%E5%85%B7%E7%B1%BB\"><span class=\"toc-text\">1.2工具类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86\"><span class=\"toc-text\">1.3补充知识</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.1复杂度分析</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">2.2技巧</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">2.3算法思想</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BB%8F%E5%85%B8%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">3.经典代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">1.二叉树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">2.动态规划</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86\"><span class=\"toc-text\">3.海量数据处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%85%B6%E5%AE%83\"><span class=\"toc-text\">3.其它</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Java特性","uid":"b4296f0600f693552b5b6c6b665f6025","slug":"Java Base","date":"2023-04-13T11:25:47.000Z","updated":"2023-06-05T12:48:11.065Z","comments":true,"path":"api/articles/Java Base.json","keywords":null,"cover":[],"text":"Java1.基础知识1.关键字 true, false, 和 null 虽然不是关键字，但它们是不能用作标识符的文字和保留字 strictfp（精确浮点数，跨平台产生相同结果）、native（原生方法） class return byte try if import public...","link":"","photos":[],"count_time":{"symbolsCount":"36k","symbolsTime":"33 mins."},"categories":[],"tags":[{"name":"language","slug":"language","count":3,"path":"api/tags/language.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}