{"title":"Internet","uid":"f00c07cb09e8c5144602456ae7f0f75a","slug":"Internet","date":"2023-08-02T14:26:24.000Z","updated":"2023-08-02T14:34:34.154Z","comments":true,"path":"api/articles/Internet.json","keywords":null,"cover":[],"content":"<h1 id=\"Internet\"><a href=\"#Internet\" class=\"headerlink\" title=\"Internet\"></a>Internet</h1><h2 id=\"1-网络层\"><a href=\"#1-网络层\" class=\"headerlink\" title=\"1.网络层\"></a>1.网络层</h2><ol>\n<li><p>IP</p>\n<ul>\n<li><p>查看IP地址：ifconfig、ip addr</p>\n<ul>\n<li>scope：如果是global，则此张网卡是可以对外开放的，可以接受各个地方的包；对于lo来说事host，说明这张网卡仅仅可以供本机相互通信</li>\n<li>lo全称是loopback，又称环回接口，往往会被分配到127.0.0.1这个地址，用于本机通信，经过内核处理后直接返回，不会再任何网络中出现。</li>\n<li>MAC地址：在 IP 地址的上一行是 link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff，这个被称为 MAC 地址，是一个网卡的物理地址，用十六进制，6 个 byte 表示。因为MAC没有定位功能，所以需要IP地址来寻路</li>\n<li>网络设备的状态标识（net_device flags）：例如&lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; ，UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包；LOWER_UP 表示 L1 是启动的，也即网线插着呢。MTU1500 是指最大传输单元 MTU 为 1500，这是以太网的默认值。</li>\n<li>排队规则（qdisc pfifo_fast）：qdisc 全称是 queueing discipline，中文叫排队规则。内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的 qdisc（排队规则）把数据包加入队列。最简单的 qdisc 是 pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列。pfifo_fast 稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。</li>\n</ul>\n</li>\n<li><p>IP地址分类方式（ 无类型域间选路（CIDR）：10.100.122.2/24 ，网络号+主机号组成，通过与掩码进行与运算来求值）</p>\n<ul>\n<li>A类地址：1.0.0.0 到126.0.0.0（私有地址10.0.0.0～10.255.255.255）</li>\n<li>B类地址：128.0.0.0到191.255.255.255（私有地址172.16.0.0～172.31.255.255）</li>\n<li>C类地址：192.0.0.0到223.255.255.255（私有地址192.168.0.0～192.168.255.255）</li>\n<li>D类组播地址用于VXLAN协议，E类留待后用</li>\n<li>0.0.0.0对应于当前主机，255.255.255.255对应于当前子网的广播地址，127.0.0.1用于环回测试（loopback test）本主机</li>\n</ul>\n</li>\n<li><p>数据报格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730115123270.png\" alt=\"image-20230730115123270\"></p>\n<ul>\n<li><strong>版本</strong> : 有 4（IPv4）和 6（IPv6）两个值；</li>\n<li><strong>首部长度</strong> : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</li>\n<li><strong>区分服务</strong> : 是一个框架和一组标准，用于支持RFC2474,RFC2475,RFC3260上不同类型的服务（即不只是尽力而为的服务，而是更好的服务）</li>\n<li><strong>总长度</strong> : 包括首部长度和数据部分长度，以字节为单位（最大为MTU一般为1500字节）</li>\n<li><strong>生存时间</strong> ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。</li>\n<li><strong>协议</strong> ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP（6）、UDP（17） 等。</li>\n<li><strong>首部检验和</strong> ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</li>\n<li><strong>标识</strong> : 避免数据报分片的混淆，在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</li>\n<li><strong>片偏移</strong> : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</li>\n<li><strong>选项字段</strong>：很多选项已经被淘汰，只有一部分被留下来放在了IPv6的扩展头部中</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路由协议：ODPF、RIP</p>\n<ul>\n<li><p>配置路由</p>\n<ul>\n<li><p>路由表：决定如何转发流量，通常称为路由表，主要包含以下三项信息，目的网络、出口设备、下一跳网关。可以通过route命令和ip route命令进行查询或者配置。例如，我们设置<code>ip route add 10.176.48.0/20 via 10.173.32.1 dev eth0</code>，就说明要去 10.176.48.0/20 这个目标网络，要从 eth0 端口出去，经过 10.173.32.1。</p>\n</li>\n<li><p>策略路由配置示例：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ ip rule add from 192.168.1.0&#x2F;24 table 10\n$ ip rule add from 192.168.2.0&#x2F;24 table 20\n#表示从 192.168.1.10&#x2F;24 这个网段来的，使用 table 10 中的路由表，\n#而从 192.168.2.0&#x2F;24 网段来的，使用 table20 的路由表\n$ ip route add default scope global nexthop via 100.100.100.1 weight 1 nexthop via 200.200.200.1 weight 2\n#下一跳有两个地方，分别是 100.100.100.1 和 200.200.200.1，权重分别为 1 比 2。</code></pre></li>\n</ul>\n</li>\n<li><p>动态路由算法：如何在网络拓扑中找到两个节点的最短路径，主要有Bellman-Ford和Dijkstra算法</p>\n<ul>\n<li><p>距离矢量路由算法（distance vector routing）：基于Bellman-Ford算法，算法思想是每个路由器都保存一个路由表，从哪出和距离，每个路由器都保存全局信息，每过一段时间将已知信息告知邻居。存在两个问题</p>\n<ul>\n<li><p>好消息（新加入路由器）传的块，坏消息（下线的路由器）传的慢</p>\n</li>\n<li><p>每次发送的时候，要发送整个全局路由表</p>\n</li>\n</ul>\n</li>\n<li><p>链路状态路由算法（link state routing），基于Dijkstra算法，算法思想是当一个路由器启动的时候，首先是发现邻居，向邻居 say hello，邻居都回复。然后计算和邻居的距离，发送一个 echo，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用 Dijkstra 算法，找到两点之间的最短路径</p>\n</li>\n</ul>\n</li>\n<li><p>动态路由协议</p>\n<ul>\n<li><p>基于链路状态路由算法的OSPF（Open Shortest Path First，开放式最短路径优先）：主要用于数据中心内部，又称内部网关协议（Interior Gateway Protocol IGP）。内部网关协议的重点就是找到最短路径，可以在多个路径中进行负载均衡，常被称为等价路由。常配合接入层的负载均衡LVS</p>\n</li>\n<li><p>基于距离矢量路由算法的BGP（Border Gateway Protocol，外网路由协议）：因为每个数据中心都有自己的Policy，所以有些路可以走，有些不可以走。这一个个数据中心称为自治系统AS（Autonomous System），通过边界路由器与外面世界建立联系。BGP有两类：</p>\n<ul>\n<li><p>eBGP：边界路由器之间使用eBGP广播路由</p>\n</li>\n<li><p>iBGP：使得内部路由器能够找到到达外网目的地的最好的边界路由器</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>数据链路层：ARP（将IP解析为MAC）</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果说互联网中每一个资源都有IP地址唯一标识，那么一些网络设备都有MAC地址唯一标识，MAC类似于身份证号，IP地址类似于住址</p></blockquote>\n<ul>\n<li><p>MAC地址：6字节，地址空间约280万亿，由IEEE统一管理与分配，FF-FF-FF-FF-FF-FF为广播地址</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120415210.png\" alt=\"image-20230730120415210\"></p>\n<ul>\n<li>类型字段用于确定协议类型：<ol>\n<li>IPv4为0x0800</li>\n<li>IPv6为0x86DD</li>\n</ol>\n</li>\n<li>FCS为帧校验序列：为待检查的消息追加n为0，除以一个n+1位的生成多项式，将余数取反放到FCS中</li>\n<li>链路层MTU为1500字节</li>\n</ul>\n</li>\n<li><p>ARP协议原理：ARP表，广播问讯，单播响应</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>全称为地址解析协议，它解决的是网络层地址和链路层地址之间的转换问题，因为一个IP数据报在物理上传输的过程中，总需要知道下一跳（物理上的下一目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题</p></blockquote>\n<ul>\n<li><p>ARP表：在一个局域网内，每个网络设备都自己维护了一个ARP表，ARP表记录了某些网络设备的IP地址和MAC地址的映射关系（<code>&lt;IP, MAC, TTL&gt;</code>），其中TTL为该映射关系的生存周期（通常为20min），超时即丢弃此条目</p>\n</li>\n<li><p>同一个局域网内的MAC寻址（A「137.196.7.23」，B「137.196.7.14」）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120439734.png\" alt=\"image-20230730120439734\"></p>\n<ul>\n<li>A检索自己的ARP表，发现ARP表中无B的IP地址对应的条目，无法知道B的MAC地址</li>\n<li>A构造一个ARP查询分组，将其广播到所在的局域网中<ul>\n<li>ARP分组主要有两种，ARP查询分组和ARP响应分组，他们具有相同的格式，均包含了发送和接收的IP地址，发送和接收的MAC地址<ul>\n<li>查询分组发送的IP地址为A的IP地址，接收的IP地址为B的IP地址；发送的MAC地址为A的MAC地址，接收的MAC地址为FF-FF-FF-FF-FF-FF</li>\n<li>响应分组IP地址与查询分组相反，MAC地址也相反，但是目的MAC地址为查询分组的发送者的MAC，源MAC地址为B的MAC地址</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>主机A构造的查询分组将在局域网内广播，每一个设备都会收到该分组，设备通过核查IP地址是否与本地相同来确定是否响应</li>\n<li>主机B收到了查询分组，构造一个ARP响应分组，该分组只有一个目的地（主机A），主机B提取IP和MAC信息，插入到ARP表中</li>\n<li>主机A收到主机B的响应分组，提取出该分组的IP地址和MAC地址，插入到ARP表中</li>\n</ul>\n</li>\n<li><p>从一个局域网到另一个局域网中的网络设备的寻址</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>路由器的每一个接口都各自维护一个ARP表</p></blockquote>\n<ul>\n<li>主机A查询ARP表，期望寻找到目标路由器（根据B的IP分析出B的子网，转发报文到该子网）的本子网接口的MAC地址</li>\n<li>主机A未能找到目标路由器的本子网接口的MAC地址，采用ARP协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同</li>\n<li>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口</li>\n<li>目标接口接收到了链路层帧，解析，根据目的IP地址，查询转发表，将该IP数据报转发到B所在的子网相连的接口上</li>\n<li>路由接口查询ARP表，寻找主机B的MAC地址，如果没找到，则采用ARP查询分组，广播问询，单播响应，获取到主机B的MAC地址，路由器接口对IP数据报重新封装成链路层帧，目标MAC地址为主机B的MAC地址，单播发送，直到目的地</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>应用层：DNS（由域名查IP，负载均衡技术，DNS解析过程如下）</p>\n<ul>\n<li>首先查缓存<ul>\n<li>浏览器缓存检查：浏览器首先搜索自身的DNS缓存（大概1000条左右），看自身缓存是否命中，或已过期</li>\n<li>操作系统缓存检查 + hosts 解析：查询操作系统的DNS缓存是否命中，可以通过<code>/etc/hosts</code>文件来设置，将任何域名解析到任何能够访问的IP地址</li>\n</ul>\n</li>\n<li>然后进行dns解析<ul>\n<li>第一步：发送域名到本地DNS服务器，查询其缓存，如果有则返回，如果没有则本地DNS服务器发送请求给根DNS服务器进行查询</li>\n<li>第二步：根域名服务器没有记录对应关系时，返回顶级域名服务器的IP；顶级域名服务器向根DNS服务器返回二级域名服务器的IP；二级域名服务器将自己缓存表中的域名和IP地址的对应关系返回给本地DNS服务器</li>\n<li>第三步：本地 DNS 服务器将获取到与域名对应的 IP 地址返回给客户端，并且将域名和 IP 地址的对应关系保存在缓存中，以备下次别的用户查询时使用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>应用层：DHCP（已有MAC，获取IP）</p>\n<ol>\n<li><p>格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120144800.png\" alt=\"image-20230730120144800\"></p>\n</li>\n<li><p>原理</p>\n<ol>\n<li><p>手动配置IP相当于自己买房装修，DHCP协议相当于租房</p>\n</li>\n<li><p>新到一个城市要先找中介（DHCP服务器）租个房（IP）-Discover</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120207306.png\" alt=\"image-20230730120207306\"></p>\n</li>\n<li><p>中介（DHCP）会带你看房，可能会有多个中介带你看多个房-Offer</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120221754.png\" alt=\"image-20230730120221754\"></p>\n</li>\n<li><p>你看上其中一个房，愿意租下来-Request</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120240826.png\" alt=\"image-20230730120240826\"></p>\n</li>\n<li><p>中介说没问题，咱们签合同，租约达成-Ack</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120255346.png\" alt=\"image-20230730120255346\"></p>\n</li>\n<li><p>租约达成要广播，防止中介之间跳单</p>\n</li>\n<li><p>租约快到之前，记得续租</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p>NAT：内网复用IP，NAT网关将私有IP改为公网IP</p>\n<ul>\n<li>允许多个范围内中的同一地址可以复用。专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP，内部原理就是重写通过路由器的数据包的识别信息</li>\n<li>一共有三个IPv4地址范围作为私有地址范围使用（常作为DHCP地址池）：10.0.0.0/8、172.16.0.0/12、192.168.0.0/16</li>\n<li>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</li>\n</ul>\n</li>\n<li><p>ICMP（ping的底层实现）</p>\n<ul>\n<li><p>帧格式</p>\n<ul>\n<li><p>查询报文类型：一种主动请求并且获得主动应答的ICMP协议，在网络抓包时，称为ICMP ECHO REQUEST和CMP ECHO REPLY，比原生ICMP多个标识符和序号字段</p>\n</li>\n<li><p>差错报文类型：主要有终点不可达（3）、源抑制（4）、超时（11）、重定向（5）等</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120007920.png\" alt=\"image-20230730120007920\"></p>\n</li>\n</ul>\n</li>\n<li><p>ping原理</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730115952768.png\" alt=\"image-20230730115952768\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-传输层\"><a href=\"#2-传输层\" class=\"headerlink\" title=\"2.传输层\"></a>2.传输层</h2><ol>\n<li><p>TCP</p>\n<ul>\n<li><p>头格式</p>\n<ul>\n<li>序号：给包编号，用来解决乱序问题（将应用层的数据分块「TCP segment」，最大为MSS、MTU除去IP头和TCP头）</li>\n<li>确认序号：发出去的包应该有确认，来确定是否已经收到相应包</li>\n<li>状态位：<ul>\n<li>SYN：发起一个连接</li>\n<li>ACK：回复</li>\n<li>RST：重新连接</li>\n<li>FIN：结束连接</li>\n</ul>\n</li>\n<li>窗口大小：TCP要做流浪控制，通信双方动态约定一个窗口，保证双方都在高效处理数据</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121059129.png\" alt=\"image-20230730121059129\"></p>\n</li>\n<li><p>三次握手：<strong>保证双方都有发送和接收的能力</strong></p>\n<ul>\n<li><p>握手次数：一次的话，请求方不知道响应方是否已经成功接受请求；两次的话，接收方不知道发送方是否成功接受相应；三次的话，刚好双方都知晓；四次以及更多的话，已经没有特殊的意义了，所以再多的数据包都不能保证真的可靠，后续通过数据包和探活包来解决相关问题</p>\n<ul>\n<li>防止旧的重复连接初始化造成混乱：旧连接的同步客户端会返回RST报文来解决</li>\n<li>同步双方初始序列号：同步双方的序列号</li>\n<li>避免资源浪费</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121118741.png\" alt=\"image-20230730121118741\"></p>\n</li>\n<li><p>TCP包的序号问题：为了防止连接之间数据包序号的相互影响，所以序号是随时间变化的，通过数据包的序号，双方都可以知道应收的包和应发的包都是哪个</p>\n</li>\n<li><p>Socket编程</p>\n<ul>\n<li><p>连接建立过程</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230802092613556-20230802092747724-20230802093240018.png\"></p>\n</li>\n<li><p>没有 accept，能建立 TCP 连接吗：accpet 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accpet 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230802093312448.png\" alt=\"image-20230802093312448\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>四次挥手</p>\n<ul>\n<li><p>等待2MSL：MSL是报文最大生存时间，虽然序号是重新生成的，但是为了防止左端提前结束后收到右端之前连接的数据包，所以需要等待2MSL时间。时间截止后，对于右端旧连接发送的数据包，左端将会直接发送RST，这样右端就知道左端已退出</p>\n<ul>\n<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收</li>\n<li>确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121140305.png\" alt=\"image-20230730121140305\"></p>\n</li>\n<li><p>TIME_WAIT 状态是主动关闭连接方才会出现的状态</p>\n<ul>\n<li>服务器出现大量 TIME_WAIT 状态的原因：服务端主动断开大量TCP连接，有可能是HTTP 没有使用长连接、HTTP 长连接超时（nginx 提供的 keepalive_timeout）、HTTP 长连接的请求数量达到上限（nginx 的 keepalive_requests）</li>\n</ul>\n</li>\n<li><p>CLOSE_WAIT 状态是「被动关闭方」才会有的状态</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230802093052027.png\" alt=\"image-20230802093052027\"></p>\n</li>\n</ul>\n</li>\n<li><p>滑动窗口</p>\n<ul>\n<li><p>发送端</p>\n<ul>\n<li>第一部分：发送了并且已经确认的。这部分就是你交代下属的，并且也做完了的，应该划掉的</li>\n<li>第二部分：发送了并且尚未确认的。这部分是你交代下属的，但是还没做完的，需要等待做完的回复之后，才能划掉</li>\n<li>第三部分：没有发送，但是已经等待发送的。这部分是你还没有交代给下属，但是马上就要交代的</li>\n<li>第四部分：没有发送，并且暂时还不会发送的。这部分是你还没有交代给下属，而且暂时还不会交代给下属的。（区分三和四是为了流量控制）</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121154410.png\" alt=\"image-20230730121154410\"></p>\n</li>\n<li><p>接收端</p>\n<ul>\n<li>第一部分：接受并且确认过的。也就是我领导交代给我，并且我做完的</li>\n<li>第二部分：还没接收，但是马上就能接收的。也即是我自己的能够接受的最大工作量</li>\n<li>第三部分：还没接收，也没法接收的。也即超过工作量的部分，实在做不完。</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121205446.png\" alt=\"image-20230730121205446\"></p>\n</li>\n<li><p>问题</p>\n<ul>\n<li>流量控制：在对包的确认中，同时会携带一个窗口的大小。当发送方窗口已经全发送过了，但是接受端还没接收，此时每接受到一个应答，窗口大小就减一，直到为0</li>\n<li>丢包问题<ul>\n<li>超时重传：对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。超时时间依靠自适应重传算法（Adaptive Retransmission Algorithm，比RTT多一点）</li>\n<li>超时间隔加倍：每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</li>\n<li>快速重传机制：当接收方收到一个序号大于下一个所期望的报文段时，就会检测到数据流中的一个间隔，于是它就会发送冗余的 ACK，仍然 ACK 的是期望接收的报文段。而当客户端收到三个冗余的 ACK 后，就会在定时器过期之前，重传丢失的报文段</li>\n<li>SACK：解决快速重传机制不确定传输是否需要传输丢失报文后续的报文问题，这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong></li>\n<li>Duplicate SACK：又称 <code>D-SACK</code>，主要使用了 SACK 来告诉发送方有哪些数据被重复接收了</li>\n</ul>\n</li>\n<li>流量控制使用什么数据结构<ul>\n<li>TCP传输协议中，流量控制是使用滑动窗口（Sliding Window）来实现的。滑动窗口是一种基于数据流的、动态调整的、可变大小的窗口，它通过协商双方的接收窗口和发送窗口大小，控制数据的传输速率。</li>\n<li>在TCP协议中，每个数据包都有一个序号，接收方通过序号来确认是否收到了正确的数据包。发送方将数据分成若干个数据段，每个数据段的大小不超过发送窗口的大小，然后将这些数据段发送给接收方。接收方会确认已经收到的数据，同时告诉发送方自己的接收窗口大小。发送方根据接收方的窗口大小，动态调整自己的发送窗口大小，从而控制数据的传输速率。</li>\n<li>滑动窗口的大小是可以动态调整的，它可以根据网络状况和双方的能力来自适应地调整，从而实现流量控制的功能。如果接收方的接收窗口变小，发送方会相应地减小自己的发送窗口，以避免过多的数据堆积在网络中导致拥塞。如果接收方的接收窗口变大，发送方会相应地增加自己的发送窗口，以提高数据传输速率。</li>\n</ul>\n</li>\n<li>TCP如何保证可靠传输<ul>\n<li>tcp的序列号可以避免乱序的问题，保证收到的tcp报文都是有序的。</li>\n<li>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</li>\n<li>TCP 针对数据包丢失的情况，会用重传机制解决。</li>\n<li>用快重传解决个别报文段的丢失问题。</li>\n<li>使用滑动窗口实现流量控制。使用接收方确认报文中的窗口字段来控制发送方发送窗口大小，进而控制发送方的发送速率，使得接收方来得及接收。</li>\n<li>使用基于窗口的拥塞控制，来尽量避免避免网络拥塞。</li>\n</ul>\n</li>\n<li>LInux的TCP连接数量最大为多少：Linux的TCP连接数量最大不能超过65535是一个常见的误解。实际上，一个TCP连接由一个五元组（协议、本地IP、本地端口、远程IP、远程端口）唯一确定12。对于服务器来说，本地端口一般是固定的，比如HTTP (80），但是远程IP和远程端口没有限制。因此，理论上服务器可以支持的TCP连接数是2的32次方（IP数）x2的16次方（端口数）x2的16次方（服多器端口数）个2</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>拥塞窗口</p>\n<ul>\n<li><p>慢启动拥塞避免</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121220688.png\" alt=\"image-20230730121220688\"></p>\n</li>\n<li><p>快重传快恢复</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730121235996.png\" alt=\"image-20230730121235996\"></p>\n</li>\n</ul>\n</li>\n<li><p>TCP粘包分析与处理</p>\n<ul>\n<li><p>概念</p>\n<ul>\n<li>TCP粘包现象：发送方发送的多个数据包，到接收方后粘连在一起，导致数据包不能完整的体现发送的数据（UDP有消息边界，所以不会出现粘包问题）</li>\n<li>如果一次发送的消息太小，没达到缓冲区大小，TCP会讲多个请求合并为同一个请求来发送，这就形成了粘包问题；如果一次发送的消息过大，超过了缓冲区的大小，TCP就会将其拆分为多次发送，这就是拆包问题</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/%E7%B2%98%E5%8C%85.png\" alt=\"粘包\"></p>\n</li>\n<li><p>原因：可能是发送方的原因也可能是接收方的原因</p>\n<ul>\n<li>发送方：由于TCP需要尽可能高效和可靠，所以TCP默认采用Nagle算法，以合并相连的小数据包，再一次性发送，以达到提升网络传输效率的目的。但是接收方并不晓得发送方合并数据包，而且数据包的合并在TCP协议中是没有分界线的，所以这就导致接收方不能还原其本来的数据包</li>\n<li>接收方：TCP是基于“流”的，网络传输数据的速度可能会快过接收方处理数据的速度，这时就会导致接收方在读取缓冲区时，缓冲区存在多个数据包。在TCP协议中接收方是一次读取缓冲区中的所有内容，所以不能反映原本的数据信息</li>\n<li>TCP协议是基于字节流的传输层协议，没有固定的分包边界。发送方将数据分成多个小的数据包进行传输，接收方再将这些数据包组合成完整的数据。在这个过程中，可能会出现拆包和沾包现象</li>\n<li>网络传输中的延迟和拥塞会影响数据包发送的速度和到达接收方的顺序。这可能导致数据包的拆分和组合不规律，从而出现拆包和沾包现象</li>\n<li>接收方的缓冲区大小限制。当接收方的缓冲区不足以容纳一个完整的数据包时，可能会将数据包拆分成多个部分，导致拆包现象</li>\n</ul>\n</li>\n<li><p>解决办法</p>\n<ul>\n<li>其他办法<ul>\n<li>禁用Negel算法：只能解决发送方的问题，但是TCP的传输效率变低了</li>\n<li>PUSH标志：在发送时可以设置这个标志位，通知接收方将收到的数据提交给接收进程，并不能完全解决，只能降低发生粘包的可能性</li>\n<li>发送端将每个包都封装成固定的长度、发送端在每个包的末尾使用固定的分隔符、将消息分为头部和消息体其中头部包含消息长度</li>\n<li>在应用层实现数据包的边界识别，例如通过添加包头，包头中包含数据包长度等信息，使得接收方能够准确地将数据包进行拼接</li>\n<li>使用固定长度的数据包或者特殊的分隔符，以便于接收方识别数据包的边界</li>\n<li>使用更高级的传输层协议，如WebSocket，它在TCP基础上增加了数据帧的概念，可以更好地解决拆包和沾包问题</li>\n</ul>\n</li>\n<li>Netty对粘包和拆包的处理，提供了一些解码器（Decoder）来解决粘包和吃啊包的问题<ul>\n<li>LineBasedFrameDecoder：以行为单位进行数据包的解码；</li>\n<li>DelimiterBasedFrameDecoder：以特殊的符号作为分隔来进行数据包的解码；</li>\n<li>FixedLengthFrameDecoder：以固定长度进行数据包的解码；</li>\n<li>LenghtFieldBasedFrameDecode：适用于消息头包含消息长度的协议（最常用）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UDP</p>\n<ul>\n<li><p>头格式</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730120927146.png\" alt=\"image-20230730120927146\"></p>\n</li>\n<li><p>使用场景</p>\n<ul>\n<li>需要资源少，在网络情况比较好的内网，或者对于丢包不敏感的应用</li>\n<li>不需要一对一沟通，建立连接，而是可以广播的应用</li>\n<li>需要处理速度快，时延低，可以容忍少数丢包，但是要求即便网络拥塞，也毫不退缩，一往无前的时候</li>\n<li>基于UDP的协议：DHCP、HTTP3、云网络中的VXLAN、操作系统镜像的下载使用的 TFTP</li>\n<li>一些新兴改进<ul>\n<li>QUIC是Google提出的一种基于UDP改进的通信协议，在应用层上，会自己实现快速连接建立、减少重传时延，自适应拥塞控制。主要用在网页和APP的访问</li>\n<li>直播协议多使用RTMP，丢包时会影响直播效果，所以很多直播应用都基于UDP实现了视频传输协议</li>\n<li>实时游戏领域，在异步IO机制引入之前，常采用自定义UDP来解决对海量客户端连接的策略</li>\n<li>物联网领域终端资源少，维护TCP协议代价太大，而且物联网对实时性要求也很高。Google 旗下的 Nest 建立 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的</li>\n<li>在 4G 网络里，移动流量上网的数据面对的协议 GTP-U 是基于 UDP 的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其它</p>\n<ul>\n<li>TCP和UDP的区别<ul>\n<li>连接：TCP 是面向连接的传输层协议，传输数据前先要建立连接；UDP 是不需要连接，即刻传输数据</li>\n<li>服务对象：TCP 是一对一的两点服务，即一条连接只有两个端点；UDP 支持一对一、一对多、多对多的交互通信</li>\n<li>可靠性：TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达；UDP 是尽最大努力交付，不保证可靠交付数据</li>\n<li>拥塞控制、流量控制：TCP 有拥塞控制和流量控制机制，保证数据传输的安全性；UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>\n<li>首部开销：TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 <code>20</code> 个字节，如果使用了「选项」字段则会变长的；UDP 首部只有 8 个字节，并且是固定不变的，开销较小。</li>\n<li>传输方式：TCP 是流式传输，没有边界，但保证顺序和可靠；UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序</li>\n<li>分片不同<ul>\n<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>\n<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-应用层\"><a href=\"#3-应用层\" class=\"headerlink\" title=\"3.应用层\"></a>3.应用层</h2><ol>\n<li><p>HTTP：<strong>H</strong>yperText <strong>T</strong>ransfer <strong>P</strong>rotocol（超文本传输协议）</p>\n<ul>\n<li>HTTP/1.1：无状态（cookie）、明文传输（SSL/TLS）、<ul>\n<li>method<ul>\n<li>GET：从服务器获取指定的资源，通过URL以ASCII格式传递参数，是安全且幂等的<ul>\n<li>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。</li>\n</ul>\n</li>\n<li>POST：根据请求负荷（报文body中）对指定的资源做出对应的处理，不是幂等的<ul>\n<li>URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</li>\n</ul>\n</li>\n<li></li>\n</ul>\n</li>\n<li>status codes<ul>\n<li><strong>1xx</strong>：表示目前是协议处理的中间状态，还需要后续操作</li>\n<li><strong>2xx</strong>：表示成功状态，报文已收到并正确处理<ul>\n<li>204：没有响应体、206：响应体不全</li>\n</ul>\n</li>\n<li><strong>3xx</strong>：重定向状态，资源位置发生变动，需要重新请求<ul>\n<li>301：永久重定向、302：暂时重定向</li>\n<li>304：内容未更改，重定向到客户端的缓存资源</li>\n</ul>\n</li>\n<li><strong>4xx</strong>：客户端错误，请求报文有误服务器无法处理<ul>\n<li>403：禁止访问资源、404资源未找到</li>\n</ul>\n</li>\n<li><strong>5xx</strong>：服务端错误，服务器在处理请求时内部发生了错误<ul>\n<li>501 Not Implemented：表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思</li>\n<li>502 Bad Gateway：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误</li>\n<li>503 Service Unavailable：表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>header fields<ul>\n<li>Host：客户端发送请求时，用来指定服务器的域名，可以将请求发往同一台服务器上的不同网站</li>\n<li>Content-Length ：表明本次回应的数据长度，HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题</li>\n<li>Connection：客户端要求服务器使用<strong>HTTP 长连接</strong>机制（Keep-Alive），任意一端没有明确提出断开连接，则保持 TCP 连接状态</li>\n<li>Content-Type：用于服务器回应时，告诉客户端，本次数据是什么格式<code>Content-Type: text/html; Charset=utf-8</code></li>\n<li>Accept：客户端请求的时候，声明自己可以接受哪些数据格式<code>Accept: */*</code></li>\n<li>Content-Encoding：表示服务器返回的数据使用了什么压缩格式；Accept-Encodin：说明客户端可以接受哪些压缩方法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>HTTP缓存：通过将不变的请求-响应数据缓存在本地提升性能<ul>\n<li>强制缓存：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边<ul>\n<li>实现：<code>Cache-Control</code>（一个相对时间）、<code>Expires</code>（一个绝对时间），建议使用<code>Cache-Control</code><ul>\n<li>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；</li>\n<li>浏览器再次请求访问服务器中的该资源时，会先<strong>通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期</strong>，如果没有，则使用该缓存，否则重新请求服务器；</li>\n<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>协商缓存：与服务端协商之后，通过协商结果来判断是否使用本地缓存<ul>\n<li>实现：使用请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段或 <code>Last-Modified</code>两种方式来实现，ETag用来唯一标识资源，Last-Modified用来记录修改时间，由于时间粒度大并且会被恶意修改，所以推荐使用ETag</li>\n<li>服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：<ul>\n<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>\n<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>性能优化<ul>\n<li>尽量避免发送 HTTP 请求：缓存</li>\n<li>在需要发送 HTTP 请求时，考虑如何减少请求次数<ul>\n<li>使用代理服务器减少重定向请求次数</li>\n<li>合并请求：使用<code>CSS Image Sprites</code>技术；使用 <code>webpack</code> 等打包工具将 js、css 等资源合并打包</li>\n<li>延迟发送请求：请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果</li>\n</ul>\n</li>\n<li>减少服务器的 HTTP 响应的数据大小：无损压缩（gzip）、有损压缩（<strong>WebP</strong>）</li>\n</ul>\n</li>\n<li>session&amp;cookie<ul>\n<li>cookie：客户端保存用户信息的一种机制，将服务器发送到浏览器的数据保存在本地，下次向同一服务器再发起请求时被携带发送，<strong>解决HTTP无状态的问题，可以保持用户登录状态</strong></li>\n<li>session：Session是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。客户端关闭会话，或者Session超时失效时会话结束</li>\n<li>目前大多数的应用都是用Cookie实现Session跟踪的。第一次创建Session时，服务端会通过在HTTP协议中返回给客户端，在Cookie中记录SessionID，后续请求时传递SessionID给服务，以便后续每次请求时都可分辨你是谁</li>\n<li>区别<ul>\n<li>作用范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。</li>\n<li>存取方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。</li>\n<li>有效期不同，Cookie可设置为长时间保持，比如默认登录功能功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。</li>\n<li>隐私策略不同，Cookie存储在客户端，信息容易被窃取；Session存储在服务端，相对安全一些。</li>\n<li>存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。</li>\n</ul>\n</li>\n<li>分布式系统中的Session：会有多个服务器处理同一业务，Session存在不同服务器上会登录失败，解决方法如下<ul>\n<li>方案一：请求精确定位。也就是通过负载均衡器让来自同一IP的用户请求始终分配到同一服务上。比如，Nginx的ip_hash策略，就可以做到</li>\n<li>方案二：Session复制共享。该方案的目标就是确保所有的服务器的Session是一致的。像Tomcat等多数主流web服务器都采用了Session复制实现Session的共享</li>\n<li>方案三：基于共享缓存。该方案是通过将Session放在一个公共地方，各个服务器使用时去取即可。比如，存放在<code>Redis</code>、Memcached等缓存中间件中</li>\n</ul>\n</li>\n<li>同源策略与跨域请求<ul>\n<li>同源：协议相同、域名相同、端口相同，主要是为了保证用户信息的安全，防止恶意的网站窃取数据<ul>\n<li>恶意网站会使用用户的Cookie来伪装成用户，窃取用户信息</li>\n</ul>\n</li>\n<li>跨域请求：请求一个与自身资源不同源的资源，浏览器设置了同源策略，但是有的时候网页中需要有跨域访问，所以W3C提供了一个解决方法（跨域资源共享CORS），浏览器将CORS请求分为两部分<ul>\n<li>简单请求：浏览器直接处理</li>\n<li>预检请求：不符合简单请求条件的请求，会在正式通信之前触发一个 **<code>OPTIONS</code>**请求进行预检。服务端收到预检请求后，会根据上述附带的信息判断是否允许跨域，浏览器会根据返回的 CORS 信息判断是否继续发送真实的请求（确认后才发实际的HTTP请求）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SSL/TLS</p>\n<ul>\n<li><p>在HTTP和TCP之间，HTTPS在进行三次握手之后还要进行SSL/TLS 的握手过程，才能进行加密报文传输。解决HTTP协议明文传输导致的：窃听信息（<strong>混合加密</strong>）、篡改响应（<strong>摘要算法</strong>）、冒充网站（<strong>数字证书</strong>）</p>\n<ul>\n<li><p>混合加密：<strong>对称加密</strong>和<strong>非对称加密</strong>结合，在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</p>\n<ul>\n<li><strong>对称加密</strong>只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>\n<li><strong>非对称加密</strong>使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>\n</ul>\n</li>\n<li><p>摘要算法：用摘要算法（哈希函数）来计算出内容的哈希值</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801164827410.png\" alt=\"image-20230801164827410\"></p>\n</li>\n<li><p>数字证书：将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的</p>\n</li>\n</ul>\n</li>\n<li><p>SSL/TLS 协议基本流程</p>\n<ul>\n<li>客户端向服务器索要并验证服务器的公钥，双方协商生产「会话秘钥」<ul>\n<li>即 SSL/TLS 的建立过程，也就是 TLS 握手阶段。TLS 的「握手阶段」涉及<strong>四次</strong>通信，使用不同的密钥交换算法，TLS 握手流程也会不一样的，现在常用的密钥交换算法有两种：RSA 算法和 ECDHE 算法。</li>\n<li>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：<ul>\n<li>TLS 握手协议就是我们前面说的 TLS 四次握手的过程，负责协商加密算法和生成对称密钥，后续用此密钥来保护应用程序数据（即 HTTP 数据）；</li>\n<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>双方采用「会话秘钥」进行加密通信</li>\n<li>SSL与TLS：SSL 是洋文 “<em>Secure Sockets Layer</em>” 的缩写，中文叫做「安全套接层」。它是在上世纪 90 年代中期，由网景公司设计的。到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是 “<em>Transport Layer Security</em>” 的缩写），中文叫做 「传输层安全协议」。很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</li>\n</ul>\n</li>\n<li><p>网络攻击常见手段</p>\n<ul>\n<li><p>IP欺骗：伪造某台主机的IP地址的技术，通过IP地址的伪装使得某台主机能够伪装另一台主机，而这台主机往往具有某种特权或者被另外的主机所信任</p>\n<ul>\n<li>示例：攻击者构造TCP数据，伪装自己的IP地址，并向服务器发送一个带有RSI位的TCP数据段，服务器接收到这样的数据后，认为该IP地址发送的连接有误，会清空缓冲区中建立好的连接。这时合法用户再发送合法数据，服务器就已经没有这样的连接了，使得服务器无法对合法用户服务</li>\n<li>缓解1：入口过滤是一种数据包过滤形式，通常在网络边缘设备上实施，用于检查传入的IP数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包</li>\n<li>缓解2：一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击</li>\n</ul>\n</li>\n<li><p>洪泛攻击：DDoS、SYN Flood、UDP Flood、HTTP Flood、DNS Flood</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>DDoS（Distributed Denial of Service，分布式拒绝服务）</p></blockquote>\n<ul>\n<li><p>DDOS</p>\n<ul>\n<li>DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用<strong>欺骗和伪装</strong>的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务</li>\n<li>如何应对<ul>\n<li><strong>高防服务器：</strong>能独立硬防御50Gbps以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点，唯一缺点就是贵</li>\n<li><strong>黑名单：</strong>设置黑名单，但是会封锁正常流量，影响正常业务</li>\n<li><strong>DDoS清洗：</strong>会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong>攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量</li>\n<li><strong>CDN加速：</strong>将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>SYN Flood</p>\n<ul>\n<li>互联网上最原始最经典的DDoS攻击，旨在耗尽可用服务器资源，致使服务器无法传输合法流量</li>\n<li>利用三次握手机制，通过工具或僵尸网络主机向服务器发送海量的不同源IP/不同源端口的TCP SYN报文，服务器响应了这些报文之后就会返回SYN-ACK报文，并生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务<ul>\n<li>常见形式<ul>\n<li>直接攻击：不伪造IP地址</li>\n<li>欺骗攻击：恶意用户伪造其发送的各个SYN数据包的IP地址</li>\n<li>分布式DDoS：通过僵尸网络，令每台分布式设备伪造其发送数据包的IP地址</li>\n</ul>\n</li>\n<li>服务器在返回SYN-ACK报文后，会有一个计时器Timer，如果超过时间还没有收到A的ACK消息，则重新发送一次SYN-ACK消息，直到重试超过一定次数才会放弃</li>\n<li>在短时面临海量连接时，SYN Flood攻击就形成了</li>\n</ul>\n</li>\n<li>解决办法主要是判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务<ul>\n<li>扩展积压工作队列：增加操作系统允许的最大半开连接数目，但需额外预留内存资源以处理各类新请求</li>\n<li>回收最先创建的 TCP 半开连接：在填充积压工作后覆盖最先创建的半开连接，这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效</li>\n<li>SYN Cookie：此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>UDP Flood</p>\n<ul>\n<li><p><strong>UDP Flood</strong>也是一种拒绝服务攻击，将大量的用户数据报协议（<strong>UDP</strong>）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因<strong>UDP</strong>泛滥而耗尽，从而导致对合法流量的拒绝服务</p>\n</li>\n<li><p>攻击原理：当服务器在特定端口接收到 </p>\n<p>UDP</p>\n<p> 数据包时，会经过两个步骤：</p>\n<ul>\n<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序</li>\n<li>如果没有程序在该端口接收数据包，则服务器使用 <strong>ICMP</strong>（ping）数据包进行响应，以通知发送方目的地不可达</li>\n</ul>\n</li>\n<li><p>如何缓解：大多数操作系统部分限制了<strong>ICMP</strong>报文的响应速率，以中断需要 ICMP 响应的<strong>DDoS</strong>攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果<strong>UDP Flood</strong>的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈</p>\n</li>\n</ul>\n</li>\n<li><p>HTTP Flood</p>\n<ul>\n<li>HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求</li>\n<li>HTTP Flood攻击有两种：<ul>\n<li><strong>HTTP GET 攻击</strong> ：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务</li>\n<li><strong>HTTP POST 攻击</strong> ： 一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止</li>\n</ul>\n</li>\n<li>防护办法<ul>\n<li>对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击</li>\n<li>Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>DNS Flood</p>\n<ul>\n<li>攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。通过中断 DNS 解析，DNS Flood攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量</li>\n<li>如何防护：DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>其他攻击</p>\n<ul>\n<li>TCP重置攻击<ul>\n<li>在 TCP重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断<ul>\n<li>一般客户端发现到达的报文对于相关连接不正确时，就会发送一个重置报文段，从而导致TCP连接的快速拆卸</li>\n</ul>\n</li>\n<li>一般只对长连接有效果，对于短连接而言，你还没攻击呢，人家已经完成了信息交换</li>\n</ul>\n</li>\n<li>中间人攻击</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>HTTP协议的演变</p>\n<ul>\n<li>HTTP/1.1 相比 HTTP/1.0 性能上的改进：<ul>\n<li>长连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。减少了 TCP 连接的重复建立和断开所造成的额外开销，<strong>减轻了服务器端的负载</strong><ul>\n<li>如果要关闭 HTTP Keep-Alive，需要在 HTTP 请求或者响应的 header 里添加 <code>Connection:close</code> 信息，也就是说，<strong>只要客户端和服务端任意一方的 HTTP header 中有 <code>Connection:close</code> 信息，那么就无法使用 HTTP 长连接的机制</strong></li>\n</ul>\n</li>\n<li>管道网络传输：即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间</strong>，但不是默认开启的</li>\n<li>对头堵塞问题：如果服务端在处理某个请求时耗时比较长，那么后续的请求的处理都会被阻塞住<ul>\n<li><strong>HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞</strong>，可以同时发多个请求但是需要响应等待服务器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>那 HTTP/2 相比 HTTP/1.1 性能上的改进：<ul>\n<li>安全传输：基于HTTPS</li>\n<li>头部压缩（HPACK算法）：通过在客户端和服务器同时维护一张头信息表，只传输索引号而不是重复传相同的头部</li>\n<li>二进制格式：不再是纯文本形式的报文，头信息和数据体都是二进制，并且统称为帧（frame），<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong></li>\n<li>并发传输：1 个 TCP 连接包含多个 Stream，Stream 里可以包含 1 个或多个 Message，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成。Message 里包含一条或者多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）<ul>\n<li>针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的</li>\n</ul>\n</li>\n<li>服务器主动推送资源：服务端不再是被动地响应，可以<strong>主动</strong>向客户端发送消息。客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</li>\n</ul>\n</li>\n<li>HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP<ul>\n<li>使用基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输</li>\n<li>QUIC协议<ul>\n<li>无队头阻塞：当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</li>\n<li>更快的连接建立：三次握手（ QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS/1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商）</li>\n<li>连接迁移：TCP通过四元组标识，Wi-Fi切换到4G时需要重新建立连接，而QUIC通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Web页面请求过程</p>\n<ol>\n<li>概览 ：HTTP解析URL（服务器名+路径名）并生成HTTP请求消息（Get/Post报文），通过DNS查询服务器名对应的IP地址（DNS请求-本地-根-顶级-权威），通过Socket委托Linux协议栈进行层层处理（TCP-IP-网卡驱动-物理网卡）；TCP协议填充头信息（端口、序号、确认号、状态位）进行三次握手、流量控制、拥塞控制，IP协议通过ip地址来确定路由方向，通过ARP协议根据ip地址得到MAC地址再通过MAC地址在以太网中传输数据；通过网卡驱动程序增加数据（报头、帧分节符、校验符）并将二进制数据转换成电信号，通过二层设备交换机通过MAC地址决定走哪个端口，通过三层设备路由器路由表来查询走哪个端口<ul>\n<li>在发送数据包时，如果目标主机不是本地局域网，填入的 MAC 地址是路由器，也就是把数据包转发给路由器，路由器一直转发下一个路由器，直到转发到目标主机的路由器，发现目标 IP 地址是自己局域网内的主机，就会 ARP 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机</li>\n</ul>\n</li>\n<li>DHCP 配置主机信息<ul>\n<li>假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。</li>\n<li>主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。</li>\n<li>该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。</li>\n<li>该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。</li>\n<li>连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。</li>\n<li>该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。</li>\n<li>主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。</li>\n</ul>\n</li>\n<li>ARP 解析 MAC 地址<ul>\n<li>主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。</li>\n<li>主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。</li>\n<li>该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。</li>\n<li>该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。</li>\n<li>DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。</li>\n<li>主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。</li>\n<li>网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。</li>\n</ul>\n</li>\n<li>DNS 解析域名<ul>\n<li>知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。</li>\n<li>网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。</li>\n<li>因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。</li>\n<li>到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。</li>\n<li>找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。</li>\n</ul>\n</li>\n<li>HTTP 请求页面<ul>\n<li>有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。</li>\n<li>在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。</li>\n<li>HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。</li>\n<li>连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。</li>\n<li>HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。</li>\n<li>浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。</li>\n</ul>\n</li>\n</ol>\n</li>\n<li><p>网络分层</p>\n<ul>\n<li><p>TCP/IP四层协议：网络接口层、网络层、传输层、应用层</p>\n<ul>\n<li>网络接口层：MAC地址<ul>\n<li>物理层<ul>\n<li>物理信道：单工通信（无线电广播）、半双工通信（对讲机）、全双工通信（手机打电话）</li>\n<li>物理设备：交换机（连接多段网线）、调制解调器（将数字信号转换成电话线的模拟信号或光信号）</li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>在一条链路上传输数据时，需要有对应的通信协议来控制数据的传输<ul>\n<li>广播信道：CSMA/CD协议，如同轴电缆、集线器等组成的网络</li>\n<li>点对点信道：PPP协议，如2个路由器之间的信道</li>\n</ul>\n</li>\n<li>数据链路层的3个基本问题<ul>\n<li>封装成帧：帧的数据部分就是网络层传递下来的数据包，帧的最大长度为MTU（1500字节）</li>\n<li>透明传输：完整的数据使用SOH作为开始，使用EOT作为结束，与标志相同的数据会被转义传输，到达后被还原</li>\n<li>差错检验：帧尾部有一个FCS字段，是根据数据部分和数据链路层首部计算得出的，可以用来检验接收到的消息对错</li>\n</ul>\n</li>\n<li>CSMA/CD：载波侦听多路访问/冲突检测，用来支持单用通信和半双工通信</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>网络层：IP、ARP（IP解析为MAC）、DHCP（获取IP）、ICMP（ping的底层实现）、NAT（网关内复用IP，将私有IP转换为公网IP）、OSPF和BGP（动态路由协议，确定走哪个路由器）</li>\n<li>传输层：TCP（流量控制、超时重传、拥塞控制）、UDP（实时性好传输效率高）、Socket编程</li>\n<li>应用层：HTTP协议（超文本传输协议）、FTP（文件传输协议）、DNS（将域名转换为IP地址）、SMTP（邮件传输协议）、Telnet（使用命令行与服务器通信）</li>\n</ul>\n</li>\n<li><p>OSI七层：（物理层、数据链路层）；网络层；传输层；（会话层、表示层、应用层）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801103658645.png\" alt=\"image-20230801103658645\"></p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><h3 id=\"1-Sockets\"><a href=\"#1-Sockets\" class=\"headerlink\" title=\"1.Sockets\"></a>1.Sockets</h3><ol>\n<li><p>socket 是什么？</p>\n<ul>\n<li>sock（或 socket）是操作系统内核提供的一种数据结构，用于实现网络传输功能</li>\n<li>基于不同的网络协议以及应用场景，衍生了各种类型的 sock。每个网络层协议都有相应的 sock 结构体来管理该层协议的连接状态和数据传输。各类 sock 操作硬件网卡，就实现了网络传输的功能</li>\n<li>为了将这些功能让处在用户态的应用程序使用，不但引入了 socket 层，还将各类功能的实现方式抽象成了 API 接口，供应用程序调用</li>\n<li>同时将 sock 封装成文件，应用程序就可以在用户层通过文件句柄（socket fd）来操作内核中 sock 的网络传输功能。这个 socket fd 是一个 int 类型的数字，而 socket 中文翻译叫做套接字，结合这个 socket fd，你是不是可以将其理解成：一套用于连接的数字</li>\n<li>而 socket 分 Internet socket 和 UNIX Domain socket，两者都可以用于不同主机进程间的通信和本机进程间的通信。只是前者采用的是基于 IP 协议的网络通信方式，而后者采用的是基于本地文件系统的通信方式</li>\n<li></li>\n</ul>\n</li>\n<li><p>网络包接收流程</p>\n<ul>\n<li><p>网卡会将收到的网络数据帧通过<code>DMA</code>的方式放到环形缓冲区<code>RingBuffer</code>（环形缓冲区，满了就丢弃）中（可通过ifconfig命令查看网卡收发数据的情况），<code>DMA</code>操作完后网卡会向<code>CPU</code>发起一个硬中断，对应中断处理程序为网络数据帧创建内核数据结构<code>sk_buffer</code>（<code>sk_buffer</code>是双向链表，每一个元素是一个网络帧，网络各层之间操作相关指针而不是复制数据）并拷贝收到的网络数据帧，然后向<code>kernel</code>发起软中断请求（软中断和硬中断在同一个CPU核上）</p>\n<ul>\n<li>为了解决频繁中断带来的性能开销，Linux 2.6 版本引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是不采用中断的方式读取数据，而是<strong>首先采用中断唤醒数据接收的服务程序，然后 <code>poll</code> 的方法来轮询数据</strong></li>\n<li>硬中断：先暂时屏蔽中断，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。接着，发起<strong>软中断</strong>，然后恢复刚才屏蔽的中断。</li>\n</ul>\n</li>\n<li><p>内核线程<code>ksoftirqd</code>（一个CPU一个）响应软中断请求，调用网卡驱动注册的<code>poll</code>函数，<code>poll</code>函数将<code>sk_buffer</code>中的网络数据包送到内核协议栈中注册的<code>ip_rcv</code>函数</p>\n</li>\n<li><p><code>ip_rcv</code>函数处在网络层，该函数取出IP头并判断下一跳走向，如果是本机则取出传输层协议类型（TCP或UDP），并去掉数据包的IP头，将数据包交给传输层处理（TCP协议使用<code>tcp_rcv</code>函数，UDP协议使用<code>udp_rcv</code>函数）</p>\n</li>\n<li><p><code>tcp_rcv</code>函数会去掉TCP头，根据<code>四元组（源IP、源端口、目的IP，目的端口）</code>查找对应的<code>Socket</code>，如果找到则将数据包中的数据拷贝到<code>Socket</code>中的接收缓冲区，否则发送一个目标不可达的<code>icmp</code>包</p>\n</li>\n<li><p>当程序调用<code>read</code>读取<code>Socket</code>接收缓冲区的数据时，如果接收缓冲区没有数据则会阻塞在系统调用上，知道<code>Socket</code>接收缓冲区有数据。然后<code>CPU</code>将内核空间（Socket接收缓冲区）的数据拷贝到用户空间，最后系统调用<code>read</code>返回，应用程序读取数据</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730151700051.png\" alt=\"image-20230730151700051\"></p>\n</li>\n</ul>\n</li>\n<li><p>网络包发送流程</p>\n<ul>\n<li><p>应用程序调用send发送数据，kernel首先根据fd找到对应的socket（包含各种协议栈的函数地址），然后构造<code>msghdr</code>对象封装用户要发送的数据。调用内核函数inet_sendmsg发送流程进入内核协议栈来处理，找到socket上具体协议的发送函数（TCP协议发送函数<code>tcp_sendmsg</code>，UDP协议发送函数<code>udp_sendmsg</code>）</p>\n<ul>\n<li><code>tcp_sendmsg</code>函数内部创建内核数据结构<code>sk_buffer</code>将<code>msghdr</code>中的数据拷贝到<code>sk_buffer</code>中，调用<code>tcp_write_queue_tail</code>函数获取Socket发送队列中的队尾元素，将<code>sk_buffer</code>添加到<code>socket</code>发送队列（双向链表）的尾部</li>\n<li>此时数据已经被拷贝到内核，但是因为TCP的流量控制和拥塞控制，所以数据并不会被马上发送，需要符合TCP协议的发送条件。如果没有达到发送条件则本次<code>send</code>系统调用就会直接返回，如果符合发送条件，则调用<code>tcp_write_xmit</code>内核函数，循环获取<code>socket</code>发送队列中待发送的<code>sk_buffer</code>，然后进行拥塞控制和滑动窗口管理</li>\n<li>发送网络数据的时候，涉及几次内存拷贝操作？<ul>\n<li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 sk_buff 内存，将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区。</li>\n<li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 sk_buff 都会被克隆一个新的副本出来。副本 sk_buff 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 sk_buff 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 sk_buff 。</li>\n<li>第三次，当 IP 层发现 sk_buff 大于 MTU 时才需要进行。会再申请额外的 sk_buff，并将原来的 sk_buff 拷贝为多个小的 sk_buff。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>将从socket发送队列中获取到的sk_buffer重新拷贝一份，并设置sk_buffer副本中的TCP HEADER</p>\n<ul>\n<li><p>sk_buffer 内部其实包含了网络协议中所有的 header。在设置 TCP HEADER的时候，只是把指针指向 sk_buffer的合适位置。后面再设置 IP HEADER的时候，在把指针移动一下就行，避免频繁的内存申请和拷贝，效率很高</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230730150639810.png\" alt=\"image-20230730150639810\"></p>\n</li>\n<li><p>为什么不直接使用Socket发送队列中的sk_buffer而是需要拷贝一份呢？因为TCP协议是支持丢包重传的，在没有收到对端的ACK之前，这个sk_buffer是不能删除的。内核每次调用网卡发送数据的时候，实际上传递的是sk_buffer的拷贝副本，当网卡把数据发送出去后，sk_buffer拷贝副本会被释放。当收到对端的ACK之后，Socket发送队列中的sk_buffer才会被真正删除</p>\n</li>\n<li><p>为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包：sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame，通过调整 sk_buff 中 <code>data</code> 的指针来实现</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801105354758.png\" alt=\"image-20230801105354758\"></p>\n</li>\n</ul>\n</li>\n<li><p>调用ip_queue_xmit内核函数进行网络层的处理</p>\n<ul>\n<li>将<code>sk_buffer</code>中的指针移动到<code>IP头</code>位置上，设置<code>IP头</code></li>\n<li>执行<code>netfilters</code>过滤。过滤通过之后，如果数据大于 <code>MTU</code>的话，则执行分片</li>\n<li>检查<code>Socket</code>中是否有缓存路由表，如果没有的话，则查找路由项，并缓存到<code>Socket</code>中。接着在把路由表设置到<code>sk_buffer</code>中</li>\n</ul>\n</li>\n<li><p>邻居子系统</p>\n<ul>\n<li><code>邻居子系统</code>位于内核协议栈中的<code>网络层</code>和<code>网络接口层</code>之间，用于发送<code>ARP请求</code>获取<code>MAC地址</code>，然后将<code>sk_buffer</code>中的指针移动到<code>MAC头</code>位置，填充<code>MAC头</code>，此时<code>sk_buffer</code>中已经封装了一个完整的数据帧</li>\n</ul>\n</li>\n<li><p>网络设备子系统</p>\n<ul>\n<li><p>选择发送队列（<code>RingBuffer</code>），因为网卡拥有多个发送队列，所以在发送前需要选择一个发送队列</p>\n</li>\n<li><p>将<code>sk_buffer</code>添加到发送队列中</p>\n</li>\n<li><p>循环从发送队列（<code>RingBuffer</code>）中取出<code>sk_buffer</code>，调用内核函数<code>sch_direct_xmit</code>发送数据，其中会调用<code>网卡驱动程序</code>来发送数据</p>\n</li>\n</ul>\n</li>\n<li><p>无论是用户线程的内核态还是触发<code>NET_TX_SOFTIRQ</code>类型的软中断在发送数据的时候最终会调用到网卡的驱动程序函数<code>dev_hard_start_xmit</code>来发送数据。在网卡驱动程序函数<code>dev_hard_start_xmit</code>中会将<code>sk_buffer</code>映射到网卡可访问的内存 DMA 区域，最终网卡驱动程序通过<code>DMA</code>的方式将数据帧通过物理网卡发送出去</p>\n<ul>\n<li>前文a-e是用户线程的内核态在执行，占用的CPU时间是系统态时间(<code>sy</code>)，当分配给用户线程的<code>CPU quota</code>用完的时候，会触发<code>NET_TX_SOFTIRQ</code>类型的软中断，内核线程<code>ksoftirqd</code>会响应这个软中断，并执行<code>NET_TX_SOFTIRQ</code>类型的软中断注册的回调函数<code>net_tx_action</code>，在回调函数中会执行到驱动程序函数 <code>dev_hard_start_xmit</code>来发送数据</li>\n<li>从这里可以看到网络包的发送过程和接受过程是不同的，在介绍网络包的接受过程时，通过触发<code>NET_RX_SOFTIRQ</code>类型的软中断在内核线程<code>ksoftirqd</code>中执行内核网络协议栈接受数据。而在网络数据包的发送过程中是用户线程的内核态在执行内核网络协议栈，只有当线程的<code>CPU quota</code>用尽时，才触发<code>NET_TX_SOFTIRQ</code>软中断来发送数据</li>\n<li>在整个网络包的发送和接受过程中，<code>NET_TX_SOFTIRQ</code>类型的软中断只会在发送网络包时并且当用户线程的<code>CPU quota</code>用尽时，才会触发。剩下的接受过程中触发的软中断类型以及发送完数据触发的软中断类型均为<code>NET_RX_SOFTIRQ</code>。所以这就是在服务器上查看 <code>/proc/softirqs</code>，一般 <code>NET_RX</code>都要比 <code>NET_TX</code>大很多的的原因</li>\n</ul>\n</li>\n<li><p>当数据发送完毕后，还有最后一项重要的工作，就是清理工作。数据发送完毕后，网卡设备会向CPU发送一个硬中断，CPU调用网卡驱动程序注册的硬中断响应程序，在硬中断响应中触发NET_RX_SOFTIRQ类型的软中断，在软中断的回调函数igb_poll中清理释放 sk_buffer，清理网卡发送队列（RingBuffer），解除DMA映射</p>\n<ul>\n<li>无论硬中断是因为有数据要接收，还是说发送完成通知，从硬中断触发的软中断都是 <code>NET_RX_SOFTIRQ</code></li>\n<li>这里释放清理的只是<code>sk_buffer</code>的副本，真正的<code>sk_buffer</code>现在还是存放在<code>Socket</code>的发送队列中。前面在传输层处理的时候我们提到过，因为传输层需要保证可靠性，所以 <code>sk_buffer</code>其实还没有删除。它得等收到对方的 ACK 之后才会真正删除</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-网络设备\"><a href=\"#2-网络设备\" class=\"headerlink\" title=\"2.网络设备\"></a>2.网络设备</h3><ul>\n<li>路由器和交换机的区别<ul>\n<li><strong>工作层次不同：</strong><ul>\n<li>交换机主要工作在数据链路层（第二层）</li>\n<li>路由器工作在网络层（第三层）</li>\n</ul>\n</li>\n<li><strong>转发依据不同：</strong><ul>\n<li>交换机转发所依据的对象时：MAC地址。（物理地址）</li>\n<li>路由转发所依据的对象是：IP地址。（网络地址），因为只处理MAC地址匹配路由器的网络爆</li>\n</ul>\n</li>\n<li><strong>主要功能不同：（交换机能做的，路由都能做。）</strong><ul>\n<li>交换机主要用于组建局域网，不能分割广播域</li>\n<li>而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet，可以提供防火墙功能</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-命令行\"><a href=\"#3-命令行\" class=\"headerlink\" title=\"3.命令行\"></a>3.命令行</h3><ul>\n<li><p><code>netstat -napt</code>：查看TCP的连接状态</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801093314230.png\" alt=\"image-20230801093314230\"></p>\n</li>\n<li><p><code>route -n</code>：查看当前系统的路由表，将目的IP与掩码与操作得到的结果与Destination比较，相同则走对应的iface（网卡）</p>\n<ul>\n<li>第三条是默认网关：如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器（Gateway即对应路由器的IP地址）</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801093423564.png\" alt=\"image-20230801093423564\"></p>\n</li>\n<li><p><code>arp -a</code> 查看 ARP 缓存的内容，记录IP与MAC的映射关系</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230801095015812.png\" alt=\"image-20230801095015812\"></p>\n</li>\n</ul>\n","feature":true,"text":"Internet1.网络层 IP 查看IP地址：ifconfig、ip addr scope：如果是global，则此张网卡是可以对外开放的，可以接受各个地方的包；对于lo来说事host，说明这张网卡仅仅可以供本机相互通信 lo全称是loopback，又称环回接口，往往会被分配到...","link":"","photos":[],"count_time":{"symbolsCount":"27k","symbolsTime":"25 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Internet\"><span class=\"toc-text\">Internet</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BD%91%E7%BB%9C%E5%B1%82\"><span class=\"toc-text\">1.网络层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BC%A0%E8%BE%93%E5%B1%82\"><span class=\"toc-text\">2.传输层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%BA%94%E7%94%A8%E5%B1%82\"><span class=\"toc-text\">3.应用层</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95\"><span class=\"toc-text\">附录</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Sockets\"><span class=\"toc-text\">1.Sockets</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87\"><span class=\"toc-text\">2.网络设备</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%91%BD%E4%BB%A4%E8%A1%8C\"><span class=\"toc-text\">3.命令行</span></a></li></ol></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"Tools","uid":"7092a7d1e2affc5f0cb3af30af9d1e19","slug":"Tools","date":"2023-07-30T02:37:14.000Z","updated":"2023-08-02T14:22:51.114Z","comments":true,"path":"api/articles/Tools.json","keywords":null,"cover":[],"text":"1.markdown 框架 多级标题：#与后面文本有一个空格，标题行前后建议空行 Markdown HTML # Heading level 1 Heading level 1 ## Heading level 2 Heading level 2 ### Heading leve...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}