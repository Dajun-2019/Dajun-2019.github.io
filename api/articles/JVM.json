{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2023-07-30T02:35:00.000Z","updated":"2023-09-26T04:50:33.955Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"content":"<h1 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h1><h2 id=\"1-编译执行\"><a href=\"#1-编译执行\" class=\"headerlink\" title=\"1.编译执行\"></a>1.编译执行</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何实现跨平台：通过不同平台的JVM实现来将相同的一个Class文件翻译成适配不同机器的机器语言用于执行，即使打包成可还行文件仍需要JVM的支持</p></blockquote>\n<ol>\n<li><p>Java程序的执行过程</p>\n<ul>\n<li>JAVA源代码编译成字节码；字节码校验并把JAVA程序通过类加载器加载到JVM内存中，在加载到内存后针对每个类创建Class对象并放到方法区；字节码指令和数据初始化到内存中；</li>\n<li>找到main方法，并创建栈帧；初始化程序计数器内部的值为main方法的内存地址；</li>\n<li>程序计数器不断递增，逐条执行JAVA字节码指令，把指令执行过程的数据存放到操作数栈中（入栈），执行完成后从操作数栈取出后放到局部变量表中，遇到创建对象，则在堆内存中分配一段连续的空间存储对象，栈内存中的局部变量表存放指向堆内存的引用；遇到方法调用则再创建一个栈帧，压到当前栈帧的上面。</li>\n</ul>\n</li>\n<li><p>编译链接：前端编译、类加载、解释执行、JIT编译执行</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731142827084.png\" alt=\"image-20230731142827084\"></p>\n<ul>\n<li><p>前端编译：将<code>.java</code>文件编译成<code>.class</code>文件，由javac编译器来完成，通过词法分析、语法分析、语义分析等方法将源代码翻译成字节码，并且还包括特有的注解处理、解语法糖操作</p>\n<ul>\n<li><p>注解处理：JDK6开始，可以开发注解插件，前端编译会调用注解插件如Lombok根据<code>@getter</code>、<code>@setter</code>为类的变量生成方法</p>\n</li>\n<li><p>解语法糖：Java一开始就注重开发效率，所以Java很适合做业务系统开发，C/C++更适合做底层的系统级开发，为了提高效率，通过对基本语法进行二次封装，来提高易用性，在前端编译的时候会还原为基本语法</p>\n<ul>\n<li><p>泛型：类型擦除，只用于编译时的类型检查</p>\n</li>\n<li><p>自动拆装箱：方便基本类型和包装类的互相转换，底层使用valueof、xxxvalue实现</p>\n</li>\n<li><p>for-each循环：底层依赖迭代器遍历</p>\n</li>\n<li><p>匿名内部类：单独生成一个class文件，名字由JVM指定如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class A&#123;&#x2F;&#x2F;A.class\n  public class B&#123;&#125;&#x2F;&#x2F;内部类，编译为A$B.class\n  public void f()&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;&#x2F;&#x2F;匿名内部类，编译为A$1.class\n      @Override\n      public void run()&#123;\n        System.out.println(&quot;anonymous inner class.&quot;);\n      &#125;\n    &#125;);\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类加载</p>\n<ul>\n<li>在Java应用中，类的字节码是按需加载到内存中的，当第一次创建某个类的对象，或调用某个类的方法时，会将这个类加载到内存中，之后便一直保存在内存中</li>\n<li>类加载过程包括验证、准备、解析、初始化等步骤，类的加载遵从双亲委派机制，不同的类有不同的classLoader加载器来加载</li>\n</ul>\n</li>\n<li><p>解释执行</p>\n<ul>\n<li>对于C/C++，代码会被事先编译出机器指令（可执行文件），然后再交由CPU来执行；对于Java来说，编译出的.class文件，需要由JVM逐条取出，边解释为机器码，边交由CPU执行</li>\n<li>比如说在使用Demo类对象的创建语句时，如果内存中没有Demo类的字节码信息，会通过类加载器在classpath对应的路径下查找Demo.class，并将其加载到内存中，后续虚拟机根据对象demo中的类指针，找到内存中的Demo类，然后在类的方法中找函数对应的字节码，逐句解释执行</li>\n</ul>\n</li>\n<li><p>JIT编译执行</p>\n<ul>\n<li>解释执行的效率比较低，所以引入JIT（Just-In-Time）编译执行，对于一些热点代码，可以将其编译为机器码并存储下来，跳过解释执行</li>\n<li>AOT（Ahead Of Time Compile）编译，运行前编译，类似于C/C++的编译（移植性由程序员来运行），但是仍支持一次编写，到处运行的特点，代码的可移植性有AOT编译器来负责</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JIT编译：JIT编译器及JVM运行模式（Client、Server）、分层编译（解释执行、不带/部分/所有编译优化的Client、Server）、热点探测（优化的对象是方法方法，调用计数器、回边计数器、阈值、调用计数器的热度衰减机制）</p>\n<ul>\n<li>JIT编译器<ul>\n<li>HotSpot支持两种JIT编译器<ul>\n<li>Client编译器（C1编译器）：只进行局部的编译优化，编译时间短，编译优化程度低</li>\n<li>Server编译器（C2编译器）：进行局部和全局优化，编译时间长，编译优化程度高</li>\n</ul>\n</li>\n<li>有两种JIT编译器引出JVM有两种运行模式，Client模式和Server模式，对于长时间运行的服务器程序，可以使用Server模式</li>\n</ul>\n</li>\n<li>分层编译<ul>\n<li>Java7之前只能通过参数指定，但是Java7引入了分层编译的技术，JVM可以根据代码、运行情况来选择不同的编译类型，主要分为5个层级（见下），Java8开始默认开启分层编译技术，关闭时直接使用Server编译器<ul>\n<li>解释执行</li>\n<li>使用不带编译优化的Client编译器</li>\n<li>使用仅带部分编译优化的Client编译器</li>\n<li>使用带有所有编译优化的Client编译器</li>\n<li>使用Server编译器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>热点探测<ul>\n<li>热点代码：主要包括被多次执行的方法和被多次执行的循环，JIT编译的对象是方法，对循环的编译是循环编译循环所在方法</li>\n<li>计数器：HotSpot使用计数器来统计方法或循环的执行次数，分别为方法调用计数器（方法的执行次数）和回边计数器（方法内循环的执行次数）</li>\n<li>阈值：调用计数器和回边计数器的总和超过阈值，JVM就会进行JIT编译<ul>\n<li>Client编译器：1500</li>\n<li>Server编译器：10000</li>\n<li>分层编译：动态阈值，根据当前编译方法数以及编译线程数动态计算得到</li>\n</ul>\n</li>\n<li>热度衰减机制：防止因为运行时间长而超过阈值的代码被判定为成热点代码，此机制（通过<code>-XX:-UseCounterDecay</code>开关）在超过一定的时间（通过<code>-XX:CounterHalfLifeTIme</code>设置）限制之后，如果某个方法没有达到触发JIT编译的阈值要求，那么这个方法的方法计数器的值就减半，回边计数器不存在此机制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>编译优化：JIT编译优化策略（方法内联、逃逸分析、无用代码消除、循环展开、消除公共子表达式、范围检查消除、空值检查消除）</p>\n<ul>\n<li>减少无效、冗余代码，以便生成高效的机器码</li>\n<li>JIT编译优化策略<ul>\n<li>方法内联：达到阈值的方法嵌入、final方法触发内联<ul>\n<li>将短小的函数嵌入到函数调用处，通过内存的增加减少时间的消耗</li>\n<li>内联要求：<ul>\n<li>函数短小（字节码小于325字节）+调用次数（大于等于100次）</li>\n<li>字节码（小于35字节）+方法调用次数（少于100次）</li>\n</ul>\n</li>\n<li>final：final方法会触发方法内联，特别是多态的情况下，因为final声明的函数不会被重载，所以可以直接通过类的方法来内联，而不用分析是否有重载变化函数的情况</li>\n</ul>\n</li>\n<li>逃逸分析：栈上分配（将对象分配到栈上）、标量替换（使用基本类型替换对象的成员变量）、锁消除（去掉无多线程并发访问的代码）<ul>\n<li>JIT编译器通过分析对象的使用范围来优化对象的内存存储方式和访问方式，针对不同的逃逸分析结果，有三种策略<ul>\n<li>栈上分配：编译器分析完，发现某个对象使用范围仅限于某个函数内部（没有逃逸到方法外），就可以启动栈上分配编译优化，将对象作为局部变量直接分配在栈上</li>\n<li>标量替换：如果某个对象只在某个函数内使用，并且函数内只访问对象的基本类型成员变量等标量数据，就可以使用基本类型变量替代对象</li>\n<li>锁消除：对不存在多线程并发访问的代码（逃逸到线程外），编译器会去掉其中保证线程安全的加锁逻辑</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类文件（class文件）结构详解</p>\n<ul>\n<li><p>class文件由ClassFile结构定义，类似于C语言的结构体</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ClassFile &#123;\n    u4             magic; &#x2F;&#x2F;Class 文件的标志，确定这个文件是否是一个能被虚拟机接收的class文件\n    u2             minor_version;&#x2F;&#x2F;Class 的小版本号\n    u2             major_version;&#x2F;&#x2F;Class 的大版本号\n    u2             constant_pool_count;&#x2F;&#x2F;常量池的数量\n    cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池，计数器从1开始，0项代表不引用任何一个常量池选项\n    u2             access_flags;&#x2F;&#x2F;Class 的访问标记，标识class是类还是接口，是否为public或者abstract，是否声明final\n    u2             this_class;&#x2F;&#x2F;当前类\n    u2             super_class;&#x2F;&#x2F;父类 Object的父类索引为0\n    u2             interfaces_count;&#x2F;&#x2F;接口\n    u2             interfaces[interfaces_count];&#x2F;&#x2F;一个类可以实现多个接口\n    u2             fields_count;&#x2F;&#x2F;Class 文件的字段属性\n\n\t\t&#x2F;&#x2F;字段作用域、字段的名称、字段和方法的描述符、字段的额外属性、具体属性具体内容\n    field_info     fields[fields_count];&#x2F;&#x2F;一个类可以有多个字段，用于描述接口或类中声明的变量\n    u2             methods_count;&#x2F;&#x2F;Class 文件的方法数量\n\n\t\t&#x2F;&#x2F;方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项\n    method_info    methods[methods_count];&#x2F;&#x2F;一个类可以有个多个方法\n    u2             attributes_count;&#x2F;&#x2F;此类的属性表中的属性数\n    attribute_info attributes[attributes_count];&#x2F;&#x2F;属性表集合\n&#125;</code></pre></li>\n<li><p>示例</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731143720818.png\" alt=\"image-20230731143720818\"></p>\n</li>\n</ul>\n</li>\n<li><p>new一个对象的过程</p>\n<ul>\n<li>类加载：首先，JVM会检查并加载该类的字节码文件。如果该类还没有被加载，它将被加载到内存中。</li>\n<li>分配内存：一旦类被加载，JVM会为对象分配内存空间。这通常发生在堆内存中，但也可能在某些情况下发生在栈上</li>\n<li>初始化：在分配内存后，JVM会调用类的构造函数（构造方法）来初始化对象。构造函数负责为对象的属性设置初始值，也可以执行其他初始化任务。这个过程可能涉及到其他对象的创建和初始化。</li>\n<li>对象创建完成：一旦构造函数执行完毕，对象就被认为是完全创建好的，可以在程序中使用。</li>\n<li>对象使用：你可以在程序中使用该对象，访问其属性和方法。</li>\n<li>对象不再被引用：当对象不再被任何引用变量引用时，它就成为不可达对象。这时，该对象就变得可被垃圾收集器回收。</li>\n<li>垃圾回收：JVM的垃圾收集器会定期扫描堆内存，找出不可达对象，并释放其占用的内存。这个过程被称为垃圾回收。</li>\n</ul>\n</li>\n<li><p>类卸载</p>\n<ul>\n<li>卸载类需要满足 3 个要求：<ul>\n<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li>\n<li>该类没有在其他任何地方被引用</li>\n<li>该类的类加载器的实例已被 GC</li>\n</ul>\n</li>\n<li>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的</li>\n<li>JDK 自带的<code>BootstrapClassLoader</code>、<code>ExtClassLoader</code>、<code>AppClassLoader</code>负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-类加载器\"><a href=\"#2-类加载器\" class=\"headerlink\" title=\"2.类加载器\"></a>2.类加载器</h2><ol>\n<li><p>类加载：类加载过程（验证、准备、解析、初始化）、类加载器（启动类加载器、扩展类加载器、应用程序类加载器）</p>\n<ul>\n<li><p>类加载过程：JVM将类的二进制字节码加载到内存中，以便创建类的对象或者执行类上的方法</p>\n<ul>\n<li><p>验证：验证所加载的类字节码格式是否符合JVM规范，防止被恶意篡改，由四个检验阶段组成</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731151203855.png\" alt=\"image-20230731151203855\"></p>\n</li>\n<li><p>准备：虚拟机为类的静态变量分配内存，并初始化为默认值</p>\n<ul>\n<li>对于static final修饰的静态常量，直接初始化指定值</li>\n<li>对于只有static修饰的变量，初始化为默认值（0、null、false等）而不是代码指定值，指定值会在下面的初始化阶段赋予</li>\n</ul>\n</li>\n<li><p>解析：解析类似C++中的链接，把类字节码的常量池中的符号引用（间接引用）转换为直接引用</p>\n<ul>\n<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行</li>\n</ul>\n</li>\n<li><p>初始化：虚拟机执行静态变量的初始化代码，包括初始化语句（<code>private static int a = 25;</code>）、静态代码块（<code>static &#123; a = 13; &#125;</code>），这一步JVM才开始真正执行类中定义的Java程序代码，只有以下5种情况必须对类进行初始化</p>\n<ul>\n<li>当遇到 new、 getstatic、putstatic 或 invokestatic这 4 条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。<ul>\n<li>当 jvm 执行 <code>new</code> 指令时会初始化类。即当程序创建一个类的实例对象。</li>\n<li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。</li>\n<li>当 jvm 执行 <code>putstatic</code> 指令时会初始化类。即程序给类的静态变量赋值。</li>\n<li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li>\n</ul>\n</li>\n<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时如 <code>Class.forname(&quot;...&quot;)</code>, <code>newInstance()</code> 等等。如果类没初始化，需要触发其初始化。</li>\n<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>\n<li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 <code>main</code> 方法的那个类)，虚拟机会先初始化这个类。</li>\n<li><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li>\n<li>补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类加载机制：启动类加载器、扩展类加载器、应用程序类加载器、双亲委派机制</p>\n<ul>\n<li>JVM定义的类加载器<ul>\n<li>启动类加载器（BootStrap ClassLoader）：负责加载<code>$JAVA_HOME/jre/lib/rt.jar</code>包中的类</li>\n<li>扩展类加载器（Extension ClassLoader）：负责加载<code>$JAVA_HOME/jre/lib/ext</code>目录下的jar包中的类</li>\n<li>应用程序类加载器（Application ClassLoader）：负责加载<code>classpath</code>所指定路径下的其余类</li>\n</ul>\n</li>\n<li>双亲委派机制：见下2</li>\n</ul>\n</li>\n<li><p>自定义类加载器：继承自ClassLoader类的子类，重写findClass函数，可以指定父类加载器</p>\n<ul>\n<li><p>定义继承自<code>ClassLoader</code>类的子类，重写<code>findClas</code>函数（<code>loadClass</code>方法可以加载指定二进制名称的类）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;从文件系统的绝对路径下读取类的二进制字节码，通过调用CLassLoader的defineClass函数将二进制的\n&#x2F;&#x2F;字节码转化成Class对象，以此来实现一个加载特定路径下的类的加载器\npublic class FileSystemClassLoader extends ClassLoader&#123;\n  private String rootDir;\n\t&#x2F;&#x2F;通过构造函数指定父类加载器\n  public FileSystemClassLoader(String rootDir)&#123;\n    this.rootDir &#x3D; rootDir;\n  &#125;\n\n  @Override\n  protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123;\n\t\t&#x2F;&#x2F;绝对路径\n    String path &#x3D; rootDir + File.separatorChar + name.replace(&#39;.&#39;, File.separatorChar) + &quot;.class&quot;;\n    byte[] bytecode &#x3D; null;\n\t\t\n    try(InputStream input &#x3D; new FileInputStream(path))&#123;\n      ByteArrayOutputStream byteStream &#x3D; new ByteArrayOutputStream();\n      byte[] buffer &#x3D; new byte[4096];\n      int readSize &#x3D; 0;\n\t\t\t&#x2F;&#x2F;读入二进制字节码\n      while((readSize &#x3D; input.read(buffer)) !&#x3D; -1)&#123;\n\t\t\t\t&#x2F;&#x2F;写出到流中\n        byteStream.write(buffer, 0, readSize);\n      &#125;\n\t\t\t&#x2F;&#x2F;写入到字节数组\n      bytecode &#x3D; byteStream.toByteArray();\n    &#125;catch(FileNotFoundException | IOException e)&#123;\n      e.printStackTrace();\n    &#125;\n    if(bytecode &#x3D;&#x3D; null)&#123;\n      throw new ClassNotFoundException(&quot;class name:&quot; + name);\n    &#125;else&#123;\n\t\t\t&#x2F;&#x2F;生成class对象\n      return defineClass(name, bytecode, 0, bytecode.length);\n    &#125;\n  &#125;\n&#125;\npublic class Demo&#123;\n  public static void main(Stringp[] args) throws ClassNotFoundException&#123;\n    ClassLoader classLoader &#x3D; new FileSystemClassLoader(&quot;&#x2F;Users&#x2F;dajunnnnnn&quot;);\n    Class&lt;?&gt; clazz &#x3D; classLoader.loadCLass(&quot;com.code.hello&quot;);\n    System.out.println(clazz.getClassLoader());&#x2F;&#x2F;打印SystemFileClassLoader对象信息\n  &#125;\n&#125;</code></pre></li>\n<li><p><code>ClassLoader</code>是一个模版方法模式类，其中的<code>loadClass</code>函数是模版方法，里面包含类加载的整个逻辑，比如双亲委派机制的实现逻辑，<code>findClass</code>函数为模版方法模式中的抽象方法，被loadClass函数使用，用来根据类名查找类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)\n  throws ClassNotFoundException\n&#123;\n  synchronized (getClassLoadingLock(name)) &#123;\n    &#x2F;&#x2F; First, check if the class has already been loaded\n    Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n    if (c &#x3D;&#x3D; null) &#123;\n      long t0 &#x3D; System.nanoTime();\n      try &#123;\n        if (parent !&#x3D; null) &#123;\n          c &#x3D; parent.loadClass(name, false);\n        &#125; else &#123;\n          c &#x3D; findBootstrapClassOrNull(name);\n        &#125;\n      &#125; catch (ClassNotFoundException e) &#123;\n        &#x2F;&#x2F; ClassNotFoundException thrown if class not found\n        &#x2F;&#x2F; from the non-null parent class loader\n      &#125;\n\n      if (c &#x3D;&#x3D; null) &#123;\n        &#x2F;&#x2F; If still not found, then invoke findClass in order\n        &#x2F;&#x2F; to find the class.\n        long t1 &#x3D; System.nanoTime();\n        c &#x3D; findClass(name);\n\n        &#x2F;&#x2F; this is the defining class loader; record the stats\n        sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n        sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n        sun.misc.PerfCounter.getFindClasses().increment();\n      &#125;\n    &#125;\n    if (resolve) &#123;\n      resolveClass(c);\n    &#125;\n    return c;\n  &#125;\n&#125;</code></pre></li>\n<li><p>默认情况下自定义类加载器的父类为应用程序类加载器，可以在构造函数中指定自定义类加载器的父类加载器</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>双亲委派机制：用来确定类加载器，定义了类加载器之间的父子关系，从子类找到父类再从父类开始向下搜索</p>\n<ul>\n<li><p>当JVM无法根据全限定名（<code>java.lang.StringUtils</code>）找到路径和对应的类加载器时，虚拟机需要通过在各个类加载器所负责的路径下查找这个类，当有重复的时候，需要机制来确定加载哪一个类，所以虚拟机设计了双亲委派机制</p>\n</li>\n<li><p>双亲委派机制：定义了类加载器之间的父子关系</p>\n<ul>\n<li><code>ClassLoaderB</code>的父类加载器为<code>ClassloaderA</code>（B继承自A）</li>\n<li><code>ClassLoaderA</code>的父类加载器为<code>AppClassloader</code></li>\n<li><code>AppClassLoader</code>的父类加载器为<code>ExtClassLoader</code></li>\n<li><code>ExtClassLoader</code>的父类加载器为<code>null</code>,实际为<code>BootrapClassLoader</code></li>\n<li>由于其由C++代码实现，因此无法在打印结果中显示</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731151311369.png\" alt=\"image-20230731151311369\"></p>\n</li>\n<li><p>在某个类加载器接收到某个类的加载请求时（使用new或反射创建类的对象时，默认为请求应用程序类加载器加载对应的类），如果这个类加载器之前没有加载过这个类，那么他便委托父类加载器加载这个类，如果父类没有加载过则继续向上委托直到有类加载器加载了这个类，如果达到最顶层父类加载器还没有的话，就从上往下请求各个类加载器在自己负责的路径下查找并加载这个类</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731151327538.png\" alt=\"image-20230731151327538\"></p>\n</li>\n<li><p>双亲委派机制可以有效防止对核心类的恶意修改，比如在自己的路径下定义一个新的java.util.String类，请求应用程序类加载器来加载，意图覆盖核心类库中的String类，但是，基于双亲委派机制，应用程序类加载器会委托父类加载器来加载java.util.String类，最终仍然会由启动类加载器加载核心类库中的String类（因为是从上往下搜索）</p>\n</li>\n<li><p>结合Tomcat说一下双亲委派机制</p>\n<ul>\n<li>Tomcat中的类加载器<ul>\n<li><strong>Bootstrap 类加载器</strong>：它是 Java 虚拟机的一部分，用于加载核心 Java 类库，例如 <code>java.lang</code> 包下的类。Tomcat 不会干预 Bootstrap 类加载器的工作。</li>\n<li><strong>Catalina 类加载器</strong>：Catalina 是 Tomcat 的核心组件，它使用自定义的类加载器来加载 Tomcat 内部的类和核心库。</li>\n<li><strong>Shared 类加载器</strong>：Tomcat 的 Shared 类加载器用于加载位于 <code>$CATALINA_BASE/lib</code> 目录下的共享库（JAR 文件），这些库可以被不同的 Web 应用程序共享。</li>\n<li><strong>Web 应用程序类加载器</strong>：每个 Web 应用程序在 Tomcat 中都有自己的类加载器。这个类加载器负责加载特定 Web 应用程序的类和资源，位于该应用程序的 <code>WEB-INF/classes</code> 和 <code>WEB-INF/lib</code> 目录下的类和 JAR 文件。</li>\n</ul>\n</li>\n<li>在 Tomcat 中，双亲委派机制有助于隔离不同 Web 应用程序之间的类加载，确保它们不会相互干扰或冲突。这意味着每个 Web 应用程序都有自己的类加载器，它们首先尝试委派给父加载器加载类，只有在父加载器找不到类的情况下才会尝试自己加载。这种隔离性和优先级机制有助于确保各个 Web 应用程序在运行时能够安全地共存，不会因为类冲突而导致问题</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"3-Java内存区域\"><a href=\"#3-Java内存区域\" class=\"headerlink\" title=\"3.Java内存区域\"></a>3.Java内存区域</h2><ol>\n<li><p>内存分区：方法区（一些不变的信息）、堆（对象，垃圾回收器管理）、程序计数器、虚拟机栈和本地方法栈、直接内存（操作系统管理）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152203358.png\" alt=\"image-20230731152203358\"></p>\n<ul>\n<li><p>方法区：类信息、方法信息、静态变量、运行时常量池、字符串常量池、JIT编译代码缓存</p>\n<ul>\n<li><p>存储内容：类信息（类的全限定名、访问修饰符、符类、接口列表）、方法信息（方法名、修饰符、入参、返回值、访问标志）、静态变量（隶属于类，存在方法区）、运行时常量池（类字节码中的常量池，存储字面量和符号引用）、字符串常量池、JIT编译代码缓存</p>\n<ul>\n<li><p>常量池中每一项常量都是一个表，这 14 种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型（<code>.class</code>文件可以通过<code>javap -v class名</code>，来查看常量池中的信息（<code>temp.txt</code>））</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152227606.png\" alt=\"image-20230731152227606\"></p>\n</li>\n<li><p>运行时常量池：存放编译器生成的各种字面量和符号引用</p>\n<ul>\n<li>字面量：源代码中的固定值的表示法，包括整数、浮点数、字符串字面量</li>\n<li>符号引用：类/接口符号引用（全限定名）、字符符号引用（名称和描述符）、方法符号引用（名称和描述符）<ul>\n<li>符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可，与虚拟机内存布局无关，引用他的目标不一定是已经加载到虚拟机内存中的内容</li>\n<li>直接引用：是可以指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄，与虚拟机内存布局直接相关</li>\n</ul>\n</li>\n<li>运行时常量池的功能类似于传统编程语言的符号表，但它包含了比典型符号表更广泛的数据。既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</li>\n</ul>\n</li>\n<li><p>字符串常量池：</p>\n<ul>\n<li>HotSpot 虚拟机中字符串常量池的实现是<code>src/hotspot/share/classfile/stringTable.cpp</code>，<code>StringTable</code>本质上是一个<code>HashSet&lt;String&gt;</code>，容量为<code>StringTableSize</code>，可以通过<code>-XX:StringTableSize</code>参数来设置</li>\n<li><code>StringTable</code>中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象</li>\n<li>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中<ul>\n<li>原因：主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>方法区是一种抽象分区，不同JVM可以有不同的实现方式</p>\n<ul>\n<li>Java7之前实现为永久代</li>\n<li>Java7方法区的字符串常量池和静态变量从永久代中移除，放入堆中</li>\n<li>Java7之后永久代被元空间（Metaspace）取代，但字符串常量池和静态常量仍存储在堆中<ul>\n<li>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小，可以使用 <code>-XX：MaxMetaspaceSize</code>标志设置最大元空间大小</li>\n<li>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由<code>MaxPermSize</code>控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>方法区常用JVM参数</p>\n<ul>\n<li><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">-XX:PermSize&#x3D;N &#x2F;&#x2F;方法区 (永久代) 初始大小\n-XX:MaxPermSize&#x3D;N &#x2F;&#x2F;方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</code></pre></li>\n<li><p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。下面是一些常用参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">-XX:MetaspaceSize&#x3D;N &#x2F;&#x2F;设置 Metaspace 的初始（和最小大小）\n-XX:MaxMetaspaceSize&#x3D;N &#x2F;&#x2F;设置 Metaspace 的最大大小</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>程序计数器：线程私有的，PC寄存器是线程共享的</p>\n<ul>\n<li>虚拟机相当于一个抽象的计算机，也有自己的指令集（字节码集），因此也需要一个存储单元（程序计数器）用来存储下一条要执行的字节码的地址</li>\n<li>与PC寄存器不同的地方在于：PC寄存器是线程共享的，PC寄存器会随着线程的切换而进行保存和恢复，程序计数器是线程私有的，每个线程都会分配一个独立的程序计数器，记录当前线程执行到哪一行字节码（因为程序计数器位于内存而不是CPU，资源丰富，线程独享能减少线程上下文切换的信息量，有利于提高线程切换的速度）</li>\n</ul>\n</li>\n<li><p>堆：用来存储Java对象，在Java中对象的回收是有虚拟机中的垃圾收集器自动完成的，堆是垃圾收集器的主要工作分区</p>\n<ul>\n<li><p><strong>新生代（Young Generation）</strong>：主要用于存放新创建的对象实例，进一步可以分为以下三个区域，垃圾回收主要采用标记-复制算法</p>\n<ul>\n<li><strong>Eden 区</strong>：这是对象的初始分配区域，大多数新创建的对象都会被分配到这里</li>\n<li><strong>Survivor 区</strong>（通常有两个，分别称为 From 和 To 区）：Eden 区中的对象经过一次垃圾回收后，仍然存活的对象会被移动到 Survivor 区</li>\n</ul>\n</li>\n<li><p><strong>老年代（Tenured/Old Generation）</strong>：主要用于存储长时间存活的对象实例，当对象在新生代经过多次垃圾回收后仍然存活就会晋升到老年代，垃圾回收主要采用标记-清除和标记-整理算法</p>\n</li>\n</ul>\n</li>\n<li><p>虚拟机栈：函数调用中，主要用栈存储函数的局部变量、参数、返回地址等信息。栈是线程私有的，每个线程会有一个栈，因此也叫线程栈。Java中的栈叫做虚拟机栈</p>\n<ul>\n<li>栈帧中主要有以下几方面<ul>\n<li>局部变量表：存放了编译器可知的各种数据类型、对象引用，分为若干slot，第一个slot存<code>this</code>，其余先是方法参数列表，然后是方法内创建的变量（int、boolean、char、Object这种都只占一个slot，如果遇到long或者double类型的，则占用两个slot来存储）</li>\n<li>操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间结算结果或临时变量</li>\n<li>动态链接：主要服务一个方法需要调用其他方法的场景，常量池中保存了大量的符号引用（方法引用的符号引用），当一个方法调用其他方法时，需要将常量池中指向方法的符号引用转化为其内存地址的直接引用，这个过程就是动态链接</li>\n<li>方法返回地址</li>\n</ul>\n</li>\n<li>return和抛出异常都会导致栈帧被弹出</li>\n<li>程序运行中栈可能会出现的两种错误<ul>\n<li><code>StackOverFlowError</code><strong>：</strong> 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 <code>StackOverFlowError</code> 错误</li>\n<li><code>OutOfMemoryError</code><strong>：</strong> 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>本地方法栈：服务于native方法（C/C++）的栈，HotSpot中，两个栈被合并为一个栈</p>\n<ul>\n<li>Java提供了很多使用C/C++实现的native方法，在JVM规范中，Java将服务于Java方法调用的栈，跟服务于native方法调用的栈做了区分，服务于Java方法调用的栈称为虚拟机栈，服务于native方法调用的栈称为本地方法栈</li>\n<li>两个栈的功能相同，在具体的虚拟机实现中，如HotSpot中，把两栈合并为一个栈，同时存储Java方法调用的栈帧和native方法调用的栈帧</li>\n<li>默认线程栈的大小：不同平台下有区别，HotSpot默认的每个线程的栈大小为1MB（可更改）</li>\n</ul>\n</li>\n<li><p>直接内存：在本地内存分配，直接受操作系统管理，减少垃圾回收对程序的影响，用于NIO基于通道和缓存区的I/O方式，</p>\n<ul>\n<li>直接内存是一种特殊的内存缓冲区，并不在 Java 堆或方法区中分配的，而是通过 JNI 的方式在本地内存上分配的。不是虚拟机运行的一部分，但是也会导致<code>OutOfMemoryError</code>错误出现</li>\n<li>JDK1.4 中新加入的<code>NIO(New Input/Output) 类</code>，引入了一种基于通道（<code>Channel</code>）与缓存区（<code>Buffer</code>）的 I/O 方式，它可以直接使用 <code>Native</code> 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 <code>DirectByteBuffer</code> 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据</li>\n<li>堆外内存就是把内存对象分配在堆（新生代+老年代+永久代）以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152318554.png\" alt=\"image-20230731152318554\"></p>\n</li>\n<li><p>栈内存</p>\n</li>\n<li><p>堆内存</p>\n<ul>\n<li><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：新生代内存(Young Generation)、老生代(Old Generation)、永久代(Permanent Generation)；JDK8版本之后，PermGen（永久）已被Metaspace（元空间）取代，元空间使用的是本地内存</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152339252.png\" alt=\"image-20230731152339252\"></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Java内存模型</p>\n<ul>\n<li><p>工作内存和主内存：Java 内存模型规定所有的变量都存储在主内存中，每个线程都有自己独立的工作内存，工作内存保存了对应该线程使用的变量的主内存副本拷贝。线程对这些变量的操作都在自己的工作内存中进行，不能直接操作主内存和其他工作内存中存储的变量或者变量副本。线程间的变量传递需通过主内存来完成，并且定义了定义了 8 种操作来完成主内存和工作内存的变量访问，三者的关系如下图所示。</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230804143925400.png\" alt=\"image-20230804143925400\"></p>\n</li>\n<li><p>Java内存模型的三大特性</p>\n<ul>\n<li>原子性：Java 内存模型直接保证的原子性操作包括 read、load、use、assign、store、write、lock、unlock</li>\n<li>可见性：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改<ul>\n<li>实现方式：通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式</li>\n<li>volatile：volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新，但是它并不能保证互斥性，也就是说多个线程并发修改某个变量时，依旧会产生多线程问题，一般用在一个线程写，其他线程读的场景</li>\n<li>synchronized：由 “对一个变量执行 unlock 操作 之前，必须先把此变量同步回主内存中（执行 store、write 操作）” 这条规则获得</li>\n</ul>\n</li>\n<li>有序性：单线程没有问题，多线程下由于指令重排，并发执行的正确性会受到影响（通过<strong>volatile</strong>和<strong>synchronized</strong>解决）<ul>\n<li>volatile 通过加入<strong>内存屏障指令</strong>来禁止内存的重排序，</li>\n<li>synchronized 通过<strong>加锁</strong>，保证同一时刻只有一个线程来执行同步代码</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-垃圾回收\"><a href=\"#4-垃圾回收\" class=\"headerlink\" title=\"4.垃圾回收\"></a>4.垃圾回收</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>GC是JVM的一项重要功能，用于自动管理内存，回收不再使用的对象，以避免内存泄漏和OOM（Out of Memory）错误。流程主要有标记、清除、整理，即它通过标记不再被引用的对象，然后清除这些对象占用的内存。在某些情况下，还会对堆内存进行整理，以减少内存碎片</p></blockquote>\n<ol>\n<li><p>可达性分析：判断哪些对象可以被回收，引用计数、STW、安全点、安全区</p>\n<ul>\n<li><p>引用计数：同可达性分析类似的判断对象是否可以被回收的算法，但是存在问题（无法检测循环引用，都为null计数不为0）不被JVM采用</p>\n</li>\n<li><p>可达性分析：GC Roots、遍历（BFS、DFS）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152416772.png\" alt=\"image-20230731152416772\"></p>\n<ul>\n<li>用有向图表示对象之间的引用关系，图中定点表示对象，有向边表示引用</li>\n<li>GC Roots：堆外变量所直接引用的堆内对象，包括虚拟机栈、本地方法栈中的局部变量所直接引用的对象，方法区中静态变量所直接引用的对象等</li>\n<li>虚拟机以GC Roots为起点，遍历（BFS或DFS）整个图，可以遍历到的对象为可达对象，遍历不到的对象被虚拟机当作垃圾回收</li>\n</ul>\n</li>\n<li><p>STW：运行在虚拟机上的用户线程和垃圾回收线程是并行的，垃圾回收是对象会被用户线程更改，可达性分析结果会有误报/漏报的情况</p>\n<ul>\n<li>误报：非存活对象误报为存活对象，等待再次垃圾回收</li>\n<li>漏报：漏报存活对象，从而将其判定为死亡对象。会产生严重的问题，导致本不该被回收的对象被回收，从而导致程序出错，解决此问题最简单的方法就是STW（Stop The World），即停止所有用户线程的执行，知道垃圾回收结束，因此会影响程序性能</li>\n</ul>\n</li>\n<li><p>安全点：使用<code>OopMap</code>动态更新<code>GC Roots</code>，JVM为某个指令记录<code>OopMap</code>，这个指令就叫～</p>\n<ul>\n<li><p>GC Roots的获得方式：遍历栈中的局部变量和方法区中的静态变量，找出引用类型变量，然后，再将引用类型变量所引用的对象放入GC Roots中</p>\n</li>\n<li><p>虚拟机使用OopMap来存储当前的<code>GC Roots</code>并动态更新，减少遍历耗时</p>\n<ul>\n<li>遍历查找<code>GC Roots</code>，初始化<code>OopMap</code>，在代码执行过程中，变量更新引用时，同步更新<code>OopMap</code></li>\n<li>因为JIT编译后的机器码直接交由CPU执行，所以需要在编译成机器码之前静态分析指令，存储指令执行后的<code>OopMap</code>，浪费内存</li>\n</ul>\n</li>\n<li><p>安全点：为了节约空间，虚拟机采用了时间换空间的策略，将为每个指令存储一个<code>OopMap</code>，改为只选取部分指令存储<code>OopMap</code>。这些被选取的指令称为安全点，当虚拟机启动垃圾回收并需要STW时，会向用户线程发送暂停的中断请求，此时，用户线程并不能立刻停止，而是需要运行到安全点之后才能停止，因为只有安全点处才记录了OopMap，只有所有线程都运行到安全点之后，虚拟机才能得到完整的GC Roots</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152435643.png\" alt=\"image-20230731152435643\"></p>\n</li>\n</ul>\n</li>\n<li><p>安全区：不会改变对象引用关系的一段连续的代码区间，安全区代码可以和垃圾回收线程并行执行</p>\n<ul>\n<li>大部分情况，用户线程在接收到暂停的中断请求之后，都可以在较短的时间内达到最近的安全点，但是在少数情况下，如果用户线程处于阻塞状态（如等待I/O读写就绪），就无法在较短的时间内达到最近的安全点，为了解决这个问题，虚拟机引入了一个新的概念：安全区，即不会改变对象引用关系的一段连续的代码区间</li>\n<li>当虚拟机执行垃圾回收并发起STW请求时，如果某个线程处于安全区，那么，这个线程并不需要停止执行，而是可以跟垃圾回收线程并行执行。但是，当用户线程离开安全区时，他需要检查虚拟机是否处于STW状态，如果是，用户线程需要阻塞等待STW结束，才能继续往下执行，以免用户线程跳出安全区之后，执行非安全代码导致对象引用关系的改变</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>垃圾回收算法：基础垃圾回收算法（标记-清除、标记-整理、标记-复制）、分代垃圾回收算法（年轻代和YoungGC、老年代和FullGC）</p>\n<ul>\n<li>概念：用于回收死亡对象，主流算法为分代垃圾回收算法，JVM将堆空间分为年轻代和老年代，针对不同的分代单独进行垃圾回收（YoungGC、FullGC）<ul>\n<li>针对年轻代的垃圾回收叫做YoungGC</li>\n<li>针对老年代的垃圾回收叫做FullGC，FullGC比YoungGC慢很多</li>\n</ul>\n</li>\n<li>基础垃圾回收：标记使用可达性分析找出需要回收的死亡对象，主要有标记-清除、标记-整理、标记-复制<ul>\n<li>标记-清除：虚拟机将死亡对象占用的内存空间释放，放入到空闲链表中，创建对象时，JVM从空闲链表中查找合适的空闲空间分配给对象，会出现内存碎片问题，标记-清除后的空闲空间不连续，查找耗时，大对象无法分配</li>\n<li>标记-整理：有叫做标记-压缩，在标记-清除的基础上，增加了整理的环节，先使用可达性分析标记存活对象所占用的内存空间，然后顺序遍历，将存活对象移动到内存的一端，从而解决内存碎片的问题，只需记录空闲空间的起始地址</li>\n<li>标记-复制：将内存分为轮流使用的两块内存，一块内存为对象分配内存空间（工作内存），另一块内存作为复制时备用（备用内存），当工作内存使用完之后，将这块内存的存活对象复制到备用内存中，然后交换两块内存角色，缺点是内存只用了一半，长时间存活的对象会被来回复制多次</li>\n</ul>\n</li>\n<li>分代垃圾回收算法<ul>\n<li>不需回收：程序计数器内存小，随着线程创建和销毁，不需要回收；虚拟机栈和本地方法栈存储的是方法的栈帧，随着方法退出而销毁，因此这三部分会随着生命周期的结束而立刻被回收，不需要经过虚拟机的垃圾回收线程的处理</li>\n<li>需要回收<ul>\n<li>堆中存储的是对象，需要所有线程共享，作用域范围大，生命周期长，使用完不会立即回收，所以堆是进行垃圾回收的重点</li>\n<li>方法区也会涉及垃圾回收，比如方法区中的一些无用的类（类所有对象被回收、类class对象未被引用、类加载器已卸载）、无用的String常量对象（存储在字符串常量池，却没有变量引用的String对象）</li>\n</ul>\n</li>\n<li>对堆的垃圾回收：堆中存储的是对象，对生命周期短的希望以较高频率进行回收；对生命周期长的希望以较低频率进行回收</li>\n<li>分代的垃圾回收：JVM将堆分为年轻代（Young Genereation）和老年代（Old Generation）两个分区，年轻代存储生命周期短的对象，老年来存储生命周期长的对象。JVM针对不同的分代使用不同的基础垃圾回收算法</li>\n</ul>\n</li>\n<li>年轻代和YoungGC<ul>\n<li>新创建的对象会分配在年轻代，选择标记-复制算法进行回收，因为生命周期短所以只需要复制少量存活对象</li>\n<li>为提高内存利用率，将年轻代分为不均等的三个分区：一个Eden区和两个Survivor区（From Survivor区、To Survivor区）<ul>\n<li>Eden满了之后，会触发Minor GC，存入survivor0中，如果触发MinorGC时survivor0也是满的，则s0和Eden一起进行可达性分析，找出活跃对象复制到s1区（标记-复制算法），请空Eden和s0，并将s0和s1交换</li>\n<li>对象在第一次进入Survivor，年龄初始化为1，在survivor中每熬过一次MinorGC，年龄就增加1</li>\n<li>Eden区和Survivor区会被动态调整，或通过参数<code>-XX:SurvivorRatio</code>来设置比例（Eden区：1个Survivor区）</li>\n</ul>\n</li>\n<li>空间分配担保机制：ToSurvivor区存不下的时候，会借用老年代的部分空间（老年代也不够时会执行FullGC，仍不够会抛出OOM），缺点是部分生命周期短的对象存储在老年代，等待很长时间才会被回收</li>\n</ul>\n</li>\n<li>老年代和FullGC<ul>\n<li>新生代存不下的对象、大对象、长期存活的对象都会进入老年代<ul>\n<li>如果设置了JVM参数<code>-XX:PretenureSizeThreshold</code>，当对象大小超过这个阈值，对象会直接在老年代创建</li>\n<li>长期存活的对象指的是经过多次年轻代垃圾回收仍然存活的对象，虚拟机在对象的对象头中记录对象的GC年龄，每经过一次GC，GC年龄就增一，当GC年龄超过一定阈值（默认15，或通过<code>-XX:PretenureSizeThreshold</code>设置）之后，对象便从年轻代移动到老年代，但是人工设置的不准需要动态年龄判断机制</li>\n<li>动态年龄判断机制：统计YoungGC后，处于每个GC年龄值的对象占To Survivor区的比例，如果GC年龄&gt;=X（X取最大值）的对象占To Survivor区的比例超过50%（比例通过<code>-XX:TargetSurvivorRatio</code>来设置），那么GC年龄&gt;=X的对象都将直接进入老年代，不等GC年龄大于15</li>\n</ul>\n</li>\n<li>老年代的垃圾回收<ul>\n<li>因为老年代中的对象生命周期较长，每次垃圾回收之后，存活对象比较多，所以采用标记-整理算法进行回收（标记-清楚有内存碎片，永久代也使用标记-整理）</li>\n<li>老年代的垃圾回收叫做OldGC，但是在HotSpotJVM中，对老年代进行垃圾回收的同时，虚拟机会一并对年轻代和永久代进行垃圾回收，整个过程叫做FullGC</li>\n<li>YoungGC只对年轻代进行垃圾回收，速度快（可达性分析遍历的对象少，需要复制的对象较少），因此也称为MinorGC，而FullGC针对整个堆进行垃圾回收，速度慢（可达性分析遍历的对象多，垃圾回收处理的对象也多），因此也称为MajorGC</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>增量（Incremental）算法</strong>：是一种渐进式的垃圾收集算法，它将垃圾收集的工作分为多个小部分分别执行，不需要一次性完成所有的垃圾收集工作，从而减少了垃圾收集时程序的暂停时间</li>\n</ul>\n</li>\n<li><p>垃圾回收器：垃圾回收算法的具体实现，同一种算法可以有不同的实现</p>\n<ul>\n<li><p>性能指标：吞吐量（业务运行时间/总运行时间）、停顿时间（STW）、资源消耗（CPU资源、内存资源）、回收延迟、回收频率</p>\n</li>\n<li><p>四大类常用的垃圾回收器：Serial、Parallel、CMS、G1</p>\n<ul>\n<li><p>Serial垃圾回收器：使用单线程进行垃圾回收，回收时需要STW、针对工作分区有以下两类</p>\n<ul>\n<li>Serial New：用于年轻代的垃圾回收，基于标记-清楚算法实现</li>\n<li>Serial Old：用于老年代的垃圾回收，基于标记-整理算法实现</li>\n</ul>\n</li>\n<li><p>Parallel垃圾回收器：使用多线程进行垃圾回收，回收是需要暂停程序运行，针对工作分区有以下三类</p>\n<ul>\n<li>Parallel Scavenge（简称PS）：用于年轻代，基于标记-复制算法，与ParOld配合使用</li>\n<li>Parallel New（简称ParNew）：用于年轻代，基于标记-复制算法，与CMS配合使用</li>\n<li>Parallel Old（简称ParOld）：用于老年代，基于标记-整理算法</li>\n</ul>\n</li>\n<li><p>CMS垃圾回收器：全称<code>Concurrent Mark Sweep</code>，采用多线程，不暂停应用程序，但不能用于年轻代的垃圾回收（Parallel New）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152517701.png\" alt=\"image-20230731152517701\"></p>\n<ul>\n<li>垃圾回收过程（见后）：初始标记（需暂停应用程序）、并发标记、重新标记（需暂停应用程序）、并发清理</li>\n<li>CMS垃圾回收器在应用程序并行执行的过程中会争抢CPU资源，因此CMS使用的并发线程数等于（CPU内核数+3）/ 4，并且需要在老年代未满的时候进行垃圾回收，为并发程序预留内存空间<ul>\n<li>预留内存通过JVM参数<code>-XX:CMSInitiatingOccupancyFraction</code>来指定已用内存占老年代的比值，超过此阈值就会触发CMS垃圾回收器的执行</li>\n<li>预留内存空间不够时，转而使用SerialOld垃圾回收器执行本次垃圾回收</li>\n</ul>\n</li>\n<li>为了减少STW时间，CMS采用标记-清除算法来实现，相对于标记-整理算法，节省了整理空闲空间的时间，并且CMS针对内存碎片问题进行了改进，即在多次垃圾回收之后进行一次内存碎片的整理</li>\n</ul>\n</li>\n<li><p>G1垃圾回收器：全称Garbage First，是一个应用于堆上的垃圾回收器，借鉴分代的处理思路，将整个堆分为2048个小的Region，并进一步分为年轻代（Eden区、Survivor区）、老年代</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152541924.png\" alt=\"image-20230731152541924\"></p>\n<ul>\n<li>之前的垃圾回收器都是针对整个分代进行垃圾回收，当分代被划分为更小的区域后，每次垃圾回收时，虚拟机可以只回收分代中的部分区域，进一步缩短STW时间</li>\n<li>G1同CMS类似，都是多线程进行垃圾回收，并且回收的过程与应用程序并发执行，不同的地方是G1垃圾回收器整体使用标记-整理算法、局部（每个Region）使用标记-复制</li>\n<li>因为G1的STW时间可以预测，所以可以通过<code>-XX:MaxGCPauseMillis</code>设置可允许的最大STW时间，G1根据这个时间决定每次对多少个区域进行垃圾回收</li>\n</ul>\n</li>\n<li><p>ZGC垃圾回收器</p>\n<ul>\n<li>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。在 ZGC 中出现 Stop The World 的情况会更少</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>垃圾回收器的对比与选择</p>\n<ul>\n<li><p>默认Java7、Java8采用Parallel垃圾回收器，Java9采用G1垃圾回收器，可以通过设置JVM参数来指定项目使用的垃圾回收器</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152604214.png\" alt=\"image-20230731152604214\"></p>\n</li>\n<li><p>实战建议</p>\n<ul>\n<li>Serial：单核系统，多个应用程序争用CPU资源的环境下，需要刻意限制虚拟机所占用资源的环境，比如运行在移动端的客户端程序</li>\n<li>Parallel与CMS相比，前者吞吐量更大，后者停顿时间更少，对于离线服务，首选吞吐量达的Parallel垃圾回收器，对于实时服务，特别是对响应时间敏感的服务，首选停顿时间更少的CMS垃圾回收器</li>\n<li>Java9中，CMS被标记为Deprecated，使用G1取代，针对比较大的堆（大于6GB），首选停顿时间可控的G1垃圾回收器</li>\n<li>老年代使用CMS（Concurrent Mark-Sweep）或G1（Garbage First），减少停顿时间</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>并发垃圾回收</p>\n<ul>\n<li>并发：并非完全并发，而是大部分时间不需要暂停应用程序，并发垃圾回收整个过程分为4个阶段，分别是：初始标记、并发标记、重新标记、并发清理，其中并发标记和并发清理这两个比较耗时的阶段可以与应用程序并发执行，而其余两个阶段仍需要暂停应用程序的执行</li>\n<li>回收过程：初始标记指的是标记GC Roots。并发标记指的是在应用程序不暂停的情况下，以GC Roots为起点，广度或深度优先遍历所有可达对象（存活对象），在并发标记的过程中，应用程序有可能修改对象之间的引用关系，导致并行标记过程出现误标或漏标的情况，重新标记所做的工作就是对误标和漏标进行修正。并发清理指的是在不暂停应用情况下，对标记出来的垃圾对象进行清理</li>\n<li>并发清理：前面三个阶段属于可达性分析，即标记-清除算法中的标记环节，并发清理是标记-清除算法中的清除环节。在并发清理过程中，如果存活对象变为死亡对象，只需要在下一次垃圾回收中被回收即可；而死亡对象不会再变成存活对象，因为死亡对象不再有变量（局部变量或静态变量）的直接或间接引用，因此应用程序是无法在代码中使用这些死亡对象（比如局部变量在函数执行结束后就被销毁了）</li>\n</ul>\n</li>\n<li><p>三色标记算法</p>\n<ul>\n<li>用于可达性分析，将遍历过程中的对象分为白色、灰色、黑色三种<ul>\n<li>白色：对象没有遍历过，遍历开始时，所有对象都初始化白色，遍历结束后，仍为白表示对象不可达</li>\n<li>灰色：对象已经被遍历，但是对象所直接引用的对象还没有完全被遍历</li>\n<li>黑色：对象已经被遍历，并且对象所直接引用的对象都已经被遍历</li>\n</ul>\n</li>\n<li>可达性分析基于图的广度和深度遍历<ul>\n<li>初始化GC Roots为灰色，其余为白色</li>\n<li>从灰色集合中取出一个灰色对象，标记为黑色，将此对象直接引用的所有白色对象标记为灰色</li>\n<li>重复第二步，直到灰色集合中没有对象为止。此时黑色集合存放的是可达对象，也就是存活对象；白色集合中存在的是不可达对象，也就是死亡对象</li>\n</ul>\n</li>\n<li>误标（白的标成黑的）和漏标（黑的标成白的）<ul>\n<li>误标：灰色对象的引用变为0，应该变成白的，但是最后变成黑的了</li>\n<li>漏标：白色对象的灰色对象引用断开，新增了黑色对象引用，应该被标成黑的，但是只能被标成白的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>增量更新和原始快照</p>\n<ul>\n<li>并发标记的误标和漏标问题会在重新标记中解决，其中误标问题不大，是可以接受的，只会导致垃圾对象延迟回收，但是漏标问题会导致应用程序运行出错，回收不该回收的对象，漏标产生的原因主要有以下两点，两者缺一不可<ul>\n<li>新增引用：新增一个黑色对象对一个白色对象的引用</li>\n<li>删除引用：删除所有灰色对象到此白色对象的直接或间接引用</li>\n</ul>\n</li>\n<li>针对以上两点，Java发明了两种漏标解决方案，针对第一点新增引用的漏标解决方案叫做增量更新，是CMS垃圾回收器所使用的方案；针对第二点删除引用的漏标解决方案叫做原始快照，是G1垃圾回收器所使用的方案，方案具体如下：<ul>\n<li>增量更新：在并发标记的过程中，如果应用程序<strong>新增</strong>了一个黑色对象对一个白色对象的引用，虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下的白色对象为起点，重新进行可达性分析，这样漏标的白色对象会被重新标记为黑色对象</li>\n<li>原始快照：在并发标记的过程中，如果应用程序<strong>删除</strong>了一个灰色对象对一个白色对象的直接/间接引用，那么虚拟机会将这个白色对象记录下来，在并发标记完成之后，重新标记阶段会以这些记录下来的白色对象为起点，重新进行可达性分析，这就相当于虚拟机对引用关系改变之前的原始快照进行可达性分析。不过，这些记录下的白色对象有可能是死亡对象，而重新标记阶段会将这些死亡对象重新标记为存活对象，因此，原始快照这种解决方案会导致误标问题，会导致垃圾对象延迟回收</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-实战调优\"><a href=\"#5-实战调优\" class=\"headerlink\" title=\"5.实战调优\"></a>5.实战调优</h2><ol>\n<li><p>JVM性能优化</p>\n<ul>\n<li>性能指标：GC频率、GC时间，印象以上两项的内部性能指标<ul>\n<li>年轻代中对象的增长速率</li>\n<li>每次YoungGC之后存活对象大小</li>\n<li>每次YoungGC之后进入老年代的对象大小</li>\n<li>老年代对象的增长速率</li>\n</ul>\n</li>\n<li>JVM参数类别：参数稳定性依次下降<ul>\n<li><code>-</code>标准参数</li>\n<li><code>-X</code>参数</li>\n<li><code>-XX</code>参数</li>\n</ul>\n</li>\n<li>常用参数：堆大小、年轻代和老年代大小、永久代和元空间大小、Eden区和Survivor区大小、线程栈大小、垃圾回收器类别<ul>\n<li>设置堆的大小：一般设置为相同的值，避免堆大小的调整而引起的性能损耗<ul>\n<li>Xms：Java堆内存的初始大小</li>\n<li>Xmx：Java堆内存的最大大小</li>\n</ul>\n</li>\n<li>设置年轻代和老年代的大小：设置年轻代大小的方法有三种，但是对于老年代的大小只需要通过堆大小减去年轻代大小即可得到<ul>\n<li>Xmn：年轻代的大小</li>\n<li>XX:NewSize：年轻代的初始大小</li>\n<li>XX:MaXNewSize：年轻代的最大大小</li>\n<li>XX:NewRatio：年轻代与老年的大小比值，值为老年代/年轻代</li>\n</ul>\n</li>\n<li>设置永久代或元空间的大小<ul>\n<li>XX:PermSize：永久代的初始大小</li>\n<li>XX:MaxPermSize：永久代的最大大小，这两个参数只在1.7之前有效</li>\n<li>XX:MetaspaceSize：元空间的初始大小</li>\n<li>XX:MaxMetaspaceSize：元空间的最大大小，这两个参数只在1.8之后有效</li>\n</ul>\n</li>\n<li>设置Eden区和survivor区的大小<ul>\n<li>XX:SurvivorRatio：一个Survivor区跟Eden区的大小比例，值为Eden区/Survivor区，注意：一共有两个Survivor区</li>\n</ul>\n</li>\n<li>设置线程栈的大小<ul>\n<li>Xss：每个线程的栈大小，HotSpot JVM不区分虚拟机栈和本地方法栈，使用一个栈同时存储Java方法和本地方法的栈帧，因此这里只有一个栈大小的设置参数，线程栈大小默认为512KB或1MB，除非系统在运行的过程中，出现非代码因素导致的StackOverflow，才需要调整线程栈的大小，否则默认即可</li>\n</ul>\n</li>\n<li>设置垃圾回收器<ul>\n<li>XX:+UseSerialGC：用Serial垃圾回收器</li>\n<li>XX:+UseParallelGC：用Parallel垃圾回收器</li>\n<li>XX:+UseConcMarkSweepGC：用CMS垃圾回收器</li>\n<li>XX:+UseG1GC：用G1垃圾回收器</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM问题排查</p>\n<ul>\n<li><p>常见工具</p>\n<ul>\n<li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>\n<li>**<code>jstat</code>**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>\n<li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li>\n<li><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li>\n<li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果;</li>\n<li><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合</li>\n</ul>\n</li>\n<li><p>JVM性能调优</p>\n<ul>\n<li>线上通过jstat得到JVM性能统计数据，JVM调优主要方向是减少FullGC频率和FullGC时间<ul>\n<li>增大年轻代的大小，增大Survivor区大小，让对象尽量在年轻代就被回收掉，减少老年代中对象的增长速率，从而降低FullGC频率</li>\n<li>增加老年代的大小也会降低FullGC的频率，但会增大FullGC的时间</li>\n</ul>\n</li>\n<li>一般来说，如果堆不是很大，没有长期存活的大对象和内存泄漏，那么应用CMS垃圾回收器并调节年轻代、老年代、Survivor区等内存分配，完全可以将FullGC时间优化到合适的范围，否则可以选择GC时间可控的G1垃圾回收器</li>\n<li>大部分情况，不需要刻意的进行调优，只有当通过监控发现GC严重影响系统性能时，才有必要对JVM参数进行调优</li>\n</ul>\n</li>\n<li><p>JVM性能监控和分析工具</p>\n<ul>\n<li><p>jstat：通过jps命令查找到要监控的JVM进程ID，然后执行jstat -gcutil [vmid] [time-interval]即可</p>\n<ul>\n<li>S0：表示Survivor0的内存使用率；S1：表示Survivor1的内存使用率；E：表示Eden区的内存使用率；O：表示老年代的内存使用率；M：表示Metaspace的内存使用率；YGC：YoungGC的次数；YGCT：YoungGC的总耗时；FGC：FullGC的次数； FGCT：FullGC的总耗时；GCT：GC的总耗时</li>\n</ul>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152719712.png\" alt=\"image-20230731152719712\"></p>\n</li>\n<li><p>GC详细日志分析</p>\n<ul>\n<li><code>-XX:+PrintGCDetails</code> 打印详细GC日志</li>\n<li><code>-Xloggc:./logs/gc.log</code> 详细GC日志存储的位置</li>\n<li>以上日志可以粗略的分为两类：ParNew日志和CMS日志<ul>\n<li>ParNew日志：记录GC触发原因、GC发生时间、GC前后年轻代大小变化、GC具体耗时等信息</li>\n<li>CMS日志示例：CMS日志包含的信息比ParNew日志要多很多，其中，CMS Initial Mark、CMS-cocurrent-mark、CMS Final Remark、CMS-concurrent-sweep分别对应并发垃圾回收的四个阶段：初始标记、并发标记、重新标记、并发清理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM内存快照获取和分析：jmap</p>\n<ul>\n<li><p>当JVM出现问题时，比如OOM、频繁GC，我们希望得知当前堆中存储的对象情况，比如哪些对象占据了大量堆内存，我们就需要将当下的内存快照dump出来，然后利用工具来查看和分析</p>\n</li>\n<li><p>常用的dump堆内存快照的方法有两种，一种是使用JVM参数，另一种是使用<code>jmap</code>命令行工具。具体如下所示。dump出来的堆内存快照为二进制文件，我们需要通过工具来查看，常用的查看工具有MAT、jhat等</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">方法一：使用JVM参数\n-XX:+HeapDumpBeforeFullGC\n-XX:HeapDumpOnOutOfMemoryError\n-XX:HeapDumpPath&#x3D;目录\n\n方法二：使用jmap命令行工具\njmap -dump:format&#x3D;b,file&#x3D;文件名 [pid]</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JVM常见问题</p>\n<ul>\n<li>OOM：应用程序使用完成的对象没有被及时释放，导致对应的内存无法被回收，长期积累，便会导致内存耗尽<ul>\n<li><p>当程序申请不到足够的内存空间，并且JVM通过GC也无法释放出足够的内存空间时，JVM便会抛出OOM</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;Object&gt; list &#x3D; new ArrayList&lt;&gt;();\nwhile (true) &#123;\n    list.add(new byte[1_000_000]); &#x2F;&#x2F; 每次添加1MB的对象\n&#125;\n</code></pre></li>\n<li><p>导致内存溢出的常见的原因有如下几种</p>\n<ul>\n<li><strong>堆内存（Heap）</strong>：OOM最常见的场景之一是堆内存不足，通常由于创建了太多对象（SQL查询全表数据）或者每个对象太大。这在处理大数据量、内存泄漏或者没有合理限制对象创建时可能发生</li>\n<li><strong>永久代/元空间（PermGen/Metaspace）</strong>：在Java 8之前，类的元数据和静态字符串池存储在永久代（PermGen），而在Java 8及以后，它们存储在元空间（Metaspace）。如果永久代或元空间太小，则OOM可能发生在这些区域，尤其是在动态生成类或加载大量类的应用中</li>\n<li><strong>栈内存（Stack）</strong>：虽然栈内存通常较小，但如果递归调用层次太深，也可能导致栈溢出（StackOverflowError）</li>\n</ul>\n</li>\n<li><p>如何排查OOM问题</p>\n<ul>\n<li>当JVM出现OOM问题时，应用程序的对应表现一般是无法继续执行，如果应用程序是接口系统，那么接口将出现大量503错误。这时，我们通过查看日志，便会发现大量<code>java.lang.OutOfMemoryError</code>错误信息。为了排查出到底哪些对象长期存在并大量占用内存，我们需要通过jmap或JVM参数获取堆内存快照，并通过MAT等工具来查看和分析</li>\n<li>使用MAT工具可以得知内存泄漏的数据可能集中在哪些代码，然后就可以去分析源代码，看是否代码存在内存泄漏，又或者创建了太多长期存在的对象，最后可以尝试调大堆内存的大小<ul>\n<li>确保资源的正确关闭和对象引用的释放</li>\n<li>特别关注长时间存活的对象和数据结构</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>频繁GC<ul>\n<li>一般OOM前会出现频繁GC，主要有两种：频繁YoungGC和频繁FullGC，单纯的频繁YoungGC往往是由年轻代空间太小导致的，只需要适当增大年轻代的大小即可解决这个问题，因为YoungGC只与存活对象的数量有关，与年轻代大小无关</li>\n<li>相对于频繁YoungGC，频繁FullGC会引发更加严重的问题，且解决起来更加复杂。因为FullGC更加消耗CPU资源并且STW停顿时间较长，所以，在发生频繁FullGC时，CPU利用率一般会飙升，并且会出现应用程序变慢的情况（比如接口请求处理速度变慢甚至大量超时）</li>\n<li>触发FullGC的主要原因是老年代空间不足。前面我们已经总结过，老年代的对象一般来源于长期存活的对象、大对象、空间分配担保。接下来，我们从这3个对象来源来分析频繁GC发生的原因。<ul>\n<li>长期存活的对象：如果应用程序创建的长期存活的对象比较多，那么，我们可以适当调大老年代的大小，以减少FullGC的频率。不过，这种情况并不常见，大部分应用程序并不会创建太多的长期存活的对象。实际上，内存泄露往往才是导致对象长期存活无法回收的主要原因。如果每次FullGC回收率很低，释放出来的空间很少，那么就说明是存在内存泄露了。频繁FullGC一段时间之后，JVM便会出现OOM</li>\n<li>大对象：前面讲到，大对象会直接进入老年代。过多的大对象是引起频繁FullGC的最常见的原因之一。比如，在某个接口中执行了未分页SQL，一次性加载过多数据到内存中，当高并发下，接口大量被调用，就会导致大量大对象被创建，从而导致老年代空间不足，引发频繁FullGC。定位此种频繁FullGC发生的原因，我们需要在FullGC前（设置JVM参数-XX:+HeapDumpBeforeFullGC）dump内存快照，分析占用堆内存比较多的是哪个对象，以此来定位问题代码</li>\n<li>空间分配担保：前面讲到，在执行YoungGC时，如果To Survivor空间不足，JVM会触发空间分配担保，将对象存储到老年代。因此，如果每次YoungGC，To Survivor都被占满，那么，我们就要考虑增大To Survivor区，避免空间分配担保，减少进入老年代的对象数量</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>GC时间过长<ul>\n<li><strong>堆内存过大：</strong>前面讲到，年轻代使用标记-复制垃圾回收算法，并且，年轻代空间增大并不会导致存活对象增多，因此，YoungGC时间跟年轻代的大小无关，但是，老年代使用标记-整理或标记-清除垃圾回收算法，并且，老年代空间增大会导致存活对象增多，因此，FullGC时间跟老年代的大小有关。老年代过大会导致FullGC时间过长。针对比较大的堆内存，我们应该选择GC时间可控的G1垃圾回收器，或者在一台大物理内存的机器上部署多个JVM，以减小单个堆内存的大小</li>\n<li><strong>Concurrent Mode Failure：</strong>前面讲到，CMS垃圾回收器采用并发垃圾回收算法，在垃圾回收的某些阶段，应用程序可以与之并发执行。应用程序的执行需要堆内存，因此，JVM在执行垃圾回收前，会预留一定的堆内存空间。但是，在执行垃圾回收的的过程中，如果预留空间不足，应用程序无法继续执行，那么，JVM便会抛出Concurrent Mode Failure错误，并且，暂停CMS垃圾回收器的执行，改为STW停顿时间更长的Serial Old垃圾回收器。垃圾回收器的中止和切换势必会增长FullGC时间。如果我们在GC详细日志中（通过设置JVM参数-XX:+PrintGCDetails得到）发现大量Concurrent Mode Failre字样，那么，我们就需要通过减小JVM参数<code>-XX:CMSInitialOccupancyFraction</code>的值来调大预留空间的大小</li>\n<li><strong>操作系统swap：</strong>swap是操作系统中的概念。当物理内存不足时，操作系统会将物理内存中的部分不活跃的数据放入磁盘，当这部分数据重新被使用时，再从磁盘加载到物理内存中。这种数据在物理内存和磁盘之间换入换出的机制，就叫作swap。swap涉及磁盘I/O操作，非常影响进程的性能。如果设置的JVM堆内存大小超过物理内存大小，或者多个应用程序争用有限的物理内存，那么，就有可能触发swap而导致GC时间增长。解决这个问题的方法也很简单，尽量保证JVM堆大小不要超过物理内存的大小，并且为操作系统或者其他软件预留充足的物理内存，比如物理内存有8GB，我们设置JVM堆大小为6GB，预留2GB给操作系统和其他并发运行的软件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ol>\n<li><p>如何判断一个常量是废弃常量</p>\n<ul>\n<li>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</li>\n<li>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了</li>\n</ul>\n</li>\n<li><p>怎么释放一个用完的大对象的内存空间</p>\n<ul>\n<li>不再使用对象后，确保将其所有引用设置为==null==。这有助于加速对象变为不可达的过程</li>\n<li>如果你知道某个大对象的生命周期非常短暂，可以考虑==手动调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>==来建议垃圾收集器执行垃圾回收。请注意，这只是建议，垃圾收集器是否真正执行垃圾回收还取决于具体的实现</li>\n<li>如果你的应用程序经常创建和销毁大量的大对象，可以考虑==使用对象池或其他内存管理技术来重用对象==，以减少垃圾收集的开销。</li>\n</ul>\n</li>\n<li><p>JVM 判定两个 Java 类是否相同的具体规则</p>\n<ul>\n<li>JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即使两个类来源于同一个Clas文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相同</li>\n</ul>\n</li>\n<li><p>打破双亲委派模型方法</p>\n<ul>\n<li>自定义加载器的话，需要继承<code>ClassLoader</code>。如果我们不想打破双亲委派模型，就重写<code>ClassLoader</code>类中的<code>findClass()</code>方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写<code>loadClass()</code>方法</li>\n<li>Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器<code>WebAppClassLoader</code>来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理（详见深入拆解Tomcat&amp;Jetty）</li>\n</ul>\n</li>\n<li><p>JVM内存模型运行原理</p>\n<ul>\n<li>当 Java 程序启动时，JVM 会初始化内存模型中的各个区域。</li>\n<li>程序代码被加载并编译成字节码，并由类加载器加载到方法区。</li>\n<li>线程开始执行，每个线程都有自己的程序计数器、虚拟机栈等区域。</li>\n<li>当方法被调用时，在虚拟机栈上创建栈帧，用于存储方法的局部变量和操作数栈。</li>\n<li>对象实例被分配到 Java 堆上，并由垃圾回收器负责回收不再被引用的对象。</li>\n<li>类的元数据信息存储在方法区（或元空间）中，包括字段、方法、方法字节码等。</li>\n<li>运行时常量池用于存储符号引用和字面量常量。</li>\n<li>JVM 运行时会执行字节码指令，操作数据、调用方法等。</li>\n<li>垃圾回收器定期检查和回收不再被引用的对象，释放内存。</li>\n</ul>\n</li>\n<li><p>HotSpot虚拟机对象探秘</p>\n<ul>\n<li><p>对象的创建</p>\n<ul>\n<li>类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程</li>\n<li>分配内存：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有“指针碰撞”和“空闲列表”两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定<ul>\n<li>指针碰撞 ：堆内存没有内存碎片的情况下，使用该分配方式的 GC 收集器有Serial, ParNew</li>\n<li>空闲列表 ：堆内存有内存碎片的情况下，虚拟机有一个空闲链表记录哪些内存块是可用的，使用该分配方式的 GC 收集器有CMS</li>\n<li>内存并发问题：创建对象是很频繁的，必须保证线程安全，有以下几种方法<ul>\n<li>CAS+失败重试<strong>：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性</li>\n<li>TLAB<strong>：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</li>\n<li>设置对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象头中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式</li>\n<li>执行init方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来</li>\n</ul>\n</li>\n<li><p>对象的内存布局</p>\n<ul>\n<li>对象头<ul>\n<li>用于存储对象自身的运行时数据：哈希码、GC分代年龄、锁状态标志等</li>\n<li>类型指针：对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>\n</ul>\n</li>\n<li>实例数据：对象真正存储的有效信息，程序中所定义的各种类型的字段内容</li>\n<li>对齐填充：仅仅起占位作用，因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</li>\n</ul>\n</li>\n<li><p>对象的内存访问：通过栈上的reference数据来操作堆上的具体对象，对象的访问方式有虚拟机实现而定，主要有以下几种</p>\n<ul>\n<li><p>句柄：如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息（reference中存储的是稳定的句柄地址，对象被移动只会改变句柄中的实例数据指针，reference本身不需要修改）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152905643.png\" alt=\"image-20230731152905643\"></p>\n</li>\n<li><p>直接指针：如果使用直接指针访问，reference 中存储的直接就是对象的地址（速度快，节省了一次指针定位的时间开销）</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731152922299.png\" alt=\"image-20230731152922299\"></p>\n</li>\n</ul>\n</li>\n<li><p>HostSpot VM的实现，里面的GC主要有两类</p>\n<ul>\n<li>Partial GC：并不收集整个GC堆的模式<ul>\n<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集</li>\n<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集，知有CMS和concurrent collection有这个模式</li>\n<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集，只有G1有这个模式</li>\n</ul>\n</li>\n<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区</li>\n</ul>\n</li>\n</ul>\n</li>\n<li></li>\n</ol>\n","text":"JVM1.编译执行 如何实现跨平台：通过不同平台的JVM实现来将相同的一个Class文件翻译成适配不同机器的机器语言用于执行，即使打包成可还行文件仍需要JVM的支持 Java程序的执行过程 JAVA源代码编译成字节码；字节码校验并把JAVA程序通过类加载器加载到JVM内存中，在加...","link":"","photos":[],"count_time":{"symbolsCount":"31k","symbolsTime":"29 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM\"><span class=\"toc-text\">JVM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">1.编译执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">2.类加载器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F\"><span class=\"toc-text\">3.Java内存区域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">4.垃圾回收</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AE%9E%E6%88%98%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">5.实战调优</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95\"><span class=\"toc-text\">附录</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Internet","uid":"f00c07cb09e8c5144602456ae7f0f75a","slug":"Internet","date":"2023-08-02T14:26:24.000Z","updated":"2023-09-26T05:28:42.290Z","comments":true,"path":"api/articles/Internet.json","keywords":null,"cover":[],"text":"Internet1.网络层 IP 查看IP地址：ifconfig、ip addr scope：如果是global，则此张网卡是可以对外开放的，可以接受各个地方的包；对于lo来说事host，说明这张网卡仅仅可以供本机相互通信 lo全称是loopback，又称环回接口，往往会被分配到...","link":"","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"31 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Linux","uid":"3fe1ee3f3830128bf539e5f4ed9fbbe9","slug":"Linux","date":"2023-05-11T11:26:21.000Z","updated":"2023-09-24T08:47:53.012Z","comments":true,"path":"api/articles/Linux.json","keywords":null,"cover":[],"text":"Linux1.进程管理 概念 fd在系统中有限制吗？可以无限申请吗：通过ulimit -n来显示当前进程的文件描述符限制数量，通过编辑或创建/etc/security/limits.conf文件来调整文件描述符限制，不可以无限申请而是需要满足系统资源限制 进程：进程是资源调度的基...","link":"","photos":[],"count_time":{"symbolsCount":"25k","symbolsTime":"22 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}