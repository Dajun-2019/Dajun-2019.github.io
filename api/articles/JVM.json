{"title":"JVM","uid":"0b1381c4a63c09e41167c5168339035a","slug":"JVM","date":"2023-07-30T02:35:00.000Z","updated":"2023-07-31T06:45:28.821Z","comments":true,"path":"api/articles/JVM.json","keywords":null,"cover":[],"content":"<h1 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h1><h2 id=\"1-编译执行\"><a href=\"#1-编译执行\" class=\"headerlink\" title=\"1.编译执行\"></a>1.编译执行</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如何实现跨平台：通过不同平台的JVM实现来将相同的一个Class文件翻译成适配不同机器的机器语言用于执行，即使打包成可还行文件仍需要JVM的支持</p></blockquote>\n<ol>\n<li><p>Java程序的执行过程</p>\n<ul>\n<li>JAVA源代码编译成字节码；字节码校验并把JAVA程序通过类加载器加载到JVM内存中，在加载到内存后针对每个类创建Class对象并放到方法区；字节码指令和数据初始化到内存中；</li>\n<li>找到main方法，并创建栈帧；初始化程序计数器内部的值为main方法的内存地址；</li>\n<li>程序计数器不断递增，逐条执行JAVA字节码指令，把指令执行过程的数据存放到操作数栈中（入栈），执行完成后从操作数栈取出后放到局部变量表中，遇到创建对象，则在堆内存中分配一段连续的空间存储对象，栈内存中的局部变量表存放指向堆内存的引用；遇到方法调用则再创建一个栈帧，压到当前栈帧的上面。</li>\n</ul>\n</li>\n<li><p>编译链接：前端编译、类加载、解释执行、JIT编译执行</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731142827084.png\" alt=\"image-20230731142827084\"></p>\n<ul>\n<li><p>前端编译：将<code>.java</code>文件编译成<code>.class</code>文件，由javac编译器来完成，通过词法分析、语法分析、语义分析等方法将源代码翻译成字节码，并且还包括特有的注解处理、解语法糖操作</p>\n<ul>\n<li><p>注解处理：JDK6开始，可以开发注解插件，前端编译会调用注解插件如Lombok根据<code>@getter</code>、<code>@setter</code>为类的变量生成方法</p>\n</li>\n<li><p>解语法糖：Java一开始就注重开发效率，所以Java很适合做业务系统开发，C/C++更适合做底层的系统级开发，为了提高效率，通过对基本语法进行二次封装，来提高易用性，在前端编译的时候会还原为基本语法</p>\n<ul>\n<li><p>泛型：类型擦除，只用于编译时的类型检查</p>\n</li>\n<li><p>自动拆装箱：方便基本类型和包装类的互相转换，底层使用valueof、xxxvalue实现</p>\n</li>\n<li><p>for-each循环：底层依赖迭代器遍历</p>\n</li>\n<li><p>匿名内部类：单独生成一个class文件，名字由JVM指定如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class A&#123;&#x2F;&#x2F;A.class\n  public class B&#123;&#125;&#x2F;&#x2F;内部类，编译为A$B.class\n  public void f()&#123;\n    Thread t1 &#x3D; new Thread(new Runnable()&#123;&#x2F;&#x2F;匿名内部类，编译为A$1.class\n      @Override\n      public void run()&#123;\n        System.out.println(&quot;anonymous inner class.&quot;);\n      &#125;\n    &#125;);\n  &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类加载</p>\n<ul>\n<li>在Java应用中，类的字节码是按需加载到内存中的，当第一次创建某个类的对象，或调用某个类的方法时，会将这个类加载到内存中，之后便一直保存在内存中</li>\n<li>类加载过程包括验证、准备、解析、初始化等步骤，类的加载遵从双亲委派机制，不同的类有不同的classLoader加载器来加载</li>\n</ul>\n</li>\n<li><p>解释执行</p>\n<ul>\n<li>对于C/C++，代码会被事先编译出机器指令（可执行文件），然后再交由CPU来执行；对于Java来说，编译出的.class文件，需要由JVM逐条取出，边解释为机器码，边交由CPU执行</li>\n<li>比如说在使用Demo类对象的创建语句时，如果内存中没有Demo类的字节码信息，会通过类加载器在classpath对应的路径下查找Demo.class，并将其加载到内存中，后续虚拟机根据对象demo中的类指针，找到内存中的Demo类，然后在类的方法中找函数对应的字节码，逐句解释执行</li>\n</ul>\n</li>\n<li><p>JIT编译执行</p>\n<ul>\n<li>解释执行的效率比较低，所以引入JIT（Just-In-Time）编译执行，对于一些热点代码，可以将其编译为机器码并存储下来，跳过解释执行</li>\n<li>AOT（Ahead Of Time Compile）编译，运行前编译，类似于C/C++的编译（移植性由程序员来运行），但是仍支持一次编写，到处运行的特点，代码的可移植性有AOT编译器来负责</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>JIT编译：JIT编译器及JVM运行模式（Client、Server）、分层编译（解释执行、不带/部分/所有编译优化的Client、Server）、热点探测（优化的对象是方法方法，调用计数器、回边计数器、阈值、调用计数器的热度衰减机制）</p>\n<ul>\n<li>JIT编译器<ul>\n<li>HotSpot支持两种JIT编译器<ul>\n<li>Client编译器（C1编译器）：只进行局部的编译优化，编译时间短，编译优化程度低</li>\n<li>Server编译器（C2编译器）：进行局部和全局优化，编译时间长，编译优化程度高</li>\n</ul>\n</li>\n<li>有两种JIT编译器引出JVM有两种运行模式，Client模式和Server模式，对于长时间运行的服务器程序，可以使用Server模式</li>\n</ul>\n</li>\n<li>分层编译<ul>\n<li>Java7之前只能通过参数指定，但是Java7引入了分层编译的技术，JVM可以根据代码、运行情况来选择不同的编译类型，主要分为5个层级（见下），Java8开始默认开启分层编译技术，关闭时直接使用Server编译器<ul>\n<li>解释执行</li>\n<li>使用不带编译优化的Client编译器</li>\n<li>使用仅带部分编译优化的Client编译器</li>\n<li>使用带有所有编译优化的Client编译器</li>\n<li>使用Server编译器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>热点探测<ul>\n<li>热点代码：主要包括被多次执行的方法和被多次执行的循环，JIT编译的对象是方法，对循环的编译是循环编译循环所在方法</li>\n<li>计数器：HotSpot使用计数器来统计方法或循环的执行次数，分别为方法调用计数器（方法的执行次数）和回边计数器（方法内循环的执行次数）</li>\n<li>阈值：调用计数器和回边计数器的总和超过阈值，JVM就会进行JIT编译<ul>\n<li>Client编译器：1500</li>\n<li>Server编译器：10000</li>\n<li>分层编译：动态阈值，根据当前编译方法数以及编译线程数动态计算得到</li>\n</ul>\n</li>\n<li>热度衰减机制：防止因为运行时间长而超过阈值的代码被判定为成热点代码，此机制（通过<code>-XX:-UseCounterDecay</code>开关）在超过一定的时间（通过<code>-XX:CounterHalfLifeTIme</code>设置）限制之后，如果某个方法没有达到触发JIT编译的阈值要求，那么这个方法的方法计数器的值就减半，回边计数器不存在此机制</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>编译优化：JIT编译优化策略（方法内联、逃逸分析、无用代码消除、循环展开、消除公共子表达式、范围检查消除、空值检查消除）</p>\n<ul>\n<li>减少无效、冗余代码，以便生成高效的机器码</li>\n<li>JIT编译优化策略<ul>\n<li>方法内联：达到阈值的方法嵌入、final方法触发内联<ul>\n<li>将短小的函数嵌入到函数调用处，通过内存的增加减少时间的消耗</li>\n<li>内联要求：<ul>\n<li>函数短小（字节码小于325字节）+调用次数（大于等于100次）</li>\n<li>字节码（小于35字节）+方法调用次数（少于100次）</li>\n</ul>\n</li>\n<li>final：final方法会触发方法内联，特别是多态的情况下，因为final声明的函数不会被重载，所以可以直接通过类的方法来内联，而不用分析是否有重载变化函数的情况</li>\n</ul>\n</li>\n<li>逃逸分析：栈上分配（将对象分配到栈上）、标量替换（使用基本类型替换对象的成员变量）、锁消除（去掉无多线程并发访问的代码）<ul>\n<li>JIT编译器通过分析对象的使用范围来优化对象的内存存储方式和访问方式，针对不同的逃逸分析结果，有三种策略<ul>\n<li>栈上分配：编译器分析完，发现某个对象使用范围仅限于某个函数内部（没有逃逸到方法外），就可以启动栈上分配编译优化，将对象作为局部变量直接分配在栈上</li>\n<li>标量替换：如果某个对象只在某个函数内使用，并且函数内只访问对象的基本类型成员变量等标量数据，就可以使用基本类型变量替代对象</li>\n<li>锁消除：对不存在多线程并发访问的代码（逃逸到线程外），编译器会去掉其中保证线程安全的加锁逻辑</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类文件（class文件）结构详解</p>\n<ul>\n<li><p>class文件由ClassFile结构定义，类似于C语言的结构体</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ClassFile &#123;\n    u4             magic; &#x2F;&#x2F;Class 文件的标志，确定这个文件是否是一个能被虚拟机接收的class文件\n    u2             minor_version;&#x2F;&#x2F;Class 的小版本号\n    u2             major_version;&#x2F;&#x2F;Class 的大版本号\n    u2             constant_pool_count;&#x2F;&#x2F;常量池的数量\n    cp_info        constant_pool[constant_pool_count-1];&#x2F;&#x2F;常量池，计数器从1开始，0项代表不引用任何一个常量池选项\n    u2             access_flags;&#x2F;&#x2F;Class 的访问标记，标识class是类还是接口，是否为public或者abstract，是否声明final\n    u2             this_class;&#x2F;&#x2F;当前类\n    u2             super_class;&#x2F;&#x2F;父类 Object的父类索引为0\n    u2             interfaces_count;&#x2F;&#x2F;接口\n    u2             interfaces[interfaces_count];&#x2F;&#x2F;一个类可以实现多个接口\n    u2             fields_count;&#x2F;&#x2F;Class 文件的字段属性\n\n\t\t&#x2F;&#x2F;字段作用域、字段的名称、字段和方法的描述符、字段的额外属性、具体属性具体内容\n    field_info     fields[fields_count];&#x2F;&#x2F;一个类可以有多个字段，用于描述接口或类中声明的变量\n    u2             methods_count;&#x2F;&#x2F;Class 文件的方法数量\n\n\t\t&#x2F;&#x2F;方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项\n    method_info    methods[methods_count];&#x2F;&#x2F;一个类可以有个多个方法\n    u2             attributes_count;&#x2F;&#x2F;此类的属性表中的属性数\n    attribute_info attributes[attributes_count];&#x2F;&#x2F;属性表集合\n&#125;</code></pre></li>\n<li><p>示例</p>\n<p><img src=\"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/image-20230731143720818.png\" alt=\"image-20230731143720818\"></p>\n</li>\n</ul>\n</li>\n<li><p>类卸载</p>\n<ul>\n<li>卸载类需要满足 3 个要求：<ul>\n<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li>\n<li>该类没有在其他任何地方被引用</li>\n<li>该类的类加载器的实例已被 GC</li>\n</ul>\n</li>\n<li>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的</li>\n<li>JDK 自带的<code>BootstrapClassLoader</code>、<code>ExtClassLoader</code>、<code>AppClassLoader</code>负责加载 JDK 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"2-类加载器\"><a href=\"#2-类加载器\" class=\"headerlink\" title=\"2.类加载器\"></a>2.类加载器</h2><ol>\n<li></li>\n</ol>\n<h2 id=\"3-Java内存区域\"><a href=\"#3-Java内存区域\" class=\"headerlink\" title=\"3.Java内存区域\"></a>3.Java内存区域</h2><h2 id=\"4-垃圾回收\"><a href=\"#4-垃圾回收\" class=\"headerlink\" title=\"4.垃圾回收\"></a>4.垃圾回收</h2><h2 id=\"5-实战调优\"><a href=\"#5-实战调优\" class=\"headerlink\" title=\"5.实战调优\"></a>5.实战调优</h2><h2 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h2><ol>\n<li>引用类型总结<ul>\n<li>强引用（StrongReference）：垃圾回收器不会回收他，自己抛出<code>OutOfMemoryError</code>错误</li>\n<li>软引用（SoftReference）：内存空间不够时才会回收，软引用可用来实现内存敏感的高速缓存，可以和一个引用队列联合使用，如果软引用引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中</li>\n<li>弱引用（WeakReference）：弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中</li>\n<li>虚引用（PhantomReference）：”虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收，虚引用主要用来跟踪对象被垃圾回收的活动</li>\n<li>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</li>\n</ul>\n</li>\n<li></li>\n</ol>\n","feature":true,"text":"JVM1.编译执行 如何实现跨平台：通过不同平台的JVM实现来将相同的一个Class文件翻译成适配不同机器的机器语言用于执行，即使打包成可还行文件仍需要JVM的支持 Java程序的执行过程 JAVA源代码编译成字节码；字节码校验并把JAVA程序通过类加载器加载到JVM内存中，在加...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM\"><span class=\"toc-text\">JVM</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C\"><span class=\"toc-text\">1.编译执行</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">2.类加载器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F\"><span class=\"toc-text\">3.Java内存区域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">4.垃圾回收</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%AE%9E%E6%88%98%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">5.实战调优</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%84%E5%BD%95\"><span class=\"toc-text\">附录</span></a></li></ol></li></ol>","author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Tools","uid":"7092a7d1e2affc5f0cb3af30af9d1e19","slug":"Tools","date":"2023-07-30T02:37:14.000Z","updated":"2023-07-30T08:42:12.780Z","comments":true,"path":"api/articles/Tools.json","keywords":null,"cover":[],"text":"1.markdown 框架 多级标题：#与后面文本有一个空格，标题行前后建议空行 Markdown HTML # Heading level 1 Heading level 1 ## Heading level 2 Heading level 2 ### Heading leve...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[],"tags":[],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Linux","uid":"3fe1ee3f3830128bf539e5f4ed9fbbe9","slug":"Linux","date":"2023-05-11T11:26:21.000Z","updated":"2023-07-30T08:40:57.928Z","comments":true,"path":"api/articles/Linux.json","keywords":null,"cover":[],"text":"Linux1.操作系统原理1.进程管理 概念 进程：进程是资源调度的基本单位，启动main函数就是启动一个JVM进程，main函数所在的线程是这个进程的主线程 线程：线程是CPU调度的基本单位，线程间共享堆和方法去资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈 协程：由...","link":"","photos":[],"count_time":{"symbolsCount":"34k","symbolsTime":"31 mins."},"categories":[],"tags":[{"name":"tools","slug":"tools","count":2,"path":"api/tags/tools.json"}],"author":{"name":"Dajunnnnnn","slug":"blog-author","avatar":"https://macro---oss2.oss-cn-beijing.aliyuncs.com/img/dajunnnnnn_psychedelic_eagle_neon_colors_comic_illustration_1ca2dde3-db58-4c04-b835-42e21feffbe8.PNG","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}